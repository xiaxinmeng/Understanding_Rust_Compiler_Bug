{"sha": "ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNjgyYmRhYmMzOWE3MjYxZWI1YzNkNDNiMjBiYjg0ZmFlNjRmZGU=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-02-10T16:12:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-10T16:12:38Z"}, "message": "Merge pull request #3335 from h-michael/rust-2018\n\nRust 2018 idioms", "tree": {"sha": "ea0e42f4c8e1b5dbb8721b556645e6cfd5b78a29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea0e42f4c8e1b5dbb8721b556645e6cfd5b78a29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcYE12CRBK7hj4Ov3rIwAAdHIIAGiaC9r7n3OHFi0qhUrVA7op\n5W3eWRbKeZt/J4Siw9Z9IQhZxFtA5sOAAeZ980LmTO4N7RU925LNZwXaMtcnSaZQ\nHS5RHCV/sYTKQEflkuVC1HLP7bEmRz7/QmJ0ACBIE6+XxrBP9VbSRa1noDvy8Jho\nIaxp/qDnD5a5dIiL0mayYq9dc9Xi59Ph2CpzNl5cpCOOF+yeukaCMmudbhh7i66i\nXhtenBfFMmnWEetTdYeWjz/ZC5oirQYjXAJ+v24C4yPlaIi61XFfwM8DlsVO6np7\ncyHo9qDmODdR4A9Mkr8etGlWpwH1nIoFNMmTtvt24GGZpb41vKp5sF5QBAasT7w=\n=l5+/\n-----END PGP SIGNATURE-----\n", "payload": "tree ea0e42f4c8e1b5dbb8721b556645e6cfd5b78a29\nparent fca91bc22f40aaf8e8fc949313b8f5b9c9ac90cc\nparent 8183b949c49cfdd5889859162e82fab4c8e64065\nauthor Seiichi Uchida <seuchida@gmail.com> 1549815158 +0900\ncommitter GitHub <noreply@github.com> 1549815158 +0900\n\nMerge pull request #3335 from h-michael/rust-2018\n\nRust 2018 idioms"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "html_url": "https://github.com/rust-lang/rust/commit/ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fca91bc22f40aaf8e8fc949313b8f5b9c9ac90cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca91bc22f40aaf8e8fc949313b8f5b9c9ac90cc", "html_url": "https://github.com/rust-lang/rust/commit/fca91bc22f40aaf8e8fc949313b8f5b9c9ac90cc"}, {"sha": "8183b949c49cfdd5889859162e82fab4c8e64065", "url": "https://api.github.com/repos/rust-lang/rust/commits/8183b949c49cfdd5889859162e82fab4c8e64065", "html_url": "https://github.com/rust-lang/rust/commit/8183b949c49cfdd5889859162e82fab4c8e64065"}], "stats": {"total": 682, "additions": 353, "deletions": 329}, "files": [{"sha": "89b0367c4846140a29df32fbec2e0db31dc287c7", "filename": "src/attr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattr.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -75,7 +75,7 @@ fn argument_shape(\n     right: usize,\n     combine: bool,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<Shape> {\n     match context.config.indent_style() {\n         IndentStyle::Block => {\n@@ -100,7 +100,7 @@ fn format_derive(\n     derive_args: &[Span],\n     prefix: &str,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     let mut result = String::with_capacity(128);\n     result.push_str(prefix);\n@@ -133,7 +133,7 @@ fn format_derive(\n /// Returns the first group of attributes that fills the given predicate.\n /// We consider two doc comments are in different group if they are separated by normal comments.\n fn take_while_with_pred<'a, P>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     attrs: &'a [ast::Attribute],\n     pred: P,\n ) -> &'a [ast::Attribute]\n@@ -164,7 +164,7 @@ where\n \n /// Rewrite the any doc comments which come before any other attributes.\n fn rewrite_initial_doc_comments(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     attrs: &[ast::Attribute],\n     shape: Shape,\n ) -> Option<(usize, Option<String>)> {\n@@ -193,7 +193,7 @@ fn rewrite_initial_doc_comments(\n }\n \n impl Rewrite for ast::NestedMetaItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self.node {\n             ast::NestedMetaItemKind::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n             ast::NestedMetaItemKind::Literal(ref l) => rewrite_literal(context, l, shape),\n@@ -221,7 +221,7 @@ fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n }\n \n impl Rewrite for ast::MetaItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         Some(match self.node {\n             ast::MetaItemKind::Word => {\n                 rewrite_path(context, PathContext::Type, None, &self.ident, shape)?\n@@ -268,7 +268,7 @@ fn format_arg_list<I, T, F1, F2, F3>(\n     get_hi: F2,\n     get_item_string: F3,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     one_line_shape: Shape,\n     one_line_limit: Option<usize>,\n@@ -318,7 +318,7 @@ where\n }\n \n impl Rewrite for ast::Attribute {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let snippet = context.snippet(self.span);\n         if self.is_sugared_doc {\n             rewrite_doc_comment(snippet, shape.comment(context.config), context.config)\n@@ -365,7 +365,7 @@ impl Rewrite for ast::Attribute {\n }\n \n impl<'a> Rewrite for [ast::Attribute] {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         if self.is_empty() {\n             return Some(String::new());\n         }"}, {"sha": "b357eed34cf3d6c5e8fa3173ff10d6ae0dec5352", "filename": "src/bin/main.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate env_logger;\n+use env_logger;\n #[macro_use]\n extern crate failure;\n-extern crate getopts;\n-extern crate rustfmt_nightly as rustfmt;\n+\n+use rustfmt_nightly as rustfmt;\n \n use std::env;\n use std::fs::File;\n@@ -296,7 +296,7 @@ fn format(\n     Ok(exit_code)\n }\n \n-fn format_and_emit_report<T: Write>(session: &mut Session<T>, input: Input) {\n+fn format_and_emit_report<T: Write>(session: &mut Session<'_, T>, input: Input) {\n     match session.format(input) {\n         Ok(report) => {\n             if report.has_warnings() {"}, {"sha": "3873671781cf6483dd16a25475b68756d419fc32", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -13,9 +13,8 @@\n #![cfg(not(test))]\n #![deny(warnings)]\n \n-extern crate cargo_metadata;\n-extern crate getopts;\n-extern crate serde_json as json;\n+use cargo_metadata;\n+use getopts;\n \n use std::collections::{HashMap, HashSet};\n use std::env;"}, {"sha": "6686211632357117abc9720215b53fd464ee31a4", "filename": "src/chains.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -84,7 +84,11 @@ use crate::utils::{\n     trimmed_last_line_width, wrap_str,\n };\n \n-pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n+pub fn rewrite_chain(\n+    expr: &ast::Expr,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n     let chain = Chain::from_ast(expr, context);\n     debug!(\"rewrite_chain {:?} {:?}\", chain, shape);\n \n@@ -128,7 +132,7 @@ enum ChainItemKind {\n }\n \n impl ChainItemKind {\n-    fn is_block_like(&self, context: &RewriteContext, reps: &str) -> bool {\n+    fn is_block_like(&self, context: &RewriteContext<'_>, reps: &str) -> bool {\n         match self {\n             ChainItemKind::Parent(ref expr) => utils::is_block_expr(context, expr, reps),\n             ChainItemKind::MethodCall(..)\n@@ -147,7 +151,7 @@ impl ChainItemKind {\n         }\n     }\n \n-    fn from_ast(context: &RewriteContext, expr: &ast::Expr) -> (ChainItemKind, Span) {\n+    fn from_ast(context: &RewriteContext<'_>, expr: &ast::Expr) -> (ChainItemKind, Span) {\n         let (kind, span) = match expr.node {\n             ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n                 let types = if let Some(ref generic_args) = segment.args {\n@@ -182,7 +186,7 @@ impl ChainItemKind {\n }\n \n impl Rewrite for ChainItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let shape = shape.sub_width(self.tries)?;\n         let rewrite = match self.kind {\n             ChainItemKind::Parent(ref expr) => expr.rewrite(context, shape)?,\n@@ -204,7 +208,7 @@ impl Rewrite for ChainItem {\n }\n \n impl ChainItem {\n-    fn new(context: &RewriteContext, expr: &ast::Expr, tries: usize) -> ChainItem {\n+    fn new(context: &RewriteContext<'_>, expr: &ast::Expr, tries: usize) -> ChainItem {\n         let (kind, span) = ChainItemKind::from_ast(context, expr);\n         ChainItem { kind, tries, span }\n     }\n@@ -229,7 +233,7 @@ impl ChainItem {\n         types: &[ast::GenericArg],\n         args: &[ptr::P<ast::Expr>],\n         span: Span,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n     ) -> Option<String> {\n         let type_str = if types.is_empty() {\n@@ -254,7 +258,7 @@ struct Chain {\n }\n \n impl Chain {\n-    fn from_ast(expr: &ast::Expr, context: &RewriteContext) -> Chain {\n+    fn from_ast(expr: &ast::Expr, context: &RewriteContext<'_>) -> Chain {\n         let subexpr_list = Self::make_subexpr_list(expr, context);\n \n         // Un-parse the expression tree into ChainItems\n@@ -376,7 +380,7 @@ impl Chain {\n \n     // Returns a Vec of the prefixes of the chain.\n     // E.g., for input `a.b.c` we return [`a.b.c`, `a.b`, 'a']\n-    fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> Vec<ast::Expr> {\n+    fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext<'_>) -> Vec<ast::Expr> {\n         let mut subexpr_list = vec![expr.clone()];\n \n         while let Some(subexpr) = Self::pop_expr_chain(subexpr_list.last().unwrap(), context) {\n@@ -388,7 +392,7 @@ impl Chain {\n \n     // Returns the expression's subexpression, if it exists. When the subexpr\n     // is a try! macro, we'll convert it to shorthand when the option is set.\n-    fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n+    fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n         match expr.node {\n             ast::ExprKind::MethodCall(_, ref expressions) => {\n                 Some(Self::convert_try(&expressions[0], context))\n@@ -400,7 +404,7 @@ impl Chain {\n         }\n     }\n \n-    fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n+    fn convert_try(expr: &ast::Expr, context: &RewriteContext<'_>) -> ast::Expr {\n         match expr.node {\n             ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n                 if let Some(subexpr) = convert_try_mac(mac, context) {\n@@ -415,12 +419,16 @@ impl Chain {\n }\n \n impl Rewrite for Chain {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         debug!(\"rewrite chain {:?} {:?}\", self, shape);\n \n         let mut formatter = match context.config.indent_style() {\n-            IndentStyle::Block => Box::new(ChainFormatterBlock::new(self)) as Box<ChainFormatter>,\n-            IndentStyle::Visual => Box::new(ChainFormatterVisual::new(self)) as Box<ChainFormatter>,\n+            IndentStyle::Block => {\n+                Box::new(ChainFormatterBlock::new(self)) as Box<dyn ChainFormatter>\n+            }\n+            IndentStyle::Visual => {\n+                Box::new(ChainFormatterVisual::new(self)) as Box<dyn ChainFormatter>\n+            }\n         };\n \n         formatter.format_root(&self.parent, context, shape)?;\n@@ -455,18 +463,18 @@ trait ChainFormatter {\n     fn format_root(\n         &mut self,\n         parent: &ChainItem,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n     ) -> Option<()>;\n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape>;\n-    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()>;\n+    fn child_shape(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<Shape>;\n+    fn format_children(&mut self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<()>;\n     fn format_last_child(\n         &mut self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         child_shape: Shape,\n     ) -> Option<()>;\n-    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String>;\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String>;\n     // Returns `Some` if the chain is only a root, None otherwise.\n     fn pure_root(&mut self) -> Option<String>;\n }\n@@ -540,7 +548,7 @@ impl<'a> ChainFormatterShared<'a> {\n     fn format_last_child(\n         &mut self,\n         may_extend: bool,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         child_shape: Shape,\n     ) -> Option<()> {\n@@ -633,7 +641,7 @@ impl<'a> ChainFormatterShared<'a> {\n         Some(())\n     }\n \n-    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String> {\n         let connector = if self.fits_single_line {\n             // Yay, we can put everything on one line.\n             Cow::from(\"\")\n@@ -682,7 +690,7 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n     fn format_root(\n         &mut self,\n         parent: &ChainItem,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n     ) -> Option<()> {\n         let mut root_rewrite: String = parent.rewrite(context, shape)?;\n@@ -713,7 +721,7 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n         Some(())\n     }\n \n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape> {\n+    fn child_shape(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<Shape> {\n         Some(\n             if self.root_ends_with_block {\n                 shape.block_indent(0)\n@@ -724,7 +732,7 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n         )\n     }\n \n-    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+    fn format_children(&mut self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<()> {\n         for item in &self.shared.children[..self.shared.children.len() - 1] {\n             let rewrite = item.rewrite(context, child_shape)?;\n             self.shared.rewrites.push(rewrite);\n@@ -734,15 +742,15 @@ impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n \n     fn format_last_child(\n         &mut self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         child_shape: Shape,\n     ) -> Option<()> {\n         self.shared\n             .format_last_child(true, context, shape, child_shape)\n     }\n \n-    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String> {\n         self.shared.join_rewrites(context, child_shape)\n     }\n \n@@ -771,7 +779,7 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n     fn format_root(\n         &mut self,\n         parent: &ChainItem,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n     ) -> Option<()> {\n         let parent_shape = shape.visual_indent(0);\n@@ -811,14 +819,14 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n         Some(())\n     }\n \n-    fn child_shape(&self, context: &RewriteContext, shape: Shape) -> Option<Shape> {\n+    fn child_shape(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<Shape> {\n         shape\n             .with_max_width(context.config)\n             .offset_left(self.offset)\n             .map(|s| s.visual_indent(0))\n     }\n \n-    fn format_children(&mut self, context: &RewriteContext, child_shape: Shape) -> Option<()> {\n+    fn format_children(&mut self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<()> {\n         for item in &self.shared.children[..self.shared.children.len() - 1] {\n             let rewrite = item.rewrite(context, child_shape)?;\n             self.shared.rewrites.push(rewrite);\n@@ -828,15 +836,15 @@ impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n \n     fn format_last_child(\n         &mut self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         child_shape: Shape,\n     ) -> Option<()> {\n         self.shared\n             .format_last_child(false, context, shape, child_shape)\n     }\n \n-    fn join_rewrites(&self, context: &RewriteContext, child_shape: Shape) -> Option<String> {\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String> {\n         self.shared.join_rewrites(context, child_shape)\n     }\n "}, {"sha": "4924c8628f55657906ea225fc3742ef0b4adb2c7", "filename": "src/closures.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -39,7 +39,7 @@ pub fn rewrite_closure(\n     fn_decl: &ast::FnDecl,\n     body: &ast::Expr,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     debug!(\"rewrite_closure {:?}\", body);\n@@ -81,7 +81,7 @@ pub fn rewrite_closure(\n fn try_rewrite_without_block(\n     expr: &ast::Expr,\n     prefix: &str,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     body_shape: Shape,\n ) -> Option<String> {\n@@ -97,7 +97,7 @@ fn try_rewrite_without_block(\n fn get_inner_expr<'a>(\n     expr: &'a ast::Expr,\n     prefix: &str,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> &'a ast::Expr {\n     if let ast::ExprKind::Block(ref block, _) = expr.node {\n         if !needs_block(block, prefix, context) {\n@@ -112,7 +112,7 @@ fn get_inner_expr<'a>(\n }\n \n // Figure out if a block is necessary.\n-fn needs_block(block: &ast::Block, prefix: &str, context: &RewriteContext) -> bool {\n+fn needs_block(block: &ast::Block, prefix: &str, context: &RewriteContext<'_>) -> bool {\n     is_unsafe_block(block)\n         || block.stmts.len() > 1\n         || block_contains_comment(block, context.source_map)\n@@ -139,7 +139,7 @@ fn veto_block(e: &ast::Expr) -> bool {\n fn rewrite_closure_with_block(\n     body: &ast::Expr,\n     prefix: &str,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     let left_most = left_most_sub_expr(body);\n@@ -167,7 +167,7 @@ fn rewrite_closure_with_block(\n fn rewrite_closure_expr(\n     expr: &ast::Expr,\n     prefix: &str,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     fn allow_multi_line(expr: &ast::Expr) -> bool {\n@@ -207,7 +207,7 @@ fn rewrite_closure_expr(\n fn rewrite_closure_block(\n     block: &ast::Block,\n     prefix: &str,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     Some(format!(\"{} {}\", prefix, block.rewrite(context, shape)?))\n@@ -221,7 +221,7 @@ fn rewrite_closure_fn_decl(\n     fn_decl: &ast::FnDecl,\n     body: &ast::Expr,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<(String, usize)> {\n     let is_async = if asyncness.is_async() { \"async \" } else { \"\" };\n@@ -296,7 +296,7 @@ fn rewrite_closure_fn_decl(\n // Rewriting closure which is placed at the end of the function call's arg.\n // Returns `None` if the reformatted closure 'looks bad'.\n pub fn rewrite_last_closure(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     expr: &ast::Expr,\n     shape: Shape,\n ) -> Option<String> {\n@@ -360,7 +360,7 @@ pub fn rewrite_last_closure(\n }\n \n /// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n-pub fn args_have_many_closure(args: &[OverflowableItem]) -> bool {\n+pub fn args_have_many_closure(args: &[OverflowableItem<'_>]) -> bool {\n     args.iter()\n         .filter_map(|arg| arg.to_expr())\n         .filter(|expr| match expr.node {\n@@ -371,7 +371,7 @@ pub fn args_have_many_closure(args: &[OverflowableItem]) -> bool {\n         > 1\n }\n \n-fn is_block_closure_forced(context: &RewriteContext, expr: &ast::Expr) -> bool {\n+fn is_block_closure_forced(context: &RewriteContext<'_>, expr: &ast::Expr) -> bool {\n     // If we are inside macro, we do not want to add or remove block from closure body.\n     if context.inside_macro() {\n         false"}, {"sha": "d9d367fa3530ce67fe2cf7b66fa296a8166a1c54", "filename": "src/comment.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -122,7 +122,7 @@ impl<'a> CommentStyle<'a> {\n     }\n }\n \n-fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n+fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle<'_> {\n     if !normalize_comments {\n         if orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\") {\n             CommentStyle::DoubleBullet\n@@ -158,7 +158,7 @@ fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle {\n /// strings, then they will be put on a single line as long as doing so does not\n /// exceed max width.\n pub fn combine_strs_with_missing_comments(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     prev_str: &str,\n     next_str: &str,\n     span: Span,\n@@ -286,7 +286,7 @@ fn identify_comment(\n     // - a boolean indicating if there is a blank line\n     // - a number indicating the size of the first group of comments\n     fn consume_same_line_comments(\n-        style: CommentStyle,\n+        style: CommentStyle<'_>,\n         orig: &str,\n         line_start: &str,\n     ) -> (bool, usize) {\n@@ -459,7 +459,7 @@ impl ItemizedBlock {\n     }\n \n     /// Returns a `StringFormat` used for formatting the content of an item\n-    fn create_string_format<'a>(&'a self, fmt: &'a StringFormat) -> StringFormat<'a> {\n+    fn create_string_format<'a>(&'a self, fmt: &'a StringFormat<'_>) -> StringFormat<'a> {\n         StringFormat {\n             opener: \"\",\n             closer: \"\",\n@@ -777,7 +777,7 @@ impl<'a> CommentRewrite<'a> {\n fn rewrite_comment_inner(\n     orig: &str,\n     block_style: bool,\n-    style: CommentStyle,\n+    style: CommentStyle<'_>,\n     shape: Shape,\n     config: &Config,\n     is_doc_comment: bool,\n@@ -820,7 +820,7 @@ fn rewrite_comment_inner(\n \n const RUSTFMT_CUSTOM_COMMENT_PREFIX: &str = \"//#### \";\n \n-fn hide_sharp_behind_comment(s: &str) -> Cow<str> {\n+fn hide_sharp_behind_comment(s: &str) -> Cow<'_, str> {\n     if s.trim_start().starts_with(\"# \") {\n         Cow::from(format!(\"{}{}\", RUSTFMT_CUSTOM_COMMENT_PREFIX, s))\n     } else {\n@@ -853,7 +853,7 @@ fn has_url(s: &str) -> bool {\n pub fn rewrite_missing_comment(\n     span: Span,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     let missing_snippet = context.snippet(span);\n     let trimmed_snippet = missing_snippet.trim();\n@@ -870,7 +870,7 @@ pub fn rewrite_missing_comment(\n pub fn recover_missing_comment_in_span(\n     span: Span,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     used_width: usize,\n ) -> Option<String> {\n     let missing_comment = rewrite_missing_comment(span, shape, context)?;\n@@ -934,7 +934,7 @@ fn light_rewrite_comment(\n /// Trims comment characters and possibly a single space from the left of a string.\n /// Does not trim all whitespace. If a single space is trimmed from the left of the string,\n /// this function returns true.\n-fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle) -> (&'a str, bool) {\n+fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle<'_>) -> (&'a str, bool) {\n     if line.starts_with(\"//! \")\n         || line.starts_with(\"/// \")\n         || line.starts_with(\"/*! \")\n@@ -1544,7 +1544,7 @@ impl<'a> Iterator for CommentCodeSlices<'a> {\n pub fn recover_comment_removed(\n     new: String,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     let snippet = context.snippet(span);\n     if snippet != new && changed_comment_content(snippet, &new) {"}, {"sha": "08d086c668e18fde117fef5ffb7d5fd58b7eec5d", "filename": "src/config/config_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fconfig_type.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -173,11 +173,11 @@ macro_rules! create_config {\n             }\n             )+\n \n-            pub fn set(&mut self) -> ConfigSetter {\n+            pub fn set(&mut self) -> ConfigSetter<'_> {\n                 ConfigSetter(self)\n             }\n \n-            pub fn was_set(&self) -> ConfigWasSet {\n+            pub fn was_set(&self) -> ConfigWasSet<'_> {\n                 ConfigWasSet(self)\n             }\n \n@@ -379,7 +379,7 @@ macro_rules! create_config {\n                 HIDE_OPTIONS.contains(&name)\n             }\n \n-            pub fn print_docs(out: &mut Write, include_unstable: bool) {\n+            pub fn print_docs(out: &mut dyn Write, include_unstable: bool) {\n                 use std::cmp;\n                 let max = 0;\n                 $( let max = cmp::max(max, stringify!($i).len()+1); )+"}, {"sha": "a7371a3da90ee401d703d32ff518e755951818a4", "filename": "src/config/file_lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Ffile_lines.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -46,7 +46,7 @@ impl From<source_map::FileName> for FileName {\n }\n \n impl fmt::Display for FileName {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             FileName::Real(p) => write!(f, \"{}\", p.to_str().unwrap()),\n             FileName::Stdin => write!(f, \"stdin\"),\n@@ -202,7 +202,7 @@ impl FileLines {\n     }\n \n     /// Returns an iterator over the files contained in `self`.\n-    pub fn files(&self) -> Files {\n+    pub fn files(&self) -> Files<'_> {\n         Files(self.0.as_ref().map(|m| m.keys()))\n     }\n "}, {"sha": "38e375084505297043c831fa612602ae4a39d739", "filename": "src/config/license.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Flicense.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -14,7 +14,7 @@ pub enum LicenseError {\n }\n \n impl fmt::Display for LicenseError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             LicenseError::IO(ref err) => err.fmt(f),\n             LicenseError::Regex(ref err) => err.fmt(f),"}, {"sha": "e51279018e21a1ad0cb7159f9742c2ae53884a96", "filename": "src/config/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -208,7 +208,7 @@ fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n     Ok(None)\n }\n \n-fn config_path(options: &CliOptions) -> Result<Option<PathBuf>, Error> {\n+fn config_path(options: &dyn CliOptions) -> Result<Option<PathBuf>, Error> {\n     let config_path_not_found = |path: &str| -> Result<Option<PathBuf>, Error> {\n         Err(Error::new(\n             ErrorKind::NotFound,"}, {"sha": "f167c34aedf2b2e7afa79a51e4a9465264b30c93", "filename": "src/config/options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -64,7 +64,7 @@ macro_rules! impl_enum_serialize_and_deserialize {\n                 impl<'de, T> Visitor<'de> for StringOnly<T>\n                         where T: ::serde::Deserializer<'de> {\n                     type Value = String;\n-                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n                         formatter.write_str(\"string\")\n                     }\n                     fn visit_str<E>(self, value: &str) -> Result<String, E> {\n@@ -120,7 +120,7 @@ macro_rules! configuration_option_enum {\n         }\n \n         impl ::std::fmt::Debug for $e {\n-            fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n                 f.write_str(match self {\n                     $(\n                         $e::$name => configuration_option_enum_stringify!($name $(: $value)*),"}, {"sha": "5b59a5114b513cd8a2ecf8624a53d7625009a2c7", "filename": "src/expr.rs", "status": "modified", "additions": 54, "deletions": 46, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -47,7 +47,7 @@ use crate::vertical::rewrite_with_alignment;\n use crate::visitor::FmtVisitor;\n \n impl Rewrite for ast::Expr {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         format_expr(self, ExprType::SubExpression, context, shape)\n     }\n }\n@@ -61,7 +61,7 @@ pub enum ExprType {\n pub fn format_expr(\n     expr: &ast::Expr,\n     expr_type: ExprType,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     skip_out_of_file_lines_range!(context, expr.span);\n@@ -249,7 +249,7 @@ pub fn format_expr(\n                 ast::RangeLimits::Closed => \"..=\",\n             };\n \n-            fn needs_space_before_range(context: &RewriteContext, lhs: &ast::Expr) -> bool {\n+            fn needs_space_before_range(context: &RewriteContext<'_>, lhs: &ast::Expr) -> bool {\n                 match lhs.node {\n                     ast::ExprKind::Lit(ref lit) => match lit.node {\n                         ast::LitKind::FloatUnsuffixed(..) => {\n@@ -399,7 +399,7 @@ pub fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n     name: &'a str,\n     exprs: impl Iterator<Item = &'a T>,\n     span: Span,\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     shape: Shape,\n     force_separator_tactic: Option<SeparatorTactic>,\n     delim_token: Option<DelimToken>,\n@@ -416,7 +416,7 @@ pub fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n }\n \n fn rewrite_empty_block(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n     label: Option<ast::Label>,\n@@ -453,7 +453,7 @@ fn rewrite_empty_block(\n     None\n }\n \n-fn block_prefix(context: &RewriteContext, block: &ast::Block, shape: Shape) -> Option<String> {\n+fn block_prefix(context: &RewriteContext<'_>, block: &ast::Block, shape: Shape) -> Option<String> {\n     Some(match block.rules {\n         ast::BlockCheckMode::Unsafe(..) => {\n             let snippet = context.snippet(block.span);\n@@ -482,7 +482,7 @@ fn block_prefix(context: &RewriteContext, block: &ast::Block, shape: Shape) -> O\n }\n \n fn rewrite_single_line_block(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     prefix: &str,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n@@ -502,7 +502,7 @@ fn rewrite_single_line_block(\n }\n \n pub fn rewrite_block_with_visitor(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     prefix: &str,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n@@ -533,7 +533,7 @@ pub fn rewrite_block_with_visitor(\n }\n \n impl Rewrite for ast::Block {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         rewrite_block(self, None, None, context, shape)\n     }\n }\n@@ -542,7 +542,7 @@ fn rewrite_block(\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n     label: Option<ast::Label>,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     let prefix = block_prefix(context, block, shape)?;\n@@ -568,7 +568,7 @@ fn rewrite_block(\n }\n \n impl Rewrite for ast::Stmt {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         skip_out_of_file_lines_range!(context, self.span());\n \n         let result = match self.node {\n@@ -590,7 +590,11 @@ impl Rewrite for ast::Stmt {\n }\n \n // Rewrite condition if the given expression has one.\n-pub fn rewrite_cond(context: &RewriteContext, expr: &ast::Expr, shape: Shape) -> Option<String> {\n+pub fn rewrite_cond(\n+    context: &RewriteContext<'_>,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n     match expr.node {\n         ast::ExprKind::Match(ref cond, _) => {\n             // `match `cond` {`\n@@ -627,7 +631,7 @@ struct ControlFlow<'a> {\n     span: Span,\n }\n \n-fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow> {\n+fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow<'_>> {\n     match expr.node {\n         ast::ExprKind::If(ref cond, ref if_block, ref else_block) => Some(ControlFlow::new_if(\n             cond,\n@@ -767,7 +771,7 @@ impl<'a> ControlFlow<'a> {\n     fn rewrite_single_line(\n         &self,\n         pat_expr_str: &str,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         width: usize,\n     ) -> Option<String> {\n         assert!(self.allow_single_line);\n@@ -825,7 +829,7 @@ fn last_line_offsetted(start_column: usize, pat_str: &str) -> bool {\n impl<'a> ControlFlow<'a> {\n     fn rewrite_pat_expr(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         expr: &ast::Expr,\n         shape: Shape,\n         offset: usize,\n@@ -865,7 +869,7 @@ impl<'a> ControlFlow<'a> {\n \n     fn rewrite_cond(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         alt_block_sep: &str,\n     ) -> Option<(String, usize)> {\n@@ -1001,7 +1005,7 @@ impl<'a> ControlFlow<'a> {\n }\n \n impl<'a> Rewrite for ControlFlow<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n \n         let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n@@ -1126,7 +1130,7 @@ fn rewrite_label(opt_label: Option<ast::Label>) -> Cow<'static, str> {\n     }\n }\n \n-fn extract_comment(span: Span, context: &RewriteContext, shape: Shape) -> Option<String> {\n+fn extract_comment(span: Span, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n     match rewrite_missing_comment(span, shape, context) {\n         Some(ref comment) if !comment.is_empty() => Some(format!(\n             \"{indent}{}{indent}\",\n@@ -1197,7 +1201,7 @@ pub fn is_unsafe_block(block: &ast::Block) -> bool {\n }\n \n pub fn rewrite_multiple_patterns(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     pats: &[&ast::Pat],\n     shape: Shape,\n ) -> Option<String> {\n@@ -1229,7 +1233,7 @@ pub fn rewrite_multiple_patterns(\n     write_list(&items, &fmt)\n }\n \n-pub fn rewrite_literal(context: &RewriteContext, l: &ast::Lit, shape: Shape) -> Option<String> {\n+pub fn rewrite_literal(context: &RewriteContext<'_>, l: &ast::Lit, shape: Shape) -> Option<String> {\n     match l.node {\n         ast::LitKind::Str(_, ast::StrStyle::Cooked) => rewrite_string_lit(context, l.span, shape),\n         _ => wrap_str(\n@@ -1240,7 +1244,7 @@ pub fn rewrite_literal(context: &RewriteContext, l: &ast::Lit, shape: Shape) ->\n     }\n }\n \n-fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Option<String> {\n+fn rewrite_string_lit(context: &RewriteContext<'_>, span: Span, shape: Shape) -> Option<String> {\n     let string_lit = context.snippet(span);\n \n     if !context.config.format_strings() {\n@@ -1285,7 +1289,7 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     )\n }\n \n-fn choose_separator_tactic(context: &RewriteContext, span: Span) -> Option<SeparatorTactic> {\n+fn choose_separator_tactic(context: &RewriteContext<'_>, span: Span) -> Option<SeparatorTactic> {\n     if context.inside_macro() {\n         if span_ends_with_comma(context, span) {\n             Some(SeparatorTactic::Always)\n@@ -1298,7 +1302,7 @@ fn choose_separator_tactic(context: &RewriteContext, span: Span) -> Option<Separ\n }\n \n pub fn rewrite_call(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     callee: &str,\n     args: &[ptr::P<ast::Expr>],\n     span: Span,\n@@ -1333,11 +1337,15 @@ pub fn is_simple_expr(expr: &ast::Expr) -> bool {\n     }\n }\n \n-pub fn is_every_expr_simple(lists: &[OverflowableItem]) -> bool {\n+pub fn is_every_expr_simple(lists: &[OverflowableItem<'_>]) -> bool {\n     lists.iter().all(OverflowableItem::is_simple)\n }\n \n-pub fn can_be_overflowed_expr(context: &RewriteContext, expr: &ast::Expr, args_len: usize) -> bool {\n+pub fn can_be_overflowed_expr(\n+    context: &RewriteContext<'_>,\n+    expr: &ast::Expr,\n+    args_len: usize,\n+) -> bool {\n     match expr.node {\n         ast::ExprKind::Match(..) => {\n             (context.use_block_indent() && args_len == 1)\n@@ -1397,7 +1405,7 @@ pub fn is_nested_call(expr: &ast::Expr) -> bool {\n /// Return true if a function call or a method call represented by the given span ends with a\n /// trailing comma. This function is used when rewriting macro, as adding or removing a trailing\n /// comma from macro can potentially break the code.\n-pub fn span_ends_with_comma(context: &RewriteContext, span: Span) -> bool {\n+pub fn span_ends_with_comma(context: &RewriteContext<'_>, span: Span) -> bool {\n     let mut result: bool = Default::default();\n     let mut prev_char: char = Default::default();\n     let closing_delimiters = &[')', '}', ']'];\n@@ -1418,7 +1426,7 @@ pub fn span_ends_with_comma(context: &RewriteContext, span: Span) -> bool {\n }\n \n fn rewrite_paren(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     mut subexpr: &ast::Expr,\n     shape: Shape,\n     mut span: Span,\n@@ -1462,7 +1470,7 @@ fn rewrite_paren(\n }\n \n fn rewrite_paren_in_multi_line(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     subexpr: &ast::Expr,\n     shape: Shape,\n     pre_span: Span,\n@@ -1495,7 +1503,7 @@ fn rewrite_paren_in_multi_line(\n fn rewrite_index(\n     expr: &ast::Expr,\n     index: &ast::Expr,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     let expr_str = expr.rewrite(context, shape)?;\n@@ -1556,7 +1564,7 @@ fn struct_lit_can_be_aligned(fields: &[ast::Field], base: Option<&ast::Expr>) ->\n }\n \n fn rewrite_struct_lit<'a>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     path: &ast::Path,\n     fields: &'a [ast::Field],\n     base: Option<&'a ast::Expr>,\n@@ -1599,7 +1607,7 @@ fn rewrite_struct_lit<'a>(\n             .map(StructLitField::Regular)\n             .chain(base.into_iter().map(StructLitField::Base));\n \n-        let span_lo = |item: &StructLitField| match *item {\n+        let span_lo = |item: &StructLitField<'_>| match *item {\n             StructLitField::Regular(field) => field.span().lo(),\n             StructLitField::Base(expr) => {\n                 let last_field_hi = fields.last().map_or(span.lo(), |field| field.span.hi());\n@@ -1608,11 +1616,11 @@ fn rewrite_struct_lit<'a>(\n                 last_field_hi + BytePos(pos as u32)\n             }\n         };\n-        let span_hi = |item: &StructLitField| match *item {\n+        let span_hi = |item: &StructLitField<'_>| match *item {\n             StructLitField::Regular(field) => field.span().hi(),\n             StructLitField::Base(expr) => expr.span.hi(),\n         };\n-        let rewrite = |item: &StructLitField| match *item {\n+        let rewrite = |item: &StructLitField<'_>| match *item {\n             StructLitField::Regular(field) => {\n                 // The 1 taken from the v_budget is for the comma.\n                 rewrite_field(context, field, v_shape.sub_width(1)?, 0)\n@@ -1662,7 +1670,7 @@ fn rewrite_struct_lit<'a>(\n }\n \n pub fn wrap_struct_field(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     fields_str: &str,\n     shape: Shape,\n     nested_shape: Shape,\n@@ -1690,7 +1698,7 @@ pub fn struct_lit_field_separator(config: &Config) -> &str {\n }\n \n pub fn rewrite_field(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     field: &ast::Field,\n     shape: Shape,\n     prefix_max_width: usize,\n@@ -1739,7 +1747,7 @@ pub fn rewrite_field(\n }\n \n fn rewrite_tuple_in_visual_indent_style<'a, T: 'a + IntoOverflowableItem<'a>>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     mut items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n@@ -1787,7 +1795,7 @@ fn rewrite_tuple_in_visual_indent_style<'a, T: 'a + IntoOverflowableItem<'a>>(\n }\n \n pub fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     items: impl Iterator<Item = &'a T>,\n     span: Span,\n     shape: Shape,\n@@ -1822,7 +1830,7 @@ pub fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n }\n \n pub fn rewrite_unary_prefix<R: Rewrite>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     prefix: &str,\n     rewrite: &R,\n     shape: Shape,\n@@ -1835,7 +1843,7 @@ pub fn rewrite_unary_prefix<R: Rewrite>(\n // FIXME: this is probably not correct for multi-line Rewrites. we should\n // subtract suffix.len() from the last line budget, not the first!\n pub fn rewrite_unary_suffix<R: Rewrite>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     suffix: &str,\n     rewrite: &R,\n     shape: Shape,\n@@ -1849,7 +1857,7 @@ pub fn rewrite_unary_suffix<R: Rewrite>(\n }\n \n fn rewrite_unary_op(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     op: ast::UnOp,\n     expr: &ast::Expr,\n     shape: Shape,\n@@ -1859,7 +1867,7 @@ fn rewrite_unary_op(\n }\n \n fn rewrite_assignment(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     lhs: &ast::Expr,\n     rhs: &ast::Expr,\n     op: Option<&ast::BinOp>,\n@@ -1889,7 +1897,7 @@ pub enum RhsTactics {\n // The left hand side must contain everything up to, and including, the\n // assignment operator.\n pub fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     lhs: S,\n     ex: &R,\n     shape: Shape,\n@@ -1898,7 +1906,7 @@ pub fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n }\n \n pub fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     lhs: S,\n     ex: &R,\n     shape: Shape,\n@@ -1927,7 +1935,7 @@ pub fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n }\n \n fn choose_rhs<R: Rewrite>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     expr: &R,\n     shape: Shape,\n     orig_rhs: Option<String>,\n@@ -1968,7 +1976,7 @@ fn choose_rhs<R: Rewrite>(\n }\n \n fn shape_from_rhs_tactic(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     rhs_tactic: RhsTactics,\n ) -> Option<Shape> {\n@@ -1993,7 +2001,7 @@ pub fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTac\n }\n \n fn rewrite_expr_addrof(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     mutability: ast::Mutability,\n     expr: &ast::Expr,\n     shape: Shape,"}, {"sha": "5ffff79811c012342b86fc671c469713f79b99d5", "filename": "src/format-diff/main.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fformat-diff%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fformat-diff%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformat-diff%2Fmain.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -14,16 +14,16 @@\n \n #![deny(warnings)]\n \n-extern crate env_logger;\n+use env_logger;\n #[macro_use]\n extern crate failure;\n-extern crate getopts;\n+use getopts;\n #[macro_use]\n extern crate log;\n-extern crate regex;\n+use regex;\n #[macro_use]\n extern crate serde_derive;\n-extern crate serde_json as json;\n+use serde_json as json;\n \n use std::collections::HashSet;\n use std::io::{self, BufRead};"}, {"sha": "91930bad00a6e738d07c0744b3ce4e831f432e92", "filename": "src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -111,7 +111,7 @@ fn format_project<T: FormatHandler>(\n \n // Used for formatting files.\n #[derive(new)]\n-struct FormatContext<'a, T: FormatHandler + 'a> {\n+struct FormatContext<'a, T: FormatHandler> {\n     krate: &'a ast::Crate,\n     report: FormatReport,\n     parse_session: ParseSess,"}, {"sha": "aae81ba3270ec32570796a7dd8de690670eedeb3", "filename": "src/git-rustfmt/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fgit-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fgit-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgit-rustfmt%2Fmain.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-extern crate env_logger;\n-extern crate getopts;\n+use env_logger;\n+\n #[macro_use]\n extern crate log;\n-extern crate rustfmt_nightly as rustfmt;\n+use rustfmt_nightly as rustfmt;\n \n use std::env;\n use std::io::stdout;"}, {"sha": "6ca29cfeaedfdbda75cbcfc307df7552f1f322c7", "filename": "src/imports.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -146,7 +146,7 @@ impl UseSegment {\n     }\n \n     fn from_path_segment(\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         path_seg: &ast::PathSegment,\n         modsep: bool,\n     ) -> Option<UseSegment> {\n@@ -193,19 +193,19 @@ fn merge_use_trees_inner(trees: &mut Vec<UseTree>, use_tree: UseTree) {\n }\n \n impl fmt::Debug for UseTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)\n     }\n }\n \n impl fmt::Debug for UseSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(self, f)\n     }\n }\n \n impl fmt::Display for UseSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             UseSegment::Glob => write!(f, \"*\"),\n             UseSegment::Ident(ref s, _) => write!(f, \"{}\", s),\n@@ -227,7 +227,7 @@ impl fmt::Display for UseSegment {\n     }\n }\n impl fmt::Display for UseTree {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         for (i, segment) in self.path.iter().enumerate() {\n             let is_last = i == self.path.len() - 1;\n             write!(f, \"{}\", segment)?;\n@@ -241,7 +241,7 @@ impl fmt::Display for UseTree {\n \n impl UseTree {\n     // Rewrite use tree with `use ` and a trailing `;`.\n-    pub fn rewrite_top_level(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    pub fn rewrite_top_level(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let vis = self.visibility.as_ref().map_or(Cow::from(\"\"), |vis| {\n             crate::utils::format_visibility(context, &vis)\n         });\n@@ -281,7 +281,7 @@ impl UseTree {\n     }\n \n     pub fn from_ast_with_normalization(\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         item: &ast::Item,\n     ) -> Option<UseTree> {\n         match item.node {\n@@ -305,7 +305,7 @@ impl UseTree {\n     }\n \n     fn from_ast(\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         a: &ast::UseTree,\n         list_item: Option<ListItem>,\n         visibility: Option<ast::Visibility>,\n@@ -710,7 +710,7 @@ impl Ord for UseTree {\n }\n \n fn rewrite_nested_use_tree(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     use_tree_list: &[UseTree],\n     shape: Shape,\n ) -> Option<String> {\n@@ -786,7 +786,7 @@ fn rewrite_nested_use_tree(\n }\n \n impl Rewrite for UseSegment {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         Some(match self {\n             UseSegment::Ident(ref ident, Some(ref rename)) => format!(\"{} as {}\", ident, rename),\n             UseSegment::Ident(ref ident, None) => ident.clone(),\n@@ -809,7 +809,7 @@ impl Rewrite for UseSegment {\n \n impl Rewrite for UseTree {\n     // This does NOT format attributes and visibility or add a trailing `;`.\n-    fn rewrite(&self, context: &RewriteContext, mut shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, mut shape: Shape) -> Option<String> {\n         let mut result = String::with_capacity(256);\n         let mut iter = self.path.iter().peekable();\n         while let Some(ref segment) = iter.next() {"}, {"sha": "3716110465ea0ecc3fbffba4b3184fe2e9252679", "filename": "src/issues.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fissues.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -48,7 +48,7 @@ pub struct Issue {\n }\n \n impl fmt::Display for Issue {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         let msg = match self.issue_type {\n             IssueType::Todo => \"TODO\",\n             IssueType::Fixme => \"FIXME\","}, {"sha": "a18cba69d6564184fffca77d21dce52cfb8766df", "filename": "src/items.rs", "status": "modified", "additions": 60, "deletions": 52, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -54,7 +54,7 @@ fn type_annotation_separator(config: &Config) -> &str {\n // Statements of the form\n // let pat: ty = init;\n impl Rewrite for ast::Local {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         debug!(\n             \"Local::rewrite {:?} {} {:?}\",\n             self, shape.width, shape.indent\n@@ -214,7 +214,7 @@ impl<'a> FnSig<'a> {\n     }\n \n     pub fn from_fn_kind(\n-        fn_kind: &'a visit::FnKind,\n+        fn_kind: &'a visit::FnKind<'_>,\n         generics: &'a ast::Generics,\n         decl: &'a ast::FnDecl,\n         defaultness: ast::Defaultness,\n@@ -242,7 +242,7 @@ impl<'a> FnSig<'a> {\n         }\n     }\n \n-    fn to_str(&self, context: &RewriteContext) -> String {\n+    fn to_str(&self, context: &RewriteContext<'_>) -> String {\n         let mut result = String::with_capacity(128);\n         // Vis defaultness constness unsafety abi.\n         result.push_str(&*format_visibility(context, &self.visibility));\n@@ -260,7 +260,7 @@ impl<'a> FnSig<'a> {\n }\n \n impl<'a> FmtVisitor<'a> {\n-    fn format_item(&mut self, item: &Item) {\n+    fn format_item(&mut self, item: &Item<'_>) {\n         self.buffer.push_str(&item.abi);\n \n         let snippet = self.snippet(item.span);\n@@ -292,7 +292,7 @@ impl<'a> FmtVisitor<'a> {\n         self.last_pos = item.span.hi();\n     }\n \n-    fn format_body_element(&mut self, element: &BodyElement) {\n+    fn format_body_element(&mut self, element: &BodyElement<'_>) {\n         match *element {\n             BodyElement::ForeignItem(item) => self.format_foreign_item(item),\n         }\n@@ -313,7 +313,7 @@ impl<'a> FmtVisitor<'a> {\n         &mut self,\n         indent: Indent,\n         ident: ast::Ident,\n-        fn_sig: &FnSig,\n+        fn_sig: &FnSig<'_>,\n         span: Span,\n         block: &ast::Block,\n         inner_attrs: Option<&[ast::Attribute]>,\n@@ -427,12 +427,12 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    pub fn visit_static(&mut self, static_parts: &StaticParts) {\n+    pub fn visit_static(&mut self, static_parts: &StaticParts<'_>) {\n         let rewrite = rewrite_static(&self.get_context(), static_parts, self.block_indent);\n         self.push_rewrite(static_parts.span, rewrite);\n     }\n \n-    pub fn visit_struct(&mut self, struct_parts: &StructParts) {\n+    pub fn visit_struct(&mut self, struct_parts: &StructParts<'_>) {\n         let is_tuple = struct_parts.def.is_tuple();\n         let rewrite = format_struct(&self.get_context(), struct_parts, self.block_indent, None)\n             .map(|s| if is_tuple { s + \";\" } else { s });\n@@ -672,7 +672,7 @@ impl<'a> FmtVisitor<'a> {\n }\n \n pub fn format_impl(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     item: &ast::Item,\n     offset: Indent,\n     where_span_end: Option<BytePos>,\n@@ -800,7 +800,7 @@ pub fn format_impl(\n }\n \n fn is_impl_single_line(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     items: &[ast::ImplItem],\n     result: &str,\n     where_clause_str: &str,\n@@ -819,7 +819,7 @@ fn is_impl_single_line(\n }\n \n fn format_impl_ref_and_type(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     item: &ast::Item,\n     offset: Indent,\n ) -> Option<String> {\n@@ -913,7 +913,7 @@ fn format_impl_ref_and_type(\n }\n \n fn rewrite_trait_ref(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     trait_ref: &ast::TraitRef,\n     offset: Indent,\n     polarity_str: &str,\n@@ -949,7 +949,7 @@ pub struct StructParts<'a> {\n }\n \n impl<'a> StructParts<'a> {\n-    fn format_header(&self, context: &RewriteContext) -> String {\n+    fn format_header(&self, context: &RewriteContext<'_>) -> String {\n         format_header(context, self.prefix, self.ident, self.vis)\n     }\n \n@@ -982,8 +982,8 @@ impl<'a> StructParts<'a> {\n }\n \n fn format_struct(\n-    context: &RewriteContext,\n-    struct_parts: &StructParts,\n+    context: &RewriteContext<'_>,\n+    struct_parts: &StructParts<'_>,\n     offset: Indent,\n     one_line_width: Option<usize>,\n ) -> Option<String> {\n@@ -998,7 +998,11 @@ fn format_struct(\n     }\n }\n \n-pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent) -> Option<String> {\n+pub fn format_trait(\n+    context: &RewriteContext<'_>,\n+    item: &ast::Item,\n+    offset: Indent,\n+) -> Option<String> {\n     if let ast::ItemKind::Trait(\n         is_auto,\n         unsafety,\n@@ -1157,7 +1161,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n }\n \n pub fn format_trait_alias(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     ident: ast::Ident,\n     generics: &ast::Generics,\n     generic_bounds: &ast::GenericBounds,\n@@ -1172,7 +1176,11 @@ pub fn format_trait_alias(\n     rewrite_assign_rhs(context, lhs, generic_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n }\n \n-fn format_unit_struct(context: &RewriteContext, p: &StructParts, offset: Indent) -> Option<String> {\n+fn format_unit_struct(\n+    context: &RewriteContext<'_>,\n+    p: &StructParts<'_>,\n+    offset: Indent,\n+) -> Option<String> {\n     let header_str = format_header(context, p.prefix, p.ident, p.vis);\n     let generics_str = if let Some(generics) = p.generics {\n         let hi = if generics.where_clause.predicates.is_empty() {\n@@ -1197,8 +1205,8 @@ fn format_unit_struct(context: &RewriteContext, p: &StructParts, offset: Indent)\n }\n \n pub fn format_struct_struct(\n-    context: &RewriteContext,\n-    struct_parts: &StructParts,\n+    context: &RewriteContext<'_>,\n+    struct_parts: &StructParts<'_>,\n     fields: &[ast::StructField],\n     offset: Indent,\n     one_line_width: Option<usize>,\n@@ -1301,7 +1309,7 @@ fn get_bytepos_after_visibility(vis: &ast::Visibility, default_span: Span) -> By\n // Format tuple or struct without any fields. We need to make sure that the comments\n // inside the delimiters are preserved.\n fn format_empty_struct_or_tuple(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     span: Span,\n     offset: Indent,\n     result: &mut String,\n@@ -1334,8 +1342,8 @@ fn format_empty_struct_or_tuple(\n }\n \n fn format_tuple_struct(\n-    context: &RewriteContext,\n-    struct_parts: &StructParts,\n+    context: &RewriteContext<'_>,\n+    struct_parts: &StructParts<'_>,\n     fields: &[ast::StructField],\n     offset: Indent,\n ) -> Option<String> {\n@@ -1429,7 +1437,7 @@ fn format_tuple_struct(\n }\n \n fn rewrite_type_prefix(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n     prefix: &str,\n     ident: ast::Ident,\n@@ -1470,7 +1478,7 @@ fn rewrite_type_prefix(\n }\n \n fn rewrite_type_item<R: Rewrite>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n     prefix: &str,\n     suffix: &str,\n@@ -1501,7 +1509,7 @@ fn rewrite_type_item<R: Rewrite>(\n }\n \n pub fn rewrite_type_alias(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n     ident: ast::Ident,\n     ty: &ast::Ty,\n@@ -1512,7 +1520,7 @@ pub fn rewrite_type_alias(\n }\n \n pub fn rewrite_existential_type(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n     ident: ast::Ident,\n     generic_bounds: &ast::GenericBounds,\n@@ -1539,7 +1547,7 @@ fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n }\n \n pub fn rewrite_struct_field_prefix(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     field: &ast::StructField,\n ) -> Option<String> {\n     let vis = format_visibility(context, &field.vis);\n@@ -1556,13 +1564,13 @@ pub fn rewrite_struct_field_prefix(\n }\n \n impl Rewrite for ast::StructField {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         rewrite_struct_field(context, self, shape, 0)\n     }\n }\n \n pub fn rewrite_struct_field(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     field: &ast::StructField,\n     shape: Shape,\n     lhs_max_width: usize,\n@@ -1693,8 +1701,8 @@ impl<'a> StaticParts<'a> {\n }\n \n fn rewrite_static(\n-    context: &RewriteContext,\n-    static_parts: &StaticParts,\n+    context: &RewriteContext<'_>,\n+    static_parts: &StaticParts<'_>,\n     offset: Indent,\n ) -> Option<String> {\n     let colon = colon_spaces(\n@@ -1752,7 +1760,7 @@ pub fn rewrite_associated_type(\n     ty_opt: Option<&ptr::P<ast::Ty>>,\n     generics: &ast::Generics,\n     generic_bounds_opt: Option<&ast::GenericBounds>,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n ) -> Option<String> {\n     let ident_str = rewrite_ident(context, ident);\n@@ -1784,7 +1792,7 @@ pub fn rewrite_associated_type(\n }\n \n pub fn rewrite_existential_impl_type(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     ident: ast::Ident,\n     generics: &ast::Generics,\n     generic_bounds: &ast::GenericBounds,\n@@ -1799,7 +1807,7 @@ pub fn rewrite_associated_impl_type(\n     defaultness: ast::Defaultness,\n     ty_opt: Option<&ptr::P<ast::Ty>>,\n     generics: &ast::Generics,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n ) -> Option<String> {\n     let result = rewrite_associated_type(ident, ty_opt, generics, None, context, indent)?;\n@@ -1811,7 +1819,7 @@ pub fn rewrite_associated_impl_type(\n }\n \n impl Rewrite for ast::FunctionRetTy {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n             ast::FunctionRetTy::Default(_) => Some(String::new()),\n             ast::FunctionRetTy::Ty(ref ty) => {\n@@ -1831,7 +1839,7 @@ fn is_empty_infer(ty: &ast::Ty, pat_span: Span) -> bool {\n }\n \n impl Rewrite for ast::Arg {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n             let mut result = self\n                 .pat\n@@ -1863,7 +1871,7 @@ impl Rewrite for ast::Arg {\n fn rewrite_explicit_self(\n     explicit_self: &ast::ExplicitSelf,\n     args: &[ast::Arg],\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     match explicit_self.node {\n         ast::SelfKind::Region(lt, m) => {\n@@ -1922,7 +1930,7 @@ pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n     }\n }\n \n-pub fn span_hi_for_arg(context: &RewriteContext, arg: &ast::Arg) -> BytePos {\n+pub fn span_hi_for_arg(context: &RewriteContext<'_>, arg: &ast::Arg) -> BytePos {\n     match arg.ty.node {\n         ast::TyKind::Infer if context.snippet(arg.ty.span) == \"_\" => arg.ty.span.hi(),\n         ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi(),\n@@ -1940,10 +1948,10 @@ pub fn is_named_arg(arg: &ast::Arg) -> bool {\n \n // Return type is (result, force_new_line_for_brace)\n fn rewrite_fn_base(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n     ident: ast::Ident,\n-    fn_sig: &FnSig,\n+    fn_sig: &FnSig<'_>,\n     span: Span,\n     newline_brace: bool,\n     has_body: bool,\n@@ -2269,7 +2277,7 @@ impl WhereClauseOption {\n }\n \n fn rewrite_args(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     args: &[ast::Arg],\n     explicit_self: Option<&ast::ExplicitSelf>,\n     one_line_budget: usize,\n@@ -2427,7 +2435,7 @@ fn arg_has_pattern(arg: &ast::Arg) -> bool {\n }\n \n fn compute_budgets_for_args(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     result: &str,\n     indent: Indent,\n     ret_str_len: usize,\n@@ -2500,7 +2508,7 @@ fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n }\n \n fn rewrite_generics(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     ident: &str,\n     generics: &ast::Generics,\n     shape: Shape,\n@@ -2531,7 +2539,7 @@ pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize)\n }\n \n fn rewrite_where_clause_rfc_style(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     where_clause: &ast::WhereClause,\n     shape: Shape,\n     terminator: &str,\n@@ -2631,7 +2639,7 @@ fn rewrite_where_clause_rfc_style(\n }\n \n fn rewrite_where_clause(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     where_clause: &ast::WhereClause,\n     brace_style: BraceStyle,\n     shape: Shape,\n@@ -2743,7 +2751,7 @@ fn missing_span_before_after_where(\n }\n \n fn rewrite_comments_before_after_where(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     span_before_where: Span,\n     span_after_where: Span,\n     shape: Shape,\n@@ -2758,7 +2766,7 @@ fn rewrite_comments_before_after_where(\n }\n \n fn format_header(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     item_name: &str,\n     ident: ast::Ident,\n     vis: &ast::Visibility,\n@@ -2779,7 +2787,7 @@ enum BracePos {\n }\n \n fn format_generics(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     generics: &ast::Generics,\n     brace_style: BraceStyle,\n     brace_pos: BracePos,\n@@ -2853,7 +2861,7 @@ fn format_generics(\n }\n \n impl Rewrite for ast::ForeignItem {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let attrs_str = self.attrs.rewrite(context, shape)?;\n         // Drop semicolon or it will be interpreted as comment.\n         // FIXME: this may be a faulty span from libsyntax.\n@@ -2914,7 +2922,7 @@ impl Rewrite for ast::ForeignItem {\n }\n \n /// Rewrite an inline mod.\n-pub fn rewrite_mod(context: &RewriteContext, item: &ast::Item) -> String {\n+pub fn rewrite_mod(context: &RewriteContext<'_>, item: &ast::Item) -> String {\n     let mut result = String::with_capacity(32);\n     result.push_str(&*format_visibility(context, &item.vis));\n     result.push_str(\"mod \");\n@@ -2924,7 +2932,7 @@ pub fn rewrite_mod(context: &RewriteContext, item: &ast::Item) -> String {\n }\n \n /// Rewrite `extern crate foo;` WITHOUT attributes.\n-pub fn rewrite_extern_crate(context: &RewriteContext, item: &ast::Item) -> Option<String> {\n+pub fn rewrite_extern_crate(context: &RewriteContext<'_>, item: &ast::Item) -> Option<String> {\n     assert!(is_extern_crate(item));\n     let new_str = context.snippet(item.span);\n     Some(if contains_comment(new_str) {"}, {"sha": "49ddbdb0a6c1967a6f1f2c429e0a6c582d456155", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -8,31 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(rust_2018_idioms)]\n+\n #[macro_use]\n extern crate derive_new;\n-extern crate atty;\n-extern crate bytecount;\n-extern crate diff;\n-extern crate dirs;\n-extern crate failure;\n-extern crate itertools;\n #[cfg(test)]\n #[macro_use]\n extern crate lazy_static;\n #[macro_use]\n extern crate log;\n-extern crate regex;\n-extern crate rustc_target;\n-extern crate serde;\n #[macro_use]\n extern crate serde_derive;\n-extern crate serde_json;\n-extern crate syntax;\n-extern crate syntax_pos;\n-extern crate toml;\n-extern crate unicode_categories;\n-extern crate unicode_segmentation;\n-extern crate unicode_width;\n \n use std::cell::RefCell;\n use std::collections::HashMap;\n@@ -264,7 +250,7 @@ impl FormatReport {\n     /// fancy output.\n     pub fn fancy_print(\n         &self,\n-        mut t: Box<term::Terminal<Output = io::Stderr>>,\n+        mut t: Box<dyn term::Terminal<Output = io::Stderr>>,\n     ) -> Result<(), term::Error> {\n         for (file, errors) in &self.internal.borrow().0 {\n             for error in errors {\n@@ -335,7 +321,7 @@ impl FormatReport {\n \n impl fmt::Display for FormatReport {\n     // Prints all the formatting errors.\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n         for (file, errors) in &self.internal.borrow().0 {\n             for error in errors {\n                 let prefix_space_len = error.line.to_string().len();\n@@ -509,7 +495,7 @@ fn format_code_block(code_snippet: &str, config: &Config) -> Option<FormattedSni\n }\n \n /// A session is a run of rustfmt across a single or multiple inputs.\n-pub struct Session<'b, T: Write + 'b> {\n+pub struct Session<'b, T: Write> {\n     pub config: Config,\n     pub out: Option<&'b mut T>,\n     pub(crate) errors: ReportedErrors,"}, {"sha": "0fb1eec68d0f28fa65b0cb90093b2a9381c9fc5c", "filename": "src/lists.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -270,7 +270,7 @@ where\n }\n \n // Format a list of commented items into a string.\n-pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n+pub fn write_list<I, T>(items: I, formatting: &ListFormatting<'_>) -> Option<String>\n where\n     I: IntoIterator<Item = T> + Clone,\n     T: AsRef<ListItem>,\n@@ -771,7 +771,7 @@ where\n #[allow(clippy::too_many_arguments)]\n // Creates an iterator over a list's items with associated comments.\n pub fn itemize_list<'a, T, I, F1, F2, F3>(\n-    snippet_provider: &'a SnippetProvider,\n+    snippet_provider: &'a SnippetProvider<'_>,\n     inner: I,\n     terminator: &'a str,\n     separator: &'a str,\n@@ -838,7 +838,7 @@ fn comment_len(comment: Option<&str>) -> usize {\n // Compute horizontal and vertical shapes for a struct-lit-like thing.\n pub fn struct_lit_shape(\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     prefix_width: usize,\n     suffix_width: usize,\n ) -> Option<(Option<Shape>, Shape)> {\n@@ -867,7 +867,7 @@ pub fn struct_lit_shape(\n // Compute the tactic for the internals of a struct-lit-like thing.\n pub fn struct_lit_tactic(\n     h_shape: Option<Shape>,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     items: &[ListItem],\n ) -> DefinitiveListTactic {\n     if let Some(h_shape) = h_shape {\n@@ -900,7 +900,7 @@ pub fn shape_for_tactic(\n pub fn struct_lit_formatting<'a>(\n     shape: Shape,\n     tactic: DefinitiveListTactic,\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     force_no_trailing_comma: bool,\n ) -> ListFormatting<'a> {\n     let ends_with_newline = context.config.indent_style() != IndentStyle::Visual"}, {"sha": "d79ae82980d895417e9710f2e501b04491cf0360", "filename": "src/macros.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -77,7 +77,7 @@ impl MacroArg {\n }\n \n impl Rewrite for ast::Item {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let mut visitor = crate::visitor::FmtVisitor::from_context(context);\n         visitor.block_indent = shape.indent;\n         visitor.last_pos = self.span().lo();\n@@ -87,7 +87,7 @@ impl Rewrite for ast::Item {\n }\n \n impl Rewrite for MacroArg {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n             MacroArg::Expr(ref expr) => expr.rewrite(context, shape),\n             MacroArg::Ty(ref ty) => ty.rewrite(context, shape),\n@@ -147,7 +147,7 @@ fn parse_macro_arg<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n \n /// Rewrite macro name without using pretty-printer if possible.\n fn rewrite_macro_name(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     path: &ast::Path,\n     extra_ident: Option<ast::Ident>,\n ) -> String {\n@@ -165,7 +165,7 @@ fn rewrite_macro_name(\n \n // Use this on failing to format the macro call.\n fn return_macro_parse_failure_fallback(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     indent: Indent,\n     span: Span,\n ) -> Option<String> {\n@@ -199,7 +199,7 @@ struct InsideMacroGuard<'a> {\n }\n \n impl<'a> InsideMacroGuard<'a> {\n-    fn inside_macro_context(context: &'a RewriteContext) -> InsideMacroGuard<'a> {\n+    fn inside_macro_context(context: &'a RewriteContext<'_>) -> InsideMacroGuard<'a> {\n         let is_nested = context.inside_macro.replace(true);\n         InsideMacroGuard { context, is_nested }\n     }\n@@ -214,7 +214,7 @@ impl<'a> Drop for InsideMacroGuard<'a> {\n pub fn rewrite_macro(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     position: MacroPosition,\n ) -> Option<String> {\n@@ -246,7 +246,7 @@ fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {\n pub fn rewrite_macro_inner(\n     mac: &ast::Mac,\n     extra_ident: Option<ast::Ident>,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     position: MacroPosition,\n     is_nested_macro: bool,\n@@ -453,7 +453,7 @@ pub fn rewrite_macro_inner(\n }\n \n pub fn rewrite_macro_def(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     indent: Indent,\n     def: &ast::MacroDef,\n@@ -624,7 +624,7 @@ enum MacroArgKind {\n }\n \n fn delim_token_to_str(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     delim_token: DelimToken,\n     shape: Shape,\n     use_multiple_lines: bool,\n@@ -690,7 +690,7 @@ impl MacroArgKind {\n \n     fn rewrite(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         use_multiple_lines: bool,\n     ) -> Option<String> {\n@@ -742,7 +742,7 @@ struct ParsedMacroArg {\n impl ParsedMacroArg {\n     pub fn rewrite(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         use_multiple_lines: bool,\n     ) -> Option<String> {\n@@ -995,7 +995,7 @@ impl MacroArgParser {\n }\n \n fn wrap_macro_args(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     args: &[ParsedMacroArg],\n     shape: Shape,\n ) -> Option<String> {\n@@ -1004,7 +1004,7 @@ fn wrap_macro_args(\n }\n \n fn wrap_macro_args_inner(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     args: &[ParsedMacroArg],\n     shape: Shape,\n     use_multiple_lines: bool,\n@@ -1047,7 +1047,11 @@ fn wrap_macro_args_inner(\n //\n // We always try and format on one line.\n // FIXME: Use multi-line when every thing does not fit on one line.\n-fn format_macro_args(context: &RewriteContext, toks: TokenStream, shape: Shape) -> Option<String> {\n+fn format_macro_args(\n+    context: &RewriteContext<'_>,\n+    toks: TokenStream,\n+    shape: Shape,\n+) -> Option<String> {\n     if !context.config.format_macro_matchers() {\n         let token_stream: TokenStream = toks.into();\n         let span = span_for_token_stream(&token_stream);\n@@ -1138,7 +1142,7 @@ fn next_space(tok: &Token) -> SpaceState {\n /// Tries to convert a macro use into a short hand try expression. Returns None\n /// when the macro is not an instance of try! (or parsing the inner expression\n /// failed).\n-pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::Expr> {\n+pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n     if &mac.node.path.to_string() == \"try\" {\n         let ts: TokenStream = mac.node.tts.clone().into();\n         let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n@@ -1154,7 +1158,7 @@ pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::\n     }\n }\n \n-fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> DelimToken {\n+fn macro_style(mac: &ast::Mac, context: &RewriteContext<'_>) -> DelimToken {\n     let snippet = context.snippet(mac.span);\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());\n     let bracket_pos = snippet.find_uncommented(\"[\").unwrap_or(usize::max_value());\n@@ -1242,7 +1246,7 @@ struct MacroBranch {\n impl MacroBranch {\n     fn rewrite(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         multi_branch_style: bool,\n     ) -> Option<String> {\n@@ -1360,7 +1364,11 @@ impl MacroBranch {\n ///     [pub] static ref NAME_N: TYPE_N = EXPR_N;\n /// }\n /// ```\n-fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream) -> Option<String> {\n+fn format_lazy_static(\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+    ts: &TokenStream,\n+) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n     let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n     let nested_shape = shape\n@@ -1429,7 +1437,7 @@ fn format_lazy_static(context: &RewriteContext, shape: Shape, ts: &TokenStream)\n }\n \n fn rewrite_macro_with_items(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     items: &[MacroArg],\n     macro_name: &str,\n     shape: Shape,"}, {"sha": "15ff7dbb8fe72b3352cab8cb953192ee9b4b1b63", "filename": "src/matches.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -67,13 +67,13 @@ impl<'a> Spanned for ArmWrapper<'a> {\n }\n \n impl<'a> Rewrite for ArmWrapper<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         rewrite_match_arm(context, self.arm, shape, self.is_last)\n     }\n }\n \n pub fn rewrite_match(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     cond: &ast::Expr,\n     arms: &[ast::Arm],\n     shape: Shape,\n@@ -168,7 +168,7 @@ fn arm_comma(config: &Config, body: &ast::Expr, is_last: bool) -> &'static str {\n \n /// Collect a byte position of the beginning `|` for each arm, if available.\n fn collect_beginning_verts(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     arms: &[ast::Arm],\n     span: Span,\n ) -> Vec<Option<BytePos>> {\n@@ -184,7 +184,7 @@ fn collect_beginning_verts(\n }\n \n fn rewrite_match_arms(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     arms: &[ast::Arm],\n     shape: Shape,\n     span: Span,\n@@ -224,7 +224,7 @@ fn rewrite_match_arms(\n }\n \n fn rewrite_match_arm(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     arm: &ast::Arm,\n     shape: Shape,\n     is_last: bool,\n@@ -286,7 +286,7 @@ fn rewrite_match_arm(\n }\n \n fn block_can_be_flattened<'a>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     expr: &'a ast::Expr,\n ) -> Option<&'a ast::Block> {\n     match expr.node {\n@@ -304,7 +304,7 @@ fn block_can_be_flattened<'a>(\n // @extend: true if the arm body can be put next to `=>`\n // @body: flattened body, if the body is block with a single expression\n fn flatten_arm_body<'a>(\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     body: &'a ast::Expr,\n     opt_shape: Option<Shape>,\n ) -> (bool, &'a ast::Expr) {\n@@ -334,7 +334,7 @@ fn flatten_arm_body<'a>(\n }\n \n fn rewrite_match_body(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     body: &ptr::P<ast::Expr>,\n     pats_str: &str,\n     shape: Shape,\n@@ -499,7 +499,7 @@ fn rewrite_match_body(\n }\n \n impl Rewrite for ast::Guard {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self {\n             ast::Guard::If(ref expr) => expr.rewrite(context, shape),\n         }\n@@ -508,7 +508,7 @@ impl Rewrite for ast::Guard {\n \n // The `if ...` guard on a match arm.\n fn rewrite_guard(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     guard: &Option<ast::Guard>,\n     shape: Shape,\n     // The amount of space used up on this line for the pattern in"}, {"sha": "740378fbc2a5da375a6880c2f20439eacf5a5076", "filename": "src/missed_spans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -79,7 +79,7 @@ impl<'a> FmtVisitor<'a> {\n         })\n     }\n \n-    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str)>(\n+    fn format_missing_inner<F: Fn(&mut FmtVisitor<'_>, &str, &str)>(\n         &mut self,\n         end: BytePos,\n         process_last_snippet: F,\n@@ -144,7 +144,7 @@ impl<'a> FmtVisitor<'a> {\n \n     fn write_snippet<F>(&mut self, span: Span, process_last_snippet: F)\n     where\n-        F: Fn(&mut FmtVisitor, &str, &str),\n+        F: Fn(&mut FmtVisitor<'_>, &str, &str),\n     {\n         // Get a snippet from the file start to the span's hi without allocating.\n         // We need it to determine what precedes the current comment. If the comment\n@@ -172,7 +172,7 @@ impl<'a> FmtVisitor<'a> {\n         span: Span,\n         process_last_snippet: F,\n     ) where\n-        F: Fn(&mut FmtVisitor, &str, &str),\n+        F: Fn(&mut FmtVisitor<'_>, &str, &str),\n     {\n         // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not"}, {"sha": "27923ddfc7c81b4d6971a46c7986420705757979", "filename": "src/overflow.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -89,7 +89,7 @@ pub enum OverflowableItem<'a> {\n }\n \n impl<'a> Rewrite for OverflowableItem<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         self.map(|item| item.rewrite(context, shape))\n     }\n }\n@@ -103,7 +103,7 @@ impl<'a> Spanned for OverflowableItem<'a> {\n impl<'a> OverflowableItem<'a> {\n     pub fn map<F, T>(&self, f: F) -> T\n     where\n-        F: Fn(&IntoOverflowableItem<'a>) -> T,\n+        F: Fn(&dyn IntoOverflowableItem<'a>) -> T,\n     {\n         match self {\n             OverflowableItem::Expr(expr) => f(*expr),\n@@ -159,7 +159,7 @@ impl<'a> OverflowableItem<'a> {\n         }\n     }\n \n-    pub fn can_be_overflowed(&self, context: &RewriteContext, len: usize) -> bool {\n+    pub fn can_be_overflowed(&self, context: &RewriteContext<'_>, len: usize) -> bool {\n         match self {\n             OverflowableItem::Expr(expr) => can_be_overflowed_expr(context, expr, len),\n             OverflowableItem::MacroArg(macro_arg) => match macro_arg {\n@@ -248,7 +248,7 @@ where\n }\n \n pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     ident: &'a str,\n     items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n@@ -272,7 +272,7 @@ pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n }\n \n pub fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     ident: &'a str,\n     items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n@@ -294,7 +294,7 @@ pub fn rewrite_with_angle_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n }\n \n pub fn rewrite_with_square_brackets<'a, T: 'a + IntoOverflowableItem<'a>>(\n-    context: &'a RewriteContext,\n+    context: &'a RewriteContext<'_>,\n     name: &'a str,\n     items: impl Iterator<Item = &'a T>,\n     shape: Shape,\n@@ -339,7 +339,7 @@ struct Context<'a> {\n \n impl<'a> Context<'a> {\n     pub fn new<T: 'a + IntoOverflowableItem<'a>>(\n-        context: &'a RewriteContext,\n+        context: &'a RewriteContext<'_>,\n         items: impl Iterator<Item = &'a T>,\n         ident: &'a str,\n         shape: Shape,\n@@ -376,7 +376,7 @@ impl<'a> Context<'a> {\n         }\n     }\n \n-    fn last_item(&self) -> Option<&OverflowableItem> {\n+    fn last_item(&self) -> Option<&OverflowableItem<'_>> {\n         self.items.last()\n     }\n \n@@ -705,15 +705,15 @@ fn need_block_indent(s: &str, shape: Shape) -> bool {\n     })\n }\n \n-fn can_be_overflowed(context: &RewriteContext, items: &[OverflowableItem]) -> bool {\n+fn can_be_overflowed(context: &RewriteContext<'_>, items: &[OverflowableItem<'_>]) -> bool {\n     items\n         .last()\n         .map_or(false, |x| x.can_be_overflowed(context, items.len()))\n }\n \n /// Returns a shape for the last argument which is going to be overflowed.\n fn last_item_shape(\n-    lists: &[OverflowableItem],\n+    lists: &[OverflowableItem<'_>],\n     items: &[ListItem],\n     shape: Shape,\n     args_max_width: usize,\n@@ -733,7 +733,7 @@ fn last_item_shape(\n }\n \n fn shape_from_indent_style(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     overhead: usize,\n     offset: usize,\n@@ -759,7 +759,10 @@ fn no_long_items(list: &[ListItem]) -> bool {\n }\n \n /// In case special-case style is required, returns an offset from which we start horizontal layout.\n-pub fn maybe_get_args_offset(callee_str: &str, args: &[OverflowableItem]) -> Option<(bool, usize)> {\n+pub fn maybe_get_args_offset(\n+    callee_str: &str,\n+    args: &[OverflowableItem<'_>],\n+) -> Option<(bool, usize)> {\n     if let Some(&(_, num_args_before)) = args\n         .get(0)?\n         .whitelist()"}, {"sha": "8429d33114f064f41738754ee85ccf5c70c1191a", "filename": "src/pairs.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpairs.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -42,7 +42,7 @@ impl<'a> PairParts<'a> {\n pub(crate) fn rewrite_all_pairs(\n     expr: &ast::Expr,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     // First we try formatting on one line.\n     if let Some(list) = expr.flatten(false) {\n@@ -62,9 +62,9 @@ pub(crate) fn rewrite_all_pairs(\n // This may return a multi-line result since we allow the last expression to go\n // multiline in a 'single line' formatting.\n fn rewrite_pairs_one_line<T: Rewrite>(\n-    list: &PairList<T>,\n+    list: &PairList<'_, '_, T>,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     assert!(list.list.len() >= 2, \"Not a pair?\");\n \n@@ -107,9 +107,9 @@ fn rewrite_pairs_one_line<T: Rewrite>(\n }\n \n fn rewrite_pairs_multiline<T: Rewrite>(\n-    list: &PairList<T>,\n+    list: &PairList<'_, '_, T>,\n     shape: Shape,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n ) -> Option<String> {\n     let rhs_offset = shape.rhs_overhead(&context.config);\n     let nested_shape = (match context.config.indent_style() {\n@@ -175,8 +175,8 @@ fn rewrite_pairs_multiline<T: Rewrite>(\n pub(crate) fn rewrite_pair<LHS, RHS>(\n     lhs: &LHS,\n     rhs: &RHS,\n-    pp: PairParts,\n-    context: &RewriteContext,\n+    pp: PairParts<'_>,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     separator_place: SeparatorPlace,\n ) -> Option<String>\n@@ -264,18 +264,18 @@ trait FlattenPair: Rewrite + Sized {\n     // operator into the list. E.g,, if the source is `a * b + c`, if `_same_op`\n     // is true, we make `[(a * b), c]` if `_same_op` is false, we make\n     // `[a, b, c]`\n-    fn flatten(&self, _same_op: bool) -> Option<PairList<Self>> {\n+    fn flatten(&self, _same_op: bool) -> Option<PairList<'_, '_, Self>> {\n         None\n     }\n }\n \n-struct PairList<'a, 'b, T: Rewrite + 'b> {\n+struct PairList<'a, 'b, T: Rewrite> {\n     list: Vec<&'b T>,\n     separators: Vec<&'a str>,\n }\n \n impl FlattenPair for ast::Expr {\n-    fn flatten(&self, same_op: bool) -> Option<PairList<ast::Expr>> {\n+    fn flatten(&self, same_op: bool) -> Option<PairList<'_, '_, ast::Expr>> {\n         let top_op = match self.node {\n             ast::ExprKind::Binary(op, _, _) => op.node,\n             _ => return None,"}, {"sha": "956ce56bdf1e1d17189cb3bf98956d26df5dbef9", "filename": "src/patterns.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -64,7 +64,7 @@ fn is_short_pattern_inner(pat: &ast::Pat) -> bool {\n }\n \n impl Rewrite for Pat {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self.node {\n             PatKind::Box(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, shape),\n             PatKind::Ident(binding_mode, ident, ref sub_pat) => {\n@@ -174,7 +174,7 @@ fn rewrite_struct_pat(\n     fields: &[source_map::Spanned<ast::FieldPat>],\n     ellipsis: bool,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     // 2 =  ` {`\n@@ -240,7 +240,7 @@ fn rewrite_struct_pat(\n }\n \n impl Rewrite for FieldPat {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let pat = self.pat.rewrite(context, shape);\n         if self.is_shorthand {\n             pat\n@@ -271,7 +271,7 @@ pub enum TuplePatField<'a> {\n }\n \n impl<'a> Rewrite for TuplePatField<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n             TuplePatField::Pat(p) => p.rewrite(context, shape),\n             TuplePatField::Dotdot(_) => Some(\"..\".to_string()),\n@@ -288,7 +288,11 @@ impl<'a> Spanned for TuplePatField<'a> {\n     }\n }\n \n-pub fn can_be_overflowed_pat(context: &RewriteContext, pat: &TuplePatField, len: usize) -> bool {\n+pub fn can_be_overflowed_pat(\n+    context: &RewriteContext<'_>,\n+    pat: &TuplePatField<'_>,\n+    len: usize,\n+) -> bool {\n     match *pat {\n         TuplePatField::Pat(pat) => match pat.node {\n             ast::PatKind::Path(..)\n@@ -310,7 +314,7 @@ fn rewrite_tuple_pat(\n     dotdot_pos: Option<usize>,\n     path_str: Option<String>,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     let mut pat_vec: Vec<_> = pats.iter().map(|x| TuplePatField::Pat(x)).collect();\n@@ -379,8 +383,8 @@ fn rewrite_tuple_pat(\n }\n \n fn count_wildcard_suffix_len(\n-    context: &RewriteContext,\n-    patterns: &[TuplePatField],\n+    context: &RewriteContext<'_>,\n+    patterns: &[TuplePatField<'_>],\n     span: Span,\n     shape: Shape,\n ) -> usize {"}, {"sha": "e078cc3279bbf5ee8369ea8bc76e80395e317647", "filename": "src/reorder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -63,7 +63,7 @@ fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n }\n \n fn wrap_reorderable_items(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     list_items: &[ListItem],\n     shape: Shape,\n ) -> Option<String> {\n@@ -74,7 +74,7 @@ fn wrap_reorderable_items(\n }\n \n fn rewrite_reorderable_item(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     item: &ast::Item,\n     shape: Shape,\n ) -> Option<String> {\n@@ -99,7 +99,7 @@ fn rewrite_reorderable_item(\n /// Rewrite a list of items with reordering. Every item in `items` must have\n /// the same `ast::ItemKind`.\n fn rewrite_reorderable_items(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     reorderable_items: &[&ast::Item],\n     shape: Shape,\n     span: Span,"}, {"sha": "5c5ed438f5e2b3c17eb1e8a699a274d83cb05719", "filename": "src/rewrite.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -23,11 +23,11 @@ use crate::FormatReport;\n \n pub trait Rewrite {\n     /// Rewrite self into shape.\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String>;\n }\n \n impl<T: Rewrite> Rewrite for ptr::P<T> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         (**self).rewrite(context, shape)\n     }\n }"}, {"sha": "81778c33ecf97d2f04d912a1c4dab7ff9dd82da8", "filename": "src/rustfmt_diff.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustfmt_diff.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -46,7 +46,7 @@ impl Mismatch {\n // This struct handles writing output to stdout and abstracts away the logic\n // of printing in color, if it's possible in the executing environment.\n pub struct OutputWriter {\n-    terminal: Option<Box<term::Terminal<Output = io::Stdout>>>,\n+    terminal: Option<Box<dyn term::Terminal<Output = io::Stdout>>>,\n }\n \n impl OutputWriter {"}, {"sha": "ac2a1a3ba227f59e40bc180a7501383a65b4f7a8", "filename": "src/test/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -785,7 +785,7 @@ impl ConfigCodeBlock {\n         true\n     }\n \n-    fn has_parsing_errors<T: Write>(&self, session: &Session<T>) -> bool {\n+    fn has_parsing_errors<T: Write>(&self, session: &Session<'_, T>) -> bool {\n         if session.has_parsing_errors() {\n             write_message(&format!(\n                 \"\\u{261d}\\u{1f3fd} Cannot format {}:{}\","}, {"sha": "340f15ead481ffa4893580c19151674c357c17a8", "filename": "src/types.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -40,7 +40,7 @@ pub enum PathContext {\n \n // Does not wrap on simple segments.\n pub fn rewrite_path(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     path_context: PathContext,\n     qself: Option<&ast::QSelf>,\n     path: &ast::Path,\n@@ -103,7 +103,7 @@ fn rewrite_path_segments<'a, I>(\n     iter: I,\n     mut span_lo: BytePos,\n     span_hi: BytePos,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String>\n where\n@@ -148,7 +148,7 @@ pub enum SegmentParam<'a> {\n }\n \n impl<'a> SegmentParam<'a> {\n-    fn from_generic_arg(arg: &ast::GenericArg) -> SegmentParam {\n+    fn from_generic_arg(arg: &ast::GenericArg) -> SegmentParam<'_> {\n         match arg {\n             ast::GenericArg::Lifetime(ref lt) => SegmentParam::LifeTime(lt),\n             ast::GenericArg::Type(ref ty) => SegmentParam::Type(ty),\n@@ -167,7 +167,7 @@ impl<'a> Spanned for SegmentParam<'a> {\n }\n \n impl<'a> Rewrite for SegmentParam<'a> {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n             SegmentParam::LifeTime(lt) => lt.rewrite(context, shape),\n             SegmentParam::Type(ty) => ty.rewrite(context, shape),\n@@ -204,7 +204,7 @@ fn rewrite_segment(\n     segment: &ast::PathSegment,\n     span_lo: &mut BytePos,\n     span_hi: BytePos,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     let mut result = String::with_capacity(128);\n@@ -285,7 +285,7 @@ fn format_function_type<'a, I>(\n     output: &FunctionRetTy,\n     variadic: bool,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String>\n where\n@@ -410,15 +410,15 @@ where\n     }\n }\n \n-fn type_bound_colon(context: &RewriteContext) -> &'static str {\n+fn type_bound_colon(context: &RewriteContext<'_>) -> &'static str {\n     colon_spaces(\n         context.config.space_before_colon(),\n         context.config.space_after_colon(),\n     )\n }\n \n impl Rewrite for ast::WherePredicate {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         // FIXME: dead spans?\n         let result = match *self {\n             ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n@@ -459,7 +459,7 @@ impl Rewrite for ast::WherePredicate {\n }\n \n impl Rewrite for ast::GenericArg {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n             ast::GenericArg::Lifetime(ref lt) => lt.rewrite(context, shape),\n             ast::GenericArg::Type(ref ty) => ty.rewrite(context, shape),\n@@ -470,7 +470,7 @@ impl Rewrite for ast::GenericArg {\n fn rewrite_bounded_lifetime(\n     lt: &ast::Lifetime,\n     bounds: &[ast::GenericBound],\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     let result = lt.rewrite(context, shape)?;\n@@ -491,13 +491,13 @@ fn rewrite_bounded_lifetime(\n }\n \n impl Rewrite for ast::Lifetime {\n-    fn rewrite(&self, context: &RewriteContext, _: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, _: Shape) -> Option<String> {\n         Some(rewrite_ident(context, self.ident).to_owned())\n     }\n }\n \n impl Rewrite for ast::GenericBound {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match *self {\n             ast::GenericBound::Trait(ref poly_trait_ref, trait_bound_modifier) => {\n                 let snippet = context.snippet(self.span());\n@@ -516,7 +516,7 @@ impl Rewrite for ast::GenericBound {\n }\n \n impl Rewrite for ast::GenericBounds {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         if self.is_empty() {\n             return Some(String::new());\n         }\n@@ -526,7 +526,7 @@ impl Rewrite for ast::GenericBounds {\n }\n \n impl Rewrite for ast::GenericParam {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let mut result = String::with_capacity(128);\n         // FIXME: If there are more than one attributes, this will force multiline.\n         match self.attrs.rewrite(context, shape) {\n@@ -558,7 +558,7 @@ impl Rewrite for ast::GenericParam {\n }\n \n impl Rewrite for ast::PolyTraitRef {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         if let Some(lifetime_str) =\n             rewrite_lifetime_param(context, shape, &self.bound_generic_params)\n         {\n@@ -576,13 +576,13 @@ impl Rewrite for ast::PolyTraitRef {\n }\n \n impl Rewrite for ast::TraitRef {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         rewrite_path(context, PathContext::Type, None, &self.path, shape)\n     }\n }\n \n impl Rewrite for ast::Ty {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         match self.node {\n             ast::TyKind::TraitObject(ref bounds, tobj_syntax) => {\n                 // we have to consider 'dyn' keyword is used or not!!!\n@@ -695,7 +695,7 @@ impl Rewrite for ast::Ty {\n fn rewrite_bare_fn(\n     bare_fn: &ast::BareFnTy,\n     span: Span,\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n ) -> Option<String> {\n     debug!(\"rewrite_bare_fn {:#?}\", shape);\n@@ -759,7 +759,7 @@ fn is_generic_bounds_in_order(generic_bounds: &[ast::GenericBound]) -> bool {\n }\n \n fn join_bounds(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     items: &[ast::GenericBound],\n     need_indent: bool,\n@@ -815,7 +815,7 @@ fn join_bounds(\n     Some(result)\n }\n \n-pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize) -> bool {\n+pub fn can_be_overflowed_type(context: &RewriteContext<'_>, ty: &ast::Ty, len: usize) -> bool {\n     match ty.node {\n         ast::TyKind::Tup(..) => context.use_block_indent() && len == 1,\n         ast::TyKind::Rptr(_, ref mutty) | ast::TyKind::Ptr(ref mutty) => {\n@@ -827,7 +827,7 @@ pub fn can_be_overflowed_type(context: &RewriteContext, ty: &ast::Ty, len: usize\n \n /// Returns `None` if there is no `LifetimeDef` in the given generic parameters.\n fn rewrite_lifetime_param(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     generic_params: &[ast::GenericParam],\n ) -> Option<String> {"}, {"sha": "b7f08a556e87986cfa8fa682ed36a049a2f3a6f5", "filename": "src/utils.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -30,7 +30,7 @@ use crate::shape::{Indent, Shape};\n pub const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n pub const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n \n-pub fn rewrite_ident<'a>(context: &'a RewriteContext, ident: ast::Ident) -> &'a str {\n+pub fn rewrite_ident<'a>(context: &'a RewriteContext<'_>, ident: ast::Ident) -> &'a str {\n     context.snippet(ident.span)\n }\n \n@@ -64,7 +64,7 @@ pub fn is_same_visibility(a: &Visibility, b: &Visibility) -> bool {\n }\n \n // Uses Cow to avoid allocating in the common cases.\n-pub fn format_visibility(context: &RewriteContext, vis: &Visibility) -> Cow<'static, str> {\n+pub fn format_visibility(context: &RewriteContext<'_>, vis: &Visibility) -> Cow<'static, str> {\n     match vis.node {\n         VisibilityKind::Public => Cow::from(\"pub \"),\n         VisibilityKind::Inherited => Cow::from(\"\"),\n@@ -267,7 +267,7 @@ pub fn contains_skip(attrs: &[Attribute]) -> bool {\n }\n \n #[inline]\n-pub fn semicolon_for_expr(context: &RewriteContext, expr: &ast::Expr) -> bool {\n+pub fn semicolon_for_expr(context: &RewriteContext<'_>, expr: &ast::Expr) -> bool {\n     match expr.node {\n         ast::ExprKind::Ret(..) | ast::ExprKind::Continue(..) | ast::ExprKind::Break(..) => {\n             context.config.trailing_semicolon()\n@@ -277,7 +277,7 @@ pub fn semicolon_for_expr(context: &RewriteContext, expr: &ast::Expr) -> bool {\n }\n \n #[inline]\n-pub fn semicolon_for_stmt(context: &RewriteContext, stmt: &ast::Stmt) -> bool {\n+pub fn semicolon_for_stmt(context: &RewriteContext<'_>, stmt: &ast::Stmt) -> bool {\n     match stmt.node {\n         ast::StmtKind::Semi(ref expr) => match expr.node {\n             ast::ExprKind::While(..)\n@@ -424,7 +424,7 @@ pub fn first_line_ends_with(s: &str, c: char) -> bool {\n \n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n-pub fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n+pub fn is_block_expr(context: &RewriteContext<'_>, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n         ast::ExprKind::Mac(..)\n         | ast::ExprKind::Call(..)"}, {"sha": "fe476c0bd40be807780d73e6d475409c3c9d2d32", "filename": "src/vertical.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -31,10 +31,10 @@ use crate::utils::{contains_skip, is_attributes_extendable, mk_sp, rewrite_ident\n pub trait AlignedItem {\n     fn skip(&self) -> bool;\n     fn get_span(&self) -> Span;\n-    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String>;\n+    fn rewrite_prefix(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String>;\n     fn rewrite_aligned_item(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         prefix_max_width: usize,\n     ) -> Option<String>;\n@@ -49,7 +49,7 @@ impl AlignedItem for ast::StructField {\n         self.span()\n     }\n \n-    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite_prefix(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let attrs_str = self.attrs.rewrite(context, shape)?;\n         let missing_span = if self.attrs.is_empty() {\n             mk_sp(self.span.lo(), self.span.lo())\n@@ -71,7 +71,7 @@ impl AlignedItem for ast::StructField {\n \n     fn rewrite_aligned_item(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         prefix_max_width: usize,\n     ) -> Option<String> {\n@@ -88,7 +88,7 @@ impl AlignedItem for ast::Field {\n         self.span()\n     }\n \n-    fn rewrite_prefix(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    fn rewrite_prefix(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n         let attrs_str = self.attrs.rewrite(context, shape)?;\n         let name = rewrite_ident(context, self.ident);\n         let missing_span = if self.attrs.is_empty() {\n@@ -108,7 +108,7 @@ impl AlignedItem for ast::Field {\n \n     fn rewrite_aligned_item(\n         &self,\n-        context: &RewriteContext,\n+        context: &RewriteContext<'_>,\n         shape: Shape,\n         prefix_max_width: usize,\n     ) -> Option<String> {\n@@ -118,7 +118,7 @@ impl AlignedItem for ast::Field {\n \n pub fn rewrite_with_alignment<T: AlignedItem>(\n     fields: &[T],\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     shape: Shape,\n     span: Span,\n     one_line_width: usize,\n@@ -185,7 +185,7 @@ pub fn rewrite_with_alignment<T: AlignedItem>(\n }\n \n fn struct_field_prefix_max_min_width<T: AlignedItem>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     fields: &[T],\n     shape: Shape,\n ) -> (usize, usize) {\n@@ -210,7 +210,7 @@ fn struct_field_prefix_max_min_width<T: AlignedItem>(\n }\n \n fn rewrite_aligned_items_inner<T: AlignedItem>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     fields: &[T],\n     span: Span,\n     offset: Indent,\n@@ -268,7 +268,7 @@ fn rewrite_aligned_items_inner<T: AlignedItem>(\n }\n \n fn group_aligned_items<T: AlignedItem>(\n-    context: &RewriteContext,\n+    context: &RewriteContext<'_>,\n     fields: &[T],\n ) -> (&'static str, usize) {\n     let mut index = 0;"}, {"sha": "ed4ab8675862f5d5f8ef19e0e3befbf74873a811", "filename": "src/visitor.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce682bdabc39a7261eb5c3d43b20bb84fae64fde/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=ce682bdabc39a7261eb5c3d43b20bb84fae64fde", "patch": "@@ -88,7 +88,7 @@ impl<'a> Drop for FmtVisitor<'a> {\n }\n \n impl<'b, 'a: 'b> FmtVisitor<'a> {\n-    fn set_parent_context(&mut self, context: &'a RewriteContext) {\n+    fn set_parent_context(&mut self, context: &'a RewriteContext<'_>) {\n         self.parent_context = Some(context);\n     }\n \n@@ -255,7 +255,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     // on traits do not get handled here.\n     fn visit_fn(\n         &mut self,\n-        fk: visit::FnKind,\n+        fk: visit::FnKind<'_>,\n         generics: &ast::Generics,\n         fd: &ast::FnDecl,\n         s: Span,\n@@ -593,7 +593,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         self.skipped_range.push((lo, hi));\n     }\n \n-    pub fn from_context(ctx: &'a RewriteContext) -> FmtVisitor<'a> {\n+    pub fn from_context(ctx: &'a RewriteContext<'_>) -> FmtVisitor<'a> {\n         let mut visitor = FmtVisitor::from_source_map(\n             ctx.parse_session,\n             ctx.config,\n@@ -607,7 +607,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn from_source_map(\n         parse_session: &'a ParseSess,\n         config: &'a Config,\n-        snippet_provider: &'a SnippetProvider,\n+        snippet_provider: &'a SnippetProvider<'_>,\n         report: FormatReport,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n@@ -785,7 +785,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     pub fn with_context<F>(&mut self, f: F) -> Option<String>\n     where\n-        F: Fn(&RewriteContext) -> Option<String>,\n+        F: Fn(&RewriteContext<'_>) -> Option<String>,\n     {\n         // FIXME borrow checker fighting - can be simplified a lot with NLL.\n         let (result, mrf) = {\n@@ -799,7 +799,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         result\n     }\n \n-    pub fn get_context(&self) -> RewriteContext {\n+    pub fn get_context(&self) -> RewriteContext<'_> {\n         RewriteContext {\n             parse_session: self.parse_session,\n             source_map: self.source_map,"}]}