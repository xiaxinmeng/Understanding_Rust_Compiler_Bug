{"sha": "df76418f1ee1a1973e862828ae8520abb6c3794a", "node_id": "C_kwDOAAsO6NoAKGRmNzY0MThmMWVlMWExOTczZTg2MjgyOGFlODUyMGFiYjZjMzc5NGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-28T22:44:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-28T22:44:45Z"}, "message": "Auto merge of #90387 - matthiaskrgr:rollup-b2x8v0x, r=matthiaskrgr\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #90082 (Fix minor typos)\n - #90336 (Remove extra lines in examples for `Duration::try_from_secs_*`)\n - #90376 (Various cleanups around opaque types)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6f3b534b310ce25340d17fea15c3b27fb7d4c8b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f3b534b310ce25340d17fea15c3b27fb7d4c8b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df76418f1ee1a1973e862828ae8520abb6c3794a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df76418f1ee1a1973e862828ae8520abb6c3794a", "html_url": "https://github.com/rust-lang/rust/commit/df76418f1ee1a1973e862828ae8520abb6c3794a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df76418f1ee1a1973e862828ae8520abb6c3794a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c390d69a615f095208ac94841f3310268521b2ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c390d69a615f095208ac94841f3310268521b2ee", "html_url": "https://github.com/rust-lang/rust/commit/c390d69a615f095208ac94841f3310268521b2ee"}, {"sha": "bcee0a6ecc19ead117826676243d6d35601f0a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcee0a6ecc19ead117826676243d6d35601f0a07", "html_url": "https://github.com/rust-lang/rust/commit/bcee0a6ecc19ead117826676243d6d35601f0a07"}], "stats": {"total": 1254, "additions": 599, "deletions": 655}, "files": [{"sha": "7e6a481ca69a1b76f62008c1282b3ea676662ac0", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -36,7 +36,6 @@ use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::VariantIdx;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::type_op;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;"}, {"sha": "e2e07f2072e498ea907e7fb176ed0ff9e9d811f2", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 591, "deletions": 1, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -1,8 +1,17 @@\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::traits;\n+use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir as hir;\n-use rustc_middle::ty::{OpaqueTypeKey, Ty};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::ty::fold::BottomUpFolder;\n+use rustc_middle::ty::subst::{GenericArgKind, Subst};\n+use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n+use std::ops::ControlFlow;\n+\n pub type OpaqueTypeMap<'tcx> = VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we\n@@ -45,3 +54,584 @@ pub struct OpaqueTypeDecl<'tcx> {\n     /// The origin of the opaque type.\n     pub origin: hir::OpaqueTyOrigin,\n }\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    /// Replaces all opaque types in `value` with fresh inference variables\n+    /// and creates appropriate obligations. For example, given the input:\n+    ///\n+    ///     impl Iterator<Item = impl Debug>\n+    ///\n+    /// this method would create two type variables, `?0` and `?1`. It would\n+    /// return the type `?0` but also the obligations:\n+    ///\n+    ///     ?0: Iterator<Item = ?1>\n+    ///     ?1: Debug\n+    ///\n+    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n+    /// info about the `impl Iterator<..>` type and `?1` to info about\n+    /// the `impl Debug` type.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n+    ///   is defined\n+    /// - `body_id` -- the body-id with which the resulting obligations should\n+    ///   be associated\n+    /// - `param_env` -- the in-scope parameter environment to be used for\n+    ///   obligations\n+    /// - `value` -- the value within which we are instantiating opaque types\n+    /// - `value_span` -- the span where the value came from, used in error reporting\n+    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+        &self,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: T,\n+        value_span: Span,\n+    ) -> InferOk<'tcx, T> {\n+        debug!(\n+            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n+             param_env={:?}, value_span={:?})\",\n+            value, body_id, param_env, value_span,\n+        );\n+        let mut instantiator =\n+            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n+        let value = instantiator.instantiate_opaque_types_in_map(value);\n+        InferOk { value, obligations: instantiator.obligations }\n+    }\n+\n+    /// Given the map `opaque_types` containing the opaque\n+    /// `impl Trait` types whose underlying, hidden types are being\n+    /// inferred, this method adds constraints to the regions\n+    /// appearing in those underlying hidden types to ensure that they\n+    /// at least do not refer to random scopes within the current\n+    /// function. These constraints are not (quite) sufficient to\n+    /// guarantee that the regions are actually legal values; that\n+    /// final condition is imposed after region inference is done.\n+    ///\n+    /// # The Problem\n+    ///\n+    /// Let's work through an example to explain how it works. Assume\n+    /// the current function is as follows:\n+    ///\n+    /// ```text\n+    /// fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n+    /// ```\n+    ///\n+    /// Here, we have two `impl Trait` types whose values are being\n+    /// inferred (the `impl Bar<'a>` and the `impl\n+    /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n+    /// define underlying opaque types (`Foo1`, `Foo2`) and then, in\n+    /// the return type of `foo`, we *reference* those definitions:\n+    ///\n+    /// ```text\n+    /// type Foo1<'x> = impl Bar<'x>;\n+    /// type Foo2<'x> = impl Bar<'x>;\n+    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n+    ///                    //  ^^^^ ^^\n+    ///                    //  |    |\n+    ///                    //  |    substs\n+    ///                    //  def_id\n+    /// ```\n+    ///\n+    /// As indicating in the comments above, each of those references\n+    /// is (in the compiler) basically a substitution (`substs`)\n+    /// applied to the type of a suitable `def_id` (which identifies\n+    /// `Foo1` or `Foo2`).\n+    ///\n+    /// Now, at this point in compilation, what we have done is to\n+    /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n+    /// fresh inference variables C1 and C2. We wish to use the values\n+    /// of these variables to infer the underlying types of `Foo1` and\n+    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n+    /// constraints like:\n+    ///\n+    /// ```text\n+    /// for<'a> (Foo1<'a> = C1)\n+    /// for<'b> (Foo1<'b> = C2)\n+    /// ```\n+    ///\n+    /// For these equation to be satisfiable, the types `C1` and `C2`\n+    /// can only refer to a limited set of regions. For example, `C1`\n+    /// can only refer to `'static` and `'a`, and `C2` can only refer\n+    /// to `'static` and `'b`. The job of this function is to impose that\n+    /// constraint.\n+    ///\n+    /// Up to this point, C1 and C2 are basically just random type\n+    /// inference variables, and hence they may contain arbitrary\n+    /// regions. In fact, it is fairly likely that they do! Consider\n+    /// this possible definition of `foo`:\n+    ///\n+    /// ```text\n+    /// fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n+    ///         (&*x, &*y)\n+    ///     }\n+    /// ```\n+    ///\n+    /// Here, the values for the concrete types of the two impl\n+    /// traits will include inference variables:\n+    ///\n+    /// ```text\n+    /// &'0 i32\n+    /// &'1 i32\n+    /// ```\n+    ///\n+    /// Ordinarily, the subtyping rules would ensure that these are\n+    /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n+    /// type per se, we don't get such constraints by default. This\n+    /// is where this function comes into play. It adds extra\n+    /// constraints to ensure that all the regions which appear in the\n+    /// inferred type are regions that could validly appear.\n+    ///\n+    /// This is actually a bit of a tricky constraint in general. We\n+    /// want to say that each variable (e.g., `'0`) can only take on\n+    /// values that were supplied as arguments to the opaque type\n+    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n+    /// scope. We don't have a constraint quite of this kind in the current\n+    /// region checker.\n+    ///\n+    /// # The Solution\n+    ///\n+    /// We generally prefer to make `<=` constraints, since they\n+    /// integrate best into the region solver. To do that, we find the\n+    /// \"minimum\" of all the arguments that appear in the substs: that\n+    /// is, some region which is less than all the others. In the case\n+    /// of `Foo1<'a>`, that would be `'a` (it's the only choice, after\n+    /// all). Then we apply that as a least bound to the variables\n+    /// (e.g., `'a <= '0`).\n+    ///\n+    /// In some cases, there is no minimum. Consider this example:\n+    ///\n+    /// ```text\n+    /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n+    /// ```\n+    ///\n+    /// Here we would report a more complex \"in constraint\", like `'r\n+    /// in ['a, 'b, 'static]` (where `'r` is some region appearing in\n+    /// the hidden type).\n+    ///\n+    /// # Constrain regions, not the hidden concrete type\n+    ///\n+    /// Note that generating constraints on each region `Rc` is *not*\n+    /// the same as generating an outlives constraint on `Tc` iself.\n+    /// For example, if we had a function like this:\n+    ///\n+    /// ```rust\n+    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n+    ///   (x, y)\n+    /// }\n+    ///\n+    /// // Equivalent to:\n+    /// type FooReturn<'a, T> = impl Foo<'a>;\n+    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n+    /// ```\n+    ///\n+    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n+    /// is an inference variable). If we generated a constraint that\n+    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n+    /// but this is not necessary, because the opaque type we\n+    /// create will be allowed to reference `T`. So we only generate a\n+    /// constraint that `'0: 'a`.\n+    ///\n+    /// # The `free_region_relations` parameter\n+    ///\n+    /// The `free_region_relations` argument is used to find the\n+    /// \"minimum\" of the regions supplied to a given opaque type.\n+    /// It must be a relation that can answer whether `'a <= 'b`,\n+    /// where `'a` and `'b` are regions that appear in the \"substs\"\n+    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n+    ///\n+    /// Note that we do not impose the constraints based on the\n+    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n+    /// is because the constraints we are imposing here is basically\n+    /// the concern of the one generating the constraining type C1,\n+    /// which is the current function. It also means that we can\n+    /// take \"implied bounds\" into account in some cases:\n+    ///\n+    /// ```text\n+    /// trait SomeTrait<'a, 'b> { }\n+    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n+    /// ```\n+    ///\n+    /// Here, the fact that `'b: 'a` is known only because of the\n+    /// implied bounds from the `&'a &'b u32` parameter, and is not\n+    /// \"inherent\" to the opaque type definition.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n+    /// - `free_region_relations` -- something that can be used to relate\n+    ///   the free regions (`'a`) that appear in the impl trait.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub fn constrain_opaque_type(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+    ) {\n+        let def_id = opaque_type_key.def_id;\n+\n+        let tcx = self.tcx;\n+\n+        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n+\n+        debug!(?concrete_ty);\n+\n+        let first_own_region = match opaque_defn.origin {\n+            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+                // We lower\n+                //\n+                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+                //\n+                // into\n+                //\n+                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+                //\n+                // For these types we only iterate over `'l0..lm` below.\n+                tcx.generics_of(def_id).parent_count\n+            }\n+            // These opaque type inherit all lifetime parameters from their\n+            // parent, so we have to check them all.\n+            hir::OpaqueTyOrigin::TyAlias => 0,\n+        };\n+\n+        // For a case like `impl Foo<'a, 'b>`, we would generate a constraint\n+        // `'r in ['a, 'b, 'static]` for each region `'r` that appears in the\n+        // hidden type (i.e., it must be equal to `'a`, `'b`, or `'static`).\n+        //\n+        // `conflict1` and `conflict2` are the two region bounds that we\n+        // detected which were unrelated. They are used for diagnostics.\n+\n+        // Create the set of choice regions: each region in the hidden\n+        // type can be equal to any of the region parameters of the\n+        // opaque type definition.\n+        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n+            opaque_type_key.substs[first_own_region..]\n+                .iter()\n+                .filter_map(|arg| match arg.unpack() {\n+                    GenericArgKind::Lifetime(r) => Some(r),\n+                    GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n+                })\n+                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n+                .collect(),\n+        );\n+\n+        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n+            op: |r| {\n+                self.member_constraint(\n+                    opaque_type_key.def_id,\n+                    opaque_defn.definition_span,\n+                    concrete_ty,\n+                    r,\n+                    &choice_regions,\n+                )\n+            },\n+        });\n+    }\n+}\n+\n+// Visitor that requires that (almost) all regions in the type visited outlive\n+// `least_region`. We cannot use `push_outlives_components` because regions in\n+// closure signatures are not included in their outlives components. We need to\n+// ensure all regions outlive the given bound so that we don't end up with,\n+// say, `ReVar` appearing in a return type and causing ICEs when other\n+// functions end up with region constraints involving regions from other\n+// functions.\n+//\n+// We also cannot use `for_each_free_region` because for closures it includes\n+// the regions parameters from the enclosing item.\n+//\n+// We ignore any type parameters because impl trait values are assumed to\n+// capture all the in-scope type parameters.\n+struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n+    tcx: TyCtxt<'tcx>,\n+    op: OP,\n+}\n+\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n+where\n+    OP: FnMut(ty::Region<'tcx>),\n+{\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &ty::Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        t.as_ref().skip_binder().visit_with(self);\n+        ControlFlow::CONTINUE\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match *r {\n+            // ignore bound regions, keep visiting\n+            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n+            _ => {\n+                (self.op)(r);\n+                ControlFlow::CONTINUE\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        // We're only interested in types involving regions\n+        if !ty.flags().intersects(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n+            return ControlFlow::CONTINUE;\n+        }\n+\n+        match ty.kind() {\n+            ty::Closure(_, ref substs) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+\n+                substs.as_closure().tupled_upvars_ty().visit_with(self);\n+                substs.as_closure().sig_as_fn_ptr_ty().visit_with(self);\n+            }\n+\n+            ty::Generator(_, ref substs, _) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+                // Also skip the witness type, because that has no free regions.\n+\n+                substs.as_generator().tupled_upvars_ty().visit_with(self);\n+                substs.as_generator().return_ty().visit_with(self);\n+                substs.as_generator().yield_ty().visit_with(self);\n+                substs.as_generator().resume_ty().visit_with(self);\n+            }\n+            _ => {\n+                ty.super_visit_with(self);\n+            }\n+        }\n+\n+        ControlFlow::CONTINUE\n+    }\n+}\n+\n+struct Instantiator<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    body_id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value_span: Span,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+}\n+\n+impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n+    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n+        let tcx = self.infcx.tcx;\n+        value.fold_with(&mut BottomUpFolder {\n+            tcx,\n+            ty_op: |ty| {\n+                if ty.references_error() {\n+                    return tcx.ty_error();\n+                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    if let Some(def_id) = def_id.as_local() {\n+                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+                        let parent_def_id = self.infcx.defining_use_anchor;\n+                        let def_scope_default = || {\n+                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n+                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n+                        };\n+                        let (in_definition_scope, origin) =\n+                            match tcx.hir().expect_item(opaque_hir_id).kind {\n+                                // Anonymous `impl Trait`\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                    impl_trait_fn: Some(parent),\n+                                    origin,\n+                                    ..\n+                                }) => (parent == parent_def_id.to_def_id(), origin),\n+                                // Named `type Foo = impl Bar;`\n+                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n+                                    impl_trait_fn: None,\n+                                    origin,\n+                                    ..\n+                                }) => (\n+                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n+                                    origin,\n+                                ),\n+                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n+                            };\n+                        if in_definition_scope {\n+                            let opaque_type_key =\n+                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n+                        }\n+\n+                        debug!(\n+                            \"instantiate_opaque_types_in_map: \\\n+                             encountered opaque outside its definition scope \\\n+                             def_id={:?}\",\n+                            def_id,\n+                        );\n+                    }\n+                }\n+\n+                ty\n+            },\n+            lt_op: |lt| lt,\n+            ct_op: |ct| ct,\n+        })\n+    }\n+\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn fold_opaque_ty(\n+        &mut self,\n+        ty: Ty<'tcx>,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        origin: hir::OpaqueTyOrigin,\n+    ) -> Ty<'tcx> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n+\n+        // Use the same type variable if the exact same opaque type appears more\n+        // than once in the return type (e.g., if it's passed to a type alias).\n+        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n+            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n+            return opaque_defn.concrete_ty;\n+        }\n+\n+        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::TypeInference,\n+            span: self.value_span,\n+        });\n+\n+        // Ideally, we'd get the span where *this specific `ty` came\n+        // from*, but right now we just use the span from the overall\n+        // value being folded. In simple cases like `-> impl Foo`,\n+        // these are the same span, but not in cases like `-> (impl\n+        // Foo, impl Bar)`.\n+        let definition_span = self.value_span;\n+\n+        {\n+            let mut infcx = self.infcx.inner.borrow_mut();\n+            infcx.opaque_types.insert(\n+                OpaqueTypeKey { def_id, substs },\n+                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n+            );\n+            infcx.opaque_types_vars.insert(ty_var, ty);\n+        }\n+\n+        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n+\n+        let item_bounds = tcx.explicit_item_bounds(def_id);\n+\n+        self.obligations.reserve(item_bounds.len());\n+        for (predicate, _) in item_bounds {\n+            debug!(?predicate);\n+            let predicate = predicate.subst(tcx, substs);\n+            debug!(?predicate);\n+\n+            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n+            let predicate = predicate.fold_with(&mut BottomUpFolder {\n+                tcx,\n+                ty_op: |ty| match ty.kind() {\n+                    ty::Projection(projection_ty) => infcx.infer_projection(\n+                        self.param_env,\n+                        *projection_ty,\n+                        traits::ObligationCause::misc(self.value_span, self.body_id),\n+                        0,\n+                        &mut self.obligations,\n+                    ),\n+                    _ => ty,\n+                },\n+                lt_op: |lt| lt,\n+                ct_op: |ct| ct,\n+            });\n+            debug!(?predicate);\n+\n+            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n+                if projection.ty.references_error() {\n+                    // No point on adding these obligations since there's a type error involved.\n+                    return tcx.ty_error();\n+                }\n+            }\n+            // Change the predicate to refer to the type variable,\n+            // which will be the concrete type instead of the opaque type.\n+            // This also instantiates nested instances of `impl Trait`.\n+            let predicate = self.instantiate_opaque_types_in_map(predicate);\n+\n+            let cause =\n+                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n+\n+            // Require that the predicate holds for the concrete type.\n+            debug!(?predicate);\n+            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n+        }\n+\n+        ty_var\n+    }\n+}\n+\n+/// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n+///\n+/// Example:\n+/// ```rust\n+/// pub mod foo {\n+///     pub mod bar {\n+///         pub trait Bar { .. }\n+///\n+///         pub type Baz = impl Bar;\n+///\n+///         fn f1() -> Baz { .. }\n+///     }\n+///\n+///     fn f2() -> bar::Baz { .. }\n+/// }\n+/// ```\n+///\n+/// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n+/// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n+/// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n+fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hir::HirId) -> bool {\n+    let mut hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+    // Named opaque types can be defined by any siblings or children of siblings.\n+    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n+    // We walk up the node tree until we hit the root or the scope of the opaque type.\n+    while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n+        hir_id = tcx.hir().get_parent_item(hir_id);\n+    }\n+    // Syntactically, we are allowed to define the concrete type if:\n+    let res = hir_id == scope;\n+    trace!(\n+        \"may_define_opaque_type(def={:?}, opaque_node={:?}) = {}\",\n+        tcx.hir().find(hir_id),\n+        tcx.hir().get(opaque_hir_id),\n+        res\n+    );\n+    res\n+}"}, {"sha": "75d57d78e3b0294be8d2138590248c775ddb6048", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 6, "deletions": 642, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -1,45 +1,14 @@\n-use crate::traits::{self, ObligationCause, PredicateObligation};\n+use crate::traits;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::DefId;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{InferCtxt, InferOk};\n-use rustc_middle::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst};\n+use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt};\n use rustc_span::Span;\n \n-use std::ops::ControlFlow;\n-\n pub trait InferCtxtExt<'tcx> {\n-    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n-        &self,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-        value_span: Span,\n-    ) -> InferOk<'tcx, T>;\n-\n-    fn constrain_opaque_types(&self);\n-\n-    fn constrain_opaque_type(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-    );\n-\n-    /*private*/\n-    fn generate_member_constraint(\n-        &self,\n-        concrete_ty: Ty<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        first_own_region_index: usize,\n-    );\n-\n     fn infer_opaque_definition_from_instantiation(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n@@ -49,305 +18,6 @@ pub trait InferCtxtExt<'tcx> {\n }\n \n impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n-    /// Replaces all opaque types in `value` with fresh inference variables\n-    /// and creates appropriate obligations. For example, given the input:\n-    ///\n-    ///     impl Iterator<Item = impl Debug>\n-    ///\n-    /// this method would create two type variables, `?0` and `?1`. It would\n-    /// return the type `?0` but also the obligations:\n-    ///\n-    ///     ?0: Iterator<Item = ?1>\n-    ///     ?1: Debug\n-    ///\n-    /// Moreover, it returns an `OpaqueTypeMap` that would map `?0` to\n-    /// info about the `impl Iterator<..>` type and `?1` to info about\n-    /// the `impl Debug` type.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `parent_def_id` -- the `DefId` of the function in which the opaque type\n-    ///   is defined\n-    /// - `body_id` -- the body-id with which the resulting obligations should\n-    ///   be associated\n-    /// - `param_env` -- the in-scope parameter environment to be used for\n-    ///   obligations\n-    /// - `value` -- the value within which we are instantiating opaque types\n-    /// - `value_span` -- the span where the value came from, used in error reporting\n-    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n-        &self,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: T,\n-        value_span: Span,\n-    ) -> InferOk<'tcx, T> {\n-        debug!(\n-            \"instantiate_opaque_types(value={:?}, body_id={:?}, \\\n-             param_env={:?}, value_span={:?})\",\n-            value, body_id, param_env, value_span,\n-        );\n-        let mut instantiator =\n-            Instantiator { infcx: self, body_id, param_env, value_span, obligations: vec![] };\n-        let value = instantiator.instantiate_opaque_types_in_map(value);\n-        InferOk { value, obligations: instantiator.obligations }\n-    }\n-\n-    /// Given the map `opaque_types` containing the opaque\n-    /// `impl Trait` types whose underlying, hidden types are being\n-    /// inferred, this method adds constraints to the regions\n-    /// appearing in those underlying hidden types to ensure that they\n-    /// at least do not refer to random scopes within the current\n-    /// function. These constraints are not (quite) sufficient to\n-    /// guarantee that the regions are actually legal values; that\n-    /// final condition is imposed after region inference is done.\n-    ///\n-    /// # The Problem\n-    ///\n-    /// Let's work through an example to explain how it works. Assume\n-    /// the current function is as follows:\n-    ///\n-    /// ```text\n-    /// fn foo<'a, 'b>(..) -> (impl Bar<'a>, impl Bar<'b>)\n-    /// ```\n-    ///\n-    /// Here, we have two `impl Trait` types whose values are being\n-    /// inferred (the `impl Bar<'a>` and the `impl\n-    /// Bar<'b>`). Conceptually, this is sugar for a setup where we\n-    /// define underlying opaque types (`Foo1`, `Foo2`) and then, in\n-    /// the return type of `foo`, we *reference* those definitions:\n-    ///\n-    /// ```text\n-    /// type Foo1<'x> = impl Bar<'x>;\n-    /// type Foo2<'x> = impl Bar<'x>;\n-    /// fn foo<'a, 'b>(..) -> (Foo1<'a>, Foo2<'b>) { .. }\n-    ///                    //  ^^^^ ^^\n-    ///                    //  |    |\n-    ///                    //  |    substs\n-    ///                    //  def_id\n-    /// ```\n-    ///\n-    /// As indicating in the comments above, each of those references\n-    /// is (in the compiler) basically a substitution (`substs`)\n-    /// applied to the type of a suitable `def_id` (which identifies\n-    /// `Foo1` or `Foo2`).\n-    ///\n-    /// Now, at this point in compilation, what we have done is to\n-    /// replace each of the references (`Foo1<'a>`, `Foo2<'b>`) with\n-    /// fresh inference variables C1 and C2. We wish to use the values\n-    /// of these variables to infer the underlying types of `Foo1` and\n-    /// `Foo2`. That is, this gives rise to higher-order (pattern) unification\n-    /// constraints like:\n-    ///\n-    /// ```text\n-    /// for<'a> (Foo1<'a> = C1)\n-    /// for<'b> (Foo1<'b> = C2)\n-    /// ```\n-    ///\n-    /// For these equation to be satisfiable, the types `C1` and `C2`\n-    /// can only refer to a limited set of regions. For example, `C1`\n-    /// can only refer to `'static` and `'a`, and `C2` can only refer\n-    /// to `'static` and `'b`. The job of this function is to impose that\n-    /// constraint.\n-    ///\n-    /// Up to this point, C1 and C2 are basically just random type\n-    /// inference variables, and hence they may contain arbitrary\n-    /// regions. In fact, it is fairly likely that they do! Consider\n-    /// this possible definition of `foo`:\n-    ///\n-    /// ```text\n-    /// fn foo<'a, 'b>(x: &'a i32, y: &'b i32) -> (impl Bar<'a>, impl Bar<'b>) {\n-    ///         (&*x, &*y)\n-    ///     }\n-    /// ```\n-    ///\n-    /// Here, the values for the concrete types of the two impl\n-    /// traits will include inference variables:\n-    ///\n-    /// ```text\n-    /// &'0 i32\n-    /// &'1 i32\n-    /// ```\n-    ///\n-    /// Ordinarily, the subtyping rules would ensure that these are\n-    /// sufficiently large. But since `impl Bar<'a>` isn't a specific\n-    /// type per se, we don't get such constraints by default. This\n-    /// is where this function comes into play. It adds extra\n-    /// constraints to ensure that all the regions which appear in the\n-    /// inferred type are regions that could validly appear.\n-    ///\n-    /// This is actually a bit of a tricky constraint in general. We\n-    /// want to say that each variable (e.g., `'0`) can only take on\n-    /// values that were supplied as arguments to the opaque type\n-    /// (e.g., `'a` for `Foo1<'a>`) or `'static`, which is always in\n-    /// scope. We don't have a constraint quite of this kind in the current\n-    /// region checker.\n-    ///\n-    /// # The Solution\n-    ///\n-    /// We generally prefer to make `<=` constraints, since they\n-    /// integrate best into the region solver. To do that, we find the\n-    /// \"minimum\" of all the arguments that appear in the substs: that\n-    /// is, some region which is less than all the others. In the case\n-    /// of `Foo1<'a>`, that would be `'a` (it's the only choice, after\n-    /// all). Then we apply that as a least bound to the variables\n-    /// (e.g., `'a <= '0`).\n-    ///\n-    /// In some cases, there is no minimum. Consider this example:\n-    ///\n-    /// ```text\n-    /// fn baz<'a, 'b>() -> impl Trait<'a, 'b> { ... }\n-    /// ```\n-    ///\n-    /// Here we would report a more complex \"in constraint\", like `'r\n-    /// in ['a, 'b, 'static]` (where `'r` is some region appearing in\n-    /// the hidden type).\n-    ///\n-    /// # Constrain regions, not the hidden concrete type\n-    ///\n-    /// Note that generating constraints on each region `Rc` is *not*\n-    /// the same as generating an outlives constraint on `Tc` iself.\n-    /// For example, if we had a function like this:\n-    ///\n-    /// ```rust\n-    /// fn foo<'a, T>(x: &'a u32, y: T) -> impl Foo<'a> {\n-    ///   (x, y)\n-    /// }\n-    ///\n-    /// // Equivalent to:\n-    /// type FooReturn<'a, T> = impl Foo<'a>;\n-    /// fn foo<'a, T>(..) -> FooReturn<'a, T> { .. }\n-    /// ```\n-    ///\n-    /// then the hidden type `Tc` would be `(&'0 u32, T)` (where `'0`\n-    /// is an inference variable). If we generated a constraint that\n-    /// `Tc: 'a`, then this would incorrectly require that `T: 'a` --\n-    /// but this is not necessary, because the opaque type we\n-    /// create will be allowed to reference `T`. So we only generate a\n-    /// constraint that `'0: 'a`.\n-    ///\n-    /// # The `free_region_relations` parameter\n-    ///\n-    /// The `free_region_relations` argument is used to find the\n-    /// \"minimum\" of the regions supplied to a given opaque type.\n-    /// It must be a relation that can answer whether `'a <= 'b`,\n-    /// where `'a` and `'b` are regions that appear in the \"substs\"\n-    /// for the opaque type references (the `<'a>` in `Foo1<'a>`).\n-    ///\n-    /// Note that we do not impose the constraints based on the\n-    /// generic regions from the `Foo1` definition (e.g., `'x`). This\n-    /// is because the constraints we are imposing here is basically\n-    /// the concern of the one generating the constraining type C1,\n-    /// which is the current function. It also means that we can\n-    /// take \"implied bounds\" into account in some cases:\n-    ///\n-    /// ```text\n-    /// trait SomeTrait<'a, 'b> { }\n-    /// fn foo<'a, 'b>(_: &'a &'b u32) -> impl SomeTrait<'a, 'b> { .. }\n-    /// ```\n-    ///\n-    /// Here, the fact that `'b: 'a` is known only because of the\n-    /// implied bounds from the `&'a &'b u32` parameter, and is not\n-    /// \"inherent\" to the opaque type definition.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n-    /// - `free_region_relations` -- something that can be used to relate\n-    ///   the free regions (`'a`) that appear in the impl trait.\n-    fn constrain_opaque_types(&self) {\n-        let opaque_types = self.inner.borrow().opaque_types.clone();\n-        for (opaque_type_key, opaque_defn) in opaque_types {\n-            self.constrain_opaque_type(opaque_type_key, &opaque_defn);\n-        }\n-    }\n-\n-    /// See `constrain_opaque_types` for documentation.\n-    #[instrument(level = \"debug\", skip(self))]\n-    fn constrain_opaque_type(\n-        &self,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-    ) {\n-        let def_id = opaque_type_key.def_id;\n-\n-        let tcx = self.tcx;\n-\n-        let concrete_ty = self.resolve_vars_if_possible(opaque_defn.concrete_ty);\n-\n-        debug!(?concrete_ty);\n-\n-        let first_own_region = match opaque_defn.origin {\n-            hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n-                // We lower\n-                //\n-                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-                //\n-                // into\n-                //\n-                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-                //\n-                // For these types we only iterate over `'l0..lm` below.\n-                tcx.generics_of(def_id).parent_count\n-            }\n-            // These opaque type inherit all lifetime parameters from their\n-            // parent, so we have to check them all.\n-            hir::OpaqueTyOrigin::TyAlias => 0,\n-        };\n-\n-        // The regions that appear in the hidden type must be equal to\n-        // one of the regions in scope for the opaque type.\n-        self.generate_member_constraint(\n-            concrete_ty,\n-            opaque_defn,\n-            opaque_type_key,\n-            first_own_region,\n-        );\n-    }\n-\n-    /// As a fallback, we sometimes generate an \"in constraint\". For\n-    /// a case like `impl Foo<'a, 'b>`, where `'a` and `'b` cannot be\n-    /// related, we would generate a constraint `'r in ['a, 'b,\n-    /// 'static]` for each region `'r` that appears in the hidden type\n-    /// (i.e., it must be equal to `'a`, `'b`, or `'static`).\n-    ///\n-    /// `conflict1` and `conflict2` are the two region bounds that we\n-    /// detected which were unrelated. They are used for diagnostics.\n-    fn generate_member_constraint(\n-        &self,\n-        concrete_ty: Ty<'tcx>,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        first_own_region: usize,\n-    ) {\n-        // Create the set of choice regions: each region in the hidden\n-        // type can be equal to any of the region parameters of the\n-        // opaque type definition.\n-        let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_key.substs[first_own_region..]\n-                .iter()\n-                .filter_map(|arg| match arg.unpack() {\n-                    GenericArgKind::Lifetime(r) => Some(r),\n-                    GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n-                })\n-                .chain(std::iter::once(self.tcx.lifetimes.re_static))\n-                .collect(),\n-        );\n-\n-        concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n-            tcx: self.tcx,\n-            op: |r| {\n-                self.member_constraint(\n-                    opaque_type_key.def_id,\n-                    opaque_defn.definition_span,\n-                    concrete_ty,\n-                    r,\n-                    &choice_regions,\n-                )\n-            },\n-        });\n-    }\n-\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an opaque type\n@@ -363,7 +33,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// purpose of this function is to do that translation.\n     ///\n     /// (*) C1 and C2 were introduced in the comments on\n-    /// `constrain_opaque_types`. Read that comment for more context.\n+    /// `constrain_opaque_type`. Read that comment for more context.\n     ///\n     /// # Parameters\n     ///\n@@ -409,83 +79,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n }\n \n-// Visitor that requires that (almost) all regions in the type visited outlive\n-// `least_region`. We cannot use `push_outlives_components` because regions in\n-// closure signatures are not included in their outlives components. We need to\n-// ensure all regions outlive the given bound so that we don't end up with,\n-// say, `ReVar` appearing in a return type and causing ICEs when other\n-// functions end up with region constraints involving regions from other\n-// functions.\n-//\n-// We also cannot use `for_each_free_region` because for closures it includes\n-// the regions parameters from the enclosing item.\n-//\n-// We ignore any type parameters because impl trait values are assumed to\n-// capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n-    tcx: TyCtxt<'tcx>,\n-    op: OP,\n-}\n-\n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n-where\n-    OP: FnMut(ty::Region<'tcx>),\n-{\n-    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n-        Some(self.tcx)\n-    }\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &ty::Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        t.as_ref().skip_binder().visit_with(self);\n-        ControlFlow::CONTINUE\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match *r {\n-            // ignore bound regions, keep visiting\n-            ty::ReLateBound(_, _) => ControlFlow::CONTINUE,\n-            _ => {\n-                (self.op)(r);\n-                ControlFlow::CONTINUE\n-            }\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        // We're only interested in types involving regions\n-        if !ty.flags().intersects(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n-            return ControlFlow::CONTINUE;\n-        }\n-\n-        match ty.kind() {\n-            ty::Closure(_, ref substs) => {\n-                // Skip lifetime parameters of the enclosing item(s)\n-\n-                substs.as_closure().tupled_upvars_ty().visit_with(self);\n-                substs.as_closure().sig_as_fn_ptr_ty().visit_with(self);\n-            }\n-\n-            ty::Generator(_, ref substs, _) => {\n-                // Skip lifetime parameters of the enclosing item(s)\n-                // Also skip the witness type, because that has no free regions.\n-\n-                substs.as_generator().tupled_upvars_ty().visit_with(self);\n-                substs.as_generator().return_ty().visit_with(self);\n-                substs.as_generator().yield_ty().visit_with(self);\n-                substs.as_generator().resume_ty().visit_with(self);\n-            }\n-            _ => {\n-                ty.super_visit_with(self);\n-            }\n-        }\n-\n-        ControlFlow::CONTINUE\n-    }\n-}\n-\n struct ReverseMapper<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n@@ -728,235 +321,6 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n     }\n }\n \n-struct Instantiator<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    body_id: hir::HirId,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value_span: Span,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n-    fn instantiate_opaque_types_in_map<T: TypeFoldable<'tcx>>(&mut self, value: T) -> T {\n-        let tcx = self.infcx.tcx;\n-        value.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            ty_op: |ty| {\n-                if ty.references_error() {\n-                    return tcx.ty_error();\n-                } else if let ty::Opaque(def_id, substs) = ty.kind() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let def_scope_default = || {\n-                            let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n-                            parent_def_id == tcx.hir().local_def_id(opaque_parent_hir_id)\n-                        };\n-                        let (in_definition_scope, origin) =\n-                            match tcx.hir().expect_item(opaque_hir_id).kind {\n-                                // Anonymous `impl Trait`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: Some(parent),\n-                                    origin,\n-                                    ..\n-                                }) => (parent == parent_def_id.to_def_id(), origin),\n-                                // Named `type Foo = impl Bar;`\n-                                hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                    impl_trait_fn: None,\n-                                    origin,\n-                                    ..\n-                                }) => (\n-                                    may_define_opaque_type(tcx, parent_def_id, opaque_hir_id),\n-                                    origin,\n-                                ),\n-                                _ => (def_scope_default(), hir::OpaqueTyOrigin::TyAlias),\n-                            };\n-                        if in_definition_scope {\n-                            let opaque_type_key =\n-                                OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n-                        }\n-\n-                        debug!(\n-                            \"instantiate_opaque_types_in_map: \\\n-                             encountered opaque outside its definition scope \\\n-                             def_id={:?}\",\n-                            def_id,\n-                        );\n-                    }\n-                }\n-\n-                ty\n-            },\n-            lt_op: |lt| lt,\n-            ct_op: |ct| ct,\n-        })\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_opaque_ty(\n-        &mut self,\n-        ty: Ty<'tcx>,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n-        origin: hir::OpaqueTyOrigin,\n-    ) -> Ty<'tcx> {\n-        let infcx = self.infcx;\n-        let tcx = infcx.tcx;\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use the same type variable if the exact same opaque type appears more\n-        // than once in the return type (e.g., if it's passed to a type alias).\n-        if let Some(opaque_defn) = infcx.inner.borrow().opaque_types.get(&opaque_type_key) {\n-            debug!(\"re-using cached concrete type {:?}\", opaque_defn.concrete_ty.kind());\n-            return opaque_defn.concrete_ty;\n-        }\n-\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::TypeInference,\n-            span: self.value_span,\n-        });\n-\n-        // Ideally, we'd get the span where *this specific `ty` came\n-        // from*, but right now we just use the span from the overall\n-        // value being folded. In simple cases like `-> impl Foo`,\n-        // these are the same span, but not in cases like `-> (impl\n-        // Foo, impl Bar)`.\n-        let definition_span = self.value_span;\n-\n-        {\n-            let mut infcx = self.infcx.inner.borrow_mut();\n-            infcx.opaque_types.insert(\n-                OpaqueTypeKey { def_id, substs },\n-                OpaqueTypeDecl { opaque_type: ty, definition_span, concrete_ty: ty_var, origin },\n-            );\n-            infcx.opaque_types_vars.insert(ty_var, ty);\n-        }\n-\n-        debug!(\"generated new type inference var {:?}\", ty_var.kind());\n-\n-        let item_bounds = tcx.explicit_item_bounds(def_id);\n-\n-        self.obligations.reserve(item_bounds.len());\n-        for (predicate, _) in item_bounds {\n-            debug!(?predicate);\n-            let predicate = predicate.subst(tcx, substs);\n-            debug!(?predicate);\n-\n-            // We can't normalize associated types from `rustc_infer`, but we can eagerly register inference variables for them.\n-            let predicate = predicate.fold_with(&mut BottomUpFolder {\n-                tcx,\n-                ty_op: |ty| match ty.kind() {\n-                    ty::Projection(projection_ty) => infcx.infer_projection(\n-                        self.param_env,\n-                        *projection_ty,\n-                        ObligationCause::misc(self.value_span, self.body_id),\n-                        0,\n-                        &mut self.obligations,\n-                    ),\n-                    _ => ty,\n-                },\n-                lt_op: |lt| lt,\n-                ct_op: |ct| ct,\n-            });\n-            debug!(?predicate);\n-\n-            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n-                if projection.ty.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n-                    return tcx.ty_error();\n-                }\n-            }\n-            // Change the predicate to refer to the type variable,\n-            // which will be the concrete type instead of the opaque type.\n-            // This also instantiates nested instances of `impl Trait`.\n-            let predicate = self.instantiate_opaque_types_in_map(predicate);\n-\n-            let cause =\n-                traits::ObligationCause::new(self.value_span, self.body_id, traits::OpaqueType);\n-\n-            // Require that the predicate holds for the concrete type.\n-            debug!(?predicate);\n-            self.obligations.push(traits::Obligation::new(cause, self.param_env, predicate));\n-        }\n-\n-        ty_var\n-    }\n-}\n-\n-/// Returns `true` if `opaque_hir_id` is a sibling or a child of a sibling of `def_id`.\n-///\n-/// Example:\n-/// ```rust\n-/// pub mod foo {\n-///     pub mod bar {\n-///         pub trait Bar { .. }\n-///\n-///         pub type Baz = impl Bar;\n-///\n-///         fn f1() -> Baz { .. }\n-///     }\n-///\n-///     fn f2() -> bar::Baz { .. }\n-/// }\n-/// ```\n-///\n-/// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n-/// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n-/// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n-fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hir::HirId) -> bool {\n-    let mut hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-    // Named opaque types can be defined by any siblings or children of siblings.\n-    let scope = tcx.hir().get_defining_scope(opaque_hir_id);\n-    // We walk up the node tree until we hit the root or the scope of the opaque type.\n-    while hir_id != scope && hir_id != hir::CRATE_HIR_ID {\n-        hir_id = tcx.hir().get_parent_item(hir_id);\n-    }\n-    // Syntactically, we are allowed to define the concrete type if:\n-    let res = hir_id == scope;\n-    trace!(\n-        \"may_define_opaque_type(def={:?}, opaque_node={:?}) = {}\",\n-        tcx.hir().find(hir_id),\n-        tcx.hir().get(opaque_hir_id),\n-        res\n-    );\n-    res\n-}\n-\n /// Given a set of predicates that apply to an object type, returns\n /// the region bounds that the (erased) `Self` type must\n /// outlive. Precisely *because* the `Self` type is erased, the"}, {"sha": "a8160313228b6381b02f6e1633fce45ae07e639b", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -6,7 +6,6 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::traits::Obligation;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyS};\n use rustc_span::{MultiSpan, Span};\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,"}, {"sha": "5040c4db95163a48473aace18608b6d7a7d55623", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -21,7 +21,6 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, MultiSpan, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_ty_utils::representability::{self, Representability};"}, {"sha": "5179b425f88e2eb54c45d496f9cd0ff8e92846d5", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -35,7 +35,6 @@ use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,"}, {"sha": "230a576046a479c9dcf5d296bd7209789bd6d753", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -88,7 +88,6 @@ use rustc_middle::hir::place::{PlaceBase, PlaceWithHirId};\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n-use rustc_trait_selection::opaque_types::InferCtxtExt as _;\n use std::ops::Deref;\n \n // a variation on try that just returns unit\n@@ -340,8 +339,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.link_fn_params(body.params);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n-\n-        self.constrain_opaque_types();\n     }\n \n     fn visit_region_obligations(&mut self, hir_id: hir::HirId) {"}, {"sha": "80220a1ecb2bafe388273baee42ec177f98dd8af", "filename": "library/core/src/time.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -737,7 +737,6 @@ impl Duration {\n     /// # Examples\n     /// ```\n     /// #![feature(duration_checked_float)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::try_from_secs_f64(2.7);\n@@ -799,7 +798,6 @@ impl Duration {\n     /// # Examples\n     /// ```\n     /// #![feature(duration_checked_float)]\n-    ///\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::try_from_secs_f32(2.7);\n@@ -1258,7 +1256,6 @@ impl fmt::Debug for Duration {\n ///\n /// ```\n /// #![feature(duration_checked_float)]\n-///\n /// use std::time::Duration;\n ///\n /// if let Err(e) = Duration::try_from_secs_f32(-1.0) {"}, {"sha": "bd7234522e1fec2f73d130aa6b8b1e7102de3a0c", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df76418f1ee1a1973e862828ae8520abb6c3794a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/df76418f1ee1a1973e862828ae8520abb6c3794a/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=df76418f1ee1a1973e862828ae8520abb6c3794a", "patch": "@@ -66,7 +66,7 @@ assert_eq!(x, 5);\n This will write the value `5` into the `u64` variable `x`.\n You can see that the string literal we use to specify instructions is actually a template string.\n It is governed by the same rules as Rust [format strings][format-syntax].\n-The arguments that are inserted into the template however look a bit different then you may\n+The arguments that are inserted into the template however look a bit different than you may\n be familiar with. First we need to specify if the variable is an input or an output of the\n inline assembly. In this case it is an output. We declared this by writing `out`.\n We also need to specify in what kind of register the assembly expects the variable.\n@@ -106,7 +106,7 @@ code.\n Second, we can see that inputs are declared by writing `in` instead of `out`.\n \n Third, one of our operands has a type we haven't seen yet, `const`.\n-This tells the compiler to expand this argument to value directly inside the assembly template.\n+This tells the compiler to expand this argument to a value directly inside the assembly template.\n This is only possible for constants and literals.\n \n Fourth, we can see that we can specify an argument number, or name as in any format string."}]}