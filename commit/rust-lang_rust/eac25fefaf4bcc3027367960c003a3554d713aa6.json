{"sha": "eac25fefaf4bcc3027367960c003a3554d713aa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhYzI1ZmVmYWY0YmNjMzAyNzM2Nzk2MGMwMDNhMzU1NGQ3MTNhYTY=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-06T07:26:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-06T07:26:02Z"}, "message": "Rollup merge of #77528 - tamird:avoid-cast-net-parser, r=dtolnay\n\nAvoid unchecked casts in net parser\n\nOnce this and #77426 are in, I'll send another PR adding scope id parsing.\n\nr? @dtolnay", "tree": {"sha": "c7f181f049561590af46c2e0da75fb8140ffccd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7f181f049561590af46c2e0da75fb8140ffccd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eac25fefaf4bcc3027367960c003a3554d713aa6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffBwKCRBK7hj4Ov3rIwAAdHIIAD8x6cL3cn6Z4O7w116yrc81\naoO/E2VAPQoYJDLIuxpxt4KveuLIcz8gBHdIS2o0n1FWCXuZTly1D8VrOo7fYjY9\nY89sJh3oSNFYyfO+Xlz5lbfNCQnVQR0REjhdr1meBYZG+zoIZJu6KZqdLhrjzU2F\n286H+kuMeO0QeM6E5yzC6I2gR0DXCcpyGw2E6X8og+zlUcyUcRPe/+iKdCWgO9nh\nVreSCH+OfXie7FOn/6COvJgPbCHOq78LaJsBOy56C8krkJ03IQFH126nEqXdiAAC\nS1UlG214knpvH265J18UJ5t7kWiMk3jnR8Qgde8+EqJ7dCOAzwfQR+u6gCkCdDk=\n=Nn7l\n-----END PGP SIGNATURE-----\n", "payload": "tree c7f181f049561590af46c2e0da75fb8140ffccd4\nparent d7123c2393462447e30f62c8a785754677cc00da\nparent f78a7ade61c1c218eead76854abb7d83bb6c6f75\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1601969162 +0900\ncommitter GitHub <noreply@github.com> 1601969162 +0900\n\nRollup merge of #77528 - tamird:avoid-cast-net-parser, r=dtolnay\n\nAvoid unchecked casts in net parser\n\nOnce this and #77426 are in, I'll send another PR adding scope id parsing.\n\nr? @dtolnay\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eac25fefaf4bcc3027367960c003a3554d713aa6", "html_url": "https://github.com/rust-lang/rust/commit/eac25fefaf4bcc3027367960c003a3554d713aa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eac25fefaf4bcc3027367960c003a3554d713aa6/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7123c2393462447e30f62c8a785754677cc00da", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7123c2393462447e30f62c8a785754677cc00da", "html_url": "https://github.com/rust-lang/rust/commit/d7123c2393462447e30f62c8a785754677cc00da"}, {"sha": "f78a7ade61c1c218eead76854abb7d83bb6c6f75", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78a7ade61c1c218eead76854abb7d83bb6c6f75", "html_url": "https://github.com/rust-lang/rust/commit/f78a7ade61c1c218eead76854abb7d83bb6c6f75"}], "stats": {"total": 84, "additions": 48, "deletions": 36}, "files": [{"sha": "3a5fd8f6f5d0ed371a5e6208f62dfee485de0f74", "filename": "library/std/src/net/parser.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/eac25fefaf4bcc3027367960c003a3554d713aa6/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eac25fefaf4bcc3027367960c003a3554d713aa6/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fparser.rs?ref=eac25fefaf4bcc3027367960c003a3554d713aa6", "patch": "@@ -6,11 +6,34 @@\n #[cfg(test)]\n mod tests;\n \n+use crate::convert::TryInto as _;\n use crate::error::Error;\n use crate::fmt;\n use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n use crate::str::FromStr;\n \n+trait ReadNumberHelper: crate::marker::Sized {\n+    const ZERO: Self;\n+    fn checked_mul(&self, other: u32) -> Option<Self>;\n+    fn checked_add(&self, other: u32) -> Option<Self>;\n+}\n+\n+macro_rules! impl_helper {\n+    ($($t:ty)*) => ($(impl ReadNumberHelper for $t {\n+        const ZERO: Self = 0;\n+        #[inline]\n+        fn checked_mul(&self, other: u32) -> Option<Self> {\n+            Self::checked_mul(*self, other.try_into().ok()?)\n+        }\n+        #[inline]\n+        fn checked_add(&self, other: u32) -> Option<Self> {\n+            Self::checked_add(*self, other.try_into().ok()?)\n+        }\n+    })*)\n+}\n+\n+impl_helper! { u8 u16 }\n+\n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n     state: &'a [u8],\n@@ -21,10 +44,6 @@ impl<'a> Parser<'a> {\n         Parser { state: input.as_bytes() }\n     }\n \n-    fn is_eof(&self) -> bool {\n-        self.state.is_empty()\n-    }\n-\n     /// Run a parser, and restore the pre-parse state if it fails\n     fn read_atomically<T, F>(&mut self, inner: F) -> Option<T>\n     where\n@@ -40,26 +59,19 @@ impl<'a> Parser<'a> {\n \n     /// Run a parser, but fail if the entire input wasn't consumed.\n     /// Doesn't run atomically.\n-    fn read_till_eof<T, F>(&mut self, inner: F) -> Option<T>\n-    where\n-        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n-    {\n-        inner(self).filter(|_| self.is_eof())\n-    }\n-\n-    /// Same as read_till_eof, but returns a Result<AddrParseError> on failure\n     fn parse_with<T, F>(&mut self, inner: F) -> Result<T, AddrParseError>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_till_eof(inner).ok_or(AddrParseError(()))\n+        let result = inner(self);\n+        if self.state.is_empty() { result } else { None }.ok_or(AddrParseError(()))\n     }\n \n     /// Read the next character from the input\n     fn read_char(&mut self) -> Option<char> {\n         self.state.split_first().map(|(&b, tail)| {\n             self.state = tail;\n-            b as char\n+            char::from(b)\n         })\n     }\n \n@@ -84,25 +96,26 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    // Read a single digit in the given radix. For instance, 0-9 in radix 10;\n-    // 0-9A-F in radix 16.\n-    fn read_digit(&mut self, radix: u32) -> Option<u32> {\n-        self.read_atomically(move |p| p.read_char()?.to_digit(radix))\n-    }\n-\n     // Read a number off the front of the input in the given radix, stopping\n     // at the first non-digit character or eof. Fails if the number has more\n-    // digits than max_digits, or the value is >= upto, or if there is no number.\n-    fn read_number(&mut self, radix: u32, max_digits: u32, upto: u32) -> Option<u32> {\n+    // digits than max_digits or if there is no number.\n+    fn read_number<T: ReadNumberHelper>(\n+        &mut self,\n+        radix: u32,\n+        max_digits: Option<usize>,\n+    ) -> Option<T> {\n         self.read_atomically(move |p| {\n-            let mut result = 0;\n+            let mut result = T::ZERO;\n             let mut digit_count = 0;\n \n-            while let Some(digit) = p.read_digit(radix) {\n-                result = (result * radix) + digit;\n+            while let Some(digit) = p.read_atomically(|p| p.read_char()?.to_digit(radix)) {\n+                result = result.checked_mul(radix)?;\n+                result = result.checked_add(digit)?;\n                 digit_count += 1;\n-                if digit_count > max_digits || result >= upto {\n-                    return None;\n+                if let Some(max_digits) = max_digits {\n+                    if digit_count > max_digits {\n+                        return None;\n+                    }\n                 }\n             }\n \n@@ -116,7 +129,7 @@ impl<'a> Parser<'a> {\n             let mut groups = [0; 4];\n \n             for (i, slot) in groups.iter_mut().enumerate() {\n-                *slot = p.read_separator('.', i, |p| p.read_number(10, 3, 0x100))? as u8;\n+                *slot = p.read_separator('.', i, |p| p.read_number(10, None))?;\n             }\n \n             Some(groups.into())\n@@ -140,17 +153,17 @@ impl<'a> Parser<'a> {\n                     let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n \n                     if let Some(v4_addr) = ipv4 {\n-                        let octets = v4_addr.octets();\n-                        groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n-                        groups[i + 1] = ((octets[2] as u16) << 8) | (octets[3] as u16);\n+                        let [one, two, three, four] = v4_addr.octets();\n+                        groups[i + 0] = u16::from_be_bytes([one, two]);\n+                        groups[i + 1] = u16::from_be_bytes([three, four]);\n                         return (i + 2, true);\n                     }\n                 }\n \n-                let group = p.read_separator(':', i, |p| p.read_number(16, 4, 0x10000));\n+                let group = p.read_separator(':', i, |p| p.read_number(16, Some(4)));\n \n                 match group {\n-                    Some(g) => *slot = g as u16,\n+                    Some(g) => *slot = g,\n                     None => return (i, false),\n                 }\n             }\n@@ -195,12 +208,11 @@ impl<'a> Parser<'a> {\n         self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n-    /// Read a : followed by a port in base 10\n+    /// Read a : followed by a port in base 10.\n     fn read_port(&mut self) -> Option<u16> {\n         self.read_atomically(|p| {\n             let _ = p.read_given_char(':')?;\n-            let port = p.read_number(10, 5, 0x10000)?;\n-            Some(port as u16)\n+            p.read_number(10, None)\n         })\n     }\n "}]}