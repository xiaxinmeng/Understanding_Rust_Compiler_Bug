{"sha": "a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MzQzZTk5YzBlMzhiY2IzMTM4NmQ0OGE2NjgyZTNhMTg5NmEwY2M=", "commit": {"author": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-01-12T03:10:02Z"}, "committer": {"name": "Jonathan Reem", "email": "jonathan.reem@gmail.com", "date": "2016-01-30T01:00:04Z"}, "message": "Add guard map methods for transforming guards to contain sub-borrows.\n\nThis is very useful when the lock is synchronizing access to a data\nstructure and you would like to return or store guards which contain\nreferences to data inside the data structure instead of the data structure\nitself.", "tree": {"sha": "0e08bb658f37588a5c74612b16336916e7c3f40c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e08bb658f37588a5c74612b16336916e7c3f40c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "html_url": "https://github.com/rust-lang/rust/commit/a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4343e99c0e38bcb31386d48a6682e3a1896a0cc/comments", "author": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "committer": {"login": "reem", "id": 4745181, "node_id": "MDQ6VXNlcjQ3NDUxODE=", "avatar_url": "https://avatars.githubusercontent.com/u/4745181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/reem", "html_url": "https://github.com/reem", "followers_url": "https://api.github.com/users/reem/followers", "following_url": "https://api.github.com/users/reem/following{/other_user}", "gists_url": "https://api.github.com/users/reem/gists{/gist_id}", "starred_url": "https://api.github.com/users/reem/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/reem/subscriptions", "organizations_url": "https://api.github.com/users/reem/orgs", "repos_url": "https://api.github.com/users/reem/repos", "events_url": "https://api.github.com/users/reem/events{/privacy}", "received_events_url": "https://api.github.com/users/reem/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "074f49a350f22b6f33890cd105b2ebe2c790ee3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/074f49a350f22b6f33890cd105b2ebe2c790ee3c", "html_url": "https://github.com/rust-lang/rust/commit/074f49a350f22b6f33890cd105b2ebe2c790ee3c"}], "stats": {"total": 144, "additions": 139, "deletions": 5}, "files": [{"sha": "bdf8ca146fa749687ae73084f2f5ac2fa26edcfa", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a4343e99c0e38bcb31386d48a6682e3a1896a0cc/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4343e99c0e38bcb31386d48a6682e3a1896a0cc/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "patch": "@@ -379,6 +379,43 @@ impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n             }\n         })\n     }\n+\n+    /// Transform this guard to hold a sub-borrow of the original data.\n+    ///\n+    /// Applies the supplied closure to the data, returning a new lock\n+    /// guard referencing the borrow returned by the closure.\n+    ///\n+    /// ```rust\n+    /// # use std::sync::{Mutex, MutexGuard};\n+    /// let x = Mutex::new(vec![1, 2]);\n+    ///\n+    /// {\n+    ///     let y = MutexGuard::map(x.lock().unwrap(), |v| &mut v[0]);\n+    ///     *y = 3;\n+    /// }\n+    ///\n+    /// assert_eq!(&*x.lock(), &[3, 2]);\n+    /// ```\n+    #[unstable(feature = \"guard_map\",\n+               reason = \"recently added, needs RFC for stabilization\",\n+               issue = \"0\")]\n+    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> MutexGuard<'mutex, U>\n+    where F: FnOnce(&'mutex mut T) -> &'mutex mut U {\n+        let new_data = unsafe {\n+            let data = cb(&mut *this.__data.get());\n+            mem::transmute::<&'mutex mut U, &'mutex UnsafeCell<U>>(data)\n+        };\n+\n+        let lock = unsafe { ptr::read(&this.__lock) };\n+        let poison = unsafe { ptr::read(&this.__poison) };\n+        mem::forget(this);\n+\n+        MutexGuard {\n+            __lock: lock,\n+            __data: new_data,\n+            __poison: poison\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -421,7 +458,7 @@ mod tests {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use sync::{Arc, Mutex, StaticMutex, Condvar};\n+    use sync::{Arc, Mutex, StaticMutex, Condvar, MutexGuard};\n     use sync::atomic::{AtomicUsize, Ordering};\n     use thread;\n \n@@ -665,4 +702,19 @@ mod tests {\n         let comp: &[i32] = &[4, 2, 5];\n         assert_eq!(&*mutex.lock().unwrap(), comp);\n     }\n+\n+    #[test]\n+    fn test_mutex_guard_map_panic() {\n+        let mutex = Arc::new(Mutex::new(vec![1, 2]));\n+        let mutex2 = mutex.clone();\n+\n+        thread::spawn(move || {\n+            let _ = MutexGuard::map::<usize, _>(mutex2.lock().unwrap(), |_| panic!());\n+        }).join().unwrap_err();\n+\n+        match mutex.lock() {\n+            Ok(r) => panic!(\"Lock on poisioned Mutex is Ok: {:?}\", &*r),\n+            Err(_) => {}\n+        };\n+    }\n }"}, {"sha": "04f00ed42d050681801a8fda991cfb927ca77d29", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 86, "deletions": 4, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a4343e99c0e38bcb31386d48a6682e3a1896a0cc/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4343e99c0e38bcb31386d48a6682e3a1896a0cc/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=a4343e99c0e38bcb31386d48a6682e3a1896a0cc", "patch": "@@ -121,7 +121,7 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock::new();\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n-    __data: &'a UnsafeCell<T>,\n+    __data: &'a T,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -417,10 +417,37 @@ impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n         poison::map_result(lock.poison.borrow(), |_| {\n             RwLockReadGuard {\n                 __lock: lock,\n-                __data: data,\n+                __data: unsafe { &*data.get() },\n             }\n         })\n     }\n+\n+    /// Transform this guard to hold a sub-borrow of the original data.\n+    ///\n+    /// Applies the supplied closure to the data, returning a new lock\n+    /// guard referencing the borrow returned by the closure.\n+    ///\n+    /// ```rust\n+    /// # use std::sync::{RwLockReadGuard, RwLock};\n+    /// let x = RwLock::new(vec![1, 2]);\n+    ///\n+    /// let y = RwLockReadGuard::map(x.read().unwrap(), |v| &v[0]);\n+    /// assert_eq!(*y, 1);\n+    /// ```\n+    #[unstable(feature = \"guard_map\",\n+               reason = \"recently added, needs RFC for stabilization\",\n+               issue = \"0\")]\n+    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockReadGuard<'rwlock, U>\n+    where F: FnOnce(&'rwlock T) -> &'rwlock U {\n+        let new = RwLockReadGuard {\n+            __lock: this.__lock,\n+            __data: cb(this.__data)\n+        };\n+\n+        mem::forget(this);\n+\n+        new\n+    }\n }\n \n impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n@@ -434,13 +461,52 @@ impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n             }\n         })\n     }\n+\n+    /// Transform this guard to hold a sub-borrow of the original data.\n+    ///\n+    /// Applies the supplied closure to the data, returning a new lock\n+    /// guard referencing the borrow returned by the closure.\n+    ///\n+    /// ```rust\n+    /// # use std::sync::{RwLockWriteGuard, RwLock};\n+    /// let x = RwLock::new(vec![1, 2]);\n+    ///\n+    /// {\n+    ///     let y = RwLockWriteGuard::map(x.write().unwrap(), |v| &mut v[0]);\n+    ///     assert_eq!(*y, 1);\n+    ///\n+    ///     *y = 10;\n+    /// }\n+    ///\n+    /// assert_eq!(&**x.read().unwrap(), &[10, 2]);\n+    /// ```\n+    #[unstable(feature = \"guard_map\",\n+               reason = \"recently added, needs RFC for stabilization\",\n+               issue = \"0\")]\n+    pub fn map<U: ?Sized, F>(this: Self, cb: F) -> RwLockWriteGuard<'rwlock, U>\n+    where F: FnOnce(&'rwlock mut T) -> &'rwlock mut U {\n+        let new_data = unsafe {\n+            let data: &'rwlock mut T = &mut *this.__data.get();\n+            mem::transmute::<&'rwlock mut U, &'rwlock UnsafeCell<U>>(cb(data))\n+        };\n+\n+        let poison = unsafe { ptr::read(&this.__poison) };\n+        let lock = unsafe { ptr::read(&this.__lock) };\n+        mem::forget(this);\n+\n+        RwLockWriteGuard {\n+            __lock: lock,\n+            __data: new_data,\n+            __poison: poison\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n-    fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n+    fn deref(&self) -> &T { self.__data }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -481,7 +547,7 @@ mod tests {\n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n     use thread;\n-    use sync::{Arc, RwLock, StaticRwLock, TryLockError};\n+    use sync::{Arc, RwLock, StaticRwLock, TryLockError, RwLockWriteGuard};\n     use sync::atomic::{AtomicUsize, Ordering};\n \n     #[derive(Eq, PartialEq, Debug)]\n@@ -729,4 +795,20 @@ mod tests {\n             Ok(x) => panic!(\"get_mut of poisoned RwLock is Ok: {:?}\", x),\n         }\n     }\n+\n+    #[test]\n+    fn test_rwlock_write_map_poison() {\n+        let rwlock = Arc::new(RwLock::new(vec![1, 2]));\n+        let rwlock2 = rwlock.clone();\n+\n+        thread::spawn(move || {\n+            let _ = RwLockWriteGuard::map::<usize, _>(rwlock2.write().unwrap(), |_| panic!());\n+        }).join().unwrap_err();\n+\n+        match rwlock.read() {\n+            Ok(r) => panic!(\"Read lock on poisioned RwLock is Ok: {:?}\", &*r),\n+            Err(_) => {}\n+        };\n+    }\n }\n+"}]}