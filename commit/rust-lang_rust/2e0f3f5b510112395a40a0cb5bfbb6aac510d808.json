{"sha": "2e0f3f5b510112395a40a0cb5bfbb6aac510d808", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMGYzZjViNTEwMTEyMzk1YTQwYTBjYjViZmJiNmFhYzUxMGQ4MDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-06T20:23:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-10T10:38:51Z"}, "message": "Move std::run off of std::io\n\nThis changes the implementation to instead use rt::io::native::process as well\nas an example of using those bindings.", "tree": {"sha": "b0f9b7bab21a8f4fba32acb515469eb973b04df6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f9b7bab21a8f4fba32acb515469eb973b04df6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e0f3f5b510112395a40a0cb5bfbb6aac510d808", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e0f3f5b510112395a40a0cb5bfbb6aac510d808", "html_url": "https://github.com/rust-lang/rust/commit/2e0f3f5b510112395a40a0cb5bfbb6aac510d808", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e0f3f5b510112395a40a0cb5bfbb6aac510d808/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee1e6529bddc4ea262e6453589a8042e0128594e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1e6529bddc4ea262e6453589a8042e0128594e", "html_url": "https://github.com/rust-lang/rust/commit/ee1e6529bddc4ea262e6453589a8042e0128594e"}], "stats": {"total": 834, "additions": 65, "deletions": 769}, "files": [{"sha": "38fb597f296fe3c641927a63ae2e353cb7c6c674", "filename": "src/libstd/run.rs", "status": "modified", "additions": 65, "deletions": 769, "changes": 834, "blob_url": "https://github.com/rust-lang/rust/blob/2e0f3f5b510112395a40a0cb5bfbb6aac510d808/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e0f3f5b510112395a40a0cb5bfbb6aac510d808/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=2e0f3f5b510112395a40a0cb5bfbb6aac510d808", "patch": "@@ -12,19 +12,14 @@\n \n #[allow(missing_doc)];\n \n-use c_str::ToCStr;\n-use cast;\n-use clone::Clone;\n-use comm::{stream, SharedChan, GenericChan, GenericPort};\n-use io;\n-use libc::{pid_t, c_void, c_int};\n+use cell::Cell;\n+use comm::{stream, SharedChan};\n+use libc::{pid_t, c_int};\n use libc;\n-use option::{Some, None};\n-use os;\n use prelude::*;\n-use ptr;\n+use rt::io::native::process;\n+use rt::io;\n use task;\n-use vec::ImmutableVector;\n \n /**\n  * A value representing a child process.\n@@ -34,28 +29,7 @@ use vec::ImmutableVector;\n  * for the process to terminate.\n  */\n pub struct Process {\n-\n-    /// The unique id of the process (this should never be negative).\n-    priv pid: pid_t,\n-\n-    /**\n-     * A handle to the process - on unix this will always be NULL, but on\n-     * windows it will be a HANDLE to the process, which will prevent the\n-     * pid being re-used until the handle is closed.\n-     */\n-    priv handle: *(),\n-\n-    /// Some(fd), or None when stdin is being redirected from a fd not created by Process::new.\n-    priv input: Option<c_int>,\n-\n-    /// Some(file), or None when stdout is being redirected to a fd not created by Process::new.\n-    priv output: Option<*libc::FILE>,\n-\n-    /// Some(file), or None when stderr is being redirected to a fd not created by Process::new.\n-    priv error: Option<*libc::FILE>,\n-\n-    /// None until finish() is called.\n-    priv exit_code: Option<int>,\n+    priv inner: process::Process,\n }\n \n /// Options that can be given when starting a Process.\n@@ -147,178 +121,50 @@ impl Process {\n      * * options - Options to configure the environment of the process,\n      *             the working directory and the standard IO streams.\n      */\n-    pub fn new(prog: &str, args: &[~str],\n-               options: ProcessOptions)\n-               -> Process {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let (in_pipe, in_fd) = match options.in_fd {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.input)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-        let (out_pipe, out_fd) = match options.out_fd {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-        let (err_pipe, err_fd) = match options.err_fd {\n-            None => {\n-                let pipe = os::pipe();\n-                (Some(pipe), pipe.out)\n-            },\n-            Some(fd) => (None, fd)\n-        };\n-\n-        let res = spawn_process_os(prog, args, options.env.clone(), options.dir,\n-                                   in_fd, out_fd, err_fd);\n-\n-        unsafe {\n-            for pipe in in_pipe.iter() { libc::close(pipe.input); }\n-            for pipe in out_pipe.iter() { libc::close(pipe.out); }\n-            for pipe in err_pipe.iter() { libc::close(pipe.out); }\n-        }\n-\n-        Process {\n-            pid: res.pid,\n-            handle: res.handle,\n-            input: in_pipe.map(|pipe| pipe.out),\n-            output: out_pipe.map(|pipe| os::fdopen(pipe.input)),\n-            error: err_pipe.map(|pipe| os::fdopen(pipe.input)),\n-            exit_code: None,\n-        }\n+    pub fn new(prog: &str, args: &[~str], options: ProcessOptions) -> Process {\n+        let ProcessOptions { env, dir, in_fd, out_fd, err_fd } = options;\n+        let inner = process::Process::new(prog, args, env, dir,\n+                                          in_fd, out_fd, err_fd);\n+        Process { inner: inner }\n     }\n \n     /// Returns the unique id of the process\n-    pub fn get_id(&self) -> pid_t { self.pid }\n-\n-    fn input_fd(&mut self) -> c_int {\n-        match self.input {\n-            Some(fd) => fd,\n-            None => fail2!(\"This Process's stdin was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    fn output_file(&mut self) -> *libc::FILE {\n-        match self.output {\n-            Some(file) => file,\n-            None => fail2!(\"This Process's stdout was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    fn error_file(&mut self) -> *libc::FILE {\n-        match self.error {\n-            Some(file) => file,\n-            None => fail2!(\"This Process's stderr was redirected to an \\\n-                           existing file descriptor.\")\n-        }\n-    }\n-\n-    /**\n-     * Returns whether this process is reading its stdin from an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n-     *\n-     * If this method returns true then self.input() will fail.\n-     */\n-    pub fn input_redirected(&self) -> bool {\n-        self.input.is_none()\n-    }\n-\n-    /**\n-     * Returns whether this process is writing its stdout to an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n-     *\n-     * If this method returns true then self.output() will fail.\n-     */\n-    pub fn output_redirected(&self) -> bool {\n-        self.output.is_none()\n-    }\n-\n-    /**\n-     * Returns whether this process is writing its stderr to an existing file\n-     * descriptor rather than a pipe that was created specifically for this\n-     * process.\n-     *\n-     * If this method returns true then self.error() will fail.\n-     */\n-    pub fn error_redirected(&self) -> bool {\n-        self.error.is_none()\n-    }\n+    pub fn get_id(&self) -> pid_t { self.inner.id() }\n \n     /**\n      * Returns an io::Writer that can be used to write to this Process's stdin.\n      *\n-     * Fails if this Process's stdin was redirected to an existing file descriptor.\n+     * Fails if there is no stdin available (it's already been removed by\n+     * take_input)\n      */\n-    pub fn input(&mut self) -> @io::Writer {\n-        // FIXME: the Writer can still be used after self is destroyed: #2625\n-       io::fd_writer(self.input_fd(), false)\n-    }\n+    pub fn input<'a>(&'a mut self) -> &'a mut io::Writer { self.inner.input() }\n \n     /**\n      * Returns an io::Reader that can be used to read from this Process's stdout.\n      *\n-     * Fails if this Process's stdout was redirected to an existing file descriptor.\n+     * Fails if there is no stdout available (it's already been removed by\n+     * take_output)\n      */\n-    pub fn output(&mut self) -> @io::Reader {\n-        // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.output_file(), false)\n-    }\n+    pub fn output<'a>(&'a mut self) -> &'a mut io::Reader { self.inner.output() }\n \n     /**\n      * Returns an io::Reader that can be used to read from this Process's stderr.\n      *\n-     * Fails if this Process's stderr was redirected to an existing file descriptor.\n+     * Fails if there is no stderr available (it's already been removed by\n+     * take_error)\n      */\n-    pub fn error(&mut self) -> @io::Reader {\n-        // FIXME: the Reader can still be used after self is destroyed: #2625\n-        io::FILE_reader(self.error_file(), false)\n-    }\n+    pub fn error<'a>(&'a mut self) -> &'a mut io::Reader { self.inner.error() }\n \n     /**\n      * Closes the handle to the child process's stdin.\n-     *\n-     * If this process is reading its stdin from an existing file descriptor, then this\n-     * method does nothing.\n      */\n     pub fn close_input(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        match self.input {\n-            Some(-1) | None => (),\n-            Some(fd) => {\n-                unsafe {\n-                    libc::close(fd);\n-                }\n-                self.input = Some(-1);\n-            }\n-        }\n+        self.inner.take_input();\n     }\n \n     fn close_outputs(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-        fclose_and_null(&mut self.output);\n-        fclose_and_null(&mut self.error);\n-\n-        fn fclose_and_null(f_opt: &mut Option<*libc::FILE>) {\n-            #[allow(cstack)]; // fixed_stack_segment declared on enclosing fn\n-            match *f_opt {\n-                Some(f) if !f.is_null() => {\n-                    unsafe {\n-                        libc::fclose(f);\n-                        *f_opt = Some(0 as *libc::FILE);\n-                    }\n-                },\n-                _ => ()\n-            }\n-        }\n+        self.inner.take_output();\n+        self.inner.take_error();\n     }\n \n     /**\n@@ -327,29 +173,35 @@ impl Process {\n      *\n      * If the child has already been finished then the exit code is returned.\n      */\n-    pub fn finish(&mut self) -> int {\n-        for &code in self.exit_code.iter() {\n-            return code;\n-        }\n-        self.close_input();\n-        let code = waitpid(self.pid);\n-        self.exit_code = Some(code);\n-        return code;\n-    }\n+    pub fn finish(&mut self) -> int { self.inner.wait() }\n \n     /**\n-     * Closes the handle to stdin, waits for the child process to terminate, and reads\n-     * and returns all remaining output of stdout and stderr, along with the exit code.\n+     * Closes the handle to stdin, waits for the child process to terminate, and\n+     * reads and returns all remaining output of stdout and stderr, along with\n+     * the exit code.\n      *\n-     * If the child has already been finished then the exit code and any remaining\n-     * unread output of stdout and stderr will be returned.\n+     * If the child has already been finished then the exit code and any\n+     * remaining unread output of stdout and stderr will be returned.\n      *\n-     * This method will fail if the child process's stdout or stderr streams were\n-     * redirected to existing file descriptors.\n+     * This method will fail if the child process's stdout or stderr streams\n+     * were redirected to existing file descriptors.\n      */\n     pub fn finish_with_output(&mut self) -> ProcessOutput {\n-        let output_file = self.output_file();\n-        let error_file = self.error_file();\n+        self.inner.take_input(); // close stdin\n+        let output = Cell::new(self.inner.take_output());\n+        let error = Cell::new(self.inner.take_error());\n+\n+        fn read_everything(r: &mut io::Reader) -> ~[u8] {\n+            let mut ret = ~[];\n+            let mut buf = [0, ..1024];\n+            loop {\n+                match r.read(buf) {\n+                    Some(n) => { ret.push_all(buf.slice_to(n)); }\n+                    None => break\n+                }\n+            }\n+            return ret;\n+        }\n \n         // Spawn two entire schedulers to read both stdout and sterr\n         // in parallel so we don't deadlock while blocking on one\n@@ -359,12 +211,16 @@ impl Process {\n         let ch = SharedChan::new(ch);\n         let ch_clone = ch.clone();\n         do task::spawn_sched(task::SingleThreaded) {\n-            let errput = io::FILE_reader(error_file, false);\n-            ch.send((2, errput.read_whole_stream()));\n+            match error.take() {\n+                Some(ref mut e) => ch.send((2, read_everything(*e))),\n+                None => ch.send((2, ~[]))\n+            }\n         }\n         do task::spawn_sched(task::SingleThreaded) {\n-            let output = io::FILE_reader(output_file, false);\n-            ch_clone.send((1, output.read_whole_stream()));\n+            match output.take() {\n+                Some(ref mut e) => ch_clone.send((1, read_everything(*e))),\n+                None => ch_clone.send((1, ~[]))\n+            }\n         }\n \n         let status = self.finish();\n@@ -382,48 +238,17 @@ impl Process {\n                               error: errs};\n     }\n \n-    fn destroy_internal(&mut self, force: bool) {\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.exit_code.is_none() {\n-            killpid(self.pid, force);\n-            self.finish();\n-        }\n-\n-        #[cfg(windows)]\n-        fn killpid(pid: pid_t, _force: bool) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-            unsafe {\n-                libc::funcs::extra::kernel32::TerminateProcess(\n-                    cast::transmute(pid), 1);\n-            }\n-        }\n-\n-        #[cfg(unix)]\n-        fn killpid(pid: pid_t, force: bool) {\n-            #[fixed_stack_segment]; #[inline(never)];\n-\n-            let signal = if force {\n-                libc::consts::os::posix88::SIGKILL\n-            } else {\n-                libc::consts::os::posix88::SIGTERM\n-            };\n-\n-            unsafe {\n-                libc::funcs::posix88::signal::kill(pid, signal as c_int);\n-            }\n-        }\n-    }\n-\n     /**\n      * Terminates the process, giving it a chance to clean itself up if\n      * this is supported by the operating system.\n      *\n      * On Posix OSs SIGTERM will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn destroy(&mut self) { self.destroy_internal(false); }\n+    pub fn destroy(&mut self) {\n+        self.inner.signal(io::process::PleaseExitSignal);\n+        self.finish();\n+    }\n \n     /**\n      * Terminates the process as soon as possible without giving it a\n@@ -432,386 +257,12 @@ impl Process {\n      * On Posix OSs SIGKILL will be sent to the process. On Win32\n      * TerminateProcess(..) will be called.\n      */\n-    pub fn force_destroy(&mut self) { self.destroy_internal(true); }\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n+    pub fn force_destroy(&mut self) {\n+        self.inner.signal(io::process::MustDieSignal);\n         self.finish();\n-        self.close_outputs();\n-        free_handle(self.handle);\n     }\n }\n \n-struct SpawnProcessResult {\n-    pid: pid_t,\n-    handle: *(),\n-}\n-\n-#[cfg(windows)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n-    use libc::consts::os::extra::{\n-        TRUE, FALSE,\n-        STARTF_USESTDHANDLES,\n-        INVALID_HANDLE_VALUE,\n-        DUPLICATE_SAME_ACCESS\n-    };\n-    use libc::funcs::extra::kernel32::{\n-        GetCurrentProcess,\n-        DuplicateHandle,\n-        CloseHandle,\n-        CreateProcessA\n-    };\n-    use libc::funcs::extra::msvcrt::get_osfhandle;\n-\n-    use sys;\n-\n-    unsafe {\n-\n-        let mut si = zeroed_startupinfo();\n-        si.cb = sys::size_of::<STARTUPINFO>() as DWORD;\n-        si.dwFlags = STARTF_USESTDHANDLES;\n-\n-        let cur_proc = GetCurrentProcess();\n-\n-        let orig_std_in = get_osfhandle(in_fd) as HANDLE;\n-        if orig_std_in == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_in, cur_proc, &mut si.hStdInput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-        }\n-\n-        let orig_std_out = get_osfhandle(out_fd) as HANDLE;\n-        if orig_std_out == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_out, cur_proc, &mut si.hStdOutput,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-        }\n-\n-        let orig_std_err = get_osfhandle(err_fd) as HANDLE;\n-        if orig_std_err == INVALID_HANDLE_VALUE as HANDLE {\n-            fail2!(\"failure in get_osfhandle: {}\", os::last_os_error());\n-        }\n-        if DuplicateHandle(cur_proc, orig_std_err, cur_proc, &mut si.hStdError,\n-                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n-            fail2!(\"failure in DuplicateHandle: {}\", os::last_os_error());\n-        }\n-\n-        let cmd = make_command_line(prog, args);\n-        let mut pi = zeroed_process_information();\n-        let mut create_err = None;\n-\n-        do with_envp(env) |envp| {\n-            do with_dirp(dir) |dirp| {\n-                do cmd.with_c_str |cmdp| {\n-                    let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n-                                                 ptr::mut_null(), ptr::mut_null(), TRUE,\n-                                                 0, envp, dirp, &mut si, &mut pi);\n-                    if created == FALSE {\n-                        create_err = Some(os::last_os_error());\n-                    }\n-                }\n-            }\n-        }\n-\n-        CloseHandle(si.hStdInput);\n-        CloseHandle(si.hStdOutput);\n-        CloseHandle(si.hStdError);\n-\n-        for msg in create_err.iter() {\n-            fail2!(\"failure in CreateProcess: {}\", *msg);\n-        }\n-\n-        // We close the thread handle because we don't care about keeping the thread id valid,\n-        // and we aren't keeping the thread handle around to be able to close it later. We don't\n-        // close the process handle however because we want the process id to stay valid at least\n-        // until the calling code closes the process handle.\n-        CloseHandle(pi.hThread);\n-\n-        SpawnProcessResult {\n-            pid: pi.dwProcessId as pid_t,\n-            handle: pi.hProcess as *()\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n-    libc::types::os::arch::extra::STARTUPINFO {\n-        cb: 0,\n-        lpReserved: ptr::mut_null(),\n-        lpDesktop: ptr::mut_null(),\n-        lpTitle: ptr::mut_null(),\n-        dwX: 0,\n-        dwY: 0,\n-        dwXSize: 0,\n-        dwYSize: 0,\n-        dwXCountChars: 0,\n-        dwYCountCharts: 0,\n-        dwFillAttribute: 0,\n-        dwFlags: 0,\n-        wShowWindow: 0,\n-        cbReserved2: 0,\n-        lpReserved2: ptr::mut_null(),\n-        hStdInput: ptr::mut_null(),\n-        hStdOutput: ptr::mut_null(),\n-        hStdError: ptr::mut_null()\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n-    libc::types::os::arch::extra::PROCESS_INFORMATION {\n-        hProcess: ptr::mut_null(),\n-        hThread: ptr::mut_null(),\n-        dwProcessId: 0,\n-        dwThreadId: 0\n-    }\n-}\n-\n-// FIXME: this is only pub so it can be tested (see issue #4536)\n-#[cfg(windows)]\n-pub fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n-    let mut cmd = ~\"\";\n-    append_arg(&mut cmd, prog);\n-    for arg in args.iter() {\n-        cmd.push_char(' ');\n-        append_arg(&mut cmd, *arg);\n-    }\n-    return cmd;\n-\n-    fn append_arg(cmd: &mut ~str, arg: &str) {\n-        let quote = arg.iter().any(|c| c == ' ' || c == '\\t');\n-        if quote {\n-            cmd.push_char('\"');\n-        }\n-        for i in range(0u, arg.len()) {\n-            append_char_at(cmd, arg, i);\n-        }\n-        if quote {\n-            cmd.push_char('\"');\n-        }\n-    }\n-\n-    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n-        match arg[i] as char {\n-            '\"' => {\n-                // Escape quotes.\n-                cmd.push_str(\"\\\\\\\"\");\n-            }\n-            '\\\\' => {\n-                if backslash_run_ends_in_quote(arg, i) {\n-                    // Double all backslashes that are in runs before quotes.\n-                    cmd.push_str(\"\\\\\\\\\");\n-                } else {\n-                    // Pass other backslashes through unescaped.\n-                    cmd.push_char('\\\\');\n-                }\n-            }\n-            c => {\n-                cmd.push_char(c);\n-            }\n-        }\n-    }\n-\n-    fn backslash_run_ends_in_quote(s: &str, mut i: uint) -> bool {\n-        while i < s.len() && s[i] as char == '\\\\' {\n-            i += 1;\n-        }\n-        return i < s.len() && s[i] as char == '\"';\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn spawn_process_os(prog: &str, args: &[~str],\n-                    env: Option<~[(~str, ~str)]>,\n-                    dir: Option<&Path>,\n-                    in_fd: c_int, out_fd: c_int, err_fd: c_int) -> SpawnProcessResult {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-    use libc::funcs::bsd44::getdtablesize;\n-\n-    mod rustrt {\n-        #[abi = \"cdecl\"]\n-        extern {\n-            pub fn rust_unset_sigprocmask();\n-        }\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe fn set_environ(_envp: *c_void) {}\n-    #[cfg(target_os = \"macos\")]\n-    unsafe fn set_environ(envp: *c_void) {\n-        externfn!(fn _NSGetEnviron() -> *mut *c_void);\n-\n-        *_NSGetEnviron() = envp;\n-    }\n-    #[cfg(not(target_os = \"macos\"), not(windows))]\n-    unsafe fn set_environ(envp: *c_void) {\n-        extern {\n-            static mut environ: *c_void;\n-        }\n-        environ = envp;\n-    }\n-\n-    unsafe {\n-\n-        let pid = fork();\n-        if pid < 0 {\n-            fail2!(\"failure in fork: {}\", os::last_os_error());\n-        } else if pid > 0 {\n-            return SpawnProcessResult {pid: pid, handle: ptr::null()};\n-        }\n-\n-        rustrt::rust_unset_sigprocmask();\n-\n-        if dup2(in_fd, 0) == -1 {\n-            fail2!(\"failure in dup2(in_fd, 0): {}\", os::last_os_error());\n-        }\n-        if dup2(out_fd, 1) == -1 {\n-            fail2!(\"failure in dup2(out_fd, 1): {}\", os::last_os_error());\n-        }\n-        if dup2(err_fd, 2) == -1 {\n-            fail2!(\"failure in dup3(err_fd, 2): {}\", os::last_os_error());\n-        }\n-        // close all other fds\n-        for fd in range(3, getdtablesize()).invert() {\n-            close(fd as c_int);\n-        }\n-\n-        do with_dirp(dir) |dirp| {\n-            if !dirp.is_null() && chdir(dirp) == -1 {\n-                fail2!(\"failure in chdir: {}\", os::last_os_error());\n-            }\n-        }\n-\n-        do with_envp(env) |envp| {\n-            if !envp.is_null() {\n-                set_environ(envp);\n-            }\n-            do with_argv(prog, args) |argv| {\n-                execvp(*argv, argv);\n-                // execvp only returns if an error occurred\n-                fail2!(\"failure in execvp: {}\", os::last_os_error());\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn with_argv<T>(prog: &str, args: &[~str], cb: &fn(**libc::c_char) -> T) -> T {\n-    use vec;\n-\n-    // We can't directly convert `str`s into `*char`s, as someone needs to hold\n-    // a reference to the intermediary byte buffers. So first build an array to\n-    // hold all the ~[u8] byte strings.\n-    let mut tmps = vec::with_capacity(args.len() + 1);\n-\n-    tmps.push(prog.to_c_str());\n-\n-    for arg in args.iter() {\n-        tmps.push(arg.to_c_str());\n-    }\n-\n-    // Next, convert each of the byte strings into a pointer. This is\n-    // technically unsafe as the caller could leak these pointers out of our\n-    // scope.\n-    let mut ptrs = do tmps.map |tmp| {\n-        tmp.with_ref(|buf| buf)\n-    };\n-\n-    // Finally, make sure we add a null pointer.\n-    ptrs.push(ptr::null());\n-\n-    ptrs.as_imm_buf(|buf, _| cb(buf))\n-}\n-\n-#[cfg(unix)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n-    use vec;\n-\n-    // On posixy systems we can pass a char** for envp, which is a\n-    // null-terminated array of \"k=v\\n\" strings. Like `with_argv`, we have to\n-    // have a temporary buffer to hold the intermediary `~[u8]` byte strings.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = vec::with_capacity(env.len());\n-\n-            for pair in env.iter() {\n-                let kv = format!(\"{}={}\", pair.first(), pair.second());\n-                tmps.push(kv.to_c_str());\n-            }\n-\n-            // Once again, this is unsafe.\n-            let mut ptrs = do tmps.map |tmp| {\n-                tmp.with_ref(|buf| buf)\n-            };\n-            ptrs.push(ptr::null());\n-\n-            do ptrs.as_imm_buf |buf, _| {\n-                unsafe { cb(cast::transmute(buf)) }\n-            }\n-        }\n-        _ => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*mut c_void) -> T) -> T {\n-    // On win32 we pass an \"environment block\" which is not a char**, but\n-    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n-    // \\0 to terminate.\n-    match env {\n-        Some(env) => {\n-            let mut blk = ~[];\n-\n-            for pair in env.iter() {\n-                let kv = format!(\"{}={}\", pair.first(), pair.second());\n-                blk.push_all(kv.as_bytes());\n-                blk.push(0);\n-            }\n-\n-            blk.push(0);\n-\n-            do blk.as_imm_buf |p, _len| {\n-                unsafe { cb(cast::transmute(p)) }\n-            }\n-        }\n-        _ => cb(ptr::mut_null())\n-    }\n-}\n-\n-fn with_dirp<T>(d: Option<&Path>, cb: &fn(*libc::c_char) -> T) -> T {\n-    match d {\n-      Some(dir) => dir.with_c_str(|buf| cb(buf)),\n-      None => cb(ptr::null())\n-    }\n-}\n-\n-#[cfg(windows)]\n-fn free_handle(handle: *()) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    unsafe {\n-        libc::funcs::extra::kernel32::CloseHandle(cast::transmute(handle));\n-    }\n-}\n-\n-#[cfg(unix)]\n-fn free_handle(_handle: *()) {\n-    // unix has no process handle object, just a pid\n-}\n-\n /**\n  * Spawns a process and waits for it to terminate. The process will\n  * inherit the current stdin/stdout/stderr file descriptors.\n@@ -825,13 +276,14 @@ fn free_handle(_handle: *()) {\n  *\n  * The process's exit code\n  */\n+#[fixed_stack_segment] #[inline(never)]\n pub fn process_status(prog: &str, args: &[~str]) -> int {\n     let mut prog = Process::new(prog, args, ProcessOptions {\n         env: None,\n         dir: None,\n-        in_fd: Some(0),\n-        out_fd: Some(1),\n-        err_fd: Some(2)\n+        in_fd: Some(unsafe { libc::dup(libc::STDIN_FILENO) }),\n+        out_fd: Some(unsafe { libc::dup(libc::STDOUT_FILENO) }),\n+        err_fd: Some(unsafe { libc::dup(libc::STDERR_FILENO) })\n     });\n     prog.finish()\n }\n@@ -853,107 +305,6 @@ pub fn process_output(prog: &str, args: &[~str]) -> ProcessOutput {\n     prog.finish_with_output()\n }\n \n-/**\n- * Waits for a process to exit and returns the exit code, failing\n- * if there is no process with the specified id.\n- *\n- * Note that this is private to avoid race conditions on unix where if\n- * a user calls waitpid(some_process.get_id()) then some_process.finish()\n- * and some_process.destroy() and some_process.finalize() will then either\n- * operate on a none-existent process or, even worse, on a newer process\n- * with the same id.\n- */\n-fn waitpid(pid: pid_t) -> int {\n-    return waitpid_os(pid);\n-\n-    #[cfg(windows)]\n-    fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        use libc::types::os::arch::extra::DWORD;\n-        use libc::consts::os::extra::{\n-            SYNCHRONIZE,\n-            PROCESS_QUERY_INFORMATION,\n-            FALSE,\n-            STILL_ACTIVE,\n-            INFINITE,\n-            WAIT_FAILED\n-        };\n-        use libc::funcs::extra::kernel32::{\n-            OpenProcess,\n-            GetExitCodeProcess,\n-            CloseHandle,\n-            WaitForSingleObject\n-        };\n-\n-        unsafe {\n-\n-            let proc = OpenProcess(SYNCHRONIZE | PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n-            if proc.is_null() {\n-                fail2!(\"failure in OpenProcess: {}\", os::last_os_error());\n-            }\n-\n-            loop {\n-                let mut status = 0;\n-                if GetExitCodeProcess(proc, &mut status) == FALSE {\n-                    CloseHandle(proc);\n-                    fail2!(\"failure in GetExitCodeProcess: {}\", os::last_os_error());\n-                }\n-                if status != STILL_ACTIVE {\n-                    CloseHandle(proc);\n-                    return status as int;\n-                }\n-                if WaitForSingleObject(proc, INFINITE) == WAIT_FAILED {\n-                    CloseHandle(proc);\n-                    fail2!(\"failure in WaitForSingleObject: {}\", os::last_os_error());\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    fn waitpid_os(pid: pid_t) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        use libc::funcs::posix01::wait::*;\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0xffi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WIFEXITED(status: i32) -> bool {\n-            (status & 0x7fi32) == 0i32\n-        }\n-\n-        #[cfg(target_os = \"linux\")]\n-        #[cfg(target_os = \"android\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            (status >> 8i32) & 0xffi32\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        #[cfg(target_os = \"freebsd\")]\n-        fn WEXITSTATUS(status: i32) -> i32 {\n-            status >> 8i32\n-        }\n-\n-        let mut status = 0 as c_int;\n-        if unsafe { waitpid(pid, &mut status, 0) } == -1 {\n-            fail2!(\"failure in waitpid: {}\", os::last_os_error());\n-        }\n-\n-        return if WIFEXITED(status) {\n-            WEXITSTATUS(status) as int\n-        } else {\n-            1\n-        };\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use io;\n@@ -965,27 +316,6 @@ mod tests {\n     use str;\n     use unstable::running_on_valgrind;\n \n-    #[test]\n-    #[cfg(windows)]\n-    fn test_make_command_line() {\n-        assert_eq!(\n-            run::make_command_line(\"prog\", [~\"aaa\", ~\"bbb\", ~\"ccc\"]),\n-            ~\"prog aaa bbb ccc\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", [~\"aaa\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"C:\\\\Program Files\\\\test\", [~\"aa\\\"bb\"]),\n-            ~\"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n-        );\n-        assert_eq!(\n-            run::make_command_line(\"echo\", [~\"a b c\"]),\n-            ~\"echo \\\"a b c\\\"\"\n-        );\n-    }\n-\n     #[test]\n     #[cfg(not(target_os=\"android\"))]\n     fn test_process_status() {\n@@ -1068,10 +398,6 @@ mod tests {\n             err_fd: Some(pipe_err.out)\n         });\n \n-        assert!(proc.input_redirected());\n-        assert!(proc.output_redirected());\n-        assert!(proc.error_redirected());\n-\n         os::close(pipe_in.input);\n         os::close(pipe_out.out);\n         os::close(pipe_err.out);\n@@ -1223,36 +549,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[should_fail]\n-    #[cfg(not(windows),not(target_os=\"android\"))]\n-    fn test_finish_with_output_redirected() {\n-        let mut prog = run::Process::new(\"echo\", [~\"hello\"], run::ProcessOptions {\n-            env: None,\n-            dir: None,\n-            in_fd: Some(0),\n-            out_fd: Some(1),\n-            err_fd: Some(2)\n-        });\n-        // this should fail because it is not valid to read the output when it was redirected\n-        prog.finish_with_output();\n-    }\n-    #[test]\n-    #[should_fail]\n-    #[cfg(not(windows),target_os=\"android\")]\n-    fn test_finish_with_output_redirected() {\n-        let mut prog = run::Process::new(\"/system/bin/sh\", [~\"-c\",~\"echo hello\"],\n-                                         run::ProcessOptions {\n-            env: None,\n-            dir: None,\n-            in_fd: Some(0),\n-            out_fd: Some(1),\n-            err_fd: Some(2)\n-        });\n-        // this should fail because it is not valid to read the output when it was redirected\n-        prog.finish_with_output();\n-    }\n-\n     #[cfg(unix,not(target_os=\"android\"))]\n     fn run_pwd(dir: Option<&Path>) -> run::Process {\n         run::Process::new(\"pwd\", [], run::ProcessOptions {"}]}