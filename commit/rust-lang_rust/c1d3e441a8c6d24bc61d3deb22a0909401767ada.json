{"sha": "c1d3e441a8c6d24bc61d3deb22a0909401767ada", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZDNlNDQxYThjNmQyNGJjNjFkM2RlYjIyYTA5MDk0MDE3NjdhZGE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-01T04:59:06Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-11-01T19:12:05Z"}, "message": "save-analysis: handle function types in bounds\n\nThis special cases the function type sugar in paths and deals with traits bounds as just the path parts. That required refactoring the path collector to distinguish between variable decls and references in patterns, basically just to please the borrow checker.\n\ncc https://github.com/nrc/rls-analysis/issues/37", "tree": {"sha": "9524d5e40355564b8bb8bc5a697e6e83cf8b63c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9524d5e40355564b8bb8bc5a697e6e83cf8b63c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1d3e441a8c6d24bc61d3deb22a0909401767ada", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1d3e441a8c6d24bc61d3deb22a0909401767ada", "html_url": "https://github.com/rust-lang/rust/commit/c1d3e441a8c6d24bc61d3deb22a0909401767ada", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1d3e441a8c6d24bc61d3deb22a0909401767ada/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90ef3372e8ad74517eafa61e9494688c258b15ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/90ef3372e8ad74517eafa61e9494688c258b15ce", "html_url": "https://github.com/rust-lang/rust/commit/90ef3372e8ad74517eafa61e9494688c258b15ce"}], "stats": {"total": 139, "additions": 81, "deletions": 58}, "files": [{"sha": "11f62b4bd804ee950ca0e68abe8d6ff5725c47df", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3e441a8c6d24bc61d3deb22a0909401767ada/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3e441a8c6d24bc61d3deb22a0909401767ada/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c1d3e441a8c6d24bc61d3deb22a0909401767ada", "patch": "@@ -318,25 +318,24 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             let mut collector = PathCollector::new();\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n-            for &(id, ref p, ..) in &collector.collected_paths {\n+\n+            for (id, i, sp, ..) in collector.collected_idents {\n                 let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n-                // get the span only for the name of the variable (I hope the path is only ever a\n-                // variable name, but who knows?)\n-                let sub_span = span_utils.span_for_last_ident(p.span);\n-                if !self.span.filter_generated(sub_span, p.span) {\n+                let sub_span = span_utils.span_for_last_ident(sp);\n+                if !self.span.filter_generated(sub_span, sp) {\n                     let id = ::id_from_node_id(id, &self.save_ctxt);\n                     let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                     self.dumper.dump_def(false, Def {\n                         kind: DefKind::Local,\n                         id,\n                         span,\n-                        name: path_to_string(p),\n-                        qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n+                        name: i.to_string(),\n+                        qualname: format!(\"{}::{}\", qualname, i.to_string()),\n                         value: typ,\n                         parent: None,\n                         children: vec![],\n@@ -391,14 +390,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_trait_ref(&mut self, trait_ref: &'l ast::TraitRef) {\n-        let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref);\n-        if let Some(trait_ref_data) = trait_ref_data {\n-            self.dumper.dump_ref(trait_ref_data);\n-        }\n-        self.process_path(trait_ref.ref_id, &trait_ref.path);\n-    }\n-\n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n         if let Some(field_data) = field_data {\n@@ -783,7 +774,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         }\n     }\n \n-    fn process_path(&mut self, id: NodeId, path: &ast::Path) {\n+    fn process_path(&mut self, id: NodeId, path: &'l ast::Path) {\n         let path_data = self.save_ctxt.get_path_data(id, path);\n         if generated_code(path.span) && path_data.is_none() {\n             return;\n@@ -798,6 +789,27 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n         self.dumper.dump_ref(path_data);\n \n+        // Type parameters\n+        for seg in &path.segments {\n+            if let Some(ref params) = seg.parameters {\n+                match **params {\n+                    ast::PathParameters::AngleBracketed(ref data) => {\n+                        for t in &data.types {\n+                            self.visit_ty(t);\n+                        }\n+                    }\n+                    ast::PathParameters::Parenthesized(ref data) => {\n+                        for t in &data.inputs {\n+                            self.visit_ty(t);\n+                        }\n+                        if let Some(ref t) = data.output {\n+                            self.visit_ty(t);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         // Modules or types in the path prefix.\n         match self.save_ctxt.get_path_def(id) {\n             HirDef::Method(did) => {\n@@ -904,7 +916,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         collector.visit_pat(&p);\n         self.visit_pat(&p);\n \n-        for &(id, ref p, immut) in &collector.collected_paths {\n+        for (id, i, sp, immut) in collector.collected_idents {\n             let mut value = match immut {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n@@ -924,18 +936,18 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n \n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n-            let sub_span = self.span.span_for_last_ident(p.span);\n+            let sub_span = self.span.span_for_last_ident(sp);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            if !self.span.filter_generated(sub_span, p.span) {\n-                let qualname = format!(\"{}${}\", path_to_string(p), id);\n+            if !self.span.filter_generated(sub_span, sp) {\n+                let qualname = format!(\"{}${}\", i.to_string(), id);\n                 let id = ::id_from_node_id(id, &self.save_ctxt);\n                 let span = self.span_from_span(sub_span.expect(\"No span found for variable\"));\n \n                 self.dumper.dump_def(false, Def {\n                     kind: DefKind::Local,\n                     id,\n                     span,\n-                    name: path_to_string(p),\n+                    name: i.to_string(),\n                     qualname,\n                     value: typ,\n                     parent: None,\n@@ -1263,7 +1275,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n         for param in generics.ty_params.iter() {\n             for bound in param.bounds.iter() {\n                 if let ast::TraitTyParamBound(ref trait_ref, _) = *bound {\n-                    self.process_trait_ref(&trait_ref.trait_ref);\n+                    self.process_path(trait_ref.trait_ref.ref_id, &trait_ref.trait_ref.path)\n                 }\n             }\n             if let Some(ref ty) = param.default {\n@@ -1430,15 +1442,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n             self.visit_pat(&pattern);\n         }\n \n-        // This is to get around borrow checking, because we need mut self to call process_path.\n-        let mut paths_to_process = vec![];\n-\n         // process collected paths\n-        for &(id, ref p, immut) in &collector.collected_paths {\n+        for (id, i, sp, immut) in collector.collected_idents {\n             match self.save_ctxt.get_path_def(id) {\n                 HirDef::Local(id) => {\n                     let mut value = if immut == ast::Mutability::Immutable {\n-                        self.span.snippet(p.span).to_string()\n+                        self.span.snippet(sp).to_string()\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n@@ -1451,18 +1460,16 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n \n-                    assert!(p.segments.len() == 1,\n-                            \"qualified path for local variable def in arm\");\n-                    if !self.span.filter_generated(Some(p.span), p.span) {\n-                        let qualname = format!(\"{}${}\", path_to_string(p), id);\n+                    if !self.span.filter_generated(Some(sp), sp) {\n+                        let qualname = format!(\"{}${}\", i.to_string(), id);\n                         let id = ::id_from_node_id(id, &self.save_ctxt);\n-                        let span = self.span_from_span(p.span);\n+                        let span = self.span_from_span(sp);\n \n                         self.dumper.dump_def(false, Def {\n                             kind: DefKind::Local,\n                             id,\n                             span,\n-                            name: path_to_string(p),\n+                            name: i.to_string(),\n                             qualname,\n                             value: typ,\n                             parent: None,\n@@ -1474,19 +1481,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                         });\n                     }\n                 }\n-                HirDef::StructCtor(..) | HirDef::VariantCtor(..) |\n-                HirDef::Const(..) | HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) | HirDef::Variant(..) |\n-                HirDef::TyAlias(..) | HirDef::AssociatedTy(..) |\n-                HirDef::SelfTy(..) => {\n-                    paths_to_process.push((id, p.clone()))\n-                }\n-                def => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n+                def => error!(\"unexpected definition kind when processing collected idents: {:?}\",\n                               def),\n             }\n         }\n \n-        for &(id, ref path) in &paths_to_process {\n+        for (id, ref path) in collector.collected_paths {\n             self.process_path(id, path);\n         }\n         walk_list!(self, visit_expr, &arm.guard);"}, {"sha": "9769f3905c7b69aaf977ab8c6899fe7b36ae6b00", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c1d3e441a8c6d24bc61d3deb22a0909401767ada/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1d3e441a8c6d24bc61d3deb22a0909401767ada/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c1d3e441a8c6d24bc61d3deb22a0909401767ada", "patch": "@@ -614,6 +614,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Ref> {\n+        // Returns true if the path is function type sugar, e.g., `Fn(A) -> B`.\n+        fn fn_type(path: &ast::Path) -> bool {\n+            if path.segments.len() != 1 {\n+                return false;\n+            }\n+            if let Some(ref params) = path.segments[0].parameters {\n+                if let ast::PathParameters::Parenthesized(_) = **params {\n+                    return true;\n+                }\n+            }\n+            false\n+        }\n+\n         let def = self.get_path_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n@@ -639,6 +652,16 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def.def_id()),\n                 })\n             }\n+            HirDef::Trait(def_id) if fn_type(path) => {\n+                // Function type bounds are desugared in the parser, so we have to\n+                // special case them here.\n+                let fn_span = self.span_utils.span_for_first_ident(path.span);\n+                fn_span.map(|span| Ref {\n+                    kind: RefKind::Type,\n+                    span: self.span_from_span(span),\n+                    ref_id: id_from_def_id(def_id),\n+                })\n+            }\n             HirDef::Struct(def_id) |\n             HirDef::Variant(def_id, ..) |\n             HirDef::Union(def_id) |\n@@ -818,29 +841,31 @@ fn make_signature(decl: &ast::FnDecl, generics: &ast::Generics) -> String {\n     sig\n }\n \n-// An AST visitor for collecting paths from patterns.\n-struct PathCollector {\n-    // The Row field identifies the kind of pattern.\n-    collected_paths: Vec<(NodeId, ast::Path, ast::Mutability)>,\n+// An AST visitor for collecting paths (e.g., the names of structs) and formal\n+// variables (idents) from patterns.\n+struct PathCollector<'l> {\n+    collected_paths: Vec<(NodeId, &'l ast::Path)>,\n+    collected_idents: Vec<(NodeId, ast::Ident, Span, ast::Mutability)>,\n }\n \n-impl PathCollector {\n-    fn new() -> PathCollector {\n-        PathCollector { collected_paths: vec![] }\n+impl<'l> PathCollector<'l> {\n+    fn new() -> PathCollector<'l> {\n+        PathCollector {\n+            collected_paths: vec![],\n+            collected_idents: vec![],\n+        }\n     }\n }\n \n-impl<'a> Visitor<'a> for PathCollector {\n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+impl<'l, 'a: 'l> Visitor<'a> for PathCollector<'l> {\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n         match p.node {\n             PatKind::Struct(ref path, ..) => {\n-                self.collected_paths.push((p.id, path.clone(),\n-                                           ast::Mutability::Mutable));\n+                self.collected_paths.push((p.id, path));\n             }\n             PatKind::TupleStruct(ref path, ..) |\n             PatKind::Path(_, ref path) => {\n-                self.collected_paths.push((p.id, path.clone(),\n-                                           ast::Mutability::Mutable));\n+                self.collected_paths.push((p.id, path));\n             }\n             PatKind::Ident(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n@@ -854,9 +879,7 @@ impl<'a> Visitor<'a> for PathCollector {\n                     ast::BindingMode::ByRef(_) => ast::Mutability::Immutable,\n                     ast::BindingMode::ByValue(mt) => mt,\n                 };\n-                // collect path for either visit_local or visit_arm\n-                let path = ast::Path::from_ident(path1.span, path1.node);\n-                self.collected_paths.push((p.id, path, immut));\n+                self.collected_idents.push((p.id, path1.node, path1.span, immut));\n             }\n             _ => {}\n         }"}]}