{"sha": "80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMTIxNzgxYTNlYWY3NWQzYjdjYmY1NGI4YjRkMGE0MTllMzliYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-04T10:07:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-04T10:07:47Z"}, "message": "Auto merge of #5868 - flip1995:rollup-5g8vft5, r=flip1995\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #5837 (needless_collect: catch x: Vec<_> = iter.collect(); x.into_iter() ...)\n - #5846 (Handle mapping to Option in `map_flatten` lint)\n - #5848 (Add derive_ord_xor_partial_ord lint)\n - #5852 (Add lint for duplicate methods of trait bounds)\n - #5856 (Remove old Symbol reexport)\n\nFailed merges:\n\nr? @ghost\n\nchangelog: rollup", "tree": {"sha": "e4583a0bc1667e01f507f0cc739c86a40bf48a6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4583a0bc1667e01f507f0cc739c86a40bf48a6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "html_url": "https://github.com/rust-lang/rust/commit/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1968aede0f3deab97347bcc936ecee5e3c3471c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1968aede0f3deab97347bcc936ecee5e3c3471c7", "html_url": "https://github.com/rust-lang/rust/commit/1968aede0f3deab97347bcc936ecee5e3c3471c7"}, {"sha": "fb7ad956f663dc2e54baf95a4fb3e5b76cd73e39", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb7ad956f663dc2e54baf95a4fb3e5b76cd73e39", "html_url": "https://github.com/rust-lang/rust/commit/fb7ad956f663dc2e54baf95a4fb3e5b76cd73e39"}], "stats": {"total": 837, "additions": 770, "deletions": 67}, "files": [{"sha": "43d83d978b8a0b739c11ada83b93d528687382b2", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -1454,6 +1454,7 @@ Released 2018-09-13\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n+[`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons\n@@ -1723,6 +1724,7 @@ Released 2018-09-13\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments\n [`too_many_lines`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_lines\n [`toplevel_ref_arg`]: https://rust-lang.github.io/rust-clippy/master/index.html#toplevel_ref_arg\n+[`trait_duplication_in_bounds`]: https://rust-lang.github.io/rust-clippy/master/index.html#trait_duplication_in_bounds\n [`transmute_bytes_to_str`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_bytes_to_str\n [`transmute_float_to_int`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_float_to_int\n [`transmute_int_to_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_bool"}, {"sha": "3ce110e8e0f7a7e6c8117baeb2d3f86c6d03f8ff", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -1,6 +1,5 @@\n //! checks for attributes\n \n-use crate::reexport::Name;\n use crate::utils::{\n     first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_help,\n     span_lint_and_sugg, span_lint_and_then, without_block_comments,\n@@ -517,7 +516,7 @@ fn is_relevant_expr(cx: &LateContext<'_>, typeck_results: &ty::TypeckResults<'_>\n     }\n }\n \n-fn check_attrs(cx: &LateContext<'_>, span: Span, name: Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext<'_>, span: Span, name: Symbol, attrs: &[Attribute]) {\n     if span.from_expansion() {\n         return;\n     }"}, {"sha": "08d8100a88545bc7ee8ada5d6ec8bc6f92e992dc", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_automatically_derived, is_copy, match_path, span_lint_and_help, span_lint_and_note, span_lint_and_then,\n+    get_trait_def_id, is_automatically_derived, is_copy, match_path, span_lint_and_help, span_lint_and_note,\n+    span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n@@ -43,6 +44,57 @@ declare_clippy_lint! {\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `Ord` but implementing `PartialOrd`\n+    /// explicitly or vice versa.\n+    ///\n+    /// **Why is this bad?** The implementation of these traits must agree (for\n+    /// example for use with `sort`) so it\u2019s probably a bad idea to use a\n+    /// default-generated `Ord` implementation with an explicitly defined\n+    /// `PartialOrd`. In particular, the following must hold for any type\n+    /// implementing `Ord`:\n+    ///\n+    /// ```text\n+    /// k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// #[derive(Ord, PartialEq, Eq)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialOrd for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// #[derive(PartialEq, Eq)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialOrd for Foo {\n+    ///     fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n+    ///        Some(self.cmp(other))\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Ord for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    /// or, if you don't need a custom ordering:\n+    /// ```rust,ignore\n+    /// #[derive(Ord, PartialOrd, PartialEq, Eq)]\n+    /// struct Foo;\n+    /// ```\n+    pub DERIVE_ORD_XOR_PARTIAL_ORD,\n+    correctness,\n+    \"deriving `Ord` but implementing `PartialOrd` explicitly\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n     /// types.\n@@ -103,7 +155,12 @@ declare_clippy_lint! {\n     \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\"\n }\n \n-declare_lint_pass!(Derive => [EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_XOR_EQ, UNSAFE_DERIVE_DESERIALIZE]);\n+declare_lint_pass!(Derive => [\n+    EXPL_IMPL_CLONE_ON_COPY,\n+    DERIVE_HASH_XOR_EQ,\n+    DERIVE_ORD_XOR_PARTIAL_ORD,\n+    UNSAFE_DERIVE_DESERIALIZE\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -116,6 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n+            check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);\n \n             if is_automatically_derived {\n                 check_unsafe_derive_deserialize(cx, item, trait_ref, ty);\n@@ -180,6 +238,60 @@ fn check_hash_peq<'tcx>(\n     }\n }\n \n+/// Implementation of the `DERIVE_ORD_XOR_PARTIAL_ORD` lint.\n+fn check_ord_partial_ord<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    trait_ref: &TraitRef<'_>,\n+    ty: Ty<'tcx>,\n+    ord_is_automatically_derived: bool,\n+) {\n+    if_chain! {\n+        if let Some(ord_trait_def_id) = get_trait_def_id(cx, &paths::ORD);\n+        if let Some(partial_ord_trait_def_id) = cx.tcx.lang_items().partial_ord_trait();\n+        if let Some(def_id) = &trait_ref.trait_def_id();\n+        if *def_id == ord_trait_def_id;\n+        then {\n+            // Look for the PartialOrd implementations for `ty`\n+            cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n+                let partial_ord_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+\n+                if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n+                    return;\n+                }\n+\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+\n+                // Only care about `impl PartialOrd<Foo> for Foo`\n+                // For `impl PartialOrd<B> for A, input_types is [A, B]\n+                if trait_ref.substs.type_at(1) == ty {\n+                    let mess = if partial_ord_is_automatically_derived {\n+                        \"you are implementing `Ord` explicitly but have derived `PartialOrd`\"\n+                    } else {\n+                        \"you are deriving `Ord` but have implemented `PartialOrd` explicitly\"\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        DERIVE_ORD_XOR_PARTIAL_ORD,\n+                        span,\n+                        mess,\n+                        |diag| {\n+                            if let Some(local_def_id) = impl_id.as_local() {\n+                                let hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+                                diag.span_note(\n+                                    cx.tcx.hir().span(hir_id),\n+                                    \"`PartialOrd` implemented here\"\n+                                );\n+                            }\n+                        }\n+                    );\n+                }\n+            });\n+        }\n+    }\n+}\n+\n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n     if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {"}, {"sha": "26aff6af8cdb9515c2a65169250c330f1f31084a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -322,10 +322,6 @@ mod zero_div_zero;\n \n pub use crate::utils::conf::Conf;\n \n-mod reexport {\n-    pub use rustc_span::Symbol as Name;\n-}\n-\n /// Register all pre expansion lints\n ///\n /// Pre-expansion lints run before any macro expansion has happened.\n@@ -513,6 +509,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &default_trait_access::DEFAULT_TRAIT_ACCESS,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n+        &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n         &derive::EXPL_IMPL_CLONE_ON_COPY,\n         &derive::UNSAFE_DERIVE_DESERIALIZE,\n         &doc::DOC_MARKDOWN,\n@@ -786,6 +783,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n         &temporary_assignment::TEMPORARY_ASSIGNMENT,\n         &to_digit_is_some::TO_DIGIT_IS_SOME,\n+        &trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n         &trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         &transmute::CROSSPOINTER_TRANSMUTE,\n         &transmute::TRANSMUTE_BYTES_TO_STR,\n@@ -1174,6 +1172,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n+        LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n         LintId::of(&trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&types::CAST_LOSSLESS),\n@@ -1230,6 +1229,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n+        LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n         LintId::of(&doc::NEEDLESS_DOCTEST_MAIN),\n         LintId::of(&double_comparison::DOUBLE_COMPARISONS),\n@@ -1648,6 +1648,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n+        LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&drop_bounds::DROP_BOUNDS),\n         LintId::of(&drop_forget_ref::DROP_COPY),\n         LintId::of(&drop_forget_ref::DROP_REF),"}, {"sha": "4df6827d77f94027551ba7663b1cace0af537c88", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -13,9 +13,8 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Symbol};\n \n-use crate::reexport::Name;\n use crate::utils::{in_macro, last_path_segment, span_lint, trait_ref_of_method};\n \n declare_clippy_lint! {\n@@ -113,7 +112,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n enum RefLt {\n     Unnamed,\n     Static,\n-    Named(Name),\n+    Named(Symbol),\n }\n \n fn check_fn_inner<'tcx>(\n@@ -456,7 +455,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n }\n \n struct LifetimeChecker {\n-    map: FxHashMap<Name, Span>,\n+    map: FxHashMap<Symbol, Span>,\n }\n \n impl<'tcx> Visitor<'tcx> for LifetimeChecker {"}, {"sha": "6359c20040c7a7458c02ee1fd78f60e58c0f2443", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 169, "deletions": 15, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -1,14 +1,13 @@\n use crate::consts::constant;\n-use crate::reexport::Name;\n use crate::utils::paths;\n+use crate::utils::sugg::Sugg;\n use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n-    is_integer_const, is_no_std_crate, is_refutable, last_path_segment, match_trait_method, match_type, match_var,\n-    multispan_sugg, snippet, snippet_opt, snippet_with_applicability, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, span_lint_and_then, SpanlessEq,\n+    is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n+    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_opt, snippet_with_applicability, span_lint,\n+    span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n-use crate::utils::{is_type_diagnostic_item, qpath_res, sugg};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -17,7 +16,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand,\n-    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    Local, LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -27,7 +26,7 @@ use rustc_middle::middle::region;\n use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::iter::{once, Iterator};\n use std::mem;\n@@ -1184,7 +1183,7 @@ fn check_for_loop_range<'tcx>(\n     }\n }\n \n-fn is_len_call(expr: &Expr<'_>, var: Name) -> bool {\n+fn is_len_call(expr: &Expr<'_>, var: Symbol) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n         if len_args.len() == 1;\n@@ -1640,15 +1639,15 @@ struct VarVisitor<'a, 'tcx> {\n     /// var name to look for as index\n     var: HirId,\n     /// indexed variables that are used mutably\n-    indexed_mut: FxHashSet<Name>,\n+    indexed_mut: FxHashSet<Symbol>,\n     /// indirectly indexed variables (`v[(i + 4) % N]`), the extend is `None` for global\n-    indexed_indirectly: FxHashMap<Name, Option<region::Scope>>,\n+    indexed_indirectly: FxHashMap<Symbol, Option<region::Scope>>,\n     /// subset of `indexed` of vars that are indexed directly: `v[i]`\n     /// this will not contain cases like `v[calc_index(i)]` or `v[(i + 4) % N]`\n-    indexed_directly: FxHashMap<Name, (Option<region::Scope>, Ty<'tcx>)>,\n+    indexed_directly: FxHashMap<Symbol, (Option<region::Scope>, Ty<'tcx>)>,\n     /// Any names that are used outside an index operation.\n     /// Used to detect things like `&mut vec` used together with `vec[i]`\n-    referenced: FxHashSet<Name>,\n+    referenced: FxHashSet<Symbol>,\n     /// has the loop variable been used in expressions other than the index of\n     /// an index op?\n     nonindex: bool,\n@@ -2004,7 +2003,7 @@ struct InitializeVisitor<'a, 'tcx> {\n     end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n     var_id: HirId,\n     state: VarState,\n-    name: Option<Name>,\n+    name: Option<Symbol>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n@@ -2167,7 +2166,7 @@ use self::Nesting::{LookFurther, RuledOut, Unknown};\n \n struct LoopNestVisitor {\n     hir_id: HirId,\n-    iterator: Name,\n+    iterator: Symbol,\n     nesting: Nesting,\n }\n \n@@ -2218,7 +2217,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-fn path_name(e: &Expr<'_>) -> Option<Name> {\n+fn path_name(e: &Expr<'_>) -> Option<Symbol> {\n     if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n@@ -2358,6 +2357,10 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    check_needless_collect_direct_usage(expr, cx);\n+    check_needless_collect_indirect_usage(expr, cx);\n+}\n+fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n         if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n@@ -2425,6 +2428,157 @@ fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n     }\n }\n \n+fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n+    if let ExprKind::Block(ref block, _) = expr.kind {\n+        for ref stmt in block.stmts {\n+            if_chain! {\n+                if let StmtKind::Local(\n+                    Local { pat: Pat { kind: PatKind::Binding(_, _, ident, .. ), .. },\n+                    init: Some(ref init_expr), .. }\n+                ) = stmt.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, &[ref iter_source], ..) = init_expr.kind;\n+                if method_name.ident.name == sym!(collect) && match_trait_method(cx, &init_expr, &paths::ITERATOR);\n+                if let Some(ref generic_args) = method_name.args;\n+                if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+                if let ty = cx.typeck_results().node_type(ty.hir_id);\n+                if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n+                    is_type_diagnostic_item(cx, ty, sym!(vecdeque_type)) ||\n+                    match_type(cx, ty, &paths::LINKED_LIST);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if iter_calls.len() == 1;\n+                then {\n+                    // Suggest replacing iter_call with iter_replacement, and removing stmt\n+                    let iter_call = &iter_calls[0];\n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        stmt.span.until(iter_call.span),\n+                        NEEDLESS_COLLECT_MSG,\n+                        |diag| {\n+                            let iter_replacement = format!(\"{}{}\", Sugg::hir(cx, iter_source, \"..\"), iter_call.get_iter_method(cx));\n+                            diag.multipart_suggestion(\n+                                iter_call.get_suggestion_text(),\n+                                vec![\n+                                    (stmt.span, String::new()),\n+                                    (iter_call.span, iter_replacement)\n+                                ],\n+                                Applicability::MachineApplicable,// MaybeIncorrect,\n+                            ).emit();\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct IterFunction {\n+    func: IterFunctionKind,\n+    span: Span,\n+}\n+impl IterFunction {\n+    fn get_iter_method(&self, cx: &LateContext<'_>) -> String {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => String::new(),\n+            IterFunctionKind::Len => String::from(\".count()\"),\n+            IterFunctionKind::IsEmpty => String::from(\".next().is_none()\"),\n+            IterFunctionKind::Contains(span) => format!(\".any(|x| x == {})\", snippet(cx, *span, \"..\")),\n+        }\n+    }\n+    fn get_suggestion_text(&self) -> &'static str {\n+        match &self.func {\n+            IterFunctionKind::IntoIter => {\n+                \"Use the original Iterator instead of collecting it and then producing a new one\"\n+            },\n+            IterFunctionKind::Len => {\n+                \"Take the original Iterator's count instead of collecting it and finding the length\"\n+            },\n+            IterFunctionKind::IsEmpty => {\n+                \"Check if the original Iterator has anything instead of collecting it and seeing if it's empty\"\n+            },\n+            IterFunctionKind::Contains(_) => {\n+                \"Check if the original Iterator contains an element instead of collecting then checking\"\n+            },\n+        }\n+    }\n+}\n+enum IterFunctionKind {\n+    IntoIter,\n+    Len,\n+    IsEmpty,\n+    Contains(Span),\n+}\n+\n+struct IterFunctionVisitor {\n+    uses: Vec<IterFunction>,\n+    seen_other: bool,\n+    target: Ident,\n+}\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        // Check function calls on our collection\n+        if_chain! {\n+            if let ExprKind::MethodCall(method_name, _, ref args, _) = &expr.kind;\n+            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. }) = args.get(0);\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                let len = sym!(len);\n+                let is_empty = sym!(is_empty);\n+                let contains = sym!(contains);\n+                match method_name.ident.name {\n+                    sym::into_iter => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n+                    ),\n+                    name if name == len => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n+                    ),\n+                    name if name == is_empty => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n+                    ),\n+                    name if name == contains => self.uses.push(\n+                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n+                    ),\n+                    _ => self.seen_other = true,\n+                }\n+                return\n+            }\n+        }\n+        // Check if the collection is used for anything else\n+        if_chain! {\n+            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, ref path)), .. } = expr;\n+            if let &[name] = &path.segments;\n+            if name.ident == self.target;\n+            then {\n+                self.seen_other = true;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Detect the occurences of calls to `iter` or `into_iter` for the\n+/// given identifier\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+    let mut visitor = IterFunctionVisitor {\n+        uses: Vec::new(),\n+        target: identifier,\n+        seen_other: false,\n+    };\n+    visitor.visit_block(block);\n+    if visitor.seen_other {\n+        None\n+    } else {\n+        Some(visitor.uses)\n+    }\n+}\n+\n fn shorten_span(expr: &Expr<'_>, target_fn_name: Symbol) -> Span {\n     let mut current_expr = expr;\n     while let ExprKind::MethodCall(ref path, ref span, ref args, _) = current_expr.kind {"}, {"sha": "9217324b18cc4188e33b9e548bb854ee7242295f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -2569,34 +2569,48 @@ fn lint_ok_expect(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ok_args: &[hir::Ex\n fn lint_map_flatten<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n-        let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n-                    This is more succinctly expressed by calling `.flat_map(..)`\";\n-        let self_snippet = snippet(cx, map_args[0].span, \"..\");\n+        let map_closure_ty = cx.typeck_results().expr_ty(&map_args[1]);\n+        let is_map_to_option = match map_closure_ty.kind {\n+            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+                let map_closure_sig = match map_closure_ty.kind {\n+                    ty::Closure(_, substs) => substs.as_closure().sig(),\n+                    _ => map_closure_ty.fn_sig(cx.tcx),\n+                };\n+                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(&map_closure_sig.output());\n+                is_type_diagnostic_item(cx, map_closure_return_ty, sym!(option_type))\n+            },\n+            _ => false,\n+        };\n+\n+        let method_to_use = if is_map_to_option {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            \"filter_map\"\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            \"flat_map\"\n+        };\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let hint = format!(\"{0}.flat_map({1})\", self_snippet, func_snippet);\n+        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span,\n-            msg,\n-            \"try using `flat_map` instead\",\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Iterator`\",\n+            &format!(\"try using `{}` instead\", method_to_use),\n             hint,\n             Applicability::MachineApplicable,\n         );\n     }\n \n     // lint if caller of `.map().flatten()` is an Option\n     if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&map_args[0]), sym!(option_type)) {\n-        let msg = \"called `map(..).flatten()` on an `Option`. \\\n-                    This is more succinctly expressed by calling `.and_then(..)`\";\n-        let self_snippet = snippet(cx, map_args[0].span, \"..\");\n         let func_snippet = snippet(cx, map_args[1].span, \"..\");\n-        let hint = format!(\"{0}.and_then({1})\", self_snippet, func_snippet);\n+        let hint = format!(\".and_then({})\", func_snippet);\n         span_lint_and_sugg(\n             cx,\n             MAP_FLATTEN,\n-            expr.span,\n-            msg,\n+            expr.span.with_lo(map_args[0].span.hi()),\n+            \"called `map(..).flatten()` on an `Option`\",\n             \"try using `and_then` instead\",\n             hint,\n             Applicability::MachineApplicable,"}, {"sha": "2610157763a8b97dcdb9a818c1ee1cfb7417190f", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -1,4 +1,3 @@\n-use crate::reexport::Name;\n use crate::utils::{contains_name, higher, iter_input_pats, snippet, span_lint_and_then};\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n@@ -10,6 +9,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n+use rustc_span::symbol::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for bindings that shadow other bindings already in\n@@ -123,7 +123,7 @@ fn check_fn<'tcx>(cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>, body: &'tcx Bo\n     check_expr(cx, &body.value, &mut bindings);\n }\n \n-fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     let len = bindings.len();\n     for stmt in block.stmts {\n         match stmt.kind {\n@@ -138,7 +138,7 @@ fn check_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'_>, bindings: &\n     bindings.truncate(len);\n }\n \n-fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     if in_external_macro(cx.sess(), local.span) {\n         return;\n     }\n@@ -173,7 +173,7 @@ fn check_pat<'tcx>(\n     pat: &'tcx Pat<'_>,\n     init: Option<&'tcx Expr<'_>>,\n     span: Span,\n-    bindings: &mut Vec<(Name, Span)>,\n+    bindings: &mut Vec<(Symbol, Span)>,\n ) {\n     // TODO: match more stuff / destructuring\n     match pat.kind {\n@@ -254,7 +254,7 @@ fn check_pat<'tcx>(\n \n fn lint_shadow<'tcx>(\n     cx: &LateContext<'tcx>,\n-    name: Name,\n+    name: Symbol,\n     span: Span,\n     pattern_span: Span,\n     init: Option<&'tcx Expr<'_>>,\n@@ -315,7 +315,7 @@ fn lint_shadow<'tcx>(\n     }\n }\n \n-fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n@@ -351,7 +351,7 @@ fn check_expr<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, bindings: &mut\n     }\n }\n \n-fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(Symbol, Span)>) {\n     match ty.kind {\n         TyKind::Slice(ref sty) => check_ty(cx, sty, bindings),\n         TyKind::Array(ref fty, ref anon_const) => {\n@@ -371,7 +371,7 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, ty: &'tcx Ty<'_>, bindings: &mut Vec<(\n     }\n }\n \n-fn is_self_shadow(name: Name, expr: &Expr<'_>) -> bool {\n+fn is_self_shadow(name: Symbol, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Box(ref inner) | ExprKind::AddrOf(_, _, ref inner) => is_self_shadow(name, inner),\n         ExprKind::Block(ref block, _) => {\n@@ -383,6 +383,6 @@ fn is_self_shadow(name: Name, expr: &Expr<'_>) -> bool {\n     }\n }\n \n-fn path_eq_name(name: Name, path: &Path<'_>) -> bool {\n+fn path_eq_name(name: Symbol, path: &Path<'_>) -> bool {\n     !path.is_global() && path.segments.len() == 1 && path.segments[0].ident.as_str() == name.as_str()\n }"}, {"sha": "06631f89f27ddf5633f80b62ca095547c1c55bf7", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -2,9 +2,10 @@ use crate::utils::{in_macro, snippet, snippet_with_applicability, span_lint_and_\n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::{GenericBound, Generics, WherePredicate};\n+use rustc_hir::{def::Res, GenericBound, Generics, ParamName, Path, QPath, TyKind, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns about unnecessary type repetitions in trait bounds\n@@ -29,6 +30,35 @@ declare_clippy_lint! {\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for cases where generics are being used and multiple\n+    /// syntax specifications for trait bounds are used simultaneously.\n+    ///\n+    /// **Why is this bad?** Duplicate bounds makes the code\n+    /// less readable than specifing them only once.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// fn func<T: Clone + Default>(arg: T) where T: Clone + Default {}\n+    /// ```\n+    ///\n+    /// Could be written as:\n+    ///\n+    /// ```rust\n+    /// fn func<T: Clone + Default>(arg: T) {}\n+    /// ```\n+    /// or\n+    ///  ///\n+    /// ```rust\n+    /// fn func<T>(arg: T) where T: Clone + Default {}\n+    /// ```\n+    pub TRAIT_DUPLICATION_IN_BOUNDS,\n+    pedantic,\n+    \"Check if the same trait bounds are specified twice during a function declaration\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TraitBounds {\n     max_trait_bounds: u64,\n@@ -41,10 +71,25 @@ impl TraitBounds {\n     }\n }\n \n-impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS]);\n+impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS, TRAIT_DUPLICATION_IN_BOUNDS]);\n \n impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n     fn check_generics(&mut self, cx: &LateContext<'tcx>, gen: &'tcx Generics<'_>) {\n+        self.check_type_repetition(cx, gen);\n+        check_trait_bound_duplication(cx, gen);\n+    }\n+}\n+\n+fn get_trait_res_span_from_bound(bound: &GenericBound<'_>) -> Option<(Res, Span)> {\n+    if let GenericBound::Trait(t, _) = bound {\n+        Some((t.trait_ref.path.res, t.span))\n+    } else {\n+        None\n+    }\n+}\n+\n+impl TraitBounds {\n+    fn check_type_repetition(self, cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         if in_macro(gen.span) {\n             return;\n         }\n@@ -101,3 +146,48 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n         }\n     }\n }\n+\n+fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n+    if in_macro(gen.span) || gen.params.is_empty() || gen.where_clause.predicates.is_empty() {\n+        return;\n+    }\n+\n+    let mut map = FxHashMap::default();\n+    for param in gen.params {\n+        if let ParamName::Plain(ref ident) = param.name {\n+            let res = param\n+                .bounds\n+                .iter()\n+                .filter_map(get_trait_res_span_from_bound)\n+                .collect::<Vec<_>>();\n+            map.insert(*ident, res);\n+        }\n+    }\n+\n+    for predicate in gen.where_clause.predicates {\n+        if_chain! {\n+            if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n+            if !in_macro(bound_predicate.span);\n+            if let TyKind::Path(ref path) = bound_predicate.bounded_ty.kind;\n+            if let QPath::Resolved(_, Path { ref segments, .. }) = path;\n+            if let Some(segment) = segments.first();\n+            if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n+            then {\n+                for (res_where, _) in bound_predicate.bounds.iter().filter_map(get_trait_res_span_from_bound) {\n+                    if let Some((_, span_direct)) = trait_resolutions_direct\n+                                                .iter()\n+                                                .find(|(res_direct, _)| *res_direct == res_where) {\n+                        span_lint_and_help(\n+                            cx,\n+                            TRAIT_DUPLICATION_IN_BOUNDS,\n+                            *span_direct,\n+                            \"this trait bound is already specified in the where clause\",\n+                            None,\n+                            \"consider removing this trait bound\",\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "214bfb7dda2cf0d9aa231616792e42bbe5cd208c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -52,7 +52,6 @@ use rustc_trait_selection::traits::query::normalize::AtExt;\n use smallvec::SmallVec;\n \n use crate::consts::{constant, Constant};\n-use crate::reexport::Name;\n \n /// Returns `true` if the two spans come from differing expansions (i.e., one is\n /// from a macro and one isn't).\n@@ -150,7 +149,7 @@ pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str])\n }\n \n /// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Name) -> bool {\n+pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n         if let [p] = path.segments {\n             return p.ident.name == var;\n@@ -420,7 +419,7 @@ pub fn is_entrypoint_fn(cx: &LateContext<'_>, def_id: DefId) -> bool {\n }\n \n /// Gets the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n     match cx.tcx.hir().find(parent_id) {\n         Some(\n@@ -433,7 +432,7 @@ pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Name> {\n }\n \n /// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Name> {\n+pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n     match pat.kind {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n@@ -443,14 +442,14 @@ pub fn get_pat_name(pat: &Pat<'_>) -> Option<Name> {\n }\n \n struct ContainsName {\n-    name: Name,\n+    name: Symbol,\n     result: bool,\n }\n \n impl<'tcx> Visitor<'tcx> for ContainsName {\n     type Map = Map<'tcx>;\n \n-    fn visit_name(&mut self, _: Span, name: Name) {\n+    fn visit_name(&mut self, _: Span, name: Symbol) {\n         if self.name == name {\n             self.result = true;\n         }\n@@ -461,7 +460,7 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n }\n \n /// Checks if an `Expr` contains a certain name.\n-pub fn contains_name(name: Name, expr: &Expr<'_>) -> bool {\n+pub fn contains_name(name: Symbol, expr: &Expr<'_>) -> bool {\n     let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n@@ -1027,7 +1026,7 @@ pub fn is_allowed(cx: &LateContext<'_>, lint: &'static Lint, id: HirId) -> bool\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n-pub fn get_arg_name(pat: &Pat<'_>) -> Option<Name> {\n+pub fn get_arg_name(pat: &Pat<'_>) -> Option<Symbol> {\n     match pat.kind {\n         PatKind::Binding(.., ident, None) => Some(ident.name),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),"}, {"sha": "a08d7da6dcb8730fe4fbf388f764ba8fda100014", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -360,6 +360,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"derive\",\n     },\n+    Lint {\n+        name: \"derive_ord_xor_partial_ord\",\n+        group: \"correctness\",\n+        desc: \"deriving `Ord` but implementing `PartialOrd` explicitly\",\n+        deprecation: None,\n+        module: \"derive\",\n+    },\n     Lint {\n         name: \"diverging_sub_expression\",\n         group: \"complexity\",\n@@ -2166,6 +2173,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"misc\",\n     },\n+    Lint {\n+        name: \"trait_duplication_in_bounds\",\n+        group: \"pedantic\",\n+        desc: \"Check if the same trait bounds are specified twice during a function declaration\",\n+        deprecation: None,\n+        module: \"trait_bounds\",\n+    },\n     Lint {\n         name: \"transmute_bytes_to_str\",\n         group: \"complexity\","}, {"sha": "b82dc518a3ba60520d21f016e2b213ddb430bed4", "filename": "tests/ui/derive_ord_xor_partial_ord.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fderive_ord_xor_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fderive_ord_xor_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_ord_xor_partial_ord.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -0,0 +1,68 @@\n+#![warn(clippy::derive_ord_xor_partial_ord)]\n+\n+use std::cmp::Ordering;\n+\n+#[derive(PartialOrd, Ord, PartialEq, Eq)]\n+struct DeriveBoth;\n+\n+impl PartialEq<u64> for DeriveBoth {\n+    fn eq(&self, _: &u64) -> bool {\n+        true\n+    }\n+}\n+\n+impl PartialOrd<u64> for DeriveBoth {\n+    fn partial_cmp(&self, _: &u64) -> Option<Ordering> {\n+        Some(Ordering::Equal)\n+    }\n+}\n+\n+#[derive(Ord, PartialEq, Eq)]\n+struct DeriveOrd;\n+\n+impl PartialOrd for DeriveOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(other.cmp(self))\n+    }\n+}\n+\n+#[derive(Ord, PartialEq, Eq)]\n+struct DeriveOrdWithExplicitTypeVariable;\n+\n+impl PartialOrd<DeriveOrdWithExplicitTypeVariable> for DeriveOrdWithExplicitTypeVariable {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(other.cmp(self))\n+    }\n+}\n+\n+#[derive(PartialOrd, PartialEq, Eq)]\n+struct DerivePartialOrd;\n+\n+impl std::cmp::Ord for DerivePartialOrd {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Ordering::Less\n+    }\n+}\n+\n+#[derive(PartialOrd, PartialEq, Eq)]\n+struct ImplUserOrd;\n+\n+trait Ord {}\n+\n+// We don't want to lint on user-defined traits called `Ord`\n+impl Ord for ImplUserOrd {}\n+\n+mod use_ord {\n+    use std::cmp::{Ord, Ordering};\n+\n+    #[derive(PartialOrd, PartialEq, Eq)]\n+    struct DerivePartialOrdInUseOrd;\n+\n+    impl Ord for DerivePartialOrdInUseOrd {\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            Ordering::Less\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "66bc4d42ce8c3c85e80d571bcbb658884a92cbe3", "filename": "tests/ui/derive_ord_xor_partial_ord.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -0,0 +1,71 @@\n+error: you are deriving `Ord` but have implemented `PartialOrd` explicitly\n+  --> $DIR/derive_ord_xor_partial_ord.rs:20:10\n+   |\n+LL | #[derive(Ord, PartialEq, Eq)]\n+   |          ^^^\n+   |\n+   = note: `-D clippy::derive-ord-xor-partial-ord` implied by `-D warnings`\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:23:1\n+   |\n+LL | / impl PartialOrd for DeriveOrd {\n+LL | |     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+LL | |         Some(other.cmp(self))\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are deriving `Ord` but have implemented `PartialOrd` explicitly\n+  --> $DIR/derive_ord_xor_partial_ord.rs:29:10\n+   |\n+LL | #[derive(Ord, PartialEq, Eq)]\n+   |          ^^^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:32:1\n+   |\n+LL | / impl PartialOrd<DeriveOrdWithExplicitTypeVariable> for DeriveOrdWithExplicitTypeVariable {\n+LL | |     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+LL | |         Some(other.cmp(self))\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are implementing `Ord` explicitly but have derived `PartialOrd`\n+  --> $DIR/derive_ord_xor_partial_ord.rs:41:1\n+   |\n+LL | / impl std::cmp::Ord for DerivePartialOrd {\n+LL | |     fn cmp(&self, other: &Self) -> Ordering {\n+LL | |         Ordering::Less\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:38:10\n+   |\n+LL | #[derive(PartialOrd, PartialEq, Eq)]\n+   |          ^^^^^^^^^^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are implementing `Ord` explicitly but have derived `PartialOrd`\n+  --> $DIR/derive_ord_xor_partial_ord.rs:61:5\n+   |\n+LL | /     impl Ord for DerivePartialOrdInUseOrd {\n+LL | |         fn cmp(&self, other: &Self) -> Ordering {\n+LL | |             Ordering::Less\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:58:14\n+   |\n+LL |     #[derive(PartialOrd, PartialEq, Eq)]\n+   |              ^^^^^^^^^^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a5fdf7df613d325d6b5bf80ed09647806581adb0", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -5,6 +5,20 @@\n #![allow(clippy::map_identity)]\n \n fn main() {\n+    // mapping to Option on Iterator\n+    fn option_id(x: i8) -> Option<i8> {\n+        Some(x)\n+    }\n+    let option_id_ref: fn(i8) -> Option<i8> = option_id;\n+    let option_id_closure = |x| Some(x);\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id).collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_ref).collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_closure).collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(|x| x.checked_add(1)).collect();\n+\n+    // mapping to Iterator on Iterator\n     let _: Vec<_> = vec![5_i8; 6].into_iter().flat_map(|x| 0..x).collect();\n+\n+    // mapping to Option on Option\n     let _: Option<_> = (Some(Some(1))).and_then(|x| x);\n }"}, {"sha": "abbc4e16e567951af8a952810e2a7bce9724d832", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -5,6 +5,20 @@\n #![allow(clippy::map_identity)]\n \n fn main() {\n+    // mapping to Option on Iterator\n+    fn option_id(x: i8) -> Option<i8> {\n+        Some(x)\n+    }\n+    let option_id_ref: fn(i8) -> Option<i8> = option_id;\n+    let option_id_closure = |x| Some(x);\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+\n+    // mapping to Iterator on Iterator\n     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+\n+    // mapping to Option on Option\n     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n }"}, {"sha": "b6479cd69eac4f49f6a0abf08c55dc3ba7f0224d", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 32, "deletions": 8, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -1,16 +1,40 @@\n-error: called `map(..).flatten()` on an `Iterator`. This is more succinctly expressed by calling `.flat_map(..)`\n-  --> $DIR/map_flatten.rs:8:21\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:14:46\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `vec![5_i8; 6].into_iter().flat_map(|x| 0..x)`\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n-error: called `map(..).flatten()` on an `Option`. This is more succinctly expressed by calling `.and_then(..)`\n-  --> $DIR/map_flatten.rs:9:24\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:15:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n+\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:16:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n+\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:17:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n+\n+error: called `map(..).flatten()` on an `Iterator`\n+  --> $DIR/map_flatten.rs:20:46\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n+\n+error: called `map(..).flatten()` on an `Option`\n+  --> $DIR/map_flatten.rs:23:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `(Some(Some(1))).and_then(|x| x)`\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 6 previous errors\n "}, {"sha": "4cf03e820352356b84f873cac15c7fd094a8020b", "filename": "tests/ui/needless_collect_indirect.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -0,0 +1,19 @@\n+use std::collections::{HashMap, VecDeque};\n+\n+fn main() {\n+    let sample = [1; 5];\n+    let indirect_iter = sample.iter().collect::<Vec<_>>();\n+    indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+    let indirect_len = sample.iter().collect::<VecDeque<_>>();\n+    indirect_len.len();\n+    let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n+    indirect_empty.is_empty();\n+    let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n+    indirect_contains.contains(&&5);\n+    let indirect_negative = sample.iter().collect::<Vec<_>>();\n+    indirect_negative.len();\n+    indirect_negative\n+        .into_iter()\n+        .map(|x| (*x, *x + 1))\n+        .collect::<HashMap<_, _>>();\n+}"}, {"sha": "0c1e61d749661c5fb4a00652e75f6165407d08a8", "filename": "tests/ui/needless_collect_indirect.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fneedless_collect_indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Fneedless_collect_indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.stderr?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -0,0 +1,55 @@\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:5:5\n+   |\n+LL | /     let indirect_iter = sample.iter().collect::<Vec<_>>();\n+LL | |     indirect_iter.into_iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+   | |____^\n+   |\n+   = note: `-D clippy::needless-collect` implied by `-D warnings`\n+help: Use the original Iterator instead of collecting it and then producing a new one\n+   |\n+LL |     \n+LL |     sample.iter().map(|x| (x, x + 1)).collect::<HashMap<_, _>>();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:7:5\n+   |\n+LL | /     let indirect_len = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_len.len();\n+   | |____^\n+   |\n+help: Take the original Iterator's count instead of collecting it and finding the length\n+   |\n+LL |     \n+LL |     sample.iter().count();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:9:5\n+   |\n+LL | /     let indirect_empty = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_empty.is_empty();\n+   | |____^\n+   |\n+help: Check if the original Iterator has anything instead of collecting it and seeing if it's empty\n+   |\n+LL |     \n+LL |     sample.iter().next().is_none();\n+   |\n+\n+error: avoid using `collect()` when not needed\n+  --> $DIR/needless_collect_indirect.rs:11:5\n+   |\n+LL | /     let indirect_contains = sample.iter().collect::<VecDeque<_>>();\n+LL | |     indirect_contains.contains(&&5);\n+   | |____^\n+   |\n+help: Check if the original Iterator contains an element instead of collecting then checking\n+   |\n+LL |     \n+LL |     sample.iter().any(|x| x == &&5);\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "cb2b0054e352b4b951dd23f0444bc0c760caf87b", "filename": "tests/ui/trait_duplication_in_bounds.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -0,0 +1,31 @@\n+#![deny(clippy::trait_duplication_in_bounds)]\n+\n+use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n+\n+fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+where\n+    T: Clone,\n+    T: Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_bar<T: Clone + Default>(arg: T) {\n+    unimplemented!();\n+}\n+\n+fn good_foo<T>(arg: T)\n+where\n+    T: Clone + Default,\n+{\n+    unimplemented!();\n+}\n+\n+fn good_foobar<T: Default>(arg: T)\n+where\n+    T: Clone,\n+{\n+    unimplemented!();\n+}\n+\n+fn main() {}"}, {"sha": "027e1c752041214d756a812f2308e335d1ff6154", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=80121781a3eaf75d3b7cbf54b8b4d0a419e39bbe", "patch": "@@ -0,0 +1,23 @@\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:5:15\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |               ^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/trait_duplication_in_bounds.rs:1:9\n+   |\n+LL | #![deny(clippy::trait_duplication_in_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: consider removing this trait bound\n+\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:5:23\n+   |\n+LL | fn bad_foo<T: Clone + Default, Z: Copy>(arg0: T, arg1: Z)\n+   |                       ^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 2 previous errors\n+"}]}