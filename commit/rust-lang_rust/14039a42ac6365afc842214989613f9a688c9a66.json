{"sha": "14039a42ac6365afc842214989613f9a688c9a66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MDM5YTQyYWM2MzY1YWZjODQyMjE0OTg5NjEzZjlhNjg4YzlhNjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-22T17:24:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-22T17:24:29Z"}, "message": "Auto merge of #44696 - michaelwoerister:fingerprints-in-dep-graph-3, r=nikomatsakis\n\nincr.comp.: Move task result fingerprinting into DepGraph.\n\nThis PR\n- makes the DepGraph store all `Fingerprints` of task results,\n- allows `DepNode` to be marked as input nodes,\n- makes HIR node hashing use the regular fingerprinting infrastructure,\n- removes the now unused `IncrementalHashesMap`, and\n- makes sure that `traits_in_scope_map` fingerprints are stable.\n\nr? @nikomatsakis\ncc @alexcrichton", "tree": {"sha": "8d753cb8e0844ecde2015f11a8a3abfc90d01f72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d753cb8e0844ecde2015f11a8a3abfc90d01f72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14039a42ac6365afc842214989613f9a688c9a66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14039a42ac6365afc842214989613f9a688c9a66", "html_url": "https://github.com/rust-lang/rust/commit/14039a42ac6365afc842214989613f9a688c9a66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14039a42ac6365afc842214989613f9a688c9a66/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eb19bf9b160825cd338b9419551670a30962c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eb19bf9b160825cd338b9419551670a30962c4e", "html_url": "https://github.com/rust-lang/rust/commit/3eb19bf9b160825cd338b9419551670a30962c4e"}, {"sha": "9798a88e9ecfc8354653b225c681cd533a88505d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9798a88e9ecfc8354653b225c681cd533a88505d", "html_url": "https://github.com/rust-lang/rust/commit/9798a88e9ecfc8354653b225c681cd533a88505d"}], "stats": {"total": 932, "additions": 417, "deletions": 515}, "files": [{"sha": "77db2fc70bc2f9efa0eda17b8622731d9b1bd399", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -80,14 +80,28 @@ macro_rules! erase {\n     ($x:tt) => ({})\n }\n \n-macro_rules! anon_attr_to_bool {\n-    (anon) => (true)\n+macro_rules! is_anon_attr {\n+    (anon) => (true);\n+    ($attr:ident) => (false);\n+}\n+\n+macro_rules! is_input_attr {\n+    (input) => (true);\n+    ($attr:ident) => (false);\n+}\n+\n+macro_rules! contains_anon_attr {\n+    ($($attr:ident),*) => ({$(is_anon_attr!($attr) | )* false});\n+}\n+\n+macro_rules! contains_input_attr {\n+    ($($attr:ident),*) => ({$(is_input_attr!($attr) | )* false});\n }\n \n macro_rules! define_dep_nodes {\n     (<$tcx:tt>\n     $(\n-        [$($anon:ident)*]\n+        [$($attr:ident),* ]\n         $variant:ident $(( $($tuple_arg:tt),* ))*\n                        $({ $($struct_arg_name:ident : $struct_arg_ty:ty),* })*\n       ,)*\n@@ -105,7 +119,9 @@ macro_rules! define_dep_nodes {\n                 match *self {\n                     $(\n                         DepKind :: $variant => {\n-                            $(return !anon_attr_to_bool!($anon);)*\n+                            if contains_anon_attr!($($attr),*) {\n+                                return false;\n+                            }\n \n                             // tuple args\n                             $({\n@@ -126,15 +142,20 @@ macro_rules! define_dep_nodes {\n                 }\n             }\n \n-            #[allow(unreachable_code)]\n             #[inline]\n-            pub fn is_anon<$tcx>(&self) -> bool {\n+            pub fn is_anon(&self) -> bool {\n                 match *self {\n                     $(\n-                        DepKind :: $variant => {\n-                            $(return anon_attr_to_bool!($anon);)*\n-                            false\n-                        }\n+                        DepKind :: $variant => { contains_anon_attr!($($attr),*) }\n+                    )*\n+                }\n+            }\n+\n+            #[inline]\n+            pub fn is_input(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => { contains_input_attr!($($attr),*) }\n                     )*\n                 }\n             }\n@@ -366,6 +387,17 @@ impl DefId {\n     }\n }\n \n+impl DepKind {\n+    #[inline]\n+    pub fn fingerprint_needed_for_crate_hash(self) -> bool {\n+        match self {\n+            DepKind::HirBody |\n+            DepKind::Krate => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n define_dep_nodes!( <'tcx>\n     // Represents the `Krate` as a whole (the `hir::Krate` value) (as\n     // distinct from the krate module). This is basically a hash of\n@@ -378,18 +410,17 @@ define_dep_nodes!( <'tcx>\n     // suitable wrapper, you can use `tcx.dep_graph.ignore()` to gain\n     // access to the krate, but you must remember to add suitable\n     // edges yourself for the individual items that you read.\n-    [] Krate,\n-\n-    // Represents the HIR node with the given node-id\n-    [] Hir(DefId),\n+    [input] Krate,\n \n     // Represents the body of a function or method. The def-id is that of the\n     // function/method.\n-    [] HirBody(DefId),\n+    [input] HirBody(DefId),\n+\n+    // Represents the HIR node with the given node-id\n+    [input] Hir(DefId),\n \n-    // Represents the metadata for a given HIR node, typically found\n-    // in an extern crate.\n-    [] MetaData(DefId),\n+    // Represents metadata from an extern crate.\n+    [input] MetaData(DefId),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier.\n@@ -529,7 +560,7 @@ define_dep_nodes!( <'tcx>\n     [] ExternCrate(DefId),\n     [] LintLevels,\n     [] Specializes { impl1: DefId, impl2: DefId },\n-    [] InScopeTraits(DefIndex),\n+    [input] InScopeTraits(DefIndex),\n     [] ModuleExports(DefId),\n     [] IsSanitizerRuntime(CrateNum),\n     [] IsProfilerRuntime(CrateNum),"}, {"sha": "29c0ba66f3f726e0c3277676a3de4ba5d2b4e388", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -123,6 +123,7 @@ impl DepGraphEdges {\n             reads\n         } = popped_node {\n             debug_assert_eq!(node, key);\n+            debug_assert!(!node.kind.is_input() || reads.is_empty());\n \n             let target_id = self.get_or_create_node(node);\n "}, {"sha": "90a29b6348245fb24eb7b798b7a89ce2330cf3b8", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -26,7 +26,16 @@ use super::edges::{DepGraphEdges, DepNodeIndex};\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Option<Rc<DepGraphData>>\n+    data: Option<Rc<DepGraphData>>,\n+\n+    // At the moment we are using DepNode as key here. In the future it might\n+    // be possible to use an IndexVec<DepNodeIndex, _> here. At the moment there\n+    // are a few problems with that:\n+    // - Some fingerprints are needed even if incr. comp. is disabled -- yet\n+    //   we need to have a dep-graph to generate DepNodeIndices.\n+    // - The architecture is still in flux and it's not clear what how to best\n+    //   implement things.\n+    fingerprints: Rc<RefCell<FxHashMap<DepNode, Fingerprint>>>\n }\n \n struct DepGraphData {\n@@ -57,7 +66,8 @@ impl DepGraph {\n                 }))\n             } else {\n                 None\n-            }\n+            },\n+            fingerprints: Rc::new(RefCell::new(FxHashMap())),\n         }\n     }\n \n@@ -139,11 +149,27 @@ impl DepGraph {\n \n             let mut stable_hasher = StableHasher::new();\n             result.hash_stable(&mut hcx, &mut stable_hasher);\n-            let _: Fingerprint = stable_hasher.finish();\n+\n+            assert!(self.fingerprints\n+                        .borrow_mut()\n+                        .insert(key, stable_hasher.finish())\n+                        .is_none());\n \n             (result, dep_node_index)\n         } else {\n-            (task(cx, arg), DepNodeIndex::INVALID)\n+            if key.kind.fingerprint_needed_for_crate_hash() {\n+                let mut hcx = cx.create_stable_hashing_context();\n+                let result = task(cx, arg);\n+                let mut stable_hasher = StableHasher::new();\n+                result.hash_stable(&mut hcx, &mut stable_hasher);\n+                assert!(self.fingerprints\n+                            .borrow_mut()\n+                            .insert(key, stable_hasher.finish())\n+                            .is_none());\n+                (result, DepNodeIndex::INVALID)\n+            } else {\n+                (task(cx, arg), DepNodeIndex::INVALID)\n+            }\n         }\n     }\n \n@@ -195,6 +221,10 @@ impl DepGraph {\n         }\n     }\n \n+    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+        self.fingerprints.borrow().get(dep_node).cloned()\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory)."}, {"sha": "51433238f2cf6fcdde713554e0847edaaa48f4d2", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 149, "deletions": 33, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -16,6 +16,9 @@ use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+\n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n@@ -25,37 +28,104 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: NodeId,\n \n+    // These fields keep track of the currently relevant DepNodes during\n+    // the visitor's traversal.\n     current_dep_node_owner: DefIndex,\n-    current_dep_node_index: DepNodeIndex,\n+    current_signature_dep_index: DepNodeIndex,\n+    current_full_dep_index: DepNodeIndex,\n+    currently_in_body: bool,\n \n     dep_graph: &'a DepGraph,\n     definitions: &'a definitions::Definitions,\n+\n+    hcx: StableHashingContext<'a>,\n+\n+    // We are collecting DepNode::HirBody hashes here so we can compute the\n+    // crate hash from then later on.\n+    hir_body_nodes: Vec<DefPathHash>,\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n     pub(super) fn root(krate: &'hir Crate,\n-                dep_graph: &'a DepGraph,\n-                definitions: &'a definitions::Definitions)\n+                       dep_graph: &'a DepGraph,\n+                       definitions: &'a definitions::Definitions,\n+                       hcx: StableHashingContext<'a>)\n                 -> NodeCollector<'a, 'hir> {\n         let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n-        let root_mod_dep_node = root_mod_def_path_hash.to_dep_node(DepKind::Hir);\n-        let root_mod_dep_node_index = dep_graph.alloc_input_node(root_mod_dep_node);\n+\n+        // Allocate DepNodes for the root module\n+        let (root_mod_sig_dep_index, root_mod_full_dep_index);\n+        {\n+            let Crate {\n+                ref module,\n+                // Crate attributes are not copied over to the root `Mod`, so hash\n+                // them explicitly here.\n+                ref attrs,\n+                span,\n+\n+                // These fields are handled separately:\n+                exported_macros: _,\n+                items: _,\n+                trait_items: _,\n+                impl_items: _,\n+                bodies: _,\n+                trait_impls: _,\n+                trait_default_impl: _,\n+                body_ids: _,\n+            } = *krate;\n+\n+            root_mod_sig_dep_index = dep_graph.with_task(\n+                root_mod_def_path_hash.to_dep_node(DepKind::Hir),\n+                &hcx,\n+                HirItemLike { item_like: (module, attrs, span), hash_bodies: false },\n+                identity_fn\n+            ).1;\n+            root_mod_full_dep_index = dep_graph.with_task(\n+                root_mod_def_path_hash.to_dep_node(DepKind::HirBody),\n+                &hcx,\n+                HirItemLike { item_like: (module, attrs, span), hash_bodies: true },\n+                identity_fn\n+            ).1;\n+        }\n+\n+        let hir_body_nodes = vec![root_mod_def_path_hash];\n \n         let mut collector = NodeCollector {\n             krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n-            current_dep_node_index: root_mod_dep_node_index,\n+            current_signature_dep_index: root_mod_sig_dep_index,\n+            current_full_dep_index: root_mod_full_dep_index,\n             current_dep_node_owner: CRATE_DEF_INDEX,\n+            currently_in_body: false,\n             dep_graph,\n             definitions,\n+            hcx,\n+            hir_body_nodes,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_dep_node_index));\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_sig_dep_index));\n \n         collector\n     }\n \n-    pub(super) fn into_map(self) -> Vec<MapEntry<'hir>> {\n+    pub(super) fn finalize_and_compute_crate_hash(self,\n+                                                  crate_disambiguator: &str)\n+                                                  -> Vec<MapEntry<'hir>> {\n+        let mut node_hashes: Vec<_> = self\n+            .hir_body_nodes\n+            .iter()\n+            .map(|&def_path_hash| {\n+                let dep_node = def_path_hash.to_dep_node(DepKind::HirBody);\n+                (def_path_hash, self.dep_graph.fingerprint_of(&dep_node))\n+            })\n+            .collect();\n+\n+        node_hashes.sort_unstable_by(|&(ref d1, _), &(ref d2, _)| d1.cmp(d2));\n+\n+        self.dep_graph.with_task(DepNode::new_no_params(DepKind::Krate),\n+                                 &self.hcx,\n+                                 (node_hashes, crate_disambiguator),\n+                                 identity_fn);\n         self.map\n     }\n \n@@ -70,7 +140,11 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n         let parent = self.parent_node;\n-        let dep_node_index = self.current_dep_node_index;\n+        let dep_node_index = if self.currently_in_body {\n+            self.current_full_dep_index\n+        } else {\n+            self.current_signature_dep_index\n+        };\n \n         let entry = match node {\n             NodeItem(n) => EntryItem(parent, dep_node_index, n),\n@@ -91,6 +165,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n             NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n             NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n+            NodeMacroDef(n) => EntryMacroDef(dep_node_index, n),\n         };\n \n         // Make sure that the DepNode of some node coincides with the HirId\n@@ -127,22 +202,41 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<F: FnOnce(&mut Self)>(&mut self,\n+    fn with_dep_node_owner<T: HashStable<StableHashingContext<'a>>,\n+                           F: FnOnce(&mut Self)>(&mut self,\n                                                  dep_node_owner: DefIndex,\n+                                                 item_like: &T,\n                                                  f: F) {\n         let prev_owner = self.current_dep_node_owner;\n-        let prev_index = self.current_dep_node_index;\n-\n-        // When we enter a new owner (item, impl item, or trait item), we always\n-        // start out again with DepKind::Hir.\n-        let new_dep_node = self.definitions\n-                               .def_path_hash(dep_node_owner)\n-                               .to_dep_node(DepKind::Hir);\n-        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        let prev_signature_dep_index = self.current_signature_dep_index;\n+        let prev_full_dep_index = self.current_signature_dep_index;\n+        let prev_in_body = self.currently_in_body;\n+\n+        let def_path_hash = self.definitions.def_path_hash(dep_node_owner);\n+\n+        self.current_signature_dep_index = self.dep_graph.with_task(\n+            def_path_hash.to_dep_node(DepKind::Hir),\n+            &self.hcx,\n+            HirItemLike { item_like, hash_bodies: false },\n+            identity_fn\n+        ).1;\n+\n+        self.current_full_dep_index = self.dep_graph.with_task(\n+            def_path_hash.to_dep_node(DepKind::HirBody),\n+            &self.hcx,\n+            HirItemLike { item_like, hash_bodies: true },\n+            identity_fn\n+        ).1;\n+\n+        self.hir_body_nodes.push(def_path_hash);\n+\n         self.current_dep_node_owner = dep_node_owner;\n+        self.currently_in_body = false;\n         f(self);\n-        self.current_dep_node_index = prev_index;\n+        self.currently_in_body = prev_in_body;\n         self.current_dep_node_owner = prev_owner;\n+        self.current_full_dep_index = prev_full_dep_index;\n+        self.current_signature_dep_index = prev_signature_dep_index;\n     }\n }\n \n@@ -169,24 +263,17 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n-        // When we enter a body, we switch to DepKind::HirBody.\n-        // Note that current_dep_node_index might already be DepKind::HirBody,\n-        // e.g. when entering the body of a closure that is already part of a\n-        // surrounding body. That's expected and not a problem.\n-        let prev_index = self.current_dep_node_index;\n-        let new_dep_node = self.definitions\n-                               .def_path_hash(self.current_dep_node_owner)\n-                               .to_dep_node(DepKind::HirBody);\n-        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        let prev_in_body = self.currently_in_body;\n+        self.currently_in_body = true;\n         self.visit_body(self.krate.body(id));\n-        self.current_dep_node_index = prev_index;\n+        self.currently_in_body = prev_in_body;\n     }\n \n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.hir_id.owner,\n                          self.definitions.opt_def_index(i.id).unwrap());\n-        self.with_dep_node_owner(i.hir_id.owner, |this| {\n+        self.with_dep_node_owner(i.hir_id.owner, i, |this| {\n             this.insert(i.id, NodeItem(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n@@ -222,7 +309,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n         debug_assert_eq!(ti.hir_id.owner,\n                          self.definitions.opt_def_index(ti.id).unwrap());\n-        self.with_dep_node_owner(ti.hir_id.owner, |this| {\n+        self.with_dep_node_owner(ti.hir_id.owner, ti, |this| {\n             this.insert(ti.id, NodeTraitItem(ti));\n \n             this.with_parent(ti.id, |this| {\n@@ -234,7 +321,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n         debug_assert_eq!(ii.hir_id.owner,\n                          self.definitions.opt_def_index(ii.id).unwrap());\n-        self.with_dep_node_owner(ii.hir_id.owner, |this| {\n+        self.with_dep_node_owner(ii.hir_id.owner, ii, |this| {\n             this.insert(ii.id, NodeImplItem(ii));\n \n             this.with_parent(ii.id, |this| {\n@@ -328,7 +415,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir MacroDef) {\n-        self.insert_entry(macro_def.id, NotPresent);\n+        let def_index = self.definitions.opt_def_index(macro_def.id).unwrap();\n+\n+        self.with_dep_node_owner(def_index, macro_def, |this| {\n+            this.insert(macro_def.id, NodeMacroDef(macro_def));\n+        });\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: NodeId) {\n@@ -375,3 +466,28 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.visit_nested_impl_item(id);\n     }\n }\n+\n+// We use this with DepGraph::with_task(). Since we are handling only input\n+// values here, the \"task\" computing them just passes them through.\n+fn identity_fn<T>(_: &StableHashingContext, item_like: T) -> T {\n+    item_like\n+}\n+\n+// This is a wrapper structure that allows determining if span values within\n+// the wrapped item should be hashed or not.\n+struct HirItemLike<T> {\n+    item_like: T,\n+    hash_bodies: bool,\n+}\n+\n+impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n+    where T: HashStable<StableHashingContext<'hir>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'hir>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.while_hashing_hir_bodies(self.hash_bodies, |hcx| {\n+            self.item_like.hash_stable(hcx, hasher);\n+        });\n+    }\n+}"}, {"sha": "d003ec40a06bd6563fc7005221d0339f8acf0398", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -57,6 +57,7 @@ pub enum Node<'hir> {\n     NodePat(&'hir Pat),\n     NodeBlock(&'hir Block),\n     NodeLocal(&'hir Local),\n+    NodeMacroDef(&'hir MacroDef),\n \n     /// NodeStructCtor represents a tuple struct.\n     NodeStructCtor(&'hir VariantData),\n@@ -93,6 +94,8 @@ enum MapEntry<'hir> {\n     EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n     EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n \n+    EntryMacroDef(DepNodeIndex, &'hir MacroDef),\n+\n     /// Roots for node trees. The DepNodeIndex is the dependency node of the\n     /// crate's root module.\n     RootCrate(DepNodeIndex),\n@@ -127,6 +130,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryLocal(id, _, _) => id,\n \n             NotPresent |\n+            EntryMacroDef(..) |\n             RootCrate(_) => return None,\n         })\n     }\n@@ -151,6 +155,7 @@ impl<'hir> MapEntry<'hir> {\n             EntryTyParam(_, _, n) => NodeTyParam(n),\n             EntryVisibility(_, _, n) => NodeVisibility(n),\n             EntryLocal(_, _, n) => NodeLocal(n),\n+            EntryMacroDef(_, n) => NodeMacroDef(n),\n \n             NotPresent |\n             RootCrate(_) => return None\n@@ -285,20 +290,12 @@ impl<'hir> Map<'hir> {\n             EntryVisibility(_, dep_node_index, _) |\n             EntryExpr(_, dep_node_index, _) |\n             EntryLocal(_, dep_node_index, _) |\n+            EntryMacroDef(dep_node_index, _) |\n             RootCrate(dep_node_index) => {\n                 self.dep_graph.read_index(dep_node_index);\n             }\n             NotPresent => {\n-                // Some nodes, notably macro definitions, are not\n-                // present in the map for whatever reason, but\n-                // they *do* have def-ids. So if we encounter an\n-                // empty hole, check for that case.\n-                if let Some(def_index) = self.definitions.opt_def_index(id) {\n-                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n-                } else {\n-                    bug!(\"called HirMap::read() with invalid NodeId\")\n-                }\n+                bug!(\"called HirMap::read() with invalid NodeId\")\n             }\n         }\n     }\n@@ -875,6 +872,7 @@ impl<'hir> Map<'hir> {\n             Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n+            Some(EntryMacroDef(_, macro_def)) => macro_def.span,\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n@@ -1012,15 +1010,22 @@ impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n-pub fn map_crate<'hir>(forest: &'hir mut Forest,\n+pub fn map_crate<'hir>(sess: &::session::Session,\n+                       cstore: &::middle::cstore::CrateStore,\n+                       forest: &'hir mut Forest,\n                        definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let map = {\n+        let hcx = ::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+\n         let mut collector = NodeCollector::root(&forest.krate,\n                                                 &forest.dep_graph,\n-                                                &definitions);\n+                                                &definitions,\n+                                                hcx);\n         intravisit::walk_crate(&mut collector, &forest.krate);\n-        collector.into_map()\n+\n+        let crate_disambiguator = sess.local_crate_disambiguator().as_str();\n+        collector.finalize_and_compute_crate_hash(&crate_disambiguator)\n     };\n \n     if log_enabled!(::log::LogLevel::Debug) {\n@@ -1103,6 +1108,7 @@ impl<'a> print::State<'a> {\n             // printing.\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n             NodeLocal(a)       => self.print_local_decl(&a),\n+            NodeMacroDef(_)    => bug!(\"cannot print MacroDef\"),\n         }\n     }\n }\n@@ -1219,6 +1225,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeVisibility(ref vis)) => {\n             format!(\"visibility {:?}{}\", vis, id_str)\n         }\n+        Some(NodeMacroDef(_)) => {\n+            format!(\"macro {}{}\",  path_str(), id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "e393459027859a741d86de7ff4ec63dd2bcad3a4", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -22,6 +22,7 @@ struct CacheEntry {\n     file_index: usize,\n }\n \n+#[derive(Clone)]\n pub struct CachingCodemapView<'cm> {\n     codemap: &'cm CodeMap,\n     line_cache: [CacheEntry; 3],"}, {"sha": "e7a26e14db5bbb6349a8b3c53295c266390f0987", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -43,6 +43,7 @@ thread_local!(static IGNORED_ATTR_NAMES: RefCell<FxHashSet<Symbol>> =\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n+#[derive(Clone)]\n pub struct StableHashingContext<'gcx> {\n     sess: &'gcx Session,\n     definitions: &'gcx Definitions,\n@@ -168,6 +169,11 @@ impl<'gcx> StableHashingContext<'gcx> {\n         self.definitions.def_path_hash(def_index)\n     }\n \n+    #[inline]\n+    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n+        self.definitions.node_to_hir_id(node_id)\n+    }\n+\n     #[inline]\n     pub fn hash_spans(&self) -> bool {\n         self.hash_spans\n@@ -259,6 +265,18 @@ impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n     }\n }\n \n+\n+impl<'gcx> StableHashingContextProvider for StableHashingContext<'gcx> {\n+    type ContextType = StableHashingContext<'gcx>;\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        self.clone()\n+    }\n+}\n+\n+impl<'gcx> ::dep_graph::DepGraphSafe for StableHashingContext<'gcx> {\n+}\n+\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,"}, {"sha": "b62b9e5ab46868fad66adf3c3904a65f83c4e438", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -698,7 +698,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n-            id,\n+            id: _,\n             hir_id: _,\n             name,\n             ref attrs,\n@@ -707,7 +707,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            id.hash_stable(hcx, hasher);\n             name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n@@ -732,7 +731,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n-            id,\n+            id: _,\n             hir_id: _,\n             name,\n             ref vis,\n@@ -743,7 +742,6 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n-            id.hash_stable(hcx, hasher);\n             name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n@@ -1167,6 +1165,25 @@ for hir::TraitCandidate {\n     }\n }\n \n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n+    type KeyType = (DefPathHash, Option<(DefPathHash, hir::ItemLocalId)>);\n+\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'gcx>)\n+                          -> Self::KeyType {\n+        let hir::TraitCandidate {\n+            def_id,\n+            import_id,\n+        } = *self;\n+\n+        let import_id = import_id.map(|node_id| hcx.node_to_hir_id(node_id))\n+                                 .map(|hir_id| (hcx.local_def_path_hash(hir_id.owner),\n+                                                hir_id.local_id));\n+        (hcx.def_path_hash(def_id), import_id)\n+    }\n+}\n+\n+\n impl_stable_hash_for!(struct hir::Freevar {\n     def,\n     span"}, {"sha": "55d0c6b4c66a34338337b14eee16eb5da9cd5164", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -310,7 +310,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             hir_map::NodeVariant(_) |\n             hir_map::NodeStructCtor(_) |\n             hir_map::NodeField(_) |\n-            hir_map::NodeTy(_) => {}\n+            hir_map::NodeTy(_) |\n+            hir_map::NodeMacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "d7327d2bd0fdce3a126b16191770acc49346d4ba", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -50,8 +50,8 @@ use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n-                                           StableHasher, StableHasherResult};\n-\n+                                           StableHasher, StableHasherResult,\n+                                           StableVec};\n use arena::{TypedArena, DroplessArena};\n use rustc_const_math::{ConstInt, ConstUsize};\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -828,7 +828,9 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n-    trait_map: FxHashMap<DefIndex, Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n+    trait_map: FxHashMap<DefIndex,\n+                         Rc<FxHashMap<ItemLocalId,\n+                                      Rc<StableVec<TraitCandidate>>>>>,\n \n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Rc<Vec<Export>>>,\n@@ -1081,15 +1083,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n-        // FIXME(mw): Each of the Vecs in the trait_map should be brought into\n-        // a deterministic order here. Otherwise we might end up with\n-        // unnecessarily unstable incr. comp. hashes.\n         let mut trait_map = FxHashMap();\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n             let map = trait_map.entry(hir_id.owner)\n                 .or_insert_with(|| Rc::new(FxHashMap()));\n-            Rc::get_mut(map).unwrap().insert(hir_id.local_id, Rc::new(v));\n+            Rc::get_mut(map).unwrap()\n+                            .insert(hir_id.local_id,\n+                                    Rc::new(StableVec::new(v)));\n         }\n         let mut defs = FxHashMap();\n         for (k, v) in named_region_map.defs {\n@@ -1235,6 +1236,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   self.hir.definitions(),\n                                   self.cstore)\n     }\n+\n+    // This method exercises the `in_scope_traits_map` query for all possible\n+    // values so that we have their fingerprints available in the DepGraph.\n+    // This is only required as long as we still use the old dependency tracking\n+    // which needs to have the fingerprints of all input nodes beforehand.\n+    pub fn precompute_in_scope_traits_hashes(self) {\n+        for &def_index in self.trait_map.keys() {\n+            self.in_scope_traits_map(def_index);\n+        }\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -2103,7 +2114,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         lint::struct_lint_level(self.sess, lint, level, src, None, msg)\n     }\n \n-    pub fn in_scope_traits(self, id: HirId) -> Option<Rc<Vec<TraitCandidate>>> {\n+    pub fn in_scope_traits(self, id: HirId) -> Option<Rc<StableVec<TraitCandidate>>> {\n         self.in_scope_traits_map(id.owner)\n             .and_then(|map| map.get(&id.local_id).cloned())\n     }"}, {"sha": "d264fecb52158258b617e567a7a637d4e04b389a", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -42,6 +42,7 @@ use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stable_hasher::StableVec;\n use std::cell::{RefCell, Cell};\n \n use std::ops::Deref;\n@@ -259,7 +260,7 @@ define_maps! { <'tcx>\n \n     [] fn specializes: specializes_node((DefId, DefId)) -> bool,\n     [] fn in_scope_traits_map: InScopeTraits(DefIndex)\n-        -> Option<Rc<FxHashMap<ItemLocalId, Rc<Vec<TraitCandidate>>>>>,\n+        -> Option<Rc<FxHashMap<ItemLocalId, Rc<StableVec<TraitCandidate>>>>>,\n     [] fn module_exports: ModuleExports(DefId) -> Option<Rc<Vec<Export>>>,\n     [] fn lint_levels: lint_levels_node(CrateNum) -> Rc<lint::LintLevelMap>,\n "}, {"sha": "9aba48c5bef07b60b5f065f15125977056415f9b", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -558,3 +558,37 @@ pub fn hash_stable_hashmap<HCX, K, V, R, SK, F, W>(\n     entries.hash_stable(hcx, hasher);\n }\n \n+\n+/// A vector container that makes sure that its items are hashed in a stable\n+/// order.\n+pub struct StableVec<T>(Vec<T>);\n+\n+impl<T> StableVec<T> {\n+    pub fn new(v: Vec<T>) -> Self {\n+        StableVec(v)\n+    }\n+}\n+\n+impl<T> ::std::ops::Deref for StableVec<T> {\n+    type Target = Vec<T>;\n+\n+    fn deref(&self) -> &Vec<T> {\n+        &self.0\n+    }\n+}\n+\n+impl<T, HCX> HashStable<HCX> for StableVec<T>\n+    where T: HashStable<HCX> + ToStableHashKey<HCX>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let StableVec(ref v) = *self;\n+\n+        let mut sorted: Vec<_> = v.iter()\n+                                  .map(|x| x.to_stable_hash_key(hcx))\n+                                  .collect();\n+        sorted.sort_unstable();\n+        sorted.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "ce4ab2c8a1de90ee5b7d53c1c88a83c47a7b4b29", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -30,7 +30,7 @@ use rustc::traits;\n use rustc::util::common::{ErrorReported, time};\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n-use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental;\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n@@ -175,7 +175,7 @@ pub fn compile_input(sess: &Session,\n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n-                           || hir_map::map_crate(&mut hir_forest, &defs));\n+                           || hir_map::map_crate(sess, cstore, &mut hir_forest, &defs));\n \n         {\n             let _ignore = hir_map.dep_graph.in_ignore();\n@@ -218,7 +218,7 @@ pub fn compile_input(sess: &Session,\n                                     &arenas,\n                                     &crate_name,\n                                     &outputs,\n-                                    |tcx, analysis, incremental_hashes_map, rx, result| {\n+                                    |tcx, analysis, rx, result| {\n             {\n                 // Eventually, we will want to track plugins.\n                 let _ignore = tcx.dep_graph.in_ignore();\n@@ -246,9 +246,7 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            let trans = phase_4_translate_to_llvm(tcx,\n-                                                  incremental_hashes_map,\n-                                                  rx);\n+            let trans = phase_4_translate_to_llvm(tcx, rx);\n \n             if log_enabled!(::log::LogLevel::Info) {\n                 println!(\"Post-trans\");\n@@ -921,7 +919,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                -> Result<R, CompileIncomplete>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n                             ty::CrateAnalysis,\n-                            IncrementalHashesMap,\n                             mpsc::Receiver<Box<Any + Send>>,\n                             CompileResult) -> R\n {\n@@ -1053,22 +1050,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              tx,\n                              output_filenames,\n                              |tcx| {\n-        let incremental_hashes_map =\n-            time(time_passes,\n-                 \"compute_incremental_hashes_map\",\n-                 || rustc_incremental::compute_incremental_hashes_map(tcx));\n-\n         time(time_passes,\n              \"load_dep_graph\",\n-             || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n+             || rustc_incremental::load_dep_graph(tcx));\n \n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));\n \n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx),\n-                    (tcx, analysis, incremental_hashes_map, rx));\n+        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, rx));\n \n         time(time_passes,\n              \"const checking\",\n@@ -1112,7 +1103,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n         // lint warnings and so on -- kindck used to do this abort, but\n         // kindck is gone now). -nmatsakis\n         if sess.err_count() > 0 {\n-            return Ok(f(tcx, analysis, incremental_hashes_map, rx, sess.compile_status()));\n+            return Ok(f(tcx, analysis, rx, sess.compile_status()));\n         }\n \n         time(time_passes, \"death checking\", || middle::dead::check_crate(tcx));\n@@ -1123,14 +1114,13 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n         time(time_passes, \"lint checking\", || lint::check_crate(tcx));\n \n-        return Ok(f(tcx, analysis, incremental_hashes_map, rx, tcx.sess.compile_status()));\n+        return Ok(f(tcx, analysis, rx, tcx.sess.compile_status()));\n     })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           incremental_hashes_map: IncrementalHashesMap,\n                                            rx: mpsc::Receiver<Box<Any + Send>>)\n                                            -> write::OngoingCrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n@@ -1141,7 +1131,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let translation =\n         time(time_passes, \"translation\", move || {\n-            trans::trans_crate(tcx, incremental_hashes_map, rx)\n+            trans::trans_crate(tcx, rx)\n         });\n \n     if tcx.sess.profile_queries() {"}, {"sha": "b633a170422eb95f31fc7d0bcf6fdc961e968060", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -237,7 +237,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  output_filenames,\n-                                                                 |tcx, _, _, _, _| {\n+                                                                 |tcx, _, _, _| {\n                     let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx,\n@@ -1036,7 +1036,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      arenas,\n                                                      crate_name,\n                                                      output_filenames,\n-                                                     |tcx, _, _, _, _| {\n+                                                     |tcx, _, _, _| {\n         match ppm {\n             PpmMir | PpmMirCFG => {\n                 if let Some(nodeid) = nodeid {"}, {"sha": "fad24e6a0f2b60a597e19d4efe99e8dba3abf390", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -133,7 +133,7 @@ fn test_env<F>(source_string: &str,\n \n     let arena = DroplessArena::new();\n     let arenas = ty::GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n+    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n     let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);"}, {"sha": "0329aa8d6741b71e1476089419735d8d86eb3c14", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/3eb19bf9b160825cd338b9419551670a30962c4e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eb19bf9b160825cd338b9419551670a30962c4e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=3eb19bf9b160825cd338b9419551670a30962c4e", "patch": "@@ -1,331 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Calculation of the (misnamed) \"strict version hash\" for crates and\n-//! items. This hash is used to tell when the HIR changed in such a\n-//! way that results from previous compilations may no longer be\n-//! applicable and hence must be recomputed. It should probably be\n-//! renamed to the ICH (incremental compilation hash).\n-//!\n-//! The hashes for all items are computed once at the beginning of\n-//! compilation and stored into a map. In addition, a hash is computed\n-//! of the **entire crate**.\n-//!\n-//! Storing the hashes in a map avoids the need to compute them twice\n-//! (once when loading prior incremental results and once when\n-//! saving), but it is also important for correctness: at least as of\n-//! the time of this writing, the typeck passes rewrites entries in\n-//! the dep-map in-place to accommodate UFCS resolutions. Since name\n-//! resolution is part of the hash, the result is that hashes computed\n-//! at the end of compilation would be different from those computed\n-//! at the beginning.\n-\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use rustc::dep_graph::{DepNode, DepKind};\n-use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n-use rustc::hir::map::DefPathHash;\n-use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::ich::{Fingerprint, StableHashingContext};\n-use rustc::ty::TyCtxt;\n-use rustc::util::common::record_time;\n-use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-\n-pub type IchHasher = StableHasher<Fingerprint>;\n-\n-pub struct IncrementalHashesMap {\n-    hashes: FxHashMap<DepNode, Fingerprint>,\n-\n-    // These are the metadata hashes for the current crate as they were stored\n-    // during the last compilation session. They are only loaded if\n-    // -Z query-dep-graph was specified and are needed for auto-tests using\n-    // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n-    // check whether some metadata hash has changed in between two revisions.\n-    pub prev_metadata_hashes: RefCell<FxHashMap<DefId, Fingerprint>>,\n-}\n-\n-impl IncrementalHashesMap {\n-    pub fn new() -> IncrementalHashesMap {\n-        IncrementalHashesMap {\n-            hashes: FxHashMap(),\n-            prev_metadata_hashes: RefCell::new(FxHashMap()),\n-        }\n-    }\n-\n-    pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n-        assert!(self.hashes.insert(k, v).is_none());\n-    }\n-\n-    pub fn iter<'a>(&'a self)\n-                    -> ::std::collections::hash_map::Iter<'a, DepNode, Fingerprint> {\n-        self.hashes.iter()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        self.hashes.len()\n-    }\n-}\n-\n-impl<'a> ::std::ops::Index<&'a DepNode> for IncrementalHashesMap {\n-    type Output = Fingerprint;\n-\n-    fn index(&self, index: &'a DepNode) -> &Fingerprint {\n-        match self.hashes.get(index) {\n-            Some(fingerprint) => fingerprint,\n-            None => {\n-                bug!(\"Could not find ICH for {:?}\", index);\n-            }\n-        }\n-    }\n-}\n-\n-struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    hcx: StableHashingContext<'tcx>,\n-    hashes: IncrementalHashesMap,\n-}\n-\n-impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n-    fn compute_and_store_ich_for_item_like<T>(&mut self,\n-                                              def_index: DefIndex,\n-                                              hash_bodies: bool,\n-                                              item_like: T)\n-        where T: HashStable<StableHashingContext<'tcx>>\n-    {\n-        if !hash_bodies && !self.tcx.sess.opts.build_dep_graph() {\n-            // If we just need the hashes in order to compute the SVH, we don't\n-            // need have two hashes per item. Just the one containing also the\n-            // item's body is sufficient.\n-            return\n-        }\n-\n-        let def_path_hash = self.hcx.local_def_path_hash(def_index);\n-\n-        let mut hasher = IchHasher::new();\n-        self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n-            item_like.hash_stable(hcx, &mut hasher);\n-        });\n-\n-        let bytes_hashed = hasher.bytes_hashed();\n-        let item_hash = hasher.finish();\n-        let dep_node = if hash_bodies {\n-            def_path_hash.to_dep_node(DepKind::HirBody)\n-        } else {\n-            def_path_hash.to_dep_node(DepKind::Hir)\n-        };\n-        debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n-        self.hashes.insert(dep_node, item_hash);\n-\n-        let bytes_hashed =\n-            self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() + bytes_hashed;\n-        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n-\n-        if hash_bodies {\n-            let in_scope_traits_map = self.tcx.in_scope_traits_map(def_index);\n-            let mut hasher = IchHasher::new();\n-            in_scope_traits_map.hash_stable(&mut self.hcx, &mut hasher);\n-            let dep_node = def_path_hash.to_dep_node(DepKind::InScopeTraits);\n-            self.hashes.insert(dep_node, hasher.finish());\n-        }\n-    }\n-\n-    fn compute_crate_hash(&mut self) {\n-        let krate = self.tcx.hir.krate();\n-\n-        let mut crate_state = IchHasher::new();\n-\n-        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n-        \"crate_disambiguator\".hash(&mut crate_state);\n-        crate_disambiguator.as_str().len().hash(&mut crate_state);\n-        crate_disambiguator.as_str().hash(&mut crate_state);\n-\n-        // add each item (in some deterministic order) to the overall\n-        // crate hash.\n-        {\n-            let mut item_hashes: Vec<_> =\n-                self.hashes.iter()\n-                           .filter_map(|(&item_dep_node, &item_hash)| {\n-                                // This `match` determines what kinds of nodes\n-                                // go into the SVH:\n-                                match item_dep_node.kind {\n-                                    DepKind::InScopeTraits |\n-                                    DepKind::Hir |\n-                                    DepKind::HirBody => {\n-                                        // We want to incoporate these into the\n-                                        // SVH.\n-                                    }\n-                                    DepKind::AllLocalTraitImpls => {\n-                                        // These are already covered by hashing\n-                                        // the HIR.\n-                                        return None\n-                                    }\n-                                    ref other => {\n-                                        bug!(\"Found unexpected DepKind during \\\n-                                              SVH computation: {:?}\",\n-                                             other)\n-                                    }\n-                                }\n-\n-                                Some((item_dep_node, item_hash))\n-                           })\n-                           .collect();\n-            item_hashes.sort_unstable(); // avoid artificial dependencies on item ordering\n-            item_hashes.hash(&mut crate_state);\n-        }\n-\n-        krate.attrs.hash_stable(&mut self.hcx, &mut crate_state);\n-\n-        let crate_hash = crate_state.finish();\n-        self.hashes.insert(DepNode::new_no_params(DepKind::Krate), crate_hash);\n-        debug!(\"calculate_crate_hash: crate_hash={:?}\", crate_hash);\n-    }\n-\n-    fn hash_crate_root_module(&mut self, krate: &'tcx hir::Crate) {\n-        let hir::Crate {\n-            ref module,\n-            // Crate attributes are not copied over to the root `Mod`, so hash\n-            // them explicitly here.\n-            ref attrs,\n-            span,\n-\n-            // These fields are handled separately:\n-            exported_macros: _,\n-            items: _,\n-            trait_items: _,\n-            impl_items: _,\n-            bodies: _,\n-            trait_impls: _,\n-            trait_default_impl: _,\n-            body_ids: _,\n-        } = *krate;\n-\n-        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n-                                                 false,\n-                                                 (module, (span, attrs)));\n-        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n-                                                 true,\n-                                                 (module, (span, attrs)));\n-    }\n-\n-    fn compute_and_store_ich_for_trait_impls(&mut self, krate: &'tcx hir::Crate)\n-    {\n-        let tcx = self.tcx;\n-\n-        let mut impls: Vec<(DefPathHash, Fingerprint)> = krate\n-            .trait_impls\n-            .iter()\n-            .map(|(&trait_id, impls)| {\n-                let trait_id = tcx.def_path_hash(trait_id);\n-                let mut impls: AccumulateVec<[_; 32]> = impls\n-                    .iter()\n-                    .map(|&node_id| {\n-                        let def_id = tcx.hir.local_def_id(node_id);\n-                        tcx.def_path_hash(def_id)\n-                    })\n-                    .collect();\n-\n-                impls.sort_unstable();\n-                let mut hasher = StableHasher::new();\n-                impls.hash_stable(&mut self.hcx, &mut hasher);\n-                (trait_id, hasher.finish())\n-            })\n-            .collect();\n-\n-        impls.sort_unstable();\n-\n-        let mut default_impls: AccumulateVec<[_; 32]> = krate\n-            .trait_default_impl\n-            .iter()\n-            .map(|(&trait_def_id, &impl_node_id)| {\n-                let impl_def_id = tcx.hir.local_def_id(impl_node_id);\n-                (tcx.def_path_hash(trait_def_id), tcx.def_path_hash(impl_def_id))\n-            })\n-            .collect();\n-\n-        default_impls.sort_unstable();\n-\n-        let mut hasher = StableHasher::new();\n-        impls.hash_stable(&mut self.hcx, &mut hasher);\n-\n-        self.hashes.insert(DepNode::new_no_params(DepKind::AllLocalTraitImpls),\n-                           hasher.finish());\n-    }\n-}\n-\n-impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-\n-    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-\n-    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        let def_index = self.tcx.hir.local_def_id(item.id).index;\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 false,\n-                                                 item);\n-        self.compute_and_store_ich_for_item_like(def_index,\n-                                                 true,\n-                                                 item);\n-    }\n-}\n-\n-\n-\n-pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                                    -> IncrementalHashesMap {\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    let krate = tcx.hir.krate();\n-\n-    let mut visitor = ComputeItemHashesVisitor {\n-        tcx,\n-        hcx: tcx.create_stable_hashing_context(),\n-        hashes: IncrementalHashesMap::new(),\n-    };\n-\n-    record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.hash_crate_root_module(krate);\n-        krate.visit_all_item_likes(&mut visitor);\n-\n-        for macro_def in krate.exported_macros.iter() {\n-            let def_index = tcx.hir.local_def_id(macro_def.id).index;\n-            visitor.compute_and_store_ich_for_item_like(def_index,\n-                                                        false,\n-                                                        macro_def);\n-            visitor.compute_and_store_ich_for_item_like(def_index,\n-                                                        true,\n-                                                        macro_def);\n-        }\n-\n-        visitor.compute_and_store_ich_for_trait_impls(krate);\n-    });\n-\n-    tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);\n-\n-    record_time(&tcx.sess.perf_stats.svh_time, || visitor.compute_crate_hash());\n-    visitor.hashes\n-}"}, {"sha": "6817856fdb1db44dbea35e61fa72e8606213c2f8", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -28,13 +28,9 @@ extern crate syntax;\n extern crate syntax_pos;\n \n mod assert_dep_graph;\n-mod calculate_svh;\n mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n-pub use calculate_svh::compute_incremental_hashes_map;\n-pub use calculate_svh::IncrementalHashesMap;\n-pub use calculate_svh::IchHasher;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n pub use persist::save_trans_partition;"}, {"sha": "f7ea0a07f3df25321ad0b8159642f05ee197d19f", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -18,7 +18,6 @@ use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n \n-use IncrementalHashesMap;\n use super::data::*;\n use super::fs::*;\n use super::file_format;\n@@ -28,49 +27,27 @@ use std::fmt::Debug;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    incremental_hashes_map: &'a IncrementalHashesMap,\n     metadata_hashes: FxHashMap<DefId, Fingerprint>,\n     crate_hashes: FxHashMap<CrateNum, Svh>,\n }\n \n impl<'a, 'tcx> HashContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               incremental_hashes_map: &'a IncrementalHashesMap)\n-               -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         HashContext {\n             tcx,\n-            incremental_hashes_map,\n             metadata_hashes: FxHashMap(),\n             crate_hashes: FxHashMap(),\n         }\n     }\n \n-    pub fn is_hashable(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n-        match dep_node.kind {\n-            DepKind::Krate |\n-            DepKind::Hir |\n-            DepKind::InScopeTraits |\n-            DepKind::HirBody =>\n-                true,\n-            DepKind::MetaData => {\n-                let def_id = dep_node.extract_def_id(tcx).unwrap();\n-                !def_id.is_local()\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     pub fn hash(&mut self, dep_node: &DepNode) -> Option<Fingerprint> {\n         match dep_node.kind {\n-            DepKind::Krate => {\n-                Some(self.incremental_hashes_map[dep_node])\n-            }\n-\n             // HIR nodes (which always come from our crate) are an input:\n+            DepKind::Krate |\n             DepKind::InScopeTraits |\n             DepKind::Hir |\n             DepKind::HirBody => {\n-                Some(self.incremental_hashes_map[dep_node])\n+                Some(self.tcx.dep_graph.fingerprint_of(dep_node).unwrap())\n             }\n \n             // MetaData from other crates is an *input* to us.\n@@ -79,13 +56,11 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             // save it for others to use.\n             DepKind::MetaData => {\n                 let def_id = dep_node.extract_def_id(self.tcx).unwrap();\n-                if !def_id.is_local() {\n-                    Some(self.metadata_hash(def_id,\n+                assert!(!def_id.is_local());\n+\n+                Some(self.metadata_hash(def_id,\n                                         def_id.krate,\n                                         |this| &mut this.metadata_hashes))\n-                } else {\n-                    None\n-                }\n             }\n \n             _ => {"}, {"sha": "0d6257e4245777c16a7ac8964c76f9c78c0a858d", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -11,18 +11,17 @@\n //! Code to save/load the dep-graph from files.\n \n use rustc::dep_graph::{DepNode, WorkProductId, DepKind};\n-use rustc::hir::def_id::DefId;\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::path::{Path};\n \n-use IncrementalHashesMap;\n use super::data::*;\n use super::dirty_clean;\n use super::hash::*;\n@@ -40,16 +39,15 @@ pub type DirtyNodes = FxHashMap<DepNodeIndex, DepNodeIndex>;\n /// early in compilation, before we've really done any work, but\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n-pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: &IncrementalHashesMap) {\n+pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    tcx.precompute_in_scope_traits_hashes();\n     if tcx.sess.incr_session_load_dep_graph() {\n         let _ignore = tcx.dep_graph.in_ignore();\n-        load_dep_graph_if_exists(tcx, incremental_hashes_map);\n+        load_dep_graph_if_exists(tcx);\n     }\n }\n \n-fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      incremental_hashes_map: &IncrementalHashesMap) {\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let dep_graph_path = dep_graph_path(tcx.sess);\n     let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n         Some(p) => p,\n@@ -62,7 +60,7 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         None => return // no file\n     };\n \n-    match decode_dep_graph(tcx, incremental_hashes_map, &dep_graph_data, &work_products_data) {\n+    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n         Ok(dirty_nodes) => dirty_nodes,\n         Err(err) => {\n             tcx.sess.warn(\n@@ -117,7 +115,6 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n /// Decode the dep graph and load the edges/nodes that are still clean\n /// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  incremental_hashes_map: &IncrementalHashesMap,\n                                   dep_graph_data: &[u8],\n                                   work_products_data: &[u8])\n                                   -> Result<(), String>\n@@ -150,7 +147,6 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Compute the set of nodes from the old graph where some input\n     // has changed or been removed.\n     let dirty_raw_nodes = initial_dirty_nodes(tcx,\n-                                              incremental_hashes_map,\n                                               &serialized_dep_graph.nodes,\n                                               &serialized_dep_graph.hashes);\n     let dirty_raw_nodes = transitive_dirty_nodes(&serialized_dep_graph,\n@@ -193,20 +189,16 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     dirty_clean::check_dirty_clean_annotations(tcx,\n                                                &serialized_dep_graph.nodes,\n                                                &dirty_raw_nodes);\n-\n-    load_prev_metadata_hashes(tcx,\n-                              &mut *incremental_hashes_map.prev_metadata_hashes.borrow_mut());\n     Ok(())\n }\n \n /// Computes which of the original set of def-ids are dirty. Stored in\n /// a bit vector where the index is the DefPathIndex.\n fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 incremental_hashes_map: &IncrementalHashesMap,\n                                  nodes: &IndexVec<DepNodeIndex, DepNode>,\n                                  serialized_hashes: &[(DepNodeIndex, Fingerprint)])\n                                  -> DirtyNodes {\n-    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n+    let mut hcx = HashContext::new(tcx);\n     let mut dirty_nodes = FxHashMap();\n \n     for &(dep_node_index, prev_hash) in serialized_hashes {\n@@ -310,11 +302,12 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n     work_product::delete_workproduct_files(tcx.sess, &swp.work_product);\n }\n \n-fn load_prev_metadata_hashes(tcx: TyCtxt,\n-                             output: &mut FxHashMap<DefId, Fingerprint>) {\n+pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n+    let mut output = DefIdMap();\n+\n     if !tcx.sess.opts.debugging_opts.query_dep_graph {\n         // Previous metadata hashes are only needed for testing.\n-        return\n+        return output\n     }\n \n     debug!(\"load_prev_metadata_hashes() - Loading previous metadata hashes\");\n@@ -324,7 +317,7 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n     if !file_path.exists() {\n         debug!(\"load_prev_metadata_hashes() - Couldn't find file containing \\\n                 hashes at `{}`\", file_path.display());\n-        return\n+        return output\n     }\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n@@ -334,12 +327,12 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n         Ok(None) => {\n             debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n                     compiler version: {}\", file_path.display());\n-            return\n+            return output\n         }\n         Err(err) => {\n             debug!(\"load_prev_metadata_hashes() - Error reading file `{}`: {}\",\n                    file_path.display(), err);\n-            return\n+            return output\n         }\n     };\n \n@@ -363,6 +356,8 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n            serialized_hashes.index_map.len());\n+\n+    output\n }\n \n fn process_edge<'a, 'tcx, 'edges>("}, {"sha": "46bb37b017f5786827b097d58f3108a413b82c9d", "filename": "src/librustc_incremental/persist/preds/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds%2Fmod.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -66,7 +66,7 @@ impl<'q> Predecessors<'q> {\n         // Reduce the graph to the most important nodes.\n         let compress::Reduction { graph, input_nodes } =\n             compress::reduce_graph(&query.graph,\n-                                   |n| HashContext::is_hashable(tcx, n),\n+                                   |n| n.kind.is_input(),\n                                    |n| is_output(n));\n \n         let mut hashes = FxHashMap();"}, {"sha": "e2d03fcb0e1c819ed53ca644c8bf8a34ff5a010b", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -15,6 +15,7 @@ use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -24,7 +25,6 @@ use std::io::{self, Cursor, Write};\n use std::fs::{self, File};\n use std::path::PathBuf;\n \n-use IncrementalHashesMap;\n use super::data::*;\n use super::hash::*;\n use super::preds::*;\n@@ -33,8 +33,9 @@ use super::dirty_clean;\n use super::file_format;\n use super::work_product;\n \n+use super::load::load_prev_metadata_hashes;\n+\n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: IncrementalHashesMap,\n                                 metadata_hashes: &EncodedMetadataHashes,\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n@@ -51,7 +52,15 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n     }\n \n-    let mut hcx = HashContext::new(tcx, &incremental_hashes_map);\n+    // We load the previous metadata hashes now before overwriting the file\n+    // (if we need them for testing).\n+    let prev_metadata_hashes = if tcx.sess.opts.debugging_opts.query_dep_graph {\n+        load_prev_metadata_hashes(tcx)\n+    } else {\n+        DefIdMap()\n+    };\n+\n+    let mut hcx = HashContext::new(tcx);\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n \n@@ -73,9 +82,8 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             dep_graph_path(sess),\n             |e| encode_dep_graph(tcx, &preds, e));\n \n-    let prev_metadata_hashes = incremental_hashes_map.prev_metadata_hashes.borrow();\n     dirty_clean::check_dirty_clean_metadata(tcx,\n-                                            &*prev_metadata_hashes,\n+                                            &prev_metadata_hashes,\n                                             &current_metadata_hashes);\n }\n "}, {"sha": "9d13d4ce15b79e9bb544dc51a21d94a2225c9749", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -20,17 +20,16 @@ use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, Pri\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n+use rustc::ich::Fingerprint;\n use rustc::middle::cstore::{LinkMeta, NativeLibrary, LibSource, NativeLibraryKind};\n use rustc::middle::dependency_format::Linkage;\n use {CrateTranslation, CrateInfo};\n use rustc::util::common::time;\n use rustc::util::fs::fix_windows_verbatim_for_gcc;\n-use rustc::dep_graph::{DepKind, DepNode};\n use rustc::hir::def_id::CrateNum;\n use rustc::hir::svh::Svh;\n use rustc_back::tempdir::TempDir;\n use rustc_back::{PanicStrategy, RelroLevel};\n-use rustc_incremental::IncrementalHashesMap;\n use context::get_reloc_model;\n use llvm;\n \n@@ -92,10 +91,9 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: usize =\n pub use self::rustc_trans_utils::link::{find_crate_name, filename_for_input,\n                                         default_output_for_target, invalid_output_for_target};\n \n-pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap) -> LinkMeta {\n-    let krate_dep_node = &DepNode::new_no_params(DepKind::Krate);\n+pub fn build_link_meta(crate_hash: Fingerprint) -> LinkMeta {\n     let r = LinkMeta {\n-        crate_hash: Svh::new(incremental_hashes_map[krate_dep_node].to_smaller_hash()),\n+        crate_hash: Svh::new(crate_hash.to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n     return r;"}, {"sha": "bfa18d84d2705add24ac9d30830a1a42f7813544", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -41,12 +41,13 @@ use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n+use rustc::dep_graph::{DepNode, DepKind};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n-use rustc_incremental::{self, IncrementalHashesMap};\n+use rustc_incremental;\n use abi;\n use allocator;\n use mir::lvalue::LvalueRef;\n@@ -935,12 +936,15 @@ pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n }\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             incremental_hashes_map: IncrementalHashesMap,\n                              rx: mpsc::Receiver<Box<Any + Send>>)\n                              -> OngoingCrateTranslation {\n     check_for_rustc_errors_attr(tcx);\n \n-    let link_meta = link::build_link_meta(&incremental_hashes_map);\n+\n+    let crate_hash = tcx.dep_graph\n+                        .fingerprint_of(&DepNode::new_no_params(DepKind::Krate))\n+                        .unwrap();\n+    let link_meta = link::build_link_meta(crate_hash);\n     let exported_symbol_node_ids = find_exported_symbols(tcx);\n \n     let shared_ccx = SharedCrateContext::new(tcx);\n@@ -980,7 +984,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ongoing_translation.translation_finished(tcx);\n \n         assert_and_save_dep_graph(tcx,\n-                                  incremental_hashes_map,\n                                   metadata_incr_hashes,\n                                   link_meta);\n \n@@ -1113,7 +1116,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ongoing_translation.check_for_errors(tcx.sess);\n \n     assert_and_save_dep_graph(tcx,\n-                              incremental_hashes_map,\n                               metadata_incr_hashes,\n                               link_meta);\n     ongoing_translation\n@@ -1124,7 +1126,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n thread_local!(static DISPOSITIONS: RefCell<Vec<(String, Disposition)>> = Default::default());\n \n fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       incremental_hashes_map: IncrementalHashesMap,\n                                        metadata_incr_hashes: EncodedMetadataHashes,\n                                        link_meta: LinkMeta) {\n     time(tcx.sess.time_passes(),\n@@ -1134,7 +1135,6 @@ fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     time(tcx.sess.time_passes(),\n          \"serialize dep graph\",\n          || rustc_incremental::save_dep_graph(tcx,\n-                                              incremental_hashes_map,\n                                               &metadata_incr_hashes,\n                                               link_meta.crate_hash));\n }"}, {"sha": "7c29186f4657f721a5424d5c1c9c736569dc76bf", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -108,11 +108,12 @@ use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::middle::trans::{Linkage, Visibility};\n+use rustc::ich::Fingerprint;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::{self, TyCtxt, InstanceDef};\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_incremental::IchHasher;\n+use rustc_data_structures::stable_hasher::StableHasher;\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n use syntax::ast::NodeId;\n@@ -155,7 +156,7 @@ pub trait CodegenUnitExt<'tcx> {\n     }\n \n     fn compute_symbol_name_hash<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> u64 {\n-        let mut state = IchHasher::new();\n+        let mut state: StableHasher<Fingerprint> = StableHasher::new();\n         let all_items = self.items_in_deterministic_order(tcx);\n         for (item, (linkage, visibility)) in all_items {\n             let symbol_name = item.symbol_name(tcx);"}, {"sha": "2ecb7b546fce2d5ba39a173023aeb8014154c01b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -175,7 +175,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let arena = DroplessArena::new();\n     let arenas = GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n+    let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n     let output_filenames = driver::build_output_filenames(&input,\n                                                           &None,\n                                                           &None,\n@@ -191,7 +191,7 @@ pub fn run_core(search_paths: SearchPaths,\n                                                      &arenas,\n                                                      &name,\n                                                      &output_filenames,\n-                                                     |tcx, analysis, _, _, result| {\n+                                                     |tcx, analysis, _, result| {\n         if let Err(_) = result {\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }"}, {"sha": "f9cb4b84545dd6b05cba6a08c446fa9bd86509e1", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14039a42ac6365afc842214989613f9a688c9a66/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=14039a42ac6365afc842214989613f9a688c9a66", "patch": "@@ -124,7 +124,7 @@ pub fn run(input: &str,\n                                        render_type);\n \n     {\n-        let map = hir::map::map_crate(&mut hir_forest, &defs);\n+        let map = hir::map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n             sess: &sess,"}]}