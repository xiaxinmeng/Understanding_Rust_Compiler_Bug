{"sha": "667f83d46baa1c42a170cfae5afbff52a85cd95d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2N2Y4M2Q0NmJhYTFjNDJhMTcwY2ZhZTVhZmJmZjUyYTg1Y2Q5NWQ=", "commit": {"author": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-11-09T10:05:28Z"}, "committer": {"name": "Lukas Kalbertodt", "email": "lukas.kalbertodt@gmail.com", "date": "2017-11-18T16:30:12Z"}, "message": "Remove inherent `ascii_ctype` methods from `str` and `[u8]`\n\nThis has been discussed in #39658. It's a bit ambiguous how those\nmethods work for a sequence of ascii values. We prefer users writing\n`s.iter().all(|b| b.is_ascii_...())` explicitly.\n\nThe AsciiExt methods still exist and are implemented for `str`\nand `[u8]`. We will deprecated or remove those later.", "tree": {"sha": "9d8a27f1b32a633155dedcd3f6388f135d89cfe2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d8a27f1b32a633155dedcd3f6388f135d89cfe2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/667f83d46baa1c42a170cfae5afbff52a85cd95d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/667f83d46baa1c42a170cfae5afbff52a85cd95d", "html_url": "https://github.com/rust-lang/rust/commit/667f83d46baa1c42a170cfae5afbff52a85cd95d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/667f83d46baa1c42a170cfae5afbff52a85cd95d/comments", "author": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LukasKalbertodt", "id": 7419664, "node_id": "MDQ6VXNlcjc0MTk2NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7419664?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LukasKalbertodt", "html_url": "https://github.com/LukasKalbertodt", "followers_url": "https://api.github.com/users/LukasKalbertodt/followers", "following_url": "https://api.github.com/users/LukasKalbertodt/following{/other_user}", "gists_url": "https://api.github.com/users/LukasKalbertodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/LukasKalbertodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LukasKalbertodt/subscriptions", "organizations_url": "https://api.github.com/users/LukasKalbertodt/orgs", "repos_url": "https://api.github.com/users/LukasKalbertodt/repos", "events_url": "https://api.github.com/users/LukasKalbertodt/events{/privacy}", "received_events_url": "https://api.github.com/users/LukasKalbertodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18250b0349848fbfca53153cf121724c773dd508", "url": "https://api.github.com/repos/rust-lang/rust/commits/18250b0349848fbfca53153cf121724c773dd508", "html_url": "https://github.com/rust-lang/rust/commit/18250b0349848fbfca53153cf121724c773dd508"}], "stats": {"total": 470, "additions": 166, "deletions": 304}, "files": [{"sha": "d2573e8d4422c39c985ec7ae16be2f9f2fb0e9e9", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/667f83d46baa1c42a170cfae5afbff52a85cd95d/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f83d46baa1c42a170cfae5afbff52a85cd95d/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=667f83d46baa1c42a170cfae5afbff52a85cd95d", "patch": "@@ -1626,120 +1626,6 @@ impl [u8] {\n             byte.make_ascii_lowercase();\n         }\n     }\n-\n-    /// Checks if all bytes of this slice are ASCII alphabetic characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII uppercase characters:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII lowercase characters:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII alphanumeric characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_digit())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII hexadecimal digits:\n-    ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII punctuation characters:\n-    ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII graphic characters:\n-    /// U+0021 '@' ... U+007E '~'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII whitespace characters:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw]. There are several other definitions in\n-    /// wide use. For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII control characters:\n-    ///\n-    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n-    /// - U+007F DELETE.\n-    ///\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_control())\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9173bda4248d3df411e51fa1ed4594580d8163dc", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/667f83d46baa1c42a170cfae5afbff52a85cd95d/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f83d46baa1c42a170cfae5afbff52a85cd95d/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=667f83d46baa1c42a170cfae5afbff52a85cd95d", "patch": "@@ -2199,153 +2199,6 @@ impl str {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n-\n-    /// Checks if all characters of this string are ASCII alphabetic\n-    /// characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII uppercase characters:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    ///\n-    /// // Only ascii uppercase characters\n-    /// assert!(\"HELLO\".is_ascii_uppercase());\n-    ///\n-    /// // While all characters are ascii, 'y' and 'e' are not uppercase\n-    /// assert!(!\"Bye\".is_ascii_uppercase());\n-    ///\n-    /// // While all characters are uppercase, '\u00dc' is not ascii\n-    /// assert!(!\"TSCH\u00dcSS\".is_ascii_uppercase());\n-    /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII lowercase characters:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    ///\n-    /// // Only ascii uppercase characters\n-    /// assert!(\"hello\".is_ascii_lowercase());\n-    ///\n-    /// // While all characters are ascii, 'B' is not lowercase\n-    /// assert!(!\"Bye\".is_ascii_lowercase());\n-    ///\n-    /// // While all characters are lowercase, '\u00dc' is not ascii\n-    /// assert!(!\"tsch\u00fcss\".is_ascii_lowercase());\n-    /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII alphanumeric\n-    /// characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_digit())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII hexadecimal digits:\n-    ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII punctuation\n-    /// characters:\n-    ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII graphic characters:\n-    /// U+0021 '@' ... U+007E '~'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII whitespace characters:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw]. There are several other definitions in\n-    /// wide use. For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII control characters:\n-    ///\n-    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n-    /// - U+007F DELETE.\n-    ///\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_control())\n-    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "312da2035744939518fadc2336579708d73e557b", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 166, "deletions": 43, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/667f83d46baa1c42a170cfae5afbff52a85cd95d/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/667f83d46baa1c42a170cfae5afbff52a85cd95d/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=667f83d46baa1c42a170cfae5afbff52a85cd95d", "patch": "@@ -490,77 +490,199 @@ impl AsciiExt for [u8] {\n     }\n }\n \n-macro_rules! impl_by_delegating {\n-    ($ty:ty, $owned:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl AsciiExt for $ty {\n-            type Owned = $owned;\n+macro_rules! delegating_ascii_methods {\n+    () => {\n+        #[inline]\n+        fn is_ascii(&self) -> bool { self.is_ascii() }\n \n-            #[inline]\n-            fn is_ascii(&self) -> bool { self.is_ascii() }\n+        #[inline]\n+        fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n \n-            #[inline]\n-            fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n+        #[inline]\n+        fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n \n-            #[inline]\n-            fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n+        #[inline]\n+        fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n \n-            #[inline]\n-            fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n+        #[inline]\n+        fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n \n-            #[inline]\n-            fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n-\n-            #[inline]\n-            fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n+        #[inline]\n+        fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n+    }\n+}\n \n-            #[inline]\n-            fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n+macro_rules! delegating_ascii_ctype_methods {\n+    () => {\n+        #[inline]\n+        fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n \n-            #[inline]\n-            fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n+        #[inline]\n+        fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n \n-            #[inline]\n-            fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n+        #[inline]\n+        fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n \n-            #[inline]\n-            fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n+        #[inline]\n+        fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n \n-            #[inline]\n-            fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n+        #[inline]\n+        fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n \n-            #[inline]\n-            fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n+        #[inline]\n+        fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n \n-            #[inline]\n-            fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n+        #[inline]\n+        fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n \n-            #[inline]\n-            fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n+        #[inline]\n+        fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n \n-            #[inline]\n-            fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n+        #[inline]\n+        fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n \n-            #[inline]\n-            fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n-        }\n+        #[inline]\n+        fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n     }\n }\n \n-impl_by_delegating!(u8, u8);\n-impl_by_delegating!(char, char);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for u8 {\n+    type Owned = u8;\n+\n+    delegating_ascii_methods!();\n+    delegating_ascii_ctype_methods!();\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for char {\n+    type Owned = char;\n+\n+    delegating_ascii_methods!();\n+    delegating_ascii_ctype_methods!();\n+}\n \n // FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `[u8]` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `[u8]`.\n #[cfg(not(stage0))]\n-impl_by_delegating!([u8], Vec<u8>);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for [u8] {\n+    type Owned = Vec<u8>;\n+\n+    delegating_ascii_methods!();\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n+}\n \n // FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `str` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `str`.\n #[cfg(not(stage0))]\n-impl_by_delegating!(str, String);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for str {\n+    type Owned = String;\n+\n+    delegating_ascii_methods!();\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n+}\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -684,6 +806,7 @@ mod tests {\n     //! Note that most of these tests are not testing `AsciiExt` methods, but\n     //! test inherent ascii methods of char, u8, str and [u8]. `AsciiExt` is\n     //! just using those methods, though.\n+    use super::AsciiExt;\n     use char::from_u32;\n \n     #[test]"}]}