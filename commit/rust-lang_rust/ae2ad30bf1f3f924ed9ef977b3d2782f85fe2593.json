{"sha": "ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMmFkMzBiZjFmM2Y5MjRlZDllZjk3N2IzZDI3ODJmODVmZTI1OTM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-01T16:10:26Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2018-09-01T16:10:26Z"}, "message": "move the is_field_list_non_exhaustive flag to VariantDef\n\nThis completely splits the IS_NON_EXHAUSTIVE flag. No functional\nchanges intended.", "tree": {"sha": "fa78674b6ec56ec6cea47eff95f856b9117bbbea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa78674b6ec56ec6cea47eff95f856b9117bbbea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "html_url": "https://github.com/rust-lang/rust/commit/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "993e7e2622da632705661007d5a3bce812cc6d3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/993e7e2622da632705661007d5a3bce812cc6d3d", "html_url": "https://github.com/rust-lang/rust/commit/993e7e2622da632705661007d5a3bce812cc6d3d"}], "stats": {"total": 181, "additions": 108, "deletions": 73}, "files": [{"sha": "3a873ec739c505de4bbf6a985f6bc0c4747e0e7e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -344,13 +344,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     }\n }\n \n-impl_stable_hash_for!(struct ty::VariantDef {\n-    did,\n-    name,\n-    discr,\n-    fields,\n-    ctor_kind\n-});\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::VariantFlags {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          _: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        std_hash::Hash::hash(self, hasher);\n+    }\n+}\n \n impl_stable_hash_for!(enum ty::VariantDiscr {\n     Explicit(def_id),"}, {"sha": "fb72585d6c667c7d2e558c7b851facee4601faba", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 66, "deletions": 44, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -1691,12 +1691,17 @@ bitflags! {\n         const IS_FUNDAMENTAL      = 1 << 2;\n         const IS_UNION            = 1 << 3;\n         const IS_BOX              = 1 << 4;\n-        /// Indicates whether this abstract data type will be expanded on in future (new\n-        /// fields/variants) and as such, whether downstream crates must match exhaustively on the\n-        /// fields/variants of this data type.\n-        ///\n-        /// See RFC 2008 (<https://github.com/rust-lang/rfcs/pull/2008>).\n-        const IS_NON_EXHAUSTIVE   = 1 << 5;\n+        /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n+        /// (i.e., this flag is never set unless this ADT is an enum).\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE   = 1 << 5;\n+    }\n+}\n+\n+bitflags! {\n+    pub struct VariantFlags: u32 {\n+        const NO_VARIANT_FLAGS        = 0;\n+        /// Indicates whether the field list of this variant is `#[non_exhaustive]`.\n+        const IS_FIELD_LIST_NON_EXHAUSTIVE = 1 << 0;\n     }\n }\n \n@@ -1709,8 +1714,56 @@ pub struct VariantDef {\n     pub discr: VariantDiscr,\n     pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n+    flags: VariantFlags,\n }\n \n+impl<'a, 'gcx, 'tcx> VariantDef {\n+    /// Create a new `VariantDef`.\n+    ///\n+    /// - `did` is the DefId used for the variant - for tuple-structs, it is the constructor DefId,\n+    /// and for everything else, it is the variant DefId.\n+    /// - `attribute_def_id` is the DefId that has the variant's attributes.\n+    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+               did: DefId,\n+               name: Name,\n+               discr: VariantDiscr,\n+               fields: Vec<FieldDef>,\n+               adt_kind: AdtKind,\n+               ctor_kind: CtorKind)\n+               -> Self\n+    {\n+        debug!(\"VariantDef::new({:?}, {:?}, {:?}, {:?}, {:?}, {:?})\", did, name, discr, fields,\n+               adt_kind, ctor_kind);\n+        let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n+        if adt_kind == AdtKind::Struct && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive field list for {:?}\", did);\n+            flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n+        }\n+        VariantDef {\n+            did,\n+            name,\n+            discr,\n+            fields,\n+            ctor_kind,\n+            flags\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn is_field_list_non_exhaustive(&self) -> bool {\n+        self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n+    }\n+}\n+\n+impl_stable_hash_for!(struct VariantDef {\n+    did,\n+    name,\n+    discr,\n+    fields,\n+    ctor_kind,\n+    flags\n+});\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum VariantDiscr {\n     /// Explicit value for this variant, i.e. `X = 123`.\n@@ -1849,7 +1902,7 @@ impl_stable_hash_for!(struct ReprFlags {\n \n \n /// Represents the repr options provided by the user,\n-#[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n     pub align: u32,\n@@ -1938,6 +1991,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n            kind: AdtKind,\n            variants: Vec<VariantDef>,\n            repr: ReprOptions) -> Self {\n+        debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1949,8 +2003,9 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         if Some(did) == tcx.lang_items().owned_box() {\n             flags = flags | AdtFlags::IS_BOX;\n         }\n-        if tcx.has_attr(did, \"non_exhaustive\") {\n-            flags = flags | AdtFlags::IS_NON_EXHAUSTIVE;\n+        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n         }\n         match kind {\n             AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n@@ -1981,28 +2036,8 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     }\n \n     #[inline]\n-    fn is_non_exhaustive(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_NON_EXHAUSTIVE)\n-    }\n-\n-    #[inline]\n-    pub fn is_enum_non_exhaustive(&self) -> bool {\n-        match self.adt_kind() {\n-            AdtKind::Enum => self.is_non_exhaustive(),\n-            AdtKind::Struct | AdtKind::Union => {\n-                bug!(\"is_non_exhaustive_enum called on non-enum `{:?}`\", self);\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn is_univariant_non_exhaustive(&self) -> bool {\n-        match self.adt_kind() {\n-            AdtKind::Struct | AdtKind::Union => self.is_non_exhaustive(),\n-            AdtKind::Enum => {\n-                bug!(\"is_non_exhaustive_enum called on non-enum `{:?}`\", self);\n-            }\n-        }\n+    pub fn is_variant_list_non_exhaustive(&self) -> bool {\n+        self.flags.intersects(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n     }\n \n     /// Returns the kind of the ADT - Struct or Enum.\n@@ -2017,19 +2052,6 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    /// Return whether `variant` is non-exhaustive as a *struct* (i.e., whether\n-    /// it can have additional fields).\n-    pub fn is_variant_non_exhaustive(&self, _variant: &ty::VariantDef) -> bool {\n-        match self.adt_kind() {\n-            // A struct is non-exhaustive if it has a `#[non_exhaustive]` attribute.\n-            AdtKind::Struct => self.is_non_exhaustive(),\n-            // At this moment, all enum variants are exhaustive.\n-            AdtKind::Enum => false,\n-            // All unions are \"exhaustive\", as far as that makes sense.\n-            AdtKind::Union => false,\n-        }\n-    }\n-\n     pub fn descr(&self) -> &'static str {\n         match self.adt_kind() {\n             AdtKind::Struct => \"struct\","}, {"sha": "91c762a01b9dfe30cacd1d2f39b9cf64cad55da2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -507,28 +507,36 @@ impl<'a, 'tcx> CrateMetadata {\n                           self.def_path_table.def_path_hash(item_id))\n     }\n \n-    fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {\n+    fn get_variant(&self,\n+                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                   item: &Entry,\n+                   index: DefIndex,\n+                   adt_kind: ty::AdtKind)\n+                   -> ty::VariantDef\n+    {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data, _) |\n             EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        ty::VariantDef {\n-            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-            name: self.item_name(index).as_symbol(),\n-            fields: item.children.decode(self).map(|index| {\n+        ty::VariantDef::new(\n+            tcx,\n+            self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+            self.item_name(index).as_symbol(),\n+            data.discr,\n+            item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n                 ty::FieldDef {\n                     did: self.local_def_id(index),\n                     ident: Ident::from_interned_str(self.item_name(index)),\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            discr: data.discr,\n-            ctor_kind: data.ctor_kind,\n-        }\n+            adt_kind,\n+            data.ctor_kind\n+        )\n     }\n \n     pub fn get_adt_def(&self,\n@@ -549,11 +557,11 @@ impl<'a, 'tcx> CrateMetadata {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n-                    self.get_variant(&self.entry(index), index)\n+                    self.get_variant(tcx, &self.entry(index), index, kind)\n                 })\n                 .collect()\n         } else {\n-            vec![self.get_variant(&item, item_id)]\n+            vec![self.get_variant(tcx, &item, item_id, kind)]\n         };\n \n         tcx.alloc_adt_def(did, kind, variants, repr)"}, {"sha": "0fd43c592c8535dd3bfeae79456e6f7242a63cc9", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -740,7 +740,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n         // If the structure is marked as non_exhaustive then lower the visibility\n         // to within the crate.\n-        if adt_def.is_univariant_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n+        if adt_def.non_enum_variant().is_field_list_non_exhaustive() &&\n+            ctor_vis == ty::Visibility::Public\n+        {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n "}, {"sha": "d7fbbc88cc16d63e864e93c11e174b5163d852c9", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n-            ty::Adt(adt_def, ..) => adt_def.is_enum() && adt_def.is_enum_non_exhaustive(),\n+            ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n             _ => false,\n         }\n     }"}, {"sha": "635f18817377bc9e0c3cbc72e7a4c9b2e3b066dd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -684,7 +684,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n                         // visibility to within the crate.\n                         let struct_def_id = self.tcx.hir.get_parent_did(node_id);\n                         let adt_def = self.tcx.adt_def(struct_def_id);\n-                        if adt_def.is_univariant_non_exhaustive()\n+                        if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n                             && ctor_vis == ty::Visibility::Public\n                         {\n                             ctor_vis = ty::Visibility::Restricted("}, {"sha": "8907ba4b7bd5597694c077974ef78fa0a282649a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -948,7 +948,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         }\n \n         // Require `..` if struct has non_exhaustive attribute.\n-        if adt.is_variant_non_exhaustive(variant) && !adt.did.is_local() && !etc {\n+        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n             span_err!(tcx.sess, span, E0638,\n                       \"`..` required with {} marked as non-exhaustive\",\n                       kind_name);"}, {"sha": "cb14f4eb6ebdd96d0f0a4f76e3a6651785588801", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -3654,7 +3654,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Prohibit struct expressions when non exhaustive flag is set.\n         let adt = adt_ty.ty_adt_def().expect(\"`check_struct_path` returned non-ADT type\");\n-        if !adt.did.is_local() && adt.is_variant_non_exhaustive(variant) {\n+        if !adt.did.is_local() && variant.is_field_list_non_exhaustive() {\n             span_err!(self.tcx.sess, expr.span, E0639,\n                       \"cannot create non-exhaustive {} using struct expression\",\n                       adt.variant_descr());"}, {"sha": "80abf48a8a28664d65db6794fb0a2f904a0d79b6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ae2ad30bf1f3f924ed9ef977b3d2782f85fe2593", "patch": "@@ -548,12 +548,13 @@ fn convert_enum_variant_types<'a, 'tcx>(\n     }\n }\n \n-fn convert_struct_variant<'a, 'tcx>(\n+fn convert_variant<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     did: DefId,\n     name: ast::Name,\n     discr: ty::VariantDiscr,\n     def: &hir::VariantData,\n+    adt_kind: ty::AdtKind\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Ident, Span> = FxHashMap();\n     let node_id = tcx.hir.as_local_node_id(did).unwrap();\n@@ -584,13 +585,13 @@ fn convert_struct_variant<'a, 'tcx>(\n             }\n         })\n         .collect();\n-    ty::VariantDef {\n+    ty::VariantDef::new(tcx,\n         did,\n         name,\n         discr,\n         fields,\n-        ctor_kind: CtorKind::from_hir(def),\n-    }\n+        adt_kind,\n+        CtorKind::from_hir(def))\n }\n \n fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::AdtDef {\n@@ -621,7 +622,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n                         };\n                         distance_from_explicit += 1;\n \n-                        convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n+                        convert_variant(tcx, did, v.node.name, discr, &v.node.data, AdtKind::Enum)\n                     })\n                     .collect(),\n             )\n@@ -635,23 +636,25 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::Ad\n             };\n             (\n                 AdtKind::Struct,\n-                vec![convert_struct_variant(\n+                vec![convert_variant(\n                     tcx,\n                     ctor_id.unwrap_or(def_id),\n                     item.name,\n                     ty::VariantDiscr::Relative(0),\n                     def,\n+                    AdtKind::Struct\n                 )],\n             )\n         }\n         ItemKind::Union(ref def, _) => (\n             AdtKind::Union,\n-            vec![convert_struct_variant(\n+            vec![convert_variant(\n                 tcx,\n                 def_id,\n                 item.name,\n                 ty::VariantDiscr::Relative(0),\n                 def,\n+                AdtKind::Union\n             )],\n         ),\n         _ => bug!(),"}]}