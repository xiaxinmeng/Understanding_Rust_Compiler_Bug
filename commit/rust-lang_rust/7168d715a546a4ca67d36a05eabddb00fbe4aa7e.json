{"sha": "7168d715a546a4ca67d36a05eabddb00fbe4aa7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNjhkNzE1YTU0NmE0Y2E2N2QzNmEwNWVhYmRkYjAwZmJlNGFhN2U=", "commit": {"author": {"name": "Raphael Speyer", "email": "rspeyer@gmail.com", "date": "2013-12-09T17:13:54Z"}, "committer": {"name": "Raphael Speyer", "email": "rspeyer@gmail.com", "date": "2013-12-09T17:20:39Z"}, "message": "Implement PortReader and ChanWriter", "tree": {"sha": "d6835d8ede31093a4cd756e2c9ffb8b73e859e8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6835d8ede31093a4cd756e2c9ffb8b73e859e8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7168d715a546a4ca67d36a05eabddb00fbe4aa7e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7168d715a546a4ca67d36a05eabddb00fbe4aa7e", "html_url": "https://github.com/rust-lang/rust/commit/7168d715a546a4ca67d36a05eabddb00fbe4aa7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7168d715a546a4ca67d36a05eabddb00fbe4aa7e/comments", "author": {"login": "rapha", "id": 29763, "node_id": "MDQ6VXNlcjI5NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/29763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rapha", "html_url": "https://github.com/rapha", "followers_url": "https://api.github.com/users/rapha/followers", "following_url": "https://api.github.com/users/rapha/following{/other_user}", "gists_url": "https://api.github.com/users/rapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/rapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rapha/subscriptions", "organizations_url": "https://api.github.com/users/rapha/orgs", "repos_url": "https://api.github.com/users/rapha/repos", "events_url": "https://api.github.com/users/rapha/events{/privacy}", "received_events_url": "https://api.github.com/users/rapha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rapha", "id": 29763, "node_id": "MDQ6VXNlcjI5NzYz", "avatar_url": "https://avatars.githubusercontent.com/u/29763?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rapha", "html_url": "https://github.com/rapha", "followers_url": "https://api.github.com/users/rapha/followers", "following_url": "https://api.github.com/users/rapha/following{/other_user}", "gists_url": "https://api.github.com/users/rapha/gists{/gist_id}", "starred_url": "https://api.github.com/users/rapha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rapha/subscriptions", "organizations_url": "https://api.github.com/users/rapha/orgs", "repos_url": "https://api.github.com/users/rapha/repos", "events_url": "https://api.github.com/users/rapha/events{/privacy}", "received_events_url": "https://api.github.com/users/rapha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e0cb316fc980f00e1b74f3fdb7a842b540be280", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0cb316fc980f00e1b74f3fdb7a842b540be280", "html_url": "https://github.com/rust-lang/rust/commit/4e0cb316fc980f00e1b74f3fdb7a842b540be280"}], "stats": {"total": 183, "additions": 172, "deletions": 11}, "files": [{"sha": "a53146f00919126184f0f88276db01db7d5e1384", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 172, "deletions": 11, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/7168d715a546a4ca67d36a05eabddb00fbe4aa7e/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7168d715a546a4ca67d36a05eabddb00fbe4aa7e/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=7168d715a546a4ca67d36a05eabddb00fbe4aa7e", "patch": "@@ -8,30 +8,107 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::Option;\n-use comm::{GenericPort, GenericChan};\n+use prelude::*;\n+\n+use comm::{GenericPort, GenericChan, GenericSmartChan};\n+use cmp;\n+use io;\n+use option::{None, Option, Some};\n use super::{Reader, Writer};\n+use vec::{bytes, CopyableVector, MutableVector, ImmutableVector};\n \n-pub struct PortReader<P>;\n+/// Allows reading from a port.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let reader = PortReader::new(port);\n+///\n+/// let mut buf = ~[0u8, ..100];\n+/// match reader.read(buf) {\n+///     Some(nread) => println!(\"Read {} bytes\", nread),\n+///     None => println!(\"At the end of the stream!\")\n+/// }\n+/// ```\n+pub struct PortReader<P> {\n+    priv buf: Option<~[u8]>,  // A buffer of bytes received but not consumed.\n+    priv pos: uint,           // How many of the buffered bytes have already be consumed.\n+    priv port: P,             // The port to pull data from.\n+    priv closed: bool,        // Whether the pipe this port connects to has been closed.\n+}\n \n impl<P: GenericPort<~[u8]>> PortReader<P> {\n-    pub fn new(_port: P) -> PortReader<P> { fail!() }\n+    pub fn new(port: P) -> PortReader<P> {\n+        PortReader {\n+            buf: None,\n+            pos: 0,\n+            port: port,\n+            closed: false,\n+        }\n+    }\n }\n \n impl<P: GenericPort<~[u8]>> Reader for PortReader<P> {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let mut num_read = 0;\n+        loop {\n+            match self.buf {\n+                Some(ref prev) => {\n+                    let dst = buf.mut_slice_from(num_read);\n+                    let src = prev.slice_from(self.pos);\n+                    let count = cmp::min(dst.len(), src.len());\n+                    bytes::copy_memory(dst, src, count);\n+                    num_read += count;\n+                    self.pos += count;\n+                },\n+                None => (),\n+            };\n+            if num_read == buf.len() || self.closed {\n+                break;\n+            }\n+            self.pos = 0;\n+            self.buf = self.port.try_recv();\n+            self.closed = self.buf.is_none();\n+        }\n+        if self.closed && num_read == 0 {\n+            io::io_error::cond.raise(io::standard_error(io::EndOfFile));\n+            None\n+        } else {\n+            Some(num_read)\n+        }\n+    }\n \n-    fn eof(&mut self) -> bool { fail!() }\n+    fn eof(&mut self) -> bool { self.closed }\n }\n \n-pub struct ChanWriter<C>;\n+/// Allows writing to a chan.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let writer = ChanWriter::new(chan);\n+/// writer.write(\"hello, world\".as_bytes());\n+/// ```\n+pub struct ChanWriter<C> {\n+    chan: C,\n+}\n \n-impl<C: GenericChan<~[u8]>> ChanWriter<C> {\n-    pub fn new(_chan: C) -> ChanWriter<C> { fail!() }\n+impl<C: GenericSmartChan<~[u8]>> ChanWriter<C> {\n+    pub fn new(chan: C) -> ChanWriter<C> {\n+        ChanWriter { chan: chan }\n+    }\n }\n \n-impl<C: GenericChan<~[u8]>> Writer for ChanWriter<C> {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n+impl<C: GenericSmartChan<~[u8]>> Writer for ChanWriter<C> {\n+    fn write(&mut self, buf: &[u8]) {\n+        if !self.chan.try_send(buf.to_owned()) {\n+            io::io_error::cond.raise(io::IoError {\n+                kind: io::BrokenPipe,\n+                desc: \"Pipe closed\",\n+                detail: None\n+            });\n+        }\n+    }\n }\n \n pub struct ReaderPort<R>;\n@@ -55,3 +132,87 @@ impl<W: Writer> WriterChan<W> {\n impl<W: Writer> GenericChan<~[u8]> for WriterChan<W> {\n     fn send(&self, _x: ~[u8]) { fail!() }\n }\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use prelude::*;\n+    use super::*;\n+    use io;\n+    use comm;\n+    use task;\n+\n+    #[test]\n+    fn test_port_reader() {\n+        let (port, chan) = comm::stream();\n+        do task::spawn {\n+          chan.send(~[1u8, 2u8]);\n+          chan.send(~[]);\n+          chan.send(~[3u8, 4u8]);\n+          chan.send(~[5u8, 6u8]);\n+          chan.send(~[7u8, 8u8]);\n+        }\n+\n+        let mut reader = PortReader::new(port);\n+        let mut buf = ~[0u8, ..3];\n+\n+        assert_eq!(false, reader.eof());\n+\n+        assert_eq!(Some(0), reader.read(~[]));\n+        assert_eq!(false, reader.eof());\n+\n+        assert_eq!(Some(3), reader.read(buf));\n+        assert_eq!(false, reader.eof());\n+        assert_eq!(~[1,2,3], buf);\n+\n+        assert_eq!(Some(3), reader.read(buf));\n+        assert_eq!(false, reader.eof());\n+        assert_eq!(~[4,5,6], buf);\n+\n+        assert_eq!(Some(2), reader.read(buf));\n+        assert_eq!(~[7,8,6], buf);\n+        assert_eq!(true, reader.eof());\n+\n+        let mut err = None;\n+        let result = io::io_error::cond.trap(|io::standard_error(k, _, _)| {\n+            err = Some(k)\n+        }).inside(|| {\n+            reader.read(buf)\n+        });\n+        assert_eq!(Some(io::EndOfFile), err);\n+        assert_eq!(None, result);\n+        assert_eq!(true, reader.eof());\n+        assert_eq!(~[7,8,6], buf);\n+\n+        // Ensure it continues to fail in the same way.\n+        err = None;\n+        let result = io::io_error::cond.trap(|io::standard_error(k, _, _)| {\n+            err = Some(k)\n+        }).inside(|| {\n+            reader.read(buf)\n+        });\n+        assert_eq!(Some(io::EndOfFile), err);\n+        assert_eq!(None, result);\n+        assert_eq!(true, reader.eof());\n+        assert_eq!(~[7,8,6], buf);\n+    }\n+\n+    #[test]\n+    fn test_chan_writer() {\n+        let (port, chan) = comm::stream();\n+        let mut writer = ChanWriter::new(chan);\n+        writer.write_be_u32(42);\n+\n+        let wanted = ~[0u8, 0u8, 0u8, 42u8];\n+        let got = do task::try { port.recv() }.unwrap();\n+        assert_eq!(wanted, got);\n+\n+        let mut err = None;\n+        io::io_error::cond.trap(|io::IoError { kind, .. } | {\n+            err = Some(kind)\n+        }).inside(|| {\n+            writer.write_u8(1)\n+        });\n+        assert_eq!(Some(io::BrokenPipe), err);\n+    }\n+}"}]}