{"sha": "eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNzRmMjFmNWE2NmZjYjY2N2E2ZDdmZGY5YjRjMjUyMWM0ZDQwMzA=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-07-06T05:41:42Z"}, "committer": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-08-09T21:08:36Z"}, "message": "try to infer linker flavor from linker name and vice versa", "tree": {"sha": "de0bffb06a23943ed829aae2afc4d411f569cc15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de0bffb06a23943ed829aae2afc4d411f569cc15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "html_url": "https://github.com/rust-lang/rust/commit/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b73535f1e9c46a698527fab51b1cc9fad3f53412", "url": "https://api.github.com/repos/rust-lang/rust/commits/b73535f1e9c46a698527fab51b1cc9fad3f53412", "html_url": "https://github.com/rust-lang/rust/commit/b73535f1e9c46a698527fab51b1cc9fad3f53412"}], "stats": {"total": 139, "additions": 97, "deletions": 42}, "files": [{"sha": "58df8f336be9606872b66e77d6307bf916aa1fce", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "patch": "@@ -42,7 +42,7 @@ use syntax::feature_gate::AttributeType;\n use syntax_pos::{MultiSpan, Span};\n use util::profiling::SelfProfiler;\n \n-use rustc_target::spec::{LinkerFlavor, PanicStrategy};\n+use rustc_target::spec::PanicStrategy;\n use rustc_target::spec::{Target, TargetTriple};\n use rustc_data_structures::flock;\n use jobserver::Client;\n@@ -607,13 +607,6 @@ impl Session {\n             .panic\n             .unwrap_or(self.target.target.options.panic_strategy)\n     }\n-    pub fn linker_flavor(&self) -> LinkerFlavor {\n-        self.opts\n-            .debugging_opts\n-            .linker_flavor\n-            .unwrap_or(self.target.target.linker_flavor)\n-    }\n-\n     pub fn fewer_names(&self) -> bool {\n         let more_names = self.opts\n             .output_types"}, {"sha": "0317dead6c0d6e7a5aed73b19f6393cdc41155e6", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 82, "deletions": 26, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "patch": "@@ -60,7 +60,7 @@ pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-pub fn get_linker(sess: &Session) -> (PathBuf, Command) {\n+pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathBuf, Command) {\n     // If our linker looks like a batch script on Windows then to execute this\n     // we'll need to spawn `cmd` explicitly. This is primarily done to handle\n     // emscripten where the linker is `emcc.bat` and needs to be spawned as\n@@ -69,36 +69,21 @@ pub fn get_linker(sess: &Session) -> (PathBuf, Command) {\n     // This worked historically but is needed manually since #42436 (regression\n     // was tagged as #42791) and some more info can be found on #44443 for\n     // emscripten itself.\n-    let cmd = |linker: &Path| {\n+    let mut cmd = (|| {\n         if let Some(linker) = linker.to_str() {\n             if cfg!(windows) && linker.ends_with(\".bat\") {\n                 return Command::bat_script(linker)\n             }\n         }\n-        match sess.linker_flavor() {\n+        match flavor {\n             LinkerFlavor::Lld(f) => Command::lld(linker, f),\n             _ => Command::new(linker),\n \n         }\n-    };\n+    })();\n \n     let msvc_tool = windows_registry::find_tool(&sess.opts.target_triple.triple(), \"link.exe\");\n \n-    let linker_path = sess.opts.cg.linker.as_ref().map(|s| &**s)\n-        .or(sess.target.target.options.linker.as_ref().map(|s| s.as_ref()))\n-        .unwrap_or(match sess.linker_flavor() {\n-            LinkerFlavor::Msvc => {\n-                msvc_tool.as_ref().map(|t| t.path()).unwrap_or(\"link.exe\".as_ref())\n-            }\n-            LinkerFlavor::Em if cfg!(windows) => \"emcc.bat\".as_ref(),\n-            LinkerFlavor::Em => \"emcc\".as_ref(),\n-            LinkerFlavor::Gcc => \"cc\".as_ref(),\n-            LinkerFlavor::Ld => \"ld\".as_ref(),\n-            LinkerFlavor::Lld(_) => \"lld\".as_ref(),\n-        });\n-\n-    let mut cmd = cmd(linker_path);\n-\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n     let mut new_path = sess.host_filesearch(PathKind::All)\n@@ -125,7 +110,7 @@ pub fn get_linker(sess: &Session) -> (PathBuf, Command) {\n     }\n     cmd.env(\"PATH\", env::join_paths(new_path).unwrap());\n \n-    (linker_path.to_path_buf(), cmd)\n+    (linker.to_path_buf(), cmd)\n }\n \n pub fn remove(sess: &Session, path: &Path) {\n@@ -615,6 +600,71 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLibrary]) {\n     }\n }\n \n+pub fn linker_and_flavor(sess: &Session) -> Result<(PathBuf, LinkerFlavor), ()> {\n+    fn from<F>(\n+        sess: &Session,\n+        linker: Option<PathBuf>,\n+        flavor: Option<LinkerFlavor>,\n+        otherwise: F,\n+    ) -> Result<(PathBuf, LinkerFlavor), ()>\n+    where\n+        F: FnOnce() -> Result<(PathBuf, LinkerFlavor), ()>\n+    {\n+        match (linker, flavor) {\n+            (Some(linker), Some(flavor)) => Ok((linker, flavor)),\n+            // only the linker flavor is known; use the default linker for the selected flavor\n+            (None, Some(flavor)) => Ok((PathBuf::from(match flavor {\n+                LinkerFlavor::Em => \"emcc\",\n+                LinkerFlavor::Gcc => \"gcc\",\n+                LinkerFlavor::Ld => \"ld\",\n+                LinkerFlavor::Msvc => \"link.exe\",\n+                LinkerFlavor::Lld(_) => \"lld\",\n+            }), flavor)),\n+            // infer the linker flavor from the linker name\n+            (Some(linker), None) => {\n+                let stem = linker.file_stem().and_then(|stem| stem.to_str()).ok_or_else(|| {\n+                    sess\n+                        .struct_err(&format!(\"couldn't extract file stem from specified linker\"))\n+                        .emit();\n+                })?.to_owned();\n+\n+                let flavor = if stem == \"emcc\" {\n+                    LinkerFlavor::Em\n+                } else if stem == \"gcc\" || stem.ends_with(\"-gcc\") {\n+                    LinkerFlavor::Gcc\n+                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n+                    LinkerFlavor::Ld\n+                } else if stem == \"link\" || stem == \"lld-link\" {\n+                    LinkerFlavor::Msvc\n+                } else {\n+                    sess\n+                        .struct_err(&format!(\"couldn't infer linker flavor from specified linker\"))\n+                        .emit();\n+                    return Err(());\n+                };\n+\n+                Ok((linker, flavor))\n+            },\n+            (None, None) => otherwise(),\n+        }\n+    }\n+\n+    // linker and linker flavor specified via command line have precedence over what the target\n+    // specification specifies\n+    from(sess, sess.opts.cg.linker.clone(), sess.opts.debugging_opts.linker_flavor, || {\n+        from(\n+            sess,\n+            sess.target.target.options.linker.clone().map(PathBuf::from),\n+            Some(sess.target.target.linker_flavor),\n+            || {\n+                sess\n+                    .struct_err(&format!(\"no linker or linker flavor information provided\"))\n+                    .emit();\n+                Err(())\n+            })\n+    })\n+}\n+\n // Create a dynamic library or executable\n //\n // This will invoke the system linker/cc to create the resulting file. This\n@@ -625,10 +675,15 @@ fn link_natively(sess: &Session,\n                  codegen_results: &CodegenResults,\n                  tmpdir: &Path) {\n     info!(\"preparing {:?} to {:?}\", crate_type, out_filename);\n-    let flavor = sess.linker_flavor();\n+    let (linker, flavor) = if let Ok((linker, flavor)) = linker_and_flavor(sess) {\n+        (linker, flavor)\n+    } else {\n+        sess.abort_if_errors();\n+        return;\n+    };\n \n     // The invocations of cc share some flags across platforms\n-    let (pname, mut cmd) = get_linker(sess);\n+    let (pname, mut cmd) = get_linker(sess, &linker, flavor);\n \n     let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     if let Some(args) = sess.target.target.options.pre_link_args.get(&flavor) {\n@@ -669,8 +724,8 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess);\n-        link_args(&mut *linker, sess, crate_type, tmpdir,\n+        let mut linker = codegen_results.linker_info.to_linker(cmd, &sess, flavor);\n+        link_args(&mut *linker, flavor, sess, crate_type, tmpdir,\n                   out_filename, codegen_results);\n         cmd = linker.finalize();\n     }\n@@ -742,7 +797,7 @@ fn link_natively(sess: &Session,\n         // linking executables as pie. Different versions of gcc seem to use\n         // different quotes in the error message so don't check for them.\n         if sess.target.target.options.linker_is_gnu &&\n-           sess.linker_flavor() != LinkerFlavor::Ld &&\n+           flavor != LinkerFlavor::Ld &&\n            (out.contains(\"unrecognized command line option\") ||\n             out.contains(\"unknown argument\")) &&\n            out.contains(\"-no-pie\") &&\n@@ -991,6 +1046,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n }\n \n fn link_args(cmd: &mut dyn Linker,\n+             flavor: LinkerFlavor,\n              sess: &Session,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n@@ -1075,7 +1131,7 @@ fn link_args(cmd: &mut dyn Linker,\n             // independent executables by default. We have to pass -no-pie to\n             // explicitly turn that off. Not applicable to ld.\n             if sess.target.target.options.linker_is_gnu\n-                && sess.linker_flavor() != LinkerFlavor::Ld {\n+                && flavor != LinkerFlavor::Ld {\n                 cmd.no_position_independent_executable();\n             }\n         }"}, {"sha": "efa4b4d52079edbf8cb2326be8dfc056c43a6c52", "filename": "src/librustc_codegen_llvm/back/linker.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs?ref=eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "patch": "@@ -44,8 +44,9 @@ impl LinkerInfo {\n \n     pub fn to_linker<'a>(&'a self,\n                          cmd: Command,\n-                         sess: &'a Session) -> Box<dyn Linker+'a> {\n-        match sess.linker_flavor() {\n+                         sess: &'a Session,\n+                         flavor: LinkerFlavor) -> Box<dyn Linker+'a> {\n+        match flavor {\n             LinkerFlavor::Lld(LldFlavor::Link) |\n             LinkerFlavor::Msvc => {\n                 Box::new(MsvcLinker {"}, {"sha": "e5e837d05de389198a440bb6727d6f05e6479617", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=eb74f21f5a66fcb667a6d7fdf9b4c2521c4d4030", "patch": "@@ -1503,12 +1503,17 @@ fn start_executing_work(tcx: TyCtxt,\n \n     let assembler_cmd = if modules_config.no_integrated_as {\n         // HACK: currently we use linker (gcc) as our assembler\n-        let (name, mut cmd) = get_linker(sess);\n-        cmd.args(&sess.target.target.options.asm_args);\n-        Some(Arc::new(AssemblerCommand {\n-            name,\n-            cmd,\n-        }))\n+        if let Ok((linker, flavor)) = link::linker_and_flavor(sess) {\n+            let (name, mut cmd) = get_linker(sess, &linker, flavor);\n+            cmd.args(&sess.target.target.options.asm_args);\n+            Some(Arc::new(AssemblerCommand {\n+                name,\n+                cmd,\n+            }))\n+        } else {\n+            sess.abort_if_errors();\n+            None\n+        }\n     } else {\n         None\n     };"}]}