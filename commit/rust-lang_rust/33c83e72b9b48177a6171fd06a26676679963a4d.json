{"sha": "33c83e72b9b48177a6171fd06a26676679963a4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYzgzZTcyYjliNDgxNzdhNjE3MWZkMDZhMjY2NzY2Nzk5NjNhNGQ=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-02T23:26:53Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:59:20Z"}, "message": "Work towards better import labels", "tree": {"sha": "b787206319b2cf0050e4ce7c89ad4365b9a43c11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b787206319b2cf0050e4ce7c89ad4365b9a43c11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33c83e72b9b48177a6171fd06a26676679963a4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33c83e72b9b48177a6171fd06a26676679963a4d", "html_url": "https://github.com/rust-lang/rust/commit/33c83e72b9b48177a6171fd06a26676679963a4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33c83e72b9b48177a6171fd06a26676679963a4d/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d4ac1d4fa0aba107a27d3fd2d209304dfe69b9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d4ac1d4fa0aba107a27d3fd2d209304dfe69b9f", "html_url": "https://github.com/rust-lang/rust/commit/4d4ac1d4fa0aba107a27d3fd2d209304dfe69b9f"}], "stats": {"total": 482, "additions": 243, "deletions": 239}, "files": [{"sha": "07ee7bdfd7ecf205dd410af5390f66ff10e9a41f", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -1094,4 +1094,27 @@ mod tests {\n             expect![[r#\"\"#]],\n         );\n     }\n+\n+    #[test]\n+    fn search_with_path() {\n+        check_search(\n+            r#\"\n+//- /main.rs crate:main deps:dep\n+//- /dep.rs crate:dep\n+pub mod foo {\n+    pub mod bar {\n+        pub mod baz {\n+            pub trait Display {\n+                fn fmt();\n+            }\n+        }\n+    }\n+}\"#,\n+            \"main\",\n+            Query::new(\"baz::fmt\".to_string()).search_mode(SearchMode::Fuzzy),\n+            expect![[r#\"\n+                dep::foo::bar::baz::Display::fmt (a)\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "f83ed65d5a6b58b9b593c6e8a18a3a68b589d152", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -478,7 +478,6 @@ impl Analysis {\n         position: FilePosition,\n         full_import_path: &str,\n         imported_name: String,\n-        import_for_trait_assoc_item: bool,\n     ) -> Cancelable<Vec<TextEdit>> {\n         Ok(self\n             .with_db(|db| {\n@@ -488,7 +487,6 @@ impl Analysis {\n                     position,\n                     full_import_path,\n                     imported_name,\n-                    import_for_trait_assoc_item,\n                 )\n             })?\n             .unwrap_or_default())"}, {"sha": "f3c969eeeca7b3ab9cf95ff8c3ca9e4981e662ed", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -93,17 +93,18 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let group = import_group_message(import_assets.import_candidate());\n     let scope = ImportScope::find_insert_use_container(&syntax_under_caret, &ctx.sema)?;\n     for import in proposed_imports {\n+        let name = match import.original_item_name(ctx.db()) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n-            format!(\"Import `{}`\", import.display_path()),\n+            format!(\"Import `{}`\", name),\n             range,\n             |builder| {\n-                let rewriter = insert_use(\n-                    &scope,\n-                    mod_path_to_ast(import.import_path()),\n-                    ctx.config.insert_use,\n-                );\n+                let rewriter =\n+                    insert_use(&scope, mod_path_to_ast(&import.import_path), ctx.config.insert_use);\n                 builder.rewrite(rewriter);\n             },\n         );"}, {"sha": "407ba47beaba294c6d86bcfb4b8edd6559f025f8", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -2,7 +2,7 @@ use std::iter;\n \n use hir::AsAssocItem;\n use ide_db::helpers::{\n-    import_assets::{ImportCandidate, Qualifier},\n+    import_assets::{ImportCandidate, LocatedImport, Qualifier},\n     mod_path_to_ast,\n };\n use ide_db::RootDatabase;\n@@ -78,13 +78,13 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         acc.add_group(\n             &group_label,\n             AssistId(\"qualify_path\", AssistKind::QuickFix),\n-            label(candidate, import.display_path()),\n+            label(ctx.db(), candidate, &import),\n             range,\n             |builder| {\n                 qualify_candidate.qualify(\n                     |replace_with: String| builder.replace(range, replace_with),\n-                    import.import_path(),\n-                    import.item_to_import(),\n+                    &import.import_path,\n+                    import.item_to_import,\n                 )\n             },\n         );\n@@ -197,17 +197,21 @@ fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n     GroupLabel(format!(\"Qualify {}\", name))\n }\n \n-fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n+fn label(db: &RootDatabase, candidate: &ImportCandidate, import: &LocatedImport) -> String {\n+    let display_path = match import.original_item_name(db) {\n+        Some(display_path) => display_path.to_string(),\n+        None => \"{unknown}\".to_string(),\n+    };\n     match candidate {\n         ImportCandidate::Path(candidate) => {\n             if !matches!(candidate.qualifier, Qualifier::Absent) {\n-                format!(\"Qualify with `{}`\", &import)\n+                format!(\"Qualify with `{}`\", display_path)\n             } else {\n-                format!(\"Qualify as `{}`\", &import)\n+                format!(\"Qualify as `{}`\", display_path)\n             }\n         }\n-        ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", &import),\n-        ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", &import),\n+        ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", display_path),\n+        ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", display_path),\n     }\n }\n "}, {"sha": "93a03e8b25ba9f7a9096567be279af8ce09a6b73", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -1,5 +1,6 @@\n+use hir::ModuleDef;\n use ide_db::helpers::mod_path_to_ast;\n-use ide_db::imports_locator;\n+use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n     ast::{self, make, AstNode, NameOwner},\n@@ -64,13 +65,14 @@ pub(crate) fn replace_derive_with_manual_impl(\n     let current_module = ctx.sema.scope(annotated_name.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n-    let found_traits = imports_locator::find_exact_imports(\n+    let found_traits = items_locator::with_for_exact_name(\n         &ctx.sema,\n         current_crate,\n         trait_token.text().to_string(),\n     )\n-    .filter_map(|candidate: either::Either<hir::ModuleDef, hir::MacroDef>| match candidate {\n-        either::Either::Left(hir::ModuleDef::Trait(trait_)) => Some(trait_),\n+    .into_iter()\n+    .filter_map(|item| match ModuleDef::from(item.as_module_def_id()?) {\n+        ModuleDef::Trait(trait_) => Some(trait_),\n         _ => None,\n     })\n     .flat_map(|trait_| {"}, {"sha": "c1e3f091fbfbd015614045b4605c4396d6a6b375", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 54, "deletions": 47, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -87,11 +87,12 @@\n //! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n //! capability enabled.\n \n-use hir::{AsAssocItem, ModPath, ModuleDef, ScopeDef};\n+use hir::ModPath;\n use ide_db::helpers::{\n     import_assets::{ImportAssets, ImportCandidate},\n     insert_use::ImportScope,\n };\n+use itertools::Itertools;\n use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n@@ -130,27 +131,23 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         &ctx.sema,\n     )?;\n \n-    let mut all_imports =\n-        import_assets.search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind);\n-    all_imports.sort_by_cached_key(|import| {\n-        compute_fuzzy_completion_order_key(import.display_path(), &user_input_lowercased)\n-    });\n-\n-    acc.add_all(all_imports.into_iter().filter_map(|import| {\n-        let import_for_trait_assoc_item = import\n-            .item_to_display()\n-            .as_module_def_id()\n-            .and_then(|module_def_id| {\n-                ModuleDef::from(module_def_id).as_assoc_item(ctx.db)?.containing_trait(ctx.db)\n+    acc.add_all(\n+        import_assets\n+            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .into_iter()\n+            .sorted_by_key(|located_import| {\n+                compute_fuzzy_completion_order_key(\n+                    &located_import.import_path,\n+                    &user_input_lowercased,\n+                )\n             })\n-            .is_some();\n-        let def_to_display = ScopeDef::from(import.item_to_display());\n-        render_resolution_with_import(\n-            RenderContext::new(ctx),\n-            ImportEdit { import, import_scope: import_scope.clone(), import_for_trait_assoc_item },\n-            &def_to_display,\n-        )\n-    }));\n+            .filter_map(|import| {\n+                render_resolution_with_import(\n+                    RenderContext::new(ctx),\n+                    ImportEdit { import, import_scope: import_scope.clone() },\n+                )\n+            }),\n+    );\n     Some(())\n }\n \n@@ -190,6 +187,7 @@ fn import_assets<'a>(ctx: &'a CompletionContext, fuzzy_name: String) -> Option<I\n             ctx.scope.clone(),\n         )?;\n \n+        // TODO kb bad: with the path prefix, the \"min 3 symbols\" limit applies. Fix in a separate PR on the symbol_index level\n         if matches!(assets_for_path.import_candidate(), ImportCandidate::Path(_))\n             && fuzzy_name_length < 2\n         {\n@@ -796,9 +794,7 @@ fn main() {\n \n     #[test]\n     fn unresolved_qualifier() {\n-        check_edit(\n-            \"Item\",\n-            r#\"\n+        let fixture = r#\"\n mod foo {\n     pub mod bar {\n         pub mod baz {\n@@ -809,31 +805,34 @@ mod foo {\n \n fn main() {\n     bar::baz::Ite$0\n-}\n-\"#,\n+}\"#;\n+\n+        check(fixture, expect![[\"st Item (foo::bar::baz::Item)\"]]);\n+\n+        check_edit(\n+            \"Item\",\n+            fixture,\n             r#\"\n-use foo::bar;\n+        use foo::bar;\n \n-mod foo {\n-    pub mod bar {\n-        pub mod baz {\n-            pub struct Item;\n+        mod foo {\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Item;\n+                }\n+            }\n         }\n-    }\n-}\n \n-fn main() {\n-    bar::baz::Item\n-}\n-\"#,\n+        fn main() {\n+            bar::baz::Item\n+        }\n+        \"#,\n         );\n     }\n \n     #[test]\n     fn unresolved_assoc_item_container() {\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            r#\"\n+        let fixture = r#\"\n mod foo {\n     pub struct Item;\n \n@@ -844,8 +843,13 @@ mod foo {\n \n fn main() {\n     Item::TEST_A$0\n-}\n-\"#,\n+}\"#;\n+\n+        check(fixture, expect![[\"ct TEST_ASSOC (foo::bar::baz::Item)\"]]);\n+\n+        check_edit(\n+            \"TEST_ASSOC\",\n+            fixture,\n             r#\"\n use foo::Item;\n \n@@ -866,9 +870,7 @@ fn main() {\n \n     #[test]\n     fn unresolved_assoc_item_container_with_path() {\n-        check_edit(\n-            \"TEST_ASSOC\",\n-            r#\"\n+        let fixture = r#\"\n mod foo {\n     pub mod bar {\n         pub struct Item;\n@@ -881,8 +883,13 @@ mod foo {\n \n fn main() {\n     bar::Item::TEST_A$0\n-}\n-\"#,\n+}\"#;\n+\n+        check(fixture, expect![[\"ct TEST_ASSOC (foo::bar::baz::Item)\"]]);\n+\n+        check_edit(\n+            \"TEST_ASSOC\",\n+            fixture,\n             r#\"\n use foo::bar;\n "}, {"sha": "d01620500ccaab77113b34b403901fbf00e307e3", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -275,7 +275,6 @@ impl CompletionItem {\n pub struct ImportEdit {\n     pub import: LocatedImport,\n     pub import_scope: ImportScope,\n-    pub import_for_trait_assoc_item: bool,\n }\n \n impl ImportEdit {\n@@ -286,7 +285,7 @@ impl ImportEdit {\n \n         let rewriter = insert_use::insert_use(\n             &self.import_scope,\n-            mod_path_to_ast(self.import.import_path()),\n+            mod_path_to_ast(&self.import.import_path),\n             cfg,\n         );\n         let old_ast = rewriter.rewrite_root()?;\n@@ -303,6 +302,7 @@ impl ImportEdit {\n pub(crate) struct Builder {\n     source_range: TextRange,\n     completion_kind: CompletionKind,\n+    // TODO kb also add a db here, to resolve the completion label?\n     import_to_add: Option<ImportEdit>,\n     label: String,\n     insert_text: Option<String>,\n@@ -322,19 +322,22 @@ impl Builder {\n     pub(crate) fn build(self) -> CompletionItem {\n         let _p = profile::span(\"item::Builder::build\");\n \n-        let mut label = self.label;\n-        let mut lookup = self.lookup;\n-        let mut insert_text = self.insert_text;\n-\n-        if let Some(import_to_add) = self.import_to_add.as_ref() {\n-            lookup = lookup.or_else(|| Some(label.clone()));\n-            insert_text = insert_text.or_else(|| Some(label.clone()));\n-            let display_path = import_to_add.import.display_path();\n-            if import_to_add.import_for_trait_assoc_item {\n-                label = format!(\"{} ({})\", label, display_path);\n-            } else {\n-                label = display_path.to_string();\n-            }\n+        let label = self.label;\n+        let lookup = self.lookup;\n+        let insert_text = self.insert_text;\n+\n+        if let Some(_import_to_add) = self.import_to_add.as_ref() {\n+            todo!(\"todo kb\")\n+            // let import = &import_to_add.import;\n+            // let item_to_import = import.item_to_import();\n+            // lookup = lookup.or_else(|| Some(label.clone()));\n+            // insert_text = insert_text.or_else(|| Some(label.clone()));\n+            // let display_path = import_to_add.import.display_path();\n+            // if import_to_add.import {\n+            //     label = format!(\"{} ({})\", label, display_path);\n+            // } else {\n+            //     label = display_path.to_string();\n+            // }\n         }\n \n         let text_edit = match self.text_edit {\n@@ -438,8 +441,8 @@ impl Builder {\n     }\n }\n \n-impl<'a> Into<CompletionItem> for Builder {\n-    fn into(self) -> CompletionItem {\n-        self.build()\n-    }\n-}\n+// impl<'a> Into<CompletionItem> for Builder {\n+//     fn into(self) -> CompletionItem {\n+//         self.build()\n+//     }\n+// }"}, {"sha": "d19368de0942b2556bbc160179aa764c29fa82bd", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -15,7 +15,7 @@ use completions::flyimport::position_for_import;\n use ide_db::{\n     base_db::FilePosition,\n     helpers::{import_assets::LocatedImport, insert_use::ImportScope},\n-    imports_locator, RootDatabase,\n+    items_locator, RootDatabase,\n };\n use text_edit::TextEdit;\n \n@@ -141,7 +141,6 @@ pub fn resolve_completion_edits(\n     position: FilePosition,\n     full_import_path: &str,\n     imported_name: String,\n-    import_for_trait_assoc_item: bool,\n ) -> Option<Vec<TextEdit>> {\n     let ctx = CompletionContext::new(db, position, config)?;\n     let position_for_import = position_for_import(&ctx, None)?;\n@@ -151,19 +150,17 @@ pub fn resolve_completion_edits(\n     let current_crate = current_module.krate();\n \n     let (import_path, item_to_import) =\n-        imports_locator::find_exact_imports(&ctx.sema, current_crate, imported_name)\n+        items_locator::with_for_exact_name(&ctx.sema, current_crate, imported_name)\n+            .into_iter()\n             .filter_map(|candidate| {\n-                let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n                 current_module\n-                    .find_use_path_prefixed(db, item, config.insert_use.prefix_kind)\n-                    .zip(Some(item))\n+                    .find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n+                    .zip(Some(candidate))\n             })\n             .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n-    let import = LocatedImport::new(import_path, item_to_import, None);\n+    let import = LocatedImport::new(import_path, item_to_import, item_to_import);\n \n-    ImportEdit { import_path, import_scope, import_for_trait_assoc_item }\n-        .to_text_edit(config.insert_use)\n-        .map(|edit| vec![edit])\n+    ImportEdit { import, import_scope }.to_text_edit(config.insert_use).map(|edit| vec![edit])\n }\n \n #[cfg(test)]"}, {"sha": "fae5685e2270a944fe6f9941e9415abc228dddf5", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -53,18 +53,20 @@ pub(crate) fn render_resolution<'a>(\n pub(crate) fn render_resolution_with_import<'a>(\n     ctx: RenderContext<'a>,\n     import_edit: ImportEdit,\n-    resolution: &ScopeDef,\n ) -> Option<CompletionItem> {\n+    let resolution = ScopeDef::from(import_edit.import.original_item);\n     let local_name = match resolution {\n         ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n         ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n         ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n-        _ => item_name(ctx.db(), import_edit.import.item_to_display())?.to_string(),\n+        _ => item_name(ctx.db(), import_edit.import.original_item)?.to_string(),\n     };\n-    Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n-        item.completion_kind = CompletionKind::Magic;\n-        item\n-    })\n+    Render::new(ctx).render_resolution(local_name, Some(import_edit), &resolution).map(\n+        |mut item| {\n+            item.completion_kind = CompletionKind::Magic;\n+            item\n+        },\n+    )\n }\n \n /// Interface for data and methods required for items rendering."}, {"sha": "8d16c011e71175eb242a26bcf2f334a322301d30", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 61, "deletions": 94, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -1,14 +1,13 @@\n //! Look up accessible paths for items.\n-use either::Either;\n use hir::{\n     AsAssocItem, AssocItem, AssocItemContainer, Crate, ItemInNs, MacroDef, ModPath, Module,\n-    ModuleDef, PathResolution, PrefixKind, ScopeDef, Semantics, SemanticsScope, Type,\n+    ModuleDef, Name, PathResolution, PrefixKind, ScopeDef, Semantics, SemanticsScope, Type,\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    imports_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n+    items_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n     RootDatabase,\n };\n \n@@ -130,34 +129,23 @@ impl<'a> ImportAssets<'a> {\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct LocatedImport {\n-    import_path: ModPath,\n-    item_to_import: ItemInNs,\n-    data_to_display: Option<(ModPath, ItemInNs)>,\n+    pub import_path: ModPath,\n+    pub item_to_import: ItemInNs,\n+    pub original_item: ItemInNs,\n }\n \n impl LocatedImport {\n-    pub fn new(\n-        import_path: ModPath,\n-        item_to_import: ItemInNs,\n-        data_to_display: Option<(ModPath, ItemInNs)>,\n-    ) -> Self {\n-        Self { import_path, item_to_import, data_to_display }\n+    pub fn new(import_path: ModPath, item_to_import: ItemInNs, original_item: ItemInNs) -> Self {\n+        Self { import_path, item_to_import, original_item }\n     }\n \n-    pub fn display_path(&self) -> &ModPath {\n-        self.data_to_display.as_ref().map(|(mod_path, _)| mod_path).unwrap_or(&self.import_path)\n-    }\n-\n-    pub fn import_path(&self) -> &ModPath {\n-        &self.import_path\n-    }\n-\n-    pub fn item_to_display(&self) -> ItemInNs {\n-        self.data_to_display.as_ref().map(|&(_, item)| item).unwrap_or(self.item_to_import)\n-    }\n-\n-    pub fn item_to_import(&self) -> ItemInNs {\n-        self.item_to_import\n+    pub fn original_item_name(&self, db: &RootDatabase) -> Option<Name> {\n+        match self.original_item {\n+            ItemInNs::Types(module_def_id) | ItemInNs::Values(module_def_id) => {\n+                ModuleDef::from(module_def_id).name(db)\n+            }\n+            ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).name(db),\n+        }\n     }\n }\n \n@@ -166,25 +154,20 @@ impl<'a> ImportAssets<'a> {\n         &self.import_candidate\n     }\n \n-    fn name_to_import(&self) -> &NameToImport {\n-        match &self.import_candidate {\n-            ImportCandidate::Path(candidate) => &candidate.name,\n-            ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n-        }\n-    }\n-\n     pub fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefix_kind: PrefixKind,\n-    ) -> Vec<LocatedImport> {\n+    ) -> FxHashSet<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n         self.search_for(sema, Some(prefix_kind))\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n-    pub fn search_for_relative_paths(&self, sema: &Semantics<RootDatabase>) -> Vec<LocatedImport> {\n+    pub fn search_for_relative_paths(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> FxHashSet<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n@@ -193,14 +176,13 @@ impl<'a> ImportAssets<'a> {\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefixed: Option<PrefixKind>,\n-    ) -> Vec<LocatedImport> {\n-        let current_crate = self.module_with_candidate.krate();\n-        let scope_definitions = self.scope_definitions();\n-\n-        let defs_for_candidate_name = match self.name_to_import() {\n-            NameToImport::Exact(exact_name) => {\n-                imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n-            }\n+    ) -> FxHashSet<LocatedImport> {\n+        let items_with_candidate_name = match self.name_to_import() {\n+            NameToImport::Exact(exact_name) => items_locator::with_for_exact_name(\n+                sema,\n+                self.module_with_candidate.krate(),\n+                exact_name.clone(),\n+            ),\n             // FIXME: ideally, we should avoid using `fst` for seacrhing trait imports for assoc items:\n             // instead, we need to look up all trait impls for a certain struct and search through them only\n             // see https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761585032\n@@ -213,20 +195,21 @@ impl<'a> ImportAssets<'a> {\n                     (AssocItemSearch::Include, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n                 };\n \n-                imports_locator::find_similar_imports(\n+                items_locator::with_similar_name(\n                     sema,\n-                    current_crate,\n+                    self.module_with_candidate.krate(),\n                     fuzzy_name.clone(),\n                     assoc_item_search,\n                     limit,\n                 )\n             }\n         };\n \n-        self.applicable_defs(sema.db, prefixed, defs_for_candidate_name)\n+        let scope_definitions = self.scope_definitions();\n+        self.applicable_defs(sema.db, prefixed, items_with_candidate_name)\n             .into_iter()\n-            .filter(|import| import.import_path().len() > 1)\n-            .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import())))\n+            .filter(|import| import.import_path.len() > 1)\n+            .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import)))\n             .collect()\n     }\n \n@@ -238,11 +221,19 @@ impl<'a> ImportAssets<'a> {\n         scope_definitions\n     }\n \n+    fn name_to_import(&self) -> &NameToImport {\n+        match &self.import_candidate {\n+            ImportCandidate::Path(candidate) => &candidate.name,\n+            ImportCandidate::TraitAssocItem(candidate)\n+            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n+        }\n+    }\n+\n     fn applicable_defs(\n         &self,\n         db: &RootDatabase,\n         prefixed: Option<PrefixKind>,\n-        defs_for_candidate_name: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+        items_with_candidate_name: FxHashSet<ItemInNs>,\n     ) -> FxHashSet<LocatedImport> {\n         let _p = profile::span(\"import_assets::applicable_defs\");\n         let current_crate = self.module_with_candidate.krate();\n@@ -251,23 +242,23 @@ impl<'a> ImportAssets<'a> {\n \n         match &self.import_candidate {\n             ImportCandidate::Path(path_candidate) => {\n-                path_applicable_imports(db, path_candidate, mod_path, defs_for_candidate_name)\n+                path_applicable_imports(db, path_candidate, mod_path, items_with_candidate_name)\n             }\n             ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_items(\n                 db,\n                 current_crate,\n                 trait_candidate,\n                 true,\n                 mod_path,\n-                defs_for_candidate_name,\n+                items_with_candidate_name,\n             ),\n             ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_items(\n                 db,\n                 current_crate,\n                 trait_candidate,\n                 false,\n                 mod_path,\n-                defs_for_candidate_name,\n+                items_with_candidate_name,\n             ),\n         }\n     }\n@@ -277,25 +268,24 @@ fn path_applicable_imports(\n     db: &RootDatabase,\n     path_candidate: &PathImportCandidate,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath> + Copy,\n-    defs_for_candidate_name: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+    items_with_candidate_name: FxHashSet<ItemInNs>,\n ) -> FxHashSet<LocatedImport> {\n     let _p = profile::span(\"import_assets::path_applicable_imports\");\n \n-    let items_for_candidate_name =\n-        defs_for_candidate_name.map(|def| def.either(ItemInNs::from, ItemInNs::from));\n-\n     let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n         Qualifier::Absent => {\n-            return items_for_candidate_name\n-                .filter_map(|item| Some(LocatedImport::new(mod_path(item)?, item, None)))\n+            return items_with_candidate_name\n+                .into_iter()\n+                .filter_map(|item| Some(LocatedImport::new(mod_path(item)?, item, item)))\n                 .collect();\n         }\n         Qualifier::FirstSegmentUnresolved(first_segment, qualifier) => {\n             (first_segment.to_string(), qualifier.to_string())\n         }\n     };\n \n-    items_for_candidate_name\n+    items_with_candidate_name\n+        .into_iter()\n         .filter_map(|item| {\n             import_for_item(db, mod_path, &unresolved_first_segment, &unresolved_qualifier, item)\n         })\n@@ -336,7 +326,6 @@ fn import_for_item(\n     }\n \n     let segment_import = find_import_for_segment(db, item_candidate, &unresolved_first_segment)?;\n-    let data_to_display = Some((import_path_candidate.clone(), original_item));\n     Some(match (segment_import == item_candidate, trait_to_import) {\n         (true, Some(_)) => {\n             // FIXME we should be able to import both the trait and the segment,\n@@ -345,11 +334,11 @@ fn import_for_item(\n             return None;\n         }\n         (false, Some(trait_to_import)) => {\n-            LocatedImport::new(mod_path(trait_to_import)?, trait_to_import, data_to_display)\n+            LocatedImport::new(mod_path(trait_to_import)?, trait_to_import, original_item)\n         }\n-        (true, None) => LocatedImport::new(import_path_candidate, item_candidate, data_to_display),\n+        (true, None) => LocatedImport::new(import_path_candidate, item_candidate, original_item),\n         (false, None) => {\n-            LocatedImport::new(mod_path(segment_import)?, segment_import, data_to_display)\n+            LocatedImport::new(mod_path(segment_import)?, segment_import, original_item)\n         }\n     })\n }\n@@ -399,16 +388,14 @@ fn trait_applicable_items(\n     trait_candidate: &TraitImportCandidate,\n     trait_assoc_item: bool,\n     mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n-    defs_for_candidate_name: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n+    items_with_candidate_name: FxHashSet<ItemInNs>,\n ) -> FxHashSet<LocatedImport> {\n     let _p = profile::span(\"import_assets::trait_applicable_items\");\n     let mut required_assoc_items = FxHashSet::default();\n \n-    let trait_candidates = defs_for_candidate_name\n-        .filter_map(|input| match input {\n-            Either::Left(module_def) => module_def.as_assoc_item(db),\n-            _ => None,\n-        })\n+    let trait_candidates = items_with_candidate_name\n+        .into_iter()\n+        .filter_map(|input| ModuleDef::from(input.as_module_def_id()?).as_assoc_item(db))\n         .filter_map(|assoc| {\n             let assoc_item_trait = assoc.containing_trait(db)?;\n             required_assoc_items.insert(assoc);\n@@ -433,20 +420,10 @@ fn trait_applicable_items(\n                     }\n \n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n-                    let item_path = mod_path(item)?;\n-\n-                    let assoc_item = assoc_to_item(assoc);\n-                    let assoc_item_path = match assoc.container(db) {\n-                        AssocItemContainer::Trait(_) => item_path.clone(),\n-                        AssocItemContainer::Impl(impl_) => mod_path(ItemInNs::from(\n-                            ModuleDef::from(impl_.target_ty(db).as_adt()?),\n-                        ))?,\n-                    };\n-\n                     located_imports.insert(LocatedImport::new(\n-                        item_path,\n+                        mod_path(item)?,\n                         item,\n-                        Some((assoc_item_path, assoc_item)),\n+                        assoc_to_item(assoc),\n                     ));\n                 }\n                 None::<()>\n@@ -462,20 +439,10 @@ fn trait_applicable_items(\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n-                    let item_path = mod_path(item)?;\n-\n-                    let assoc_item = assoc_to_item(assoc);\n-                    let assoc_item_path = match assoc.container(db) {\n-                        AssocItemContainer::Trait(_) => item_path.clone(),\n-                        AssocItemContainer::Impl(impl_) => mod_path(ItemInNs::from(\n-                            ModuleDef::from(impl_.target_ty(db).as_adt()?),\n-                        ))?,\n-                    };\n-\n                     located_imports.insert(LocatedImport::new(\n-                        item_path,\n+                        mod_path(item)?,\n                         item,\n-                        Some((assoc_item_path, assoc_item)),\n+                        assoc_to_item(assoc),\n                     ));\n                 }\n                 None::<()>"}, {"sha": "b81c14618a3ad414a09b5fb7c6cc448e7872c158", "filename": "crates/ide_db/src/items_locator.rs", "status": "renamed", "additions": 39, "deletions": 36, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -1,9 +1,10 @@\n //! This module contains an import search functionality that is provided to the assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the assists module.\n \n+use either::Either;\n use hir::{\n     import_map::{self, ImportKind},\n-    AsAssocItem, Crate, MacroDef, ModuleDef, Semantics,\n+    AsAssocItem, Crate, ItemInNs, ModuleDef, Semantics,\n };\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n@@ -12,32 +13,31 @@ use crate::{\n     symbol_index::{self, FileSymbol},\n     RootDatabase,\n };\n-use either::Either;\n use rustc_hash::FxHashSet;\n \n pub(crate) const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n \n-pub fn find_exact_imports(\n+pub fn with_for_exact_name(\n     sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n-    name_to_import: String,\n-) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>>> {\n+    exact_name: String,\n+) -> FxHashSet<ItemInNs> {\n     let _p = profile::span(\"find_exact_imports\");\n-    Box::new(find_imports(\n+    find_items(\n         sema,\n         krate,\n         {\n-            let mut local_query = symbol_index::Query::new(name_to_import.clone());\n+            let mut local_query = symbol_index::Query::new(exact_name.clone());\n             local_query.exact();\n             local_query.limit(DEFAULT_QUERY_SEARCH_LIMIT);\n             local_query\n         },\n-        import_map::Query::new(name_to_import)\n+        import_map::Query::new(exact_name)\n             .limit(DEFAULT_QUERY_SEARCH_LIMIT)\n             .name_only()\n             .search_mode(import_map::SearchMode::Equals)\n             .case_sensitive(),\n-    ))\n+    )\n }\n \n #[derive(Debug)]\n@@ -47,13 +47,13 @@ pub enum AssocItemSearch {\n     AssocItemsOnly,\n }\n \n-pub fn find_similar_imports<'a>(\n-    sema: &'a Semantics<'a, RootDatabase>,\n+pub fn with_similar_name(\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n     fuzzy_search_string: String,\n     assoc_item_search: AssocItemSearch,\n     limit: Option<usize>,\n-) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n+) -> FxHashSet<ItemInNs> {\n     let _p = profile::span(\"find_similar_imports\");\n \n     let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n@@ -77,56 +77,59 @@ pub fn find_similar_imports<'a>(\n         local_query.limit(limit);\n     }\n \n-    Box::new(find_imports(sema, krate, local_query, external_query).filter(\n-        move |import_candidate| match assoc_item_search {\n+    find_items(sema, krate, local_query, external_query)\n+        .into_iter()\n+        .filter(move |&item| match assoc_item_search {\n             AssocItemSearch::Include => true,\n-            AssocItemSearch::Exclude => !is_assoc_item(import_candidate, sema.db),\n-            AssocItemSearch::AssocItemsOnly => is_assoc_item(import_candidate, sema.db),\n-        },\n-    ))\n+            AssocItemSearch::Exclude => !is_assoc_item(item, sema.db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(item, sema.db),\n+        })\n+        .collect()\n }\n \n-fn is_assoc_item(import_candidate: &Either<ModuleDef, MacroDef>, db: &RootDatabase) -> bool {\n-    match import_candidate {\n-        Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_some(),\n-        Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_some(),\n-        Either::Left(ModuleDef::TypeAlias(type_alias)) => type_alias.as_assoc_item(db).is_some(),\n-        _ => false,\n-    }\n+fn is_assoc_item(item: ItemInNs, db: &RootDatabase) -> bool {\n+    item.as_module_def_id()\n+        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n+        .is_some()\n }\n \n-fn find_imports<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+fn find_items(\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n     local_query: symbol_index::Query,\n     external_query: import_map::Query,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+) -> FxHashSet<ItemInNs> {\n     let _p = profile::span(\"find_similar_imports\");\n     let db = sema.db;\n \n     // Query dependencies first.\n-    let mut candidates: FxHashSet<_> =\n-        krate.query_external_importables(db, external_query).collect();\n+    let mut candidates = krate\n+        .query_external_importables(db, external_query)\n+        .map(|external_importable| match external_importable {\n+            Either::Left(module_def) => ItemInNs::from(module_def),\n+            Either::Right(macro_def) => ItemInNs::from(macro_def),\n+        })\n+        .collect::<FxHashSet<_>>();\n \n     // Query the local crate using the symbol index.\n     let local_results = symbol_index::crate_symbols(db, krate.into(), local_query);\n \n     candidates.extend(\n         local_results\n             .into_iter()\n-            .filter_map(|import_candidate| get_name_definition(sema, &import_candidate))\n+            .filter_map(|local_candidate| get_name_definition(sema, &local_candidate))\n             .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n-                Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n+                Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n+                Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n                 _ => None,\n             }),\n     );\n \n-    candidates.into_iter()\n+    candidates\n }\n \n-fn get_name_definition<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+fn get_name_definition(\n+    sema: &Semantics<'_, RootDatabase>,\n     import_candidate: &FileSymbol,\n ) -> Option<Definition> {\n     let _p = profile::span(\"get_name_definition\");", "previous_filename": "crates/ide_db/src/imports_locator.rs"}, {"sha": "88ee4a87d51c4b9019a9270ee5ef841aea153481", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -8,7 +8,7 @@ pub mod line_index;\n pub mod symbol_index;\n pub mod defs;\n pub mod search;\n-pub mod imports_locator;\n+pub mod items_locator;\n pub mod source_change;\n pub mod ty_filter;\n pub mod traits;"}, {"sha": "2c4c339cb73152f06db3bdefb6e5c53f3abd62fa", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c83e72b9b48177a6171fd06a26676679963a4d/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=33c83e72b9b48177a6171fd06a26676679963a4d", "patch": "@@ -697,7 +697,6 @@ pub(crate) fn handle_completion_resolve(\n             FilePosition { file_id, offset },\n             &resolve_data.full_import_path,\n             resolve_data.imported_name,\n-            resolve_data.import_for_trait_assoc_item,\n         )?\n         .into_iter()\n         .flat_map(|edit| edit.into_iter().map(|indel| to_proto::text_edit(&line_index, indel)))\n@@ -1525,7 +1524,6 @@ struct CompletionResolveData {\n     position: lsp_types::TextDocumentPositionParams,\n     full_import_path: String,\n     imported_name: String,\n-    import_for_trait_assoc_item: bool,\n }\n \n fn fill_resolve_data(\n@@ -1534,14 +1532,13 @@ fn fill_resolve_data(\n     position: &TextDocumentPositionParams,\n ) -> Option<()> {\n     let import_edit = item.import_to_add()?;\n-    let import_path = import_edit.import.import_path();\n+    let import_path = &import_edit.import.import_path;\n \n     *resolve_data = Some(\n         to_value(CompletionResolveData {\n             position: position.to_owned(),\n             full_import_path: import_path.to_string(),\n             imported_name: import_path.segments().last()?.to_string(),\n-            import_for_trait_assoc_item: import_edit.import_for_trait_assoc_item,\n         })\n         .unwrap(),\n     );"}]}