{"sha": "5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "node_id": "C_kwDOAAsO6NoAKDViYjFhOWZlYmNlMTNkYmU3ZWNlOWNkYjMyNDhiNTJjMWFjNDRjYzU", "commit": {"author": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-10-25T08:16:43Z"}, "committer": {"name": "kadmin", "email": "julianknodt@gmail.com", "date": "2022-11-25T09:28:43Z"}, "message": "Add expand_abstract_const\n\nAdds the ability to directly expand a const to an expr without having to deal with intermediate\nsteps.", "tree": {"sha": "7a7c8cd30dd83c745b3c253e0354acb76e6c2e8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a7c8cd30dd83c745b3c253e0354acb76e6c2e8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "html_url": "https://github.com/rust-lang/rust/commit/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/comments", "author": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JulianKnodt", "id": 7675847, "node_id": "MDQ6VXNlcjc2NzU4NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/7675847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JulianKnodt", "html_url": "https://github.com/JulianKnodt", "followers_url": "https://api.github.com/users/JulianKnodt/followers", "following_url": "https://api.github.com/users/JulianKnodt/following{/other_user}", "gists_url": "https://api.github.com/users/JulianKnodt/gists{/gist_id}", "starred_url": "https://api.github.com/users/JulianKnodt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JulianKnodt/subscriptions", "organizations_url": "https://api.github.com/users/JulianKnodt/orgs", "repos_url": "https://api.github.com/users/JulianKnodt/repos", "events_url": "https://api.github.com/users/JulianKnodt/events{/privacy}", "received_events_url": "https://api.github.com/users/JulianKnodt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9750c1554a355a3755a412581c57b230248f06d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9750c1554a355a3755a412581c57b230248f06d", "html_url": "https://github.com/rust-lang/rust/commit/f9750c1554a355a3755a412581c57b230248f06d"}], "stats": {"total": 294, "additions": 122, "deletions": 172}, "files": [{"sha": "e0b465bab16d9bb0f8790ab2c414a3a95f3d5fcc", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -193,18 +193,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n                 ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n-                /*\n-                ) => {\n-                    if let (Ok(Some(a)), Ok(Some(b))) = (\n-                        tcx.expand_bound_abstract_const(tcx.bound_abstract_const(a.def), a.substs),\n-                        tcx.expand_bound_abstract_const(tcx.bound_abstract_const(b.def), b.substs),\n-                    ) && a.ty() == b.ty() {\n-                        return relator.relate(a, b).is_ok();\n-                    } else {\n-                        false\n-                    }\n-                }\n-                */\n                 (\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),"}, {"sha": "8d01afa322e2eb484a2b2a93404e538ba054b029", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -1621,15 +1621,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         // variables\n         let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            let substs_erased = tcx.erase_regions(unevaluated.substs);\n-            let ac = tcx.expand_bound_abstract_const(\n-                tcx.bound_abstract_const(unevaluated.def),\n-                substs_erased,\n-            );\n+            let ac = tcx.expand_unevaluated_abstract_const(unevaluated.def, unevaluated.substs);\n             match ac {\n                 Ok(None) => {\n                     substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n-                    param_env = self.tcx.param_env(unevaluated.def.did);\n+                    param_env = tcx.param_env(unevaluated.def.did);\n                 }\n                 Ok(Some(ct)) => {\n                     if ct.has_non_region_infer() || ct.has_non_region_param() {"}, {"sha": "7c1029e6604c744e46768847bba20c07b9058a1a", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 60, "deletions": 49, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -1,5 +1,8 @@\n //! A subset of a mir body used for const evaluatability checking.\n-use crate::ty::{self, Const, EarlyBinder, FallibleTypeFolder, GenericArg, TyCtxt, TypeFoldable};\n+use crate::ty::{\n+    self, subst::SubstsRef, Const, EarlyBinder, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable,\n+    TypeSuperFoldable, TypeVisitable,\n+};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n \n@@ -33,71 +36,79 @@ pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>,\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a const with substs applied by\n-    pub fn bound_abstract_const(\n+    fn bound_abstract_const(self, uv: ty::WithOptConstParam<DefId>) -> BoundAbstractConst<'tcx> {\n+        let ac = if let Some((did, param_did)) = uv.as_const_arg() {\n+            self.thir_abstract_const_of_const_arg((did, param_did))\n+        } else {\n+            self.thir_abstract_const(uv.did)\n+        };\n+        Ok(ac?.map(|ac| EarlyBinder(ac)))\n+    }\n+\n+    pub fn expand_abstract_consts<T: TypeFoldable<'tcx>>(\n         self,\n-        uv: ty::WithOptConstParam<DefId>,\n-    ) -> BoundAbstractConst<'tcx> {\n-        self.thir_abstract_const_opt_const_arg(uv).map(|ac| ac.map(|ac| EarlyBinder(ac)))\n+        ac: T,\n+    ) -> Result<Option<T>, ErrorGuaranteed> {\n+        self._expand_abstract_consts(ac, true)\n     }\n-    #[inline]\n-    pub fn thir_abstract_const_opt_const_arg(\n+\n+    pub fn expand_unevaluated_abstract_const(\n         self,\n-        def: ty::WithOptConstParam<DefId>,\n+        did: ty::WithOptConstParam<DefId>,\n+        substs: SubstsRef<'tcx>,\n     ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n-            self.thir_abstract_const_of_const_arg((did, param_did))\n-        } else {\n-            self.thir_abstract_const(def.did)\n-        }\n+        let Some(ac) = self.bound_abstract_const(did)? else {\n+            return Ok(None);\n+        };\n+        let substs = self.erase_regions(substs);\n+        let ac = ac.subst(self, substs);\n+        self._expand_abstract_consts(ac, false)\n     }\n \n-    pub fn expand_bound_abstract_const(\n+    fn _expand_abstract_consts<T: TypeFoldable<'tcx>>(\n         self,\n-        ct: BoundAbstractConst<'tcx>,\n-        substs: &[GenericArg<'tcx>],\n-    ) -> Result<Option<Const<'tcx>>, ErrorGuaranteed> {\n+        ac: T,\n+        first: bool,\n+    ) -> Result<Option<T>, ErrorGuaranteed> {\n         struct Expander<'tcx> {\n             tcx: TyCtxt<'tcx>,\n+            first: bool,\n         }\n+\n         impl<'tcx> FallibleTypeFolder<'tcx> for Expander<'tcx> {\n-            type Error = ErrorGuaranteed;\n+            type Error = Option<ErrorGuaranteed>;\n             fn tcx(&self) -> TyCtxt<'tcx> {\n                 self.tcx\n             }\n-            fn try_fold_const(&mut self, c: Const<'tcx>) -> Result<Const<'tcx>, ErrorGuaranteed> {\n-                use ty::ConstKind::*;\n-                let uv = match c.kind() {\n-                    Unevaluated(uv) => uv,\n-                    Param(..) | Infer(..) | Bound(..) | Placeholder(..) | Value(..) | Error(..) => {\n-                        return Ok(c);\n-                    }\n-                    Expr(e) => {\n-                        let new_expr = match e {\n-                            ty::Expr::Binop(op, l, r) => {\n-                                ty::Expr::Binop(op, l.try_fold_with(self)?, r.try_fold_with(self)?)\n-                            }\n-                            ty::Expr::UnOp(op, v) => ty::Expr::UnOp(op, v.try_fold_with(self)?),\n-                            ty::Expr::Cast(k, c, t) => {\n-                                ty::Expr::Cast(k, c.try_fold_with(self)?, t.try_fold_with(self)?)\n-                            }\n-                            ty::Expr::FunctionCall(func, args) => ty::Expr::FunctionCall(\n-                                func.try_fold_with(self)?,\n-                                args.try_fold_with(self)?,\n-                            ),\n-                        };\n-                        return Ok(self.tcx().mk_const(ty::ConstKind::Expr(new_expr), c.ty()));\n+            fn try_fold_ty(&mut self, ty: Ty<'tcx>) -> Result<Ty<'tcx>, Self::Error> {\n+                if ty.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n+                    ty.try_super_fold_with(self)\n+                } else {\n+                    Ok(ty)\n+                }\n+            }\n+            fn try_fold_const(&mut self, c: Const<'tcx>) -> Result<Const<'tcx>, Self::Error> {\n+                let ct = match c.kind() {\n+                    ty::ConstKind::Unevaluated(uv) => {\n+                        if let Some(bac) = self.tcx.bound_abstract_const(uv.def)? {\n+                            let substs = self.tcx.erase_regions(uv.substs);\n+                            bac.subst(self.tcx, substs)\n+                        } else if self.first {\n+                            return Err(None);\n+                        } else {\n+                            c\n+                        }\n                     }\n+                    _ => c,\n                 };\n-                let bac = self.tcx.bound_abstract_const(uv.def);\n-                let ac = self.tcx.expand_bound_abstract_const(bac, uv.substs);\n-                if let Ok(Some(ac)) = ac { ac.try_fold_with(self) } else { Ok(c) }\n+                self.first = false;\n+                ct.try_super_fold_with(self)\n             }\n         }\n-\n-        let Some(ac) = ct? else {\n-            return Ok(None);\n-        };\n-        let ac = ac.subst(self, substs);\n-        Ok(Some(ac.try_fold_with(&mut Expander { tcx: self })?))\n+        match ac.try_fold_with(&mut Expander { tcx: self, first }) {\n+            Ok(c) => Ok(Some(c)),\n+            Err(None) => Ok(None),\n+            Err(Some(e)) => Err(e),\n+        }\n     }\n }"}, {"sha": "84eeb81f1dbe91d5942f2aa3258002fd3c9f8299", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -626,7 +626,7 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     // an unnormalized (i.e. unevaluated) const in the param-env.\n     // FIXME(generic_const_exprs): Once we always lazily unify unevaluated constants\n     // these `eval` calls can be removed.\n-    if !relation.tcx().features().generic_const_exprs {\n+    if !tcx.features().generic_const_exprs {\n         a = a.eval(tcx, relation.param_env());\n         b = b.eval(tcx, relation.param_env());\n     }\n@@ -647,12 +647,12 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,\n         (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n \n-        (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n+        (ty::ConstKind::Unevaluated(_au), ty::ConstKind::Unevaluated(_bu))\n             if tcx.features().generic_const_exprs =>\n         {\n             if let (Ok(Some(a)), Ok(Some(b))) = (\n-                tcx.expand_bound_abstract_const(tcx.bound_abstract_const(au.def), au.substs),\n-                tcx.expand_bound_abstract_const(tcx.bound_abstract_const(bu.def), bu.substs),\n+                tcx.expand_abstract_consts(a),\n+                tcx.expand_abstract_consts(b),\n             ) && a.ty() == b.ty() {\n                 return relation.consts(a, b);\n             } else {"}, {"sha": "f8e99006923e65d3631f23365b555f42b52e1bdc", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -287,12 +287,8 @@ where\n         self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n         if let ty::ConstKind::Unevaluated(uv) = c.kind() &&\n-           let Ok(Some(ct)) = tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def),\n-           uv.substs) {\n-            ct.visit_with(self)?;\n-        }\n-        if let ty::ConstKind::Expr(e) = c.kind() {\n-            e.visit_with(self)?;\n+           let Ok(Some(ct)) = tcx.expand_unevaluated_abstract_const(uv.def, uv.substs) {\n+            ct.super_visit_with(self)?;\n         }\n         ControlFlow::CONTINUE\n     }"}, {"sha": "bf7396d6113f168aff12a53b2a4c7bc56039bee5", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -29,8 +29,7 @@ pub fn is_const_evaluatable<'tcx>(\n     let tcx = infcx.tcx;\n     let uv = match ct.kind() {\n         ty::ConstKind::Unevaluated(uv) => uv,\n-        // should be recursivee fixes.\n-        ty::ConstKind::Expr(..) => todo!(),\n+        ty::ConstKind::Expr(_) => bug!(\"unexpected expr in `is_const_evaluatable: {ct:?}\"),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)\n         | ty::ConstKind::Placeholder(_)\n@@ -40,10 +39,7 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        let substs = tcx.erase_regions(uv.substs);\n-        if let Some(ct) =\n-            tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def), substs)?\n-        {\n+        if let Some(ct) = tcx.expand_abstract_consts(ct)? {\n             if satisfied_from_param_env(tcx, infcx, ct, param_env)? {\n                 return Ok(());\n             }\n@@ -74,17 +70,13 @@ pub fn is_const_evaluatable<'tcx>(\n         //\n         // See #74595 for more details about this.\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n-\n-        let substs = tcx.erase_regions(uv.substs);\n         match concrete {\n-          // If we're evaluating a foreign constant, under a nightly compiler without generic\n-          // const exprs, AND it would've passed if that expression had been evaluated with\n-          // generic const exprs, then suggest using generic const exprs.\n+          // If we're evaluating a generic foreign constant, under a nightly compiler while\n+          // the current crate does not enable `feature(generic_const_exprs)`, abort\n+          // compilation with a useful error.\n           Err(_) if tcx.sess.is_nightly_build()\n-            && let Ok(Some(ct)) =\n-            tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def), substs)\n-            && let ty::ConstKind::Expr(_expr) = ct.kind()\n-            && satisfied_from_param_env(tcx, infcx, ct, param_env) == Ok(true) => {\n+            && let Ok(Some(ac)) = tcx.expand_abstract_consts(ct)\n+            && let ty::ConstKind::Expr(_) = ac.kind() => {\n               tcx.sess\n                   .struct_span_fatal(\n                       // Slightly better span than just using `span` alone\n@@ -126,46 +118,43 @@ fn satisfied_from_param_env<'tcx>(\n     ct: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> Result<bool, NotConstEvaluatable> {\n+    // Try to unify with each subtree in the AbstractConst to allow for\n+    // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n+    // predicate for `(N + 1) * 2`\n+    struct Visitor<'a, 'tcx> {\n+        ct: ty::Const<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+\n+        infcx: &'a InferCtxt<'tcx>,\n+    }\n+    impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n+        type BreakTy = ();\n+        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if c.ty() == self.ct.ty()\n+                && let Ok(_nested_obligations) = self\n+                    .infcx\n+                    .at(&ObligationCause::dummy(), self.param_env)\n+                    .eq(c, self.ct)\n+            {\n+                ControlFlow::BREAK\n+            } else if let ty::ConstKind::Expr(e) = c.kind() {\n+                e.visit_with(self)\n+            } else {\n+                ControlFlow::CONTINUE\n+            }\n+        }\n+    }\n+\n     for pred in param_env.caller_bounds() {\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n-                let ty::ConstKind::Unevaluated(uv) = uv.kind() else {\n+            ty::PredicateKind::ConstEvaluatable(ce) => {\n+                let ty::ConstKind::Unevaluated(_) = ce.kind() else {\n                     continue\n                 };\n-                let substs = tcx.erase_regions(uv.substs);\n-                let Some(b_ct) =\n-                tcx.expand_bound_abstract_const(tcx.bound_abstract_const(uv.def), substs)? else {\n-                    return Ok(false);\n+                let Some(b_ct) = tcx.expand_abstract_consts(ce)? else {\n+                    continue\n                 };\n \n-                // Try to unify with each subtree in the AbstractConst to allow for\n-                // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n-                // predicate for `(N + 1) * 2`\n-                struct Visitor<'a, 'tcx> {\n-                    ct: ty::Const<'tcx>,\n-                    param_env: ty::ParamEnv<'tcx>,\n-\n-                    infcx: &'a InferCtxt<'tcx>,\n-                }\n-                impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n-                    type BreakTy = ();\n-                    fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                        if c.ty() == self.ct.ty()\n-                            && let Ok(_nested_obligations) = self\n-                                .infcx\n-                                .at(&ObligationCause::dummy(), self.param_env)\n-                                .eq(c, self.ct)\n-                        {\n-                            //let obligations = nested_obligations.into_obligations();\n-                            ControlFlow::BREAK\n-                        } else if let ty::ConstKind::Expr(e) = c.kind() {\n-                            e.visit_with(self)\n-                        } else {\n-                            ControlFlow::CONTINUE\n-                        }\n-                    }\n-                }\n-\n                 let mut v = Visitor { ct, infcx, param_env };\n                 let result = b_ct.visit_with(&mut v);\n "}, {"sha": "9f4423605ab89c1fae9e15e8ad5c622940dfc4cb", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -478,14 +478,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                                 );\n                             }\n                             if let (Ok(Some(a)), Ok(Some(b))) = (\n-                                    tcx.expand_bound_abstract_const(\n-                                        tcx.bound_abstract_const(a.def),\n-                                        a.substs,\n-                                    ),\n-                                    tcx.expand_bound_abstract_const(\n-                                        tcx.bound_abstract_const(b.def),\n-                                        b.substs,\n-                                    ),\n+                                    tcx.expand_abstract_consts(c1),\n+                                    tcx.expand_abstract_consts(c2),\n                                 ) && a.ty() == b.ty() &&\n                                   let Ok(new_obligations) = infcx\n                                       .at(&obligation.cause, obligation.param_env)\n@@ -534,7 +528,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n-                                Ok(_) => ProcessResult::Changed(vec![]),\n+                                Ok(inf_ok) => {\n+                                    ProcessResult::Changed(mk_pending(inf_ok.into_obligations()))\n+                                }\n                                 Err(err) => ProcessResult::Error(\n                                     FulfillmentErrorCode::CodeConstEquateError(\n                                         ExpectedFound::new(true, c1, c2),"}, {"sha": "0ea126fa9c99ef6c6f545c44bcc68a69256f6a05", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -849,11 +849,8 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n             //\n             // This shouldn't really matter though as we can't really use any\n             // constants which are not considered const evaluatable.\n-            if let ty::ConstKind::Unevaluated(uv) = ct.kind() &&\n-                let Ok(Some(ct)) = self\n-                .tcx\n-                .expand_bound_abstract_const(self.tcx.bound_abstract_const(uv.def), uv.substs)\n-            {\n+            if let ty::ConstKind::Unevaluated(_uv) = ct.kind() &&\n+                let Ok(Some(ct)) = self.tcx.expand_abstract_consts(ct){\n                 self.visit_const(ct)\n             } else {\n                 ct.super_visit_with(self)"}, {"sha": "98b227940ffa0f0253f3a5a6828465fa30dd8de5", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -668,19 +668,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // if the constants depend on generic parameters.\n                     //\n                     // Let's just see where this breaks :shrug:\n-                    if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n+                    if let (ty::ConstKind::Unevaluated(_), ty::ConstKind::Unevaluated(_)) =\n                         (c1.kind(), c2.kind())\n                     {\n                         if let (Ok(Some(a)), Ok(Some(b))) = (\n-                                tcx.expand_bound_abstract_const(\n-                                    tcx.bound_abstract_const(a.def),\n-                                    a.substs,\n-                                ),\n-                                tcx.expand_bound_abstract_const(\n-                                    tcx.bound_abstract_const(b.def),\n-                                    b.substs,\n-                                ),\n-                            ) && a.ty() == b.ty() && let Ok(new_obligations) =\n+                          tcx.expand_abstract_consts(c1),\n+                          tcx.expand_abstract_consts(c2),\n+                        ) && a.ty() == b.ty() && let Ok(new_obligations) =\n                                     self.infcx.at(&obligation.cause, obligation.param_env).eq(a, b)\n                                 {\n                                     let mut obligations = new_obligations.obligations;\n@@ -718,7 +712,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n-                                Ok(_) => Ok(EvaluatedToOk),\n+                                Ok(inf_ok) => self.evaluate_predicates_recursively(\n+                                    previous_stack,\n+                                    inf_ok.into_obligations(),\n+                                ),\n                                 Err(_) => Ok(EvaluatedToErr),\n                             }\n                         }"}, {"sha": "674efa723cfac28bd757e5253bad3c3e51181723", "filename": "src/test/ui/const-generics/issues/issue-83765.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.rs?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -120,8 +120,6 @@ fn main() {\n     let v = vec![1, 2, 3];\n     let bv = v.lazy_updim([3, 4]);\n     let bbv = bv.bmap(|x| x * x);\n-    //~^ ERROR mismatched types\n \n     println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n-    //~^ ERROR mismatched types\n }"}, {"sha": "3cf1aab3a8bf31685512e496dec4ff73df5769a4", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=5bb1a9febce13dbe7ece9cdb3248b52c1ac44cc5", "patch": "@@ -98,25 +98,7 @@ LL |         self.reference.bget(index).map(&self.closure)\n    = note: expected constant `Self::DIM`\n               found constant `DIM`\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:122:15\n-   |\n-LL |     let bbv = bv.bmap(|x| x * x);\n-   |               ^^^^^^^^^^^^^^^^^^ expected `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`, found `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n-   |\n-   = note: expected constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n-              found constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n-\n-error[E0308]: mismatched types\n-  --> $DIR/issue-83765.rs:125:43\n-   |\n-LL |     println!(\"The size of v is {:?}\", bbv.bget([0, 2]).expect(\"Out of bounds.\"));\n-   |                                           ^^^^ expected `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`, found `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n-   |\n-   = note: expected constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n-              found constant `<LazyUpdim<'_, Vec<{integer}>, { Self::DIM }, 2> as TensorDimension>::DIM`\n-\n-error: aborting due to 12 previous errors\n+error: aborting due to 10 previous errors\n \n Some errors have detailed explanations: E0277, E0308.\n For more information about an error, try `rustc --explain E0277`."}]}