{"sha": "a373e73f5a9e4db97e69875ff787dfa4de9958d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNzNlNzNmNWE5ZTRkYjk3ZTY5ODc1ZmY3ODdkZmE0ZGU5OTU4ZDc=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-03-25T11:33:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-25T11:33:25Z"}, "message": "Merge pull request #3469 from topecongiro/cargo-fmt\n\nFix cargo fmt inconsistency", "tree": {"sha": "d6c11c8e198c0cf08aec1cfa1d047c8fcdb61c9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c11c8e198c0cf08aec1cfa1d047c8fcdb61c9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a373e73f5a9e4db97e69875ff787dfa4de9958d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcmLyFCRBK7hj4Ov3rIwAAdHIIAF1vqKM1LFp8sCAEzIgTOqwx\n1uJ30iouDNJ+/sVR0s04JfjRxDcXb1h3o130VO+lbO6/bvJe1nns95R89RiPwXwY\n6291qnMz0db1kgsDU6di2vsaOMDCx8RrG4OLjuXt9wTSAjVH+3tQ1/TNgg1XfLXU\n/uqe9sEUWKDZ++YKDrhNls7fW7c9/VS58JyMgDYYsjMdIxZS/JgGLaWpfH6cKw9V\nDXs+PziNy5tc0SJePI7wJ+zXYcPmassnz1hYOyzdHaEjVvXD+PvzoOc3+NqJti8R\nPkn0te80WnWGuL9VMMQRocnmj8cASmHrzWvEYWbvpE78TPnpL1BNzFd8YlPvWbg=\n=7wun\n-----END PGP SIGNATURE-----\n", "payload": "tree d6c11c8e198c0cf08aec1cfa1d047c8fcdb61c9f\nparent f910afde8568f3bf62bc2009ab53a5b2763ba049\nparent b4d4b5795ef9229f24f838592c4c915a7f4086bc\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1553513605 +0100\ncommitter GitHub <noreply@github.com> 1553513605 +0100\n\nMerge pull request #3469 from topecongiro/cargo-fmt\n\nFix cargo fmt inconsistency"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a373e73f5a9e4db97e69875ff787dfa4de9958d7", "html_url": "https://github.com/rust-lang/rust/commit/a373e73f5a9e4db97e69875ff787dfa4de9958d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a373e73f5a9e4db97e69875ff787dfa4de9958d7/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f910afde8568f3bf62bc2009ab53a5b2763ba049", "url": "https://api.github.com/repos/rust-lang/rust/commits/f910afde8568f3bf62bc2009ab53a5b2763ba049", "html_url": "https://github.com/rust-lang/rust/commit/f910afde8568f3bf62bc2009ab53a5b2763ba049"}, {"sha": "b4d4b5795ef9229f24f838592c4c915a7f4086bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d4b5795ef9229f24f838592c4c915a7f4086bc", "html_url": "https://github.com/rust-lang/rust/commit/b4d4b5795ef9229f24f838592c4c915a7f4086bc"}], "stats": {"total": 62, "additions": 36, "deletions": 26}, "files": [{"sha": "a686e91b6947ced8501523d038ff75e07c7e2181", "filename": "src/cargo-fmt/main.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a373e73f5a9e4db97e69875ff787dfa4de9958d7/src%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a373e73f5a9e4db97e69875ff787dfa4de9958d7/src%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo-fmt%2Fmain.rs?ref=a373e73f5a9e4db97e69875ff787dfa4de9958d7", "patch": "@@ -6,7 +6,8 @@\n use cargo_metadata;\n use getopts;\n \n-use std::collections::{HashMap, HashSet};\n+use std::cmp::Ordering;\n+use std::collections::{BTreeMap, BTreeSet};\n use std::env;\n use std::fs;\n use std::hash::{Hash, Hasher};\n@@ -122,7 +123,7 @@ fn handle_command_status(status: Result<i32, io::Error>, opts: &getopts::Options\n }\n \n fn get_version(verbosity: Verbosity) -> Result<i32, io::Error> {\n-    run_rustfmt(&HashSet::new(), &[String::from(\"--version\")], verbosity)\n+    run_rustfmt(&BTreeSet::new(), &[String::from(\"--version\")], verbosity)\n }\n \n fn format_crate(verbosity: Verbosity, strategy: &CargoFmtStrategy) -> Result<i32, io::Error> {\n@@ -131,7 +132,7 @@ fn format_crate(verbosity: Verbosity, strategy: &CargoFmtStrategy) -> Result<i32\n         .iter()\n         .any(|s| [\"--print-config\", \"-h\", \"--help\", \"-V\", \"--version\"].contains(&s.as_str()))\n     {\n-        HashSet::new()\n+        BTreeSet::new()\n     } else {\n         get_targets(strategy)?\n     };\n@@ -175,6 +176,18 @@ impl PartialEq for Target {\n     }\n }\n \n+impl PartialOrd for Target {\n+    fn partial_cmp(&self, other: &Target) -> Option<Ordering> {\n+        Some(self.path.cmp(&other.path))\n+    }\n+}\n+\n+impl Ord for Target {\n+    fn cmp(&self, other: &Target) -> Ordering {\n+        self.path.cmp(&other.path)\n+    }\n+}\n+\n impl Eq for Target {}\n \n impl Hash for Target {\n@@ -204,12 +217,12 @@ impl CargoFmtStrategy {\n }\n \n /// Based on the specified `CargoFmtStrategy`, returns a set of main source files.\n-fn get_targets(strategy: &CargoFmtStrategy) -> Result<HashSet<Target>, io::Error> {\n-    let mut targets = HashSet::new();\n+fn get_targets(strategy: &CargoFmtStrategy) -> Result<BTreeSet<Target>, io::Error> {\n+    let mut targets = BTreeSet::new();\n \n     match *strategy {\n         CargoFmtStrategy::Root => get_targets_root_only(&mut targets)?,\n-        CargoFmtStrategy::All => get_targets_recursive(None, &mut targets, &mut HashSet::new())?,\n+        CargoFmtStrategy::All => get_targets_recursive(None, &mut targets, &mut BTreeSet::new())?,\n         CargoFmtStrategy::Some(ref hitlist) => get_targets_with_hitlist(hitlist, &mut targets)?,\n     }\n \n@@ -223,7 +236,7 @@ fn get_targets(strategy: &CargoFmtStrategy) -> Result<HashSet<Target>, io::Error\n     }\n }\n \n-fn get_targets_root_only(targets: &mut HashSet<Target>) -> Result<(), io::Error> {\n+fn get_targets_root_only(targets: &mut BTreeSet<Target>) -> Result<(), io::Error> {\n     let metadata = get_cargo_metadata(None)?;\n     let current_dir = env::current_dir()?.canonicalize()?;\n     let current_dir_manifest = current_dir.join(\"Cargo.toml\");\n@@ -243,8 +256,8 @@ fn get_targets_root_only(targets: &mut HashSet<Target>) -> Result<(), io::Error>\n \n fn get_targets_recursive(\n     manifest_path: Option<&Path>,\n-    mut targets: &mut HashSet<Target>,\n-    visited: &mut HashSet<String>,\n+    mut targets: &mut BTreeSet<Target>,\n+    visited: &mut BTreeSet<String>,\n ) -> Result<(), io::Error> {\n     let metadata = get_cargo_metadata(manifest_path)?;\n \n@@ -275,11 +288,11 @@ fn get_targets_recursive(\n \n fn get_targets_with_hitlist(\n     hitlist: &[String],\n-    targets: &mut HashSet<Target>,\n+    targets: &mut BTreeSet<Target>,\n ) -> Result<(), io::Error> {\n     let metadata = get_cargo_metadata(None)?;\n \n-    let mut workspace_hitlist: HashSet<&String> = HashSet::from_iter(hitlist);\n+    let mut workspace_hitlist: BTreeSet<&String> = BTreeSet::from_iter(hitlist);\n \n     for package in metadata.packages {\n         if workspace_hitlist.remove(&package.name) {\n@@ -300,34 +313,30 @@ fn get_targets_with_hitlist(\n     }\n }\n \n-fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut HashSet<Target>) {\n+fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut BTreeSet<Target>) {\n     for target in target_paths {\n         targets.insert(Target::from_target(target));\n     }\n }\n \n fn run_rustfmt(\n-    targets: &HashSet<Target>,\n+    targets: &BTreeSet<Target>,\n     fmt_args: &[String],\n     verbosity: Verbosity,\n ) -> Result<i32, io::Error> {\n-    let default_edition = String::from(\"2015\");\n-    let mut by_edition = targets\n+    let by_edition = targets\n         .iter()\n         .inspect(|t| {\n             if verbosity == Verbosity::Verbose {\n                 println!(\"[{} ({})] {:?}\", t.kind, t.edition, t.path)\n             }\n         })\n-        .map(|t| (&t.edition, &t.path))\n-        .fold(HashMap::new(), |mut h, t| {\n-            h.entry(t.0).or_insert_with(Vec::new).push(t.1);\n+        .fold(BTreeMap::new(), |mut h, t| {\n+            h.entry(&t.edition).or_insert_with(Vec::new).push(&t.path);\n             h\n         });\n-    if by_edition.is_empty() {\n-        by_edition.insert(&default_edition, Vec::new());\n-    }\n \n+    let mut status = vec![];\n     for (edition, files) in by_edition {\n         let stdout = if verbosity == Verbosity::Quiet {\n             std::process::Stdio::null()\n@@ -357,13 +366,14 @@ fn run_rustfmt(\n                 _ => e,\n             })?;\n \n-        let status = command.wait()?;\n-        if !status.success() {\n-            return Ok(status.code().unwrap_or(FAILURE));\n-        }\n+        status.push(command.wait()?);\n     }\n \n-    Ok(SUCCESS)\n+    Ok(status\n+        .iter()\n+        .filter_map(|s| if s.success() { None } else { s.code() })\n+        .next()\n+        .unwrap_or(SUCCESS))\n }\n \n fn get_cargo_metadata(manifest_path: Option<&Path>) -> Result<cargo_metadata::Metadata, io::Error> {"}]}