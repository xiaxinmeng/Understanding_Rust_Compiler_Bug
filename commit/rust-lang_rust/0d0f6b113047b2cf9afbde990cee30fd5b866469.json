{"sha": "0d0f6b113047b2cf9afbde990cee30fd5b866469", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkMGY2YjExMzA0N2IyY2Y5YWZiZGU5OTBjZWUzMGZkNWI4NjY0Njk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-03T21:20:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-03T21:20:21Z"}, "message": "Auto merge of #70793 - the8472:in-place-iter-collect, r=Amanieu\n\nspecialize some collection and iterator operations to run in-place\n\nThis is a rebase and update of #66383 which was closed due inactivity.\n\nRecent rustc changes made the compile time regressions disappear, at least for webrender-wrench. Running a stage2 compile and the rustc-perf suite takes hours on the hardware I have at the moment, so I can't do much more than that.\n\n![Screenshot_2020-04-05 rustc performance data](https://user-images.githubusercontent.com/1065730/78462657-5d60f100-76d4-11ea-8a0b-4f3962707c38.png)\n\nIn the best case of the `vec::bench_in_place_recycle` synthetic microbenchmark these optimizations can provide a 15x speedup over the regular implementation which allocates a new vec for every benchmark iteration. [Benchmark results](https://gist.github.com/the8472/6d999b2d08a2bedf3b93f12112f96e2f). In real code the speedups are tiny, but it also depends on the allocator used, a system allocator that uses a process-wide mutex will benefit more than one with thread-local pools.\n\n## What was changed\n\n* `SpecExtend` which covered `from_iter` and `extend` specializations was split into separate traits\n* `extend` and `from_iter` now reuse the `append_elements` if passed iterators are from slices.\n* A preexisting `vec.into_iter().collect::<Vec<_>>()` optimization that passed through the original vec has been generalized further to also cover cases where the original has been partially drained.\n* A chain of *Vec<T> / BinaryHeap<T> / Box<[T]>* `IntoIter`s  through various iterator adapters collected into *Vec<U>* and *BinaryHeap<U>* will be performed in place as long as `T` and `U` have the same alignment and size and aren't ZSTs.\n* To enable above specialization the unsafe, unstable `SourceIter` and `InPlaceIterable` traits have been added. The first allows reaching through the iterator pipeline to grab a pointer to the source memory. The latter is a marker that promises that the read pointer will advance as fast or faster than the write pointer and thus in-place operation is possible in the first place.\n* `vec::IntoIter` implements `TrustedRandomAccess` for `T: Copy` to allow in-place collection when there is a `Zip` adapter in the iterator. TRA had to be made an unstable public trait to support this.\n\n## In-place collectible adapters\n\n* `Map`\n* `MapWhile`\n* `Filter`\n* `FilterMap`\n* `Fuse`\n* `Skip`\n* `SkipWhile`\n* `Take`\n* `TakeWhile`\n* `Enumerate`\n* `Zip` (left hand side only, `Copy` types only)\n* `Peek`\n* `Scan`\n* `Inspect`\n\n## Concerns\n\n`vec.into_iter().filter(|_| false).collect()` will no longer return a vec with 0 capacity, instead it will return its original allocation. This avoids the cost of doing any allocation or deallocation but could lead to large allocations living longer than expected.\nIf that's not acceptable some resizing policy at the end of the attempted in-place collect would be necessary, which in the worst case could result in one more memcopy than the non-specialized case.\n\n## Possible followup work\n\n* split liballoc/vec.rs to remove `ignore-tidy-filelength`\n* try to get trivial chains such as `vec.into_iter().skip(1).collect::<Vec<)>>()` to compile to a `memmove` (currently compiles to a pile of SIMD, see #69187 )\n* improve up the traits so they can be reused by other crates, e.g. itertools. I think currently they're only good enough for internal use\n* allow iterators sourced from a `HashSet` to be in-place collected into a `Vec`", "tree": {"sha": "2acd3b19b461e2a64162ed81fc027b33072df6a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2acd3b19b461e2a64162ed81fc027b33072df6a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d0f6b113047b2cf9afbde990cee30fd5b866469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0f6b113047b2cf9afbde990cee30fd5b866469", "html_url": "https://github.com/rust-lang/rust/commit/0d0f6b113047b2cf9afbde990cee30fd5b866469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d0f6b113047b2cf9afbde990cee30fd5b866469/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62dad457bc73804891c6ac9a31f90de19cbb59a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/62dad457bc73804891c6ac9a31f90de19cbb59a3", "html_url": "https://github.com/rust-lang/rust/commit/62dad457bc73804891c6ac9a31f90de19cbb59a3"}, {"sha": "2f23a0fccad2f4d85d2ec923f0ac40b4b42211a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f23a0fccad2f4d85d2ec923f0ac40b4b42211a8", "html_url": "https://github.com/rust-lang/rust/commit/2f23a0fccad2f4d85d2ec923f0ac40b4b42211a8"}], "stats": {"total": 1127, "additions": 1078, "deletions": 49}, "files": [{"sha": "5ba3e0e00572c052f509c3e155e42dd1ca63a48f", "filename": "library/alloc/benches/vec.rs", "status": "modified", "additions": 243, "deletions": 2, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fbenches%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fbenches%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -1,12 +1,14 @@\n+use rand::prelude::*;\n use std::iter::{repeat, FromIterator};\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {\n     b.iter(|| {\n         let v: Vec<u32> = Vec::new();\n         assert_eq!(v.len(), 0);\n         assert_eq!(v.capacity(), 0);\n+        v\n     })\n }\n \n@@ -17,6 +19,7 @@ fn do_bench_with_capacity(b: &mut Bencher, src_len: usize) {\n         let v: Vec<u32> = Vec::with_capacity(src_len);\n         assert_eq!(v.len(), 0);\n         assert_eq!(v.capacity(), src_len);\n+        v\n     })\n }\n \n@@ -47,6 +50,7 @@ fn do_bench_from_fn(b: &mut Bencher, src_len: usize) {\n         let dst = (0..src_len).collect::<Vec<_>>();\n         assert_eq!(dst.len(), src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        dst\n     })\n }\n \n@@ -77,6 +81,7 @@ fn do_bench_from_elem(b: &mut Bencher, src_len: usize) {\n         let dst: Vec<usize> = repeat(5).take(src_len).collect();\n         assert_eq!(dst.len(), src_len);\n         assert!(dst.iter().all(|x| *x == 5));\n+        dst\n     })\n }\n \n@@ -109,6 +114,7 @@ fn do_bench_from_slice(b: &mut Bencher, src_len: usize) {\n         let dst = src.clone()[..].to_vec();\n         assert_eq!(dst.len(), src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        dst\n     });\n }\n \n@@ -141,6 +147,7 @@ fn do_bench_from_iter(b: &mut Bencher, src_len: usize) {\n         let dst: Vec<_> = FromIterator::from_iter(src.clone());\n         assert_eq!(dst.len(), src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        dst\n     });\n }\n \n@@ -175,6 +182,7 @@ fn do_bench_extend(b: &mut Bencher, dst_len: usize, src_len: usize) {\n         dst.extend(src.clone());\n         assert_eq!(dst.len(), dst_len + src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        dst\n     });\n }\n \n@@ -224,9 +232,24 @@ fn do_bench_extend_from_slice(b: &mut Bencher, dst_len: usize, src_len: usize) {\n         dst.extend_from_slice(&src);\n         assert_eq!(dst.len(), dst_len + src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        dst\n     });\n }\n \n+#[bench]\n+fn bench_extend_recycle(b: &mut Bencher) {\n+    let mut data = vec![0; 1000];\n+\n+    b.iter(|| {\n+        let tmp = std::mem::replace(&mut data, Vec::new());\n+        let mut to_extend = black_box(Vec::new());\n+        to_extend.extend(tmp.into_iter());\n+        data = black_box(to_extend);\n+    });\n+\n+    black_box(data);\n+}\n+\n #[bench]\n fn bench_extend_from_slice_0000_0000(b: &mut Bencher) {\n     do_bench_extend_from_slice(b, 0, 0)\n@@ -271,6 +294,7 @@ fn do_bench_clone(b: &mut Bencher, src_len: usize) {\n         let dst = src.clone();\n         assert_eq!(dst.len(), src_len);\n         assert!(dst.iter().enumerate().all(|(i, x)| i == *x));\n+        dst\n     });\n }\n \n@@ -305,10 +329,10 @@ fn do_bench_clone_from(b: &mut Bencher, times: usize, dst_len: usize, src_len: u\n \n         for _ in 0..times {\n             dst.clone_from(&src);\n-\n             assert_eq!(dst.len(), src_len);\n             assert!(dst.iter().enumerate().all(|(i, x)| dst_len + i == *x));\n         }\n+        dst\n     });\n }\n \n@@ -431,3 +455,220 @@ fn bench_clone_from_10_0100_0010(b: &mut Bencher) {\n fn bench_clone_from_10_1000_0100(b: &mut Bencher) {\n     do_bench_clone_from(b, 10, 1000, 100)\n }\n+\n+macro_rules! bench_in_place {\n+    (\n+        $($fname:ident, $type:ty , $count:expr, $init: expr);*\n+    ) => {\n+        $(\n+            #[bench]\n+            fn $fname(b: &mut Bencher) {\n+                b.iter(|| {\n+                    let src: Vec<$type> = black_box(vec![$init; $count]);\n+                    let mut sink = src.into_iter()\n+                        .enumerate()\n+                        .map(|(idx, e)| { (idx as $type) ^ e }).collect::<Vec<$type>>();\n+                    black_box(sink.as_mut_ptr())\n+                });\n+            }\n+        )+\n+    };\n+}\n+\n+bench_in_place![\n+    bench_in_place_xxu8_i0_0010,     u8,     10, 0;\n+    bench_in_place_xxu8_i0_0100,     u8,    100, 0;\n+    bench_in_place_xxu8_i0_1000,     u8,   1000, 0;\n+    bench_in_place_xxu8_i1_0010,     u8,     10, 1;\n+    bench_in_place_xxu8_i1_0100,     u8,    100, 1;\n+    bench_in_place_xxu8_i1_1000,     u8,   1000, 1;\n+    bench_in_place_xu32_i0_0010,    u32,     10, 0;\n+    bench_in_place_xu32_i0_0100,    u32,    100, 0;\n+    bench_in_place_xu32_i0_1000,    u32,   1000, 0;\n+    bench_in_place_xu32_i1_0010,    u32,     10, 1;\n+    bench_in_place_xu32_i1_0100,    u32,    100, 1;\n+    bench_in_place_xu32_i1_1000,    u32,   1000, 1;\n+    bench_in_place_u128_i0_0010,   u128,     10, 0;\n+    bench_in_place_u128_i0_0100,   u128,    100, 0;\n+    bench_in_place_u128_i0_1000,   u128,   1000, 0;\n+    bench_in_place_u128_i1_0010,   u128,     10, 1;\n+    bench_in_place_u128_i1_0100,   u128,    100, 1;\n+    bench_in_place_u128_i1_1000,   u128,   1000, 1\n+];\n+\n+#[bench]\n+fn bench_in_place_recycle(b: &mut test::Bencher) {\n+    let mut data = vec![0; 1000];\n+\n+    b.iter(|| {\n+        let tmp = std::mem::replace(&mut data, Vec::new());\n+        data = black_box(\n+            tmp.into_iter()\n+                .enumerate()\n+                .map(|(idx, e)| idx.wrapping_add(e))\n+                .fuse()\n+                .peekable()\n+                .collect::<Vec<usize>>(),\n+        );\n+    });\n+}\n+\n+#[bench]\n+fn bench_in_place_zip_recycle(b: &mut test::Bencher) {\n+    let mut data = vec![0u8; 1000];\n+    let mut rng = rand::thread_rng();\n+    let mut subst = vec![0u8; 1000];\n+    rng.fill_bytes(&mut subst[..]);\n+\n+    b.iter(|| {\n+        let tmp = std::mem::replace(&mut data, Vec::new());\n+        let mangled = tmp\n+            .into_iter()\n+            .zip(subst.iter().copied())\n+            .enumerate()\n+            .map(|(i, (d, s))| d.wrapping_add(i as u8) ^ s)\n+            .collect::<Vec<_>>();\n+        assert_eq!(mangled.len(), 1000);\n+        data = black_box(mangled);\n+    });\n+}\n+\n+#[bench]\n+fn bench_in_place_zip_iter_mut(b: &mut test::Bencher) {\n+    let mut data = vec![0u8; 256];\n+    let mut rng = rand::thread_rng();\n+    let mut subst = vec![0u8; 1000];\n+    rng.fill_bytes(&mut subst[..]);\n+\n+    b.iter(|| {\n+        data.iter_mut().enumerate().for_each(|(i, d)| {\n+            *d = d.wrapping_add(i as u8) ^ subst[i];\n+        });\n+    });\n+\n+    black_box(data);\n+}\n+\n+#[derive(Clone)]\n+struct Droppable(usize);\n+\n+impl Drop for Droppable {\n+    fn drop(&mut self) {\n+        black_box(self);\n+    }\n+}\n+\n+#[bench]\n+fn bench_in_place_collect_droppable(b: &mut test::Bencher) {\n+    let v: Vec<Droppable> = std::iter::repeat_with(|| Droppable(0)).take(1000).collect();\n+    b.iter(|| {\n+        v.clone()\n+            .into_iter()\n+            .skip(100)\n+            .enumerate()\n+            .map(|(i, e)| Droppable(i ^ e.0))\n+            .collect::<Vec<_>>()\n+    })\n+}\n+\n+#[bench]\n+fn bench_chain_collect(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| data.iter().cloned().chain([1].iter().cloned()).collect::<Vec<_>>());\n+}\n+\n+#[bench]\n+fn bench_chain_chain_collect(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| {\n+        data.iter()\n+            .cloned()\n+            .chain([1].iter().cloned())\n+            .chain([2].iter().cloned())\n+            .collect::<Vec<_>>()\n+    });\n+}\n+\n+#[bench]\n+fn bench_nest_chain_chain_collect(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| {\n+        data.iter().cloned().chain([1].iter().chain([2].iter()).cloned()).collect::<Vec<_>>()\n+    });\n+}\n+\n+pub fn example_plain_slow(l: &[u32]) -> Vec<u32> {\n+    let mut result = Vec::with_capacity(l.len());\n+    result.extend(l.iter().rev());\n+    result\n+}\n+\n+pub fn map_fast(l: &[(u32, u32)]) -> Vec<u32> {\n+    let mut result = Vec::with_capacity(l.len());\n+    for i in 0..l.len() {\n+        unsafe {\n+            *result.get_unchecked_mut(i) = l[i].0;\n+            result.set_len(i);\n+        }\n+    }\n+    result\n+}\n+\n+const LEN: usize = 16384;\n+\n+#[bench]\n+fn bench_range_map_collect(b: &mut test::Bencher) {\n+    b.iter(|| (0..LEN).map(|_| u32::default()).collect::<Vec<_>>());\n+}\n+\n+#[bench]\n+fn bench_chain_extend_ref(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| {\n+        let mut v = Vec::<u32>::with_capacity(data.len() + 1);\n+        v.extend(data.iter().chain([1].iter()));\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn bench_chain_extend_value(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| {\n+        let mut v = Vec::<u32>::with_capacity(data.len() + 1);\n+        v.extend(data.iter().cloned().chain(Some(1)));\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn bench_rev_1(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| {\n+        let mut v = Vec::<u32>::new();\n+        v.extend(data.iter().rev());\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn bench_rev_2(b: &mut test::Bencher) {\n+    let data = black_box([0; LEN]);\n+    b.iter(|| example_plain_slow(&data));\n+}\n+\n+#[bench]\n+fn bench_map_regular(b: &mut test::Bencher) {\n+    let data = black_box([(0, 0); LEN]);\n+    b.iter(|| {\n+        let mut v = Vec::<u32>::new();\n+        v.extend(data.iter().map(|t| t.1));\n+        v\n+    });\n+}\n+\n+#[bench]\n+fn bench_map_fast(b: &mut test::Bencher) {\n+    let data = black_box([(0, 0); LEN]);\n+    b.iter(|| map_fast(&data));\n+}"}, {"sha": "40aa4d850f59ddc0798b156ae97f67a8e5c6a006", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -145,13 +145,13 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::fmt;\n-use core::iter::{FromIterator, FusedIterator, TrustedLen};\n+use core::iter::{FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen};\n use core::mem::{self, size_of, swap, ManuallyDrop};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n use crate::slice;\n-use crate::vec::{self, Vec};\n+use crate::vec::{self, AsIntoIter, Vec};\n \n use super::SpecExtend;\n \n@@ -1173,6 +1173,27 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T> SourceIter for IntoIter<T> {\n+    type Source = IntoIter<T>;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n+        self\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I> InPlaceIterable for IntoIter<I> {}\n+\n+impl<I> AsIntoIter for IntoIter<I> {\n+    type Item = I;\n+\n+    fn as_into_iter(&mut self) -> &mut vec::IntoIter<Self::Item> {\n+        &mut self.iter\n+    }\n+}\n+\n #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n #[derive(Clone, Debug)]\n pub struct IntoIterSorted<T> {"}, {"sha": "43b70a51636909395808bd84a4f6d4d78d9fcf17", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -99,13 +99,15 @@\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]\n+#![feature(inplace_iteration)]\n #![feature(internal_uninit_const)]\n #![feature(lang_items)]\n #![feature(layout_for_ptr)]\n #![feature(libc)]\n #![feature(map_first_last)]\n #![feature(map_into_keys_values)]\n #![feature(negative_impls)]\n+#![feature(never_type)]\n #![feature(new_uninit)]\n #![feature(nll)]\n #![feature(nonnull_slice_from_raw_parts)]\n@@ -133,7 +135,9 @@\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n+#![feature(trusted_random_access)]\n #![feature(try_trait)]\n+#![feature(type_alias_impl_trait)]\n #![feature(associated_type_bounds)]\n // Allow testing this library\n "}, {"sha": "9013e3fc16ab918f86c2a5a864bd9662a1147a5e", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 322, "deletions": 40, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -58,7 +58,9 @@ use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n-use core::iter::{FromIterator, FusedIterator, TrustedLen};\n+use core::iter::{\n+    FromIterator, FusedIterator, InPlaceIterable, SourceIter, TrustedLen, TrustedRandomAccess,\n+};\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n@@ -2012,7 +2014,7 @@ impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n-        <Self as SpecExtend<T, I::IntoIter>>::from_iter(iter.into_iter())\n+        <Self as SpecFromIter<T, I::IntoIter>>::from_iter(iter.into_iter())\n     }\n }\n \n@@ -2094,13 +2096,39 @@ impl<T> Extend<T> for Vec<T> {\n     }\n }\n \n-// Specialization trait used for Vec::from_iter and Vec::extend\n-trait SpecExtend<T, I> {\n+/// Specialization trait used for Vec::from_iter\n+///\n+/// ## The delegation graph:\n+///\n+/// ```text\n+/// +-------------+\n+/// |FromIterator |\n+/// +-+-----------+\n+///   |\n+///   v\n+/// +-+-------------------------------+  +---------------------+\n+/// |SpecFromIter                  +---->+SpecFromIterNested   |\n+/// |where I:                      |  |  |where I:             |\n+/// |  Iterator (default)----------+  |  |  Iterator (default) |\n+/// |  vec::IntoIter               |  |  |  TrustedLen         |\n+/// |  SourceIterMarker---fallback-+  |  |                     |\n+/// |  slice::Iter                    |  |                     |\n+/// |  Iterator<Item = &Clone>        |  +---------------------+\n+/// +---------------------------------+\n+///\n+/// ```\n+trait SpecFromIter<T, I> {\n     fn from_iter(iter: I) -> Self;\n-    fn spec_extend(&mut self, iter: I);\n }\n \n-impl<T, I> SpecExtend<T, I> for Vec<T>\n+/// Another specialization trait for Vec::from_iter\n+/// necessary to manually prioritize overlapping specializations\n+/// see [`SpecFromIter`] for details.\n+trait SpecFromIterNested<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n where\n     I: Iterator<Item = T>,\n {\n@@ -2122,25 +2150,233 @@ where\n                 vector\n             }\n         };\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n         <Vec<T> as SpecExtend<T, I>>::spec_extend(&mut vector, iterator);\n         vector\n     }\n-\n-    default fn spec_extend(&mut self, iter: I) {\n-        self.extend_desugared(iter)\n-    }\n }\n \n-impl<T, I> SpecExtend<T, I> for Vec<T>\n+impl<T, I> SpecFromIterNested<T, I> for Vec<T>\n where\n     I: TrustedLen<Item = T>,\n {\n-    default fn from_iter(iterator: I) -> Self {\n+    fn from_iter(iterator: I) -> Self {\n         let mut vector = Vec::new();\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n         vector.spec_extend(iterator);\n         vector\n     }\n+}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIterNested::from_iter(iterator)\n+    }\n+}\n+\n+// A helper struct for in-place iteration that drops the destination slice of iteration,\n+// i.e. the head. The source slice (the tail) is dropped by IntoIter.\n+struct InPlaceDrop<T> {\n+    inner: *mut T,\n+    dst: *mut T,\n+}\n+\n+impl<T> InPlaceDrop<T> {\n+    fn len(&self) -> usize {\n+        unsafe { self.dst.offset_from(self.inner) as usize }\n+    }\n+}\n+\n+impl<T> Drop for InPlaceDrop<T> {\n+    #[inline]\n+    fn drop(&mut self) {\n+        if mem::needs_drop::<T>() {\n+            unsafe {\n+                ptr::drop_in_place(slice::from_raw_parts_mut(self.inner, self.len()));\n+            }\n+        }\n+    }\n+}\n+\n+impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n+    fn from_iter(iterator: IntoIter<T>) -> Self {\n+        // A common case is passing a vector into a function which immediately\n+        // re-collects into a vector. We can short circuit this if the IntoIter\n+        // has not been advanced at all.\n+        // When it has been advanced We can also reuse the memory and move the data to the front.\n+        // But we only do so when the resulting Vec wouldn't have more unused capacity\n+        // than creating it through the generic FromIterator implementation would. That limitation\n+        // is not strictly necessary as Vec's allocation behavior is intentionally unspecified.\n+        // But it is a conservative choice.\n+        let has_advanced = iterator.buf.as_ptr() as *const _ != iterator.ptr;\n+        if !has_advanced || iterator.len() >= iterator.cap / 2 {\n+            unsafe {\n+                let it = ManuallyDrop::new(iterator);\n+                if has_advanced {\n+                    ptr::copy(it.ptr, it.buf.as_ptr(), it.len());\n+                }\n+                return Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap);\n+            }\n+        }\n+\n+        let mut vec = Vec::new();\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vec.spec_extend(iterator);\n+        vec\n+    }\n+}\n+\n+fn write_in_place_with_drop<T>(\n+    src_end: *const T,\n+) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n+    move |mut sink, item| {\n+        unsafe {\n+            // the InPlaceIterable contract cannot be verified precisely here since\n+            // try_fold has an exclusive reference to the source pointer\n+            // all we can do is check if it's still in range\n+            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(sink.dst, item);\n+            sink.dst = sink.dst.add(1);\n+        }\n+        Ok(sink)\n+    }\n+}\n+\n+/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n+/// source allocation, i.e. executing the pipeline in place.\n+///\n+/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n+/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n+/// additional bounds on the impl.\n+#[rustc_unsafe_specialization_marker]\n+trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n+\n+// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n+// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n+// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n+// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n+// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n+// several other specializations already depend on.\n+impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T> + SourceIterMarker,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n+        // instead:\n+        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n+        // b) size match as required by Alloc contract\n+        // c) alignments match as required by Alloc contract\n+        if mem::size_of::<T>() == 0\n+            || mem::size_of::<T>()\n+                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+            || mem::align_of::<T>()\n+                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+        {\n+            // fallback to more generic implementations\n+            return SpecFromIterNested::from_iter(iterator);\n+        }\n+\n+        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n+            let inner = iterator.as_inner().as_into_iter();\n+            (\n+                inner.buf.as_ptr(),\n+                inner.ptr,\n+                inner.buf.as_ptr() as *mut T,\n+                inner.end as *const T,\n+                inner.cap,\n+            )\n+        };\n+\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods methods it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink = iterator\n+            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n+            .unwrap();\n+        // iteration succeeded, don't drop head\n+        let dst = mem::ManuallyDrop::new(sink).dst;\n+\n+        let src = unsafe { iterator.as_inner().as_into_iter() };\n+        // check if SourceIter contract was upheld\n+        // caveat: if they weren't we may not even make it to this point\n+        debug_assert_eq!(src_buf, src.buf.as_ptr());\n+        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n+        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n+        // then the source pointer will stay in its initial position and we can't use it as reference\n+        if src.ptr != src_ptr {\n+            debug_assert!(\n+                dst as *const _ <= src.ptr,\n+                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n+            );\n+        }\n+\n+        // drop any remaining values at the tail of the source\n+        src.drop_remaining();\n+        // but prevent drop of the allocation itself once IntoIter goes out of scope\n+        src.forget_allocation();\n+\n+        let vec = unsafe {\n+            let len = dst.offset_from(dst_buf) as usize;\n+            Vec::from_raw_parts(dst_buf, len, cap)\n+        };\n+\n+        vec\n+    }\n+}\n+\n+impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecFromIter::from_iter(iterator.cloned())\n+    }\n+}\n+\n+impl<'a, T: 'a> SpecFromIter<&'a T, slice::Iter<'a, T>> for Vec<T>\n+where\n+    T: Copy,\n+{\n+    // reuses the extend specialization for T: Copy\n+    fn from_iter(iterator: slice::Iter<'a, T>) -> Self {\n+        let mut vec = Vec::new();\n+        // must delegate to spec_extend() since extend() itself delegates\n+        // to spec_from for empty Vecs\n+        vec.spec_extend(iterator);\n+        vec\n+    }\n+}\n+\n+// Specialization trait used for Vec::extend\n+trait SpecExtend<T, I> {\n+    fn spec_extend(&mut self, iter: I);\n+}\n+\n+impl<T, I> SpecExtend<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T>,\n+{\n+    default fn spec_extend(&mut self, iter: I) {\n+        self.extend_desugared(iter)\n+    }\n+}\n \n+impl<T, I> SpecExtend<T, I> for Vec<T>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n     default fn spec_extend(&mut self, iterator: I) {\n         // This is the case for a TrustedLen iterator.\n         let (low, high) = iterator.size_hint();\n@@ -2171,22 +2407,6 @@ where\n }\n \n impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n-    fn from_iter(iterator: IntoIter<T>) -> Self {\n-        // A common case is passing a vector into a function which immediately\n-        // re-collects into a vector. We can short circuit this if the IntoIter\n-        // has not been advanced at all.\n-        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n-            unsafe {\n-                let it = ManuallyDrop::new(iterator);\n-                Vec::from_raw_parts(it.buf.as_ptr(), it.len(), it.cap)\n-            }\n-        } else {\n-            let mut vector = Vec::new();\n-            vector.spec_extend(iterator);\n-            vector\n-        }\n-    }\n-\n     fn spec_extend(&mut self, mut iterator: IntoIter<T>) {\n         unsafe {\n             self.append_elements(iterator.as_slice() as _);\n@@ -2200,10 +2420,6 @@ where\n     I: Iterator<Item = &'a T>,\n     T: Clone,\n {\n-    default fn from_iter(iterator: I) -> Self {\n-        SpecExtend::from_iter(iterator.cloned())\n-    }\n-\n     default fn spec_extend(&mut self, iterator: I) {\n         self.spec_extend(iterator.cloned())\n     }\n@@ -2215,17 +2431,13 @@ where\n {\n     fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n         let slice = iterator.as_slice();\n-        self.reserve(slice.len());\n-        unsafe {\n-            let len = self.len();\n-            let dst_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(len), slice.len());\n-            dst_slice.copy_from_slice(slice);\n-            self.set_len(len + slice.len());\n-        }\n+        unsafe { self.append_elements(slice) };\n     }\n }\n \n impl<T> Vec<T> {\n+    // leaf method to which various SpecFrom/SpecExtend implementations delegate when\n+    // they have no further optimizations to apply\n     fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n         // This is the case for a general iterator.\n         //\n@@ -2656,6 +2868,24 @@ impl<T> IntoIter<T> {\n     fn as_raw_mut_slice(&mut self) -> *mut [T] {\n         ptr::slice_from_raw_parts_mut(self.ptr as *mut T, self.len())\n     }\n+\n+    fn drop_remaining(&mut self) {\n+        if mem::needs_drop::<T>() {\n+            unsafe {\n+                ptr::drop_in_place(self.as_mut_slice());\n+            }\n+        }\n+        self.ptr = self.end;\n+    }\n+\n+    /// Relinquishes the backing allocation, equivalent to\n+    /// `ptr::write(&mut self, Vec::new().into_iter())`\n+    fn forget_allocation(&mut self) {\n+        self.cap = 0;\n+        self.buf = unsafe { NonNull::new_unchecked(RawVec::NEW.ptr()) };\n+        self.ptr = self.buf.as_ptr();\n+        self.end = self.buf.as_ptr();\n+    }\n }\n \n #[stable(feature = \"vec_intoiter_as_ref\", since = \"1.46.0\")]\n@@ -2712,6 +2942,17 @@ impl<T> Iterator for IntoIter<T> {\n     fn count(self) -> usize {\n         self.len()\n     }\n+\n+    unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::get_unchecked`.\n+        unsafe {\n+            if mem::size_of::<T>() == 0 { mem::zeroed() } else { ptr::read(self.ptr.add(i)) }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2751,6 +2992,19 @@ impl<T> FusedIterator for IntoIter<T> {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<T> TrustedLen for IntoIter<T> {}\n \n+#[doc(hidden)]\n+#[unstable(issue = \"none\", feature = \"std_internals\")]\n+// T: Copy as approximation for !Drop since get_unchecked does not advance self.ptr\n+// and thus we can't implement drop-handling\n+unsafe impl<T> TrustedRandomAccess for IntoIter<T>\n+where\n+    T: Copy,\n+{\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n #[stable(feature = \"vec_into_iter_clone\", since = \"1.8.0\")]\n impl<T: Clone> Clone for IntoIter<T> {\n     fn clone(&self) -> IntoIter<T> {\n@@ -2779,6 +3033,34 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n     }\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T> InPlaceIterable for IntoIter<T> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<T> SourceIter for IntoIter<T> {\n+    type Source = IntoIter<T>;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut Self::Source {\n+        self\n+    }\n+}\n+\n+// internal helper trait for in-place iteration specialization.\n+#[rustc_specialization_trait]\n+pub(crate) trait AsIntoIter {\n+    type Item;\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n+}\n+\n+impl<T> AsIntoIter for IntoIter<T> {\n+    type Item = T;\n+\n+    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {\n+        self\n+    }\n+}\n+\n /// A draining iterator for `Vec<T>`.\n ///\n /// This `struct` is created by [`Vec::drain`].\n@@ -3042,7 +3324,7 @@ where\n     old_len: usize,\n     /// The filter test predicate.\n     pred: F,\n-    /// A flag that indicates a panic has occurred in the filter test prodicate.\n+    /// A flag that indicates a panic has occurred in the filter test predicate.\n     /// This is used as a hint in the drop implementation to prevent consumption\n     /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n     /// backshifted in the `vec`, but no further items will be dropped or"}, {"sha": "ce794a9a4afa2dd0c89b167efc33a3ff76edfdd1", "filename": "library/alloc/tests/binary_heap.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fbinary_heap.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -230,6 +230,18 @@ fn test_to_vec() {\n     check_to_vec(vec![5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1]);\n }\n \n+#[test]\n+fn test_in_place_iterator_specialization() {\n+    let src: Vec<usize> = vec![1, 2, 3];\n+    let src_ptr = src.as_ptr();\n+    let heap: BinaryHeap<_> = src.into_iter().map(std::convert::identity).collect();\n+    let heap_ptr = heap.iter().next().unwrap() as *const usize;\n+    assert_eq!(src_ptr, heap_ptr);\n+    let sink: Vec<_> = heap.into_iter().map(std::convert::identity).collect();\n+    let sink_ptr = sink.as_ptr();\n+    assert_eq!(heap_ptr, sink_ptr);\n+}\n+\n #[test]\n fn test_empty_pop() {\n     let mut heap = BinaryHeap::<i32>::new();"}, {"sha": "b1513d1b056554d83dcd60627cbfbc9e38e75615", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -14,6 +14,8 @@\n #![feature(slice_ptr_get)]\n #![feature(split_inclusive)]\n #![feature(binary_heap_retain)]\n+#![feature(inplace_iteration)]\n+#![feature(iter_map_while)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "1f561bebd908b5b86a21fa2c941ff6ba094cb0f2", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -1459,6 +1459,15 @@ fn test_to_vec() {\n     assert_eq!(ys, [1, 2, 3]);\n }\n \n+#[test]\n+fn test_in_place_iterator_specialization() {\n+    let src: Box<[usize]> = box [1, 2, 3];\n+    let src_ptr = src.as_ptr();\n+    let sink: Box<_> = src.into_vec().into_iter().map(std::convert::identity).collect();\n+    let sink_ptr = sink.as_ptr();\n+    assert_eq!(src_ptr, sink_ptr);\n+}\n+\n #[test]\n fn test_box_slice_clone() {\n     let data = vec![vec![0, 1], vec![0], vec![1]];"}, {"sha": "8e66c8a22cec594f39176dd62fb5c273ce6547c8", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -1,8 +1,10 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::fmt::Debug;\n+use std::iter::InPlaceIterable;\n use std::mem::size_of;\n use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::rc::Rc;\n use std::vec::{Drain, IntoIter};\n \n struct DropCounter<'a> {\n@@ -775,6 +777,87 @@ fn test_into_iter_leak() {\n     assert_eq!(unsafe { DROPS }, 3);\n }\n \n+#[test]\n+fn test_from_iter_specialization() {\n+    let src: Vec<usize> = vec![0usize; 1];\n+    let srcptr = src.as_ptr();\n+    let sink = src.into_iter().collect::<Vec<_>>();\n+    let sinkptr = sink.as_ptr();\n+    assert_eq!(srcptr, sinkptr);\n+}\n+\n+#[test]\n+fn test_from_iter_partially_drained_in_place_specialization() {\n+    let src: Vec<usize> = vec![0usize; 10];\n+    let srcptr = src.as_ptr();\n+    let mut iter = src.into_iter();\n+    iter.next();\n+    iter.next();\n+    let sink = iter.collect::<Vec<_>>();\n+    let sinkptr = sink.as_ptr();\n+    assert_eq!(srcptr, sinkptr);\n+}\n+\n+#[test]\n+fn test_from_iter_specialization_with_iterator_adapters() {\n+    fn assert_in_place_trait<T: InPlaceIterable>(_: &T) {};\n+    let src: Vec<usize> = vec![0usize; 65535];\n+    let srcptr = src.as_ptr();\n+    let iter = src\n+        .into_iter()\n+        .enumerate()\n+        .map(|i| i.0 + i.1)\n+        .zip(std::iter::repeat(1usize))\n+        .map(|(a, b)| a + b)\n+        .map_while(Option::Some)\n+        .peekable()\n+        .skip(1)\n+        .map(|e| std::num::NonZeroUsize::new(e));\n+    assert_in_place_trait(&iter);\n+    let sink = iter.collect::<Vec<_>>();\n+    let sinkptr = sink.as_ptr();\n+    assert_eq!(srcptr, sinkptr as *const usize);\n+}\n+\n+#[test]\n+fn test_from_iter_specialization_head_tail_drop() {\n+    let drop_count: Vec<_> = (0..=2).map(|_| Rc::new(())).collect();\n+    let src: Vec<_> = drop_count.iter().cloned().collect();\n+    let srcptr = src.as_ptr();\n+    let iter = src.into_iter();\n+    let sink: Vec<_> = iter.skip(1).take(1).collect();\n+    let sinkptr = sink.as_ptr();\n+    assert_eq!(srcptr, sinkptr, \"specialization was applied\");\n+    assert_eq!(Rc::strong_count(&drop_count[0]), 1, \"front was dropped\");\n+    assert_eq!(Rc::strong_count(&drop_count[1]), 2, \"one element was collected\");\n+    assert_eq!(Rc::strong_count(&drop_count[2]), 1, \"tail was dropped\");\n+    assert_eq!(sink.len(), 1);\n+}\n+\n+#[test]\n+fn test_from_iter_specialization_panic_drop() {\n+    let drop_count: Vec<_> = (0..=2).map(|_| Rc::new(())).collect();\n+    let src: Vec<_> = drop_count.iter().cloned().collect();\n+    let iter = src.into_iter();\n+\n+    let _ = std::panic::catch_unwind(AssertUnwindSafe(|| {\n+        let _ = iter\n+            .enumerate()\n+            .filter_map(|(i, e)| {\n+                if i == 1 {\n+                    std::panic!(\"aborting iteration\");\n+                }\n+                Some(e)\n+            })\n+            .collect::<Vec<_>>();\n+    }));\n+\n+    assert!(\n+        drop_count.iter().map(Rc::strong_count).all(|count| count == 1),\n+        \"all items were dropped once\"\n+    );\n+}\n+\n #[test]\n fn test_cow_from() {\n     let borrowed: &[_] = &[\"borrowed\", \"(slice)\"];"}, {"sha": "4185453ac5ae331adb51becd0a7ef98a75cda2f7", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -1,5 +1,7 @@\n+use super::InPlaceIterable;\n use crate::intrinsics;\n use crate::iter::adapters::zip::try_get_unchecked;\n+use crate::iter::adapters::SourceIter;\n use crate::iter::TrustedRandomAccess;\n use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n use crate::ops::Try;\n@@ -517,3 +519,24 @@ where\n         unchecked!(self).is_empty()\n     }\n }\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: FusedIterator> SourceIter for Fuse<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        match self.iter {\n+            // Safety: unsafe function forwarding to unsafe function with the same requirements\n+            Some(ref mut iter) => unsafe { SourceIter::as_inner(iter) },\n+            // SAFETY: the specialized iterator never sets `None`\n+            None => unsafe { intrinsics::unreachable() },\n+        }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Fuse<I> {}"}, {"sha": "c3f1269401aa99e43c971db3bde7cdb3709b80e3", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 302, "deletions": 2, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -4,7 +4,9 @@ use crate::intrinsics;\n use crate::ops::{Add, AddAssign, ControlFlow, Try};\n \n use super::from_fn;\n-use super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n+use super::{\n+    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, TrustedLen,\n+};\n \n mod chain;\n mod flatten;\n@@ -16,9 +18,77 @@ pub use self::chain::Chain;\n pub use self::flatten::{FlatMap, Flatten};\n pub use self::fuse::Fuse;\n use self::zip::try_get_unchecked;\n-pub(crate) use self::zip::TrustedRandomAccess;\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+pub use self::zip::TrustedRandomAccess;\n pub use self::zip::Zip;\n \n+/// This trait provides transitive access to source-stage in an interator-adapter pipeline\n+/// under the conditions that\n+/// * the iterator source `S` itself implements `SourceIter<Source = S>`\n+/// * there is a delegating implementation of this trait for each adapter in the pipeline between\n+///   the source and the pipeline consumer.\n+///\n+/// When the source is an owning iterator struct (commonly called `IntoIter`) then\n+/// this can be useful for specializing [`FromIterator`] implementations or recovering the\n+/// remaining elements after an iterator has been partially exhausted.\n+///\n+/// Note that implementations do not necessarily have to provide access to the inner-most\n+/// source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part\n+/// of the pipeline and expose its internal storage as source.\n+///\n+/// The trait is unsafe because implementers must uphold additional safety properties.\n+/// See [`as_inner`] for details.\n+///\n+/// # Examples\n+///\n+/// Retrieving a partially consumed source:\n+///\n+/// ```\n+/// # #![feature(inplace_iteration)]\n+/// # use std::iter::SourceIter;\n+///\n+/// let mut iter = vec![9, 9, 9].into_iter().map(|i| i * i);\n+/// let _ = iter.next();\n+/// let mut remainder = std::mem::replace(unsafe { iter.as_inner() }, Vec::new().into_iter());\n+/// println!(\"n = {} elements remaining\", remainder.len());\n+/// ```\n+///\n+/// [`FromIterator`]: crate::iter::FromIterator\n+/// [`as_inner`]: SourceIter::as_inner\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub unsafe trait SourceIter {\n+    /// A source stage in an iterator pipeline.\n+    type Source: Iterator;\n+\n+    /// Retrieve the source of an iterator pipeline.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Implementations of must return the same mutable reference for their lifetime, unless\n+    /// replaced by a caller.\n+    /// Callers may only replace the reference when they stopped iteration and drop the\n+    /// iterator pipeline after extracting the source.\n+    ///\n+    /// This means iterator adapters can rely on the source not changing during\n+    /// iteration but they cannot rely on it in their Drop implementations.\n+    ///\n+    /// Implementing this method means adapters relinquish private-only access to their\n+    /// source and can only rely on guarantees made based on method receiver types.\n+    /// The lack of restricted access also requires that adapters must uphold the source's\n+    /// public API even when they have access to its internals.\n+    ///\n+    /// Callers in turn must expect the source to be in any state that is consistent with\n+    /// its public API since adapters sitting between it and the source have the same\n+    /// access. In particular an adapter may have consumed more elements than strictly necessary.\n+    ///\n+    /// The overall goal of these requirements is to let the consumer of a pipeline use\n+    /// * whatever remains in the source after iteration has stopped\n+    /// * the memory that has become unused by advancing a consuming iterator\n+    ///\n+    /// [`next()`]: trait.Iterator.html#method.next\n+    unsafe fn as_inner(&mut self) -> &mut Self::Source;\n+}\n+\n /// A double-ended iterator with the direction inverted.\n ///\n /// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n@@ -939,6 +1009,24 @@ where\n     }\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}\n+\n /// An iterator that filters the elements of `iter` with `predicate`.\n ///\n /// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n@@ -1070,6 +1158,24 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n+\n /// An iterator that uses `f` to both filter and map elements from `iter`.\n ///\n /// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n@@ -1196,6 +1302,27 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n+    F: FnMut(I::Item) -> Option<B>\n+{\n+}\n+\n /// An iterator that yields the current count and the element during iteration.\n ///\n /// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n@@ -1414,6 +1541,23 @@ impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}\n+\n /// An iterator with a `peek()` that returns an optional reference to the next\n /// element.\n ///\n@@ -1692,6 +1836,26 @@ impl<I: Iterator> Peekable<I> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}\n+\n /// An iterator that rejects elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n@@ -1793,6 +1957,27 @@ where\n {\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}\n+\n /// An iterator that only accepts elements while `predicate` returns `true`.\n ///\n /// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n@@ -1907,6 +2092,27 @@ where\n {\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}\n+\n /// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n ///\n /// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n@@ -1984,6 +2190,27 @@ where\n     }\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n+    P: FnMut(I::Item) -> Option<B>\n+{\n+}\n+\n /// An iterator that skips over `n` elements of `iter`.\n ///\n /// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n@@ -2167,6 +2394,23 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}\n+\n /// An iterator that only iterates over the first `n` iterations of `iter`.\n ///\n /// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n@@ -2277,6 +2521,23 @@ where\n     }\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n+\n #[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n impl<I> DoubleEndedIterator for Take<I>\n where\n@@ -2441,6 +2702,27 @@ where\n     }\n }\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n+where\n+    I: SourceIter<Source = S>,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n+    F: FnMut(&mut St, I::Item) -> Option<B>\n+{\n+}\n+\n /// An iterator that calls a function with a reference to each element before\n /// yielding it.\n ///\n@@ -2587,6 +2869,24 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}\n+\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///"}, {"sha": "c1c90ec9a836aa4790bc5b169cdb61a1fd878da0", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -1,7 +1,10 @@\n use crate::cmp;\n use crate::fmt::{self, Debug};\n \n-use super::super::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator, TrustedLen};\n+use super::super::{\n+    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, SourceIter,\n+    TrustedLen,\n+};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n@@ -327,6 +330,32 @@ where\n {\n }\n \n+// Arbitrarily selects the left side of the zip iteration as extractable \"source\"\n+// it would require negative trait bounds to be able to try both\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S, A, B> SourceIter for Zip<A, B>\n+where\n+    A: SourceIter<Source = S>,\n+    B: Iterator,\n+    S: Iterator,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // Safety: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.a) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+// Limited to Item: Copy since interaction between Zip's use of TrustedRandomAccess\n+// and Drop implementation of the source is unclear.\n+//\n+// An additional method returning the number of times the source has been logically advanced\n+// (without calling next()) would be needed to properly drop the remainder of the source.\n+unsafe impl<A: InPlaceIterable, B: Iterator> InPlaceIterable for Zip<A, B> where A::Item: Copy {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Debug, B: Debug> Debug for Zip<A, B> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "59f333e888b88cd7e2af852959d282347da6b21d", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -342,24 +342,32 @@ pub use self::traits::{DoubleEndedIterator, Extend, FromIterator, IntoIterator};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::traits::{ExactSizeIterator, Product, Sum};\n \n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub use self::traits::InPlaceIterable;\n+\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::adapters::Cloned;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n+\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::adapters::MapWhile;\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub use self::adapters::SourceIter;\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n pub use self::adapters::StepBy;\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+pub use self::adapters::TrustedRandomAccess;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::adapters::{Chain, Cycle, Enumerate, Filter, FilterMap, Map, Rev, Zip};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::adapters::{FlatMap, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::adapters::{Fuse, Inspect};\n \n-pub(crate) use self::adapters::{process_results, TrustedRandomAccess};\n+pub(crate) use self::adapters::process_results;\n \n mod adapters;\n mod range;"}, {"sha": "f287196da03efccb7317f3c3b5bae06ec251ebd8", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -42,3 +42,15 @@ pub unsafe trait TrustedLen: Iterator {}\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}\n+\n+/// An iterator that when yielding an item will have taken at least one element\n+/// from its underlying [`SourceIter`].\n+///\n+/// Calling next() guarantees that at least one value of the iterator's underlying source\n+/// has been moved out and the result of the iterator chain could be inserted in its place,\n+/// assuming structural constraints of the source allow such an insertion.\n+/// In other words this trait indicates that an iterator pipeline can be collected in place.\n+///\n+/// [`SourceIter`]: ../../std/iter/trait.SourceIter.html\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub unsafe trait InPlaceIterable: Iterator {}"}, {"sha": "880f8d831fd922bf9961296dda96ab137871727d", "filename": "library/core/src/iter/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmod.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -11,5 +11,7 @@ pub use self::double_ended::DoubleEndedIterator;\n pub use self::exact_size::ExactSizeIterator;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::iterator::Iterator;\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub use self::marker::InPlaceIterable;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::marker::{FusedIterator, TrustedLen};"}, {"sha": "ffbe89a14e3bbd4501f66355ca5a5c8b018d328c", "filename": "src/test/ui/iterators/issue-58952-filter-type-length.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d0f6b113047b2cf9afbde990cee30fd5b866469/src%2Ftest%2Fui%2Fiterators%2Fissue-58952-filter-type-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d0f6b113047b2cf9afbde990cee30fd5b866469/src%2Ftest%2Fui%2Fiterators%2Fissue-58952-filter-type-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Fissue-58952-filter-type-length.rs?ref=0d0f6b113047b2cf9afbde990cee30fd5b866469", "patch": "@@ -3,6 +3,7 @@\n //! so check that we don't accidentially exceed the type length limit.\n // FIXME: Once the size of iterator adaptors is further reduced,\n // increase the complexity of this test.\n+use std::collections::VecDeque;\n \n fn main() {\n     let c = 2;\n@@ -27,5 +28,5 @@ fn main() {\n         .filter(|a| b.clone().any(|b| *b == *a))\n         .filter(|a| b.clone().any(|b| *b == *a))\n         .filter(|a| b.clone().any(|b| *b == *a))\n-        .collect::<Vec<_>>();\n+        .collect::<VecDeque<_>>();\n }"}]}