{"sha": "2666c38acb8352b7fd5903f50ee5fd76e2441cff", "node_id": "C_kwDOAAsO6NoAKDI2NjZjMzhhY2I4MzUyYjdmZDU5MDNmNTBlZTVmZDc2ZTI0NDFjZmY", "commit": {"author": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2022-07-29T00:50:43Z"}, "committer": {"name": "Serial", "email": "69764315+Serial-ATA@users.noreply.github.com", "date": "2022-08-19T12:05:59Z"}, "message": "Add [`unused_peekable`] lint", "tree": {"sha": "66920e9176cdb62e0c9831d92eaea025dcb3a32b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66920e9176cdb62e0c9831d92eaea025dcb3a32b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2666c38acb8352b7fd5903f50ee5fd76e2441cff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2666c38acb8352b7fd5903f50ee5fd76e2441cff", "html_url": "https://github.com/rust-lang/rust/commit/2666c38acb8352b7fd5903f50ee5fd76e2441cff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2666c38acb8352b7fd5903f50ee5fd76e2441cff/comments", "author": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Serial-ATA", "id": 69764315, "node_id": "MDQ6VXNlcjY5NzY0MzE1", "avatar_url": "https://avatars.githubusercontent.com/u/69764315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Serial-ATA", "html_url": "https://github.com/Serial-ATA", "followers_url": "https://api.github.com/users/Serial-ATA/followers", "following_url": "https://api.github.com/users/Serial-ATA/following{/other_user}", "gists_url": "https://api.github.com/users/Serial-ATA/gists{/gist_id}", "starred_url": "https://api.github.com/users/Serial-ATA/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Serial-ATA/subscriptions", "organizations_url": "https://api.github.com/users/Serial-ATA/orgs", "repos_url": "https://api.github.com/users/Serial-ATA/repos", "events_url": "https://api.github.com/users/Serial-ATA/events{/privacy}", "received_events_url": "https://api.github.com/users/Serial-ATA/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "868dba9f65a40ffd406baba9ca301b4dc33ff641", "url": "https://api.github.com/repos/rust-lang/rust/commits/868dba9f65a40ffd406baba9ca301b4dc33ff641", "html_url": "https://github.com/rust-lang/rust/commit/868dba9f65a40ffd406baba9ca301b4dc33ff641"}], "stats": {"total": 387, "additions": 386, "deletions": 1}, "files": [{"sha": "c42a03c04a00f09d073bd7a448f0a13c466207c8", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -4152,6 +4152,7 @@ Released 2018-09-13\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_peekable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_peekable\n [`unused_rounding`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_rounding\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit"}, {"sha": "de0514c1b66503b8db0a852af905e91dab998fea", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -337,6 +337,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n+    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(unwrap::PANICKING_UNWRAP),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),"}, {"sha": "eb23bb0c7dbe6693b2c1399e24122b3a05ff97f3", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -573,6 +573,7 @@ store.register_lints(&[\n     unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n     unused_async::UNUSED_ASYNC,\n     unused_io_amount::UNUSED_IO_AMOUNT,\n+    unused_peekable::UNUSED_PEEKABLE,\n     unused_rounding::UNUSED_ROUNDING,\n     unused_self::UNUSED_SELF,\n     unused_unit::UNUSED_UNIT,"}, {"sha": "5793d59bcad116e5f3f26d75b862abbf528547ff", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -33,4 +33,5 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n     LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n     LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n+    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n ])"}, {"sha": "d4c6c4918cb30c54a03bf534aebc4bbd0c5ba064", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -398,6 +398,7 @@ mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_async;\n mod unused_io_amount;\n+mod unused_peekable;\n mod unused_rounding;\n mod unused_self;\n mod unused_unit;\n@@ -935,6 +936,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n     store.register_late_pass(|| Box::new(partialeq_to_none::PartialeqToNone));\n     store.register_late_pass(|| Box::new(manual_empty_string_creations::ManualEmptyStringCreations));\n+    store.register_late_pass(|| Box::new(unused_peekable::UnusedPeekable::default()));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "4988ec0eca12c973a8a70ad5651f001cebcc3fb8", "filename": "clippy_lints/src/unused_peekable.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -0,0 +1,208 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::{match_type, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::{fn_def_id, path_to_local_id, paths, peel_ref_operators};\n+use rustc_ast::Mutability;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, Local, Node, PatKind, PathSegment, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::Ty;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the creation of a `peekable` iterator that is never `.peek()`ed\n+    ///\n+    /// ### Why is this bad?\n+    /// Creating a peekable iterator without using any of its methods is likely a mistake,\n+    /// or just a leftover after a refactor.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let collection = vec![1, 2, 3];\n+    /// let iter = collection.iter().peekable();\n+    ///\n+    /// for item in iter {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let collection = vec![1, 2, 3];\n+    /// let iter = collection.iter();\n+    ///\n+    /// for item in iter {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub UNUSED_PEEKABLE,\n+    suspicious,\n+    \"creating a peekable iterator without using any of its methods\"\n+}\n+\n+#[derive(Default)]\n+pub struct UnusedPeekable {\n+    visited: Vec<HirId>,\n+}\n+\n+impl_lint_pass!(UnusedPeekable => [UNUSED_PEEKABLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnusedPeekable {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+        // Don't lint `Peekable`s returned from a block\n+        if let Some(expr) = block.expr\n+            && let Some(ty) = cx.typeck_results().expr_ty_opt(peel_ref_operators(cx, expr))\n+            && match_type(cx, ty, &paths::PEEKABLE)\n+        {\n+            return;\n+        }\n+\n+        for (idx, stmt) in block.stmts.iter().enumerate() {\n+            if !stmt.span.from_expansion()\n+                && let StmtKind::Local(local) = stmt.kind\n+                && !self.visited.contains(&local.pat.hir_id)\n+                && let PatKind::Binding(_, _, ident, _) = local.pat.kind\n+                && let Some(init) = local.init\n+                && !init.span.from_expansion()\n+                && let Some(ty) = cx.typeck_results().expr_ty_opt(init)\n+                && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+                && match_type(cx, ty, &paths::PEEKABLE)\n+            {\n+                let mut vis = PeekableVisitor::new(cx, local.pat.hir_id);\n+\n+                if idx + 1 == block.stmts.len() && block.expr.is_none() {\n+                    return;\n+                }\n+\n+                for stmt in &block.stmts[idx..] {\n+                    vis.visit_stmt(stmt);\n+                }\n+\n+                if let Some(expr) = block.expr {\n+                    vis.visit_expr(expr);\n+                }\n+\n+                if !vis.found_peek_call {\n+                    span_lint_and_help(\n+                        cx,\n+                        UNUSED_PEEKABLE,\n+                        ident.span,\n+                        \"`peek` never called on `Peekable` iterator\",\n+                        None,\n+                        \"consider removing the call to `peekable`\"\n+                   );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct PeekableVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    expected_hir_id: HirId,\n+    found_peek_call: bool,\n+}\n+\n+impl<'a, 'tcx> PeekableVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, expected_hir_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            expected_hir_id,\n+            found_peek_call: false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'_ Expr<'_>) {\n+        if path_to_local_id(ex, self.expected_hir_id) {\n+            for (_, node) in self.cx.tcx.hir().parent_iter(ex.hir_id) {\n+                match node {\n+                    Node::Expr(expr) => {\n+                        match expr.kind {\n+                            // some_function(peekable)\n+                            //\n+                            // If the Peekable is passed to a function, stop\n+                            ExprKind::Call(_, args) => {\n+                                if let Some(func_did) = fn_def_id(self.cx, expr)\n+                                    && let Ok(into_iter_did) = self\n+                                        .cx\n+                                        .tcx\n+                                        .lang_items()\n+                                        .require(LangItem::IntoIterIntoIter)\n+                                    && func_did == into_iter_did\n+                                {\n+                                    // Probably a for loop desugar, stop searching\n+                                    return;\n+                                }\n+\n+                                for arg in args.iter().map(|arg| peel_ref_operators(self.cx, arg)) {\n+                                    if let ExprKind::Path(_) = arg.kind\n+                                        && let Some(ty) = self\n+                                            .cx\n+                                            .typeck_results()\n+                                            .expr_ty_opt(arg)\n+                                            .map(Ty::peel_refs)\n+                                        && match_type(self.cx, ty, &paths::PEEKABLE)\n+                                    {\n+                                        self.found_peek_call = true;\n+                                        return;\n+                                    }\n+                                }\n+                            },\n+                            // Peekable::peek()\n+                            ExprKind::MethodCall(PathSegment { ident: method_name, .. }, [arg, ..], _) => {\n+                                let arg = peel_ref_operators(self.cx, arg);\n+                                let method_name = method_name.name.as_str();\n+\n+                                if (method_name == \"peek\"\n+                                    || method_name == \"peek_mut\"\n+                                    || method_name == \"next_if\"\n+                                    || method_name == \"next_if_eq\")\n+                                    && let ExprKind::Path(_) = arg.kind\n+                                    && let Some(ty) = self.cx.typeck_results().expr_ty_opt(arg).map(Ty::peel_refs)\n+                                    && match_type(self.cx, ty, &paths::PEEKABLE)\n+                                {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+                            },\n+                            // Don't bother if moved into a struct\n+                            ExprKind::Struct(..) => {\n+                                self.found_peek_call = true;\n+                                return;\n+                            },\n+                            _ => {},\n+                        }\n+                    },\n+                    Node::Local(Local { init: Some(init), .. }) => {\n+                        if let Some(ty) = self.cx.typeck_results().expr_ty_opt(init)\n+                            && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+                            && match_type(self.cx, ty, &paths::PEEKABLE)\n+                        {\n+                            self.found_peek_call = true;\n+                            return;\n+                        }\n+\n+                        break;\n+                    },\n+                    Node::Stmt(stmt) => match stmt.kind {\n+                        StmtKind::Expr(_) | StmtKind::Semi(_) => {},\n+                        _ => {\n+                            self.found_peek_call = true;\n+                            return;\n+                        },\n+                    },\n+                    Node::Block(_) => {},\n+                    _ => {\n+                        break;\n+                    },\n+                }\n+            }\n+        }\n+\n+        walk_expr(self, ex);\n+    }\n+}"}, {"sha": "d3ae537a890dea92801f7bc24e2881fea9901828", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -96,6 +96,7 @@ pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwL\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n+pub const PEEKABLE: [&str; 5] = [\"core\", \"iter\", \"adapters\", \"peekable\", \"Peekable\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n #[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];"}, {"sha": "edbe9c5a8970ebb2bb0d0a982ff1e5c6c90a714a", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -410,7 +410,7 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     peel(ty, 0)\n }\n \n-/// Peels off all references on the type.Returns the underlying type, the number of references\n+/// Peels off all references on the type. Returns the underlying type, the number of references\n /// removed, and whether the pointer is ultimately mutable or not.\n pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n     fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {"}, {"sha": "12cab9956219c41e34fd2d18c180d563d5184ae8", "filename": "tests/ui/unused_peekable.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/tests%2Fui%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/tests%2Fui%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_peekable.rs?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -0,0 +1,119 @@\n+#![warn(clippy::unused_peekable)]\n+#![allow(clippy::no_effect)]\n+\n+use std::iter::Empty;\n+use std::iter::Peekable;\n+\n+fn main() {\n+    invalid();\n+    valid();\n+}\n+\n+#[allow(clippy::unused_unit)]\n+fn invalid() {\n+    let peekable = std::iter::empty::<u32>().peekable();\n+\n+    // Only lint `new_local`\n+    let old_local = std::iter::empty::<u32>().peekable();\n+    let new_local = old_local;\n+\n+    // Behind mut ref\n+    let mut by_mut_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_mut_ref = &mut by_mut_ref_test;\n+\n+    // Explicitly returns `Peekable`\n+    fn returns_peekable() -> Peekable<Empty<u32>> {\n+        std::iter::empty().peekable()\n+    }\n+\n+    let peekable_from_fn = returns_peekable();\n+\n+    // Using a method not exclusive to `Peekable`\n+    let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n+    peekable_using_iterator_method.next();\n+\n+    let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n+    for x in peekable_in_for_loop {}\n+}\n+\n+fn valid() {\n+    fn takes_peekable(_peek: Peekable<Empty<u32>>) {}\n+\n+    // Passed to another function\n+    let passed_along = std::iter::empty::<u32>().peekable();\n+    takes_peekable(passed_along);\n+\n+    // `peek` called in another block\n+    let mut peekable_in_block = std::iter::empty::<u32>().peekable();\n+    {\n+        peekable_in_block.peek();\n+    }\n+\n+    // Check the other `Peekable` methods :)\n+    {\n+        let mut peekable_with_peek_mut = std::iter::empty::<u32>().peekable();\n+        peekable_with_peek_mut.peek_mut();\n+\n+        let mut peekable_with_next_if = std::iter::empty::<u32>().peekable();\n+        peekable_with_next_if.next_if(|_| true);\n+\n+        let mut peekable_with_next_if_eq = std::iter::empty::<u32>().peekable();\n+        peekable_with_next_if_eq.next_if_eq(&3);\n+    }\n+\n+    let mut peekable_in_closure = std::iter::empty::<u32>().peekable();\n+    let call_peek = |p: &mut Peekable<Empty<u32>>| {\n+        p.peek();\n+    };\n+    call_peek(&mut peekable_in_closure);\n+\n+    // From a macro\n+    macro_rules! make_me_a_peekable_please {\n+        () => {\n+            std::iter::empty::<u32>().peekable()\n+        };\n+    }\n+\n+    let _unsuspecting_macro_user = make_me_a_peekable_please!();\n+\n+    // Generic Iterator returned\n+    fn return_an_iter() -> impl Iterator<Item = u32> {\n+        std::iter::empty::<u32>().peekable()\n+    }\n+\n+    let _unsuspecting_user = return_an_iter();\n+\n+    // Call `peek` in a macro\n+    macro_rules! peek_iter {\n+        ($iter:ident) => {\n+            $iter.peek();\n+        };\n+    }\n+\n+    let mut peek_in_macro = std::iter::empty::<u32>().peekable();\n+    peek_iter!(peek_in_macro);\n+\n+    // Behind mut ref\n+    let mut by_mut_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_mut_ref = &mut by_mut_ref_test;\n+    by_mut_ref.peek();\n+\n+    // Behind ref\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_ref = &by_ref_test;\n+    by_ref_test.peek();\n+\n+    // In struct\n+    struct PeekableWrapper {\n+        f: Peekable<Empty<u32>>,\n+    }\n+\n+    let struct_test = std::iter::empty::<u32>().peekable();\n+    PeekableWrapper { f: struct_test };\n+\n+    // `peek` called in another block as the last expression\n+    let mut peekable_last_expr = std::iter::empty::<u32>().peekable();\n+    {\n+        peekable_last_expr.peek();\n+    }\n+}"}, {"sha": "bd087f56e4ceb85f158cf2475cba03a693b3a253", "filename": "tests/ui/unused_peekable.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2666c38acb8352b7fd5903f50ee5fd76e2441cff/tests%2Fui%2Funused_peekable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2666c38acb8352b7fd5903f50ee5fd76e2441cff/tests%2Fui%2Funused_peekable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_peekable.stderr?ref=2666c38acb8352b7fd5903f50ee5fd76e2441cff", "patch": "@@ -0,0 +1,51 @@\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:14:9\n+   |\n+LL |     let peekable = std::iter::empty::<u32>().peekable();\n+   |         ^^^^^^^^\n+   |\n+   = note: `-D clippy::unused-peekable` implied by `-D warnings`\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:18:9\n+   |\n+LL |     let new_local = old_local;\n+   |         ^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:22:9\n+   |\n+LL |     let by_mut_ref = &mut by_mut_ref_test;\n+   |         ^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:29:9\n+   |\n+LL |     let peekable_from_fn = returns_peekable();\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:32:13\n+   |\n+LL |     let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:35:13\n+   |\n+LL |     let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: aborting due to 6 previous errors\n+"}]}