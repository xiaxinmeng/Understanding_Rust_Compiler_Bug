{"sha": "e70e211e99b3b7a4c3d75ff56598662530828f65", "node_id": "C_kwDOAAsO6NoAKGU3MGUyMTFlOTliM2I3YTRjM2Q3NWZmNTY1OTg2NjI1MzA4MjhmNjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-25T09:09:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-25T09:09:48Z"}, "message": "Auto merge of #95082 - spastorino:overlap-inherent-impls, r=nikomatsakis\n\nOverlap inherent impls\n\nr? `@nikomatsakis`\n\nCloses #94526", "tree": {"sha": "08ec170499816df13205071fd07d828f8c08de75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08ec170499816df13205071fd07d828f8c08de75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e70e211e99b3b7a4c3d75ff56598662530828f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e70e211e99b3b7a4c3d75ff56598662530828f65", "html_url": "https://github.com/rust-lang/rust/commit/e70e211e99b3b7a4c3d75ff56598662530828f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e70e211e99b3b7a4c3d75ff56598662530828f65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a0c55046c7092d9e019dad03729e8d32e38df72", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0c55046c7092d9e019dad03729e8d32e38df72", "html_url": "https://github.com/rust-lang/rust/commit/8a0c55046c7092d9e019dad03729e8d32e38df72"}, {"sha": "42e986f77ba350f9cb28958d9ef19af06007ac1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e986f77ba350f9cb28958d9ef19af06007ac1c", "html_url": "https://github.com/rust-lang/rust/commit/42e986f77ba350f9cb28958d9ef19af06007ac1c"}], "stats": {"total": 242, "additions": 177, "deletions": 65}, "files": [{"sha": "ff8082840e1e0f29af1d4dbf84e9eee7618ece6f", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -28,7 +28,7 @@\n use super::*;\n \n use rustc_middle::ty::relate::{Relate, TypeRelation};\n-use rustc_middle::ty::Const;\n+use rustc_middle::ty::{Const, ImplSubject};\n \n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -272,6 +272,29 @@ impl<'a, 'tcx> Trace<'a, 'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ImplSubject<'tcx> {\n+    fn to_trace(\n+        tcx: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        match (a, b) {\n+            (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, trait_ref_a, trait_ref_b)\n+            }\n+            (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {\n+                ToTrace::to_trace(tcx, cause, a_is_expected, ty_a, ty_b)\n+            }\n+            (ImplSubject::Trait(_), ImplSubject::Inherent(_))\n+            | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {\n+                bug!(\"can not trace TraitRef and Ty\");\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for Ty<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "a9e22d16ee0506de64f6f8c1dde4883e00403458", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -7,10 +7,10 @@ pub mod nested_filter;\n pub mod place;\n \n use crate::ty::query::Providers;\n-use crate::ty::TyCtxt;\n+use crate::ty::{ImplSubject, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::*;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::DUMMY_SP;\n@@ -54,6 +54,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn parent_module(self, id: HirId) -> LocalDefId {\n         self.parent_module_from_def_id(id.owner)\n     }\n+\n+    pub fn impl_subject(self, def_id: DefId) -> ImplSubject<'tcx> {\n+        self.impl_trait_ref(def_id)\n+            .map(ImplSubject::Trait)\n+            .unwrap_or_else(|| ImplSubject::Inherent(self.type_of(def_id)))\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "31db66dc242f1c1f8373ab681c16f1a786ae031c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -44,6 +44,7 @@ use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n \n+use std::fmt::Debug;\n use std::hash::Hash;\n use std::ops::ControlFlow;\n use std::{fmt, str};\n@@ -172,6 +173,12 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n+#[derive(Copy, Clone, Debug, TypeFoldable)]\n+pub enum ImplSubject<'tcx> {\n+    Trait(TraitRef<'tcx>),\n+    Inherent(Ty<'tcx>),\n+}\n+\n #[derive(\n     Copy,\n     Clone,"}, {"sha": "d9b55563996bab580d050db2d2d9d4d517e244ed", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -7,7 +7,7 @@\n use crate::mir::interpret::{get_slice_bytes, ConstValue, GlobalAlloc, Scalar};\n use crate::ty::error::{ExpectedFound, TypeError};\n use crate::ty::subst::{GenericArg, GenericArgKind, Subst, SubstsRef};\n-use crate::ty::{self, Term, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, ImplSubject, Term, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n use rustc_span::DUMMY_SP;\n@@ -356,6 +356,30 @@ impl<'tcx> Relate<'tcx> for GeneratorWitness<'tcx> {\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for ImplSubject<'tcx> {\n+    #[inline]\n+    fn relate<R: TypeRelation<'tcx>>(\n+        relation: &mut R,\n+        a: ImplSubject<'tcx>,\n+        b: ImplSubject<'tcx>,\n+    ) -> RelateResult<'tcx, ImplSubject<'tcx>> {\n+        match (a, b) {\n+            (ImplSubject::Trait(trait_ref_a), ImplSubject::Trait(trait_ref_b)) => {\n+                let trait_ref = ty::TraitRef::relate(relation, trait_ref_a, trait_ref_b)?;\n+                Ok(ImplSubject::Trait(trait_ref))\n+            }\n+            (ImplSubject::Inherent(ty_a), ImplSubject::Inherent(ty_b)) => {\n+                let ty = Ty::relate(relation, ty_a, ty_b)?;\n+                Ok(ImplSubject::Inherent(ty))\n+            }\n+            (ImplSubject::Trait(_), ImplSubject::Inherent(_))\n+            | (ImplSubject::Inherent(_), ImplSubject::Trait(_)) => {\n+                bug!(\"can not relate TraitRef and Ty\");\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for Ty<'tcx> {\n     #[inline]\n     fn relate<R: TypeRelation<'tcx>>("}, {"sha": "ec4f8084e212d437047b24f1f74731afdc9b63ce", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -7,7 +7,7 @@\n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{CombinedSnapshot, InferOk, RegionckMode};\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::util::impl_trait_ref_and_oblig;\n+use crate::traits::util::impl_subject_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n     self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n@@ -23,9 +23,10 @@ use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{self, TreatParams};\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n+use std::fmt::Debug;\n use std::iter;\n \n /// Whether we do the orphan check relative to this crate or\n@@ -300,60 +301,62 @@ fn negative_impl<'cx, 'tcx>(\n     debug!(\"negative_impl(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n     let tcx = selcx.infcx().tcx;\n \n-    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n-    let impl1_env = tcx.param_env(impl1_def_id);\n-    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n-\n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     tcx.infer_ctxt().enter(|infcx| {\n-        // Normalize the trait reference. The WF rules ought to ensure\n-        // that this always succeeds.\n-        let impl1_trait_ref = match traits::fully_normalize(\n+        // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+        let impl_env = tcx.param_env(impl1_def_id);\n+        let subject1 = match traits::fully_normalize(\n             &infcx,\n             FulfillmentContext::new(),\n             ObligationCause::dummy(),\n-            impl1_env,\n-            impl1_trait_ref,\n+            impl_env,\n+            tcx.impl_subject(impl1_def_id),\n         ) {\n-            Ok(impl1_trait_ref) => impl1_trait_ref,\n-            Err(err) => {\n-                bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n-            }\n+            Ok(s) => s,\n+            Err(err) => bug!(\"failed to fully normalize {:?}: {:?}\", impl1_def_id, err),\n         };\n \n         // Attempt to prove that impl2 applies, given all of the above.\n         let selcx = &mut SelectionContext::new(&infcx);\n         let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n-        let (impl2_trait_ref, obligations) =\n-            impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n-\n-        // do the impls unify? If not, not disjoint.\n-        let Ok(InferOk { obligations: more_obligations, .. }) = infcx\n-            .at(&ObligationCause::dummy(), impl1_env)\n-            .eq(impl1_trait_ref, impl2_trait_ref)\n-        else {\n-            debug!(\n-                \"explicit_disjoint: {:?} does not unify with {:?}\",\n-                impl1_trait_ref, impl2_trait_ref\n-            );\n-            return false;\n-        };\n+        let (subject2, obligations) =\n+            impl_subject_and_oblig(selcx, impl_env, impl2_def_id, impl2_substs);\n \n-        let opt_failing_obligation = obligations\n-            .into_iter()\n-            .chain(more_obligations)\n-            .find(|o| negative_impl_exists(selcx, impl1_env, impl1_def_id, o));\n-\n-        if let Some(failing_obligation) = opt_failing_obligation {\n-            debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n-            true\n-        } else {\n-            false\n-        }\n+        !equate(&infcx, impl_env, impl1_def_id, subject1, subject2, obligations)\n     })\n }\n \n-/// Try to prove that a negative impl exist for the given obligation and their super predicates.\n+fn equate<'cx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'tcx>,\n+    impl_env: ty::ParamEnv<'tcx>,\n+    impl1_def_id: DefId,\n+    subject1: ImplSubject<'tcx>,\n+    subject2: ImplSubject<'tcx>,\n+    obligations: impl Iterator<Item = PredicateObligation<'tcx>>,\n+) -> bool {\n+    // do the impls unify? If not, not disjoint.\n+    let Ok(InferOk { obligations: more_obligations, .. }) =\n+        infcx.at(&ObligationCause::dummy(), impl_env).eq(subject1, subject2)\n+    else {\n+        debug!(\"explicit_disjoint: {:?} does not unify with {:?}\", subject1, subject2);\n+        return true;\n+    };\n+\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    let opt_failing_obligation = obligations\n+        .into_iter()\n+        .chain(more_obligations)\n+        .find(|o| negative_impl_exists(selcx, impl_env, impl1_def_id, o));\n+\n+    if let Some(failing_obligation) = opt_failing_obligation {\n+        debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n+/// Try to prove that a negative impl exist for the given obligation and its super predicates.\n #[instrument(level = \"debug\", skip(selcx))]\n fn negative_impl_exists<'cx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'tcx>,\n@@ -367,7 +370,7 @@ fn negative_impl_exists<'cx, 'tcx>(\n         return true;\n     }\n \n-    // Try to prove a negative obligation exist for super predicates\n+    // Try to prove a negative obligation exists for super predicates\n     for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n         if resolve_negative_obligation(infcx, param_env, region_context, &o) {\n             return true;"}, {"sha": "328e0d2e0e90a859ca51248c684fc3ccf6fd955a", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -20,12 +20,12 @@ use rustc_errors::{struct_span_err, EmissionGuarantee};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty::{self, ImplSubject, TyCtxt};\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::{Span, DUMMY_SP};\n \n-use super::util::impl_trait_ref_and_oblig;\n+use super::util;\n use super::{FulfillmentContext, SelectionContext};\n \n /// Information pertinent to an overlapping impl error.\n@@ -186,18 +186,20 @@ fn fulfill_implication<'a, 'tcx>(\n         param_env, source_trait_ref, target_impl\n     );\n \n+    let source_trait = ImplSubject::Trait(source_trait_ref);\n+\n     let selcx = &mut SelectionContext::new(&infcx);\n     let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n-    let (target_trait_ref, obligations) =\n-        impl_trait_ref_and_oblig(selcx, param_env, target_impl, target_substs);\n+    let (target_trait, obligations) =\n+        util::impl_subject_and_oblig(selcx, param_env, target_impl, target_substs);\n \n     // do the impls unify? If not, no specialization.\n     let Ok(InferOk { obligations: more_obligations, .. }) =\n-        infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait_ref, target_trait_ref)\n+        infcx.at(&ObligationCause::dummy(), param_env).eq(source_trait, target_trait)\n     else {\n         debug!(\n             \"fulfill_implication: {:?} does not unify with {:?}\",\n-            source_trait_ref, target_trait_ref\n+            source_trait, target_trait\n         );\n         return Err(());\n     };\n@@ -225,7 +227,7 @@ fn fulfill_implication<'a, 'tcx>(\n             [] => {\n                 debug!(\n                     \"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                    source_trait_ref, target_trait_ref\n+                    source_trait, target_trait\n                 );\n \n                 // Now resolve the *substitution* we built for the target earlier, replacing\n@@ -237,8 +239,8 @@ fn fulfill_implication<'a, 'tcx>(\n                 debug!(\n                     \"fulfill_implication: for impls on {:?} and {:?}, \\\n                      could not fulfill: {:?} given {:?}\",\n-                    source_trait_ref,\n-                    target_trait_ref,\n+                    source_trait,\n+                    target_trait,\n                     errors,\n                     param_env.caller_bounds()\n                 );"}, {"sha": "7543d1f9a7b5532693d13bb990ce17d14618570a", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -6,7 +6,7 @@ use smallvec::SmallVec;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeFoldable};\n \n use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n pub use rustc_infer::traits::{self, util::*};\n@@ -190,19 +190,19 @@ impl Iterator for SupertraitDefIds<'_> {\n // Other\n ///////////////////////////////////////////////////////////////////////////\n \n-/// Instantiate all bound parameters of the impl with the given substs,\n-/// returning the resulting trait ref and all obligations that arise.\n+/// Instantiate all bound parameters of the impl subject with the given substs,\n+/// returning the resulting subject and all obligations that arise.\n /// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n+pub fn impl_subject_and_oblig<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     impl_def_id: DefId,\n     impl_substs: SubstsRef<'tcx>,\n-) -> (ty::TraitRef<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n-    let impl_trait_ref = selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n-    let impl_trait_ref = impl_trait_ref.subst(selcx.tcx(), impl_substs);\n-    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), impl_trait_ref);\n+) -> (ImplSubject<'tcx>, impl Iterator<Item = PredicateObligation<'tcx>>) {\n+    let subject = selcx.tcx().impl_subject(impl_def_id);\n+    let subject = subject.subst(selcx.tcx(), impl_substs);\n+    let Normalized { value: subject, obligations: normalization_obligations1 } =\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), subject);\n \n     let predicates = selcx.tcx().predicates_of(impl_def_id);\n     let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n@@ -215,7 +215,7 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n         .chain(normalization_obligations1.into_iter())\n         .chain(normalization_obligations2.into_iter());\n \n-    (impl_trait_ref, impl_obligations)\n+    (subject, impl_obligations)\n }\n \n pub fn predicates_for_generics<'tcx>("}, {"sha": "39ccaa6ac3542a1e914bfc242360c21c97b034f6", "filename": "src/test/ui/coherence/coherence-negative-inherent-where-bounds.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent-where-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent-where-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent-where-bounds.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+#![feature(with_negative_coherence)]\n+\n+trait Foo {}\n+\n+impl !Foo for u32 {}\n+\n+#[rustc_strict_coherence]\n+struct MyStruct<T>(T);\n+\n+impl MyStruct<u32> {\n+    fn method(&self) {}\n+}\n+\n+impl<T> MyStruct<T>\n+where\n+    T: Foo,\n+{\n+    fn method(&self) {}\n+}\n+\n+fn main() {}"}, {"sha": "a9e1acc8044a578f907b767082a20ca216d35a44", "filename": "src/test/ui/coherence/coherence-negative-inherent.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e70e211e99b3b7a4c3d75ff56598662530828f65/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e70e211e99b3b7a4c3d75ff56598662530828f65/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-negative-inherent.rs?ref=e70e211e99b3b7a4c3d75ff56598662530828f65", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+#![feature(with_negative_coherence)]\n+\n+#[rustc_strict_coherence]\n+trait Foo {}\n+\n+impl !Foo for u32 {}\n+\n+struct MyStruct<T>(T);\n+\n+impl<T: Foo> MyStruct<T> {\n+    fn method(&self) {}\n+}\n+\n+impl MyStruct<u32> {\n+    fn method(&self) {}\n+}\n+\n+fn main() {}"}]}