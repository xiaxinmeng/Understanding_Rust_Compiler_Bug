{"sha": "cdfad40735745252ad42519df8a6c8ecc3739b58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkZmFkNDA3MzU3NDUyNTJhZDQyNTE5ZGY4YTZjOGVjYzM3MzliNTg=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T20:04:51Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:47Z"}, "message": "trans: Condense the fn instantiation logic into callee.", "tree": {"sha": "63792ab6097efa08054d4ae60af4280a6664a466", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63792ab6097efa08054d4ae60af4280a6664a466"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdfad40735745252ad42519df8a6c8ecc3739b58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdfad40735745252ad42519df8a6c8ecc3739b58", "html_url": "https://github.com/rust-lang/rust/commit/cdfad40735745252ad42519df8a6c8ecc3739b58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdfad40735745252ad42519df8a6c8ecc3739b58/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b05556e06da7c79f9db746728c2557114a94b3b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b05556e06da7c79f9db746728c2557114a94b3b1", "html_url": "https://github.com/rust-lang/rust/commit/b05556e06da7c79f9db746728c2557114a94b3b1"}], "stats": {"total": 663, "additions": 141, "deletions": 522}, "files": [{"sha": "d177bb396c902e86f33a5b8d6ad48574777b4ae5", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 219, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=cdfad40735745252ad42519df8a6c8ecc3739b58", "patch": "@@ -192,22 +192,6 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n     }\n }\n \n-fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                fn_ty: Ty<'tcx>,\n-                                name: &str,\n-                                attrs: &[ast::Attribute])\n-                                -> ValueRef {\n-    if let Some(n) = ccx.externs().borrow().get(name) {\n-        return *n;\n-    }\n-\n-    let f = declare::declare_rust_fn(ccx, name, fn_ty);\n-    attributes::from_fn_attrs(ccx, &attrs, f);\n-\n-    ccx.externs().borrow_mut().insert(name.to_string(), f);\n-    f\n-}\n-\n pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                        closure_id: DefId,\n                                        fn_ty: Ty<'tcx>)\n@@ -865,34 +849,6 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn get_extern_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               def_id: DefId)\n-                               -> datum::Datum<'tcx, datum::Rvalue> {\n-    let name = ccx.sess().cstore.item_symbol(def_id);\n-    let attrs = ccx.sess().cstore.item_attrs(def_id);\n-    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n-    match ty.sty {\n-        ty::TyFnDef(_, _, fty) => {\n-            let abi = fty.abi;\n-            let fty = infer::normalize_associated_type(ccx.tcx(), fty);\n-            let ty = ccx.tcx().mk_fn_ptr(fty);\n-            let llfn = match ccx.sess().target.target.adjust_abi(abi) {\n-                Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                    ccx.sess().bug(\"unexpected intrinsic in get_extern_fn\")\n-                }\n-                Abi::Rust | Abi::RustCall => {\n-                    get_extern_rust_fn(ccx, ty, &name, &attrs)\n-                }\n-                _ => {\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, &name, &attrs)\n-                }\n-            };\n-            datum::immediate_rvalue(llfn, ty)\n-        }\n-        _ => unreachable!(\"get_extern_fn: expected fn item type, found {}\", ty)\n-    }\n-}\n-\n pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n@@ -2186,20 +2142,11 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     Result::new(bcx, llresult)\n }\n \n-pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    ctor_id: ast::NodeId,\n-                                    param_substs: &'tcx Substs<'tcx>,\n-                                    llfndecl: ValueRef) {\n-    let _icx = push_ctxt(\"trans_tuple_struct\");\n-\n-    trans_enum_variant_or_tuple_like_struct(ccx, ctor_id, Disr(0), param_substs, llfndecl);\n-}\n-\n-fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                     ctor_id: ast::NodeId,\n-                                                     disr: Disr,\n-                                                     param_substs: &'tcx Substs<'tcx>,\n-                                                     llfndecl: ValueRef) {\n+pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 ctor_id: ast::NodeId,\n+                                 disr: Disr,\n+                                 param_substs: &'tcx Substs<'tcx>,\n+                                 llfndecl: ValueRef) {\n     let ctor_ty = ccx.tcx().node_id_to_type(ctor_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n \n@@ -2557,54 +2504,6 @@ pub fn trans_item(ccx: &CrateContext, item: &hir::Item) {\n     }\n }\n \n-// only use this for foreign function ABIs and glue, use `register_fn` for Rust functions\n-pub fn register_fn_llvmty(ccx: &CrateContext,\n-                          sp: Span,\n-                          sym: String,\n-                          node_id: ast::NodeId,\n-                          cc: llvm::CallConv,\n-                          llfty: Type)\n-                          -> ValueRef {\n-    debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n-\n-    let llfn = declare::define_fn(ccx, &sym[..], cc, llfty,\n-                                   ty::FnConverging(ccx.tcx().mk_nil())).unwrap_or_else(||{\n-        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n-    });\n-    finish_register_fn(ccx, sym, node_id);\n-    llfn\n-}\n-\n-fn finish_register_fn(ccx: &CrateContext, sym: String, node_id: ast::NodeId) {\n-    ccx.item_symbols().borrow_mut().insert(node_id, sym);\n-}\n-\n-fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                         sp: Span,\n-                         sym: String,\n-                         node_id: ast::NodeId,\n-                         node_type: Ty<'tcx>)\n-                         -> ValueRef {\n-    if let ty::TyFnDef(_, _, ref f) = node_type.sty {\n-        if f.abi != Abi::Rust && f.abi != Abi::RustCall {\n-            ccx.sess().span_bug(sp,\n-                                &format!(\"only the `{}` or `{}` calling conventions are valid \\\n-                                          for this function; `{}` was specified\",\n-                                         Abi::Rust.name(),\n-                                         Abi::RustCall.name(),\n-                                         f.abi.name()));\n-        }\n-    } else {\n-        ccx.sess().span_bug(sp, \"expected bare rust function\")\n-    }\n-\n-    let llfn = declare::define_rust_fn(ccx, &sym[..], node_type).unwrap_or_else(|| {\n-        ccx.sess().span_fatal(sp, &format!(\"symbol `{}` is already defined\", sym));\n-    });\n-    finish_register_fn(ccx, sym, node_id);\n-    llfn\n-}\n-\n pub fn is_entry_fn(sess: &Session, node_id: ast::NodeId) -> bool {\n     match *sess.entry_fn.borrow() {\n         Some((entry_id, _)) => node_id == entry_id,\n@@ -2724,119 +2623,6 @@ fn contains_null(s: &str) -> bool {\n     s.bytes().any(|b| b == 0)\n }\n \n-pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n-    debug!(\"get_item_val(id=`{}`)\", id);\n-\n-    if let Some(v) = ccx.item_vals().borrow().get(&id).cloned() {\n-        return v;\n-    }\n-\n-    let item = ccx.tcx().map.get(id);\n-    debug!(\"get_item_val: id={} item={:?}\", id, item);\n-    let val = match item {\n-        hir_map::NodeItem(i) => {\n-            let ty = ccx.tcx().node_id_to_type(i.id);\n-            let sym = || exported_name(ccx, id, ty, &i.attrs);\n-\n-            let v = match i.node {\n-\n-                hir::ItemFn(_, _, _, abi, _, _) => {\n-                    let sym = sym();\n-                    let llfn = if abi == Abi::Rust {\n-                        register_fn(ccx, i.span, sym, i.id, ty)\n-                    } else {\n-                        foreign::register_rust_fn_with_foreign_abi(ccx, i.span, sym, i.id)\n-                    };\n-                    attributes::from_fn_attrs(ccx, &i.attrs, llfn);\n-                    llfn\n-                }\n-\n-                _ => ccx.sess().bug(\"get_item_val: weird result in table\"),\n-            };\n-\n-            v\n-        }\n-\n-        hir_map::NodeTraitItem(trait_item) => {\n-            debug!(\"get_item_val(): processing a NodeTraitItem\");\n-            match trait_item.node {\n-                hir::MethodTraitItem(_, Some(_)) => {\n-                    register_method(ccx, id, &trait_item.attrs, trait_item.span)\n-                }\n-                _ => {\n-                    ccx.sess().span_bug(trait_item.span,\n-                                        \"unexpected variant: trait item other than a provided \\\n-                                         method in get_item_val()\");\n-                }\n-            }\n-        }\n-\n-        hir_map::NodeImplItem(impl_item) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(..) => {\n-                    register_method(ccx, id, &impl_item.attrs, impl_item.span)\n-                }\n-                _ => {\n-                    ccx.sess().span_bug(impl_item.span,\n-                                        \"unexpected variant: non-method impl item in \\\n-                                         get_item_val()\");\n-                }\n-            }\n-        }\n-\n-        hir_map::NodeForeignItem(ni) => {\n-            match ni.node {\n-                hir::ForeignItemFn(..) => {\n-                    let abi = ccx.tcx().map.get_foreign_abi(id);\n-                    let ty = ccx.tcx().node_id_to_type(ni.id);\n-                    let name = foreign::link_name(&ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, &name, &ni.attrs)\n-                }\n-                hir::ForeignItemStatic(..) => {\n-                    foreign::register_static(ccx, &ni)\n-                }\n-            }\n-        }\n-        ref variant => {\n-            ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\", variant))\n-        }\n-    };\n-\n-    // All LLVM globals and functions are initially created as external-linkage\n-    // declarations.  If `trans_item`/`trans_fn` later turns the declaration\n-    // into a definition, it adjusts the linkage then (using `update_linkage`).\n-    //\n-    // The exception is foreign items, which have their linkage set inside the\n-    // call to `foreign::register_*` above.  We don't touch the linkage after\n-    // that (`foreign::trans_foreign_mod` doesn't adjust the linkage like the\n-    // other item translation functions do).\n-\n-    ccx.item_vals().borrow_mut().insert(id, val);\n-    val\n-}\n-\n-fn register_method(ccx: &CrateContext,\n-                   id: ast::NodeId,\n-                   attrs: &[ast::Attribute],\n-                   span: Span)\n-                   -> ValueRef {\n-    let mty = ccx.tcx().node_id_to_type(id);\n-\n-    let sym = exported_name(ccx, id, mty, &attrs);\n-\n-    if let ty::TyFnDef(_, _, ref f) = mty.sty {\n-        let llfn = if f.abi == Abi::Rust || f.abi == Abi::RustCall {\n-            register_fn(ccx, span, sym, id, mty)\n-        } else {\n-            foreign::register_rust_fn_with_foreign_abi(ccx, span, sym, id)\n-        };\n-        attributes::from_fn_attrs(ccx, &attrs, llfn);\n-        return llfn;\n-    } else {\n-        ccx.sess().span_bug(span, \"expected bare rust function\");\n-    }\n-}\n-\n pub fn write_metadata<'a, 'tcx>(cx: &SharedCrateContext<'a, 'tcx>,\n                                 krate: &hir::Crate,\n                                 reachable: &NodeSet,"}, {"sha": "65724405db1b379d639bb35afc83794bb249983b", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 74, "deletions": 35, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=cdfad40735745252ad42519df8a6c8ecc3739b58", "patch": "@@ -25,15 +25,17 @@ use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n use middle::subst::{Substs};\n+use middle::traits;\n use rustc::front::map as hir_map;\n use trans::adt;\n+use trans::attributes;\n use trans::base;\n use trans::base::*;\n use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n-use trans::common::{self, Block, Result, NodeIdAndSpan, ExprId, CrateContext,\n-                    ExprOrMethodCall, FunctionContext, MethodCallKey};\n+use trans::closure;\n+use trans::common::{self, Block, Result, NodeIdAndSpan, CrateContext, FunctionContext};\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n@@ -44,7 +46,7 @@ use trans::inline;\n use trans::foreign;\n use trans::intrinsic;\n use trans::meth;\n-use trans::monomorphize;\n+use trans::monomorphize::{self, Instance};\n use trans::type_::Type;\n use trans::type_of;\n use trans::value::Value;\n@@ -442,46 +444,80 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(def_id.krate, LOCAL_CRATE);\n \n         let substs = tcx.mk_substs(substs.clone().erase_regions());\n-        let (mut val, fn_ty, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, substs);\n-        let fn_ty = ref_ty.unwrap_or(fn_ty);\n+        let (val, fn_ty) = monomorphize::monomorphic_fn(ccx, def_id, substs);\n         let fn_ptr_ty = match fn_ty.sty {\n             ty::TyFnDef(_, _, fty) => {\n                 // Create a fn pointer with the substituted signature.\n                 tcx.mk_ty(ty::TyFnPtr(fty))\n             }\n             _ => unreachable!(\"expected fn item type, found {}\", fn_ty)\n         };\n-        if must_cast && ref_ty.is_some() {\n-            let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n-            if llptrty != common::val_ty(val) {\n-                val = consts::ptrcast(val, llptrty);\n-            }\n-        }\n+        assert_eq!(type_of::type_of(ccx, fn_ptr_ty), common::val_ty(val));\n         return immediate_rvalue(val, fn_ptr_ty);\n     }\n \n     // Find the actual function pointer.\n-    let local_node = ccx.tcx().map.as_local_node_id(def_id);\n-    let mut datum = if let Some(node_id) = local_node {\n-        // Type scheme of the function item (may have type params)\n-        let fn_type_scheme = tcx.lookup_item_type(def_id);\n-        let fn_type = match fn_type_scheme.ty.sty {\n-            ty::TyFnDef(_, _, fty) => {\n-                // Create a fn pointer with the normalized signature.\n-                tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n+    let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+    let fn_ptr_ty = match ty.sty {\n+        ty::TyFnDef(_, _, fty) => {\n+            // Create a fn pointer with the normalized signature.\n+            tcx.mk_fn_ptr(infer::normalize_associated_type(tcx, fty))\n+        }\n+        _ => unreachable!(\"expected fn item type, found {}\", ty)\n+    };\n+\n+    let instance = Instance::mono(ccx.tcx(), def_id);\n+    if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n+        return immediate_rvalue(llfn, fn_ptr_ty);\n+    }\n+\n+    let attrs;\n+    let local_id = ccx.tcx().map.as_local_node_id(def_id);\n+    let maybe_node = local_id.and_then(|id| tcx.map.find(id));\n+    let (sym, attrs, local_item) = match maybe_node {\n+        Some(hir_map::NodeItem(&hir::Item {\n+            ref attrs, id, span, node: hir::ItemFn(..), ..\n+        })) |\n+        Some(hir_map::NodeTraitItem(&hir::TraitItem {\n+            ref attrs, id, span, node: hir::MethodTraitItem(_, Some(_)), ..\n+        })) |\n+        Some(hir_map::NodeImplItem(&hir::ImplItem {\n+            ref attrs, id, span, node: hir::ImplItemKind::Method(..), ..\n+        })) => {\n+            let sym = exported_name(ccx, id, ty, attrs);\n+\n+            if declare::get_defined_value(ccx, &sym).is_some() {\n+                ccx.sess().span_fatal(span,\n+                    &format!(\"symbol `{}` is already defined\", sym));\n             }\n-            _ => unreachable!(\"expected fn item type, found {}\",\n-                              fn_type_scheme.ty)\n-        };\n \n-        // Internal reference.\n-        immediate_rvalue(get_item_val(ccx, node_id), fn_type)\n-    } else {\n-        // External reference.\n-        get_extern_fn(ccx, def_id)\n+            (sym, &attrs[..], Some(id))\n+        }\n+\n+        Some(hir_map::NodeForeignItem(&hir::ForeignItem {\n+            ref attrs, name, node: hir::ForeignItemFn(..), ..\n+        })) => {\n+            (foreign::link_name(name, attrs).to_string(), &attrs[..], None)\n+        }\n+\n+        None => {\n+            attrs = ccx.sess().cstore.item_attrs(def_id);\n+            (ccx.sess().cstore.item_symbol(def_id), &attrs[..], None)\n+        }\n+\n+        ref variant => {\n+            ccx.sess().bug(&format!(\"get_fn: unexpected variant: {:?}\", variant))\n+        }\n     };\n \n+    let llfn = declare::declare_fn(ccx, &sym, ty);\n+    attributes::from_fn_attrs(ccx, attrs, llfn);\n+    if let Some(id) = local_item {\n+        // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+        attributes::unwind(llfn, true);\n+        ccx.item_symbols().borrow_mut().insert(id, sym);\n+    }\n+\n     // This is subtle and surprising, but sometimes we have to bitcast\n     // the resulting fn pointer.  The reason has to do with external\n     // functions.  If you have two crates that both bind the same C\n@@ -505,15 +541,18 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llptrty = type_of::type_of(ccx, datum.ty);\n-    if common::val_ty(datum.val) != llptrty {\n-        debug!(\"trans_fn_ref_with_substs(): casting pointer!\");\n-        datum.val = consts::ptrcast(datum.val, llptrty);\n+    let llptrty = type_of::type_of(ccx, fn_ptr_ty);\n+    let llfn = if common::val_ty(llfn) != llptrty {\n+        debug!(\"get_fn: casting {:?} to {:?}\", llfn, llptrty);\n+        consts::ptrcast(llfn, llptrty)\n     } else {\n-        debug!(\"trans_fn_ref_with_substs(): not casting pointer!\");\n-    }\n+        debug!(\"get_fn: not casting pointer!\");\n+        llfn\n+    };\n+\n+    ccx.instances().borrow_mut().insert(instance, llfn);\n \n-    datum\n+    immediate_rvalue(llfn, fn_ptr_ty)\n }\n \n // ______________________________________________________________________"}, {"sha": "b38050d2467e3182fd04836bba91da148fb93cf3", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=cdfad40735745252ad42519df8a6c8ecc3739b58", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::mir_map::MirMap;\n use trans::adt;\n use trans::base;\n use trans::builder::Builder;\n-use trans::common::{ExternMap,BuilderRef_res};\n+use trans::common::BuilderRef_res;\n use trans::debuginfo;\n use trans::declare;\n use trans::glue::DropGlueKind;\n@@ -90,8 +90,6 @@ pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n     tn: TypeNames,\n-    externs: RefCell<ExternMap>,\n-    item_vals: RefCell<NodeMap<ValueRef>>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n     fn_pointer_shims: RefCell<FnvHashMap<Ty<'tcx>, ValueRef>>,\n     drop_glues: RefCell<FnvHashMap<DropGlueKind<'tcx>, ValueRef>>,\n@@ -464,8 +462,6 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 llmod: llmod,\n                 llcx: llcx,\n                 tn: TypeNames::new(),\n-                externs: RefCell::new(FnvHashMap()),\n-                item_vals: RefCell::new(NodeMap()),\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n                 fn_pointer_shims: RefCell::new(FnvHashMap()),\n                 drop_glues: RefCell::new(FnvHashMap()),\n@@ -616,14 +612,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.tn\n     }\n \n-    pub fn externs<'a>(&'a self) -> &'a RefCell<ExternMap> {\n-        &self.local.externs\n-    }\n-\n-    pub fn item_vals<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n-        &self.local.item_vals\n-    }\n-\n     pub fn export_map<'a>(&'a self) -> &'a ExportMap {\n         &self.shared.export_map\n     }"}, {"sha": "0c8ac32ecc11370ab74e9888b863289bdbc2ffd9", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 96, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=cdfad40735745252ad42519df8a6c8ecc3739b58", "patch": "@@ -10,7 +10,7 @@\n \n \n use back::{abi, link};\n-use llvm::{ValueRef, CallConv, get_param};\n+use llvm::{ValueRef, get_param};\n use llvm;\n use middle::weak_lang_items;\n use trans::attributes;\n@@ -37,12 +37,10 @@ use std::iter::once;\n use libc::c_uint;\n use syntax::abi::Abi;\n use syntax::attr;\n-use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n \n-use rustc_front::print::pprust;\n use rustc_front::hir;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -112,56 +110,6 @@ pub fn register_static(ccx: &CrateContext,\n     return c;\n }\n \n-// only use this for foreign function ABIs and glue, use `get_extern_rust_fn` for Rust functions\n-pub fn get_extern_fn(ccx: &CrateContext,\n-                     externs: &mut ExternMap,\n-                     name: &str,\n-                     cc: llvm::CallConv,\n-                     ty: Type,\n-                     output: Ty)\n-                     -> ValueRef {\n-    match externs.get(name) {\n-        Some(n) => return *n,\n-        None => {}\n-    }\n-    let f = declare::declare_fn(ccx, name, cc, ty, ty::FnConverging(output));\n-    externs.insert(name.to_string(), f);\n-    f\n-}\n-\n-/// Registers a foreign function found in a library. Just adds a LLVM global.\n-pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                          abi: Abi, fty: Ty<'tcx>,\n-                                          name: &str,\n-                                          attrs: &[ast::Attribute])-> ValueRef {\n-    debug!(\"register_foreign_item_fn(abi={:?}, \\\n-            ty={:?}, \\\n-            name={})\",\n-           abi,\n-           fty,\n-           name);\n-\n-    let cc = llvm_calling_convention(ccx, abi);\n-\n-    // Register the function as a C extern fn\n-    let tys = foreign_types_for_fn_ty(ccx, fty);\n-\n-    // Make sure the calling convention is right for variadic functions\n-    // (should've been caught if not in typeck)\n-    if tys.fn_sig.variadic {\n-        assert!(cc == llvm::CCallConv);\n-    }\n-\n-    // Create the LLVM value for the C extern fn\n-    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-\n-    let llfn = get_extern_fn(ccx, &mut *ccx.externs().borrow_mut(), name, cc, llfn_ty, fty);\n-    attributes::unwind(llfn, false);\n-    add_argument_attributes(&tys, llfn);\n-    attributes::from_fn_attrs(ccx, attrs, llfn);\n-    llfn\n-}\n-\n /// Prepares a call to a native function. This requires adapting\n /// from the Rust argument passing rules to the native rules.\n ///\n@@ -414,49 +362,6 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // inline the one into the other. Of course we could just generate the\n // correct code in the first place, but this is much simpler.\n \n-pub fn decl_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                               t: Ty<'tcx>,\n-                                               name: &str)\n-                                               -> ValueRef {\n-    let tys = foreign_types_for_fn_ty(ccx, t);\n-    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let cconv = match t.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => {\n-            llvm_calling_convention(ccx, fn_ty.abi)\n-        }\n-        _ => panic!(\"expected bare fn in decl_rust_fn_with_foreign_abi\")\n-    };\n-    let llfn = declare::declare_fn(ccx, name, cconv, llfn_ty,\n-                                   ty::FnConverging(ccx.tcx().mk_nil()));\n-    add_argument_attributes(&tys, llfn);\n-    debug!(\"decl_rust_fn_with_foreign_abi(llfn_ty={:?}, llfn={:?})\",\n-           llfn_ty, Value(llfn));\n-    llfn\n-}\n-\n-pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n-                                         sp: Span,\n-                                         sym: String,\n-                                         node_id: ast::NodeId)\n-                                         -> ValueRef {\n-    let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n-\n-    let t = ccx.tcx().node_id_to_type(node_id);\n-    let cconv = match t.sty {\n-        ty::TyFnDef(_, _, ref fn_ty) | ty::TyFnPtr(ref fn_ty) => {\n-            llvm_calling_convention(ccx, fn_ty.abi)\n-        }\n-        _ => panic!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n-    };\n-    let tys = foreign_types_for_fn_ty(ccx, t);\n-    let llfn_ty = lltype_for_fn_from_foreign_types(ccx, &tys);\n-    let llfn = base::register_fn_llvmty(ccx, sp, sym, node_id, cconv, llfn_ty);\n-    add_argument_attributes(&tys, llfn);\n-    debug!(\"register_rust_fn_with_foreign_abi(node_id={}, llfn_ty={:?}, llfn={:?})\",\n-           node_id, llfn_ty, Value(llfn));\n-    llfn\n-}\n-\n pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 decl: &hir::FnDecl,\n                                                 body: &hir::Block,"}, {"sha": "fcbf0bdf790b489dc7901e49752f71adf741ac3e", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 60, "deletions": 159, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdfad40735745252ad42519df8a6c8ecc3739b58/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=cdfad40735745252ad42519df8a6c8ecc3739b58", "patch": "@@ -17,7 +17,7 @@ use middle::subst;\n use middle::subst::{Subst, Substs};\n use middle::ty::fold::{TypeFolder, TypeFoldable};\n use trans::attributes;\n-use trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n+use trans::base::{push_ctxt};\n use trans::base::trans_fn;\n use trans::base;\n use trans::common::*;\n@@ -31,7 +31,6 @@ use rustc::util::ppaux;\n use rustc_front::hir;\n \n use syntax::abi::Abi;\n-use syntax::ast;\n use syntax::attr;\n use syntax::errors;\n \n@@ -41,14 +40,11 @@ use std::hash::{Hasher, Hash, SipHasher};\n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: DefId,\n                                 psubsts: &'tcx subst::Substs<'tcx>)\n-                                -> (ValueRef, Ty<'tcx>, bool) {\n+                                -> (ValueRef, Ty<'tcx>) {\n     debug!(\"monomorphic_fn(fn_id={:?}, real_substs={:?})\", fn_id, psubsts);\n \n     assert!(!psubsts.types.needs_infer() && !psubsts.types.has_param_types());\n \n-    // we can only monomorphize things in this crate (or inlined into it)\n-    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n-\n     let _icx = push_ctxt(\"monomorphic_fn\");\n \n     let instance = Instance {\n@@ -72,25 +68,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"monomorphic_fn({:?})\", instance);\n \n-\n-    let map_node = errors::expect(\n-        ccx.sess().diagnostic(),\n-        ccx.tcx().map.find(fn_node_id),\n-        || {\n-            format!(\"while instantiating `{}`, couldn't find it in \\\n-                     the item map (may have attempted to monomorphize \\\n-                     an item defined in a different crate?)\",\n-                    instance)\n-        });\n-\n-    if let hir_map::NodeForeignItem(_) = map_node {\n-        let abi = ccx.tcx().map.get_foreign_abi(fn_node_id);\n-        if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n-            // Foreign externs don't have to be monomorphized.\n-            return (get_item_val(ccx, fn_node_id), mono_ty, true);\n-        }\n-    }\n-\n     ccx.stats().n_monos.set(ccx.stats().n_monos.get() + 1);\n \n     let depth;\n@@ -132,155 +109,79 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"monomorphize_fn mangled to {}\", s);\n     assert!(declare::get_defined_value(ccx, &s).is_none());\n \n-    // This shouldn't need to option dance.\n-    let mut hash_id = Some(hash_id);\n-    let mut mk_lldecl = |abi: Abi| {\n-        let lldecl = if abi != Abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s)\n-        } else {\n-            // FIXME(nagisa): perhaps needs a more fine grained selection? See\n-            // setup_lldecl below.\n-            declare::define_internal_rust_fn(ccx, &s, mono_ty)\n-        };\n+    // FIXME(nagisa): perhaps needs a more fine grained selection?\n+    let lldecl = declare::define_internal_fn(ccx, &s, mono_ty);\n+    // FIXME(eddyb) Doubt all extern fn should allow unwinding.\n+    attributes::unwind(lldecl, true);\n \n-        ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n-        lldecl\n-    };\n-    let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n-        base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n-        attributes::from_fn_attrs(ccx, attrs, lldecl);\n-\n-        let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n-        if is_first {\n-            ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n-        }\n-\n-        let trans_everywhere = attr::requests_inline(attrs);\n-        if trans_everywhere && !is_first {\n-            llvm::SetLinkage(lldecl, llvm::AvailableExternallyLinkage);\n-        }\n+    ccx.instances().borrow_mut().insert(instance, lldecl);\n \n-        // If `true`, then `lldecl` should be given a function body.\n-        // Otherwise, it should be left as a declaration of an external\n-        // function, with no definition in the current compilation unit.\n-        trans_everywhere || is_first\n-    };\n+    // we can only monomorphize things in this crate (or inlined into it)\n+    let fn_node_id = ccx.tcx().map.as_local_node_id(fn_id).unwrap();\n+    let map_node = errors::expect(\n+        ccx.sess().diagnostic(),\n+        ccx.tcx().map.find(fn_node_id),\n+        || {\n+            format!(\"while instantiating `{}`, couldn't find it in \\\n+                     the item map (may have attempted to monomorphize \\\n+                     an item defined in a different crate?)\",\n+                    instance)\n+        });\n+    match map_node {\n+        hir_map::NodeItem(&hir::Item {\n+            ref attrs, node: hir::ItemFn(ref decl, _, _, abi, _, ref body), ..\n+        }) |\n+        hir_map::NodeTraitItem(&hir::TraitItem {\n+            ref attrs, node: hir::MethodTraitItem(\n+                hir::MethodSig { abi, ref decl, .. }, Some(ref body)), ..\n+        }) |\n+        hir_map::NodeImplItem(&hir::ImplItem {\n+            ref attrs, node: hir::ImplItemKind::Method(\n+                hir::MethodSig { abi, ref decl, .. }, ref body), ..\n+        }) => {\n+            base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n+            attributes::from_fn_attrs(ccx, attrs, lldecl);\n+\n+            let is_first = !ccx.available_monomorphizations().borrow().contains(&s);\n+            if is_first {\n+                ccx.available_monomorphizations().borrow_mut().insert(s.clone());\n+            }\n \n-    let lldecl = match map_node {\n-        hir_map::NodeItem(i) => {\n-            match *i {\n-              hir::Item {\n-                  node: hir::ItemFn(ref decl, _, _, abi, _, ref body),\n-                  ..\n-              } => {\n-                  let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, &i.attrs);\n-                  if needs_body {\n-                      if abi != Abi::Rust {\n-                          foreign::trans_rust_fn_with_foreign_abi(\n-                              ccx, &decl, &body, &[], d, psubsts, fn_node_id,\n-                              Some(&hash[..]));\n-                      } else {\n-                          trans_fn(ccx,\n-                                   &decl,\n-                                   &body,\n-                                   d,\n-                                   psubsts,\n-                                   fn_node_id,\n-                                   &i.attrs);\n-                      }\n-                  }\n-\n-                  d\n-              }\n-              _ => {\n-                ccx.sess().bug(\"Can't monomorphize this kind of item\")\n-              }\n+            let trans_everywhere = attr::requests_inline(attrs);\n+            if trans_everywhere && !is_first {\n+                llvm::SetLinkage(lldecl, llvm::AvailableExternallyLinkage);\n             }\n-        }\n-        hir_map::NodeVariant(v) => {\n-            let variant = inlined_variant_def(ccx, fn_node_id);\n-            assert_eq!(v.node.name, variant.name);\n-            let d = mk_lldecl(Abi::Rust);\n-            attributes::inline(d, attributes::InlineAttr::Hint);\n-            trans_enum_variant(ccx, fn_node_id, Disr::from(variant.disr_val), psubsts, d);\n-            d\n-        }\n-        hir_map::NodeImplItem(impl_item) => {\n-            match impl_item.node {\n-                hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    let d = mk_lldecl(Abi::Rust);\n-                    let needs_body = setup_lldecl(d, &impl_item.attrs);\n-                    if needs_body {\n-                        trans_fn(ccx,\n-                                 &sig.decl,\n-                                 body,\n-                                 d,\n-                                 psubsts,\n-                                 impl_item.id,\n-                                 &impl_item.attrs);\n-                    }\n-                    d\n-                }\n-                _ => {\n-                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                           map_node))\n+\n+            if trans_everywhere || is_first {\n+                if abi != Abi::Rust && abi != Abi::RustCall {\n+                    foreign::trans_rust_fn_with_foreign_abi(\n+                        ccx, decl, body, attrs, lldecl, psubsts, fn_node_id,\n+                        Some(&hash));\n+                } else {\n+                    trans_fn(ccx, decl, body, lldecl, psubsts, fn_node_id, attrs);\n                 }\n             }\n         }\n-        hir_map::NodeTraitItem(trait_item) => {\n-            match trait_item.node {\n-                hir::MethodTraitItem(ref sig, Some(ref body)) => {\n-                    let d = mk_lldecl(Abi::Rust);\n-                    let needs_body = setup_lldecl(d, &trait_item.attrs);\n-                    if needs_body {\n-                        trans_fn(ccx,\n-                                 &sig.decl,\n-                                 body,\n-                                 d,\n-                                 psubsts,\n-                                 trait_item.id,\n-                                 &trait_item.attrs);\n-                    }\n-                    d\n-                }\n-                _ => {\n-                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                           map_node))\n+\n+        hir_map::NodeVariant(_) | hir_map::NodeStructCtor(_) => {\n+            let disr = match map_node {\n+                hir_map::NodeVariant(_) => {\n+                    Disr::from(inlined_variant_def(ccx, fn_node_id).disr_val)\n                 }\n-            }\n-        }\n-        hir_map::NodeStructCtor(struct_def) => {\n-            let d = mk_lldecl(Abi::Rust);\n-            attributes::inline(d, attributes::InlineAttr::Hint);\n-            if struct_def.is_struct() {\n-                panic!(\"ast-mapped struct didn't have a ctor id\")\n-            }\n-            base::trans_tuple_struct(ccx,\n-                                     struct_def.id(),\n-                                     psubsts,\n-                                     d);\n-            d\n+                hir_map::NodeStructCtor(_) => Disr(0),\n+                _ => unreachable!()\n+            };\n+            attributes::inline(lldecl, attributes::InlineAttr::Hint);\n+            base::trans_ctor_shim(ccx, fn_node_id, disr, psubsts, lldecl);\n         }\n \n-        // Ugh -- but this ensures any new variants won't be forgotten\n-        hir_map::NodeForeignItem(..) |\n-        hir_map::NodeLifetime(..) |\n-        hir_map::NodeTyParam(..) |\n-        hir_map::NodeExpr(..) |\n-        hir_map::NodeStmt(..) |\n-        hir_map::NodeBlock(..) |\n-        hir_map::NodePat(..) |\n-        hir_map::NodeLocal(..) => {\n-            ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                   map_node))\n-        }\n+        _ => unreachable!(\"can't monomorphize a {:?}\", map_node)\n     };\n \n     ccx.monomorphizing().borrow_mut().insert(fn_id, depth);\n \n     debug!(\"leaving monomorphic fn {}\", ccx.tcx().item_path_str(fn_id));\n-    (lldecl, mono_ty, true)\n+    (lldecl, mono_ty)\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]"}]}