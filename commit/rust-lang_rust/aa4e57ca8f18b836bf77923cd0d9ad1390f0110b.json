{"sha": "aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNGU1N2NhOGYxOGI4MzZiZjc3OTIzY2QwZDlhZDEzOTBmMDExMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-31T15:15:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-31T15:15:53Z"}, "message": "Auto merge of #65091 - sekineh:into-iter-sorted, r=KodrAus\n\nImplement ordered/sorted iterators on BinaryHeap as per #59278\n\nI've implemented the ordered version of iterator on BinaryHeap as per #59278.\n\n# Added methods:\n\n* `.into_iter_sorted()`\n  * like `.into_iter()`; but returns elements in heap order\n* `.drain_sorted()`\n  * like `.drain()`; but returns elements in heap order\n  * It's a bit _lazy_; elements are removed on drop. (Edit: it\u2019s similar to vec::Drain)\n\nFor `DrainSorted` struct, I implemented `Drop` trait following @scottmcm 's [suggestion](https://github.com/rust-lang/rust/issues/59278#issuecomment-537306925)\n\n# ~TODO~ DONE\n* ~I think I need to add more tests other than doctest.~\n\n# **Notes:**\n* we renamed `_ordered` to `_sorted`, because the latter is more common in rust libs. (as suggested by @KodrAus )", "tree": {"sha": "ed4e7119840dea12d6ec237a7e018edfc5d8c63b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed4e7119840dea12d6ec237a7e018edfc5d8c63b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "html_url": "https://github.com/rust-lang/rust/commit/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92df638162b7ccea6f97a8e1287ed05c5c0818b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/92df638162b7ccea6f97a8e1287ed05c5c0818b4", "html_url": "https://github.com/rust-lang/rust/commit/92df638162b7ccea6f97a8e1287ed05c5c0818b4"}, {"sha": "95442ae251d24c062ca317dcafdf3240f3cec846", "url": "https://api.github.com/repos/rust-lang/rust/commits/95442ae251d24c062ca317dcafdf3240f3cec846", "html_url": "https://github.com/rust-lang/rust/commit/95442ae251d24c062ca317dcafdf3240f3cec846"}], "stats": {"total": 209, "additions": 204, "deletions": 5}, "files": [{"sha": "fda6f090fd7795c4a19d831e29f1a6723ea2847f", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 129, "deletions": 1, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "patch": "@@ -146,7 +146,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::ops::{Deref, DerefMut};\n-use core::iter::{FromIterator, FusedIterator};\n+use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::mem::{swap, size_of, ManuallyDrop};\n use core::ptr;\n use core::fmt;\n@@ -648,6 +648,36 @@ impl<T: Ord> BinaryHeap<T> {\n             self.extend(other.drain());\n         }\n     }\n+\n+    /// Returns an iterator which retrieves elements in heap order.\n+    /// The retrieved elements are removed from the original heap.\n+    /// The remaining elements will be removed on drop in heap order.\n+    ///\n+    /// Note:\n+    /// * `.drain_sorted()` is O(n lg n); much slower than `.drain()`.\n+    ///   You should use the latter for most cases.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_drain_sorted)]\n+    /// use std::collections::BinaryHeap;\n+    ///\n+    /// let mut heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    /// assert_eq!(heap.len(), 5);\n+    ///\n+    /// drop(heap.drain_sorted()); // removes all elements in heap order\n+    /// assert_eq!(heap.len(), 0);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+    pub fn drain_sorted(&mut self) -> DrainSorted<'_, T> {\n+        DrainSorted {\n+            inner: self,\n+        }\n+    }\n }\n \n impl<T> BinaryHeap<T> {\n@@ -672,6 +702,27 @@ impl<T> BinaryHeap<T> {\n         Iter { iter: self.data.iter() }\n     }\n \n+    /// Returns an iterator which retrieves elements in heap order.\n+    /// This method consumes the original heap.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(binary_heap_into_iter_sorted)]\n+    /// use std::collections::BinaryHeap;\n+    /// let heap = BinaryHeap::from(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(heap.into_iter_sorted().take(2).collect::<Vec<_>>(), vec![5, 4]);\n+    /// ```\n+    #[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+    pub fn into_iter_sorted(self) -> IntoIterSorted<T> {\n+        IntoIterSorted {\n+            inner: self,\n+        }\n+    }\n+\n     /// Returns the greatest item in the binary heap, or `None` if it is empty.\n     ///\n     /// # Examples\n@@ -1115,6 +1166,37 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+#[derive(Clone, Debug)]\n+pub struct IntoIterSorted<T> {\n+    inner: BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> Iterator for IntoIterSorted<T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = self.inner.len();\n+        (exact, Some(exact))\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> ExactSizeIterator for IntoIterSorted<T> {}\n+\n+#[unstable(feature = \"binary_heap_into_iter_sorted\", issue = \"59278\")]\n+impl<T: Ord> FusedIterator for IntoIterSorted<T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T: Ord> TrustedLen for IntoIterSorted<T> {}\n+\n /// A draining iterator over the elements of a `BinaryHeap`.\n ///\n /// This `struct` is created by the [`drain`] method on [`BinaryHeap`]. See its\n@@ -1161,6 +1243,52 @@ impl<T> ExactSizeIterator for Drain<'_, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for Drain<'_, T> {}\n \n+/// A draining iterator over the elements of a `BinaryHeap`.\n+///\n+/// This `struct` is created by the [`drain_sorted`] method on [`BinaryHeap`]. See its\n+/// documentation for more.\n+///\n+/// [`drain_sorted`]: struct.BinaryHeap.html#method.drain_sorted\n+/// [`BinaryHeap`]: struct.BinaryHeap.html\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+#[derive(Debug)]\n+pub struct DrainSorted<'a, T: Ord> {\n+    inner: &'a mut BinaryHeap<T>,\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n+    /// Removes heap elements in heap order.\n+    fn drop(&mut self) {\n+        while let Some(_) = self.inner.pop() {}\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> Iterator for DrainSorted<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.pop()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let exact = self.inner.len();\n+        (exact, Some(exact))\n+    }\n+}\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> ExactSizeIterator for DrainSorted<'_, T> { }\n+\n+#[unstable(feature = \"binary_heap_drain_sorted\", issue = \"59278\")]\n+impl<T: Ord> FusedIterator for DrainSorted<'_, T> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T: Ord> TrustedLen for DrainSorted<'_, T> {}\n+\n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n     /// Converts a `Vec<T>` into a `BinaryHeap<T>`."}, {"sha": "a44cf1eaf6df0310471d4e6d8e67050c6c9aca95", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "patch": "@@ -1,5 +1,6 @@\n use std::collections::BinaryHeap;\n use std::collections::binary_heap::{Drain, PeekMut};\n+use std::iter::TrustedLen;\n \n #[test]\n fn test_iterator() {\n@@ -14,7 +15,7 @@ fn test_iterator() {\n }\n \n #[test]\n-fn test_iterator_reverse() {\n+fn test_iter_rev_cloned_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n     let pq = BinaryHeap::from(data);\n@@ -24,7 +25,7 @@ fn test_iterator_reverse() {\n }\n \n #[test]\n-fn test_move_iter() {\n+fn test_into_iter_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![9, 5, 3];\n     let pq = BinaryHeap::from(data);\n@@ -34,7 +35,7 @@ fn test_move_iter() {\n }\n \n #[test]\n-fn test_move_iter_size_hint() {\n+fn test_into_iter_size_hint() {\n     let data = vec![5, 9];\n     let pq = BinaryHeap::from(data);\n \n@@ -51,7 +52,7 @@ fn test_move_iter_size_hint() {\n }\n \n #[test]\n-fn test_move_iter_reverse() {\n+fn test_into_iter_rev_collect() {\n     let data = vec![5, 9, 3];\n     let iterout = vec![3, 5, 9];\n     let pq = BinaryHeap::from(data);\n@@ -60,6 +61,65 @@ fn test_move_iter_reverse() {\n     assert_eq!(v, iterout);\n }\n \n+#[test]\n+fn test_into_iter_sorted_collect() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    let it = heap.into_iter_sorted();\n+    let sorted = it.collect::<Vec<_>>();\n+    assert_eq!(sorted, vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 0]);\n+}\n+\n+#[test]\n+fn test_drain_sorted_collect() {\n+    let mut heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    let it = heap.drain_sorted();\n+    let sorted = it.collect::<Vec<_>>();\n+    assert_eq!(sorted, vec![10, 9, 8, 7, 6, 5, 4, 3, 2, 2, 1, 1, 0]);\n+}\n+\n+fn check_exact_size_iterator<I: ExactSizeIterator>(len: usize, it: I) {\n+    let mut it = it;\n+\n+    for i in 0..it.len() {\n+        let (lower, upper) = it.size_hint();\n+        assert_eq!(Some(lower), upper);\n+        assert_eq!(lower, len - i);\n+        assert_eq!(it.len(), len - i);\n+        it.next();\n+    }\n+    assert_eq!(it.len(), 0);\n+    assert!(it.is_empty());\n+}\n+\n+#[test]\n+fn test_exact_size_iterator() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_exact_size_iterator(heap.len(), heap.iter());\n+    check_exact_size_iterator(heap.len(), heap.clone().into_iter());\n+    check_exact_size_iterator(heap.len(), heap.clone().into_iter_sorted());\n+    check_exact_size_iterator(heap.len(), heap.clone().drain());\n+    check_exact_size_iterator(heap.len(), heap.clone().drain_sorted());\n+}\n+\n+fn check_trusted_len<I: TrustedLen>(len: usize, it: I) {\n+    let mut it = it;\n+    for i in 0..len {\n+        let (lower, upper) = it.size_hint();\n+        if upper.is_some() {\n+            assert_eq!(Some(lower), upper);\n+            assert_eq!(lower, len - i);\n+        }\n+        it.next();\n+    }\n+}\n+\n+#[test]\n+fn test_trusted_len() {\n+    let heap = BinaryHeap::from(vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1]);\n+    check_trusted_len(heap.len(), heap.clone().into_iter_sorted());\n+    check_trusted_len(heap.len(), heap.clone().drain_sorted());\n+}\n+\n #[test]\n fn test_peek_and_pop() {\n     let data = vec![2, 4, 6, 2, 1, 8, 10, 3, 5, 7, 0, 9, 1];\n@@ -206,6 +266,15 @@ fn test_drain() {\n     assert!(q.is_empty());\n }\n \n+#[test]\n+fn test_drain_sorted() {\n+    let mut q: BinaryHeap<_> = [9, 8, 7, 6, 5, 4, 3, 2, 1].iter().cloned().collect();\n+\n+    assert_eq!(q.drain_sorted().take(5).collect::<Vec<_>>(), vec![9, 8, 7, 6, 5]);\n+\n+    assert!(q.is_empty());\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = BinaryHeap::new();"}, {"sha": "3273feb7b5dd4b291e1250386f4b1acce1427dba", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa4e57ca8f18b836bf77923cd0d9ad1390f0110b/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=aa4e57ca8f18b836bf77923cd0d9ad1390f0110b", "patch": "@@ -8,6 +8,8 @@\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![feature(associated_type_bounds)]\n+#![feature(binary_heap_into_iter_sorted)]\n+#![feature(binary_heap_drain_sorted)]\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}]}