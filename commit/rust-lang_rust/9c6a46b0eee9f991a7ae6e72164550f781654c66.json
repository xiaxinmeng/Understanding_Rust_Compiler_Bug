{"sha": "9c6a46b0eee9f991a7ae6e72164550f781654c66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNmE0NmIwZWVlOWY5OTFhN2FlNmU3MjE2NDU1MGY3ODE2NTRjNjY=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-29T22:43:51Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-29T22:43:51Z"}, "message": "fiddlin'", "tree": {"sha": "01b4e69994bf6a9f0382b32f3ed294bd2c249aef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01b4e69994bf6a9f0382b32f3ed294bd2c249aef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c6a46b0eee9f991a7ae6e72164550f781654c66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6a46b0eee9f991a7ae6e72164550f781654c66", "html_url": "https://github.com/rust-lang/rust/commit/9c6a46b0eee9f991a7ae6e72164550f781654c66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c6a46b0eee9f991a7ae6e72164550f781654c66/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65a0c1753e7eaa2ee1a77a4591d328afc85766be", "url": "https://api.github.com/repos/rust-lang/rust/commits/65a0c1753e7eaa2ee1a77a4591d328afc85766be", "html_url": "https://github.com/rust-lang/rust/commit/65a0c1753e7eaa2ee1a77a4591d328afc85766be"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "b86f6209f35af2e9a8538952b7228cd83627f3bf", "filename": "README.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c6a46b0eee9f991a7ae6e72164550f781654c66/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c6a46b0eee9f991a7ae6e72164550f781654c66/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=9c6a46b0eee9f991a7ae6e72164550f781654c66", "patch": "@@ -1,18 +1,23 @@\n % The Unsafe Rust Programming Language\n \n+# NOTE: This is a draft document, and may contain serious errors\n+\n **This document is about advanced functionality and low-level development practices\n in the Rust Programming Language. Most of the things discussed won't matter\n to the average Rust programmer. However if you wish to correctly write unsafe\n code in Rust, this text contains invaluable information.**\n \n-This document seeks to complement [The Rust Programming Language Book][trpl] (TRPL).\n+The Unsafe Rust Programming Language (TURPL) seeks to complement\n+[The Rust Programming Language Book][trpl] (TRPL).\n Where TRPL introduces the language and teaches the basics, TURPL dives deep into\n the specification of the language, and all the nasty bits necessary to write\n Unsafe Rust. TURPL does not assume you have read TRPL, but does assume you know\n the basics of the language and systems programming. We will not explain the\n stack or heap, we will not explain the syntax.\n \n \n+\n+\n # A Tale Of Two Languages\n \n Rust can be thought of as two different languages: Safe Rust, and Unsafe Rust."}, {"sha": "599415bfe4b954f6b1815d0f2c77d6b1b150d4cd", "filename": "data.md", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9c6a46b0eee9f991a7ae6e72164550f781654c66/data.md", "raw_url": "https://github.com/rust-lang/rust/raw/9c6a46b0eee9f991a7ae6e72164550f781654c66/data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/data.md?ref=9c6a46b0eee9f991a7ae6e72164550f781654c66", "patch": "@@ -21,23 +21,25 @@ An enum is said to be *C-like* if none of its variants have associated data.\n For all these, individual fields are aligned to their preferred alignment. For\n primitives this is usually equal to their size. For instance, a u32 will be\n aligned to a multiple of 32 bits, and a u16 will be aligned to a multiple of 16\n-bits. Composite structures will have their size rounded up to be a multiple of\n-the highest alignment required by their fields, and an alignment requirement\n-equal to the highest alignment required by their fields. So for instance,\n+bits. Composite structures will have a preferred alignment equal to the maximum\n+of their fields' preferred alignment, and a size equal to a multiple of their\n+preferred alignment. This ensures that arrays of T can be correctly iterated\n+by offsetting by their size. So for instance,\n \n ```rust\n struct A {\n     a: u8,\n-    c: u64,\n-    b: u32,\n+    c: u32,\n+    b: u16,\n }\n ```\n \n-will have a size that is a multiple of 64-bits, and 64-bit alignment.\n+will have a size that is a multiple of 32-bits, and 32-bit alignment.\n \n There is *no indirection* for these types; all data is stored contiguously as you would\n-expect in C. However with the exception of arrays, the layout of data is not by\n-default specified in Rust. Given the two following struct definitions:\n+expect in C. However with the exception of arrays (which are densely packed and\n+in-order), the layout of data is not by default specified in Rust. Given the two\n+following struct definitions:\n \n ```rust\n struct A {\n@@ -91,9 +93,9 @@ struct Foo<u32, u16> {\n ```\n \n The latter case quite simply wastes space. An optimal use of space therefore requires\n-different monomorphizations to *have different field orderings*.\n+different monomorphizations to have *different field orderings*.\n \n-**Note: this is a hypothetical optimization that is not yet implemented in Rust 1.0.0**\n+**Note: this is a hypothetical optimization that is not yet implemented in Rust 1.0**\n \n Enums make this consideration even more complicated. Naively, an enum such as:\n \n@@ -120,31 +122,32 @@ such a representation is ineffiecient. The classic case of this is Rust's\n \"null pointer optimization\". Given a pointer that is known to not be null\n (e.g. `&u32`), an enum can *store* a discriminant bit *inside* the pointer\n by using null as a special value. The net result is that\n-`sizeof(Option<&T>) == sizeof<&T>`\n+`size_of::<Option<&T>>() == size_of::<&T>()`\n \n-There are many types in Rust that are, or contain, \"not null\" pointers such as `Box<T>`, `Vec<T>`,\n-`String`, `&T`, and `&mut T`. Similarly, one can imagine nested enums pooling their tags into\n-a single descriminant, as they are by definition known to have a limited range of valid values.\n-In principle enums can use fairly elaborate algorithms to cache bits throughout nested types\n-with special constrained representations. As such it is *especially* desirable that we leave\n-enum layout unspecified today.\n+There are many types in Rust that are, or contain, \"not null\" pointers such as\n+`Box<T>`, `Vec<T>`, `String`, `&T`, and `&mut T`. Similarly, one can imagine\n+nested enums pooling their tags into a single descriminant, as they are by\n+definition known to have a limited range of valid values. In principle enums can\n+use fairly elaborate algorithms to cache bits throughout nested types with\n+special constrained representations. As such it is *especially* desirable that\n+we leave enum layout unspecified today.\n \n \n \n \n # Dynamically Sized Types (DSTs)\n \n Rust also supports types without a statically known size. On the surface,\n-this is a bit nonsensical: Rust must know the size of something in order to\n-work with it. DSTs are generally produced as views, or through type-erasure\n+this is a bit nonsensical: Rust *must* know the size of something in order to\n+work with it! DSTs are generally produced as views, or through type-erasure\n of types that *do* have a known size. Due to their lack of a statically known\n size, these types can only exist *behind* some kind of pointer. They consequently\n produce a *fat* pointer consisting of the pointer and the information that\n *completes* them.\n \n For instance, the slice type, `[T]`, is some statically unknown number of elements\n stored contiguously. `&[T]` consequently consists of a `(&T, usize)` pair that specifies\n-where the slice starts, and how many elements it contains. Similarly Trait Objects\n+where the slice starts, and how many elements it contains. Similarly, Trait Objects\n support interface-oriented type erasure through a `(data_ptr, vtable_ptr)` pair.\n \n Structs can actually store a single DST directly as their last field, but this\n@@ -158,6 +161,8 @@ struct Foo {\n }\n ```\n \n+**NOTE: As of Rust 1.0 struct DSTs are broken if the last field has\n+a variable position based on its alignment.**\n \n \n \n@@ -235,6 +240,7 @@ Rust allows you to specify alternative data layout strategies from the default.\n \n \n \n+\n ## repr(C)\n \n This is the most important `repr`. It has fairly simple intent: do what C does.\n@@ -262,6 +268,7 @@ the FFI boundary.\n \n \n \n+\n ## repr(packed)\n \n `repr(packed)` forces rust to strip any padding, and only align the type to a\n@@ -278,11 +285,13 @@ this should not be used.\n This repr is a modifier on `repr(C)` and `repr(rust)`.\n \n \n+\n+\n ## repr(u8), repr(u16), repr(u32), repr(u64)\n \n These specify the size to make a C-like enum. If the discriminant overflows the\n integer it has to fit in, it will be an error. You can manually ask Rust to\n allow this by setting the overflowing element to explicitly be 0. However Rust\n will not allow you to create an enum where two variants.\n \n-These reprs have no affect on struct or non-C-like enum.\n+These reprs have no affect on a struct or non-C-like enum."}]}