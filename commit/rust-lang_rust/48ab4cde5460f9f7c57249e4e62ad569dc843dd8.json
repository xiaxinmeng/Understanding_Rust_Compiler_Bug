{"sha": "48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4YWI0Y2RlNTQ2MGY5ZjdjNTcyNDllNGU2MmFkNTY5ZGM4NDNkZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-14T08:49:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-14T08:49:10Z"}, "message": "Auto merge of #47268 - EdSchouten:cloudabi-libstd, r=alexcrichton\n\nImplement libstd for CloudABI.\n\nThough CloudABI is strongly inspired by POSIX, its absence of features that don't work well with capability-based sandboxing makes it different enough that adding bits to `sys/unix` will make things a mess. This change therefore adds CloudABI specific platform code under `sys/cloudabi`.\n\nOne of the goals of this implementation is to build as much as possible directly on top of CloudABI's system call layer, as opposed to using the C library. This is preferred, as the system call layer is supposed to be stable, whereas the C library ABI technically is not. An advantage of this approach is that it allows us to implement certain interfaces, such as mutexes and condition variables more optimally. They can be lighter than the ones provided by pthreads.\n\nThis change disables some modules that cannot realistically be implemented right now. For example, libstd's pathname abstraction is not designed with POSIX `*at()` (e.g., `openat()`) in mind. The `*at()` functions are the only set of file system APIs available on CloudABI. There is no global file system namespace, nor a process working directory. Discussions on how to port these modules over are outside the scope of this change.", "tree": {"sha": "21ff4881b0ad83bbec006f25dc9a567073ca4a0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21ff4881b0ad83bbec006f25dc9a567073ca4a0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "html_url": "https://github.com/rust-lang/rust/commit/48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd0f29237c9562efef25fb30f03df24edb1e2042", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd0f29237c9562efef25fb30f03df24edb1e2042", "html_url": "https://github.com/rust-lang/rust/commit/fd0f29237c9562efef25fb30f03df24edb1e2042"}, {"sha": "6a8d55a235e1ce6336dff162aae3feef9f7873b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8d55a235e1ce6336dff162aae3feef9f7873b4", "html_url": "https://github.com/rust-lang/rust/commit/6a8d55a235e1ce6336dff162aae3feef9f7873b4"}], "stats": {"total": 5071, "additions": 5057, "deletions": 14}, "files": [{"sha": "27bf326631fb0416cf74082a6315bbf931e46a75", "filename": "src/libstd/env.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -956,8 +956,7 @@ mod arch {\n mod tests {\n     use super::*;\n \n-    use ffi::OsStr;\n-    use path::{Path, PathBuf};\n+    use path::Path;\n \n     #[test]\n     #[cfg_attr(target_os = \"emscripten\", ignore)]\n@@ -980,6 +979,8 @@ mod tests {\n     #[test]\n     #[cfg(windows)]\n     fn split_paths_windows() {\n+        use path::PathBuf;\n+\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n                 parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n@@ -1000,6 +1001,8 @@ mod tests {\n     #[test]\n     #[cfg(unix)]\n     fn split_paths_unix() {\n+        use path::PathBuf;\n+\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n                 parsed.iter().map(|s| PathBuf::from(*s)).collect::<Vec<_>>()\n@@ -1015,6 +1018,8 @@ mod tests {\n     #[test]\n     #[cfg(unix)]\n     fn join_paths_unix() {\n+        use ffi::OsStr;\n+\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n                 OsStr::new(output)\n@@ -1031,6 +1036,8 @@ mod tests {\n     #[test]\n     #[cfg(windows)]\n     fn join_paths_windows() {\n+        use ffi::OsStr;\n+\n         fn test_eq(input: &[&str], output: &str) -> bool {\n             &*join_paths(input.iter().cloned()).unwrap() ==\n                 OsStr::new(output)"}, {"sha": "4e0ff450cabdc84b9622db12b04fa01fd79d08f8", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -1989,7 +1989,7 @@ impl AsInnerMut<fs_imp::DirBuilder> for DirBuilder {\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use io::prelude::*;\n "}, {"sha": "78235ea1b4b5f31b886d7fb95deb7a1f4b2a5215", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -885,7 +885,7 @@ impl fmt::Debug for TcpListener {\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use io::ErrorKind;\n     use io::prelude::*;"}, {"sha": "fc7f9205d06ff6f72d57e6289b8d4dd9a4cfccde", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -786,7 +786,7 @@ impl fmt::Debug for UdpSocket {\n     }\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use io::ErrorKind;\n     use net::*;"}, {"sha": "5c66ac6ddded8efc2049c03fd12e8a766f8ca745", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -1392,7 +1392,7 @@ pub fn id() -> u32 {\n     ::sys::os::getpid()\n }\n \n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n+#[cfg(all(test, not(any(target_os = \"cloudabi\", target_os = \"emscripten\"))))]\n mod tests {\n     use io::prelude::*;\n "}, {"sha": "f764cc1df5a5c2384dbb2e756ca8603fe9feb79e", "filename": "src/libstd/sys/cloudabi/abi/bitflags.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fbitflags.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2018 Nuxi (https://nuxi.nl/) and contributors.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+// 1. Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+// 2. Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+// SUCH DAMAGE.\n+\n+// Appease Rust's tidy.\n+// ignore-license\n+\n+#[cfg(feature = \"bitflags\")]\n+#[macro_use]\n+extern crate bitflags;\n+\n+// Minimal implementation of bitflags! in case we can't depend on the bitflags\n+// crate. Only implements `bits()` and a `from_bits_truncate()` that doesn't\n+// actually truncate.\n+#[cfg(not(feature = \"bitflags\"))]\n+macro_rules! bitflags {\n+  (\n+    $(#[$attr:meta])*\n+    pub struct $name:ident: $type:ty {\n+      $($(#[$const_attr:meta])* const $const:ident = $val:expr;)*\n+    }\n+  ) => {\n+    $(#[$attr])*\n+    #[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+    pub struct $name { bits: $type }\n+    impl $name {\n+      $($(#[$const_attr])* pub const $const: $name = $name{ bits: $val };)*\n+      pub fn bits(&self) -> $type { self.bits }\n+      pub fn from_bits_truncate(bits: $type) -> Self { $name{ bits } }\n+    }\n+  }\n+}"}, {"sha": "2909db5098e58f58860d1c4ad4f1a6569706112a", "filename": "src/libstd/sys/cloudabi/abi/cloudabi.rs", "status": "added", "additions": 2847, "deletions": 0, "changes": 2847, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,2847 @@\n+// Copyright (c) 2016-2017 Nuxi (https://nuxi.nl/) and contributors.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+// 1. Redistributions of source code must retain the above copyright\n+//    notice, this list of conditions and the following disclaimer.\n+// 2. Redistributions in binary form must reproduce the above copyright\n+//    notice, this list of conditions and the following disclaimer in the\n+//    documentation and/or other materials provided with the distribution.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n+// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n+// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+// SUCH DAMAGE.\n+//\n+// This file is automatically generated. Do not edit.\n+//\n+// Source: https://github.com/NuxiNL/cloudabi\n+\n+// Appease Rust's tidy.\n+// ignore-license\n+// ignore-tidy-linelength\n+\n+//! **PLEASE NOTE: This entire crate including this\n+//! documentation is automatically generated from\n+//! [`cloudabi.txt`](https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt)**\n+//!\n+//! # Nuxi CloudABI\n+//!\n+//! CloudABI is what you get if you take POSIX, add capability-based\n+//! security, and remove everything that's incompatible with that. The\n+//! result is a minimal ABI consisting of only 49 syscalls.\n+//!\n+//! CloudABI doesn't have its own kernel, but instead is implemented in existing\n+//! kernels: FreeBSD has CloudABI support for x86-64 and arm64, and [a patch-set\n+//! for NetBSD](https://github.com/NuxiNL/netbsd) and [a patch-set for\n+//! Linux](https://github.com/NuxiNL/linux) are available as well. This means that\n+//! CloudABI binaries can be executed on different operating systems, without any\n+//! modification.\n+//!\n+//! ## Capability-Based Security\n+//!\n+//! Capability-based security means that processes can only perform\n+//! actions that have no global impact. Processes cannot open files by\n+//! their absolute path, cannot open network connections, and cannot\n+//! observe global system state such as the process table.\n+//!\n+//! The capabilities of a process are fully determined by its set of open\n+//! file descriptors (fds). For example, files can only be opened if the\n+//! process already has a file descriptor to a directory the file is in.\n+//!\n+//! Unlike in POSIX, where processes are normally started with file\n+//! descriptors 0, 1, and 2 reserved for standard input, output, and\n+//! error, CloudABI does not reserve any file descriptor numbers for\n+//! specific purposes.\n+//!\n+//! In CloudABI, a process depends on its parent process to launch it with\n+//! the right set of resources, since the process will not be able to open\n+//! any new resources. For example, a simple static web server would need\n+//! to be started with a file descriptor to a [TCP\n+//! listener](https://github.com/NuxiNL/flower), and a file descriptor to\n+//! the directory for which to serve files. The web server will then be\n+//! unable to do anything other than reading files in that directory, and\n+//! process incoming network connections.\n+//!\n+//! So, unknown CloudABI binaries can safely be executed without the need\n+//! for containers, virtual machines, or other sandboxing technologies.\n+//!\n+//! Watch [Ed Schouten's Talk at\n+//! 32C3](https://www.youtube.com/watch?v=3N29vrPoDv8) for more\n+//! information about what capability-based security for UNIX means.\n+//!\n+//! ## Cloudlibc\n+//!\n+//! [Cloudlibc](https://github.com/NuxiNL/cloudlibc) is an implementation\n+//! of the C standard library, without all CloudABI-incompatible\n+//! functions. For example, Cloudlibc does not have `printf`, but does\n+//! have `fprintf`. It does not have `open`, but does have `openat`.\n+//!\n+//! ## CloudABI-Ports\n+//!\n+//! [CloudABI-Ports](https://github.com/NuxiNL/cloudabi-ports) is a\n+//! collection of ports of commonly used libraries and applications to\n+//! CloudABI. It contains software such as `zlib`, `libpng`, `boost`,\n+//! `memcached`, and much more. The software is patched to not depend on\n+//! any global state, such as files in `/etc` or `/dev`, using `open()`,\n+//! etc.\n+//!\n+//! ## Using CloudABI\n+//!\n+//! Instructions for using CloudABI (including kernel modules/patches,\n+//! toolchain, and ports) are available for several operating systems:\n+//!\n+//! - [Arch Linux](https://nuxi.nl/cloudabi/archlinux/)\n+//! - [Debian, Ubuntu, and other Debian derivatives](https://nuxi.nl/cloudabi/debian/)\n+//! - [FreeBSD, PC-BSD and DragonFly BSD](https://nuxi.nl/cloudabi/freebsd/)\n+//! - [Mac OS X](https://nuxi.nl/cloudabi/mac/)\n+//! - [NetBSD](https://nuxi.nl/cloudabi/netbsd/)\n+//!\n+//! ## Specification of the ABI\n+//!\n+//! The entire ABI is specified in a a file called\n+//! [`cloudabi.txt`](https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt),\n+//! from which all\n+//! [headers](https://github.com/NuxiNL/cloudabi/tree/master/headers)\n+//! and documentation (including the one you're reading now) is generated.\n+\n+#![no_std]\n+#![allow(non_camel_case_types)]\n+\n+include!(\"bitflags.rs\");\n+\n+/// File or memory access pattern advisory information.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum advice {\n+  /// The application expects that it will not access the\n+  /// specified data in the near future.\n+  DONTNEED   = 1,\n+  /// The application expects to access the specified data\n+  /// once and then not reuse it thereafter.\n+  NOREUSE    = 2,\n+  /// The application has no advice to give on its behavior\n+  /// with respect to the specified data.\n+  NORMAL     = 3,\n+  /// The application expects to access the specified data\n+  /// in a random order.\n+  RANDOM     = 4,\n+  /// The application expects to access the specified data\n+  /// sequentially from lower offsets to higher offsets.\n+  SEQUENTIAL = 5,\n+  /// The application expects to access the specified data\n+  /// in the near future.\n+  WILLNEED   = 6,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+/// Enumeration describing the kind of value stored in [`auxv`](struct.auxv.html).\n+#[repr(u32)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum auxtype {\n+  /// Base address of the binary argument data provided to\n+  /// [`proc_exec()`](fn.proc_exec.html).\n+  ARGDATA      = 256,\n+  /// Length of the binary argument data provided to\n+  /// [`proc_exec()`](fn.proc_exec.html).\n+  ARGDATALEN   = 257,\n+  /// Base address at which the executable is placed in\n+  /// memory.\n+  BASE         =   7,\n+  /// Base address of a buffer of random data that may be\n+  /// used for non-cryptographic purposes, for example as a\n+  /// canary for stack smashing protection.\n+  CANARY       = 258,\n+  /// Length of a buffer of random data that may be used\n+  /// for non-cryptographic purposes, for example as a\n+  /// canary for stack smashing protection.\n+  CANARYLEN    = 259,\n+  /// Number of CPUs that the system this process is running\n+  /// on has.\n+  NCPUS        = 260,\n+  /// Terminator of the auxiliary vector.\n+  NULL         =   0,\n+  /// Smallest memory object size for which individual\n+  /// memory protection controls can be configured.\n+  PAGESZ       =   6,\n+  /// Address of the first ELF program header of the\n+  /// executable.\n+  PHDR         =   3,\n+  /// Number of ELF program headers of the executable.\n+  PHNUM        =   4,\n+  /// Identifier of the process.\n+  ///\n+  /// This environment does not provide any simple numerical\n+  /// process identifiers, for the reason that these are not\n+  /// useful in distributed contexts. Instead, processes are\n+  /// identified by a UUID.\n+  ///\n+  /// This record should point to sixteen bytes of binary\n+  /// data, containing a version 4 UUID (fully random).\n+  PID          = 263,\n+  /// Address of the ELF header of the vDSO.\n+  ///\n+  /// The vDSO is a shared library that is mapped in the\n+  /// address space of the process. It provides entry points\n+  /// for every system call supported by the environment,\n+  /// all having a corresponding symbol that is prefixed\n+  /// with `cloudabi_sys_`. System calls should be invoked\n+  /// through these entry points.\n+  ///\n+  /// The first advantage of letting processes call into a\n+  /// vDSO to perform system calls instead of raising\n+  /// hardware traps is that it allows for easy emulation of\n+  /// executables on top of existing operating systems. The\n+  /// second advantage is that in cases where an operating\n+  /// system provides native support for CloudABI executables,\n+  /// it may still implement partial userspace\n+  /// implementations of these system calls to improve\n+  /// performance (e.g., [`clock_time_get()`](fn.clock_time_get.html)). It also provides\n+  /// a more dynamic way of adding, removing or replacing\n+  /// system calls.\n+  SYSINFO_EHDR = 262,\n+  /// Thread ID of the initial thread of the process.\n+  TID          = 261,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u32,\n+}\n+\n+/// Identifiers for clocks.\n+#[repr(u32)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum clockid {\n+  /// The system-wide monotonic clock, which is defined as a\n+  /// clock measuring real time, whose value cannot be\n+  /// adjusted and which cannot have negative clock jumps.\n+  ///\n+  /// The epoch of this clock is undefined. The absolute\n+  /// time value of this clock therefore has no meaning.\n+  MONOTONIC          = 1,\n+  /// The CPU-time clock associated with the current\n+  /// process.\n+  PROCESS_CPUTIME_ID = 2,\n+  /// The system-wide clock measuring real time. Time value\n+  /// zero corresponds with 1970-01-01T00:00:00Z.\n+  REALTIME           = 3,\n+  /// The CPU-time clock associated with the current thread.\n+  THREAD_CPUTIME_ID  = 4,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u32,\n+}\n+\n+/// A userspace condition variable.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct condvar(pub u32);\n+/// The condition variable is in its initial state. There\n+/// are no threads waiting to be woken up. If the\n+/// condition variable has any other value, the kernel\n+/// must be called to wake up any sleeping threads.\n+pub const CONDVAR_HAS_NO_WAITERS: condvar = condvar(0);\n+\n+/// Identifier for a device containing a file system. Can be used\n+/// in combination with [`inode`](struct.inode.html) to uniquely identify a file on the\n+/// local system.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct device(pub u64);\n+\n+/// A reference to the offset of a directory entry.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct dircookie(pub u64);\n+/// Permanent reference to the first directory entry\n+/// within a directory.\n+pub const DIRCOOKIE_START: dircookie = dircookie(0);\n+\n+/// Error codes returned by system calls.\n+///\n+/// Not all of these error codes are returned by the system calls\n+/// provided by this environment, but are either used in userspace\n+/// exclusively or merely provided for alignment with POSIX.\n+#[repr(u16)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum errno {\n+  /// No error occurred. System call completed successfully.\n+  SUCCESS        =  0,\n+  /// Argument list too long.\n+  TOOBIG         =  1,\n+  /// Permission denied.\n+  ACCES          =  2,\n+  /// Address in use.\n+  ADDRINUSE      =  3,\n+  /// Address not available.\n+  ADDRNOTAVAIL   =  4,\n+  /// Address family not supported.\n+  AFNOSUPPORT    =  5,\n+  /// Resource unavailable, or operation would block.\n+  AGAIN          =  6,\n+  /// Connection already in progress.\n+  ALREADY        =  7,\n+  /// Bad file descriptor.\n+  BADF           =  8,\n+  /// Bad message.\n+  BADMSG         =  9,\n+  /// Device or resource busy.\n+  BUSY           = 10,\n+  /// Operation canceled.\n+  CANCELED       = 11,\n+  /// No child processes.\n+  CHILD          = 12,\n+  /// Connection aborted.\n+  CONNABORTED    = 13,\n+  /// Connection refused.\n+  CONNREFUSED    = 14,\n+  /// Connection reset.\n+  CONNRESET      = 15,\n+  /// Resource deadlock would occur.\n+  DEADLK         = 16,\n+  /// Destination address required.\n+  DESTADDRREQ    = 17,\n+  /// Mathematics argument out of domain of function.\n+  DOM            = 18,\n+  /// Reserved.\n+  DQUOT          = 19,\n+  /// File exists.\n+  EXIST          = 20,\n+  /// Bad address.\n+  FAULT          = 21,\n+  /// File too large.\n+  FBIG           = 22,\n+  /// Host is unreachable.\n+  HOSTUNREACH    = 23,\n+  /// Identifier removed.\n+  IDRM           = 24,\n+  /// Illegal byte sequence.\n+  ILSEQ          = 25,\n+  /// Operation in progress.\n+  INPROGRESS     = 26,\n+  /// Interrupted function.\n+  INTR           = 27,\n+  /// Invalid argument.\n+  INVAL          = 28,\n+  /// I/O error.\n+  IO             = 29,\n+  /// Socket is connected.\n+  ISCONN         = 30,\n+  /// Is a directory.\n+  ISDIR          = 31,\n+  /// Too many levels of symbolic links.\n+  LOOP           = 32,\n+  /// File descriptor value too large.\n+  MFILE          = 33,\n+  /// Too many links.\n+  MLINK          = 34,\n+  /// Message too large.\n+  MSGSIZE        = 35,\n+  /// Reserved.\n+  MULTIHOP       = 36,\n+  /// Filename too long.\n+  NAMETOOLONG    = 37,\n+  /// Network is down.\n+  NETDOWN        = 38,\n+  /// Connection aborted by network.\n+  NETRESET       = 39,\n+  /// Network unreachable.\n+  NETUNREACH     = 40,\n+  /// Too many files open in system.\n+  NFILE          = 41,\n+  /// No buffer space available.\n+  NOBUFS         = 42,\n+  /// No such device.\n+  NODEV          = 43,\n+  /// No such file or directory.\n+  NOENT          = 44,\n+  /// Executable file format error.\n+  NOEXEC         = 45,\n+  /// No locks available.\n+  NOLCK          = 46,\n+  /// Reserved.\n+  NOLINK         = 47,\n+  /// Not enough space.\n+  NOMEM          = 48,\n+  /// No message of the desired type.\n+  NOMSG          = 49,\n+  /// Protocol not available.\n+  NOPROTOOPT     = 50,\n+  /// No space left on device.\n+  NOSPC          = 51,\n+  /// Function not supported.\n+  NOSYS          = 52,\n+  /// The socket is not connected.\n+  NOTCONN        = 53,\n+  /// Not a directory or a symbolic link to a directory.\n+  NOTDIR         = 54,\n+  /// Directory not empty.\n+  NOTEMPTY       = 55,\n+  /// State not recoverable.\n+  NOTRECOVERABLE = 56,\n+  /// Not a socket.\n+  NOTSOCK        = 57,\n+  /// Not supported, or operation not supported on socket.\n+  NOTSUP         = 58,\n+  /// Inappropriate I/O control operation.\n+  NOTTY          = 59,\n+  /// No such device or address.\n+  NXIO           = 60,\n+  /// Value too large to be stored in data type.\n+  OVERFLOW       = 61,\n+  /// Previous owner died.\n+  OWNERDEAD      = 62,\n+  /// Operation not permitted.\n+  PERM           = 63,\n+  /// Broken pipe.\n+  PIPE           = 64,\n+  /// Protocol error.\n+  PROTO          = 65,\n+  /// Protocol not supported.\n+  PROTONOSUPPORT = 66,\n+  /// Protocol wrong type for socket.\n+  PROTOTYPE      = 67,\n+  /// Result too large.\n+  RANGE          = 68,\n+  /// Read-only file system.\n+  ROFS           = 69,\n+  /// Invalid seek.\n+  SPIPE          = 70,\n+  /// No such process.\n+  SRCH           = 71,\n+  /// Reserved.\n+  STALE          = 72,\n+  /// Connection timed out.\n+  TIMEDOUT       = 73,\n+  /// Text file busy.\n+  TXTBSY         = 74,\n+  /// Cross-device link.\n+  XDEV           = 75,\n+  /// Extension: Capabilities insufficient.\n+  NOTCAPABLE     = 76,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u16,\n+}\n+\n+bitflags! {\n+  /// The state of the file descriptor subscribed to with\n+  /// [`FD_READ`](enum.eventtype.html#variant.FD_READ) or [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+  #[repr(C)]\n+  pub struct eventrwflags: u16 {\n+    /// The peer of this socket has closed or disconnected.\n+    const HANGUP = 0x0001;\n+  }\n+}\n+\n+/// Type of a subscription to an event or its occurrence.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum eventtype {\n+  /// The time value of clock [`subscription.union.clock.clock_id`](struct.subscription_clock.html#structfield.clock_id)\n+  /// has reached timestamp [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout).\n+  CLOCK          = 1,\n+  /// Condition variable [`subscription.union.condvar.condvar`](struct.subscription_condvar.html#structfield.condvar) has\n+  /// been woken up and [`subscription.union.condvar.lock`](struct.subscription_condvar.html#structfield.lock) has been\n+  /// acquired for writing.\n+  CONDVAR        = 2,\n+  /// File descriptor [`subscription.union.fd_readwrite.fd`](struct.subscription_fd_readwrite.html#structfield.fd) has\n+  /// data available for reading. This event always triggers\n+  /// for regular files.\n+  FD_READ        = 3,\n+  /// File descriptor [`subscription.union.fd_readwrite.fd`](struct.subscription_fd_readwrite.html#structfield.fd) has\n+  /// capacity available for writing. This event always\n+  /// triggers for regular files.\n+  FD_WRITE       = 4,\n+  /// Lock [`subscription.union.lock.lock`](struct.subscription_lock.html#structfield.lock) has been acquired for\n+  /// reading.\n+  LOCK_RDLOCK    = 5,\n+  /// Lock [`subscription.union.lock.lock`](struct.subscription_lock.html#structfield.lock) has been acquired for\n+  /// writing.\n+  LOCK_WRLOCK    = 6,\n+  /// The process associated with process descriptor\n+  /// [`subscription.union.proc_terminate.fd`](struct.subscription_proc_terminate.html#structfield.fd) has terminated.\n+  PROC_TERMINATE = 7,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+/// Exit code generated by a process when exiting.\n+pub type exitcode = u32;\n+\n+/// A file descriptor number.\n+///\n+/// Unlike on POSIX-compliant systems, none of the file descriptor\n+/// numbers are reserved for a purpose (e.g., stdin, stdout,\n+/// stderr). Operating systems are not required to allocate new\n+/// file descriptors in ascending order.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct fd(pub u32);\n+/// Returned to the child process by [`proc_fork()`](fn.proc_fork.html).\n+pub const PROCESS_CHILD: fd = fd(0xffffffff);\n+/// Passed to [`mem_map()`](fn.mem_map.html) when creating a mapping to\n+/// anonymous memory.\n+pub const MAP_ANON_FD  : fd = fd(0xffffffff);\n+\n+bitflags! {\n+  /// File descriptor flags.\n+  #[repr(C)]\n+  pub struct fdflags: u16 {\n+    /// Append mode: Data written to the file is always\n+    /// appended to the file's end.\n+    const APPEND   = 0x0001;\n+    /// Write according to synchronized I/O data integrity\n+    /// completion. Only the data stored in the file is\n+    /// synchronized.\n+    const DSYNC    = 0x0002;\n+    /// Non-blocking mode.\n+    const NONBLOCK = 0x0004;\n+    /// Synchronized read I/O operations.\n+    const RSYNC    = 0x0008;\n+    /// Write according to synchronized I/O file integrity\n+    /// completion. In addition to synchronizing the data\n+    /// stored in the file, the system may also synchronously\n+    /// update the file's metadata.\n+    const SYNC     = 0x0010;\n+  }\n+}\n+\n+bitflags! {\n+  /// Which file descriptor attributes to adjust.\n+  #[repr(C)]\n+  pub struct fdsflags: u16 {\n+    /// Adjust the file descriptor flags stored in\n+    /// [`fdstat.fs_flags`](struct.fdstat.html#structfield.fs_flags).\n+    const FLAGS  = 0x0001;\n+    /// Restrict the rights of the file descriptor to the\n+    /// rights stored in [`fdstat.fs_rights_base`](struct.fdstat.html#structfield.fs_rights_base) and\n+    /// [`fdstat.fs_rights_inheriting`](struct.fdstat.html#structfield.fs_rights_inheriting).\n+    const RIGHTS = 0x0002;\n+  }\n+}\n+\n+/// Relative offset within a file.\n+pub type filedelta = i64;\n+\n+/// Non-negative file size or length of a region within a file.\n+pub type filesize = u64;\n+\n+/// The type of a file descriptor or file.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum filetype {\n+  /// The type of the file descriptor or file is unknown or\n+  /// is different from any of the other types specified.\n+  UNKNOWN          =   0,\n+  /// The file descriptor or file refers to a block device\n+  /// inode.\n+  BLOCK_DEVICE     =  16,\n+  /// The file descriptor or file refers to a character\n+  /// device inode.\n+  CHARACTER_DEVICE =  17,\n+  /// The file descriptor or file refers to a directory\n+  /// inode.\n+  DIRECTORY        =  32,\n+  /// The file descriptor refers to a process handle.\n+  PROCESS          =  80,\n+  /// The file descriptor or file refers to a regular file\n+  /// inode.\n+  REGULAR_FILE     =  96,\n+  /// The file descriptor refers to a shared memory object.\n+  SHARED_MEMORY    = 112,\n+  /// The file descriptor or file refers to a datagram\n+  /// socket.\n+  SOCKET_DGRAM     = 128,\n+  /// The file descriptor or file refers to a byte-stream\n+  /// socket.\n+  SOCKET_STREAM    = 130,\n+  /// The file refers to a symbolic link inode.\n+  SYMBOLIC_LINK    = 144,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+bitflags! {\n+  /// Which file attributes to adjust.\n+  #[repr(C)]\n+  pub struct fsflags: u16 {\n+    /// Adjust the last data access timestamp to the value\n+    /// stored in [`filestat.st_atim`](struct.filestat.html#structfield.st_atim).\n+    const ATIM     = 0x0001;\n+    /// Adjust the last data access timestamp to the time\n+    /// of clock [`REALTIME`](enum.clockid.html#variant.REALTIME).\n+    const ATIM_NOW = 0x0002;\n+    /// Adjust the last data modification timestamp to the\n+    /// value stored in [`filestat.st_mtim`](struct.filestat.html#structfield.st_mtim).\n+    const MTIM     = 0x0004;\n+    /// Adjust the last data modification timestamp to the\n+    /// time of clock [`REALTIME`](enum.clockid.html#variant.REALTIME).\n+    const MTIM_NOW = 0x0008;\n+    /// Truncate or extend the file to the size stored in\n+    /// [`filestat.st_size`](struct.filestat.html#structfield.st_size).\n+    const SIZE     = 0x0010;\n+  }\n+}\n+\n+/// File serial number that is unique within its file system.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct inode(pub u64);\n+\n+/// Number of hard links to an inode.\n+pub type linkcount = u32;\n+\n+/// A userspace read-recursive readers-writer lock, similar to a\n+/// Linux futex or a FreeBSD umtx.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct lock(pub u32);\n+/// Value indicating that the lock is in its initial\n+/// unlocked state.\n+pub const LOCK_UNLOCKED      : lock = lock(0x00000000);\n+/// Bitmask indicating that the lock is write-locked. If\n+/// set, the lower 30 bits of the lock contain the\n+/// identifier of the thread that owns the write lock.\n+/// Otherwise, the lower 30 bits of the lock contain the\n+/// number of acquired read locks.\n+pub const LOCK_WRLOCKED      : lock = lock(0x40000000);\n+/// Bitmask indicating that the lock is either read locked\n+/// or write locked, and that one or more threads have\n+/// their execution suspended, waiting to acquire the\n+/// lock. The last owner of the lock must call the\n+/// kernel to unlock.\n+///\n+/// When the lock is acquired for reading and this bit is\n+/// set, it means that one or more threads are attempting\n+/// to acquire this lock for writing. In that case, other\n+/// threads should only acquire additional read locks if\n+/// suspending execution would cause a deadlock. It is\n+/// preferred to suspend execution, as this prevents\n+/// starvation of writers.\n+pub const LOCK_KERNEL_MANAGED: lock = lock(0x80000000);\n+/// Value indicating that the lock is in an incorrect\n+/// state. A lock cannot be in its initial unlocked state,\n+/// while also managed by the kernel.\n+pub const LOCK_BOGUS         : lock = lock(0x80000000);\n+\n+bitflags! {\n+  /// Flags determining the method of how paths are resolved.\n+  #[repr(C)]\n+  pub struct lookupflags: u32 {\n+    /// As long as the resolved path corresponds to a symbolic\n+    /// link, it is expanded.\n+    const SYMLINK_FOLLOW = 0x00000001;\n+  }\n+}\n+\n+bitflags! {\n+  /// Memory mapping flags.\n+  #[repr(C)]\n+  pub struct mflags: u8 {\n+    /// Instead of mapping the contents of the file provided,\n+    /// create a mapping to anonymous memory. The file\n+    /// descriptor argument must be set to [`MAP_ANON_FD`](constant.MAP_ANON_FD.html),\n+    /// and the offset must be set to zero.\n+    const ANON    = 0x01;\n+    /// Require that the mapping is performed at the base\n+    /// address provided.\n+    const FIXED   = 0x02;\n+    /// Changes are private.\n+    const PRIVATE = 0x04;\n+    /// Changes are shared.\n+    const SHARED  = 0x08;\n+  }\n+}\n+\n+bitflags! {\n+  /// Memory page protection options.\n+  ///\n+  /// This implementation enforces the `W^X` property: Pages cannot be\n+  /// mapped for execution while also mapped for writing.\n+  #[repr(C)]\n+  pub struct mprot: u8 {\n+    /// Page can be executed.\n+    const EXEC  = 0x01;\n+    /// Page can be written.\n+    const WRITE = 0x02;\n+    /// Page can be read.\n+    const READ  = 0x04;\n+  }\n+}\n+\n+bitflags! {\n+  /// Methods of synchronizing memory with physical storage.\n+  #[repr(C)]\n+  pub struct msflags: u8 {\n+    /// Perform asynchronous writes.\n+    const ASYNC      = 0x01;\n+    /// Invalidate cached data.\n+    const INVALIDATE = 0x02;\n+    /// Perform synchronous writes.\n+    const SYNC       = 0x04;\n+  }\n+}\n+\n+/// Specifies the number of threads sleeping on a condition\n+/// variable that should be woken up.\n+pub type nthreads = u32;\n+\n+bitflags! {\n+  /// Open flags used by [`file_open()`](fn.file_open.html).\n+  #[repr(C)]\n+  pub struct oflags: u16 {\n+    /// Create file if it does not exist.\n+    const CREAT     = 0x0001;\n+    /// Fail if not a directory.\n+    const DIRECTORY = 0x0002;\n+    /// Fail if file already exists.\n+    const EXCL      = 0x0004;\n+    /// Truncate file to size 0.\n+    const TRUNC     = 0x0008;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags provided to [`sock_recv()`](fn.sock_recv.html).\n+  #[repr(C)]\n+  pub struct riflags: u16 {\n+    /// Returns the message without removing it from the\n+    /// socket's receive queue.\n+    const PEEK    = 0x0004;\n+    /// On byte-stream sockets, block until the full amount\n+    /// of data can be returned.\n+    const WAITALL = 0x0010;\n+  }\n+}\n+\n+bitflags! {\n+  /// File descriptor rights, determining which actions may be\n+  /// performed.\n+  #[repr(C)]\n+  pub struct rights: u64 {\n+    /// The right to invoke [`fd_datasync()`](fn.fd_datasync.html).\n+    ///\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, includes the right to\n+    /// invoke [`file_open()`](fn.file_open.html) with [`DSYNC`](struct.fdflags.html#associatedconstant.DSYNC).\n+    const FD_DATASYNC           = 0x0000000000000001;\n+    /// The right to invoke [`fd_read()`](fn.fd_read.html) and [`sock_recv()`](fn.sock_recv.html).\n+    ///\n+    /// If [`MEM_MAP`](struct.rights.html#associatedconstant.MEM_MAP) is set, includes the right to\n+    /// invoke [`mem_map()`](fn.mem_map.html) with memory protection option\n+    /// [`READ`](struct.mprot.html#associatedconstant.READ).\n+    ///\n+    /// If [`FD_SEEK`](struct.rights.html#associatedconstant.FD_SEEK) is set, includes the right to invoke\n+    /// [`fd_pread()`](fn.fd_pread.html).\n+    const FD_READ               = 0x0000000000000002;\n+    /// The right to invoke [`fd_seek()`](fn.fd_seek.html). This flag implies\n+    /// [`FD_TELL`](struct.rights.html#associatedconstant.FD_TELL).\n+    const FD_SEEK               = 0x0000000000000004;\n+    /// The right to invoke [`fd_stat_put()`](fn.fd_stat_put.html) with\n+    /// [`FLAGS`](struct.fdsflags.html#associatedconstant.FLAGS).\n+    const FD_STAT_PUT_FLAGS     = 0x0000000000000008;\n+    /// The right to invoke [`fd_sync()`](fn.fd_sync.html).\n+    ///\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, includes the right to\n+    /// invoke [`file_open()`](fn.file_open.html) with [`RSYNC`](struct.fdflags.html#associatedconstant.RSYNC) and\n+    /// [`DSYNC`](struct.fdflags.html#associatedconstant.DSYNC).\n+    const FD_SYNC               = 0x0000000000000010;\n+    /// The right to invoke [`fd_seek()`](fn.fd_seek.html) in such a way that the\n+    /// file offset remains unaltered (i.e., [`CUR`](enum.whence.html#variant.CUR) with\n+    /// offset zero).\n+    const FD_TELL               = 0x0000000000000020;\n+    /// The right to invoke [`fd_write()`](fn.fd_write.html) and [`sock_send()`](fn.sock_send.html).\n+    ///\n+    /// If [`MEM_MAP`](struct.rights.html#associatedconstant.MEM_MAP) is set, includes the right to\n+    /// invoke [`mem_map()`](fn.mem_map.html) with memory protection option\n+    /// [`WRITE`](struct.mprot.html#associatedconstant.WRITE).\n+    ///\n+    /// If [`FD_SEEK`](struct.rights.html#associatedconstant.FD_SEEK) is set, includes the right to\n+    /// invoke [`fd_pwrite()`](fn.fd_pwrite.html).\n+    const FD_WRITE              = 0x0000000000000040;\n+    /// The right to invoke [`file_advise()`](fn.file_advise.html).\n+    const FILE_ADVISE           = 0x0000000000000080;\n+    /// The right to invoke [`file_allocate()`](fn.file_allocate.html).\n+    const FILE_ALLOCATE         = 0x0000000000000100;\n+    /// The right to invoke [`file_create()`](fn.file_create.html) with\n+    /// [`DIRECTORY`](enum.filetype.html#variant.DIRECTORY).\n+    const FILE_CREATE_DIRECTORY = 0x0000000000000200;\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, the right to invoke\n+    /// [`file_open()`](fn.file_open.html) with [`CREAT`](struct.oflags.html#associatedconstant.CREAT).\n+    const FILE_CREATE_FILE      = 0x0000000000000400;\n+    /// The right to invoke [`file_link()`](fn.file_link.html) with the file\n+    /// descriptor as the source directory.\n+    const FILE_LINK_SOURCE      = 0x0000000000001000;\n+    /// The right to invoke [`file_link()`](fn.file_link.html) with the file\n+    /// descriptor as the target directory.\n+    const FILE_LINK_TARGET      = 0x0000000000002000;\n+    /// The right to invoke [`file_open()`](fn.file_open.html).\n+    const FILE_OPEN             = 0x0000000000004000;\n+    /// The right to invoke [`file_readdir()`](fn.file_readdir.html).\n+    const FILE_READDIR          = 0x0000000000008000;\n+    /// The right to invoke [`file_readlink()`](fn.file_readlink.html).\n+    const FILE_READLINK         = 0x0000000000010000;\n+    /// The right to invoke [`file_rename()`](fn.file_rename.html) with the file\n+    /// descriptor as the source directory.\n+    const FILE_RENAME_SOURCE    = 0x0000000000020000;\n+    /// The right to invoke [`file_rename()`](fn.file_rename.html) with the file\n+    /// descriptor as the target directory.\n+    const FILE_RENAME_TARGET    = 0x0000000000040000;\n+    /// The right to invoke [`file_stat_fget()`](fn.file_stat_fget.html).\n+    const FILE_STAT_FGET        = 0x0000000000080000;\n+    /// The right to invoke [`file_stat_fput()`](fn.file_stat_fput.html) with\n+    /// [`SIZE`](struct.fsflags.html#associatedconstant.SIZE).\n+    ///\n+    /// If [`FILE_OPEN`](struct.rights.html#associatedconstant.FILE_OPEN) is set, includes the right to\n+    /// invoke [`file_open()`](fn.file_open.html) with [`TRUNC`](struct.oflags.html#associatedconstant.TRUNC).\n+    const FILE_STAT_FPUT_SIZE   = 0x0000000000100000;\n+    /// The right to invoke [`file_stat_fput()`](fn.file_stat_fput.html) with\n+    /// [`ATIM`](struct.fsflags.html#associatedconstant.ATIM), [`ATIM_NOW`](struct.fsflags.html#associatedconstant.ATIM_NOW), [`MTIM`](struct.fsflags.html#associatedconstant.MTIM),\n+    /// and [`MTIM_NOW`](struct.fsflags.html#associatedconstant.MTIM_NOW).\n+    const FILE_STAT_FPUT_TIMES  = 0x0000000000200000;\n+    /// The right to invoke [`file_stat_get()`](fn.file_stat_get.html).\n+    const FILE_STAT_GET         = 0x0000000000400000;\n+    /// The right to invoke [`file_stat_put()`](fn.file_stat_put.html) with\n+    /// [`ATIM`](struct.fsflags.html#associatedconstant.ATIM), [`ATIM_NOW`](struct.fsflags.html#associatedconstant.ATIM_NOW), [`MTIM`](struct.fsflags.html#associatedconstant.MTIM),\n+    /// and [`MTIM_NOW`](struct.fsflags.html#associatedconstant.MTIM_NOW).\n+    const FILE_STAT_PUT_TIMES   = 0x0000000000800000;\n+    /// The right to invoke [`file_symlink()`](fn.file_symlink.html).\n+    const FILE_SYMLINK          = 0x0000000001000000;\n+    /// The right to invoke [`file_unlink()`](fn.file_unlink.html).\n+    const FILE_UNLINK           = 0x0000000002000000;\n+    /// The right to invoke [`mem_map()`](fn.mem_map.html) with [`mprot`](struct.mprot.html) set to\n+    /// zero.\n+    const MEM_MAP               = 0x0000000004000000;\n+    /// If [`MEM_MAP`](struct.rights.html#associatedconstant.MEM_MAP) is set, the right to invoke\n+    /// [`mem_map()`](fn.mem_map.html) with [`EXEC`](struct.mprot.html#associatedconstant.EXEC).\n+    const MEM_MAP_EXEC          = 0x0000000008000000;\n+    /// If [`FD_READ`](struct.rights.html#associatedconstant.FD_READ) is set, includes the right to\n+    /// invoke [`poll()`](fn.poll.html) to subscribe to [`FD_READ`](enum.eventtype.html#variant.FD_READ).\n+    ///\n+    /// If [`FD_WRITE`](struct.rights.html#associatedconstant.FD_WRITE) is set, includes the right to\n+    /// invoke [`poll()`](fn.poll.html) to subscribe to [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+    const POLL_FD_READWRITE     = 0x0000000010000000;\n+    /// The right to invoke [`poll()`](fn.poll.html) to subscribe to\n+    /// [`PROC_TERMINATE`](enum.eventtype.html#variant.PROC_TERMINATE).\n+    const POLL_PROC_TERMINATE   = 0x0000000040000000;\n+    /// The right to invoke [`proc_exec()`](fn.proc_exec.html).\n+    const PROC_EXEC             = 0x0000000100000000;\n+    /// The right to invoke [`sock_shutdown()`](fn.sock_shutdown.html).\n+    const SOCK_SHUTDOWN         = 0x0000008000000000;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags returned by [`sock_recv()`](fn.sock_recv.html).\n+  #[repr(C)]\n+  pub struct roflags: u16 {\n+    /// Returned by [`sock_recv()`](fn.sock_recv.html): List of file descriptors\n+    /// has been truncated.\n+    const FDS_TRUNCATED  = 0x0001;\n+    /// Returned by [`sock_recv()`](fn.sock_recv.html): Message data has been\n+    /// truncated.\n+    const DATA_TRUNCATED = 0x0008;\n+  }\n+}\n+\n+/// Indicates whether an object is stored in private or shared\n+/// memory.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum scope {\n+  /// The object is stored in private memory.\n+  PRIVATE = 4,\n+  /// The object is stored in shared memory.\n+  SHARED  = 8,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+bitflags! {\n+  /// Which channels on a socket need to be shut down.\n+  #[repr(C)]\n+  pub struct sdflags: u8 {\n+    /// Disables further receive operations.\n+    const RD = 0x01;\n+    /// Disables further send operations.\n+    const WR = 0x02;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags provided to [`sock_send()`](fn.sock_send.html). As there are currently no flags\n+  /// defined, it must be set to zero.\n+  #[repr(C)]\n+  pub struct siflags: u16 {\n+    const DEFAULT = 0;\n+  }\n+}\n+\n+/// Signal condition.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum signal {\n+  /// Process abort signal.\n+  ///\n+  /// Action: Terminates the process.\n+  ABRT   =  1,\n+  /// Alarm clock.\n+  ///\n+  /// Action: Terminates the process.\n+  ALRM   =  2,\n+  /// Access to an undefined portion of a memory object.\n+  ///\n+  /// Action: Terminates the process.\n+  BUS    =  3,\n+  /// Child process terminated, stopped, or continued.\n+  ///\n+  /// Action: Ignored.\n+  CHLD   =  4,\n+  /// Continue executing, if stopped.\n+  ///\n+  /// Action: Continues executing, if stopped.\n+  CONT   =  5,\n+  /// Erroneous arithmetic operation.\n+  ///\n+  /// Action: Terminates the process.\n+  FPE    =  6,\n+  /// Hangup.\n+  ///\n+  /// Action: Terminates the process.\n+  HUP    =  7,\n+  /// Illegal instruction.\n+  ///\n+  /// Action: Terminates the process.\n+  ILL    =  8,\n+  /// Terminate interrupt signal.\n+  ///\n+  /// Action: Terminates the process.\n+  INT    =  9,\n+  /// Kill.\n+  ///\n+  /// Action: Terminates the process.\n+  KILL   = 10,\n+  /// Write on a pipe with no one to read it.\n+  ///\n+  /// Action: Ignored.\n+  PIPE   = 11,\n+  /// Terminal quit signal.\n+  ///\n+  /// Action: Terminates the process.\n+  QUIT   = 12,\n+  /// Invalid memory reference.\n+  ///\n+  /// Action: Terminates the process.\n+  SEGV   = 13,\n+  /// Stop executing.\n+  ///\n+  /// Action: Stops executing.\n+  STOP   = 14,\n+  /// Bad system call.\n+  ///\n+  /// Action: Terminates the process.\n+  SYS    = 15,\n+  /// Termination signal.\n+  ///\n+  /// Action: Terminates the process.\n+  TERM   = 16,\n+  /// Trace/breakpoint trap.\n+  ///\n+  /// Action: Terminates the process.\n+  TRAP   = 17,\n+  /// Terminal stop signal.\n+  ///\n+  /// Action: Stops executing.\n+  TSTP   = 18,\n+  /// Background process attempting read.\n+  ///\n+  /// Action: Stops executing.\n+  TTIN   = 19,\n+  /// Background process attempting write.\n+  ///\n+  /// Action: Stops executing.\n+  TTOU   = 20,\n+  /// High bandwidth data is available at a socket.\n+  ///\n+  /// Action: Ignored.\n+  URG    = 21,\n+  /// User-defined signal 1.\n+  ///\n+  /// Action: Terminates the process.\n+  USR1   = 22,\n+  /// User-defined signal 2.\n+  ///\n+  /// Action: Terminates the process.\n+  USR2   = 23,\n+  /// Virtual timer expired.\n+  ///\n+  /// Action: Terminates the process.\n+  VTALRM = 24,\n+  /// CPU time limit exceeded.\n+  ///\n+  /// Action: Terminates the process.\n+  XCPU   = 25,\n+  /// File size limit exceeded.\n+  ///\n+  /// Action: Terminates the process.\n+  XFSZ   = 26,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+bitflags! {\n+  /// Flags determining how the timestamp provided in\n+  /// [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout) should be interpreted.\n+  #[repr(C)]\n+  pub struct subclockflags: u16 {\n+    /// If set, treat the timestamp provided in\n+    /// [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout) as an absolute timestamp\n+    /// of clock [`subscription.union.clock.clock_id`](struct.subscription_clock.html#structfield.clock_id).\n+    ///\n+    /// If clear, treat the timestamp provided in\n+    /// [`subscription.union.clock.timeout`](struct.subscription_clock.html#structfield.timeout) relative to the current\n+    /// time value of clock [`subscription.union.clock.clock_id`](struct.subscription_clock.html#structfield.clock_id).\n+    const ABSTIME = 0x0001;\n+  }\n+}\n+\n+bitflags! {\n+  /// Flags influencing the method of polling for read or writing on\n+  /// a file descriptor.\n+  #[repr(C)]\n+  pub struct subrwflags: u16 {\n+    /// Deprecated. Must be set by callers and ignored by\n+    /// implementations.\n+    const POLL = 0x0001;\n+  }\n+}\n+\n+/// Unique system-local identifier of a thread. This identifier is\n+/// only valid during the lifetime of the thread.\n+///\n+/// Threads must be aware of their thread identifier, as it is\n+/// written it into locks when acquiring them for writing. It is\n+/// not advised to use these identifiers for any other purpose.\n+///\n+/// As the thread identifier is also stored in [`lock`](struct.lock.html) when\n+/// [`LOCK_WRLOCKED`](constant.LOCK_WRLOCKED.html) is set, the top two bits of the thread\n+/// must always be set to zero.\n+#[repr(C)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub struct tid(pub u32);\n+\n+/// Timestamp in nanoseconds.\n+pub type timestamp = u64;\n+\n+bitflags! {\n+  /// Specifies whether files are unlinked or directories are\n+  /// removed.\n+  #[repr(C)]\n+  pub struct ulflags: u8 {\n+    /// If set, removes a directory. Otherwise, unlinks any\n+    /// non-directory file.\n+    const REMOVEDIR = 0x01;\n+  }\n+}\n+\n+/// User-provided value that can be attached to objects that is\n+/// retained when extracted from the kernel.\n+pub type userdata = u64;\n+\n+/// Relative to which position the offset of the file descriptor\n+/// should be set.\n+#[repr(u8)]\n+#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]\n+pub enum whence {\n+  /// Seek relative to current position.\n+  CUR = 1,\n+  /// Seek relative to end-of-file.\n+  END = 2,\n+  /// Seek relative to start-of-file.\n+  SET = 3,\n+  #[doc(hidden)] _NonExhaustive = -1 as isize as u8,\n+}\n+\n+/// Auxiliary vector entry.\n+///\n+/// The auxiliary vector is a list of key-value pairs that is\n+/// provided to the process on startup. Unlike structures, it is\n+/// extensible, as it is possible to add new records later on.\n+/// The auxiliary vector is always terminated by an entry having\n+/// type [`NULL`](enum.auxtype.html#variant.NULL).\n+///\n+/// The auxiliary vector is part of the x86-64 ABI, but is used by\n+/// this environment on all architectures.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct auxv {\n+  /// The type of the auxiliary vector entry.\n+  pub a_type: auxtype,\n+  pub union: auxv_union\n+}\n+/// A union inside `auxv`.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union auxv_union {\n+  /// Used when `a_type` is [`ARGDATALEN`](enum.auxtype.html#variant.ARGDATALEN), [`CANARYLEN`](enum.auxtype.html#variant.CANARYLEN), [`NCPUS`](enum.auxtype.html#variant.NCPUS), [`PAGESZ`](enum.auxtype.html#variant.PAGESZ), [`PHNUM`](enum.auxtype.html#variant.PHNUM), or [`TID`](enum.auxtype.html#variant.TID).\n+/// A numerical value.\n+  pub a_val: usize,\n+  /// Used when `a_type` is [`ARGDATA`](enum.auxtype.html#variant.ARGDATA), [`BASE`](enum.auxtype.html#variant.BASE), [`CANARY`](enum.auxtype.html#variant.CANARY), [`PHDR`](enum.auxtype.html#variant.PHDR), [`PID`](enum.auxtype.html#variant.PID), or [`SYSINFO_EHDR`](enum.auxtype.html#variant.SYSINFO_EHDR).\n+/// A pointer value.\n+  pub a_ptr: *mut (),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn auxv_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<auxv>(), 8);\n+  assert_eq!(::core::mem::align_of::<auxv>(), 4);\n+  unsafe {\n+    let obj: auxv = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.a_type as *const _ as usize - base, 0);\n+    assert_eq!(&obj.union.a_val as *const _ as usize - base, 4);\n+    assert_eq!(&obj.union.a_ptr as *const _ as usize - base, 4);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn auxv_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<auxv>(), 16);\n+  assert_eq!(::core::mem::align_of::<auxv>(), 8);\n+  unsafe {\n+    let obj: auxv = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.a_type as *const _ as usize - base, 0);\n+    assert_eq!(&obj.union.a_val as *const _ as usize - base, 8);\n+    assert_eq!(&obj.union.a_ptr as *const _ as usize - base, 8);\n+  }\n+}\n+\n+/// A region of memory for scatter/gather writes.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct ciovec {\n+  /// The address and length of the buffer to be written.\n+  pub buf: (*const (), usize),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn ciovec_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<ciovec>(), 8);\n+  assert_eq!(::core::mem::align_of::<ciovec>(), 4);\n+  unsafe {\n+    let obj: ciovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 4);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn ciovec_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<ciovec>(), 16);\n+  assert_eq!(::core::mem::align_of::<ciovec>(), 8);\n+  unsafe {\n+    let obj: ciovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 8);\n+  }\n+}\n+\n+/// A directory entry.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct dirent {\n+  /// The offset of the next directory entry stored in this\n+  /// directory.\n+  pub d_next: dircookie,\n+  /// The serial number of the file referred to by this\n+  /// directory entry.\n+  pub d_ino: inode,\n+  /// The length of the name of the directory entry.\n+  pub d_namlen: u32,\n+  /// The type of the file referred to by this directory\n+  /// entry.\n+  pub d_type: filetype,\n+}\n+#[test]\n+fn dirent_layout_test() {\n+  assert_eq!(::core::mem::size_of::<dirent>(), 24);\n+  assert_eq!(::core::mem::align_of::<dirent>(), 8);\n+  unsafe {\n+    let obj: dirent = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.d_next as *const _ as usize - base, 0);\n+    assert_eq!(&obj.d_ino as *const _ as usize - base, 8);\n+    assert_eq!(&obj.d_namlen as *const _ as usize - base, 16);\n+    assert_eq!(&obj.d_type as *const _ as usize - base, 20);\n+  }\n+}\n+\n+/// An event that occurred.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct event {\n+  /// User-provided value that got attached to\n+  /// [`subscription.userdata`](struct.subscription.html#structfield.userdata).\n+  pub userdata: userdata,\n+  /// If non-zero, an error that occurred while processing\n+  /// the subscription request.\n+  pub error: errno,\n+  /// The type of the event that occurred.\n+  pub type_: eventtype,\n+  pub union: event_union\n+}\n+/// A union inside `event`.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union event_union {\n+  /// Used when `type_` is [`FD_READ`](enum.eventtype.html#variant.FD_READ) or [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+  pub fd_readwrite: event_fd_readwrite,\n+  /// Used when `type_` is [`PROC_TERMINATE`](enum.eventtype.html#variant.PROC_TERMINATE).\n+  pub proc_terminate: event_proc_terminate,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct event_fd_readwrite {\n+  /// The number of bytes available\n+  /// for reading or writing.\n+  pub nbytes: filesize,\n+  /// Obsolete.\n+  pub unused: [u8; 4],\n+  /// The state of the file\n+  /// descriptor.\n+  pub flags: eventrwflags,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct event_proc_terminate {\n+  /// Obsolete.\n+  pub unused: [u8; 4],\n+  /// If zero, the process has\n+  /// exited.\n+  /// Otherwise, the signal\n+  /// condition causing it to\n+  /// terminated.\n+  pub signal: signal,\n+  /// If exited, the exit code of\n+  /// the process.\n+  pub exitcode: exitcode,\n+}\n+#[test]\n+fn event_layout_test() {\n+  assert_eq!(::core::mem::size_of::<event>(), 32);\n+  assert_eq!(::core::mem::align_of::<event>(), 8);\n+  unsafe {\n+    let obj: event = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.userdata as *const _ as usize - base, 0);\n+    assert_eq!(&obj.error as *const _ as usize - base, 8);\n+    assert_eq!(&obj.type_ as *const _ as usize - base, 10);\n+    assert_eq!(&obj.union.fd_readwrite.nbytes as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.fd_readwrite.unused as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.fd_readwrite.flags as *const _ as usize - base, 28);\n+    assert_eq!(&obj.union.proc_terminate.unused as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.proc_terminate.signal as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.proc_terminate.exitcode as *const _ as usize - base, 24);\n+  }\n+}\n+\n+/// File descriptor attributes.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct fdstat {\n+  /// File type.\n+  pub fs_filetype: filetype,\n+  /// File descriptor flags.\n+  pub fs_flags: fdflags,\n+  /// Rights that apply to this file descriptor.\n+  pub fs_rights_base: rights,\n+  /// Maximum set of rights that can be installed on new\n+  /// file descriptors that are created through this file\n+  /// descriptor, e.g., through [`file_open()`](fn.file_open.html).\n+  pub fs_rights_inheriting: rights,\n+}\n+#[test]\n+fn fdstat_layout_test() {\n+  assert_eq!(::core::mem::size_of::<fdstat>(), 24);\n+  assert_eq!(::core::mem::align_of::<fdstat>(), 8);\n+  unsafe {\n+    let obj: fdstat = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.fs_filetype as *const _ as usize - base, 0);\n+    assert_eq!(&obj.fs_flags as *const _ as usize - base, 2);\n+    assert_eq!(&obj.fs_rights_base as *const _ as usize - base, 8);\n+    assert_eq!(&obj.fs_rights_inheriting as *const _ as usize - base, 16);\n+  }\n+}\n+\n+/// File attributes.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct filestat {\n+  /// Device ID of device containing the file.\n+  pub st_dev: device,\n+  /// File serial number.\n+  pub st_ino: inode,\n+  /// File type.\n+  pub st_filetype: filetype,\n+  /// Number of hard links to the file.\n+  pub st_nlink: linkcount,\n+  /// For regular files, the file size in bytes. For\n+  /// symbolic links, the length in bytes of the pathname\n+  /// contained in the symbolic link.\n+  pub st_size: filesize,\n+  /// Last data access timestamp.\n+  pub st_atim: timestamp,\n+  /// Last data modification timestamp.\n+  pub st_mtim: timestamp,\n+  /// Last file status change timestamp.\n+  pub st_ctim: timestamp,\n+}\n+#[test]\n+fn filestat_layout_test() {\n+  assert_eq!(::core::mem::size_of::<filestat>(), 56);\n+  assert_eq!(::core::mem::align_of::<filestat>(), 8);\n+  unsafe {\n+    let obj: filestat = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.st_dev as *const _ as usize - base, 0);\n+    assert_eq!(&obj.st_ino as *const _ as usize - base, 8);\n+    assert_eq!(&obj.st_filetype as *const _ as usize - base, 16);\n+    assert_eq!(&obj.st_nlink as *const _ as usize - base, 20);\n+    assert_eq!(&obj.st_size as *const _ as usize - base, 24);\n+    assert_eq!(&obj.st_atim as *const _ as usize - base, 32);\n+    assert_eq!(&obj.st_mtim as *const _ as usize - base, 40);\n+    assert_eq!(&obj.st_ctim as *const _ as usize - base, 48);\n+  }\n+}\n+\n+/// A region of memory for scatter/gather reads.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct iovec {\n+  /// The address and length of the buffer to be filled.\n+  pub buf: (*mut (), usize),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn iovec_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<iovec>(), 8);\n+  assert_eq!(::core::mem::align_of::<iovec>(), 4);\n+  unsafe {\n+    let obj: iovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 4);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn iovec_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<iovec>(), 16);\n+  assert_eq!(::core::mem::align_of::<iovec>(), 8);\n+  unsafe {\n+    let obj: iovec = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.buf.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.buf.1 as *const _ as usize - base, 8);\n+  }\n+}\n+\n+/// Path lookup properties.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct lookup {\n+  /// The working directory at which the resolution of the\n+  /// path starts.\n+  pub fd: fd,\n+  /// Flags determining the method of how the path is\n+  /// resolved.\n+  pub flags: lookupflags,\n+}\n+#[test]\n+fn lookup_layout_test() {\n+  assert_eq!(::core::mem::size_of::<lookup>(), 8);\n+  assert_eq!(::core::mem::align_of::<lookup>(), 4);\n+  unsafe {\n+    let obj: lookup = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.fd as *const _ as usize - base, 0);\n+    assert_eq!(&obj.flags as *const _ as usize - base, 4);\n+  }\n+}\n+\n+/// Entry point for a process (`_start`).\n+///\n+/// **auxv**:\n+/// The auxiliary vector. See [`auxv`](struct.auxv.html).\n+pub type processentry = unsafe extern \"C\" fn(\n+  auxv: *const auxv,\n+) -> ();\n+\n+/// Arguments of [`sock_recv()`](fn.sock_recv.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct recv_in {\n+  /// List of scatter/gather vectors where message data\n+  /// should be stored.\n+  pub ri_data: (*const iovec, usize),\n+  /// Buffer where numbers of incoming file descriptors\n+  /// should be stored.\n+  pub ri_fds: (*mut fd, usize),\n+  /// Message flags.\n+  pub ri_flags: riflags,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn recv_in_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<recv_in>(), 20);\n+  assert_eq!(::core::mem::align_of::<recv_in>(), 4);\n+  unsafe {\n+    let obj: recv_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ri_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ri_data.1 as *const _ as usize - base, 4);\n+    assert_eq!(&obj.ri_fds.0 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ri_fds.1 as *const _ as usize - base, 12);\n+    assert_eq!(&obj.ri_flags as *const _ as usize - base, 16);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn recv_in_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<recv_in>(), 40);\n+  assert_eq!(::core::mem::align_of::<recv_in>(), 8);\n+  unsafe {\n+    let obj: recv_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ri_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ri_data.1 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ri_fds.0 as *const _ as usize - base, 16);\n+    assert_eq!(&obj.ri_fds.1 as *const _ as usize - base, 24);\n+    assert_eq!(&obj.ri_flags as *const _ as usize - base, 32);\n+  }\n+}\n+\n+/// Results of [`sock_recv()`](fn.sock_recv.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct recv_out {\n+  /// Number of bytes stored in [`recv_in.ri_data`](struct.recv_in.html#structfield.ri_data).\n+  pub ro_datalen: usize,\n+  /// Number of file descriptors stored in [`recv_in.ri_fds`](struct.recv_in.html#structfield.ri_fds).\n+  pub ro_fdslen: usize,\n+  /// Fields that were used by previous implementations.\n+  pub ro_unused: [u8; 40],\n+  /// Message flags.\n+  pub ro_flags: roflags,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn recv_out_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<recv_out>(), 52);\n+  assert_eq!(::core::mem::align_of::<recv_out>(), 4);\n+  unsafe {\n+    let obj: recv_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ro_datalen as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ro_fdslen as *const _ as usize - base, 4);\n+    assert_eq!(&obj.ro_unused as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ro_flags as *const _ as usize - base, 48);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn recv_out_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<recv_out>(), 64);\n+  assert_eq!(::core::mem::align_of::<recv_out>(), 8);\n+  unsafe {\n+    let obj: recv_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.ro_datalen as *const _ as usize - base, 0);\n+    assert_eq!(&obj.ro_fdslen as *const _ as usize - base, 8);\n+    assert_eq!(&obj.ro_unused as *const _ as usize - base, 16);\n+    assert_eq!(&obj.ro_flags as *const _ as usize - base, 56);\n+  }\n+}\n+\n+/// Arguments of [`sock_send()`](fn.sock_send.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct send_in {\n+  /// List of scatter/gather vectors where message data\n+  /// should be retrieved.\n+  pub si_data: (*const ciovec, usize),\n+  /// File descriptors that need to be attached to the\n+  /// message.\n+  pub si_fds: (*const fd, usize),\n+  /// Message flags.\n+  pub si_flags: siflags,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn send_in_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<send_in>(), 20);\n+  assert_eq!(::core::mem::align_of::<send_in>(), 4);\n+  unsafe {\n+    let obj: send_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.si_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.si_data.1 as *const _ as usize - base, 4);\n+    assert_eq!(&obj.si_fds.0 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.si_fds.1 as *const _ as usize - base, 12);\n+    assert_eq!(&obj.si_flags as *const _ as usize - base, 16);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn send_in_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<send_in>(), 40);\n+  assert_eq!(::core::mem::align_of::<send_in>(), 8);\n+  unsafe {\n+    let obj: send_in = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.si_data.0 as *const _ as usize - base, 0);\n+    assert_eq!(&obj.si_data.1 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.si_fds.0 as *const _ as usize - base, 16);\n+    assert_eq!(&obj.si_fds.1 as *const _ as usize - base, 24);\n+    assert_eq!(&obj.si_flags as *const _ as usize - base, 32);\n+  }\n+}\n+\n+/// Results of [`sock_send()`](fn.sock_send.html).\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct send_out {\n+  /// Number of bytes transmitted.\n+  pub so_datalen: usize,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn send_out_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<send_out>(), 4);\n+  assert_eq!(::core::mem::align_of::<send_out>(), 4);\n+  unsafe {\n+    let obj: send_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.so_datalen as *const _ as usize - base, 0);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn send_out_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<send_out>(), 8);\n+  assert_eq!(::core::mem::align_of::<send_out>(), 8);\n+  unsafe {\n+    let obj: send_out = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.so_datalen as *const _ as usize - base, 0);\n+  }\n+}\n+\n+/// Subscription to an event.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription {\n+  /// User-provided value that is attached to the\n+  /// subscription in the kernel and returned through\n+  /// [`event.userdata`](struct.event.html#structfield.userdata).\n+  pub userdata: userdata,\n+  /// Used by previous implementations. Ignored.\n+  pub unused: u16,\n+  /// The type of the event to which to subscribe.\n+  ///\n+  /// Currently, [`CONDVAR`](enum.eventtype.html#variant.CONDVAR),\n+  /// [`LOCK_RDLOCK`](enum.eventtype.html#variant.LOCK_RDLOCK), and [`LOCK_WRLOCK`](enum.eventtype.html#variant.LOCK_WRLOCK)\n+  /// must be provided as the first subscription and may\n+  /// only be followed by up to one other subscription,\n+  /// having type [`CLOCK`](enum.eventtype.html#variant.CLOCK).\n+  pub type_: eventtype,\n+  pub union: subscription_union\n+}\n+/// A union inside `subscription`.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub union subscription_union {\n+  /// Used when `type_` is [`CLOCK`](enum.eventtype.html#variant.CLOCK).\n+  pub clock: subscription_clock,\n+  /// Used when `type_` is [`CONDVAR`](enum.eventtype.html#variant.CONDVAR).\n+  pub condvar: subscription_condvar,\n+  /// Used when `type_` is [`FD_READ`](enum.eventtype.html#variant.FD_READ) or [`FD_WRITE`](enum.eventtype.html#variant.FD_WRITE).\n+  pub fd_readwrite: subscription_fd_readwrite,\n+  /// Used when `type_` is [`LOCK_RDLOCK`](enum.eventtype.html#variant.LOCK_RDLOCK) or [`LOCK_WRLOCK`](enum.eventtype.html#variant.LOCK_WRLOCK).\n+  pub lock: subscription_lock,\n+  /// Used when `type_` is [`PROC_TERMINATE`](enum.eventtype.html#variant.PROC_TERMINATE).\n+  pub proc_terminate: subscription_proc_terminate,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_clock {\n+  /// The user-defined unique\n+  /// identifier of the clock.\n+  pub identifier: userdata,\n+  /// The clock against which the\n+  /// timestamp should be compared.\n+  pub clock_id: clockid,\n+  /// The absolute or relative\n+  /// timestamp.\n+  pub timeout: timestamp,\n+  /// The amount of time that the\n+  /// kernel may wait additionally\n+  /// to coalesce with other events.\n+  pub precision: timestamp,\n+  /// Flags specifying whether the\n+  /// timeout is absolute or\n+  /// relative.\n+  pub flags: subclockflags,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_condvar {\n+  /// The condition variable on\n+  /// which to wait to be woken up.\n+  pub condvar: *mut condvar,\n+  /// The lock that will be\n+  /// released while waiting.\n+  ///\n+  /// The lock will be reacquired\n+  /// for writing when the condition\n+  /// variable triggers.\n+  pub lock: *mut lock,\n+  /// Whether the condition variable\n+  /// is stored in private or shared\n+  /// memory.\n+  pub condvar_scope: scope,\n+  /// Whether the lock is stored in\n+  /// private or shared memory.\n+  pub lock_scope: scope,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_fd_readwrite {\n+  /// The file descriptor on which\n+  /// to wait for it to become ready\n+  /// for reading or writing.\n+  pub fd: fd,\n+  /// Under which conditions to\n+  /// trigger.\n+  pub flags: subrwflags,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_lock {\n+  /// The lock that will be acquired\n+  /// for reading or writing.\n+  pub lock: *mut lock,\n+  /// Whether the lock is stored in\n+  /// private or shared memory.\n+  pub lock_scope: scope,\n+}\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct subscription_proc_terminate {\n+  /// The process descriptor on\n+  /// which to wait for process\n+  /// termination.\n+  pub fd: fd,\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn subscription_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<subscription>(), 56);\n+  assert_eq!(::core::mem::align_of::<subscription>(), 8);\n+  unsafe {\n+    let obj: subscription = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.userdata as *const _ as usize - base, 0);\n+    assert_eq!(&obj.unused as *const _ as usize - base, 8);\n+    assert_eq!(&obj.type_ as *const _ as usize - base, 10);\n+    assert_eq!(&obj.union.clock.identifier as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.clock.clock_id as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.clock.timeout as *const _ as usize - base, 32);\n+    assert_eq!(&obj.union.clock.precision as *const _ as usize - base, 40);\n+    assert_eq!(&obj.union.clock.flags as *const _ as usize - base, 48);\n+    assert_eq!(&obj.union.condvar.condvar as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.condvar.lock as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.condvar.condvar_scope as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.condvar.lock_scope as *const _ as usize - base, 25);\n+    assert_eq!(&obj.union.fd_readwrite.fd as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.fd_readwrite.flags as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.lock.lock as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.lock.lock_scope as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.proc_terminate.fd as *const _ as usize - base, 16);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn subscription_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<subscription>(), 56);\n+  assert_eq!(::core::mem::align_of::<subscription>(), 8);\n+  unsafe {\n+    let obj: subscription = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.userdata as *const _ as usize - base, 0);\n+    assert_eq!(&obj.unused as *const _ as usize - base, 8);\n+    assert_eq!(&obj.type_ as *const _ as usize - base, 10);\n+    assert_eq!(&obj.union.clock.identifier as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.clock.clock_id as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.clock.timeout as *const _ as usize - base, 32);\n+    assert_eq!(&obj.union.clock.precision as *const _ as usize - base, 40);\n+    assert_eq!(&obj.union.clock.flags as *const _ as usize - base, 48);\n+    assert_eq!(&obj.union.condvar.condvar as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.condvar.lock as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.condvar.condvar_scope as *const _ as usize - base, 32);\n+    assert_eq!(&obj.union.condvar.lock_scope as *const _ as usize - base, 33);\n+    assert_eq!(&obj.union.fd_readwrite.fd as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.fd_readwrite.flags as *const _ as usize - base, 20);\n+    assert_eq!(&obj.union.lock.lock as *const _ as usize - base, 16);\n+    assert_eq!(&obj.union.lock.lock_scope as *const _ as usize - base, 24);\n+    assert_eq!(&obj.union.proc_terminate.fd as *const _ as usize - base, 16);\n+  }\n+}\n+\n+/// The Thread Control Block (TCB).\n+///\n+/// After a thread begins execution (at program startup or when\n+/// created through [`thread_create()`](fn.thread_create.html)), the CPU's registers\n+/// controlling Thread-Local Storage (TLS) will already be\n+/// initialized. They will point to an area only containing the\n+/// TCB.\n+///\n+/// If the thread needs space for storing thread-specific\n+/// variables, the thread may allocate a larger area and adjust\n+/// the CPU's registers to point to that area instead. However, it\n+/// does need to make sure that the TCB is copied over to the new\n+/// TLS area.\n+///\n+/// The purpose of the TCB is that it allows light-weight\n+/// emulators to store information related to individual threads.\n+/// For example, it may be used to store a copy of the CPU\n+/// registers prior emulation, so that TLS for the host system\n+/// can be restored if needed.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct tcb {\n+  /// Pointer that may be freely assigned by the system. Its\n+  /// value cannot be interpreted by the application.\n+  pub parent: *mut (),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn tcb_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<tcb>(), 4);\n+  assert_eq!(::core::mem::align_of::<tcb>(), 4);\n+  unsafe {\n+    let obj: tcb = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.parent as *const _ as usize - base, 0);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn tcb_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<tcb>(), 8);\n+  assert_eq!(::core::mem::align_of::<tcb>(), 8);\n+  unsafe {\n+    let obj: tcb = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.parent as *const _ as usize - base, 0);\n+  }\n+}\n+\n+/// Entry point for additionally created threads.\n+///\n+/// **tid**:\n+/// Thread ID of the current thread.\n+///\n+/// **aux**:\n+/// Copy of the value stored in\n+/// [`threadattr.argument`](struct.threadattr.html#structfield.argument).\n+pub type threadentry = unsafe extern \"C\" fn(\n+  tid: tid,\n+  aux: *mut (),\n+) -> ();\n+\n+/// Attributes for thread creation.\n+#[repr(C)]\n+#[derive(Copy, Clone)]\n+pub struct threadattr {\n+  /// Initial program counter value.\n+  pub entry_point: threadentry,\n+  /// Region allocated to serve as stack space.\n+  pub stack: (*mut (), usize),\n+  /// Argument to be forwarded to the entry point function.\n+  pub argument: *mut (),\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"32\")]\n+fn threadattr_layout_test_32() {\n+  assert_eq!(::core::mem::size_of::<threadattr>(), 16);\n+  assert_eq!(::core::mem::align_of::<threadattr>(), 4);\n+  unsafe {\n+    let obj: threadattr = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.entry_point as *const _ as usize - base, 0);\n+    assert_eq!(&obj.stack.0 as *const _ as usize - base, 4);\n+    assert_eq!(&obj.stack.1 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.argument as *const _ as usize - base, 12);\n+  }\n+}\n+#[test]\n+#[cfg(target_pointer_width = \"64\")]\n+fn threadattr_layout_test_64() {\n+  assert_eq!(::core::mem::size_of::<threadattr>(), 32);\n+  assert_eq!(::core::mem::align_of::<threadattr>(), 8);\n+  unsafe {\n+    let obj: threadattr = ::core::mem::uninitialized();\n+    let base = &obj as *const _ as usize;\n+    assert_eq!(&obj.entry_point as *const _ as usize - base, 0);\n+    assert_eq!(&obj.stack.0 as *const _ as usize - base, 8);\n+    assert_eq!(&obj.stack.1 as *const _ as usize - base, 16);\n+    assert_eq!(&obj.argument as *const _ as usize - base, 24);\n+  }\n+}\n+\n+/// The table with pointers to all syscall implementations.\n+#[allow(improper_ctypes)]\n+extern \"C\" {\n+  fn cloudabi_sys_clock_res_get(_: clockid, _: *mut timestamp) -> errno;\n+  fn cloudabi_sys_clock_time_get(_: clockid, _: timestamp, _: *mut timestamp) -> errno;\n+  fn cloudabi_sys_condvar_signal(_: *mut condvar, _: scope, _: nthreads) -> errno;\n+  fn cloudabi_sys_fd_close(_: fd) -> errno;\n+  fn cloudabi_sys_fd_create1(_: filetype, _: *mut fd) -> errno;\n+  fn cloudabi_sys_fd_create2(_: filetype, _: *mut fd, _: *mut fd) -> errno;\n+  fn cloudabi_sys_fd_datasync(_: fd) -> errno;\n+  fn cloudabi_sys_fd_dup(_: fd, _: *mut fd) -> errno;\n+  fn cloudabi_sys_fd_pread(_: fd, _: *const iovec, _: usize, _: filesize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_fd_pwrite(_: fd, _: *const ciovec, _: usize, _: filesize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_fd_read(_: fd, _: *const iovec, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_fd_replace(_: fd, _: fd) -> errno;\n+  fn cloudabi_sys_fd_seek(_: fd, _: filedelta, _: whence, _: *mut filesize) -> errno;\n+  fn cloudabi_sys_fd_stat_get(_: fd, _: *mut fdstat) -> errno;\n+  fn cloudabi_sys_fd_stat_put(_: fd, _: *const fdstat, _: fdsflags) -> errno;\n+  fn cloudabi_sys_fd_sync(_: fd) -> errno;\n+  fn cloudabi_sys_fd_write(_: fd, _: *const ciovec, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_file_advise(_: fd, _: filesize, _: filesize, _: advice) -> errno;\n+  fn cloudabi_sys_file_allocate(_: fd, _: filesize, _: filesize) -> errno;\n+  fn cloudabi_sys_file_create(_: fd, _: *const u8, _: usize, _: filetype) -> errno;\n+  fn cloudabi_sys_file_link(_: lookup, _: *const u8, _: usize, _: fd, _: *const u8, _: usize) -> errno;\n+  fn cloudabi_sys_file_open(_: lookup, _: *const u8, _: usize, _: oflags, _: *const fdstat, _: *mut fd) -> errno;\n+  fn cloudabi_sys_file_readdir(_: fd, _: *mut (), _: usize, _: dircookie, _: *mut usize) -> errno;\n+  fn cloudabi_sys_file_readlink(_: fd, _: *const u8, _: usize, _: *mut u8, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_file_rename(_: fd, _: *const u8, _: usize, _: fd, _: *const u8, _: usize) -> errno;\n+  fn cloudabi_sys_file_stat_fget(_: fd, _: *mut filestat) -> errno;\n+  fn cloudabi_sys_file_stat_fput(_: fd, _: *const filestat, _: fsflags) -> errno;\n+  fn cloudabi_sys_file_stat_get(_: lookup, _: *const u8, _: usize, _: *mut filestat) -> errno;\n+  fn cloudabi_sys_file_stat_put(_: lookup, _: *const u8, _: usize, _: *const filestat, _: fsflags) -> errno;\n+  fn cloudabi_sys_file_symlink(_: *const u8, _: usize, _: fd, _: *const u8, _: usize) -> errno;\n+  fn cloudabi_sys_file_unlink(_: fd, _: *const u8, _: usize, _: ulflags) -> errno;\n+  fn cloudabi_sys_lock_unlock(_: *mut lock, _: scope) -> errno;\n+  fn cloudabi_sys_mem_advise(_: *mut (), _: usize, _: advice) -> errno;\n+  fn cloudabi_sys_mem_map(_: *mut (), _: usize, _: mprot, _: mflags, _: fd, _: filesize, _: *mut *mut ()) -> errno;\n+  fn cloudabi_sys_mem_protect(_: *mut (), _: usize, _: mprot) -> errno;\n+  fn cloudabi_sys_mem_sync(_: *mut (), _: usize, _: msflags) -> errno;\n+  fn cloudabi_sys_mem_unmap(_: *mut (), _: usize) -> errno;\n+  fn cloudabi_sys_poll(_: *const subscription, _: *mut event, _: usize, _: *mut usize) -> errno;\n+  fn cloudabi_sys_proc_exec(_: fd, _: *const (), _: usize, _: *const fd, _: usize) -> errno;\n+  fn cloudabi_sys_proc_exit(_: exitcode) -> !;\n+  fn cloudabi_sys_proc_fork(_: *mut fd, _: *mut tid) -> errno;\n+  fn cloudabi_sys_proc_raise(_: signal) -> errno;\n+  fn cloudabi_sys_random_get(_: *mut (), _: usize) -> errno;\n+  fn cloudabi_sys_sock_recv(_: fd, _: *const recv_in, _: *mut recv_out) -> errno;\n+  fn cloudabi_sys_sock_send(_: fd, _: *const send_in, _: *mut send_out) -> errno;\n+  fn cloudabi_sys_sock_shutdown(_: fd, _: sdflags) -> errno;\n+  fn cloudabi_sys_thread_create(_: *mut threadattr, _: *mut tid) -> errno;\n+  fn cloudabi_sys_thread_exit(_: *mut lock, _: scope) -> !;\n+  fn cloudabi_sys_thread_yield() -> errno;\n+}\n+\n+/// Obtains the resolution of a clock.\n+///\n+/// ## Parameters\n+///\n+/// **clock_id**:\n+/// The clock for which the resolution needs to be\n+/// returned.\n+///\n+/// **resolution**:\n+/// The resolution of the clock.\n+#[inline]\n+pub unsafe fn clock_res_get(clock_id_: clockid, resolution_: &mut timestamp) -> errno {\n+  cloudabi_sys_clock_res_get(clock_id_, resolution_)\n+}\n+\n+/// Obtains the time value of a clock.\n+///\n+/// ## Parameters\n+///\n+/// **clock_id**:\n+/// The clock for which the time needs to be\n+/// returned.\n+///\n+/// **precision**:\n+/// The maximum lag (exclusive) that the returned\n+/// time value may have, compared to its actual\n+/// value.\n+///\n+/// **time**:\n+/// The time value of the clock.\n+#[inline]\n+pub unsafe fn clock_time_get(clock_id_: clockid, precision_: timestamp, time_: &mut timestamp) -> errno {\n+  cloudabi_sys_clock_time_get(clock_id_, precision_, time_)\n+}\n+\n+/// Wakes up threads waiting on a userspace condition variable.\n+///\n+/// If an invocation of this system call causes all waiting\n+/// threads to be woken up, the value of the condition variable\n+/// is set to [`CONDVAR_HAS_NO_WAITERS`](constant.CONDVAR_HAS_NO_WAITERS.html). As long as the condition\n+/// variable is set to this value, it is not needed to invoke this\n+/// system call.\n+///\n+/// ## Parameters\n+///\n+/// **condvar**:\n+/// The userspace condition variable that has\n+/// waiting threads.\n+///\n+/// **scope**:\n+/// Whether the condition variable is stored in\n+/// private or shared memory.\n+///\n+/// **nwaiters**:\n+/// The number of threads that need to be woken\n+/// up. If it exceeds the number of waiting\n+/// threads, all threads are woken up.\n+#[inline]\n+pub unsafe fn condvar_signal(condvar_: *mut condvar, scope_: scope, nwaiters_: nthreads) -> errno {\n+  cloudabi_sys_condvar_signal(condvar_, scope_, nwaiters_)\n+}\n+\n+/// Closes a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor that needs to be closed.\n+#[inline]\n+pub unsafe fn fd_close(fd_: fd) -> errno {\n+  cloudabi_sys_fd_close(fd_)\n+}\n+\n+/// Creates a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **type**:\n+/// Possible values:\n+///\n+///   - [`SHARED_MEMORY`](enum.filetype.html#variant.SHARED_MEMORY):\n+///     Creates an anonymous shared memory\n+///     object.\n+///\n+/// **fd**:\n+/// The file descriptor that has been created.\n+#[inline]\n+pub unsafe fn fd_create1(type_: filetype, fd_: &mut fd) -> errno {\n+  cloudabi_sys_fd_create1(type_, fd_)\n+}\n+\n+/// Creates a pair of file descriptors.\n+///\n+/// ## Parameters\n+///\n+/// **type**:\n+/// Possible values:\n+///\n+///   - [`SOCKET_DGRAM`](enum.filetype.html#variant.SOCKET_DGRAM):\n+///     Creates a UNIX datagram socket pair.\n+///   - [`SOCKET_STREAM`](enum.filetype.html#variant.SOCKET_STREAM):\n+///     Creates a UNIX byte-stream socket\n+///     pair.\n+///\n+/// **fd1**:\n+/// The first file descriptor of the pair.\n+///\n+/// **fd2**:\n+/// The second file descriptor of the pair.\n+#[inline]\n+pub unsafe fn fd_create2(type_: filetype, fd1_: &mut fd, fd2_: &mut fd) -> errno {\n+  cloudabi_sys_fd_create2(type_, fd1_, fd2_)\n+}\n+\n+/// Synchronizes the data of a file to disk.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor of the file whose data\n+/// needs to be synchronized to disk.\n+#[inline]\n+pub unsafe fn fd_datasync(fd_: fd) -> errno {\n+  cloudabi_sys_fd_datasync(fd_)\n+}\n+\n+/// Duplicates a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **from**:\n+/// The file descriptor that needs to be\n+/// duplicated.\n+///\n+/// **fd**:\n+/// The new file descriptor.\n+#[inline]\n+pub unsafe fn fd_dup(from_: fd, fd_: &mut fd) -> errno {\n+  cloudabi_sys_fd_dup(from_, fd_)\n+}\n+\n+/// Reads from a file descriptor, without using and updating the\n+/// file descriptor's offset.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor from which data should be\n+/// read.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be stored.\n+///\n+/// **offset**:\n+/// The offset within the file at which reading\n+/// should start.\n+///\n+/// **nread**:\n+/// The number of bytes read.\n+#[inline]\n+pub unsafe fn fd_pread(fd_: fd, iovs_: &[iovec], offset_: filesize, nread_: &mut usize) -> errno {\n+  cloudabi_sys_fd_pread(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nread_)\n+}\n+\n+/// Writes to a file descriptor, without using and updating the\n+/// file descriptor's offset.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor to which data should be\n+/// written.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be retrieved.\n+///\n+/// **offset**:\n+/// The offset within the file at which writing\n+/// should start.\n+///\n+/// **nwritten**:\n+/// The number of bytes written.\n+#[inline]\n+pub unsafe fn fd_pwrite(fd_: fd, iovs_: &[ciovec], offset_: filesize, nwritten_: &mut usize) -> errno {\n+  cloudabi_sys_fd_pwrite(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nwritten_)\n+}\n+\n+/// Reads from a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor from which data should be\n+/// read.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be stored.\n+///\n+/// **nread**:\n+/// The number of bytes read.\n+#[inline]\n+pub unsafe fn fd_read(fd_: fd, iovs_: &[iovec], nread_: &mut usize) -> errno {\n+  cloudabi_sys_fd_read(fd_, iovs_.as_ptr(), iovs_.len(), nread_)\n+}\n+\n+/// Atomically replaces a file descriptor by a copy of another\n+/// file descriptor.\n+///\n+/// Due to the strong focus on thread safety, this environment\n+/// does not provide a mechanism to duplicate a file descriptor to\n+/// an arbitrary number, like dup2(). This would be prone to race\n+/// conditions, as an actual file descriptor with the same number\n+/// could be allocated by a different thread at the same time.\n+///\n+/// This system call provides a way to atomically replace file\n+/// descriptors, which would disappear if dup2() were to be\n+/// removed entirely.\n+///\n+/// ## Parameters\n+///\n+/// **from**:\n+/// The file descriptor that needs to be copied.\n+///\n+/// **to**:\n+/// The file descriptor that needs to be\n+/// overwritten.\n+#[inline]\n+pub unsafe fn fd_replace(from_: fd, to_: fd) -> errno {\n+  cloudabi_sys_fd_replace(from_, to_)\n+}\n+\n+/// Moves the offset of the file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose offset has to be\n+/// moved.\n+///\n+/// **offset**:\n+/// The number of bytes to move.\n+///\n+/// **whence**:\n+/// Relative to which position the move should\n+/// take place.\n+///\n+/// **newoffset**:\n+/// The new offset of the file descriptor,\n+/// relative to the start of the file.\n+#[inline]\n+pub unsafe fn fd_seek(fd_: fd, offset_: filedelta, whence_: whence, newoffset_: &mut filesize) -> errno {\n+  cloudabi_sys_fd_seek(fd_, offset_, whence_, newoffset_)\n+}\n+\n+/// Gets attributes of a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be obtained.\n+///\n+/// **buf**:\n+/// The buffer where the file descriptor's\n+/// attributes are stored.\n+#[inline]\n+pub unsafe fn fd_stat_get(fd_: fd, buf_: *mut fdstat) -> errno {\n+  cloudabi_sys_fd_stat_get(fd_, buf_)\n+}\n+\n+/// Adjusts attributes of a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be adjusted.\n+///\n+/// **buf**:\n+/// The desired values of the file descriptor\n+/// attributes that are adjusted.\n+///\n+/// **flags**:\n+/// A bitmask indicating which attributes have to\n+/// be adjusted.\n+#[inline]\n+pub unsafe fn fd_stat_put(fd_: fd, buf_: *const fdstat, flags_: fdsflags) -> errno {\n+  cloudabi_sys_fd_stat_put(fd_, buf_, flags_)\n+}\n+\n+/// Synchronizes the data and metadata of a file to disk.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor of the file whose data\n+/// and metadata needs to be synchronized to disk.\n+#[inline]\n+pub unsafe fn fd_sync(fd_: fd) -> errno {\n+  cloudabi_sys_fd_sync(fd_)\n+}\n+\n+/// Writes to a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor to which data should be\n+/// written.\n+///\n+/// **iovs**:\n+/// List of scatter/gather vectors where data\n+/// should be retrieved.\n+///\n+/// **nwritten**:\n+/// The number of bytes written.\n+#[inline]\n+pub unsafe fn fd_write(fd_: fd, iovs_: &[ciovec], nwritten_: &mut usize) -> errno {\n+  cloudabi_sys_fd_write(fd_, iovs_.as_ptr(), iovs_.len(), nwritten_)\n+}\n+\n+/// Provides file advisory information on a file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor for which to provide file\n+/// advisory information.\n+///\n+/// **offset**:\n+/// The offset within the file to which the\n+/// advisory applies.\n+///\n+/// **len**:\n+/// The length of the region to which the advisory\n+/// applies.\n+///\n+/// **advice**:\n+/// The advice.\n+#[inline]\n+pub unsafe fn file_advise(fd_: fd, offset_: filesize, len_: filesize, advice_: advice) -> errno {\n+  cloudabi_sys_file_advise(fd_, offset_, len_, advice_)\n+}\n+\n+/// Forces the allocation of space in a file.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file in which the space should be\n+/// allocated.\n+///\n+/// **offset**:\n+/// The offset at which the allocation should\n+/// start.\n+///\n+/// **len**:\n+/// The length of the area that is allocated.\n+#[inline]\n+pub unsafe fn file_allocate(fd_: fd, offset_: filesize, len_: filesize) -> errno {\n+  cloudabi_sys_file_allocate(fd_, offset_, len_)\n+}\n+\n+/// Creates a file of a specified type.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the file to be created starts.\n+///\n+/// **path**:\n+/// The path at which the file should be created.\n+///\n+/// **type**:\n+/// Possible values:\n+///\n+///   - [`DIRECTORY`](enum.filetype.html#variant.DIRECTORY):\n+///     Creates a directory.\n+#[inline]\n+pub unsafe fn file_create(fd_: fd, path_: &[u8], type_: filetype) -> errno {\n+  cloudabi_sys_file_create(fd_, path_.as_ptr(), path_.len(), type_)\n+}\n+\n+/// Creates a hard link.\n+///\n+/// ## Parameters\n+///\n+/// **fd1**:\n+/// The working directory at which the resolution\n+/// of the source path starts.\n+///\n+/// **path1**:\n+/// The source path of the file that should be\n+/// hard linked.\n+///\n+/// **fd2**:\n+/// The working directory at which the resolution\n+/// of the destination path starts.\n+///\n+/// **path2**:\n+/// The destination path at which the hard link\n+/// should be created.\n+#[inline]\n+pub unsafe fn file_link(fd1_: lookup, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n+  cloudabi_sys_file_link(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len())\n+}\n+\n+/// Opens a file.\n+///\n+/// ## Parameters\n+///\n+/// **dirfd**:\n+/// The working directory at which the resolution\n+/// of the file to be opened starts.\n+///\n+/// **path**:\n+/// The path of the file that should be opened.\n+///\n+/// **oflags**:\n+/// The method at which the file should be opened.\n+///\n+/// **fds**:\n+/// [`fdstat.fs_rights_base`](struct.fdstat.html#structfield.fs_rights_base) and\n+/// [`fdstat.fs_rights_inheriting`](struct.fdstat.html#structfield.fs_rights_inheriting) specify the\n+/// initial rights of the newly created file\n+/// descriptor. The operating system is allowed to\n+/// return a file descriptor with fewer rights\n+/// than specified, if and only if those rights do\n+/// not apply to the type of file being opened.\n+///\n+/// [`fdstat.fs_flags`](struct.fdstat.html#structfield.fs_flags) specifies the initial flags\n+/// of the file descriptor.\n+///\n+/// [`fdstat.fs_filetype`](struct.fdstat.html#structfield.fs_filetype) is ignored.\n+///\n+/// **fd**:\n+/// The file descriptor of the file that has been\n+/// opened.\n+#[inline]\n+pub unsafe fn file_open(dirfd_: lookup, path_: &[u8], oflags_: oflags, fds_: *const fdstat, fd_: &mut fd) -> errno {\n+  cloudabi_sys_file_open(dirfd_, path_.as_ptr(), path_.len(), oflags_, fds_, fd_)\n+}\n+\n+/// Reads directory entries from a directory.\n+///\n+/// When successful, the contents of the output buffer consist of\n+/// a sequence of directory entries. Each directory entry consists\n+/// of a [`dirent`](struct.dirent.html) object, followed by [`dirent.d_namlen`](struct.dirent.html#structfield.d_namlen) bytes\n+/// holding the name of the directory entry.\n+///\n+/// This system call fills the output buffer as much as possible,\n+/// potentially truncating the last directory entry. This allows\n+/// the caller to grow its read buffer size in case it's too small\n+/// to fit a single large directory entry, or skip the oversized\n+/// directory entry.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The directory from which to read the directory\n+/// entries.\n+///\n+/// **buf**:\n+/// The buffer where directory entries are stored.\n+///\n+/// **cookie**:\n+/// The location within the directory to start\n+/// reading.\n+///\n+/// **bufused**:\n+/// The number of bytes stored in the read buffer.\n+/// If less than the size of the read buffer, the\n+/// end of the directory has been reached.\n+#[inline]\n+pub unsafe fn file_readdir(fd_: fd, buf_: &mut [u8], cookie_: dircookie, bufused_: &mut usize) -> errno {\n+  cloudabi_sys_file_readdir(fd_, buf_.as_mut_ptr() as *mut (), buf_.len(), cookie_, bufused_)\n+}\n+\n+/// Reads the contents of a symbolic link.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path of the symbolic starts.\n+///\n+/// **path**:\n+/// The path of the symbolic link whose contents\n+/// should be read.\n+///\n+/// **buf**:\n+/// The buffer where the contents of the symbolic\n+/// link should be stored.\n+///\n+/// **bufused**:\n+/// The number of bytes placed in the buffer.\n+#[inline]\n+pub unsafe fn file_readlink(fd_: fd, path_: &[u8], buf_: &mut [u8], bufused_: &mut usize) -> errno {\n+  cloudabi_sys_file_readlink(fd_, path_.as_ptr(), path_.len(), buf_.as_mut_ptr(), buf_.len(), bufused_)\n+}\n+\n+/// Renames a file.\n+///\n+/// ## Parameters\n+///\n+/// **fd1**:\n+/// The working directory at which the resolution\n+/// of the source path starts.\n+///\n+/// **path1**:\n+/// The source path of the file that should be\n+/// renamed.\n+///\n+/// **fd2**:\n+/// The working directory at which the resolution\n+/// of the destination path starts.\n+///\n+/// **path2**:\n+/// The destination path to which the file should\n+/// be renamed.\n+#[inline]\n+pub unsafe fn file_rename(fd1_: fd, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n+  cloudabi_sys_file_rename(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len())\n+}\n+\n+/// Gets attributes of a file by file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be obtained.\n+///\n+/// **buf**:\n+/// The buffer where the file's attributes are\n+/// stored.\n+#[inline]\n+pub unsafe fn file_stat_fget(fd_: fd, buf_: *mut filestat) -> errno {\n+  cloudabi_sys_file_stat_fget(fd_, buf_)\n+}\n+\n+/// Adjusts attributes of a file by file descriptor.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The file descriptor whose attributes have to\n+/// be adjusted.\n+///\n+/// **buf**:\n+/// The desired values of the file attributes that\n+/// are adjusted.\n+///\n+/// **flags**:\n+/// A bitmask indicating which attributes have to\n+/// be adjusted.\n+#[inline]\n+pub unsafe fn file_stat_fput(fd_: fd, buf_: *const filestat, flags_: fsflags) -> errno {\n+  cloudabi_sys_file_stat_fput(fd_, buf_, flags_)\n+}\n+\n+/// Gets attributes of a file by path.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path whose attributes have to be\n+/// obtained starts.\n+///\n+/// **path**:\n+/// The path of the file whose attributes have to\n+/// be obtained.\n+///\n+/// **buf**:\n+/// The buffer where the file's attributes are\n+/// stored.\n+#[inline]\n+pub unsafe fn file_stat_get(fd_: lookup, path_: &[u8], buf_: *mut filestat) -> errno {\n+  cloudabi_sys_file_stat_get(fd_, path_.as_ptr(), path_.len(), buf_)\n+}\n+\n+/// Adjusts attributes of a file by path.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path whose attributes have to be\n+/// adjusted starts.\n+///\n+/// **path**:\n+/// The path of the file whose attributes have to\n+/// be adjusted.\n+///\n+/// **buf**:\n+/// The desired values of the file attributes that\n+/// are adjusted.\n+///\n+/// **flags**:\n+/// A bitmask indicating which attributes have to\n+/// be adjusted.\n+#[inline]\n+pub unsafe fn file_stat_put(fd_: lookup, path_: &[u8], buf_: *const filestat, flags_: fsflags) -> errno {\n+  cloudabi_sys_file_stat_put(fd_, path_.as_ptr(), path_.len(), buf_, flags_)\n+}\n+\n+/// Creates a symbolic link.\n+///\n+/// ## Parameters\n+///\n+/// **path1**:\n+/// The contents of the symbolic link.\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the destination path starts.\n+///\n+/// **path2**:\n+/// The destination path at which the symbolic\n+/// link should be created.\n+#[inline]\n+pub unsafe fn file_symlink(path1_: &[u8], fd_: fd, path2_: &[u8]) -> errno {\n+  cloudabi_sys_file_symlink(path1_.as_ptr(), path1_.len(), fd_, path2_.as_ptr(), path2_.len())\n+}\n+\n+/// Unlinks a file, or removes a directory.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// The working directory at which the resolution\n+/// of the path starts.\n+///\n+/// **path**:\n+/// The path that needs to be unlinked or removed.\n+///\n+/// **flags**:\n+/// Possible values:\n+///\n+///   - [`REMOVEDIR`](struct.ulflags.html#associatedconstant.REMOVEDIR):\n+///     If set, attempt to remove a directory.\n+///     Otherwise, unlink a file.\n+#[inline]\n+pub unsafe fn file_unlink(fd_: fd, path_: &[u8], flags_: ulflags) -> errno {\n+  cloudabi_sys_file_unlink(fd_, path_.as_ptr(), path_.len(), flags_)\n+}\n+\n+/// Unlocks a write-locked userspace lock.\n+///\n+/// If a userspace lock is unlocked while having its\n+/// [`LOCK_KERNEL_MANAGED`](constant.LOCK_KERNEL_MANAGED.html) flag set, the lock cannot be unlocked in\n+/// userspace directly. This system call needs to be performed\n+/// instead, so that any waiting threads can be woken up.\n+///\n+/// To prevent spurious invocations of this system call, the lock\n+/// must be locked for writing. This prevents other threads from\n+/// acquiring additional read locks while the system call is in\n+/// progress. If the lock is acquired for reading, it must first\n+/// be upgraded to a write lock.\n+///\n+/// ## Parameters\n+///\n+/// **lock**:\n+/// The userspace lock that is locked for writing\n+/// by the calling thread.\n+///\n+/// **scope**:\n+/// Whether the lock is stored in private or\n+/// shared memory.\n+#[inline]\n+pub unsafe fn lock_unlock(lock_: *mut lock, scope_: scope) -> errno {\n+  cloudabi_sys_lock_unlock(lock_, scope_)\n+}\n+\n+/// Provides memory advisory information on a region of memory.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages for which to provide memory advisory\n+/// information.\n+///\n+/// **advice**:\n+/// The advice.\n+#[inline]\n+pub unsafe fn mem_advise(mapping_: &mut [u8], advice_: advice) -> errno {\n+  cloudabi_sys_mem_advise(mapping_.as_mut_ptr() as *mut (), mapping_.len(), advice_)\n+}\n+\n+/// Creates a memory mapping, making the contents of a file\n+/// accessible through memory.\n+///\n+/// ## Parameters\n+///\n+/// **addr**:\n+/// If [`FIXED`](struct.mflags.html#associatedconstant.FIXED) is set, specifies to which\n+/// address the file region is mapped. Otherwise,\n+/// the mapping is performed at an unused\n+/// location.\n+///\n+/// **len**:\n+/// The length of the memory mapping to be\n+/// created.\n+///\n+/// **prot**:\n+/// Initial memory protection options for the\n+/// memory mapping.\n+///\n+/// **flags**:\n+/// Memory mapping flags.\n+///\n+/// **fd**:\n+/// If [`ANON`](struct.mflags.html#associatedconstant.ANON) is set, this argument must be\n+/// [`MAP_ANON_FD`](constant.MAP_ANON_FD.html). Otherwise, this argument\n+/// specifies the file whose contents need to be\n+/// mapped.\n+///\n+/// **off**:\n+/// If [`ANON`](struct.mflags.html#associatedconstant.ANON) is set, this argument must be\n+/// zero. Otherwise, this argument specifies the\n+/// offset within the file at which the mapping\n+/// starts.\n+///\n+/// **mem**:\n+/// The starting address of the memory mapping.\n+#[inline]\n+pub unsafe fn mem_map(addr_: *mut (), len_: usize, prot_: mprot, flags_: mflags, fd_: fd, off_: filesize, mem_: &mut *mut ()) -> errno {\n+  cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_)\n+}\n+\n+/// Change the protection of a memory mapping.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages that need their protection changed.\n+///\n+/// **prot**:\n+/// New protection options.\n+#[inline]\n+pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n+  cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_)\n+}\n+\n+/// Synchronize a region of memory with its physical storage.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages that need to be synchronized.\n+///\n+/// **flags**:\n+/// The method of synchronization.\n+#[inline]\n+pub unsafe fn mem_sync(mapping_: &mut [u8], flags_: msflags) -> errno {\n+  cloudabi_sys_mem_sync(mapping_.as_mut_ptr() as *mut (), mapping_.len(), flags_)\n+}\n+\n+/// Unmaps a region of memory.\n+///\n+/// ## Parameters\n+///\n+/// **mapping**:\n+/// The pages that needs to be unmapped.\n+#[inline]\n+pub unsafe fn mem_unmap(mapping_: &mut [u8]) -> errno {\n+  cloudabi_sys_mem_unmap(mapping_.as_mut_ptr() as *mut (), mapping_.len())\n+}\n+\n+/// Concurrently polls for the occurrence of a set of events.\n+///\n+/// ## Parameters\n+///\n+/// **in**:\n+/// The events to which to subscribe.\n+///\n+/// **out**:\n+/// The events that have occurred.\n+///\n+/// **nsubscriptions**:\n+/// Both the number of subscriptions and events.\n+///\n+/// **nevents**:\n+/// The number of events stored.\n+#[inline]\n+pub unsafe fn poll(in_: *const subscription, out_: *mut event, nsubscriptions_: usize, nevents_: &mut usize) -> errno {\n+  cloudabi_sys_poll(in_, out_, nsubscriptions_, nevents_)\n+}\n+\n+/// Replaces the process by a new executable.\n+///\n+/// Process execution in CloudABI differs from POSIX in two ways:\n+/// handling of arguments and inheritance of file descriptors.\n+///\n+/// CloudABI does not use string command line arguments. Instead,\n+/// a buffer with binary data is copied into the address space of\n+/// the new executable. The kernel does not enforce any specific\n+/// structure to this data, although CloudABI's C library uses it\n+/// to store a tree structure that is semantically identical to\n+/// YAML.\n+///\n+/// Due to the strong focus on thread safety, file descriptors\n+/// aren't inherited through close-on-exec flags. An explicit\n+/// list of file descriptors that need to be retained needs to be\n+/// provided. After execution, file descriptors are placed in the\n+/// order in which they are stored in the array. This not only\n+/// makes the execution process deterministic. It also prevents\n+/// potential information disclosures about the layout of the\n+/// original process.\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// A file descriptor of the new executable.\n+///\n+/// **data**:\n+/// Binary argument data that is passed on to the\n+/// new executable.\n+///\n+/// **fds**:\n+/// The layout of the file descriptor table after\n+/// execution.\n+#[inline]\n+pub unsafe fn proc_exec(fd_: fd, data_: &[u8], fds_: &[fd]) -> errno {\n+  cloudabi_sys_proc_exec(fd_, data_.as_ptr() as *const (), data_.len(), fds_.as_ptr(), fds_.len())\n+}\n+\n+/// Terminates the process normally.\n+///\n+/// ## Parameters\n+///\n+/// **rval**:\n+/// The exit code returned by the process. The\n+/// exit code can be obtained by other processes\n+/// through [`event.union.proc_terminate.exitcode`](struct.event_proc_terminate.html#structfield.exitcode).\n+#[inline]\n+pub unsafe fn proc_exit(rval_: exitcode) -> ! {\n+  cloudabi_sys_proc_exit(rval_)\n+}\n+\n+/// Forks the process of the calling thread.\n+///\n+/// After forking, a new process shall be created, having only a\n+/// copy of the calling thread. The parent process will obtain a\n+/// process descriptor. When closed, the child process is\n+/// automatically signaled with [`KILL`](enum.signal.html#variant.KILL).\n+///\n+/// ## Parameters\n+///\n+/// **fd**:\n+/// In the parent process: the file descriptor\n+/// number of the process descriptor.\n+///\n+/// In the child process: [`PROCESS_CHILD`](constant.PROCESS_CHILD.html).\n+///\n+/// **tid**:\n+/// In the parent process: undefined.\n+///\n+/// In the child process: the thread ID of the\n+/// initial thread of the child process.\n+#[inline]\n+pub unsafe fn proc_fork(fd_: &mut fd, tid_: &mut tid) -> errno {\n+  cloudabi_sys_proc_fork(fd_, tid_)\n+}\n+\n+/// Sends a signal to the process of the calling thread.\n+///\n+/// ## Parameters\n+///\n+/// **sig**:\n+/// The signal condition that should be triggered.\n+/// If the signal causes the process to terminate,\n+/// its condition can be obtained by other\n+/// processes through\n+/// [`event.union.proc_terminate.signal`](struct.event_proc_terminate.html#structfield.signal).\n+#[inline]\n+pub unsafe fn proc_raise(sig_: signal) -> errno {\n+  cloudabi_sys_proc_raise(sig_)\n+}\n+\n+/// Obtains random data from the kernel random number generator.\n+///\n+/// As this interface is not guaranteed to be fast, it is advised\n+/// that the random data obtained through this system call is used\n+/// as the seed for a userspace pseudo-random number generator.\n+///\n+/// ## Parameters\n+///\n+/// **buf**:\n+/// The buffer that needs to be filled with random\n+/// data.\n+#[inline]\n+pub unsafe fn random_get(buf_: &mut [u8]) -> errno {\n+  cloudabi_sys_random_get(buf_.as_mut_ptr() as *mut (), buf_.len())\n+}\n+\n+/// Receives a message on a socket.\n+///\n+/// ## Parameters\n+///\n+/// **sock**:\n+/// The socket on which a message should be\n+/// received.\n+///\n+/// **in**:\n+/// Input parameters.\n+///\n+/// **out**:\n+/// Output parameters.\n+#[inline]\n+pub unsafe fn sock_recv(sock_: fd, in_: *const recv_in, out_: *mut recv_out) -> errno {\n+  cloudabi_sys_sock_recv(sock_, in_, out_)\n+}\n+\n+/// Sends a message on a socket.\n+///\n+/// ## Parameters\n+///\n+/// **sock**:\n+/// The socket on which a message should be sent.\n+///\n+/// **in**:\n+/// Input parameters.\n+///\n+/// **out**:\n+/// Output parameters.\n+#[inline]\n+pub unsafe fn sock_send(sock_: fd, in_: *const send_in, out_: *mut send_out) -> errno {\n+  cloudabi_sys_sock_send(sock_, in_, out_)\n+}\n+\n+/// Shuts down socket send and receive channels.\n+///\n+/// ## Parameters\n+///\n+/// **sock**:\n+/// The socket that needs its channels shut down.\n+///\n+/// **how**:\n+/// Which channels on the socket need to be shut\n+/// down.\n+#[inline]\n+pub unsafe fn sock_shutdown(sock_: fd, how_: sdflags) -> errno {\n+  cloudabi_sys_sock_shutdown(sock_, how_)\n+}\n+\n+/// Creates a new thread within the current process.\n+///\n+/// ## Parameters\n+///\n+/// **attr**:\n+/// The desired attributes of the new thread.\n+///\n+/// **tid**:\n+/// The thread ID of the new thread.\n+#[inline]\n+pub unsafe fn thread_create(attr_: *mut threadattr, tid_: &mut tid) -> errno {\n+  cloudabi_sys_thread_create(attr_, tid_)\n+}\n+\n+/// Terminates the calling thread.\n+///\n+/// This system call can also unlock a single userspace lock\n+/// after termination, which can be used to implement thread\n+/// joining.\n+///\n+/// ## Parameters\n+///\n+/// **lock**:\n+/// Userspace lock that is locked for writing by\n+/// the calling thread.\n+///\n+/// **scope**:\n+/// Whether the lock is stored in private or\n+/// shared memory.\n+#[inline]\n+pub unsafe fn thread_exit(lock_: *mut lock, scope_: scope) -> ! {\n+  cloudabi_sys_thread_exit(lock_, scope_)\n+}\n+\n+/// Temporarily yields execution of the calling thread.\n+#[inline]\n+pub unsafe fn thread_yield() -> errno {\n+  cloudabi_sys_thread_yield()\n+}"}, {"sha": "81a4d29342301cf54938459787b2c2f627519a60", "filename": "src/libstd/sys/cloudabi/abi/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fmod.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(warnings)]\n+mod cloudabi;\n+pub use self::cloudabi::*;"}, {"sha": "7b62cc6adc9848753e3a7fc57ccd0dd2eac5450d", "filename": "src/libstd/sys/cloudabi/args.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fargs.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use sys::cloudabi::shims::args::*;\n+\n+#[allow(dead_code)]\n+pub fn init(_: isize, _: *const *const u8) {}\n+\n+#[allow(dead_code)]\n+pub fn cleanup() {}"}, {"sha": "33d931792375d4270dd9966da933eeb7985d82a1", "filename": "src/libstd/sys/cloudabi/backtrace.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fbacktrace.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use error::Error;\n+use ffi::CStr;\n+use intrinsics;\n+use io;\n+use libc;\n+use sys_common::backtrace::Frame;\n+use unwind as uw;\n+\n+pub struct BacktraceContext;\n+\n+struct Context<'a> {\n+    idx: usize,\n+    frames: &'a mut [Frame],\n+}\n+\n+#[derive(Debug)]\n+struct UnwindError(uw::_Unwind_Reason_Code);\n+\n+impl Error for UnwindError {\n+    fn description(&self) -> &'static str {\n+        \"unexpected return value while unwinding\"\n+    }\n+}\n+\n+impl ::fmt::Display for UnwindError {\n+    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        write!(f, \"{}: {:?}\", self.description(), self.0)\n+    }\n+}\n+\n+#[inline(never)] // if we know this is a function call, we can skip it when\n+                 // tracing\n+pub fn unwind_backtrace(frames: &mut [Frame]) -> io::Result<(usize, BacktraceContext)> {\n+    let mut cx = Context { idx: 0, frames };\n+    let result_unwind =\n+        unsafe { uw::_Unwind_Backtrace(trace_fn, &mut cx as *mut Context as *mut libc::c_void) };\n+    // See libunwind:src/unwind/Backtrace.c for the return values.\n+    // No, there is no doc.\n+    match result_unwind {\n+        // These return codes seem to be benign and need to be ignored for backtraces\n+        // to show up properly on all tested platforms.\n+        uw::_URC_END_OF_STACK | uw::_URC_FATAL_PHASE1_ERROR | uw::_URC_FAILURE => {\n+            Ok((cx.idx, BacktraceContext))\n+        }\n+        _ => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            UnwindError(result_unwind),\n+        )),\n+    }\n+}\n+\n+extern \"C\" fn trace_fn(\n+    ctx: *mut uw::_Unwind_Context,\n+    arg: *mut libc::c_void,\n+) -> uw::_Unwind_Reason_Code {\n+    let cx = unsafe { &mut *(arg as *mut Context) };\n+    let mut ip_before_insn = 0;\n+    let mut ip = unsafe { uw::_Unwind_GetIPInfo(ctx, &mut ip_before_insn) as *mut libc::c_void };\n+    if !ip.is_null() && ip_before_insn == 0 {\n+        // this is a non-signaling frame, so `ip` refers to the address\n+        // after the calling instruction. account for that.\n+        ip = (ip as usize - 1) as *mut _;\n+    }\n+\n+    let symaddr = unsafe { uw::_Unwind_FindEnclosingFunction(ip) };\n+    if cx.idx < cx.frames.len() {\n+        cx.frames[cx.idx] = Frame {\n+            symbol_addr: symaddr as *mut u8,\n+            exact_position: ip as *mut u8,\n+        };\n+        cx.idx += 1;\n+    }\n+\n+    uw::_URC_NO_REASON\n+}\n+\n+pub fn foreach_symbol_fileline<F>(_: Frame, _: F, _: &BacktraceContext) -> io::Result<bool>\n+where\n+    F: FnMut(&[u8], u32) -> io::Result<()>,\n+{\n+    // No way to obtain this information on CloudABI.\n+    Ok(false)\n+}\n+\n+pub fn resolve_symname<F>(frame: Frame, callback: F, _: &BacktraceContext) -> io::Result<()>\n+where\n+    F: FnOnce(Option<&str>) -> io::Result<()>,\n+{\n+    unsafe {\n+        let mut info: Dl_info = intrinsics::init();\n+        let symname =\n+            if dladdr(frame.exact_position as *mut _, &mut info) == 0 || info.dli_sname.is_null() {\n+                None\n+            } else {\n+                CStr::from_ptr(info.dli_sname).to_str().ok()\n+            };\n+        callback(symname)\n+    }\n+}\n+\n+#[repr(C)]\n+struct Dl_info {\n+    dli_fname: *const libc::c_char,\n+    dli_fbase: *mut libc::c_void,\n+    dli_sname: *const libc::c_char,\n+    dli_saddr: *mut libc::c_void,\n+}\n+\n+extern \"C\" {\n+    fn dladdr(addr: *const libc::c_void, info: *mut Dl_info) -> libc::c_int;\n+}"}, {"sha": "c05c837ade27498fef4e2d144e8a378535aa789b", "filename": "src/libstd/sys/cloudabi/condvar.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,169 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicU32, Ordering};\n+use sys::cloudabi::abi;\n+use sys::mutex::{self, Mutex};\n+use sys::time::dur2intervals;\n+use time::Duration;\n+\n+extern \"C\" {\n+    #[thread_local]\n+    static __pthread_thread_id: abi::tid;\n+}\n+\n+pub struct Condvar {\n+    condvar: UnsafeCell<AtomicU32>,\n+}\n+\n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n+impl Condvar {\n+    pub const fn new() -> Condvar {\n+        Condvar {\n+            condvar: UnsafeCell::new(AtomicU32::new(abi::CONDVAR_HAS_NO_WAITERS.0)),\n+        }\n+    }\n+\n+    pub unsafe fn init(&mut self) {}\n+\n+    pub unsafe fn notify_one(&self) {\n+        let condvar = self.condvar.get();\n+        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+            let ret = abi::condvar_signal(condvar as *mut abi::condvar, abi::scope::PRIVATE, 1);\n+            assert_eq!(\n+                ret,\n+                abi::errno::SUCCESS,\n+                \"Failed to signal on condition variable\"\n+            );\n+        }\n+    }\n+\n+    pub unsafe fn notify_all(&self) {\n+        let condvar = self.condvar.get();\n+        if (*condvar).load(Ordering::Relaxed) != abi::CONDVAR_HAS_NO_WAITERS.0 {\n+            let ret = abi::condvar_signal(\n+                condvar as *mut abi::condvar,\n+                abi::scope::PRIVATE,\n+                abi::nthreads::max_value(),\n+            );\n+            assert_eq!(\n+                ret,\n+                abi::errno::SUCCESS,\n+                \"Failed to broadcast on condition variable\"\n+            );\n+        }\n+    }\n+\n+    pub unsafe fn wait(&self, mutex: &Mutex) {\n+        let mutex = mutex::raw(mutex);\n+        assert_eq!(\n+            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This lock is not write-locked by this thread\"\n+        );\n+\n+        // Call into the kernel to wait on the condition variable.\n+        let condvar = self.condvar.get();\n+        let subscription = abi::subscription {\n+            type_: abi::eventtype::CONDVAR,\n+            union: abi::subscription_union {\n+                condvar: abi::subscription_condvar {\n+                    condvar: condvar as *mut abi::condvar,\n+                    condvar_scope: abi::scope::PRIVATE,\n+                    lock: mutex as *mut abi::lock,\n+                    lock_scope: abi::scope::PRIVATE,\n+                },\n+            },\n+            ..mem::zeroed()\n+        };\n+        let mut event: abi::event = mem::uninitialized();\n+        let mut nevents: usize = mem::uninitialized();\n+        let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+        assert_eq!(\n+            ret,\n+            abi::errno::SUCCESS,\n+            \"Failed to wait on condition variable\"\n+        );\n+        assert_eq!(\n+            event.error,\n+            abi::errno::SUCCESS,\n+            \"Failed to wait on condition variable\"\n+        );\n+    }\n+\n+    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n+        let mutex = mutex::raw(mutex);\n+        assert_eq!(\n+            (*mutex).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This lock is not write-locked by this thread\"\n+        );\n+\n+        // Call into the kernel to wait on the condition variable.\n+        let condvar = self.condvar.get();\n+        let subscriptions = [\n+            abi::subscription {\n+                type_: abi::eventtype::CONDVAR,\n+                union: abi::subscription_union {\n+                    condvar: abi::subscription_condvar {\n+                        condvar: condvar as *mut abi::condvar,\n+                        condvar_scope: abi::scope::PRIVATE,\n+                        lock: mutex as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            },\n+            abi::subscription {\n+                type_: abi::eventtype::CLOCK,\n+                union: abi::subscription_union {\n+                    clock: abi::subscription_clock {\n+                        clock_id: abi::clockid::MONOTONIC,\n+                        timeout: dur2intervals(&dur),\n+                        ..mem::zeroed()\n+                    },\n+                },\n+                ..mem::zeroed()\n+            },\n+        ];\n+        let mut events: [abi::event; 2] = mem::uninitialized();\n+        let mut nevents: usize = mem::uninitialized();\n+        let ret = abi::poll(subscriptions.as_ptr(), events.as_mut_ptr(), 2, &mut nevents);\n+        assert_eq!(\n+            ret,\n+            abi::errno::SUCCESS,\n+            \"Failed to wait on condition variable\"\n+        );\n+        for i in 0..nevents {\n+            assert_eq!(\n+                events[i].error,\n+                abi::errno::SUCCESS,\n+                \"Failed to wait on condition variable\"\n+            );\n+            if events[i].type_ == abi::eventtype::CONDVAR {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let condvar = self.condvar.get();\n+        assert_eq!(\n+            (*condvar).load(Ordering::Relaxed),\n+            abi::CONDVAR_HAS_NO_WAITERS.0,\n+            \"Attempted to destroy a condition variable with blocked threads\"\n+        );\n+    }\n+}"}, {"sha": "9e943c17fc85f788f9ebbc4656778a4ef50c9c33", "filename": "src/libstd/sys/cloudabi/mod.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmod.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc;\n+use mem;\n+\n+pub mod args;\n+#[cfg(feature = \"backtrace\")]\n+pub mod backtrace;\n+#[path = \"../unix/cmath.rs\"]\n+pub mod cmath;\n+pub mod condvar;\n+#[path = \"../unix/memchr.rs\"]\n+pub mod memchr;\n+pub mod mutex;\n+pub mod os;\n+#[path = \"../unix/os_str.rs\"]\n+pub mod os_str;\n+pub mod rwlock;\n+pub mod stack_overflow;\n+pub mod stdio;\n+pub mod thread;\n+#[path = \"../unix/thread_local.rs\"]\n+pub mod thread_local;\n+pub mod time;\n+\n+mod abi;\n+\n+mod shims;\n+pub use self::shims::*;\n+\n+#[allow(dead_code)]\n+pub fn init() {}\n+\n+pub fn decode_error_kind(errno: i32) -> io::ErrorKind {\n+    match errno {\n+        x if x == abi::errno::ACCES as i32 => io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::ADDRINUSE as i32 => io::ErrorKind::AddrInUse,\n+        x if x == abi::errno::ADDRNOTAVAIL as i32 => io::ErrorKind::AddrNotAvailable,\n+        x if x == abi::errno::AGAIN as i32 => io::ErrorKind::WouldBlock,\n+        x if x == abi::errno::CONNABORTED as i32 => io::ErrorKind::ConnectionAborted,\n+        x if x == abi::errno::CONNREFUSED as i32 => io::ErrorKind::ConnectionRefused,\n+        x if x == abi::errno::CONNRESET as i32 => io::ErrorKind::ConnectionReset,\n+        x if x == abi::errno::EXIST as i32 => io::ErrorKind::AlreadyExists,\n+        x if x == abi::errno::INTR as i32 => io::ErrorKind::Interrupted,\n+        x if x == abi::errno::INVAL as i32 => io::ErrorKind::InvalidInput,\n+        x if x == abi::errno::NOENT as i32 => io::ErrorKind::NotFound,\n+        x if x == abi::errno::NOTCONN as i32 => io::ErrorKind::NotConnected,\n+        x if x == abi::errno::PERM as i32 => io::ErrorKind::PermissionDenied,\n+        x if x == abi::errno::PIPE as i32 => io::ErrorKind::BrokenPipe,\n+        x if x == abi::errno::TIMEDOUT as i32 => io::ErrorKind::TimedOut,\n+        _ => io::ErrorKind::Other,\n+    }\n+}\n+\n+pub unsafe fn abort_internal() -> ! {\n+    ::core::intrinsics::abort();\n+}\n+\n+pub use libc::strlen;\n+\n+pub fn hashmap_random_keys() -> (u64, u64) {\n+    unsafe {\n+        let mut v = mem::uninitialized();\n+        libc::arc4random_buf(&mut v as *mut _ as *mut libc::c_void, mem::size_of_val(&v));\n+        v\n+    }\n+}"}, {"sha": "d4ba6bcfc806262eeccfc4cec5916babfb62cbe0", "filename": "src/libstd/sys/cloudabi/mutex.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fmutex.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicU32, Ordering};\n+use sys::cloudabi::abi;\n+use sys::rwlock::{self, RWLock};\n+\n+extern \"C\" {\n+    #[thread_local]\n+    static __pthread_thread_id: abi::tid;\n+}\n+\n+// Implement Mutex using an RWLock. This doesn't introduce any\n+// performance overhead in this environment, as the operations would be\n+// implemented identically.\n+pub struct Mutex(RWLock);\n+\n+pub unsafe fn raw(m: &Mutex) -> *mut AtomicU32 {\n+    rwlock::raw(&m.0)\n+}\n+\n+impl Mutex {\n+    pub const fn new() -> Mutex {\n+        Mutex(RWLock::new())\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        // This function should normally reinitialize the mutex after\n+        // moving it to a different memory address. This implementation\n+        // does not require adjustments after moving.\n+    }\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        self.0.try_write()\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        self.0.write()\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        self.0.write_unlock()\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        self.0.destroy()\n+    }\n+}\n+\n+pub struct ReentrantMutex {\n+    lock: UnsafeCell<AtomicU32>,\n+    recursion: UnsafeCell<u32>,\n+}\n+\n+impl ReentrantMutex {\n+    pub unsafe fn uninitialized() -> ReentrantMutex {\n+        mem::uninitialized()\n+    }\n+\n+    pub unsafe fn init(&mut self) {\n+        self.lock = UnsafeCell::new(AtomicU32::new(abi::LOCK_UNLOCKED.0));\n+        self.recursion = UnsafeCell::new(0);\n+    }\n+\n+    pub unsafe fn try_lock(&self) -> bool {\n+        // Attempt to acquire the lock.\n+        let lock = self.lock.get();\n+        let recursion = self.recursion.get();\n+        if let Err(old) = (*lock).compare_exchange(\n+            abi::LOCK_UNLOCKED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+        ) {\n+            // If we fail to acquire the lock, it may be the case\n+            // that we've already acquired it and may need to recurse.\n+            if old & !abi::LOCK_KERNEL_MANAGED.0 == __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 {\n+                *recursion += 1;\n+                true\n+            } else {\n+                false\n+            }\n+        } else {\n+            // Success.\n+            assert_eq!(*recursion, 0, \"Mutex has invalid recursion count\");\n+            true\n+        }\n+    }\n+\n+    pub unsafe fn lock(&self) {\n+        if !self.try_lock() {\n+            // Call into the kernel to acquire a write lock.\n+            let lock = self.lock.get();\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::LOCK_WRLOCK,\n+                union: abi::subscription_union {\n+                    lock: abi::subscription_lock {\n+                        lock: lock as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n+            assert_eq!(event.error, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n+        }\n+    }\n+\n+    pub unsafe fn unlock(&self) {\n+        let lock = self.lock.get();\n+        let recursion = self.recursion.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This mutex is locked by a different thread\"\n+        );\n+\n+        if *recursion > 0 {\n+            *recursion -= 1;\n+        } else if !(*lock)\n+            .compare_exchange(\n+                __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                abi::LOCK_UNLOCKED.0,\n+                Ordering::Release,\n+                Ordering::Relaxed,\n+            )\n+            .is_ok()\n+        {\n+            // Lock is managed by kernelspace. Call into the kernel\n+            // to unblock waiting threads.\n+            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to unlock a mutex\");\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let lock = self.lock.get();\n+        let recursion = self.recursion.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed),\n+            abi::LOCK_UNLOCKED.0,\n+            \"Attempted to destroy locked mutex\"\n+        );\n+        assert_eq!(*recursion, 0, \"Recursion counter invalid\");\n+    }\n+}"}, {"sha": "7e506b84df1ce653c5a65f4e7e7fb9db75b68e4e", "filename": "src/libstd/sys/cloudabi/os.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fos.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::CStr;\n+use libc::{self, c_int};\n+use str;\n+\n+pub use sys::cloudabi::shims::os::*;\n+\n+pub fn errno() -> i32 {\n+    extern \"C\" {\n+        #[thread_local]\n+        static errno: c_int;\n+    }\n+\n+    unsafe { errno as i32 }\n+}\n+\n+/// Gets a detailed string description for the given error number.\n+pub fn error_string(errno: i32) -> String {\n+    // cloudlibc's strerror() is guaranteed to be thread-safe. There is\n+    // thus no need to use strerror_r().\n+    str::from_utf8(unsafe { CStr::from_ptr(libc::strerror(errno)) }.to_bytes())\n+        .unwrap()\n+        .to_owned()\n+}\n+\n+pub fn exit(code: i32) -> ! {\n+    unsafe { libc::exit(code as c_int) }\n+}"}, {"sha": "8539aec5e2c07a1cb5ae8427701abb35b7ce0115", "filename": "src/libstd/sys/cloudabi/rwlock.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Frwlock.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cell::UnsafeCell;\n+use mem;\n+use sync::atomic::{AtomicU32, Ordering};\n+use sys::cloudabi::abi;\n+\n+extern \"C\" {\n+    #[thread_local]\n+    static __pthread_thread_id: abi::tid;\n+}\n+\n+#[thread_local]\n+static mut RDLOCKS_ACQUIRED: u32 = 0;\n+\n+pub struct RWLock {\n+    lock: UnsafeCell<AtomicU32>,\n+}\n+\n+pub unsafe fn raw(r: &RWLock) -> *mut AtomicU32 {\n+    r.lock.get()\n+}\n+\n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n+impl RWLock {\n+    pub const fn new() -> RWLock {\n+        RWLock {\n+            lock: UnsafeCell::new(AtomicU32::new(abi::LOCK_UNLOCKED.0)),\n+        }\n+    }\n+\n+    pub unsafe fn try_read(&self) -> bool {\n+        let lock = self.lock.get();\n+        let mut old = abi::LOCK_UNLOCKED.0;\n+        while let Err(cur) =\n+            (*lock).compare_exchange_weak(old, old + 1, Ordering::Acquire, Ordering::Relaxed)\n+        {\n+            if (cur & abi::LOCK_WRLOCKED.0) != 0 {\n+                // Another thread already has a write lock.\n+                assert_ne!(\n+                    old & !abi::LOCK_KERNEL_MANAGED.0,\n+                    __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                    \"Attempted to acquire a read lock while holding a write lock\"\n+                );\n+                return false;\n+            } else if (old & abi::LOCK_KERNEL_MANAGED.0) != 0 && RDLOCKS_ACQUIRED == 0 {\n+                // Lock has threads waiting for the lock. Only acquire\n+                // the lock if we have already acquired read locks. In\n+                // that case, it is justified to acquire this lock to\n+                // prevent a deadlock.\n+                return false;\n+            }\n+            old = cur;\n+        }\n+\n+        RDLOCKS_ACQUIRED += 1;\n+        true\n+    }\n+\n+    pub unsafe fn read(&self) {\n+        if !self.try_read() {\n+            // Call into the kernel to acquire a read lock.\n+            let lock = self.lock.get();\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::LOCK_RDLOCK,\n+                union: abi::subscription_union {\n+                    lock: abi::subscription_lock {\n+                        lock: lock as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire read lock\");\n+            assert_eq!(\n+                event.error,\n+                abi::errno::SUCCESS,\n+                \"Failed to acquire read lock\"\n+            );\n+\n+            RDLOCKS_ACQUIRED += 1;\n+        }\n+    }\n+\n+    pub unsafe fn read_unlock(&self) {\n+        // Perform a read unlock. We can do this in userspace, except when\n+        // other threads are blocked and we are performing the last unlock.\n+        // In that case, call into the kernel.\n+        //\n+        // Other threads may attempt to increment the read lock count,\n+        // meaning that the call into the kernel could be spurious. To\n+        // prevent this from happening, upgrade to a write lock first. This\n+        // allows us to call into the kernel, having the guarantee that the\n+        // lock value will not change in the meantime.\n+        assert!(RDLOCKS_ACQUIRED > 0, \"Bad lock count\");\n+        let mut old = 1;\n+        loop {\n+            let lock = self.lock.get();\n+            if old == 1 | abi::LOCK_KERNEL_MANAGED.0 {\n+                // Last read lock while threads are waiting. Attempt to upgrade\n+                // to a write lock before calling into the kernel to unlock.\n+                if let Err(cur) = (*lock).compare_exchange_weak(\n+                    old,\n+                    __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0 | abi::LOCK_KERNEL_MANAGED.0,\n+                    Ordering::Acquire,\n+                    Ordering::Relaxed,\n+                ) {\n+                    old = cur;\n+                } else {\n+                    // Call into the kernel to unlock.\n+                    let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+                    assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n+                    break;\n+                }\n+            } else {\n+                // No threads waiting or not the last read lock. Just decrement\n+                // the read lock count.\n+                assert_ne!(\n+                    old & !abi::LOCK_KERNEL_MANAGED.0,\n+                    0,\n+                    \"This rwlock is not locked\"\n+                );\n+                assert_eq!(\n+                    old & abi::LOCK_WRLOCKED.0,\n+                    0,\n+                    \"Attempted to read-unlock a write-locked rwlock\"\n+                );\n+                if let Err(cur) = (*lock).compare_exchange_weak(\n+                    old,\n+                    old - 1,\n+                    Ordering::Acquire,\n+                    Ordering::Relaxed,\n+                ) {\n+                    old = cur;\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        RDLOCKS_ACQUIRED -= 1;\n+    }\n+\n+    pub unsafe fn try_write(&self) -> bool {\n+        // Attempt to acquire the lock.\n+        let lock = self.lock.get();\n+        if let Err(old) = (*lock).compare_exchange(\n+            abi::LOCK_UNLOCKED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            Ordering::Acquire,\n+            Ordering::Relaxed,\n+        ) {\n+            // Failure. Crash upon recursive acquisition.\n+            assert_ne!(\n+                old & !abi::LOCK_KERNEL_MANAGED.0,\n+                __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                \"Attempted to recursive write-lock a rwlock\",\n+            );\n+            false\n+        } else {\n+            // Success.\n+            true\n+        }\n+    }\n+\n+    pub unsafe fn write(&self) {\n+        if !self.try_write() {\n+            // Call into the kernel to acquire a write lock.\n+            let lock = self.lock.get();\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::LOCK_WRLOCK,\n+                union: abi::subscription_union {\n+                    lock: abi::subscription_lock {\n+                        lock: lock as *mut abi::lock,\n+                        lock_scope: abi::scope::PRIVATE,\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire write lock\");\n+            assert_eq!(\n+                event.error,\n+                abi::errno::SUCCESS,\n+                \"Failed to acquire write lock\"\n+            );\n+        }\n+    }\n+\n+    pub unsafe fn write_unlock(&self) {\n+        let lock = self.lock.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed) & !abi::LOCK_KERNEL_MANAGED.0,\n+            __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+            \"This rwlock is not write-locked by this thread\"\n+        );\n+\n+        if !(*lock)\n+            .compare_exchange(\n+                __pthread_thread_id.0 | abi::LOCK_WRLOCKED.0,\n+                abi::LOCK_UNLOCKED.0,\n+                Ordering::Release,\n+                Ordering::Relaxed,\n+            )\n+            .is_ok()\n+        {\n+            // Lock is managed by kernelspace. Call into the kernel\n+            // to unblock waiting threads.\n+            let ret = abi::lock_unlock(lock as *mut abi::lock, abi::scope::PRIVATE);\n+            assert_eq!(ret, abi::errno::SUCCESS, \"Failed to write unlock a rwlock\");\n+        }\n+    }\n+\n+    pub unsafe fn destroy(&self) {\n+        let lock = self.lock.get();\n+        assert_eq!(\n+            (*lock).load(Ordering::Relaxed),\n+            abi::LOCK_UNLOCKED.0,\n+            \"Attempted to destroy locked rwlock\"\n+        );\n+    }\n+}"}, {"sha": "1b5785adc8ab377e74d2b1f3a6b89bbcbee52e2a", "filename": "src/libstd/sys/cloudabi/shims/args.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fargs.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+\n+pub struct Args(());\n+\n+impl Args {\n+    pub fn inner_debug(&self) -> &[OsString] {\n+        &[]\n+    }\n+}\n+\n+impl Iterator for Args {\n+    type Item = OsString;\n+    fn next(&mut self) -> Option<OsString> {\n+        None\n+    }\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+impl ExactSizeIterator for Args {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        None\n+    }\n+}\n+\n+pub fn args() -> Args {\n+    Args(())\n+}"}, {"sha": "31777aa94bcd4628ea477f6276d9f88bb8c71efa", "filename": "src/libstd/sys/cloudabi/shims/env.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fenv.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub mod os {\n+    pub const FAMILY: &'static str = \"cloudabi\";\n+    pub const OS: &'static str = \"cloudabi\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}"}, {"sha": "d3da0fbc37192b47017cc039b027f237a1cf7bb5", "filename": "src/libstd/sys/cloudabi/shims/fs.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Ffs.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,302 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsString;\n+use fmt;\n+use hash::{Hash, Hasher};\n+use io::{self, SeekFrom};\n+use path::{Path, PathBuf};\n+use sys::time::SystemTime;\n+use sys::{unsupported, Void};\n+\n+pub struct File(Void);\n+\n+pub struct FileAttr(Void);\n+\n+pub struct ReadDir(Void);\n+\n+pub struct DirEntry(Void);\n+\n+#[derive(Clone, Debug)]\n+pub struct OpenOptions {}\n+\n+pub struct FilePermissions(Void);\n+\n+pub struct FileType(Void);\n+\n+#[derive(Debug)]\n+pub struct DirBuilder {}\n+\n+impl FileAttr {\n+    pub fn size(&self) -> u64 {\n+        match self.0 {}\n+    }\n+\n+    pub fn perm(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> FileType {\n+        match self.0 {}\n+    }\n+\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+\n+    pub fn created(&self) -> io::Result<SystemTime> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileAttr {\n+    fn clone(&self) -> FileAttr {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FilePermissions {\n+    pub fn readonly(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_readonly(&mut self, _readonly: bool) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FilePermissions {\n+    fn clone(&self) -> FilePermissions {\n+        match self.0 {}\n+    }\n+}\n+\n+impl PartialEq for FilePermissions {\n+    fn eq(&self, _other: &FilePermissions) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FilePermissions {}\n+\n+impl fmt::Debug for FilePermissions {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl FileType {\n+    pub fn is_dir(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_file(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn is_symlink(&self) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for FileType {\n+    fn clone(&self) -> FileType {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for FileType {}\n+\n+impl PartialEq for FileType {\n+    fn eq(&self, _other: &FileType) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for FileType {}\n+\n+impl Hash for FileType {\n+    fn hash<H: Hasher>(&self, _h: &mut H) {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for FileType {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for ReadDir {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Iterator for ReadDir {\n+    type Item = io::Result<DirEntry>;\n+\n+    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirEntry {\n+    pub fn path(&self) -> PathBuf {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_name(&self) -> OsString {\n+        match self.0 {}\n+    }\n+\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn file_type(&self) -> io::Result<FileType> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl OpenOptions {\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {}\n+    }\n+\n+    pub fn read(&mut self, _read: bool) {}\n+    pub fn write(&mut self, _write: bool) {}\n+    pub fn append(&mut self, _append: bool) {}\n+    pub fn truncate(&mut self, _truncate: bool) {}\n+    pub fn create(&mut self, _create: bool) {}\n+    pub fn create_new(&mut self, _create_new: bool) {}\n+}\n+\n+impl File {\n+    pub fn open(_path: &Path, _opts: &OpenOptions) -> io::Result<File> {\n+        unsupported()\n+    }\n+\n+    pub fn file_attr(&self) -> io::Result<FileAttr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn fsync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn datasync(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn truncate(&self, _size: u64) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn seek(&self, _pos: SeekFrom) -> io::Result<u64> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<File> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+impl DirBuilder {\n+    pub fn new() -> DirBuilder {\n+        DirBuilder {}\n+    }\n+\n+    pub fn mkdir(&self, _p: &Path) -> io::Result<()> {\n+        unsupported()\n+    }\n+}\n+\n+impl fmt::Debug for File {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn readdir(_p: &Path) -> io::Result<ReadDir> {\n+    unsupported()\n+}\n+\n+pub fn unlink(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn rename(_old: &Path, _new: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn set_perm(_p: &Path, perm: FilePermissions) -> io::Result<()> {\n+    match perm.0 {}\n+}\n+\n+pub fn rmdir(_p: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn remove_dir_all(_path: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn stat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn lstat(_p: &Path) -> io::Result<FileAttr> {\n+    unsupported()\n+}\n+\n+pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn copy(_from: &Path, _to: &Path) -> io::Result<u64> {\n+    unsupported()\n+}"}, {"sha": "407c2b90511d3e71cb1cc058e69576e41f2a7143", "filename": "src/libstd/sys/cloudabi/shims/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fmod.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+\n+pub mod args;\n+pub mod env;\n+pub mod fs;\n+pub mod net;\n+#[path = \"../../unix/path.rs\"]\n+pub mod path;\n+pub mod pipe;\n+pub mod process;\n+pub mod os;\n+\n+// This enum is used as the storage for a bunch of types which can't actually exist.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub enum Void {}\n+\n+pub fn unsupported<T>() -> io::Result<T> {\n+    Err(io::Error::new(\n+        io::ErrorKind::Other,\n+        \"This function is not available on CloudABI.\",\n+    ))\n+}"}, {"sha": "93eaf6a9e7d6970171ce5bf12463a07ffbc0ff07", "filename": "src/libstd/sys/cloudabi/shims/net.rs", "status": "added", "additions": 296, "deletions": 0, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fnet.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,296 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+use io;\n+use net::{Ipv4Addr, Ipv6Addr, Shutdown, SocketAddr};\n+use time::Duration;\n+use sys::{unsupported, Void};\n+\n+pub extern crate libc as netc;\n+\n+pub struct TcpStream(Void);\n+\n+impl TcpStream {\n+    pub fn connect(_: &SocketAddr) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn connect_timeout(_: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n+        unsupported()\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn shutdown(&self, _: Shutdown) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpStream> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nodelay(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn nodelay(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpStream {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct TcpListener(Void);\n+\n+impl TcpListener {\n+    pub fn bind(_: &SocketAddr) -> io::Result<TcpListener> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<TcpListener> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_only_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn only_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for TcpListener {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct UdpSocket(Void);\n+\n+impl UdpSocket {\n+    pub fn bind(_: &SocketAddr) -> io::Result<UdpSocket> {\n+        unsupported()\n+    }\n+\n+    pub fn socket_addr(&self) -> io::Result<SocketAddr> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek_from(&self, _: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send_to(&self, _: &[u8], _: &SocketAddr) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn duplicate(&self) -> io::Result<UdpSocket> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_read_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_write_timeout(&self, _: Option<Duration>) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_broadcast(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn broadcast(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v4(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v4(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_ttl_v4(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_ttl_v4(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_multicast_loop_v6(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn multicast_loop_v6(&self) -> io::Result<bool> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn join_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v4(&self, _: &Ipv4Addr, _: &Ipv4Addr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn leave_multicast_v6(&self, _: &Ipv6Addr, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_ttl(&self, _: u32) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn ttl(&self) -> io::Result<u32> {\n+        match self.0 {}\n+    }\n+\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        match self.0 {}\n+    }\n+\n+    pub fn set_nonblocking(&self, _: bool) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn recv(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn peek(&self, _: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn send(&self, _: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn connect(&self, _: &SocketAddr) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Debug for UdpSocket {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct LookupHost(Void);\n+\n+impl Iterator for LookupHost {\n+    type Item = SocketAddr;\n+    fn next(&mut self) -> Option<SocketAddr> {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn lookup_host(_: &str) -> io::Result<LookupHost> {\n+    unsupported()\n+}"}, {"sha": "1e355d9ad042e45e0b282a955d9c7a1e37bee990", "filename": "src/libstd/sys/cloudabi/shims/os.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fos.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use error::Error as StdError;\n+use ffi::{OsStr, OsString};\n+use fmt;\n+use io;\n+use iter;\n+use path::{self, PathBuf};\n+use sys::{unsupported, Void};\n+\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn chdir(_: &path::Path) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub type Env = iter::Empty<(OsString, OsString)>;\n+\n+pub fn env() -> Env {\n+    iter::empty()\n+}\n+\n+pub fn getenv(_: &OsStr) -> io::Result<Option<OsString>> {\n+    Ok(None)\n+}\n+\n+pub fn setenv(_: &OsStr, _: &OsStr) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub fn unsetenv(_: &OsStr) -> io::Result<()> {\n+    unsupported()\n+}\n+\n+pub struct SplitPaths<'a>(&'a Void);\n+\n+pub fn split_paths(_unparsed: &OsStr) -> SplitPaths {\n+    panic!(\"unsupported\")\n+}\n+\n+impl<'a> Iterator for SplitPaths<'a> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n+        match *self.0 {}\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct JoinPathsError;\n+\n+pub fn join_paths<I, T>(_paths: I) -> Result<OsString, JoinPathsError>\n+where\n+    I: Iterator<Item = T>,\n+    T: AsRef<OsStr>,\n+{\n+    Err(JoinPathsError)\n+}\n+\n+impl fmt::Display for JoinPathsError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        \"not supported on CloudABI yet\".fmt(f)\n+    }\n+}\n+\n+impl StdError for JoinPathsError {\n+    fn description(&self) -> &str {\n+        \"not supported on CloudABI yet\"\n+    }\n+}\n+\n+pub fn home_dir() -> Option<PathBuf> {\n+    None\n+}\n+\n+pub fn temp_dir() -> PathBuf {\n+    PathBuf::from(\"/tmp\")\n+}\n+\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    unsupported()\n+}\n+\n+pub fn getpid() -> u32 {\n+    1\n+}"}, {"sha": "77a9cd6259005c3675f1215ce1faf20423888762", "filename": "src/libstd/sys/cloudabi/shims/pipe.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fpipe.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::Void;\n+\n+pub struct AnonPipe(Void);\n+\n+impl AnonPipe {\n+    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n+        match self.0 {}\n+    }\n+\n+    pub fn diverge(&self) -> ! {\n+        match self.0 {}\n+    }\n+}\n+\n+pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n+    match p1.0 {}\n+}"}, {"sha": "52e8c82e2b2393e916c8a56bacfc976fe4f88670", "filename": "src/libstd/sys/cloudabi/shims/process.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fshims%2Fprocess.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,147 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ffi::OsStr;\n+use fmt;\n+use io;\n+use sys::fs::File;\n+use sys::pipe::AnonPipe;\n+use sys::{unsupported, Void};\n+use sys_common::process::{CommandEnv, DefaultEnvKey};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Command {\n+    env: CommandEnv<DefaultEnvKey>,\n+}\n+\n+// passed back to std::process with the pipes connected to the child, if any\n+// were requested\n+pub struct StdioPipes {\n+    pub stdin: Option<AnonPipe>,\n+    pub stdout: Option<AnonPipe>,\n+    pub stderr: Option<AnonPipe>,\n+}\n+\n+pub enum Stdio {\n+    Inherit,\n+    Null,\n+    MakePipe,\n+}\n+\n+impl Command {\n+    pub fn new(_program: &OsStr) -> Command {\n+        Command {\n+            env: Default::default(),\n+        }\n+    }\n+\n+    pub fn arg(&mut self, _arg: &OsStr) {}\n+\n+    pub fn env_mut(&mut self) -> &mut CommandEnv<DefaultEnvKey> {\n+        &mut self.env\n+    }\n+\n+    pub fn cwd(&mut self, _dir: &OsStr) {}\n+\n+    pub fn stdin(&mut self, _stdin: Stdio) {}\n+\n+    pub fn stdout(&mut self, _stdout: Stdio) {}\n+\n+    pub fn stderr(&mut self, _stderr: Stdio) {}\n+\n+    pub fn spawn(\n+        &mut self,\n+        _default: Stdio,\n+        _needs_stdin: bool,\n+    ) -> io::Result<(Process, StdioPipes)> {\n+        unsupported()\n+    }\n+}\n+\n+impl From<AnonPipe> for Stdio {\n+    fn from(pipe: AnonPipe) -> Stdio {\n+        pipe.diverge()\n+    }\n+}\n+\n+impl From<File> for Stdio {\n+    fn from(file: File) -> Stdio {\n+        file.diverge()\n+    }\n+}\n+\n+impl fmt::Debug for Command {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+pub struct ExitStatus(Void);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        match self.0 {}\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Clone for ExitStatus {\n+    fn clone(&self) -> ExitStatus {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Copy for ExitStatus {}\n+\n+impl PartialEq for ExitStatus {\n+    fn eq(&self, _other: &ExitStatus) -> bool {\n+        match self.0 {}\n+    }\n+}\n+\n+impl Eq for ExitStatus {}\n+\n+impl fmt::Debug for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, _f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.0 {}\n+    }\n+}\n+\n+pub struct Process(Void);\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        match self.0 {}\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        match self.0 {}\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        match self.0 {}\n+    }\n+\n+    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n+        match self.0 {}\n+    }\n+}"}, {"sha": "5c0b1e5671e1b8d3d2ee855c3d68589ca8ec7dca", "filename": "src/libstd/sys/cloudabi/stack_overflow.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg_attr(test, allow(dead_code))]\n+\n+pub struct Handler;\n+\n+impl Handler {\n+    pub unsafe fn new() -> Handler {\n+        Handler\n+    }\n+}\n+\n+pub unsafe fn init() {}\n+\n+pub unsafe fn cleanup() {}"}, {"sha": "9519a926471085f92e64217c60a6bb21c5b977e9", "filename": "src/libstd/sys/cloudabi/stdio.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstdio.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use sys::cloudabi::abi;\n+\n+pub struct Stdin(());\n+pub struct Stdout(());\n+pub struct Stderr(());\n+\n+impl Stdin {\n+    pub fn new() -> io::Result<Stdin> {\n+        Ok(Stdin(()))\n+    }\n+\n+    pub fn read(&self, _: &mut [u8]) -> io::Result<usize> {\n+        Ok(0)\n+    }\n+}\n+\n+impl Stdout {\n+    pub fn new() -> io::Result<Stdout> {\n+        Ok(Stdout(()))\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        Err(io::Error::new(\n+            io::ErrorKind::BrokenPipe,\n+            \"Stdout is not connected to any output in this environment\",\n+        ))\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+impl Stderr {\n+    pub fn new() -> io::Result<Stderr> {\n+        Ok(Stderr(()))\n+    }\n+\n+    pub fn write(&self, _: &[u8]) -> io::Result<usize> {\n+        Err(io::Error::new(\n+            io::ErrorKind::BrokenPipe,\n+            \"Stderr is not connected to any output in this environment\",\n+        ))\n+    }\n+\n+    pub fn flush(&self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+// FIXME: right now this raw stderr handle is used in a few places because\n+//        std::io::stderr_raw isn't exposed, but once that's exposed this impl\n+//        should go away\n+impl io::Write for Stderr {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Stderr::write(self, data)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Stderr::flush(self)\n+    }\n+}\n+\n+pub fn is_ebadf(err: &io::Error) -> bool {\n+    err.raw_os_error() == Some(abi::errno::BADF as i32)\n+}\n+\n+pub const STDIN_BUF_SIZE: usize = ::sys_common::io::DEFAULT_BUF_SIZE;"}, {"sha": "c980ae75261caad971960e712a5259ba0da5cb96", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2014-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use alloc::boxed::FnBox;\n+use cmp;\n+use ffi::CStr;\n+use io;\n+use libc;\n+use mem;\n+use ptr;\n+use sys::cloudabi::abi;\n+use sys::time::dur2intervals;\n+use sys_common::thread::*;\n+use time::Duration;\n+\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n+\n+pub struct Thread {\n+    id: libc::pthread_t,\n+}\n+\n+// CloudABI has pthread_t as a pointer in which case we still want\n+// a thread to be Send/Sync\n+unsafe impl Send for Thread {}\n+unsafe impl Sync for Thread {}\n+\n+impl Thread {\n+    pub unsafe fn new<'a>(stack: usize, p: Box<FnBox() + 'a>) -> io::Result<Thread> {\n+        let p = box p;\n+        let mut native: libc::pthread_t = mem::zeroed();\n+        let mut attr: libc::pthread_attr_t = mem::zeroed();\n+        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n+\n+        let stack_size = cmp::max(stack, min_stack_size(&attr));\n+        assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n+\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n+\n+        return if ret != 0 {\n+            Err(io::Error::from_raw_os_error(ret))\n+        } else {\n+            mem::forget(p); // ownership passed to pthread_create\n+            Ok(Thread { id: native })\n+        };\n+\n+        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n+            unsafe {\n+                start_thread(main as *mut u8);\n+            }\n+            ptr::null_mut()\n+        }\n+    }\n+\n+    pub fn yield_now() {\n+        let ret = unsafe { abi::thread_yield() };\n+        debug_assert_eq!(ret, abi::errno::SUCCESS);\n+    }\n+\n+    pub fn set_name(_name: &CStr) {\n+        // CloudABI has no way to set a thread name.\n+    }\n+\n+    pub fn sleep(dur: Duration) {\n+        unsafe {\n+            let subscription = abi::subscription {\n+                type_: abi::eventtype::CLOCK,\n+                union: abi::subscription_union {\n+                    clock: abi::subscription_clock {\n+                        clock_id: abi::clockid::MONOTONIC,\n+                        timeout: dur2intervals(&dur),\n+                        ..mem::zeroed()\n+                    },\n+                },\n+                ..mem::zeroed()\n+            };\n+            let mut event: abi::event = mem::uninitialized();\n+            let mut nevents: usize = mem::uninitialized();\n+            let ret = abi::poll(&subscription, &mut event, 1, &mut nevents);\n+            assert_eq!(ret, abi::errno::SUCCESS);\n+            assert_eq!(event.error, abi::errno::SUCCESS);\n+        }\n+    }\n+\n+    pub fn join(self) {\n+        unsafe {\n+            let ret = libc::pthread_join(self.id, ptr::null_mut());\n+            mem::forget(self);\n+            assert!(\n+                ret == 0,\n+                \"failed to join thread: {}\",\n+                io::Error::from_raw_os_error(ret)\n+            );\n+        }\n+    }\n+}\n+\n+impl Drop for Thread {\n+    fn drop(&mut self) {\n+        let ret = unsafe { libc::pthread_detach(self.id) };\n+        debug_assert_eq!(ret, 0);\n+    }\n+}\n+\n+#[cfg_attr(test, allow(dead_code))]\n+pub mod guard {\n+    pub unsafe fn current() -> Option<usize> {\n+        None\n+    }\n+    pub unsafe fn init() -> Option<usize> {\n+        None\n+    }\n+}\n+\n+fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n+    libc::PTHREAD_STACK_MIN\n+}"}, {"sha": "ee12731619aac3bfbae63a38a796ba8984a7ec4d", "filename": "src/libstd/sys/cloudabi/time.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Ftime.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use mem;\n+use sys::cloudabi::abi;\n+use time::Duration;\n+\n+const NSEC_PER_SEC: abi::timestamp = 1_000_000_000;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct Instant {\n+    t: abi::timestamp,\n+}\n+\n+pub fn dur2intervals(dur: &Duration) -> abi::timestamp {\n+    dur.as_secs()\n+        .checked_mul(NSEC_PER_SEC)\n+        .and_then(|nanos| nanos.checked_add(dur.subsec_nanos() as abi::timestamp))\n+        .expect(\"overflow converting duration to nanoseconds\")\n+}\n+\n+impl Instant {\n+    pub fn now() -> Instant {\n+        unsafe {\n+            let mut t = mem::uninitialized();\n+            let ret = abi::clock_time_get(abi::clockid::MONOTONIC, 0, &mut t);\n+            assert_eq!(ret, abi::errno::SUCCESS);\n+            Instant { t: t }\n+        }\n+    }\n+\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        let diff = self.t\n+            .checked_sub(other.t)\n+            .expect(\"second instant is later than self\");\n+        Duration::new(diff / NSEC_PER_SEC, (diff % NSEC_PER_SEC) as u32)\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant {\n+            t: self.t\n+                .checked_add(dur2intervals(other))\n+                .expect(\"overflow when adding duration to instant\"),\n+        }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant {\n+            t: self.t\n+                .checked_sub(dur2intervals(other))\n+                .expect(\"overflow when subtracting duration from instant\"),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+pub struct SystemTime {\n+    t: abi::timestamp,\n+}\n+\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        unsafe {\n+            let mut t = mem::uninitialized();\n+            let ret = abi::clock_time_get(abi::clockid::REALTIME, 0, &mut t);\n+            assert_eq!(ret, abi::errno::SUCCESS);\n+            SystemTime { t: t }\n+        }\n+    }\n+\n+    pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n+        if self.t >= other.t {\n+            let diff = self.t - other.t;\n+            Ok(Duration::new(\n+                diff / NSEC_PER_SEC,\n+                (diff % NSEC_PER_SEC) as u32,\n+            ))\n+        } else {\n+            let diff = other.t - self.t;\n+            Err(Duration::new(\n+                diff / NSEC_PER_SEC,\n+                (diff % NSEC_PER_SEC) as u32,\n+            ))\n+        }\n+    }\n+\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime {\n+            t: self.t\n+                .checked_add(dur2intervals(other))\n+                .expect(\"overflow when adding duration to instant\"),\n+        }\n+    }\n+\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime {\n+            t: self.t\n+                .checked_sub(dur2intervals(other))\n+                .expect(\"overflow when subtracting duration from instant\"),\n+        }\n+    }\n+}\n+\n+pub const UNIX_EPOCH: SystemTime = SystemTime { t: 0 };"}, {"sha": "1231898ed7eba0051edc90b95fd0babf9ee7aece", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -39,6 +39,9 @@ cfg_if! {\n     } else if #[cfg(windows)] {\n         mod windows;\n         pub use self::windows::*;\n+    } else if #[cfg(target_os = \"cloudabi\")] {\n+        mod cloudabi;\n+        pub use self::cloudabi::*;\n     } else if #[cfg(target_os = \"redox\")] {\n         mod redox;\n         pub use self::redox::*;\n@@ -59,9 +62,10 @@ cfg_if! {\n     if #[cfg(any(unix, target_os = \"redox\"))] {\n         // On unix we'll document what's already available\n         pub use self::ext as unix_ext;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n-        // On wasm right now the module below doesn't compile (missing things\n-        // in `libc` which is empty) so just omit everything with an empty module\n+    } else if #[cfg(any(target_os = \"cloudabi\", target_arch = \"wasm32\"))] {\n+        // On CloudABI and wasm right now the module below doesn't compile\n+        // (missing things in `libc` which is empty) so just omit everything\n+        // with an empty module\n         #[unstable(issue = \"0\", feature = \"std_internals\")]\n         pub mod unix_ext {}\n     } else {\n@@ -77,8 +81,9 @@ cfg_if! {\n     if #[cfg(windows)] {\n         // On windows we'll just be documenting what's already available\n         pub use self::ext as windows_ext;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n-        // On wasm right now the shim below doesn't compile, so just omit it\n+    } else if #[cfg(any(target_os = \"cloudabi\", target_arch = \"wasm32\"))] {\n+        // On CloudABI and wasm right now the shim below doesn't compile, so\n+        // just omit it\n         #[unstable(issue = \"0\", feature = \"std_internals\")]\n         pub mod windows_ext {}\n     } else {"}, {"sha": "27504d374ddbfaba19cb09ea52ba382aae13919b", "filename": "src/libstd/sys_common/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Flibstd%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmod.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -46,7 +46,7 @@ pub mod bytestring;\n pub mod process;\n \n cfg_if! {\n-    if #[cfg(any(target_os = \"redox\", target_os = \"l4re\"))] {\n+    if #[cfg(any(target_os = \"cloudabi\", target_os = \"l4re\", target_os = \"redox\"))] {\n         pub use sys::net;\n     } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n         pub use sys::net;"}, {"sha": "8071f07d811959975e8d409d06a674c82102dd7a", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ab4cde5460f9f7c57249e4e62ad569dc843dd8/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=48ab4cde5460f9f7c57249e4e62ad569dc843dd8", "patch": "@@ -168,8 +168,8 @@ fn find_test_mod(contents: &str) -> usize {\n         let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n         if let Some(nl) = prev_newline_idx {\n             let prev_line = &contents[nl + 1 .. mod_tests_idx];\n-            let emcc_cfg = \"cfg(all(test, not(target_os\";\n-            if prev_line.contains(emcc_cfg) {\n+            if prev_line.contains(\"cfg(all(test, not(target_os\")\n+                || prev_line.contains(\"cfg(all(test, not(any(target_os\") {\n                 nl\n             } else {\n                 mod_tests_idx"}]}