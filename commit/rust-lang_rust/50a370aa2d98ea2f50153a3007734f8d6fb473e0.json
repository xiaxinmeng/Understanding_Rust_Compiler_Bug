{"sha": "50a370aa2d98ea2f50153a3007734f8d6fb473e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwYTM3MGFhMmQ5OGVhMmY1MDE1M2EzMDA3NzM0ZjhkNmZiNDczZTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-24T20:06:31Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-26T02:15:09Z"}, "message": "Remove dead code related to old closures.", "tree": {"sha": "8b80d4193c5090ec464125a152bb83029473602b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8b80d4193c5090ec464125a152bb83029473602b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50a370aa2d98ea2f50153a3007734f8d6fb473e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50a370aa2d98ea2f50153a3007734f8d6fb473e0", "html_url": "https://github.com/rust-lang/rust/commit/50a370aa2d98ea2f50153a3007734f8d6fb473e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50a370aa2d98ea2f50153a3007734f8d6fb473e0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab9c773cdb17404dd5982add2980a35921b844b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab9c773cdb17404dd5982add2980a35921b844b8", "html_url": "https://github.com/rust-lang/rust/commit/ab9c773cdb17404dd5982add2980a35921b844b8"}], "stats": {"total": 129, "additions": 16, "deletions": 113}, "files": [{"sha": "9954aa3922635667f1db689409a14aa67bd3729d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=50a370aa2d98ea2f50153a3007734f8d6fb473e0", "patch": "@@ -104,10 +104,7 @@ pub enum categorization<'tcx> {\n #[derive(Clone, Copy, PartialEq, Show)]\n pub struct Upvar {\n     pub id: ty::UpvarId,\n-    // Unboxed closure kinds are used even for old-style closures for simplicity\n-    pub kind: ty::ClosureKind,\n-    // Is this from an unboxed closure?  Used only for diagnostics.\n-    pub is_unboxed: bool\n+    pub kind: ty::ClosureKind\n }\n \n // different kinds of pointers:\n@@ -599,7 +596,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   ty::ty_closure(closure_id, _, _) => {\n                       let kind = self.typer.closure_kind(closure_id);\n                       let mode = self.typer.capture_mode(fn_node_id);\n-                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode, true)\n+                      self.cat_upvar(id, span, var_id, fn_node_id, kind, mode)\n                   }\n                   _ => {\n                       self.tcx().sess.span_bug(\n@@ -632,8 +629,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                  var_id: ast::NodeId,\n                  fn_node_id: ast::NodeId,\n                  kind: ty::ClosureKind,\n-                 mode: ast::CaptureClause,\n-                 is_unboxed: bool)\n+                 mode: ast::CaptureClause)\n                  -> McResult<cmt<'tcx>> {\n         // An upvar can have up to 3 components.  The base is a\n         // `cat_upvar`.  Next, we add a deref through the implicit\n@@ -654,8 +650,6 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // Fn             | copied -> &'env      | upvar -> &'env -> &'up bk\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n-        // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n-        // old proc/once  | copied               | N/A\n         let var_ty = try!(self.node_ty(var_id));\n \n         let upvar_id = ty::UpvarId { var_id: var_id,\n@@ -711,8 +705,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span: span,\n                     cat: cat_upvar(Upvar {\n                         id: upvar_id,\n-                        kind: kind,\n-                        is_unboxed: is_unboxed\n+                        kind: kind\n                     }),\n                     mutbl: var_mutbl,\n                     ty: var_ty,\n@@ -751,8 +744,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     span: span,\n                     cat: cat_upvar(Upvar {\n                         id: upvar_id,\n-                        kind: kind,\n-                        is_unboxed: is_unboxed\n+                        kind: kind\n                     }),\n                     mutbl: McImmutable,\n                     ty: self.tcx().types.err,"}, {"sha": "230a4c5d4272ecb043d4cc941320d94e54b5f1fb", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=50a370aa2d98ea2f50153a3007734f8d6fb473e0", "patch": "@@ -1763,12 +1763,6 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq)]\n-pub enum IsUnboxedClosureFlag {\n-    NotUnboxedClosure,\n-    IsUnboxedClosure,\n-}\n-\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned."}, {"sha": "233197ccb5b8b414ee601d3601c81699148e29e5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=50a370aa2d98ea2f50153a3007734f8d6fb473e0", "patch": "@@ -1237,16 +1237,6 @@ impl fmt::Display for Onceness {\n     }\n }\n \n-/// Represents the type of a closure\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub struct ClosureTy {\n-    pub lifetimes: Vec<LifetimeDef>,\n-    pub unsafety: Unsafety,\n-    pub onceness: Onceness,\n-    pub decl: P<FnDecl>,\n-    pub bounds: TyParamBounds,\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct BareFnTy {\n     pub unsafety: Unsafety,"}, {"sha": "d06ac50920e04b12f032a2432de235400ed3243d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 84, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50a370aa2d98ea2f50153a3007734f8d6fb473e0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=50a370aa2d98ea2f50153a3007734f8d6fb473e0", "patch": "@@ -703,14 +703,11 @@ impl<'a> State<'a> {\n                         predicates: Vec::new(),\n                     },\n                 };\n-                try!(self.print_ty_fn(Some(f.abi),\n-                                      None,\n+                try!(self.print_ty_fn(f.abi,\n                                       f.unsafety,\n-                                      ast::Many,\n                                       &*f.decl,\n                                       None,\n-                                      &OwnedSlice::empty(),\n-                                      Some(&generics),\n+                                      &generics,\n                                       None));\n             }\n             ast::TyPath(ref path, _) => {\n@@ -1215,14 +1212,11 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n         try!(self.print_outer_attributes(&m.attrs[]));\n-        try!(self.print_ty_fn(None,\n-                              None,\n+        try!(self.print_ty_fn(m.abi,\n                               m.unsafety,\n-                              ast::Many,\n                               &*m.decl,\n                               Some(m.ident),\n-                              &OwnedSlice::empty(),\n-                              Some(&m.generics),\n+                              &m.generics,\n                               Some(&m.explicit_self.node)));\n         word(&mut self.s, \";\")\n     }\n@@ -2300,7 +2294,7 @@ impl<'a> State<'a> {\n                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n-        try!(self.print_fn_header_info(opt_explicit_self, unsafety, abi, vis));\n+        try!(self.print_fn_header_info(unsafety, abi, vis));\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n@@ -2396,31 +2390,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_proc_args(&mut self, decl: &ast::FnDecl) -> IoResult<()> {\n-        try!(word(&mut self.s, \"proc\"));\n-        try!(word(&mut self.s, \"(\"));\n-        try!(self.print_fn_args(decl, None));\n-        try!(word(&mut self.s, \")\"));\n-\n-        if let ast::DefaultReturn(..) = decl.output {\n-            return Ok(());\n-        }\n-\n-        try!(self.space_if_not_bol());\n-        try!(self.word_space(\"->\"));\n-        match decl.output {\n-            ast::Return(ref ty) => {\n-                try!(self.print_type(&**ty));\n-                self.maybe_print_comment(ty.span.lo)\n-            }\n-            ast::DefaultReturn(..) => unreachable!(),\n-            ast::NoReturn(span) => {\n-                try!(self.word_nbsp(\"!\"));\n-                self.maybe_print_comment(span.lo)\n-            }\n-        }\n-    }\n-\n     pub fn print_bounds(&mut self,\n                         prefix: &str,\n                         bounds: &[ast::TyParamBound])\n@@ -2696,31 +2665,15 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_fn(&mut self,\n-                       opt_abi: Option<abi::Abi>,\n-                       opt_sigil: Option<char>,\n+                       abi: abi::Abi,\n                        unsafety: ast::Unsafety,\n-                       onceness: ast::Onceness,\n                        decl: &ast::FnDecl,\n                        id: Option<ast::Ident>,\n-                       bounds: &OwnedSlice<ast::TyParamBound>,\n-                       generics: Option<&ast::Generics>,\n+                       generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> IoResult<()> {\n         try!(self.ibox(indent_unit));\n-\n-        // Duplicates the logic in `print_fn_header_info()`.  This is because that\n-        // function prints the sigil in the wrong place.  That should be fixed.\n-        if opt_sigil == Some('~') && onceness == ast::Once {\n-            try!(word(&mut self.s, \"proc\"));\n-        } else if opt_sigil == Some('&') {\n-            try!(self.print_unsafety(unsafety));\n-            try!(self.print_extern_opt_abi(opt_abi));\n-        } else {\n-            assert!(opt_sigil.is_none());\n-            try!(self.print_unsafety(unsafety));\n-            try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n-            try!(word(&mut self.s, \"fn\"));\n-        }\n+        try!(self.print_fn_header_info(Some(unsafety), abi, ast::Inherited));\n \n         match id {\n             Some(id) => {\n@@ -2730,35 +2683,10 @@ impl<'a> State<'a> {\n             _ => ()\n         }\n \n-        match generics { Some(g) => try!(self.print_generics(g)), _ => () }\n+        try!(self.print_generics(generics));\n         try!(zerobreak(&mut self.s));\n-\n-        if opt_sigil == Some('&') {\n-            try!(word(&mut self.s, \"|\"));\n-        } else {\n-            try!(self.popen());\n-        }\n-\n-        try!(self.print_fn_args(decl, opt_explicit_self));\n-\n-        if opt_sigil == Some('&') {\n-            try!(word(&mut self.s, \"|\"));\n-        } else {\n-            if decl.variadic {\n-                try!(word(&mut self.s, \", ...\"));\n-            }\n-            try!(self.pclose());\n-        }\n-\n-        try!(self.print_bounds(\":\", &bounds[]));\n-\n-        try!(self.print_fn_output(decl));\n-\n-        match generics {\n-            Some(generics) => try!(self.print_where_clause(generics)),\n-            None => {}\n-        }\n-\n+        try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n+        try!(self.print_where_clause(generics));\n         self.end()\n     }\n \n@@ -3015,7 +2943,6 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                _opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 opt_unsafety: Option<ast::Unsafety>,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> IoResult<()> {"}]}