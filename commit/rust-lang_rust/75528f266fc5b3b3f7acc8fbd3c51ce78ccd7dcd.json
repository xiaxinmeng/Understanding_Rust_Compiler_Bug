{"sha": "75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NTI4ZjI2NmZjNWIzYjNmN2FjYzhmYmQzYzUxY2U3OGNjZDdkY2Q=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-08-31T12:45:44Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-07T23:31:58Z"}, "message": "Replace writeln!/write! with push_str", "tree": {"sha": "b5f68c55571cb2fe70de586e48c8538672b9a76c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5f68c55571cb2fe70de586e48c8538672b9a76c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd", "html_url": "https://github.com/rust-lang/rust/commit/75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57243b74b136c26ffa20d0802ce2777b5bf1f3f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/57243b74b136c26ffa20d0802ce2777b5bf1f3f0", "html_url": "https://github.com/rust-lang/rust/commit/57243b74b136c26ffa20d0802ce2777b5bf1f3f0"}], "stats": {"total": 150, "additions": 69, "deletions": 81}, "files": [{"sha": "09c2e31b4ed6bac19eeb301b4dcd80dfab7c31b0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 69, "deletions": 81, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=75528f266fc5b3b3f7acc8fbd3c51ce78ccd7dcd", "patch": "@@ -65,7 +65,7 @@ use crate::docfs::{DocFS, ErrorStorage, PathError};\n use crate::doctree;\n use crate::fold::DocFolder;\n use crate::html::escape::Escape;\n-use crate::html::format::{AsyncSpace, ConstnessSpace};\n+use crate::html::format::{Buffer, AsyncSpace, ConstnessSpace};\n use crate::html::format::{GenericBounds, WhereClause, href, AbiSpace, DefaultSpace};\n use crate::html::format::{VisSpace, Function, UnsafetySpace, MutableSpace};\n use crate::html::format::fmt_impl_for_trait_page;\n@@ -1025,12 +1025,12 @@ themePicker.onblur = handleThemeButtonsBlur;\n         }\n         all_aliases.push(format!(\"ALIASES[\\\"{}\\\"] = {{{}}};\", krate.name, output));\n         all_aliases.sort();\n-        let mut v = Vec::new();\n-        try_err!(writeln!(&mut v, \"var ALIASES = {{}};\"), &dst);\n+        let mut v = Buffer::html();\n+        writeln!(&mut v, \"var ALIASES = {{}};\");\n         for aliases in &all_aliases {\n-            try_err!(writeln!(&mut v, \"{}\", aliases), &dst);\n+            writeln!(&mut v, \"{}\", aliases);\n         }\n-        cx.shared.fs.write(&dst, &v)?;\n+        cx.shared.fs.write(&dst, v.into_inner().into_bytes())?;\n     }\n \n     use std::ffi::OsString;\n@@ -1114,12 +1114,9 @@ themePicker.onblur = handleThemeButtonsBlur;\n                                  &krate.name,\n                                  hierarchy.to_json_string()));\n         all_sources.sort();\n-        let mut v = Vec::new();\n-        try_err!(writeln!(&mut v,\n-                          \"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\",\n-                          all_sources.join(\"\\n\")),\n-                 &dst);\n-        cx.shared.fs.write(&dst, &v)?;\n+        let v = format!(\"var N = null;var sourcesIndex = {{}};\\n{}\\ncreateSourceSidebar();\\n\",\n+                          all_sources.join(\"\\n\"));\n+        cx.shared.fs.write(&dst, v.as_bytes())?;\n     }\n \n     // Update the search index\n@@ -1134,14 +1131,11 @@ themePicker.onblur = handleThemeButtonsBlur;\n     // with rustdoc running in parallel.\n     all_indexes.sort();\n     {\n-        let mut v = Vec::new();\n-        try_err!(writeln!(&mut v, \"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={{}};\"), &dst);\n-        try_err!(write_minify_replacer(\n-            &mut v,\n+        let mut v = String::from(\"var N=null,E=\\\"\\\",T=\\\"t\\\",U=\\\"u\\\",searchIndex={};\\n\");\n+        v.push_str(&minify_replacer(\n             &format!(\"{}\\n{}\", variables.join(\"\"), all_indexes.join(\"\\n\")),\n-            options.enable_minification),\n-            &dst);\n-        try_err!(write!(&mut v, \"initSearch(searchIndex);addSearchOptions(searchIndex);\"), &dst);\n+            options.enable_minification));\n+        v.push_str(\"initSearch(searchIndex);addSearchOptions(searchIndex);\");\n         cx.shared.fs.write(&dst, &v)?;\n     }\n     if options.enable_index_page {\n@@ -1247,19 +1241,18 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // identically even with rustdoc running in parallel.\n         all_implementors.sort();\n \n-        let mut v = Vec::new();\n-        try_err!(writeln!(&mut v, \"(function() {{var implementors = {{}};\"), &mydst);\n+        let mut v = String::from(\"(function() {var implementors = {}};\\n\");\n         for implementor in &all_implementors {\n-            try_err!(writeln!(&mut v, \"{}\", *implementor), &mydst);\n+            v.push_str(&format!(\"{}\", *implementor));\n         }\n-        try_err!(writeln!(&mut v, \"{}\", r\"\n+        v.push_str(r\"\n             if (window.register_implementors) {\n                 window.register_implementors(implementors);\n             } else {\n                 window.pending_implementors = implementors;\n             }\n-        \"), &mydst);\n-        try_err!(writeln!(&mut v, r\"}})()\"), &mydst);\n+        \\n\");\n+        v.push_str(\"})()\");\n         cx.shared.fs.write(&mydst, &v)?;\n     }\n     Ok(())\n@@ -1279,68 +1272,65 @@ fn write_minify(fs:&DocFS, dst: PathBuf, contents: &str, enable_minification: bo\n     }\n }\n \n-fn write_minify_replacer<W: Write>(\n-    dst: &mut W,\n+fn minify_replacer(\n     contents: &str,\n     enable_minification: bool,\n-) -> io::Result<()> {\n+) -> String {\n     use minifier::js::{simple_minify, Keyword, ReservedChar, Token, Tokens};\n \n     if enable_minification {\n-        writeln!(dst, \"{}\",\n-                 {\n-                    let tokens: Tokens<'_> = simple_minify(contents)\n-                        .into_iter()\n-                        .filter(|(f, next)| {\n-                            // We keep backlines.\n-                            minifier::js::clean_token_except(f, next, &|c: &Token<'_>| {\n-                                c.get_char() != Some(ReservedChar::Backline)\n-                            })\n-                        })\n-                        .map(|(f, _)| {\n-                            minifier::js::replace_token_with(f, &|t: &Token<'_>| {\n-                                match *t {\n-                                    Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n-                                    Token::String(s) => {\n-                                        let s = &s[1..s.len() -1]; // The quotes are included\n-                                        if s.is_empty() {\n-                                            Some(Token::Other(\"E\"))\n-                                        } else if s == \"t\" {\n-                                            Some(Token::Other(\"T\"))\n-                                        } else if s == \"u\" {\n-                                            Some(Token::Other(\"U\"))\n-                                        } else {\n-                                            None\n-                                        }\n-                                    }\n-                                    _ => None,\n-                                }\n-                            })\n-                        })\n-                        .collect::<Vec<_>>()\n-                        .into();\n-                    tokens.apply(|f| {\n-                        // We add a backline after the newly created variables.\n-                        minifier::js::aggregate_strings_into_array_with_separation_filter(\n-                            f,\n-                            \"R\",\n-                            Token::Char(ReservedChar::Backline),\n-                            // This closure prevents crates' names from being aggregated.\n-                            //\n-                            // The point here is to check if the string is preceded by '[' and\n-                            // \"searchIndex\". If so, it means this is a crate name and that it\n-                            // shouldn't be aggregated.\n-                            |tokens, pos| {\n-                                pos < 2 ||\n-                                !tokens[pos - 1].eq_char(ReservedChar::OpenBracket) ||\n-                                tokens[pos - 2].get_other() != Some(\"searchIndex\")\n+        let tokens: Tokens<'_> = simple_minify(contents)\n+            .into_iter()\n+            .filter(|(f, next)| {\n+                // We keep backlines.\n+                minifier::js::clean_token_except(f, next, &|c: &Token<'_>| {\n+                    c.get_char() != Some(ReservedChar::Backline)\n+                })\n+            })\n+            .map(|(f, _)| {\n+                minifier::js::replace_token_with(f, &|t: &Token<'_>| {\n+                    match *t {\n+                        Token::Keyword(Keyword::Null) => Some(Token::Other(\"N\")),\n+                        Token::String(s) => {\n+                            let s = &s[1..s.len() -1]; // The quotes are included\n+                            if s.is_empty() {\n+                                Some(Token::Other(\"E\"))\n+                            } else if s == \"t\" {\n+                                Some(Token::Other(\"T\"))\n+                            } else if s == \"u\" {\n+                                Some(Token::Other(\"U\"))\n+                            } else {\n+                                None\n                             }\n-                        )\n-                    })\n-                    .to_string()\n+                        }\n+                        _ => None,\n+                    }\n                 })\n+            })\n+            .collect::<Vec<_>>()\n+            .into();\n+        let o = tokens.apply(|f| {\n+            // We add a backline after the newly created variables.\n+            minifier::js::aggregate_strings_into_array_with_separation_filter(\n+                f,\n+                \"R\",\n+                Token::Char(ReservedChar::Backline),\n+                // This closure prevents crates' names from being aggregated.\n+                //\n+                // The point here is to check if the string is preceded by '[' and\n+                // \"searchIndex\". If so, it means this is a crate name and that it\n+                // shouldn't be aggregated.\n+                |tokens, pos| {\n+                    pos < 2 ||\n+                    !tokens[pos - 1].eq_char(ReservedChar::OpenBracket) ||\n+                    tokens[pos - 2].get_other() != Some(\"searchIndex\")\n+                }\n+            )\n+        })\n+        .to_string();\n+        format!(\"{}\\n\", o)\n     } else {\n-        writeln!(dst, \"{}\", contents)\n+        format!(\"{}\\n\", contents)\n     }\n }\n \n@@ -2073,9 +2063,7 @@ impl Context {\n             if !self.render_redirect_pages {\n                 let items = self.build_sidebar_items(&m);\n                 let js_dst = self.dst.join(\"sidebar-items.js\");\n-                let mut v = Vec::new();\n-                try_err!(write!(&mut v, \"initSidebarItems({});\",\n-                                as_json(&items)), &js_dst);\n+                let v = format!(\"initSidebarItems({});\", as_json(&items));\n                 scx.fs.write(&js_dst, &v)?;\n             }\n "}]}