{"sha": "fc15f96651408bec002664627f003ef628a041c6", "node_id": "C_kwDOAAsO6NoAKGZjMTVmOTY2NTE0MDhiZWMwMDI2NjQ2MjdmMDAzZWY2MjhhMDQxYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T22:53:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-07T22:53:54Z"}, "message": "Auto merge of #1981 - tavianator:readdir, r=RalfJung\n\nImplement a readdir64() shim for Linux\n\nPartial fix for #1966.", "tree": {"sha": "9c1999c9c3b811df1e849831a026033cc98e7cda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1999c9c3b811df1e849831a026033cc98e7cda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc15f96651408bec002664627f003ef628a041c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc15f96651408bec002664627f003ef628a041c6", "html_url": "https://github.com/rust-lang/rust/commit/fc15f96651408bec002664627f003ef628a041c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc15f96651408bec002664627f003ef628a041c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccaf7206e122b544aa2762f6b42474d8ee545a8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccaf7206e122b544aa2762f6b42474d8ee545a8a", "html_url": "https://github.com/rust-lang/rust/commit/ccaf7206e122b544aa2762f6b42474d8ee545a8a"}, {"sha": "0886419524c5baf61d6f3980e81ba4e0429ac402", "url": "https://api.github.com/repos/rust-lang/rust/commits/0886419524c5baf61d6f3980e81ba4e0429ac402", "html_url": "https://github.com/rust-lang/rust/commit/0886419524c5baf61d6f3980e81ba4e0429ac402"}], "stats": {"total": 178, "additions": 96, "deletions": 82}, "files": [{"sha": "1e91c66b859ed33cf843e996c8d412b398dd5b9d", "filename": "src/data_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/src%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/src%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdata_race.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -743,7 +743,7 @@ impl VClockAlloc {\n             MemoryKind::Machine(\n                 MiriMemoryKind::Global\n                 | MiriMemoryKind::Machine\n-                | MiriMemoryKind::Env\n+                | MiriMemoryKind::Runtime\n                 | MiriMemoryKind::ExternStatic\n                 | MiriMemoryKind::Tls,\n             )"}, {"sha": "bb43cb95507c5391b62d0668039d4308b94017a1", "filename": "src/machine.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -71,8 +71,9 @@ pub enum MiriMemoryKind {\n     /// Memory for args, errno, and other parts of the machine-managed environment.\n     /// This memory may leak.\n     Machine,\n-    /// Memory for env vars. Separate from `Machine` because we clean it up and leak-check it.\n-    Env,\n+    /// Memory allocated by the runtime (e.g. env vars). Separate from `Machine`\n+    /// because we clean it up and leak-check it.\n+    Runtime,\n     /// Globals copied from `tcx`.\n     /// This memory may leak.\n     Global,\n@@ -96,7 +97,7 @@ impl MayLeak for MiriMemoryKind {\n     fn may_leak(self) -> bool {\n         use self::MiriMemoryKind::*;\n         match self {\n-            Rust | C | WinHeap | Env => false,\n+            Rust | C | WinHeap | Runtime => false,\n             Machine | Global | ExternStatic | Tls => true,\n         }\n     }\n@@ -110,7 +111,7 @@ impl fmt::Display for MiriMemoryKind {\n             C => write!(f, \"C heap\"),\n             WinHeap => write!(f, \"Windows heap\"),\n             Machine => write!(f, \"machine-managed memory\"),\n-            Env => write!(f, \"environment variable\"),\n+            Runtime => write!(f, \"language runtime memory\"),\n             Global => write!(f, \"global (static or const)\"),\n             ExternStatic => write!(f, \"extern static\"),\n             Tls => write!(f, \"thread-local static\"),"}, {"sha": "fd772868858099eb8ce06719742a1d36f180570e", "filename": "src/shims/env.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -78,12 +78,12 @@ impl<'tcx> EnvVars<'tcx> {\n     ) -> InterpResult<'tcx> {\n         // Deallocate individual env vars.\n         for (_name, ptr) in ecx.machine.env_vars.map.drain() {\n-            ecx.memory.deallocate(ptr, None, MiriMemoryKind::Env.into())?;\n+            ecx.memory.deallocate(ptr, None, MiriMemoryKind::Runtime.into())?;\n         }\n         // Deallocate environ var list.\n         let environ = ecx.machine.env_vars.environ.unwrap();\n         let old_vars_ptr = ecx.read_pointer(&environ.into())?;\n-        ecx.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Env.into())?;\n+        ecx.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n         Ok(())\n     }\n }\n@@ -96,7 +96,7 @@ fn alloc_env_var_as_c_str<'mir, 'tcx>(\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n-    ecx.alloc_os_str_as_c_str(name_osstring.as_os_str(), MiriMemoryKind::Env.into())\n+    ecx.alloc_os_str_as_c_str(name_osstring.as_os_str(), MiriMemoryKind::Runtime.into())\n }\n \n fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n@@ -107,7 +107,7 @@ fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n-    ecx.alloc_os_str_as_wide_str(name_osstring.as_os_str(), MiriMemoryKind::Env.into())\n+    ecx.alloc_os_str_as_wide_str(name_osstring.as_os_str(), MiriMemoryKind::Runtime.into())\n }\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -186,7 +186,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         // Allocate environment block & Store environment variables to environment block.\n         // Final null terminator(block terminator) is added by `alloc_os_str_to_wide_str`.\n-        let envblock_ptr = this.alloc_os_str_as_wide_str(&env_vars, MiriMemoryKind::Env.into())?;\n+        let envblock_ptr =\n+            this.alloc_os_str_as_wide_str(&env_vars, MiriMemoryKind::Runtime.into())?;\n         // If the function succeeds, the return value is a pointer to the environment block of the current process.\n         Ok(envblock_ptr)\n     }\n@@ -200,7 +201,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n \n         let env_block_ptr = this.read_pointer(env_block_op)?;\n-        let result = this.memory.deallocate(env_block_ptr, None, MiriMemoryKind::Env.into());\n+        let result = this.memory.deallocate(env_block_ptr, None, MiriMemoryKind::Runtime.into());\n         // If the function succeeds, the return value is nonzero.\n         Ok(result.is_ok() as i32)\n     }\n@@ -231,7 +232,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         if let Some((name, value)) = new {\n             let var_ptr = alloc_env_var_as_c_str(&name, &value, &mut this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n             Ok(0) // return zero on success\n@@ -268,15 +269,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         } else if this.ptr_is_null(value_ptr)? {\n             // Delete environment variable `{name}`\n             if let Some(var) = this.machine.env_vars.map.remove(&name) {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n             Ok(1) // return non-zero on success\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, &mut this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n             Ok(1) // return non-zero on success\n@@ -301,7 +302,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         if let Some(old) = success {\n             if let Some(var) = old {\n-                this.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                this.memory.deallocate(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n             Ok(0)\n@@ -437,7 +438,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Deallocate the old environ list, if any.\n         if let Some(environ) = this.machine.env_vars.environ {\n             let old_vars_ptr = this.read_pointer(&environ.into())?;\n-            this.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Env.into())?;\n+            this.memory.deallocate(old_vars_ptr, None, MiriMemoryKind::Runtime.into())?;\n         } else {\n             // No `environ` allocated yet, let's do that.\n             // This is memory backing an extern static, hence `ExternStatic`, not `Env`.\n@@ -455,7 +456,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let tcx = this.tcx;\n         let vars_layout =\n             this.layout_of(tcx.mk_array(tcx.types.usize, u64::try_from(vars.len()).unwrap()))?;\n-        let vars_place = this.allocate(vars_layout, MiriMemoryKind::Env.into())?;\n+        let vars_place = this.allocate(vars_layout, MiriMemoryKind::Runtime.into())?;\n         for (idx, var) in vars.into_iter().enumerate() {\n             let place = this.mplace_field(&vars_place, idx)?;\n             this.write_pointer(var, &place.into())?;"}, {"sha": "300e3c514b37598546a197ad771c433aab30c4cb", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 66, "deletions": 54, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -16,6 +16,7 @@ use rustc_target::abi::{Align, Size};\n \n use crate::*;\n use helpers::{check_arg_count, immty_from_int_checked, immty_from_uint_checked};\n+use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n \n #[derive(Debug)]\n@@ -421,6 +422,22 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n     }\n }\n \n+/// An open directory, tracked by DirHandler.\n+#[derive(Debug)]\n+pub struct OpenDir {\n+    /// The directory reader on the host.\n+    read_dir: ReadDir,\n+    /// The most recent entry returned by readdir()\n+    entry: Pointer<Option<Tag>>,\n+}\n+\n+impl OpenDir {\n+    fn new(read_dir: ReadDir) -> Self {\n+        // We rely on `free` being a NOP on null pointers.\n+        Self { read_dir, entry: Pointer::null() }\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct DirHandler {\n     /// Directory iterators used to emulate libc \"directory streams\", as used in opendir, readdir,\n@@ -432,7 +449,7 @@ pub struct DirHandler {\n     /// the corresponding ReadDir iterator from this map, and information from the next\n     /// directory entry is returned. When closedir is called, the ReadDir iterator is removed from\n     /// the map.\n-    streams: FxHashMap<u64, ReadDir>,\n+    streams: FxHashMap<u64, OpenDir>,\n     /// ID number to be used by the next call to opendir\n     next_id: u64,\n }\n@@ -441,7 +458,7 @@ impl DirHandler {\n     fn insert_new(&mut self, read_dir: ReadDir) -> u64 {\n         let id = self.next_id;\n         self.next_id += 1;\n-        self.streams.try_insert(id, read_dir).unwrap();\n+        self.streams.try_insert(id, OpenDir::new(read_dir)).unwrap();\n         id\n     }\n }\n@@ -1207,32 +1224,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn linux_readdir64_r(\n-        &mut self,\n-        dirp_op: &OpTy<'tcx, Tag>,\n-        entry_op: &OpTy<'tcx, Tag>,\n-        result_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, i32> {\n+    fn linux_readdir64(&mut self, dirp_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n \n-        this.assert_target_os(\"linux\", \"readdir64_r\");\n+        this.assert_target_os(\"linux\", \"readdir64\");\n \n         let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n-            this.reject_in_isolation(\"`readdir64_r`\", reject_with)?;\n-            // Set error code as \"EBADF\" (bad fd)\n-            return this.handle_not_found();\n+            this.reject_in_isolation(\"`readdir`\", reject_with)?;\n+            let eacc = this.eval_libc(\"EBADF\")?;\n+            this.set_last_error(eacc)?;\n+            return Ok(Scalar::null_ptr(this));\n         }\n \n-        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n-            err_unsup_format!(\"the DIR pointer passed to readdir64_r did not come from opendir\")\n+        let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+            err_unsup_format!(\"the DIR pointer passed to readdir64 did not come from opendir\")\n         })?;\n-        match dir_iter.next() {\n+\n+        let entry = match open_dir.read_dir.next() {\n             Some(Ok(dir_entry)) => {\n-                // Write into entry, write pointer to result, return 0 on success.\n-                // The name is written with write_os_str_to_c_str, while the rest of the\n+                // Write the directory entry into a newly allocated buffer.\n+                // The name is written with write_bytes, while the rest of the\n                 // dirent64 struct is written using write_packed_immediates.\n \n                 // For reference:\n@@ -1244,22 +1258,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 //     pub d_name: [c_char; 256],\n                 // }\n \n-                let entry_place = this.deref_operand(entry_op)?;\n-                let name_place = this.mplace_field(&entry_place, 4)?;\n+                let mut name = dir_entry.file_name(); // not a Path as there are no separators!\n+                name.push(\"\\0\"); // Add a NUL terminator\n+                let name_bytes = os_str_to_bytes(&name)?;\n+                let name_len = u64::try_from(name_bytes.len()).unwrap();\n \n-                let file_name = dir_entry.file_name(); // not a Path as there are no separators!\n-                let (name_fits, _) = this.write_os_str_to_c_str(\n-                    &file_name,\n-                    name_place.ptr,\n-                    name_place.layout.size.bytes(),\n-                )?;\n-                if !name_fits {\n-                    throw_unsup_format!(\n-                        \"a directory entry had a name too large to fit in libc::dirent64\"\n-                    );\n-                }\n+                let dirent64_layout = this.libc_ty_layout(\"dirent64\")?;\n+                let d_name_offset = dirent64_layout.fields.offset(4 /* d_name */).bytes();\n+                let size = d_name_offset.checked_add(name_len).unwrap();\n \n-                let entry_place = this.deref_operand(entry_op)?;\n+                let entry =\n+                    this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::Runtime)?;\n+\n+                // FIXME: make use of dirent64_layout\n                 let ino64_t_layout = this.libc_ty_layout(\"ino64_t\")?;\n                 let off64_t_layout = this.libc_ty_layout(\"off64_t\")?;\n                 let c_ushort_layout = this.libc_ty_layout(\"c_ushort\")?;\n@@ -1277,33 +1288,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let imms = [\n                     immty_from_uint_checked(ino, ino64_t_layout)?, // d_ino\n                     immty_from_uint_checked(0u128, off64_t_layout)?, // d_off\n-                    immty_from_uint_checked(0u128, c_ushort_layout)?, // d_reclen\n+                    immty_from_uint_checked(size, c_ushort_layout)?, // d_reclen\n                     immty_from_int_checked(file_type, c_uchar_layout)?, // d_type\n                 ];\n+                let entry_layout = this.layout_of(this.tcx.mk_array(this.tcx.types.u8, size))?;\n+                let entry_place = MPlaceTy::from_aligned_ptr(entry, entry_layout);\n                 this.write_packed_immediates(&entry_place, &imms)?;\n \n-                let result_place = this.deref_operand(result_op)?;\n-                this.write_scalar(this.read_scalar(entry_op)?, &result_place.into())?;\n+                let name_ptr = entry.offset(Size::from_bytes(d_name_offset), this)?;\n+                this.memory.write_bytes(name_ptr, name_bytes.iter().copied())?;\n \n-                Ok(0)\n+                entry\n             }\n             None => {\n-                // end of stream: return 0, assign *result=NULL\n-                this.write_null(&this.deref_operand(result_op)?.into())?;\n-                Ok(0)\n+                // end of stream: return NULL\n+                Pointer::null()\n             }\n-            Some(Err(e)) =>\n-                match e.raw_os_error() {\n-                    // return positive error number on error\n-                    Some(error) => Ok(error),\n-                    None => {\n-                        throw_unsup_format!(\n-                            \"the error {} couldn't be converted to a return value\",\n-                            e\n-                        )\n-                    }\n-                },\n-        }\n+            Some(Err(e)) => {\n+                this.set_last_error_from_io_error(e.kind())?;\n+                Pointer::null()\n+            }\n+        };\n+\n+        let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).unwrap();\n+        let old_entry = std::mem::replace(&mut open_dir.entry, entry);\n+        this.free(old_entry, MiriMemoryKind::Runtime)?;\n+\n+        Ok(Scalar::from_maybe_pointer(entry, this))\n     }\n \n     fn macos_readdir_r(\n@@ -1325,10 +1336,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return this.handle_not_found();\n         }\n \n-        let dir_iter = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n+        let open_dir = this.machine.dir_handler.streams.get_mut(&dirp).ok_or_else(|| {\n             err_unsup_format!(\"the DIR pointer passed to readdir_r did not come from opendir\")\n         })?;\n-        match dir_iter.next() {\n+        match open_dir.read_dir.next() {\n             Some(Ok(dir_entry)) => {\n                 // Write into entry, write pointer to result, return 0 on success.\n                 // The name is written with write_os_str_to_c_str, while the rest of the\n@@ -1419,8 +1430,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             return this.handle_not_found();\n         }\n \n-        if let Some(dir_iter) = this.machine.dir_handler.streams.remove(&dirp) {\n-            drop(dir_iter);\n+        if let Some(open_dir) = this.machine.dir_handler.streams.remove(&dirp) {\n+            this.free(open_dir.entry, MiriMemoryKind::Runtime)?;\n+            drop(open_dir);\n             Ok(0)\n         } else {\n             this.handle_not_found()"}, {"sha": "280f24e9ea49629e1ac849a87f5b994a29d10a41", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -43,11 +43,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.opendir(name)?;\n                 this.write_scalar(result, dest)?;\n             }\n-            \"readdir64_r\" => {\n-                let &[ref dirp, ref entry, ref result] =\n+            \"readdir64\" => {\n+                let &[ref dirp] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n-                let result = this.linux_readdir64_r(dirp, entry, result)?;\n-                this.write_scalar(Scalar::from_i32(result), dest)?;\n+                let result = this.linux_readdir64(dirp)?;\n+                this.write_scalar(result, dest)?;\n             }\n             \"ftruncate64\" => {\n                 let &[ref fd, ref length] ="}, {"sha": "0e47a9e1c3b07a9b812a47d4576bdfc7f027dc24", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -535,7 +535,7 @@ impl Stacks {\n                 MiriMemoryKind::Global\n                 | MiriMemoryKind::ExternStatic\n                 | MiriMemoryKind::Tls\n-                | MiriMemoryKind::Env\n+                | MiriMemoryKind::Runtime\n                 | MiriMemoryKind::Machine,\n             ) => (extra.base_tag(id), Permission::SharedReadWrite),\n             // Heap allocations we only track precisely when raw pointers are tagged, for now."}, {"sha": "be680131f84ab106563aa7cff391ee38e5029638", "filename": "tests/run-pass/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc15f96651408bec002664627f003ef628a041c6/tests%2Frun-pass%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc15f96651408bec002664627f003ef628a041c6/tests%2Frun-pass%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffs.rs?ref=fc15f96651408bec002664627f003ef628a041c6", "patch": "@@ -6,7 +6,9 @@\n extern crate libc;\n \n use std::ffi::CString;\n-use std::fs::{create_dir, remove_dir, remove_dir_all, remove_file, rename, File, OpenOptions};\n+use std::fs::{\n+    create_dir, read_dir, remove_dir, remove_dir_all, remove_file, rename, File, OpenOptions,\n+};\n use std::io::{Error, ErrorKind, Read, Result, Seek, SeekFrom, Write};\n use std::path::{Path, PathBuf};\n \n@@ -374,19 +376,17 @@ fn test_directory() {\n     let path_2 = dir_path.join(\"test_file_2\");\n     drop(File::create(&path_2).unwrap());\n     // Test that the files are present inside the directory\n-    /* FIXME(1966) disabled due to missing readdir support\n     let dir_iter = read_dir(&dir_path).unwrap();\n     let mut file_names = dir_iter.map(|e| e.unwrap().file_name()).collect::<Vec<_>>();\n     file_names.sort_unstable();\n-    assert_eq!(file_names, vec![\"test_file_1\", \"test_file_2\"]); */\n+    assert_eq!(file_names, vec![\"test_file_1\", \"test_file_2\"]);\n     // Clean up the files in the directory\n     remove_file(&path_1).unwrap();\n     remove_file(&path_2).unwrap();\n     // Now there should be nothing left in the directory.\n-    /* FIXME(1966) disabled due to missing readdir support\n-    dir_iter = read_dir(&dir_path).unwrap();\n+    let dir_iter = read_dir(&dir_path).unwrap();\n     let file_names = dir_iter.map(|e| e.unwrap().file_name()).collect::<Vec<_>>();\n-    assert!(file_names.is_empty());*/\n+    assert!(file_names.is_empty());\n \n     // Deleting the directory should succeed.\n     remove_dir(&dir_path).unwrap();"}]}