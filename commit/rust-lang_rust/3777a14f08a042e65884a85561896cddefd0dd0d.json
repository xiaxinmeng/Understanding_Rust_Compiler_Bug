{"sha": "3777a14f08a042e65884a85561896cddefd0dd0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NzdhMTRmMDhhMDQyZTY1ODg0YTg1NTYxODk2Y2RkZWZkMGRkMGQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-06-30T04:21:15Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-02T20:03:38Z"}, "message": "Add doubly-linked list to libcore (to be used in task.rs).", "tree": {"sha": "708b20f61033e9c83be5343b0442653a545875c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708b20f61033e9c83be5343b0442653a545875c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3777a14f08a042e65884a85561896cddefd0dd0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3777a14f08a042e65884a85561896cddefd0dd0d", "html_url": "https://github.com/rust-lang/rust/commit/3777a14f08a042e65884a85561896cddefd0dd0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3777a14f08a042e65884a85561896cddefd0dd0d/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b41592f21fb83d15f494ef61fca091d1010ce14", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b41592f21fb83d15f494ef61fca091d1010ce14", "html_url": "https://github.com/rust-lang/rust/commit/5b41592f21fb83d15f494ef61fca091d1010ce14"}], "stats": {"total": 635, "additions": 635, "deletions": 0}, "files": [{"sha": "fd1d20f9d6e2e21abe5ad15fc4f7809b8d3b32dc", "filename": "src/libcore/core.rc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3777a14f08a042e65884a85561896cddefd0dd0d/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3777a14f08a042e65884a85561896cddefd0dd0d/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=3777a14f08a042e65884a85561896cddefd0dd0d", "patch": "@@ -173,6 +173,12 @@ mod dvec_iter {\n     #[path = \"dvec.rs\"]\n     mod inst;\n }\n+mod dlist;\n+#[path=\"iter-trait\"]\n+mod dlist_iter {\n+    #[path =\"dlist.rs\"]\n+    mod inst;\n+}\n \n // Concurrency\n mod arc;"}, {"sha": "0ce40e99c4e6b3197adebc7c86153cf96a623252", "filename": "src/libcore/dlist.rs", "status": "added", "additions": 593, "deletions": 0, "changes": 593, "blob_url": "https://github.com/rust-lang/rust/blob/3777a14f08a042e65884a85561896cddefd0dd0d/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3777a14f08a042e65884a85561896cddefd0dd0d/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=3777a14f08a042e65884a85561896cddefd0dd0d", "patch": "@@ -0,0 +1,593 @@\n+#[doc = \"\n+A doubly-linked list. Supports O(1) head, tail, count, push, pop, etc.\n+\n+Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n+\"]\n+\n+import dlist_iter::extensions;\n+\n+export dlist, dlist_node;\n+export create, from_elt, from_vec, extensions;\n+\n+type dlist_link<T> = option<dlist_node<T>>;\n+\n+enum dlist_node<T> = @{\n+    data: T,\n+    mut root: option<dlist<T>>,\n+    mut prev: dlist_link<T>,\n+    mut next: dlist_link<T>\n+};\n+\n+// Needs to be an @-box so nodes can back-reference it.\n+enum dlist<T> = @{\n+    mut size: uint,\n+    mut hd: dlist_link<T>,\n+    mut tl: dlist_link<T>\n+};\n+\n+impl private_methods<T> for dlist_node<T> {\n+    pure fn assert_links() {\n+        alt self.next {\n+            some(neighbour) {\n+                alt neighbour.prev {\n+                    some(me) {\n+                        if !box::ptr_eq(*self, *me) {\n+                            fail \"Asymmetric next-link in dlist node.\"\n+                        }\n+                    }\n+                    none { fail \"One-way next-link in dlist node.\" }\n+                }\n+            }\n+            none { }\n+        }\n+        alt self.prev {\n+            some(neighbour) {\n+                alt neighbour.next {\n+                    some(me) {\n+                        if !box::ptr_eq(*me, *self) {\n+                            fail \"Asymmetric prev-link in dlist node.\"\n+                        }\n+                    }\n+                    none { fail \"One-way prev-link in dlist node.\" }\n+                }\n+            }\n+            none { }\n+        }\n+    }\n+}\n+\n+impl extensions<T> for dlist_node<T> {\n+    #[doc = \"Get the next node in the list, if there is one.\"]\n+    pure fn next_link() -> option<dlist_node<T>> {\n+        self.assert_links();\n+        self.next\n+    }\n+    #[doc = \"Get the next node in the list, failing if there isn't one.\"]\n+    pure fn next_node() -> dlist_node<T> {\n+        alt self.next_link() {\n+            some(nobe) { nobe }\n+            none       { fail \"This dlist node has no next neighbour.\" }\n+        }\n+    }\n+    #[doc = \"Get the previous node in the list, if there is one.\"]\n+    pure fn prev_link() -> option<dlist_node<T>> {\n+        self.assert_links();\n+        self.prev\n+    }\n+    #[doc = \"Get the previous node in the list, failing if there isn't one.\"]\n+    pure fn prev_node() -> dlist_node<T> {\n+        alt self.prev_link() {\n+            some(nobe) { nobe }\n+            none       { fail \"This dlist node has no previous neighbour.\" }\n+        }\n+    }\n+\n+    #[doc = \"Remove a node from whatever dlist it's on (failing if none).\"]\n+    fn remove() {\n+        if option::is_some(self.root) {\n+            option::get(self.root).remove(self);\n+        } else {\n+            fail \"Removing an orphaned dlist node - what do I remove from?\"\n+        }\n+    }\n+}\n+\n+#[doc = \"Creates a new dlist node with the given data.\"]\n+pure fn create_node<T>(+data: T) -> dlist_node<T> {\n+    dlist_node(@{data: data, mut root: none, mut prev: none, mut next: none})\n+}\n+\n+#[doc = \"Creates a new, empty dlist.\"]\n+pure fn create<T>() -> dlist<T> {\n+    dlist(@{mut size: 0, mut hd: none, mut tl: none})\n+}\n+\n+#[doc = \"Creates a new dlist with a single element\"]\n+fn from_elt<T>(+data: T) -> dlist<T> {\n+    let list = create();\n+    list.push(data);\n+    list\n+}\n+\n+fn from_vec<T: copy>(+vec: &[T]) -> dlist<T> {\n+    do vec::foldl(create(), vec) |list,data| {\n+        list.push(data); // Iterating left-to-right -- add newly to the tail.\n+        list\n+    }\n+}\n+\n+impl private_methods<T> for dlist<T> {\n+    pure fn new_link(-data: T) -> dlist_link<T> {\n+        some(dlist_node(@{data: data, mut root: some(self),\n+                          mut prev: none, mut next: none}))\n+    }\n+    pure fn assert_mine(nobe: dlist_node<T>) {\n+        alt nobe.root {\n+            some(me) { assert box::ptr_eq(*self, *me); }\n+            none     { fail \"This node isn't on this dlist.\" }\n+        }\n+    }\n+    fn make_mine(nobe: dlist_node<T>) {\n+        if option::is_some(nobe.root) {\n+            fail \"Cannot insert node that's already on a dlist!\"\n+        }\n+        nobe.root = some(self);\n+    }\n+    // Link two nodes together. If either of them are 'none', also sets\n+    // the head and/or tail pointers appropriately.\n+    #[inline(always)]\n+    fn link(+before: dlist_link<T>, +after: dlist_link<T>) {\n+        alt before {\n+            some(neighbour) { neighbour.next = after; }\n+            none            { self.hd        = after; }\n+        }\n+        alt after {\n+            some(neighbour) { neighbour.prev = before; }\n+            none            { self.tl        = before; }\n+        }\n+    }\n+    // Remove a node from the list.\n+    fn unlink(nobe: dlist_node<T>) {\n+        self.assert_mine(nobe);\n+        assert self.size > 0;\n+        self.link(nobe.prev, nobe.next);\n+        nobe.prev = none; // Release extraneous references.\n+        nobe.next = none;\n+        nobe.root = none;\n+        self.size -= 1;\n+    }\n+\n+    fn add_head(+nobe: dlist_link<T>) {\n+        self.link(nobe, self.hd); // Might set tail too.\n+        self.hd = nobe;\n+        self.size += 1;\n+    }\n+    fn add_tail(+nobe: dlist_link<T>) {\n+        self.link(self.tl, nobe); // Might set head too.\n+        self.tl = nobe;\n+        self.size += 1;\n+    }\n+    fn insert_left(nobe: dlist_link<T>, neighbour: dlist_node<T>) {\n+        self.assert_mine(neighbour);\n+        assert self.size > 0;\n+        self.link(neighbour.prev, nobe);\n+        self.link(nobe, some(neighbour));\n+        self.size += 1;\n+    }\n+    fn insert_right(neighbour: dlist_node<T>, nobe: dlist_link<T>) {\n+        self.assert_mine(neighbour);\n+        assert self.size > 0;\n+        self.link(nobe, neighbour.next);\n+        self.link(some(neighbour), nobe);\n+        self.size += 1;\n+    }\n+}\n+\n+impl extensions<T> for dlist<T> {\n+    #[doc = \"Get the size of the list. O(1).\"]\n+    pure fn len()          -> uint { self.size }\n+    #[doc = \"Returns true if the list is empty. O(1).\"]\n+    pure fn is_empty()     -> bool { self.len() == 0 }\n+    #[doc = \"Returns true if the list is not empty. O(1).\"]\n+    pure fn is_not_empty() -> bool { self.len() != 0 }\n+\n+    #[doc = \"Add data to the head of the list. O(1).\"]\n+    fn push_head(+data: T) {\n+        self.add_head(self.new_link(data));\n+    }\n+    #[doc = \"Add data to the head of the list, and get the new containing\n+             node. O(1).\"]\n+    fn push_head_n(+data: T) -> dlist_node<T> {\n+        let mut nobe = self.new_link(data);\n+        self.add_head(nobe);\n+        option::get(nobe)\n+    }\n+    #[doc = \"Add data to the tail of the list. O(1).\"]\n+    fn push(+data: T) {\n+        self.add_tail(self.new_link(data));\n+    }\n+    #[doc = \"Add data to the tail of the list, and get the new containing\n+             node. O(1).\"]\n+    fn push_n(+data: T) -> dlist_node<T> {\n+        let mut nobe = self.new_link(data);\n+        self.add_tail(nobe);\n+        option::get(nobe)\n+    }\n+    #[doc = \"Insert data into the middle of the list, left of the given node.\n+             O(1).\"]\n+    fn insert_before(+data: T, neighbour: dlist_node<T>) {\n+        self.insert_left(self.new_link(data), neighbour);\n+    }\n+    #[doc = \"Insert an existing node in the middle of the list, left of the\n+             given node. O(1).\"]\n+    fn insert_n_before(nobe: dlist_node<T>, neighbour: dlist_node<T>) {\n+        self.make_mine(nobe);\n+        self.insert_left(some(nobe), neighbour);\n+    }\n+    #[doc = \"Insert data in the middle of the list, left of the given node,\n+             and get its containing node. O(1).\"]\n+    fn insert_before_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {\n+        let mut nobe = self.new_link(data);\n+        self.insert_left(nobe, neighbour);\n+        option::get(nobe)\n+    }\n+    #[doc = \"Insert data into the middle of the list, right of the given node.\n+             O(1).\"]\n+    fn insert_after(+data: T, neighbour: dlist_node<T>) {\n+        self.insert_right(neighbour, self.new_link(data));\n+    }\n+    #[doc = \"Insert an existing node in the middle of the list, right of the\n+             given node. O(1).\"]\n+    fn insert_n_after(nobe: dlist_node<T>, neighbour: dlist_node<T>) {\n+        self.make_mine(nobe);\n+        self.insert_right(neighbour, some(nobe));\n+    }\n+    #[doc = \"Insert data in the middle of the list, right of the given node,\n+             and get its containing node. O(1).\"]\n+    fn insert_after_n(+data: T, neighbour: dlist_node<T>) -> dlist_node<T> {\n+        let mut nobe = self.new_link(data);\n+        self.insert_right(neighbour, nobe);\n+        option::get(nobe)\n+    }\n+\n+    #[doc = \"Remove a node from the head of the list. O(1).\"]\n+    fn pop_n() -> option<dlist_node<T>> {\n+        let hd = self.peek_n();\n+        hd.map(|nobe| self.unlink(nobe));\n+        hd\n+    }\n+    #[doc = \"Remove a node from the tail of the list. O(1).\"]\n+    fn pop_tail_n() -> option<dlist_node<T>> {\n+        let tl = self.peek_tail_n();\n+        tl.map(|nobe| self.unlink(nobe));\n+        tl\n+    }\n+    #[doc = \"Get the node at the list's head. O(1).\"]\n+    pure fn peek_n() -> option<dlist_node<T>> { self.hd }\n+    #[doc = \"Get the node at the list's tail. O(1).\"]\n+    pure fn peek_tail_n() -> option<dlist_node<T>> { self.tl }\n+\n+    #[doc = \"Get the node at the list's head, failing if empty. O(1).\"]\n+    pure fn head_n() -> dlist_node<T> {\n+        alt self.hd {\n+            some(nobe) { nobe }\n+            none       { fail \"Attempted to get the head of an empty dlist.\" }\n+        }\n+    }\n+    #[doc = \"Get the node at the list's tail, failing if empty. O(1).\"]\n+    pure fn tail_n() -> dlist_node<T> {\n+        alt self.tl {\n+            some(nobe) { nobe }\n+            none       { fail \"Attempted to get the tail of an empty dlist.\" }\n+        }\n+    }\n+\n+    #[doc = \"Remove a node from anywhere in the list. O(1).\"]\n+    fn remove(nobe: dlist_node<T>) { self.unlink(nobe); }\n+\n+    #[doc = \"Check data structure integrity. O(n).\"]\n+    fn assert_consistent() {\n+        if option::is_none(self.hd) || option::is_none(self.tl) {\n+            assert option::is_none(self.hd) && option::is_none(self.tl);\n+        }\n+        // iterate forwards\n+        let mut count = 0;\n+        let mut link = self.peek_n();\n+        let mut rabbit = link;\n+        while option::is_some(link) {\n+            let nobe = option::get(link);\n+            // check self on this list\n+            assert option::is_some(nobe.root) &&\n+                box::ptr_eq(*option::get(nobe.root), *self);\n+            // check cycle\n+            if option::is_some(rabbit) { rabbit = option::get(rabbit).next; }\n+            if option::is_some(rabbit) { rabbit = option::get(rabbit).next; }\n+            if option::is_some(rabbit) {\n+                assert !box::ptr_eq(*option::get(rabbit), *nobe);\n+            }\n+            // advance\n+            link = nobe.next_link();\n+            count += 1;\n+        }\n+        assert count == self.len();\n+        // iterate backwards - some of this is probably redundant.\n+        link = self.peek_tail_n();\n+        rabbit = link;\n+        while option::is_some(link) {\n+            let nobe = option::get(link);\n+            // check self on this list\n+            assert option::is_some(nobe.root) &&\n+                box::ptr_eq(*option::get(nobe.root), *self);\n+            // check cycle\n+            if option::is_some(rabbit) { rabbit = option::get(rabbit).prev; }\n+            if option::is_some(rabbit) { rabbit = option::get(rabbit).prev; }\n+            if option::is_some(rabbit) {\n+                assert !box::ptr_eq(*option::get(rabbit), *nobe);\n+            }\n+            // advance\n+            link = nobe.prev_link();\n+            count -= 1;\n+        }\n+        assert count == 0;\n+    }\n+}\n+\n+impl extensions<T: copy> for dlist<T> {\n+    #[doc = \"Remove data from the head of the list. O(1).\"]\n+    fn pop()       -> option<T> { self.pop_n().map       (|nobe| nobe.data) }\n+    #[doc = \"Remove data from the tail of the list. O(1).\"]\n+    fn pop_tail()  -> option<T> { self.pop_tail_n().map  (|nobe| nobe.data) }\n+    #[doc = \"Get data at the list's head. O(1).\"]\n+    fn peek()      -> option<T> { self.peek_n().map      (|nobe| nobe.data) }\n+    #[doc = \"Get data at the list's tail. O(1).\"]\n+    fn peek_tail() -> option<T> { self.peek_tail_n().map (|nobe| nobe.data) }\n+    #[doc = \"Get data at the list's head, failing if empty. O(1).\"]\n+    pure fn head() -> T         { self.head_n().data }\n+    #[doc = \"Get data at the list's tail, failing if empty. O(1).\"]\n+    pure fn tail() -> T         { self.tail_n().data }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_dlist_is_empty() {\n+        let empty = create::<int>();\n+        let full1 = from_vec(~[1,2,3]);\n+        assert empty.is_empty();\n+        assert !full1.is_empty();\n+        assert !empty.is_not_empty();\n+        assert full1.is_not_empty();\n+    }\n+    #[test]\n+    fn test_dlist_head_tail() {\n+        let l = from_vec(~[1,2,3]);\n+        assert l.head() == 1;\n+        assert l.tail() == 3;\n+        assert l.len() == 3;\n+    }\n+    #[test]\n+    fn test_dlist_pop() {\n+        let l = from_vec(~[1,2,3]);\n+        assert l.pop().get() == 1;\n+        assert l.tail() == 3;\n+        assert l.head() == 2;\n+        assert l.pop().get() == 2;\n+        assert l.tail() == 3;\n+        assert l.head() == 3;\n+        assert l.pop().get() == 3;\n+        assert l.is_empty();\n+        assert l.pop().is_none();\n+    }\n+    #[test]\n+    fn test_dlist_pop_tail() {\n+        let l = from_vec(~[1,2,3]);\n+        assert l.pop_tail().get() == 3;\n+        assert l.tail() == 2;\n+        assert l.head() == 1;\n+        assert l.pop_tail().get() == 2;\n+        assert l.tail() == 1;\n+        assert l.head() == 1;\n+        assert l.pop_tail().get() == 1;\n+        assert l.is_empty();\n+        assert l.pop_tail().is_none();\n+    }\n+    #[test]\n+    fn test_dlist_push() {\n+        let l = create::<int>();\n+        l.push(1);\n+        assert l.head() == 1;\n+        assert l.tail() == 1;\n+        l.push(2);\n+        assert l.head() == 1;\n+        assert l.tail() == 2;\n+        l.push(3);\n+        assert l.head() == 1;\n+        assert l.tail() == 3;\n+        assert l.len() == 3;\n+    }\n+    #[test]\n+    fn test_dlist_push_head() {\n+        let l = create::<int>();\n+        l.push_head(3);\n+        assert l.head() == 3;\n+        assert l.tail() == 3;\n+        l.push_head(2);\n+        assert l.head() == 2;\n+        assert l.tail() == 3;\n+        l.push_head(1);\n+        assert l.head() == 1;\n+        assert l.tail() == 3;\n+        assert l.len() == 3;\n+    }\n+    #[test]\n+    fn test_dlist_foldl() {\n+        let l = from_vec(vec::from_fn(101, |x|x));\n+        assert iter::foldl(l, 0, |accum,elem| accum+elem) == 5050;\n+    }\n+    #[test]\n+    fn test_dlist_remove_head() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let one = l.push_n(1);\n+        l.assert_consistent(); let _two = l.push_n(2);\n+        l.assert_consistent(); let _three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(one);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); assert l.head() == 2;\n+        l.assert_consistent(); assert l.tail() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_remove_mid() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let _one = l.push_n(1);\n+        l.assert_consistent(); let two = l.push_n(2);\n+        l.assert_consistent(); let _three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(two);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); assert l.head() == 1;\n+        l.assert_consistent(); assert l.tail() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_remove_tail() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let _one = l.push_n(1);\n+        l.assert_consistent(); let _two = l.push_n(2);\n+        l.assert_consistent(); let three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(three);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); assert l.head() == 1;\n+        l.assert_consistent(); assert l.tail() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_remove_one_two() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let one = l.push_n(1);\n+        l.assert_consistent(); let two = l.push_n(2);\n+        l.assert_consistent(); let _three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(one);\n+        l.assert_consistent(); l.remove(two);\n+        // and through and through, the vorpal blade went snicker-snack\n+        l.assert_consistent(); assert l.len() == 1;\n+        l.assert_consistent(); assert l.head() == 3;\n+        l.assert_consistent(); assert l.tail() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_remove_one_three() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let one = l.push_n(1);\n+        l.assert_consistent(); let _two = l.push_n(2);\n+        l.assert_consistent(); let three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(one);\n+        l.assert_consistent(); l.remove(three);\n+        l.assert_consistent(); assert l.len() == 1;\n+        l.assert_consistent(); assert l.head() == 2;\n+        l.assert_consistent(); assert l.tail() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_remove_two_three() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let _one = l.push_n(1);\n+        l.assert_consistent(); let two = l.push_n(2);\n+        l.assert_consistent(); let three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(two);\n+        l.assert_consistent(); l.remove(three);\n+        l.assert_consistent(); assert l.len() == 1;\n+        l.assert_consistent(); assert l.head() == 1;\n+        l.assert_consistent(); assert l.tail() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_remove_all() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let one = l.push_n(1);\n+        l.assert_consistent(); let two = l.push_n(2);\n+        l.assert_consistent(); let three = l.push_n(3);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); l.remove(two);\n+        l.assert_consistent(); l.remove(three);\n+        l.assert_consistent(); l.remove(one); // Twenty-three is number one!\n+        l.assert_consistent(); assert l.peek() == none;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_insert_n_before() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let _one = l.push_n(1);\n+        l.assert_consistent(); let two = l.push_n(2);\n+        l.assert_consistent(); let three = create_node(3);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); l.insert_n_before(three, two);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); assert l.head() == 1;\n+        l.assert_consistent(); assert l.tail() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_insert_n_after() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let one = l.push_n(1);\n+        l.assert_consistent(); let _two = l.push_n(2);\n+        l.assert_consistent(); let three = create_node(3);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); l.insert_n_after(three, one);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); assert l.head() == 1;\n+        l.assert_consistent(); assert l.tail() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_insert_before_head() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let one = l.push_n(1);\n+        l.assert_consistent(); let _two = l.push_n(2);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); l.insert_before(3, one);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); assert l.head() == 3;\n+        l.assert_consistent(); assert l.tail() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+    #[test]\n+    fn test_dlist_insert_after_tail() {\n+        let l = create::<int>();\n+        l.assert_consistent(); let _one = l.push_n(1);\n+        l.assert_consistent(); let two = l.push_n(2);\n+        l.assert_consistent(); assert l.len() == 2;\n+        l.assert_consistent(); l.insert_after(3, two);\n+        l.assert_consistent(); assert l.len() == 3;\n+        l.assert_consistent(); assert l.head() == 1;\n+        l.assert_consistent(); assert l.tail() == 3;\n+        l.assert_consistent(); assert l.pop().get() == 1;\n+        l.assert_consistent(); assert l.pop().get() == 2;\n+        l.assert_consistent(); assert l.pop().get() == 3;\n+        l.assert_consistent(); assert l.is_empty();\n+    }\n+}"}, {"sha": "f97dce5854dc8216d993ab17f1b6b4f62f0cff36", "filename": "src/libcore/iter-trait/dlist.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3777a14f08a042e65884a85561896cddefd0dd0d/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3777a14f08a042e65884a85561896cddefd0dd0d/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=3777a14f08a042e65884a85561896cddefd0dd0d", "patch": "@@ -0,0 +1,36 @@\n+type IMPL_T<A> = dlist::dlist<A>;\n+\n+#[doc = \"\n+Iterates through the current contents.\n+\n+Attempts to access this dlist during iteration are allowed (to allow for e.g.\n+breadth-first search with in-place enqueues), but removing the current node\n+is forbidden.\n+\"]\n+fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n+    import dlist::extensions;\n+\n+    let mut link = self.peek_n();\n+    while option::is_some(link) {\n+        let nobe = option::get(link);\n+        // Check dlist invariant.\n+        if !option::is_some(nobe.root) ||\n+           !box::ptr_eq(*option::get(nobe.root), *self) {\n+            fail \"Iteration encountered a dlist node not on this dlist.\"\n+        }\n+        f(nobe.data);\n+        // Check that the user didn't do a remove.\n+        // Note that this makes it ok for the user to remove the node and then\n+        // immediately put it back in a different position. I allow this.\n+        if !option::is_some(nobe.root) ||\n+           !box::ptr_eq(*option::get(nobe.root), *self) {\n+            fail \"Removing a dlist node during iteration is forbidden!\"\n+        }\n+        link = nobe.next_link();\n+    }\n+}\n+\n+fn SIZE_HINT<A>(self: IMPL_T<A>) -> option<uint> {\n+    import dlist::extensions;\n+    some(self.len())\n+}"}]}