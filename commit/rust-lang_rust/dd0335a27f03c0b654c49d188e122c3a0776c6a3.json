{"sha": "dd0335a27f03c0b654c49d188e122c3a0776c6a3", "node_id": "C_kwDOAAsO6NoAKGRkMDMzNWEyN2YwM2MwYjY1NGM0OWQxODhlMTIyYzNhMDc3NmM2YTM", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-26T19:08:35Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-09-08T22:04:10Z"}, "message": "Don't construct ReEmpty regions in resolve_var", "tree": {"sha": "adad2f425cc705f7a71b8601852b69c3f0f0d8d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adad2f425cc705f7a71b8601852b69c3f0f0d8d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd0335a27f03c0b654c49d188e122c3a0776c6a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd0335a27f03c0b654c49d188e122c3a0776c6a3", "html_url": "https://github.com/rust-lang/rust/commit/dd0335a27f03c0b654c49d188e122c3a0776c6a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd0335a27f03c0b654c49d188e122c3a0776c6a3/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7e5feb637ca0e130f2890800da054771410d321", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e5feb637ca0e130f2890800da054771410d321", "html_url": "https://github.com/rust-lang/rust/commit/e7e5feb637ca0e130f2890800da054771410d321"}], "stats": {"total": 107, "additions": 102, "deletions": 5}, "files": [{"sha": "99f956bede7a885373e6e1a62c16d843833196a5", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 102, "deletions": 5, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/dd0335a27f03c0b654c49d188e122c3a0776c6a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd0335a27f03c0b654c49d188e122c3a0776c6a3/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=dd0335a27f03c0b654c49d188e122c3a0776c6a3", "patch": "@@ -460,6 +460,90 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// True if `a <= b`.\n+    fn sub_region_values(&self, a: VarValue<'tcx>, b: VarValue<'tcx>) -> bool {\n+        match (a, b) {\n+            // Error region is `'static`\n+            (VarValue::ErrorValue, _) | (_, VarValue::ErrorValue) => return true,\n+            (VarValue::Empty(a_ui), VarValue::Empty(b_ui)) => {\n+                // Empty regions are ordered according to the universe\n+                // they are associated with.\n+                a_ui.min(b_ui) == b_ui\n+            }\n+            (VarValue::Value(a), VarValue::Empty(b_ui)) => {\n+                match *a {\n+                    ReLateBound(..) | ReErased => {\n+                        bug!(\"cannot relate region: {:?}\", a);\n+                    }\n+\n+                    ReVar(v_id) => {\n+                        span_bug!(\n+                            self.var_infos[v_id].origin.span(),\n+                            \"lub_concrete_regions invoked with non-concrete region: {:?}\",\n+                            a\n+                        );\n+                    }\n+\n+                    ReStatic | ReEarlyBound(_) | ReFree(_) => {\n+                        // nothing lives longer than `'static`\n+\n+                        // All empty regions are less than early-bound, free,\n+                        // and scope regions.\n+\n+                        false\n+                    }\n+\n+                    ReEmpty(a_ui) => {\n+                        // Empty regions are ordered according to the universe\n+                        // they are associated with.\n+                        a_ui.min(b_ui) == b_ui\n+                    }\n+\n+                    RePlaceholder(_) => {\n+                        // The LUB is either `a` or `'static`\n+                        false\n+                    }\n+                }\n+            }\n+            (VarValue::Empty(a_ui), VarValue::Value(b)) => {\n+                match *b {\n+                    ReLateBound(..) | ReErased => {\n+                        bug!(\"cannot relate region: {:?}\", b);\n+                    }\n+\n+                    ReVar(v_id) => {\n+                        span_bug!(\n+                            self.var_infos[v_id].origin.span(),\n+                            \"lub_concrete_regions invoked with non-concrete regions: {:?}\",\n+                            b\n+                        );\n+                    }\n+\n+                    ReStatic | ReEarlyBound(_) | ReFree(_) => {\n+                        // nothing lives longer than `'static`\n+                        // All empty regions are less than early-bound, free,\n+                        // and scope regions.\n+                        true\n+                    }\n+\n+                    ReEmpty(b_ui) => {\n+                        // Empty regions are ordered according to the universe\n+                        // they are associated with.\n+                        a_ui.min(b_ui) == b_ui\n+                    }\n+\n+                    RePlaceholder(placeholder) => {\n+                        // If this empty region is from a universe that can\n+                        // name the placeholder, then the placeholder is\n+                        // larger; otherwise, the only ancestor is `'static`.\n+                        if a_ui.can_name(placeholder.universe) { true } else { false }\n+                    }\n+                }\n+            }\n+            (VarValue::Value(a), VarValue::Value(b)) => self.sub_concrete_regions(a, b),\n+        }\n+    }\n+\n     /// True if `a <= b`, but not defined over inference variables.\n     #[instrument(level = \"trace\", skip(self))]\n     fn sub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> bool {\n@@ -989,12 +1073,25 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n \n             VerifyBound::OutlivedBy(r) => {\n-                self.sub_concrete_regions(min, var_values.normalize(self.tcx(), *r))\n+                let a = match *min {\n+                    ty::ReVar(rid) => var_values.values[rid],\n+                    _ => VarValue::Value(min),\n+                };\n+                let b = match **r {\n+                    ty::ReVar(rid) => var_values.values[rid],\n+                    _ => VarValue::Value(*r),\n+                };\n+                self.sub_region_values(a, b)\n             }\n \n-            VerifyBound::IsEmpty => {\n-                matches!(*min, ty::ReEmpty(_))\n-            }\n+            VerifyBound::IsEmpty => match *min {\n+                ty::ReVar(rid) => match var_values.values[rid] {\n+                    VarValue::ErrorValue => false,\n+                    VarValue::Empty(_) => true,\n+                    VarValue::Value(min) => matches!(*min, ty::ReEmpty(_)),\n+                },\n+                _ => matches!(*min, ty::ReEmpty(_)),\n+            },\n \n             VerifyBound::AnyBound(bs) => {\n                 bs.iter().any(|b| self.bound_is_met(b, var_values, generic_ty, min))\n@@ -1036,7 +1133,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     ) -> ty::Region<'tcx> {\n         let result = match *r {\n             ty::ReVar(rid) => match self.values[rid] {\n-                VarValue::Empty(vid_universe) => tcx.mk_region(ty::ReEmpty(vid_universe)),\n+                VarValue::Empty(_) => r,\n                 VarValue::Value(r) => r,\n                 VarValue::ErrorValue => tcx.lifetimes.re_static,\n             },"}]}