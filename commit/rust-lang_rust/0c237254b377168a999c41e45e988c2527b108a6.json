{"sha": "0c237254b377168a999c41e45e988c2527b108a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjMjM3MjU0YjM3NzE2OGE5OTljNDFlNDVlOTg4YzI1MjdiMTA4YTY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-19T20:23:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-19T20:23:35Z"}, "message": "doc: Copyedit task section", "tree": {"sha": "90b472f1fc7dcd122f2b45774e803ab84e0be392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90b472f1fc7dcd122f2b45774e803ab84e0be392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c237254b377168a999c41e45e988c2527b108a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c237254b377168a999c41e45e988c2527b108a6", "html_url": "https://github.com/rust-lang/rust/commit/0c237254b377168a999c41e45e988c2527b108a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c237254b377168a999c41e45e988c2527b108a6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35f553dbd630b8da03e8fdf0faef6f55a5cf5743", "url": "https://api.github.com/repos/rust-lang/rust/commits/35f553dbd630b8da03e8fdf0faef6f55a5cf5743", "html_url": "https://github.com/rust-lang/rust/commit/35f553dbd630b8da03e8fdf0faef6f55a5cf5743"}], "stats": {"total": 56, "additions": 27, "deletions": 29}, "files": [{"sha": "d2645a3f983aafad5a83eca16866eb674694d6b4", "filename": "doc/rust.md", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0c237254b377168a999c41e45e988c2527b108a6/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/0c237254b377168a999c41e45e988c2527b108a6/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=0c237254b377168a999c41e45e988c2527b108a6", "patch": "@@ -2964,17 +2964,18 @@ Many channels can be bound to the same port, but each channel is bound to a\n single port. In other words, channels and ports exist in an N:1 relationship,\n N channels to 1 port. ^[It may help to remember nautical terminology\n when differentiating channels from ports.  Many different waterways --\n-channels -- may lead to the same port.}\n+channels -- may lead to the same port.]\n \n Each port and channel can carry only one type of message. The message type is\n encoded as a parameter of the channel or port type. The message type of a\n channel is equal to the message type of the port it is bound to. The types of\n messages must satisfy the `send` built-in interface.\n \n-Messages are generally sent asynchronously, with optional rate-limiting on the\n-transmit side. A channel contains a message queue and asynchronously sending a\n-message merely inserts it into the sending channel's queue; message receipt is\n-the responsibility of the receiving task.\n+Messages are generally sent asynchronously, with optional\n+rate-limiting on the transmit side.  Each port contains a message\n+queue and sending a message over a channel merely means inserting it\n+into the associated port's queue; message receipt is the\n+responsibility of the receiving task.\n \n Messages are sent on channels and received on ports using standard library\n functions.\n@@ -3032,71 +3033,68 @@ execute, after which it is *descheduled* at a loop-edge or similar\n preemption point, and another task within is scheduled, pseudo-randomly.\n \n An executing task can yield control at any time, by making a library call to\n-`std::task::yield`, which deschedules it immediately. Entering any other\n+`core::task::yield`, which deschedules it immediately. Entering any other\n non-executing state (blocked, dead) similarly deschedules the task.\n \n \n ### Spawning tasks\n \n-A call to `std::task::spawn`, passing a 0-argument function as its single\n+A call to `core::task::spawn`, passing a 0-argument function as its single\n argument, causes the runtime to construct a new task executing the passed\n function. The passed function is referred to as the _entry function_ for\n the spawned task, and any captured environment is carries is moved from the\n spawning task to the spawned task before the spawned task begins execution.\n \n-The result of a `spawn` call is a `std::task::task` value.\n+The result of a `spawn` call is a `core::task::task` value.\n \n An example of a `spawn` call:\n \n ~~~~\n-import std::task::*;\n-import std::comm::*;\n+import task::*;\n+import comm::*;\n \n-fn helper(c: chan<u8>) {\n-    // do some work.\n-    let result = ...;\n-    send(c, result);\n-}\n+let p = port();\n+let c = chan(p);\n \n-let p: port<u8>;\n+spawn {||\n+    // let task run, do other things\n+    // ...\n+    send(c, true);\n+};\n \n-spawn(bind helper(chan(p)));\n-// let task run, do other things.\n-// ...\n let result = recv(p);\n ~~~~\n \n \n ### Sending values into channels\n \n-Sending a value into a channel is done by a library call to `std::comm::send`,\n+Sending a value into a channel is done by a library call to `core::comm::send`,\n which takes a channel and a value to send, and moves the value into the\n channel's outgoing buffer.\n \n An example of a send:\n \n ~~~~\n-import std::comm::*;\n+import comm::*;\n let c: chan<str> = ...;\n send(c, \"hello, world\");\n ~~~~\n \n \n ### Receiving values from ports\n \n-Receiving a value is done by a call to the `recv` method, on a value of type\n-`std::comm::port`. This call causes the receiving task to enter the *blocked\n-reading* state until a task is sending a value to the port, at which point the\n-runtime pseudo-randomly selects a sending task and moves a value from the head\n-of one of the task queues to the call's return value, and un-blocks the\n-receiving task. See [communication system](#communication-system).\n+Receiving a value is done by a call to the `recv` method on a value of type\n+`core::comm::port`. This call causes the receiving task to enter the *blocked\n+reading* state until a value arrives in the port's receive queue, at which\n+time the port deques a value to return, and un-blocks the receiving task.\n+See [communication system](#communication-system).\n \n An example of a *receive*:\n \n ~~~~~~~~\n-import std::comm::*;\n+import comm::*;\n let p: port<str> = ...;\n-let s: str = recv(p);\n+let s = recv(p);\n ~~~~~~~~\n \n "}]}