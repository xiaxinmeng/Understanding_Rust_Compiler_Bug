{"sha": "df87be88d8500c8955f882d71467e01a7d4db9ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmODdiZTg4ZDg1MDBjODk1NWY4ODJkNzE0NjdlMDFhN2Q0ZGI5YWI=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-13T22:56:41Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-14T17:23:45Z"}, "message": "Factor format string highlighting out", "tree": {"sha": "1d3a21d1824fda2016597625eac41df1aa69822c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d3a21d1824fda2016597625eac41df1aa69822c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df87be88d8500c8955f882d71467e01a7d4db9ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df87be88d8500c8955f882d71467e01a7d4db9ab", "html_url": "https://github.com/rust-lang/rust/commit/df87be88d8500c8955f882d71467e01a7d4db9ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df87be88d8500c8955f882d71467e01a7d4db9ab/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0fb069c5b02072239891ce564feaa7d1890c6d6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fb069c5b02072239891ce564feaa7d1890c6d6f", "html_url": "https://github.com/rust-lang/rust/commit/0fb069c5b02072239891ce564feaa7d1890c6d6f"}], "stats": {"total": 165, "additions": 90, "deletions": 75}, "files": [{"sha": "f430006d7d5155cb4c14d5234b5476d24b0d562b", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 8, "deletions": 75, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/df87be88d8500c8955f882d71467e01a7d4db9ab/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df87be88d8500c8955f882d71467e01a7d4db9ab/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=df87be88d8500c8955f882d71467e01a7d4db9ab", "patch": "@@ -1,6 +1,7 @@\n-mod tags;\n+mod format;\n mod html;\n mod injection;\n+mod tags;\n #[cfg(test)]\n mod tests;\n \n@@ -17,9 +18,8 @@ use syntax::{\n     SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n };\n \n-use crate::FileId;\n+use crate::{syntax_highlighting::format::FormatStringHighlighter, FileId};\n \n-use ast::FormatSpecifier;\n pub(crate) use html::highlight_as_html;\n pub use tags::{Highlight, HighlightModifier, HighlightModifiers, HighlightTag};\n \n@@ -69,7 +69,7 @@ pub(crate) fn highlight(\n     let mut stack = HighlightedRangeStack::new();\n \n     let mut current_macro_call: Option<(ast::MacroCall, Option<MacroMatcherParseState>)> = None;\n-    let mut format_string: Option<SyntaxElement> = None;\n+    let mut format_string_highlighter = FormatStringHighlighter::default();\n \n     // Walk all nodes, keeping track of whether we are inside a macro or not.\n     // If in macro, expand it first and highlight the expanded code.\n@@ -121,7 +121,7 @@ pub(crate) fn highlight(\n             WalkEvent::Leave(Some(mc)) => {\n                 assert!(current_macro_call.map(|it| it.0) == Some(mc));\n                 current_macro_call = None;\n-                format_string = None;\n+                format_string_highlighter.reset();\n             }\n             _ => (),\n         }\n@@ -173,30 +173,7 @@ pub(crate) fn highlight(\n             let token = sema.descend_into_macros(token.clone());\n             let parent = token.parent();\n \n-            // Check if macro takes a format string and remember it for highlighting later.\n-            // The macros that accept a format string expand to a compiler builtin macros\n-            // `format_args` and `format_args_nl`.\n-            if let Some(name) = parent\n-                .parent()\n-                .and_then(ast::MacroCall::cast)\n-                .and_then(|mc| mc.path())\n-                .and_then(|p| p.segment())\n-                .and_then(|s| s.name_ref())\n-            {\n-                match name.text().as_str() {\n-                    \"format_args\" | \"format_args_nl\" => {\n-                        format_string = parent\n-                            .children_with_tokens()\n-                            .filter(|t| t.kind() != WHITESPACE)\n-                            .nth(1)\n-                            .filter(|e| {\n-                                ast::String::can_cast(e.kind())\n-                                    || ast::RawString::can_cast(e.kind())\n-                            })\n-                    }\n-                    _ => {}\n-                }\n-            }\n+            format_string_highlighter.check_for_format_string(&parent);\n \n             // We only care Name and Name_ref\n             match (token.kind(), parent.kind()) {\n@@ -214,8 +191,6 @@ pub(crate) fn highlight(\n             }\n         }\n \n-        let is_format_string = format_string.as_ref() == Some(&element_to_highlight);\n-\n         if let Some((highlight, binding_hash)) = highlight_element(\n             &sema,\n             &mut bindings_shadow_count,\n@@ -226,19 +201,7 @@ pub(crate) fn highlight(\n             if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n             {\n-                if is_format_string {\n-                    stack.push();\n-                    string.lex_format_specifier(|piece_range, kind| {\n-                        if let Some(highlight) = highlight_format_specifier(kind) {\n-                            stack.add(HighlightedRange {\n-                                range: piece_range + range.start(),\n-                                highlight: highlight.into(),\n-                                binding_hash: None,\n-                            });\n-                        }\n-                    });\n-                    stack.pop();\n-                }\n+                format_string_highlighter.highlight_format_string(&mut stack, &string, range);\n                 // Highlight escape sequences\n                 if let Some(char_ranges) = string.char_ranges() {\n                     stack.push();\n@@ -256,19 +219,7 @@ pub(crate) fn highlight(\n             } else if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::RawString::cast)\n             {\n-                if is_format_string {\n-                    stack.push();\n-                    string.lex_format_specifier(|piece_range, kind| {\n-                        if let Some(highlight) = highlight_format_specifier(kind) {\n-                            stack.add(HighlightedRange {\n-                                range: piece_range + range.start(),\n-                                highlight: highlight.into(),\n-                                binding_hash: None,\n-                            });\n-                        }\n-                    });\n-                    stack.pop();\n-                }\n+                format_string_highlighter.highlight_format_string(&mut stack, &string, range);\n             }\n         }\n     }\n@@ -436,24 +387,6 @@ impl HighlightedRangeStack {\n     }\n }\n \n-fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n-    Some(match kind {\n-        FormatSpecifier::Open\n-        | FormatSpecifier::Close\n-        | FormatSpecifier::Colon\n-        | FormatSpecifier::Fill\n-        | FormatSpecifier::Align\n-        | FormatSpecifier::Sign\n-        | FormatSpecifier::NumberSign\n-        | FormatSpecifier::DollarSign\n-        | FormatSpecifier::Dot\n-        | FormatSpecifier::Asterisk\n-        | FormatSpecifier::QuestionMark => HighlightTag::FormatSpecifier,\n-        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n-        FormatSpecifier::Identifier => HighlightTag::Local,\n-    })\n-}\n-\n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n     let path = macro_call.path()?;\n     let name_ref = path.segment()?.name_ref()?;"}, {"sha": "3ab01295ab2c8a1da44e9757fd624220a4595a1a", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/df87be88d8500c8955f882d71467e01a7d4db9ab/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df87be88d8500c8955f882d71467e01a7d4db9ab/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=df87be88d8500c8955f882d71467e01a7d4db9ab", "patch": "@@ -0,0 +1,82 @@\n+//! Syntax highlighting for format macro strings.\n+use syntax::{\n+    ast::{self, FormatSpecifier, HasFormatSpecifier},\n+    AstNode, AstToken, SyntaxElement, SyntaxKind, SyntaxNode, TextRange,\n+};\n+\n+use crate::{syntax_highlighting::HighlightedRangeStack, HighlightTag, HighlightedRange};\n+\n+#[derive(Default)]\n+pub(super) struct FormatStringHighlighter {\n+    format_string: Option<SyntaxElement>,\n+}\n+\n+impl FormatStringHighlighter {\n+    pub(super) fn reset(&mut self) {\n+        self.format_string = None;\n+    }\n+\n+    pub(super) fn check_for_format_string(&mut self, parent: &SyntaxNode) {\n+        // Check if macro takes a format string and remember it for highlighting later.\n+        // The macros that accept a format string expand to a compiler builtin macros\n+        // `format_args` and `format_args_nl`.\n+        if let Some(name) = parent\n+            .parent()\n+            .and_then(ast::MacroCall::cast)\n+            .and_then(|mc| mc.path())\n+            .and_then(|p| p.segment())\n+            .and_then(|s| s.name_ref())\n+        {\n+            match name.text().as_str() {\n+                \"format_args\" | \"format_args_nl\" => {\n+                    self.format_string = parent\n+                        .children_with_tokens()\n+                        .filter(|t| t.kind() != SyntaxKind::WHITESPACE)\n+                        .nth(1)\n+                        .filter(|e| {\n+                            ast::String::can_cast(e.kind()) || ast::RawString::can_cast(e.kind())\n+                        })\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+    pub(super) fn highlight_format_string(\n+        &self,\n+        range_stack: &mut HighlightedRangeStack,\n+        string: &impl HasFormatSpecifier,\n+        range: TextRange,\n+    ) {\n+        if self.format_string.as_ref() == Some(&SyntaxElement::from(string.syntax().clone())) {\n+            range_stack.push();\n+            string.lex_format_specifier(|piece_range, kind| {\n+                if let Some(highlight) = highlight_format_specifier(kind) {\n+                    range_stack.add(HighlightedRange {\n+                        range: piece_range + range.start(),\n+                        highlight: highlight.into(),\n+                        binding_hash: None,\n+                    });\n+                }\n+            });\n+            range_stack.pop();\n+        }\n+    }\n+}\n+\n+fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n+    Some(match kind {\n+        FormatSpecifier::Open\n+        | FormatSpecifier::Close\n+        | FormatSpecifier::Colon\n+        | FormatSpecifier::Fill\n+        | FormatSpecifier::Align\n+        | FormatSpecifier::Sign\n+        | FormatSpecifier::NumberSign\n+        | FormatSpecifier::DollarSign\n+        | FormatSpecifier::Dot\n+        | FormatSpecifier::Asterisk\n+        | FormatSpecifier::QuestionMark => HighlightTag::FormatSpecifier,\n+        FormatSpecifier::Integer | FormatSpecifier::Zero => HighlightTag::NumericLiteral,\n+        FormatSpecifier::Identifier => HighlightTag::Local,\n+    })\n+}"}]}