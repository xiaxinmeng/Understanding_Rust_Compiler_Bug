{"sha": "828289610bece3d2208d34147ae2a419a9c524c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyODI4OTYxMGJlY2UzZDIyMDhkMzQxNDdhZTJhNDE5YTljNTI0YzQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-09-16T21:04:11Z"}, "committer": {"name": "Jorge Aparicio", "email": "jorge@japaric.io", "date": "2018-09-16T21:04:11Z"}, "message": "remove (more) CAS API from Atomic* types where not natively supported\n\ncloses #54276", "tree": {"sha": "ac91cc744b2a9f565b21057f04d59dc4f69c15b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac91cc744b2a9f565b21057f04d59dc4f69c15b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/828289610bece3d2208d34147ae2a419a9c524c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/828289610bece3d2208d34147ae2a419a9c524c4", "html_url": "https://github.com/rust-lang/rust/commit/828289610bece3d2208d34147ae2a419a9c524c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/828289610bece3d2208d34147ae2a419a9c524c4/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3cba9b4b4959d63eaaf5ffd647e4a5fc6d43e17", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3cba9b4b4959d63eaaf5ffd647e4a5fc6d43e17", "html_url": "https://github.com/rust-lang/rust/commit/d3cba9b4b4959d63eaaf5ffd647e4a5fc6d43e17"}], "stats": {"total": 23, "additions": 23, "deletions": 0}, "files": [{"sha": "69c524925fc546e9d82f9f1a9aab80cba7e504bc", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/828289610bece3d2208d34147ae2a419a9c524c4/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/828289610bece3d2208d34147ae2a419a9c524c4/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=828289610bece3d2208d34147ae2a419a9c524c4", "patch": "@@ -558,6 +558,7 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: bool,\n                                  new: bool,\n@@ -1041,6 +1042,7 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\")]\n+    #[cfg(target_has_atomic = \"cas\")]\n     pub fn compare_exchange_weak(&self,\n                                  current: *mut T,\n                                  new: *mut T,\n@@ -1434,6 +1436,7 @@ loop {\n ```\"),\n                 #[inline]\n                 #[$stable_cxchg]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn compare_exchange_weak(&self,\n                                              current: $int_type,\n                                              new: $int_type,\n@@ -1471,6 +1474,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n@@ -1502,6 +1506,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n@@ -1536,6 +1541,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n@@ -1571,6 +1577,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n ```\"),\n                 #[inline]\n                 #[$stable_nand]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n@@ -1605,6 +1612,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n@@ -1639,6 +1647,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n ```\"),\n                 #[inline]\n                 #[$stable]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n@@ -1688,6 +1697,7 @@ assert_eq!(x.load(Ordering::SeqCst), 9);\n                 #[unstable(feature = \"no_more_cas\",\n                        reason = \"no more CAS loops in user code\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_update<F>(&self,\n                                        mut f: F,\n                                        fetch_order: Ordering,\n@@ -1748,6 +1758,7 @@ assert!(max_foo == 42);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n@@ -1799,6 +1810,7 @@ assert_eq!(min_foo, 12);\n                 #[unstable(feature = \"atomic_min_max\",\n                        reason = \"easier and faster min/max than writing manual CAS loop\",\n                        issue = \"48655\")]\n+                #[cfg(target_has_atomic = \"cas\")]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n@@ -1987,6 +1999,7 @@ unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xadd_acq(dst, val),\n@@ -1999,6 +2012,7 @@ unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xsub_acq(dst, val),\n@@ -2035,6 +2049,7 @@ unsafe fn atomic_compare_exchange<T>(dst: *mut T,\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n                                           old: T,\n                                           new: T,\n@@ -2059,6 +2074,7 @@ unsafe fn atomic_compare_exchange_weak<T>(dst: *mut T,\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_and_acq(dst, val),\n@@ -2070,6 +2086,7 @@ unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_nand_acq(dst, val),\n@@ -2081,6 +2098,7 @@ unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_or_acq(dst, val),\n@@ -2092,6 +2110,7 @@ unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_xor_acq(dst, val),\n@@ -2104,6 +2123,7 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_max_acq(dst, val),\n@@ -2116,6 +2136,7 @@ unsafe fn atomic_max<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_min_acq(dst, val),\n@@ -2128,6 +2149,7 @@ unsafe fn atomic_min<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umax_acq(dst, val),\n@@ -2140,6 +2162,7 @@ unsafe fn atomic_umax<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n+#[cfg(target_has_atomic = \"cas\")]\n unsafe fn atomic_umin<T>(dst: *mut T, val: T, order: Ordering) -> T {\n     match order {\n         Acquire => intrinsics::atomic_umin_acq(dst, val),"}]}