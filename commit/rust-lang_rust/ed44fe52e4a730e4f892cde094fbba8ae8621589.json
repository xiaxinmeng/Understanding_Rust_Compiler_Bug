{"sha": "ed44fe52e4a730e4f892cde094fbba8ae8621589", "node_id": "C_kwDOAAsO6NoAKGVkNDRmZTUyZTRhNzMwZTRmODkyY2RlMDk0ZmJiYThhZTg2MjE1ODk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-01T14:46:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-01T14:46:48Z"}, "message": "Auto merge of #12668 - Veykril:mac-source-map, r=Veykril\n\nfix: Simplify macro statement expansion handling\n\nI only meant to fix https://github.com/rust-lang/rust-analyzer/issues/12644 but that somehow turned into a rewrite of the statement handling ... at least this fixes a few more issues in the IDE layer now", "tree": {"sha": "dbb4b5bcc25566c0f16905c9364574cea86aed21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbb4b5bcc25566c0f16905c9364574cea86aed21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed44fe52e4a730e4f892cde094fbba8ae8621589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed44fe52e4a730e4f892cde094fbba8ae8621589", "html_url": "https://github.com/rust-lang/rust/commit/ed44fe52e4a730e4f892cde094fbba8ae8621589", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed44fe52e4a730e4f892cde094fbba8ae8621589/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8489cd7c7be501fe78069095ce180876324f7197", "url": "https://api.github.com/repos/rust-lang/rust/commits/8489cd7c7be501fe78069095ce180876324f7197", "html_url": "https://github.com/rust-lang/rust/commit/8489cd7c7be501fe78069095ce180876324f7197"}, {"sha": "e5e5a0932dbdfa5de7b6cdae10a76378ff041cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e5a0932dbdfa5de7b6cdae10a76378ff041cf2", "html_url": "https://github.com/rust-lang/rust/commit/e5e5a0932dbdfa5de7b6cdae10a76378ff041cf2"}], "stats": {"total": 349, "additions": 221, "deletions": 128}, "files": [{"sha": "94210ab33fb69bd7d500c4b07db30b38840fb99e", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -19,7 +19,6 @@ use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use smallvec::SmallVec;\n use syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n \n use crate::{\n@@ -294,10 +293,6 @@ pub struct BodySourceMap {\n     field_map: FxHashMap<InFile<AstPtr<ast::RecordExprField>>, ExprId>,\n     field_map_back: FxHashMap<ExprId, InFile<AstPtr<ast::RecordExprField>>>,\n \n-    /// Maps a macro call to its lowered expressions, a single one if it expands to an expression,\n-    /// or multiple if it expands to MacroStmts.\n-    macro_call_to_exprs: FxHashMap<InFile<AstPtr<ast::MacroCall>>, SmallVec<[ExprId; 1]>>,\n-\n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n \n     /// Diagnostics accumulated during body lowering. These contain `AstPtr`s and so are stored in\n@@ -466,9 +461,9 @@ impl BodySourceMap {\n         self.field_map.get(&src).cloned()\n     }\n \n-    pub fn macro_expansion_expr(&self, node: InFile<&ast::MacroCall>) -> Option<&[ExprId]> {\n-        let src = node.map(AstPtr::new);\n-        self.macro_call_to_exprs.get(&src).map(|it| &**it)\n+    pub fn macro_expansion_expr(&self, node: InFile<&ast::MacroExpr>) -> Option<ExprId> {\n+        let src = node.map(AstPtr::new).map(AstPtr::upcast::<ast::MacroExpr>).map(AstPtr::upcast);\n+        self.expr_map.get(&src).copied()\n     }\n \n     /// Get a reference to the body source map's diagnostics."}, {"sha": "049afa82279d13d671f866c57f0bb0e88b124102", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 72, "deletions": 82, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -13,7 +13,6 @@ use hir_expand::{\n use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use smallvec::smallvec;\n use syntax::{\n     ast::{\n         self, ArrayExprKind, AstChildren, HasArgList, HasLoopBody, HasName, LiteralKind,\n@@ -97,7 +96,6 @@ pub(super) fn lower(\n             or_pats: Default::default(),\n         },\n         expander,\n-        statements_in_scope: Vec::new(),\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n     }\n@@ -109,7 +107,6 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     body: Body,\n     source_map: BodySourceMap,\n-    statements_in_scope: Vec<Statement>,\n     // a poor-mans union-find?\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n@@ -514,27 +511,25 @@ impl ExprCollector<'_> {\n             ast::Expr::MacroExpr(e) => {\n                 let e = e.macro_call()?;\n                 let macro_ptr = AstPtr::new(&e);\n-                let id = self.collect_macro_call(e, macro_ptr.clone(), true, |this, expansion| {\n+                let id = self.collect_macro_call(e, macro_ptr, true, |this, expansion| {\n                     expansion.map(|it| this.collect_expr(it))\n                 });\n                 match id {\n                     Some(id) => {\n-                        self.source_map\n-                            .macro_call_to_exprs\n-                            .insert(self.expander.to_source(macro_ptr), smallvec![id]);\n+                        // Make the macro-call point to its expanded expression so we can query\n+                        // semantics on syntax pointers to the macro\n+                        let src = self.expander.to_source(syntax_ptr);\n+                        self.source_map.expr_map.insert(src, id);\n                         id\n                     }\n-                    None => self.alloc_expr(Expr::Missing, syntax_ptr.clone()),\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n             ast::Expr::MacroStmts(e) => {\n-                e.statements().for_each(|s| self.collect_stmt(s));\n-                let tail = e\n-                    .expr()\n-                    .map(|e| self.collect_expr(e))\n-                    .unwrap_or_else(|| self.alloc_expr(Expr::Missing, syntax_ptr.clone()));\n+                let statements = e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+                let tail = e.expr().map(|e| self.collect_expr(e));\n \n-                self.alloc_expr(Expr::MacroStmts { tail }, syntax_ptr)\n+                self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n             }\n             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n         })\n@@ -607,11 +602,11 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) {\n+    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Statement> {\n         match s {\n             ast::Stmt::LetStmt(stmt) => {\n                 if self.check_cfg(&stmt).is_none() {\n-                    return;\n+                    return None;\n                 }\n                 let pat = self.collect_pat_opt(stmt.pat());\n                 let type_ref =\n@@ -621,70 +616,61 @@ impl ExprCollector<'_> {\n                     .let_else()\n                     .and_then(|let_else| let_else.block_expr())\n                     .map(|block| self.collect_block(block));\n-                self.statements_in_scope.push(Statement::Let {\n-                    pat,\n-                    type_ref,\n-                    initializer,\n-                    else_branch,\n-                });\n+                Some(Statement::Let { pat, type_ref, initializer, else_branch })\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n-                if let Some(expr) = stmt.expr() {\n-                    if self.check_cfg(&expr).is_none() {\n-                        return;\n+                let expr = stmt.expr();\n+                if let Some(expr) = &expr {\n+                    if self.check_cfg(expr).is_none() {\n+                        return None;\n                     }\n                 }\n                 let has_semi = stmt.semicolon_token().is_some();\n-                // Note that macro could be expended to multiple statements\n-                if let Some(ast::Expr::MacroExpr(e)) = stmt.expr() {\n-                    let m = match e.macro_call() {\n-                        Some(it) => it,\n-                        None => return,\n-                    };\n-                    let macro_ptr = AstPtr::new(&m);\n-                    let syntax_ptr = AstPtr::new(&stmt.expr().unwrap());\n-\n-                    let prev_stmt = self.statements_in_scope.len();\n-                    self.collect_macro_call(m, macro_ptr.clone(), false, |this, expansion| {\n-                        match expansion {\n+                // Note that macro could be expanded to multiple statements\n+                if let Some(expr @ ast::Expr::MacroExpr(mac)) = &expr {\n+                    let mac_call = mac.macro_call()?;\n+                    let syntax_ptr = AstPtr::new(expr);\n+                    let macro_ptr = AstPtr::new(&mac_call);\n+                    let stmt = self.collect_macro_call(\n+                        mac_call,\n+                        macro_ptr,\n+                        false,\n+                        |this, expansion: Option<ast::MacroStmts>| match expansion {\n                             Some(expansion) => {\n-                                let statements: ast::MacroStmts = expansion;\n-\n-                                statements.statements().for_each(|stmt| this.collect_stmt(stmt));\n-                                if let Some(expr) = statements.expr() {\n-                                    let expr = this.collect_expr(expr);\n-                                    this.statements_in_scope\n-                                        .push(Statement::Expr { expr, has_semi });\n-                                }\n+                                let statements = expansion\n+                                    .statements()\n+                                    .filter_map(|stmt| this.collect_stmt(stmt))\n+                                    .collect();\n+                                let tail = expansion.expr().map(|expr| this.collect_expr(expr));\n+\n+                                let mac_stmts = this.alloc_expr(\n+                                    Expr::MacroStmts { tail, statements },\n+                                    AstPtr::new(&ast::Expr::MacroStmts(expansion)),\n+                                );\n+\n+                                Some(mac_stmts)\n                             }\n-                            None => {\n-                                let expr = this.alloc_expr(Expr::Missing, syntax_ptr.clone());\n-                                this.statements_in_scope.push(Statement::Expr { expr, has_semi });\n-                            }\n-                        }\n-                    });\n+                            None => None,\n+                        },\n+                    );\n \n-                    let mut macro_exprs = smallvec![];\n-                    for stmt in &self.statements_in_scope[prev_stmt..] {\n-                        match *stmt {\n-                            Statement::Let { initializer, else_branch, .. } => {\n-                                macro_exprs.extend(initializer);\n-                                macro_exprs.extend(else_branch);\n-                            }\n-                            Statement::Expr { expr, .. } => macro_exprs.push(expr),\n+                    let expr = match stmt {\n+                        Some(expr) => {\n+                            // Make the macro-call point to its expanded expression so we can query\n+                            // semantics on syntax pointers to the macro\n+                            let src = self.expander.to_source(syntax_ptr);\n+                            self.source_map.expr_map.insert(src, expr);\n+                            expr\n                         }\n-                    }\n-                    if !macro_exprs.is_empty() {\n-                        self.source_map\n-                            .macro_call_to_exprs\n-                            .insert(self.expander.to_source(macro_ptr), macro_exprs);\n-                    }\n+                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n+                    };\n+                    Some(Statement::Expr { expr, has_semi })\n                 } else {\n-                    let expr = self.collect_expr_opt(stmt.expr());\n-                    self.statements_in_scope.push(Statement::Expr { expr, has_semi });\n+                    let expr = self.collect_expr_opt(expr);\n+                    Some(Statement::Expr { expr, has_semi })\n                 }\n             }\n-            ast::Stmt::Item(_item) => {}\n+            ast::Stmt::Item(_item) => None,\n         }\n     }\n \n@@ -703,25 +689,27 @@ impl ExprCollector<'_> {\n         };\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n-        let prev_statements = std::mem::take(&mut self.statements_in_scope);\n \n-        block.statements().for_each(|s| self.collect_stmt(s));\n-        block.tail_expr().and_then(|e| {\n-            let expr = self.maybe_collect_expr(e)?;\n-            self.statements_in_scope.push(Statement::Expr { expr, has_semi: false });\n-            Some(())\n+        let mut statements: Vec<_> =\n+            block.statements().filter_map(|s| self.collect_stmt(s)).collect();\n+        let tail = block.tail_expr().and_then(|e| self.maybe_collect_expr(e));\n+        let tail = tail.or_else(|| {\n+            let stmt = statements.pop()?;\n+            if let Statement::Expr { expr, has_semi: false } = stmt {\n+                return Some(expr);\n+            }\n+            statements.push(stmt);\n+            None\n         });\n \n-        let mut tail = None;\n-        if let Some(Statement::Expr { expr, has_semi: false }) = self.statements_in_scope.last() {\n-            tail = Some(*expr);\n-            self.statements_in_scope.pop();\n-        }\n-        let tail = tail;\n-        let statements = std::mem::replace(&mut self.statements_in_scope, prev_statements).into();\n         let syntax_node_ptr = AstPtr::new(&block.into());\n         let expr_id = self.alloc_expr(\n-            Expr::Block { id: block_id, statements, tail, label: None },\n+            Expr::Block {\n+                id: block_id,\n+                statements: statements.into_boxed_slice(),\n+                tail,\n+                label: None,\n+            },\n             syntax_node_ptr,\n         );\n \n@@ -903,10 +891,12 @@ impl ExprCollector<'_> {\n             ast::Pat::MacroPat(mac) => match mac.macro_call() {\n                 Some(call) => {\n                     let macro_ptr = AstPtr::new(&call);\n+                    let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n                             this.collect_pat_opt_(expanded_pat)\n                         });\n+                    self.source_map.pat_map.insert(src, pat);\n                     return pat;\n                 }\n                 None => Pat::Missing,"}, {"sha": "f4c390dce26e0520168594430508281406137c3f", "filename": "crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -145,27 +145,28 @@ fn compute_block_scopes(\n     tail: Option<ExprId>,\n     body: &Body,\n     scopes: &mut ExprScopes,\n-    mut scope: ScopeId,\n+    scope: &mut ScopeId,\n ) {\n     for stmt in statements {\n         match stmt {\n             Statement::Let { pat, initializer, else_branch, .. } => {\n                 if let Some(expr) = initializer {\n-                    compute_expr_scopes(*expr, body, scopes, &mut scope);\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n                 }\n                 if let Some(expr) = else_branch {\n-                    compute_expr_scopes(*expr, body, scopes, &mut scope);\n+                    compute_expr_scopes(*expr, body, scopes, scope);\n                 }\n-                scope = scopes.new_scope(scope);\n-                scopes.add_bindings(body, scope, *pat);\n+\n+                *scope = scopes.new_scope(*scope);\n+                scopes.add_bindings(body, *scope, *pat);\n             }\n             Statement::Expr { expr, .. } => {\n-                compute_expr_scopes(*expr, body, scopes, &mut scope);\n+                compute_expr_scopes(*expr, body, scopes, scope);\n             }\n         }\n     }\n     if let Some(expr) = tail {\n-        compute_expr_scopes(expr, body, scopes, &mut scope);\n+        compute_expr_scopes(expr, body, scopes, scope);\n     }\n }\n \n@@ -175,12 +176,15 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n     scopes.set_scope(expr, *scope);\n     match &body[expr] {\n+        Expr::MacroStmts { statements, tail } => {\n+            compute_block_scopes(statements, *tail, body, scopes, scope);\n+        }\n         Expr::Block { statements, tail, id, label } => {\n-            let scope = scopes.new_block_scope(*scope, *id, make_label(label));\n+            let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));\n             // Overwrite the old scope for the block expr, so that every block scope can be found\n             // via the block itself (important for blocks that only contain items, no expressions).\n             scopes.set_scope(expr, scope);\n-            compute_block_scopes(statements, *tail, body, scopes, scope);\n+            compute_block_scopes(statements, *tail, body, scopes, &mut scope);\n         }\n         Expr::For { iterable, pat, body: body_expr, label } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);"}, {"sha": "4295bacc4668e490a185a70c9b9988728dd7166a", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -199,7 +199,8 @@ pub enum Expr {\n         body: ExprId,\n     },\n     MacroStmts {\n-        tail: ExprId,\n+        statements: Box<[Statement]>,\n+        tail: Option<ExprId>,\n     },\n     Array(Array),\n     Literal(Literal),\n@@ -254,7 +255,7 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::Block { statements, tail, .. } => {\n+            Expr::MacroStmts { tail, statements } | Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {\n@@ -344,7 +345,6 @@ impl Expr {\n                     f(*repeat)\n                 }\n             },\n-            Expr::MacroStmts { tail } => f(*tail),\n             Expr::Literal(_) => {}\n             Expr::Underscore => {}\n         }"}, {"sha": "defceefc79fae5a02d1835a994ed98bb07f373cc", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -774,7 +774,9 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_float_var(),\n                 },\n             },\n-            Expr::MacroStmts { tail } => self.infer_expr_inner(*tail, expected),\n+            Expr::MacroStmts { tail, statements } => {\n+                self.infer_block(tgt_expr, statements, *tail, expected)\n+            }\n             Expr::Underscore => {\n                 // Underscore expressions may only appear in assignee expressions,\n                 // which are handled by `infer_assignee_expr()`, so any underscore"}, {"sha": "a4299d9f0500e50406a65ed7443e0fdea96f855f", "filename": "crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 38, "deletions": 8, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -1,6 +1,8 @@\n use expect_test::expect;\n use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n+use crate::tests::check_infer_with_mismatches;\n+\n use super::{check_infer, check_types};\n \n #[test]\n@@ -191,6 +193,8 @@ fn expr_macro_def_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n             39..442 '{     ...!(); }': ()\n             73..94 'spam!(...am!())': {unknown}\n             100..119 'for _ ...!() {}': ()\n@@ -272,6 +276,8 @@ fn expr_macro_rules_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n+            !0..6 '1isize': isize\n             53..456 '{     ...!(); }': ()\n             87..108 'spam!(...am!())': {unknown}\n             114..133 'for _ ...!() {}': ()\n@@ -306,7 +312,6 @@ fn expr_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..8 'leta=();': ()\n             !0..8 'leta=();': ()\n             !3..4 'a': ()\n             !5..7 '()': ()\n@@ -335,11 +340,11 @@ fn recurisve_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..7 'leta=3;': {unknown}\n-            !0..7 'leta=3;': {unknown}\n-            !0..13 'ng!{[leta=3]}': {unknown}\n-            !0..13 'ng!{[leta=]3}': {unknown}\n-            !0..13 'ng!{[leta]=3}': {unknown}\n+            !0..7 'leta=3;': ()\n+            !0..13 'ng!{[leta=3]}': ()\n+            !0..13 'ng!{[leta=]3}': ()\n+            !0..13 'ng!{[leta]=3}': ()\n+            !0..13 'ng!{[let]a=3}': ()\n             !3..4 'a': i32\n             !5..6 '3': i32\n             196..237 '{     ...= a; }': ()\n@@ -364,8 +369,8 @@ fn recursive_inner_item_macro_rules() {\n         \"#,\n         expect![[r#\"\n             !0..1 '1': i32\n-            !0..26 'macro_...>{1};}': {unknown}\n-            !0..26 'macro_...>{1};}': {unknown}\n+            !0..7 'mac!($)': ()\n+            !0..26 'macro_...>{1};}': ()\n             107..143 '{     ...!(); }': ()\n             129..130 'a': i32\n         \"#]],\n@@ -1244,3 +1249,28 @@ fn infinitely_recursive_macro_type() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn cfg_tails() {\n+    check_infer_with_mismatches(\n+        r#\"\n+//- /lib.rs crate:foo cfg:feature=foo\n+struct S {}\n+\n+impl S {\n+    fn new2(bar: u32) -> Self {\n+        #[cfg(feature = \"foo\")]\n+        { Self { } }\n+        #[cfg(not(feature = \"foo\"))]\n+        { Self { } }\n+    }\n+}\n+\"#,\n+        expect![[r#\"\n+            34..37 'bar': u32\n+            52..170 '{     ...     }': S\n+            62..106 '#[cfg(... { } }': S\n+            96..104 'Self { }': S\n+        \"#]],\n+    );\n+}"}, {"sha": "ee0a631a1bc734663f94488294ef5cb03c2959bf", "filename": "crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -573,6 +573,7 @@ fn issue_6811() {\n         }\n         \"#,\n         expect![[r#\"\n+            !0..16 'let_a=...t_b=1;': ()\n             !3..5 '_a': i32\n             !6..7 '1': i32\n             !11..13 '_b': i32"}, {"sha": "ef17f2a75e1d23a197cf7d57e00139b4425547b2", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -2223,6 +2223,7 @@ impl Local {\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db.upcast());\n         src.map(|ast| match ast {\n+            // Suspicious unwrap\n             Either::Left(it) => Either::Left(it.cast().unwrap().to_node(&root)),\n             Either::Right(it) => Either::Right(it.to_node(&root)),\n         })"}, {"sha": "2298a75d57ff0b8d11b26534386969ec6453929b", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -539,24 +539,26 @@ impl SourceAnalyzer {\n                 _ => (),\n             }\n         }\n+        let macro_expr = match macro_call\n+            .map(|it| it.syntax().parent().and_then(ast::MacroExpr::cast))\n+            .transpose()\n+        {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+\n         if let (Some((def, body, sm)), Some(infer)) = (&self.def, &self.infer) {\n-            if let Some(expr_ids) = sm.macro_expansion_expr(macro_call) {\n+            if let Some(expanded_expr) = sm.macro_expansion_expr(macro_expr.as_ref()) {\n                 let mut is_unsafe = false;\n-                for &expr_id in expr_ids {\n-                    unsafe_expressions(\n-                        db,\n-                        infer,\n-                        *def,\n-                        body,\n-                        expr_id,\n-                        &mut |UnsafeExpr { inside_unsafe_block, .. }| {\n-                            is_unsafe |= !inside_unsafe_block\n-                        },\n-                    );\n-                    if is_unsafe {\n-                        return true;\n-                    }\n-                }\n+                unsafe_expressions(\n+                    db,\n+                    infer,\n+                    *def,\n+                    body,\n+                    expanded_expr,\n+                    &mut |UnsafeExpr { inside_unsafe_block, .. }| is_unsafe |= !inside_unsafe_block,\n+                );\n+                return is_unsafe;\n             }\n         }\n         false"}, {"sha": "96d0219fef6fa3d122d8b2b0dd651dc828235264", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -810,3 +810,33 @@ fn main() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn regression_12644() {\n+    check(\n+        r#\"\n+macro_rules! __rust_force_expr {\n+    ($e:expr) => {\n+        $e\n+    };\n+}\n+macro_rules! vec {\n+    ($elem:expr) => {\n+        __rust_force_expr!($elem)\n+    };\n+}\n+\n+struct Struct;\n+impl Struct {\n+    fn foo(self) {}\n+}\n+\n+fn f() {\n+    vec![Struct].$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(self)\n+        \"#]],\n+    );\n+}"}, {"sha": "7c0a7fa1e7243a5b2e7a2654a40ff8caf8cc60f3", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -689,7 +689,7 @@ fn foo() ->$0 u32 {\n     never();\n  // ^^^^^^^\n     never!();\n- // FIXME sema doesn't give us types for macrocalls\n+ // ^^^^^^^^\n \n     Never.never();\n  // ^^^^^^^^^^^^^"}, {"sha": "a1484fa19fcde1ffe5a97c73eaf83daced7e3a72", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -4920,3 +4920,34 @@ impl T for () {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn hover_ranged_macro_call() {\n+    check_hover_range(\n+        r#\"\n+macro_rules! __rust_force_expr {\n+    ($e:expr) => {\n+        $e\n+    };\n+}\n+macro_rules! vec {\n+    ($elem:expr) => {\n+        __rust_force_expr!($elem)\n+    };\n+}\n+\n+struct Struct;\n+impl Struct {\n+    fn foo(self) {}\n+}\n+\n+fn f() {\n+    $0vec![Struct]$0;\n+}\n+\"#,\n+        expect![[r#\"\n+            ```rust\n+            Struct\n+            ```\"#]],\n+    );\n+}"}, {"sha": "bd96e35cc6e5d31cc201c6e8398e86802272696d", "filename": "crates/syntax/src/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fsyntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed44fe52e4a730e4f892cde094fbba8ae8621589/crates%2Fsyntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fptr.rs?ref=ed44fe52e4a730e4f892cde094fbba8ae8621589", "patch": "@@ -67,6 +67,13 @@ impl<N: AstNode> AstPtr<N> {\n         Some(AstPtr { raw: self.raw, _ty: PhantomData })\n     }\n \n+    pub fn upcast<M: AstNode>(self) -> AstPtr<M>\n+    where\n+        N: Into<M>,\n+    {\n+        AstPtr { raw: self.raw, _ty: PhantomData }\n+    }\n+\n     /// Like `SyntaxNodePtr::cast` but the trait bounds work out.\n     pub fn try_from_raw(raw: SyntaxNodePtr) -> Option<AstPtr<N>> {\n         N::can_cast(raw.kind()).then(|| AstPtr { raw, _ty: PhantomData })"}]}