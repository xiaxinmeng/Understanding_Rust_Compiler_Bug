{"sha": "44386d5373114ffc88ef6bd182fb3b58a7c27e69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0Mzg2ZDUzNzMxMTRmZmM4OGVmNmJkMTgyZmIzYjU4YTdjMjdlNjk=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-08-21T21:34:50Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2019-08-26T19:44:50Z"}, "message": "An attempt to add the coercion logic for Never", "tree": {"sha": "19a1d277377ecf2ea9c5ca9232f019d20b53137d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19a1d277377ecf2ea9c5ca9232f019d20b53137d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44386d5373114ffc88ef6bd182fb3b58a7c27e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44386d5373114ffc88ef6bd182fb3b58a7c27e69", "html_url": "https://github.com/rust-lang/rust/commit/44386d5373114ffc88ef6bd182fb3b58a7c27e69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44386d5373114ffc88ef6bd182fb3b58a7c27e69/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0", "html_url": "https://github.com/rust-lang/rust/commit/89f3cc587d07a3cdcebf84cc4b99fe42636e66f0"}], "stats": {"total": 149, "additions": 98, "deletions": 51}, "files": [{"sha": "074baa8ef441c9a8100a198aaa8aaaf06b3472c5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/44386d5373114ffc88ef6bd182fb3b58a7c27e69/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44386d5373114ffc88ef6bd182fb3b58a7c27e69/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=44386d5373114ffc88ef6bd182fb3b58a7c27e69", "patch": "@@ -296,9 +296,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             | (Ty::Infer(InferTy::IntVar(tv)), other)\n             | (other, Ty::Infer(InferTy::IntVar(tv)))\n             | (Ty::Infer(InferTy::FloatVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::FloatVar(tv)))\n-                if !is_never(other) =>\n-            {\n+            | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n                 // the type var is unknown since we tried to resolve it\n                 self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n                 true\n@@ -977,27 +975,56 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         ret_ty\n     }\n \n+    fn coerce(&mut self, tgt_expr: ExprId, ty1: Ty, ty2: Ty) -> Ty {\n+        if is_never(&ty1) {\n+            ty2\n+        } else {\n+            self.unify(&ty1, &ty2);\n+            // TODO Fugly and looks like we need more, `infer_adt_pattern` and other fails\n+            let ty = self.resolve_ty_as_possible(&mut vec![], ty1);\n+            self.write_expr_ty(tgt_expr, ty.clone());\n+            ty\n+        }\n+    }\n+\n     fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n+        let ty = self.infer_expr_inner(tgt_expr, expected);\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        let could_unify = self.unify(&ty, &expected.ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        self.write_expr_ty(tgt_expr, ty.clone());\n+        if !could_unify {\n+            self.result.type_mismatches.insert(\n+                tgt_expr,\n+                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n+            );\n+        }\n+        ty\n+    }\n+\n+    fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        let ty = match &body[tgt_expr] {\n+        match &body[tgt_expr] {\n             Expr::Missing => Ty::Unknown,\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n \n-                let mut branch_tys = Vec::with_capacity(2);\n-                let then_ty = self.infer_expr(*then_branch, &expected);\n+                let then_ty = self.infer_expr_inner(*then_branch, &expected);\n+                self.coerce(*then_branch, then_ty.clone(), expected.ty.clone());\n                 match else_branch {\n                     Some(else_branch) => {\n-                        branch_tys.push(self.infer_expr(*else_branch, &expected));\n+                        let else_ty = self.infer_expr_inner(*else_branch, &expected);\n+                        self.coerce(*else_branch, else_ty, expected.ty.clone());\n                     }\n                     None => {\n                         // no else branch -> unit\n                         self.unify(&then_ty, &Ty::unit()); // actually coerce\n                     }\n                 };\n-                branch_tys.push(then_ty);\n-                calculate_least_upper_bound(expected.ty.clone(), branch_tys)\n+\n+                expected.ty.clone()\n             }\n             Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n             Expr::TryBlock { body } => {\n@@ -1084,8 +1111,6 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     expected.clone()\n                 };\n \n-                let mut arm_tys = Vec::with_capacity(arms.len());\n-\n                 for arm in arms {\n                     for &pat in &arm.pats {\n                         let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::default());\n@@ -1096,9 +1121,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                             &Expectation::has_type(Ty::simple(TypeCtor::Bool)),\n                         );\n                     }\n-                    arm_tys.push(self.infer_expr(arm.expr, &expected));\n+                    let match_arm_ty = self.infer_expr_inner(arm.expr, &expected);\n+                    self.coerce(arm.expr, match_arm_ty, expected.ty.clone());\n                 }\n-                calculate_least_upper_bound(expected.ty.clone(), arm_tys)\n+\n+                expected.ty\n             }\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n@@ -1358,19 +1385,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Literal::Int(_v, ty) => Ty::simple(TypeCtor::Int(*ty)),\n                 Literal::Float(_v, ty) => Ty::simple(TypeCtor::Float(*ty)),\n             },\n-        };\n-        // use a new type variable if we got Ty::Unknown here\n-        let ty = self.insert_type_vars_shallow(ty);\n-        let could_unify = self.unify(&ty, &expected.ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        self.write_expr_ty(tgt_expr, ty.clone());\n-        if !could_unify {\n-            self.result.type_mismatches.insert(\n-                tgt_expr,\n-                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n-            );\n         }\n-        ty\n     }\n \n     fn infer_block(\n@@ -1629,29 +1644,3 @@ fn is_never(ty: &Ty) -> bool {\n         false\n     }\n }\n-\n-fn calculate_least_upper_bound(expected_ty: Ty, actual_tys: Vec<Ty>) -> Ty {\n-    let mut all_never = true;\n-    let mut last_never_ty = None;\n-    let mut least_upper_bound = expected_ty;\n-\n-    for actual_ty in actual_tys {\n-        if is_never(&actual_ty) {\n-            last_never_ty = Some(actual_ty);\n-        } else {\n-            all_never = false;\n-            least_upper_bound = match (&actual_ty, &least_upper_bound) {\n-                (_, Ty::Unknown)\n-                | (Ty::Infer(_), Ty::Infer(InferTy::TypeVar(_)))\n-                | (Ty::Apply(_), _) => actual_ty,\n-                _ => least_upper_bound,\n-            }\n-        }\n-    }\n-\n-    if all_never && last_never_ty.is_some() {\n-        last_never_ty.unwrap()\n-    } else {\n-        least_upper_bound\n-    }\n-}"}, {"sha": "4fa9d131dffc7605d842c0bf19e2bc54ef1e9189", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/44386d5373114ffc88ef6bd182fb3b58a7c27e69/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44386d5373114ffc88ef6bd182fb3b58a7c27e69/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=44386d5373114ffc88ef6bd182fb3b58a7c27e69", "patch": "@@ -3618,6 +3618,26 @@ fn test(a: i32) {\n         assert_eq!(t, \"f64\");\n     }\n \n+    #[test]\n+    fn match_second_block_arm_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => { 3.0 },\n+        2 => { loop {} },\n+        3 => { 3.0 },\n+        _ => { return },\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+\n     #[test]\n     fn if_never() {\n         let t = type_at(\n@@ -3656,6 +3676,26 @@ fn test(input: bool) {\n         assert_eq!(t, \"f64\");\n     }\n \n+    #[test]\n+    fn match_first_block_arm_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        1 => { return },\n+        2 => { 2.0 },\n+        3 => { loop {} },\n+        _ => { 3.0 },\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"f64\");\n+    }\n+\n     #[test]\n     fn match_second_arm_never() {\n         let t = type_at(\n@@ -3694,6 +3734,24 @@ fn test(a: i32) {\n         assert_eq!(t, \"!\");\n     }\n \n+    #[test]\n+    fn match_all_block_arms_never() {\n+        let t = type_at(\n+            r#\"\n+//- /main.rs\n+fn test(a: i32) {\n+    let i = match a {\n+        2 => { return },\n+        _ => { loop {} },\n+    };\n+    i<|>\n+    ()\n+}\n+\"#,\n+        );\n+        assert_eq!(t, \"!\");\n+    }\n+\n     #[test]\n     fn match_no_never_arms() {\n         let t = type_at("}]}