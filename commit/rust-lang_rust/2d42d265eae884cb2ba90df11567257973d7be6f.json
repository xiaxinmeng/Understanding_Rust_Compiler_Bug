{"sha": "2d42d265eae884cb2ba90df11567257973d7be6f", "node_id": "C_kwDOAAsO6NoAKDJkNDJkMjY1ZWFlODg0Y2IyYmE5MGRmMTE1NjcyNTc5NzNkN2JlNmY", "commit": {"author": {"name": "Vanille-N", "email": "neven.villani@crans.org", "date": "2022-12-02T12:23:37Z"}, "committer": {"name": "Vanille-N", "email": "neven.villani@crans.org", "date": "2022-12-02T12:23:37Z"}, "message": "extract common borrow tracking logic", "tree": {"sha": "71fc60d24b1565bac15398e634e30a93745638f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71fc60d24b1565bac15398e634e30a93745638f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d42d265eae884cb2ba90df11567257973d7be6f", "comment_count": 0, "verification": {"verified": false, "reason": "invalid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCAAdFiEE1bhy5AfUOHIeWIegAOdl+n9PLt4FAmOJ7lMACgkQAOdl+n9P\nLt7+1Qv+IBSETWgID19JeTptRODW/UnvqtZZ41y41BQr9U+50bqJiTi2jfOIivRp\nGiDXwZQc3zYpwhMyrVS6cPcMyqmJfa+2yRjs+LJbb48XYVC9eD/EoR8KvocXsSOm\niyhgeuOK+zFMykV8YLtdBRwvT/B/54iPNUFqPuFbJJm1Dh9DwzfVNLmarBLK2lYO\nN9yTzxZI5/mGBkYUpyav49xP54LsYgWCr1U7F+ekTiSBD5IHRNI/ddztEZ9CTI7V\nJa7DSDHNwcHFyYHGfuy1h8eh6QLDepN6bjbV9q9zE/tpj7w6isgV70YdrnEr0sM8\napgQiLHc3nMYnxkiGBXJNQFLU0UqORw9G30MGSmCcyAIB//ZO+u+DRlMQ0iC2kSW\n2lRZ/kyDkfrDfowzI271P2RCOyqWSyiDE+IRoZftvrVgW5bWI57XUXwV50kOGZ2/\np7kGqsTsR/FXTxtYz+KuDK47TvkTUN3w7es3UxJA+0uWlp1NXkBw3QaoyxdOXGba\nbGo4HYX6\n=tMWz\n-----END PGP SIGNATURE-----", "payload": "tree 71fc60d24b1565bac15398e634e30a93745638f6\nparent 4a12a13b588d54b6992bc74131aa4868357dd716\nauthor Vanille-N <neven.villani@crans.org> 1669983817 +0100\ncommitter Vanille-N <neven.villani@crans.org> 1669983817 +0100\n\nextract common borrow tracking logic\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d42d265eae884cb2ba90df11567257973d7be6f", "html_url": "https://github.com/rust-lang/rust/commit/2d42d265eae884cb2ba90df11567257973d7be6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d42d265eae884cb2ba90df11567257973d7be6f/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a12a13b588d54b6992bc74131aa4868357dd716", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a12a13b588d54b6992bc74131aa4868357dd716", "html_url": "https://github.com/rust-lang/rust/commit/4a12a13b588d54b6992bc74131aa4868357dd716"}], "stats": {"total": 365, "additions": 365, "deletions": 0}, "files": [{"sha": "69f9bd09f26de42610c5329530940ceba48d9e9f", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/2d42d265eae884cb2ba90df11567257973d7be6f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d42d265eae884cb2ba90df11567257973d7be6f/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=2d42d265eae884cb2ba90df11567257973d7be6f", "patch": "@@ -0,0 +1,365 @@\n+use std::cell::RefCell;\n+use std::fmt;\n+use std::num::NonZeroU64;\n+\n+use log::trace;\n+use smallvec::SmallVec;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_middle::mir::RetagKind;\n+use rustc_target::abi::Size;\n+\n+use crate::*;\n+pub mod stacked_borrows;\n+use stacked_borrows::diagnostics::RetagCause;\n+\n+pub type CallId = NonZeroU64;\n+\n+/// Tracking pointer provenance\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct BorTag(NonZeroU64);\n+\n+impl BorTag {\n+    pub fn new(i: u64) -> Option<Self> {\n+        NonZeroU64::new(i).map(BorTag)\n+    }\n+\n+    pub fn get(&self) -> u64 {\n+        self.0.get()\n+    }\n+\n+    pub fn inner(&self) -> NonZeroU64 {\n+        self.0\n+    }\n+\n+    pub fn succ(self) -> Option<Self> {\n+        self.0.checked_add(1).map(Self)\n+    }\n+\n+    /// The minimum representable tag\n+    pub fn one() -> Self {\n+        Self::new(1).unwrap()\n+    }\n+}\n+\n+impl std::default::Default for BorTag {\n+    /// The default to be used when borrow tracking is disabled\n+    fn default() -> Self {\n+        Self::one()\n+    }\n+}\n+\n+impl fmt::Debug for BorTag {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"<{}>\", self.0)\n+    }\n+}\n+\n+/// Per-frame data for borrow tracking\n+#[derive(Debug)]\n+pub struct FrameExtra {\n+    /// The ID of the call this frame corresponds to.\n+    pub call_id: CallId,\n+\n+    /// If this frame is protecting any tags, they are listed here. We use this list to do\n+    /// incremental updates of the global list of protected tags stored in the\n+    /// `stacked_borrows::GlobalState` upon function return, and if we attempt to pop a protected\n+    /// tag, to identify which call is responsible for protecting the tag.\n+    /// See `Stack::item_popped` for more explanation.\n+    ///\n+    /// This will contain one tag per reference passed to the function, so\n+    /// a size of 2 is enough for the vast majority of functions.\n+    pub protected_tags: SmallVec<[BorTag; 2]>,\n+}\n+\n+impl VisitTags for FrameExtra {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n+        // `protected_tags` are fine to GC.\n+    }\n+}\n+\n+/// Extra global state, available to the memory access hooks.\n+#[derive(Debug)]\n+pub struct GlobalStateInner {\n+    /// Borrow tracker method currently in use.\n+    pub borrow_tracker_method: BorrowTrackerMethod,\n+    /// Next unused pointer ID (tag).\n+    pub next_ptr_tag: BorTag,\n+    /// Table storing the \"base\" tag for each allocation.\n+    /// The base tag is the one used for the initial pointer.\n+    /// We need this in a separate table to handle cyclic statics.\n+    pub base_ptr_tags: FxHashMap<AllocId, BorTag>,\n+    /// Next unused call ID (for protectors).\n+    pub next_call_id: CallId,\n+    /// All currently protected tags.\n+    /// An item is protected if its tag is in this set, *and* it has the \"protected\" bit set.\n+    /// We add tags to this when they are created with a protector in `reborrow`, and\n+    /// we remove tags from this when the call which is protecting them returns, in\n+    /// `GlobalStateInner::end_call`. See `Stack::item_popped` for more details.\n+    pub protected_tags: FxHashMap<BorTag, ProtectorKind>,\n+    /// The pointer ids to trace\n+    pub tracked_pointer_tags: FxHashSet<BorTag>,\n+    /// The call ids to trace\n+    pub tracked_call_ids: FxHashSet<CallId>,\n+    /// Whether to recurse into datatypes when searching for pointers to retag.\n+    pub retag_fields: RetagFields,\n+}\n+\n+impl VisitTags for GlobalStateInner {\n+    fn visit_tags(&self, _visit: &mut dyn FnMut(BorTag)) {\n+        // The only candidate is base_ptr_tags, and that does not need visiting since we don't ever\n+        // GC the bottommost tag.\n+    }\n+}\n+\n+/// We need interior mutable access to the global state.\n+pub type GlobalState = RefCell<GlobalStateInner>;\n+\n+/// Indicates which kind of access is being performed.\n+#[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+}\n+\n+impl fmt::Display for AccessKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            AccessKind::Read => write!(f, \"read access\"),\n+            AccessKind::Write => write!(f, \"write access\"),\n+        }\n+    }\n+}\n+\n+/// Policy on whether to recurse into fields to retag\n+#[derive(Copy, Clone, Debug)]\n+pub enum RetagFields {\n+    /// Don't retag any fields.\n+    No,\n+    /// Retag all fields.\n+    Yes,\n+    /// Only retag fields of types with Scalar and ScalarPair layout,\n+    /// to match the LLVM `noalias` we generate.\n+    OnlyScalar,\n+}\n+\n+/// The flavor of the protector.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum ProtectorKind {\n+    /// Protected against aliasing violations from other pointers.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated, *but* the pointer itself may\n+    /// still be used to issue a deallocation.\n+    ///\n+    /// This is required for LLVM IR pointers that are `noalias` but *not* `dereferenceable`.\n+    WeakProtector,\n+\n+    /// Protected against any kind of invalidation.\n+    ///\n+    /// Items protected like this cause UB when they are invalidated or the memory is deallocated.\n+    /// This is strictly stronger protection than `WeakProtector`.\n+    ///\n+    /// This is required for LLVM IR pointers that are `dereferenceable` (and also allows `noalias`).\n+    StrongProtector,\n+}\n+\n+/// Utilities for initialization and ID generation\n+impl GlobalStateInner {\n+    pub fn new(\n+        borrow_tracker_method: BorrowTrackerMethod,\n+        tracked_pointer_tags: FxHashSet<BorTag>,\n+        tracked_call_ids: FxHashSet<CallId>,\n+        retag_fields: RetagFields,\n+    ) -> Self {\n+        GlobalStateInner {\n+            borrow_tracker_method,\n+            next_ptr_tag: BorTag::one(),\n+            base_ptr_tags: FxHashMap::default(),\n+            next_call_id: NonZeroU64::new(1).unwrap(),\n+            protected_tags: FxHashMap::default(),\n+            tracked_pointer_tags,\n+            tracked_call_ids,\n+            retag_fields,\n+        }\n+    }\n+\n+    /// Generates a new pointer tag. Remember to also check track_pointer_tags and log its creation!\n+    pub fn new_ptr(&mut self) -> BorTag {\n+        let id = self.next_ptr_tag;\n+        self.next_ptr_tag = id.succ().unwrap();\n+        id\n+    }\n+\n+    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameExtra {\n+        let call_id = self.next_call_id;\n+        trace!(\"new_frame: Assigning call ID {}\", call_id);\n+        if self.tracked_call_ids.contains(&call_id) {\n+            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n+        }\n+        self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n+        FrameExtra { call_id, protected_tags: SmallVec::new() }\n+    }\n+\n+    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n+        for tag in &frame\n+            .borrow_tracker\n+            .as_ref()\n+            .expect(\"we should have borrow tracking data\")\n+            .protected_tags\n+        {\n+            self.protected_tags.remove(tag);\n+        }\n+    }\n+\n+    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &MiriMachine<'_, '_>) -> BorTag {\n+        self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n+            let tag = self.new_ptr();\n+            if self.tracked_pointer_tags.contains(&tag) {\n+                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                    tag.inner(),\n+                    None,\n+                    None,\n+                ));\n+            }\n+            trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n+            self.base_ptr_tags.try_insert(id, tag).unwrap();\n+            tag\n+        })\n+    }\n+}\n+\n+/// Which borrow tracking method to use\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum BorrowTrackerMethod {\n+    /// Stacked Borrows, as implemented in borrow_tracker/stacked\n+    StackedBorrows,\n+}\n+\n+impl BorrowTrackerMethod {\n+    pub fn instanciate_global_state(self, config: &MiriConfig) -> GlobalState {\n+        RefCell::new(GlobalStateInner::new(\n+            self,\n+            config.tracked_pointer_tags.clone(),\n+            config.tracked_call_ids.clone(),\n+            config.retag_fields,\n+        ))\n+    }\n+}\n+\n+impl GlobalStateInner {\n+    pub fn new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        alloc_size: Size,\n+        kind: MemoryKind<machine::MiriMemoryKind>,\n+        machine: &MiriMachine<'_, '_>,\n+    ) -> AllocExtra {\n+        match self.borrow_tracker_method {\n+            BorrowTrackerMethod::StackedBorrows =>\n+                AllocExtra::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n+                    id, alloc_size, self, kind, machine,\n+                )))),\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag(kind, place),\n+        }\n+    }\n+\n+    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_retag_return_place(),\n+        }\n+    }\n+\n+    fn expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.sb_expose_tag(alloc_id, tag),\n+        }\n+    }\n+}\n+\n+/// Extra per-allocation data for borrow tracking\n+#[derive(Debug, Clone)]\n+pub enum AllocExtra {\n+    /// Data corresponding to Stacked Borrows\n+    StackedBorrows(Box<RefCell<stacked_borrows::AllocExtra>>),\n+}\n+\n+impl AllocExtra {\n+    pub fn assert_sb(&self) -> &RefCell<stacked_borrows::AllocExtra> {\n+        match self {\n+            AllocExtra::StackedBorrows(ref sb) => sb,\n+        }\n+    }\n+\n+    pub fn assert_sb_mut(&mut self) -> &mut RefCell<stacked_borrows::AllocExtra> {\n+        match self {\n+            AllocExtra::StackedBorrows(ref mut sb) => sb,\n+        }\n+    }\n+\n+    pub fn before_memory_read<'tcx>(\n+        &self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) =>\n+                sb.borrow_mut().before_memory_read(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn before_memory_write<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) =>\n+                sb.get_mut().before_memory_write(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn before_memory_deallocation<'tcx>(\n+        &mut self,\n+        alloc_id: AllocId,\n+        prov_extra: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &mut MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) =>\n+                sb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n+        }\n+    }\n+\n+    pub fn remove_unreachable_tags(&self, tags: &FxHashSet<BorTag>) {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n+        }\n+    }\n+}\n+\n+impl VisitTags for AllocExtra {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        match self {\n+            AllocExtra::StackedBorrows(sb) => sb.visit_tags(visit),\n+        }\n+    }\n+}"}]}