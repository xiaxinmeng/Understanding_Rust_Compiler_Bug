{"sha": "10269dfaeb223f28421eb4564b03aa31ef49c5a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMjY5ZGZhZWIyMjNmMjg0MjFlYjQ1NjRiMDNhYTMxZWY0OWM1YTE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T10:45:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-22T12:06:17Z"}, "message": "Replace &ty::t with ty::t throughout the compiler\n\nType handles are uints, passing them by reference only causes\nunnecessary spilling.", "tree": {"sha": "2afd314bca3c5ee33ea11bf38fb47fdf2cd5ff61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2afd314bca3c5ee33ea11bf38fb47fdf2cd5ff61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10269dfaeb223f28421eb4564b03aa31ef49c5a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10269dfaeb223f28421eb4564b03aa31ef49c5a1", "html_url": "https://github.com/rust-lang/rust/commit/10269dfaeb223f28421eb4564b03aa31ef49c5a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10269dfaeb223f28421eb4564b03aa31ef49c5a1/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "081caf5bb8e22102ba517c7484dafcf65705c681", "url": "https://api.github.com/repos/rust-lang/rust/commits/081caf5bb8e22102ba517c7484dafcf65705c681", "html_url": "https://github.com/rust-lang/rust/commit/081caf5bb8e22102ba517c7484dafcf65705c681"}], "stats": {"total": 302, "additions": 151, "deletions": 151}, "files": [{"sha": "8a176d1b0e91aedefab9dcfa554bc5a442a641f5", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -392,7 +392,7 @@ fn truncated_sha1_result(sha: sha1) -> str {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: &ty::t, link_meta: &link_meta) ->\n+fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: &link_meta) ->\n    str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n@@ -410,7 +410,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: &ty::t, link_meta: &link_meta) ->\n     ret \"_\" + hash;\n }\n \n-fn get_symbol_hash(ccx: &@crate_ctxt, t: &ty::t) -> str {\n+fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> str {\n     let hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n@@ -440,12 +440,12 @@ fn exported_name(path: &[str], hash: &str, _vers: &str) -> str {\n \n }\n \n-fn mangle_exported_name(ccx: &@crate_ctxt, path: &[str], t: &ty::t) -> str {\n+fn mangle_exported_name(ccx: &@crate_ctxt, path: &[str], t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: &ty::t, name: &str)\n+fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &str)\n    -> str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);"}, {"sha": "02427fa0321ff2aeb24d143253ed5db40638cc11", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -193,7 +193,7 @@ fn encode_variant_id(ebml_w: &ebml::writer, vid: &def_id) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebml::writer, typ: &ty::t) {\n+fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebml::writer, typ: ty::t) {\n     ebml::start_tag(ebml_w, tag_items_data_item_type);\n     let f = def_to_str;\n     let ty_str_ctxt =\n@@ -618,7 +618,7 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n }\n \n // Get the encoded string for a type\n-fn encoded_ty(tcx: &ty::ctxt, t: &ty::t) -> str {\n+fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> str {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n     let sw = io::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);"}, {"sha": "7b0915ba7b79496969607a3b9ae785e2d4eddfc9", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -36,7 +36,7 @@ fn cx_uses_abbrevs(cx: &@ctxt) -> bool {\n     }\n }\n \n-fn enc_ty(w: &io::writer, cx: &@ctxt, t: &ty::t) {\n+fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n     alt cx.abbrevs {\n       ac_no_abbrevs. {\n         let result_str;\n@@ -202,7 +202,7 @@ fn enc_proto(w: &io::writer, proto: proto) {\n     }\n }\n \n-fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: &ty::t,\n+fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n              cf: &controlflow, constrs: &[@ty::constr]) {\n     w.write_char('[');\n     for arg: ty::arg in args {"}, {"sha": "92c29b15e4fae8d2a43b754264466826ac157013", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -94,7 +94,7 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     ret bcx;\n }\n \n-fn type_is_gc_relevant(cx: &ty::ctxt, ty: &ty::t) -> bool {\n+fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n       ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. | ty::ty_float. |\n       ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. | ty::ty_istr. |"}, {"sha": "ddb855e97c8484e6f307e0c1d818228767eb2f91", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -78,7 +78,7 @@ import trans_objects::trans_obj;\n // return value was always meaningless in that case anyhow). Beware!\n //\n // TODO: Enforce via a predicate.\n-fn type_of(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n+fn type_of(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n         cx.sess.span_fatal(sp,\n                            \"type_of() called on a type with dynamic size: \" +\n@@ -113,7 +113,7 @@ fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &[ty::arg]) ->\n //  - new_fn_ctxt\n //  - trans_args\n fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n-                   is_method: bool, inputs: &[ty::arg], output: &ty::t,\n+                   is_method: bool, inputs: &[ty::arg], output: ty::t,\n                    ty_param_count: uint) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n@@ -145,21 +145,21 @@ fn type_of_fn_full(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n }\n \n fn type_of_fn(cx: &@crate_ctxt, sp: &span, proto: ast::proto,\n-              inputs: &[ty::arg], output: &ty::t, ty_param_count: uint) ->\n+              inputs: &[ty::arg], output: ty::t, ty_param_count: uint) ->\n    TypeRef {\n     ret type_of_fn_full(cx, sp, proto, false, inputs, output, ty_param_count);\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: &@crate_ctxt, sp: &span, fty: &ty::t,\n+fn type_of_fn_from_ty(cx: &@crate_ctxt, sp: &span, fty: ty::t,\n                       ty_param_count: uint) -> TypeRef {\n     ret type_of_fn(cx, sp, ty::ty_fn_proto(cx.tcx, fty),\n                    ty::ty_fn_args(cx.tcx, fty), ty::ty_fn_ret(cx.tcx, fty),\n                    ty_param_count);\n }\n \n fn type_of_native_fn(cx: &@crate_ctxt, sp: &span, abi: ast::native_abi,\n-                     inputs: &[ty::arg], output: &ty::t, ty_param_count: uint)\n+                     inputs: &[ty::arg], output: ty::t, ty_param_count: uint)\n    -> TypeRef {\n     let atys: [TypeRef] = [];\n     if abi == ast::native_abi_rust {\n@@ -171,7 +171,7 @@ fn type_of_native_fn(cx: &@crate_ctxt, sp: &span, abi: ast::native_abi,\n     ret T_fn(atys, type_of_inner(cx, sp, output));\n }\n \n-fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n+fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n     // Check the cache.\n \n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n@@ -248,7 +248,7 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> TypeRef {\n     ret llty;\n }\n \n-fn type_of_tag(cx: &@crate_ctxt, sp: &span, did: &ast::def_id, t: &ty::t) ->\n+fn type_of_tag(cx: &@crate_ctxt, sp: &span, did: &ast::def_id, t: ty::t) ->\n    TypeRef {\n     let degen = std::vec::len(ty::tag_variants(cx.tcx, did)) == 1u;\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n@@ -437,14 +437,14 @@ fn llalign_of(t: TypeRef) -> ValueRef {\n                                False);\n }\n \n-fn size_of(cx: &@block_ctxt, t: &ty::t) -> result {\n+fn size_of(cx: &@block_ctxt, t: ty::t) -> result {\n     if !ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n         ret rslt(cx, llsize_of(type_of(bcx_ccx(cx), cx.sp, t)));\n     }\n     ret dynamic_size_of(cx, t);\n }\n \n-fn align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n+fn align_of(cx: &@block_ctxt, t: ty::t) -> result {\n     if !ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n         ret rslt(cx, llalign_of(type_of(bcx_ccx(cx), cx.sp, t)));\n     }\n@@ -485,7 +485,7 @@ fn mk_obstack_token(ccx: &@crate_ctxt, lldynamicallocas: BasicBlockRef,\n // to have (a) the same size as the type that was passed in; (b) to be non-\n // recursive. This is done by replacing all boxes in a type with boxed unit\n // types.\n-fn simplify_type(ccx: &@crate_ctxt, typ: &ty::t) -> ty::t {\n+fn simplify_type(ccx: &@crate_ctxt, typ: ty::t) -> ty::t {\n     fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n         alt ty::struct(ccx.tcx, typ) {\n           ty::ty_box(_) { ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)); }\n@@ -513,7 +513,7 @@ fn simplify_type(ccx: &@crate_ctxt, typ: &ty::t) -> ty::t {\n \n \n // Computes the size of the data part of a non-dynamically-sized tag.\n-fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: &ty::t) -> uint {\n+fn static_size_of_tag(cx: &@crate_ctxt, sp: &span, t: ty::t) -> uint {\n     if ty::type_has_dynamic_size(cx.tcx, t) {\n         cx.tcx.sess.span_fatal(sp,\n                                \"dynamically sized type passed to \\\n@@ -628,7 +628,7 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n     }\n }\n \n-fn dynamic_align_of(cx: &@block_ctxt, t: &ty::t) -> result {\n+fn dynamic_align_of(cx: &@block_ctxt, t: ty::t) -> result {\n     alt ty::struct(bcx_tcx(cx), t) {\n       ty::ty_param(p, _) {\n         let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n@@ -677,7 +677,7 @@ fn GEPi(cx: &@block_ctxt, base: ValueRef, ixs: &[int]) -> ValueRef {\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n // to a given type.\n-fn bump_ptr(bcx: &@block_ctxt, t: &ty::t, base: ValueRef, sz: ValueRef) ->\n+fn bump_ptr(bcx: &@block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n    ValueRef {\n     let raw = bcx.build.PointerCast(base, T_ptr(T_i8()));\n     let bumped = bcx.build.GEP(raw, [sz]);\n@@ -691,7 +691,7 @@ fn bump_ptr(bcx: &@block_ctxt, t: &ty::t, base: ValueRef, sz: ValueRef) ->\n // ty::struct and knows what to do when it runs into a ty_param stuck in the\n // middle of the thing it's GEP'ing into. Much like size_of and align_of,\n // above.\n-fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n+fn GEP_tup_like(cx: &@block_ctxt, t: ty::t, base: ValueRef, ixs: &[int]) ->\n    result {\n     assert (ty::type_is_tup_like(bcx_tcx(cx), t));\n     // It might be a static-known type. Handle this.\n@@ -714,7 +714,7 @@ fn GEP_tup_like(cx: &@block_ctxt, t: &ty::t, base: ValueRef, ixs: &[int]) ->\n     // elements of the type and splitting the Xth off. Return the prefix as\n     // well as the innermost Xth type.\n \n-    fn split_type(ccx: &@crate_ctxt, t: &ty::t, ixs: &[int], n: uint) ->\n+    fn split_type(ccx: &@crate_ctxt, t: ty::t, ixs: &[int], n: uint) ->\n        {prefix: [ty::t], target: ty::t} {\n         let len: uint = std::vec::len::<int>(ixs);\n         // We don't support 0-index or 1-index GEPs: The former is nonsense\n@@ -879,7 +879,7 @@ fn trans_malloc_boxed(cx: &@block_ctxt, t: ty::t) ->\n // Given a type and a field index into its corresponding type descriptor,\n // returns an LLVM ValueRef of that field from the tydesc, generating the\n // tydesc if necessary.\n-fn field_of_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool, field: int) ->\n+fn field_of_tydesc(cx: &@block_ctxt, t: ty::t, escapes: bool, field: int) ->\n    result {\n     let ti = none::<@tydesc_info>;\n     let tydesc = get_tydesc(cx, t, escapes, ti).result;\n@@ -892,7 +892,7 @@ fn field_of_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool, field: int) ->\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n-fn linearize_ty_params(cx: &@block_ctxt, t: &ty::t) ->\n+fn linearize_ty_params(cx: &@block_ctxt, t: ty::t) ->\n    {params: [uint], descs: [ValueRef]} {\n     let param_vals: [ValueRef] = [];\n     let param_defs: [uint] = [];\n@@ -938,7 +938,7 @@ fn trans_stack_local_derived_tydesc(cx: &@block_ctxt, llsz: ValueRef,\n     ret llmyroottydesc;\n }\n \n-fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n+fn get_derived_tydesc(cx: &@block_ctxt, t: ty::t, escapes: bool,\n                       static_ti: &mutable option::t<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n@@ -1008,7 +1008,7 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n \n type get_tydesc_result = {kind: tydesc_kind, result: result};\n \n-fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n+fn get_tydesc(cx: &@block_ctxt, orig_t: ty::t, escapes: bool,\n               static_ti: &mutable option::t<@tydesc_info>) ->\n    get_tydesc_result {\n \n@@ -1043,7 +1043,7 @@ fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n     ret {kind: tk_static, result: rslt(cx, info.tydesc)};\n }\n \n-fn get_static_tydesc(cx: &@block_ctxt, orig_t: &ty::t, ty_params: &[uint]) ->\n+fn get_static_tydesc(cx: &@block_ctxt, orig_t: ty::t, ty_params: &[uint]) ->\n    @tydesc_info {\n     let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n \n@@ -1079,15 +1079,15 @@ fn set_always_inline(f: ValueRef) {\n                                   lib::llvm::llvm::Attribute);\n }\n \n-fn set_glue_inlining(cx: &@local_ctxt, f: ValueRef, t: &ty::t) {\n+fn set_glue_inlining(cx: &@local_ctxt, f: ValueRef, t: ty::t) {\n     if ty::type_is_structural(cx.ccx.tcx, t) {\n         set_no_inline(f);\n     } else { set_always_inline(f); }\n }\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: &ty::t, ty_params: &[uint])\n+fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: ty::t, ty_params: &[uint])\n    -> @tydesc_info {\n     log \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t);\n     let ccx = cx.ccx;\n@@ -1127,11 +1127,11 @@ fn declare_tydesc(cx: &@local_ctxt, sp: &span, t: &ty::t, ty_params: &[uint])\n }\n \n tag glue_helper {\n-    default_helper(fn(&@block_ctxt, ValueRef, &ty::t));\n-    copy_helper(fn(&@block_ctxt, ValueRef, ValueRef, &ty::t));\n+    default_helper(fn(&@block_ctxt, ValueRef, ty::t));\n+    copy_helper(fn(&@block_ctxt, ValueRef, ValueRef, ty::t));\n }\n \n-fn declare_generic_glue(cx: &@local_ctxt, t: &ty::t, llfnty: TypeRef,\n+fn declare_generic_glue(cx: &@local_ctxt, t: ty::t, llfnty: TypeRef,\n                         name: &str) -> ValueRef {\n     let fn_nm;\n     if cx.ccx.sess.get_opts().debuginfo {\n@@ -1143,7 +1143,7 @@ fn declare_generic_glue(cx: &@local_ctxt, t: &ty::t, llfnty: TypeRef,\n     ret llfn;\n }\n \n-fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n+fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: ty::t,\n                            llfn: ValueRef,\n                            helper: &glue_helper,\n                            ty_params: &[uint]) -> ValueRef {\n@@ -1195,7 +1195,7 @@ fn make_generic_glue_inner(cx: &@local_ctxt, sp: &span, t: &ty::t,\n     ret llfn;\n }\n \n-fn make_generic_glue(cx: &@local_ctxt, sp: &span, t: &ty::t, llfn: ValueRef,\n+fn make_generic_glue(cx: &@local_ctxt, sp: &span, t: ty::t, llfn: ValueRef,\n                      helper: &glue_helper, ty_params: &[uint],\n                      name: &str) -> ValueRef {\n     if !cx.ccx.sess.get_opts().stats {\n@@ -1272,12 +1272,12 @@ fn emit_tydescs(ccx: &@crate_ctxt) {\n     }\n }\n \n-fn make_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: &ty::t) {\n+fn make_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) {\n     let bcx = memmove_ty(cx, dst, src, t).bcx;\n     build_return(bcx);\n }\n \n-fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t) {\n+fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n \n     let bcx;\n@@ -1308,7 +1308,7 @@ fn incr_refcnt_of_boxed(cx: &@block_ctxt, box_ptr: ValueRef) -> result {\n     ret rslt(next_cx, C_nil());\n }\n \n-fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n+fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v is an *alias* of type t here, not a direct value.\n     let rs =\n         alt ty::struct(bcx_tcx(cx), t) {\n@@ -1407,7 +1407,7 @@ fn maybe_free_ivec_heap_part(cx: &@block_ctxt, v0: ValueRef, unit_ty: ty::t)\n     ret rslt(next_cx, C_nil());\n }\n \n-fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: &ty::t) {\n+fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(cx);\n     let rs =\n@@ -1495,7 +1495,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n }\n \n fn decr_refcnt_maybe_free(cx: &@block_ctxt, box_ptr_alias: ValueRef,\n-                          full_alias: ValueRef, t: &ty::t) -> result {\n+                          full_alias: ValueRef, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n     let load_rc_cx = new_sub_block_ctxt(cx, \"load rc\");\n     let rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n@@ -1544,7 +1544,7 @@ tag scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n \n \n fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n-                        t: &ty::t, llop: ValueRef) -> result {\n+                        t: ty::t, llop: ValueRef) -> result {\n     let f = bind compare_scalar_values(cx, lhs, rhs, _, llop);\n \n     alt ty::struct(bcx_tcx(cx), t) {\n@@ -1662,7 +1662,7 @@ type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n \n \n // Iterates through the elements of a structural type.\n-fn iter_structural_ty(cx: &@block_ctxt, v: ValueRef, t: &ty::t,\n+fn iter_structural_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t,\n                       f: val_and_ty_fn) -> result {\n     fn adaptor_fn(f: val_and_ty_fn, cx: &@block_ctxt, av: ValueRef, t: ty::t)\n        -> result {\n@@ -1687,7 +1687,7 @@ fn incr_ptr(cx: &@block_ctxt, p: ValueRef, incr: ValueRef, pp: ValueRef) {\n     cx.build.Store(cx.build.InBoundsGEP(p, [incr]), pp);\n }\n \n-fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: &ty::t,\n+fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n                            f: &val_and_ty_fn) -> result {\n     fn iter_boxpp(cx: @block_ctxt, box_cell: ValueRef, f: &val_and_ty_fn) ->\n        result {\n@@ -1936,9 +1936,9 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n \n \n // Iterates through the elements of a vec or str.\n-fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: &ty::t, f: &val_and_ty_fn)\n+fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n    -> result {\n-    fn iter_sequence_body(cx: @block_ctxt, v: ValueRef, elt_ty: &ty::t,\n+    fn iter_sequence_body(cx: @block_ctxt, v: ValueRef, elt_ty: ty::t,\n                           f: &val_and_ty_fn, trailing_null: bool,\n                           interior: bool) -> result {\n         let p0;\n@@ -2131,7 +2131,7 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n                    C_null(T_ptr(T_nil())), lltydescs, llrawptr]);\n }\n \n-fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t, field: int) ->\n+fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t, field: int) ->\n    result {\n     let ti: option::t<@tydesc_info> = none::<@tydesc_info>;\n     let td = get_tydesc(cx, t, false, ti).result;\n@@ -2140,7 +2140,7 @@ fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t, field: int) ->\n     ret rslt(td.bcx, C_nil());\n }\n \n-fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n+fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n                  llop: ValueRef) -> result {\n     // We can't use call_tydesc_glue_full() and friends here because compare\n     // glue has a special signature.\n@@ -2177,7 +2177,7 @@ fn call_cmp_glue(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n     ret rslt(r.bcx, r.bcx.build.Load(llcmpresultptr));\n }\n \n-fn call_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: &ty::t,\n+fn call_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t,\n                   take: bool) -> @block_ctxt {\n     // You can't call this on immediate types. Those are simply copied with\n     // Load/Store.\n@@ -2218,7 +2218,7 @@ fn call_copy_glue(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: &ty::t,\n \n // Compares two values. Performs the simple scalar comparison if the types are\n // scalar and calls to comparison glue otherwise.\n-fn compare(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: &ty::t,\n+fn compare(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n            llop: ValueRef) -> result {\n     if ty::type_is_scalar(bcx_tcx(cx), t) {\n         ret compare_scalar_types(cx, lhs, rhs, t, llop);\n@@ -2234,7 +2234,7 @@ fn take_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n     ret rslt(cx, C_nil());\n }\n \n-fn drop_slot(cx: &@block_ctxt, slot: ValueRef, t: &ty::t) -> result {\n+fn drop_slot(cx: &@block_ctxt, slot: ValueRef, t: ty::t) -> result {\n     let llptr = load_if_immediate(cx, slot, t);\n     ret drop_ty(cx, llptr, t);\n }\n@@ -2292,7 +2292,7 @@ fn call_bzero(cx: &@block_ctxt, dst: ValueRef, n_bytes: ValueRef,\n                            [dst_ptr, C_u8(0u), size, align, volatile]));\n }\n \n-fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: &ty::t) ->\n+fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n    result {\n     if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n         let llsz = size_of(cx, t);\n@@ -2328,7 +2328,7 @@ fn type_is_structural_or_param(tcx: &ty::ctxt, t: ty::t) -> bool {\n }\n \n fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n-            src: ValueRef, t: &ty::t) -> @block_ctxt {\n+            src: ValueRef, t: ty::t) -> @block_ctxt {\n     if type_is_structural_or_param(bcx_ccx(cx).tcx, t) &&\n        action == DROP_EXISTING {\n         let do_copy_cx = new_sub_block_ctxt(cx, \"do_copy\");\n@@ -2345,7 +2345,7 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n }\n \n fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n-                     src: ValueRef, t: &ty::t) -> @block_ctxt {\n+                     src: ValueRef, t: ty::t) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n     // FIXME this is just a clunky stopgap. we should do proper checking in an\n     // earlier pass.\n@@ -2384,7 +2384,7 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n // case where a variable is always deinitialized by block exit and thus\n // doesn't need to be dropped.\n fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-            src: &lval_result, t: &ty::t) -> @block_ctxt {\n+            src: &lval_result, t: ty::t) -> @block_ctxt {\n     let src_val = src.res.val;\n     if ty::type_is_scalar(bcx_tcx(cx), t) ||\n            ty::type_is_native(bcx_tcx(cx), t) {\n@@ -2422,7 +2422,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n }\n \n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n-                    src: &lval_result, t: &ty::t) -> @block_ctxt {\n+                    src: &lval_result, t: ty::t) -> @block_ctxt {\n \n     // Lvals in memory are not temporaries. Copy them.\n     if src.is_mem {\n@@ -2606,7 +2606,7 @@ fn trans_compare(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n     }\n }\n \n-fn trans_evec_append(cx: &@block_ctxt, t: &ty::t, lhs: ValueRef,\n+fn trans_evec_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n                      rhs: ValueRef) -> result {\n     let elt_ty = ty::sequence_element_type(bcx_tcx(cx), t);\n     let skip_null = C_bool(false);\n@@ -2847,7 +2847,7 @@ mod ivec {\n                                stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n         ret rslt(next_cx, data_ptr);\n     }\n-    fn trans_append(cx: &@block_ctxt, t: &ty::t, orig_lhs: ValueRef,\n+    fn trans_append(cx: &@block_ctxt, t: ty::t, orig_lhs: ValueRef,\n                     orig_rhs: ValueRef) -> result {\n         // Cast to opaque interior vector types if necessary.\n         let lhs;\n@@ -3231,7 +3231,7 @@ mod ivec {\n     }\n }\n \n-fn trans_evec_add(cx: &@block_ctxt, t: &ty::t, lhs: ValueRef, rhs: ValueRef)\n+fn trans_evec_add(cx: &@block_ctxt, t: ty::t, lhs: ValueRef, rhs: ValueRef)\n    -> result {\n     let r = alloc_ty(cx, t);\n     let tmp = r.val;\n@@ -3306,7 +3306,7 @@ fn trans_eager_binop(cx: &@block_ctxt, op: ast::binop, lhs: ValueRef,\n     }\n }\n \n-fn autoderef(cx: &@block_ctxt, v: ValueRef, t: &ty::t) -> result_t {\n+fn autoderef(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n     let ccx = bcx_ccx(cx);\n@@ -3644,7 +3644,7 @@ fn build_closure(cx: &@block_ctxt, upvars: &@[ast::node_id], copying: bool) ->\n // be dynamically sized, we can't skip past them to get to the tydescs until\n // we have loaded the tydescs. Thus we use the stored size of the bindings\n // in the tydesc for the closure to skip over them. Ugh.\n-fn find_environment_tydescs(bcx: &@block_ctxt, envty: &ty::t,\n+fn find_environment_tydescs(bcx: &@block_ctxt, envty: ty::t,\n                             closure: ValueRef) -> ValueRef {\n     ret if !ty::type_has_dynamic_size(bcx_tcx(bcx), envty) {\n \n@@ -3675,7 +3675,7 @@ fn find_environment_tydescs(bcx: &@block_ctxt, envty: &ty::t,\n // Given an enclosing block context, a new function context, a closure type,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n-fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: &ty::t,\n+fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n                     upvars: &@[ast::node_id], copying: bool) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n@@ -4003,7 +4003,7 @@ fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n     ret trans_var(cx, p.span, id);\n }\n \n-fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: &ty::t,\n+fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: ty::t,\n                field: &ast::ident) -> lval_result {\n     let r = autoderef(cx, v, t0);\n     let t = r.ty;\n@@ -4270,9 +4270,9 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n     ret rslt(e_res.bcx, newval);\n }\n \n-fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n-                    outgoing_fty: &ty::t, args: &[option::t<@ast::expr>],\n-                    env_ty: &ty::t, ty_param_count: uint,\n+fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n+                    outgoing_fty: ty::t, args: &[option::t<@ast::expr>],\n+                    env_ty: ty::t, ty_param_count: uint,\n                     target_fn: &option::t<ValueRef>) ->\n    {val: ValueRef, ty: TypeRef} {\n \n@@ -4594,7 +4594,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n //  - trans_args\n fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n               gen: &option::t<generic_info>, lliterbody: &option::t<ValueRef>,\n-              es: &[@ast::expr], fn_ty: &ty::t) ->\n+              es: &[@ast::expr], fn_ty: ty::t) ->\n    {bcx: @block_ctxt,\n     args: [ValueRef],\n     retslot: ValueRef,\n@@ -5176,7 +5176,7 @@ fn with_out_method(work: fn(&out_method) -> result, cx: @block_ctxt,\n // latter group \"immediates\" and, in some circumstances when we know we have a\n // pointer (or need one), perform load/store operations based on the\n // immediate-ness of the type.\n-fn type_is_immediate(ccx: &@crate_ctxt, t: &ty::t) -> bool {\n+fn type_is_immediate(ccx: &@crate_ctxt, t: ty::t) -> bool {\n     ret ty::type_is_scalar(ccx.tcx, t) || ty::type_is_boxed(ccx.tcx, t) ||\n             ty::type_is_native(ccx.tcx, t);\n }\n@@ -5188,12 +5188,12 @@ fn do_spill(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n     ret llptr;\n }\n \n-fn spill_if_immediate(cx: &@block_ctxt, v: ValueRef, t: &ty::t) -> ValueRef {\n+fn spill_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n     if type_is_immediate(bcx_ccx(cx), t) { ret do_spill(cx, v); }\n     ret v;\n }\n \n-fn load_if_immediate(cx: &@block_ctxt, v: ValueRef, t: &ty::t) -> ValueRef {\n+fn load_if_immediate(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> ValueRef {\n     if type_is_immediate(bcx_ccx(cx), t) { ret cx.build.Load(v); }\n     ret v;\n }\n@@ -5665,7 +5665,7 @@ fn llderivedtydescs_block_ctxt(fcx: &@fn_ctxt) -> @block_ctxt {\n }\n \n \n-fn alloc_ty(cx: &@block_ctxt, t: &ty::t) -> result {\n+fn alloc_ty(cx: &@block_ctxt, t: ty::t) -> result {\n     let bcx = cx;\n     let val = C_int(0);\n     if ty::type_has_dynamic_size(bcx_tcx(bcx), t) {"}, {"sha": "b2fb3a92750bcebf733db7b2c5d0a74306627bd1", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -428,7 +428,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n     let has_params: bool = false;\n     let has_vars: bool = false;\n     fn derive_flags_t(cx: &ctxt, has_params: &mutable bool,\n-                      has_vars: &mutable bool, tt: &t) {\n+                      has_vars: &mutable bool, tt: t) {\n         let rt = interner::get::<@raw_t>(*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n         has_vars = has_vars || rt.has_vars;\n@@ -442,7 +442,7 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n         derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n     fn derive_flags_sig(cx: &ctxt, has_params: &mutable bool,\n-                        has_vars: &mutable bool, args: &[arg], tt: &t) {\n+                        has_vars: &mutable bool, args: &[arg], tt: t) {\n         for a: arg in args { derive_flags_arg(cx, has_params, has_vars, a); }\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n@@ -553,40 +553,40 @@ fn mk_tag(cx: &ctxt, did: &ast::def_id, tys: &[t]) -> t {\n \n fn mk_box(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_box(tm)); }\n \n-fn mk_uniq(cx: &ctxt, typ: &t) -> t { ret gen_ty(cx, ty_uniq(typ)); }\n+fn mk_uniq(cx: &ctxt, typ: t) -> t { ret gen_ty(cx, ty_uniq(typ)); }\n \n fn mk_ptr(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_ptr(tm)); }\n \n-fn mk_imm_box(cx: &ctxt, ty: &t) -> t {\n+fn mk_imm_box(cx: &ctxt, ty: t) -> t {\n     ret mk_box(cx, {ty: ty, mut: ast::imm});\n }\n \n-fn mk_mut_ptr(cx: &ctxt, ty: &t) -> t {\n+fn mk_mut_ptr(cx: &ctxt, ty: t) -> t {\n     ret mk_ptr(cx, {ty: ty, mut: ast::mut});\n }\n \n fn mk_vec(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_vec(tm)); }\n \n fn mk_rec(cx: &ctxt, fs: &[field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_constr(cx: &ctxt, t: &t, cs: &[@type_constr]) -> t {\n+fn mk_constr(cx: &ctxt, t: t, cs: &[@type_constr]) -> t {\n     ret gen_ty(cx, ty_constr(t, cs));\n }\n \n fn mk_tup(cx: &ctxt, ts: &[t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n \n-fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: &t,\n+fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: t,\n          cf: &controlflow, constrs: &[@constr]) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n-fn mk_native_fn(cx: &ctxt, abi: &ast::native_abi, args: &[arg], ty: &t) -> t {\n+fn mk_native_fn(cx: &ctxt, abi: &ast::native_abi, args: &[arg], ty: t) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n fn mk_obj(cx: &ctxt, meths: &[method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n \n-fn mk_res(cx: &ctxt, did: &ast::def_id, inner: &t, tps: &[t]) -> t {\n+fn mk_res(cx: &ctxt, did: &ast::def_id, inner: t, tps: &[t]) -> t {\n     ret gen_ty(cx, ty_res(did, inner, tps));\n }\n \n@@ -600,19 +600,19 @@ fn mk_type(_cx: &ctxt) -> t { ret idx_type; }\n \n fn mk_native(cx: &ctxt, did: &def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n-fn mk_iter_body_fn(cx: &ctxt, output: &t) -> t {\n+fn mk_iter_body_fn(cx: &ctxt, output: t) -> t {\n     ret mk_fn(cx, ast::proto_block, [{mode: ty::mo_alias(false), ty: output}],\n               ty::mk_nil(cx), ast::return, []);\n }\n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(cx: &ctxt, typ: &t) -> sty {\n+fn struct(cx: &ctxt, typ: t) -> sty {\n     ret interner::get(*cx.ts, typ).struct;\n }\n \n \n // Returns the canonical name of the given type.\n-fn cname(cx: &ctxt, typ: &t) -> option::t<str> {\n+fn cname(cx: &ctxt, typ: t) -> option::t<str> {\n     ret interner::get(*cx.ts, typ).cname;\n }\n \n@@ -803,19 +803,19 @@ fn copy_cname(cx: &ctxt, struct_ty: t, cname_ty: t) -> t {\n     ret gen_ty_full(cx, struct(cx, struct_ty), cname(cx, cname_ty));\n }\n \n-fn type_is_nil(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_nil(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_nil. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_bot(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_bot(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_bot. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_bool(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_bool(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_bool. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_structural(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_structural(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_rec(_) { ret true; }\n       ty_tup(_) { ret true; }\n@@ -829,15 +829,15 @@ fn type_is_structural(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_is_copyable(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_copyable(cx: &ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_res(_, _, _) { false }\n           ty_fn(proto_block., _, _, _, _) { false }\n           _ { true }\n         };\n }\n \n-fn type_is_sequence(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_sequence(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_str. { ret true; }\n       ty_istr. { ret true; }\n@@ -846,15 +846,15 @@ fn type_is_sequence(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_is_str(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_str(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_str. { ret true; }\n       ty_istr. { ret true; }\n       _ { ret false; }\n     }\n }\n \n-fn sequence_is_interior(cx: &ctxt, ty: &t) -> bool {\n+fn sequence_is_interior(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n \n \n@@ -867,7 +867,7 @@ fn sequence_is_interior(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn sequence_element_type(cx: &ctxt, ty: &t) -> t {\n+fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n     alt struct(cx, ty) {\n       ty_str. { ret mk_mach(cx, ast::ty_u8); }\n       ty_istr. { ret mk_mach(cx, ast::ty_u8); }\n@@ -876,7 +876,7 @@ fn sequence_element_type(cx: &ctxt, ty: &t) -> t {\n     }\n }\n \n-fn type_is_tup_like(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_tup_like(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_box(_) { ret true; }\n       ty_rec(_) { ret true; }\n@@ -886,7 +886,7 @@ fn type_is_tup_like(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn get_element_type(cx: &ctxt, ty: &t, i: uint) -> t {\n+fn get_element_type(cx: &ctxt, ty: t, i: uint) -> t {\n     alt struct(cx, ty) {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n@@ -900,23 +900,23 @@ fn get_element_type(cx: &ctxt, ty: &t, i: uint) -> t {\n     // tag.\n }\n \n-fn type_is_box(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_box(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_box(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_is_boxed(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_boxed(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_str. { ret true; }\n       ty_box(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-fn type_is_unique(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_unique(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_uniq(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_is_scalar(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_scalar(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_nil. { ret true; }\n       ty_bool. { ret true; }\n@@ -932,7 +932,7 @@ fn type_is_scalar(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n+fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n     alt cx.has_pointer_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n@@ -986,14 +986,14 @@ fn type_has_pointers(cx: &ctxt, ty: &t) -> bool {\n     ret result;\n }\n \n-fn type_needs_drop(cx: &ctxt, ty: &t) -> bool {\n+fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_res(_, _, _) { true }\n           _ { type_has_pointers(cx, ty) }\n         };\n }\n \n-fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n+fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n     alt cx.kind_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n@@ -1127,11 +1127,11 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?\n-fn type_is_native(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_native(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_native(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n+fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_nil. { ret false; }\n       ty_bot. { ret false; }\n@@ -1181,7 +1181,7 @@ fn type_has_dynamic_size(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_is_integral(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_integral(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }\n       ty_uint. { ret true; }\n@@ -1204,7 +1204,7 @@ fn type_is_integral(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_is_fp(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_fp(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_machine(tm) {\n         alt tm {\n@@ -1218,7 +1218,7 @@ fn type_is_fp(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_is_signed(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_signed(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }\n       ty_machine(tm) {\n@@ -1234,7 +1234,7 @@ fn type_is_signed(cx: &ctxt, ty: &t) -> bool {\n     }\n }\n \n-fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n+fn type_owns_heap_mem(cx: &ctxt, ty: t) -> bool {\n     alt cx.owns_heap_mem_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n@@ -1311,7 +1311,7 @@ fn type_owns_heap_mem(cx: &ctxt, ty: &t) -> bool {\n }\n \n // Whether a type is Plain Old Data (i.e. can be safely memmoved).\n-fn type_is_pod(cx: &ctxt, ty: &t) -> bool {\n+fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n \n@@ -1363,7 +1363,7 @@ fn type_is_pod(cx: &ctxt, ty: &t) -> bool {\n     ret result;\n }\n \n-fn type_param(cx: &ctxt, ty: &t) -> option::t<uint> {\n+fn type_param(cx: &ctxt, ty: t) -> option::t<uint> {\n     alt struct(cx, ty) {\n       ty_param(id, _) { ret some(id); }\n       _ {/* fall through */ }\n@@ -1373,7 +1373,7 @@ fn type_param(cx: &ctxt, ty: &t) -> option::t<uint> {\n \n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n-fn vars_in_type(cx: &ctxt, ty: &t) -> [int] {\n+fn vars_in_type(cx: &ctxt, ty: t) -> [int] {\n     fn collect_var(cx: &ctxt, vars: &@mutable [int], ty: t) {\n         alt struct(cx, ty) { ty_var(v) { *vars += [v]; } _ { } }\n     }\n@@ -1384,7 +1384,7 @@ fn vars_in_type(cx: &ctxt, ty: &t) -> [int] {\n     ret *rslt;\n }\n \n-fn type_autoderef(cx: &ctxt, t: &ty::t) -> ty::t {\n+fn type_autoderef(cx: &ctxt, t: ty::t) -> ty::t {\n     let t1: ty::t = t;\n     while true {\n         alt struct(cx, t1) {\n@@ -1419,7 +1419,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         h += h << 5u + (did.node as uint);\n         ret h;\n     }\n-    fn hash_subty(id: uint, subty: &t) -> uint {\n+    fn hash_subty(id: uint, subty: t) -> uint {\n         let h = id;\n         h += h << 5u + hash_ty(subty);\n         ret h;\n@@ -1448,7 +1448,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n \n \n-    fn hash_fn(id: uint, args: &[arg], rty: &t) -> uint {\n+    fn hash_fn(id: uint, args: &[arg], rty: t) -> uint {\n         let h = id;\n         for a: arg in args { h += h << 5u + hash_ty(a.ty); }\n         h += h << 5u + hash_ty(rty);\n@@ -1681,47 +1681,47 @@ fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n     ret vec::len::<uint>(*param_indices);\n }\n \n-fn type_contains_vars(cx: &ctxt, typ: &t) -> bool {\n+fn type_contains_vars(cx: &ctxt, typ: t) -> bool {\n     ret interner::get(*cx.ts, typ).has_vars;\n }\n \n-fn type_contains_params(cx: &ctxt, typ: &t) -> bool {\n+fn type_contains_params(cx: &ctxt, typ: t) -> bool {\n     ret interner::get(*cx.ts, typ).has_params;\n }\n \n \n // Type accessors for substructures of types\n-fn ty_fn_args(cx: &ctxt, fty: &t) -> [arg] {\n+fn ty_fn_args(cx: &ctxt, fty: t) -> [arg] {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, a, _, _, _) { ret a; }\n       ty::ty_native_fn(_, a, _) { ret a; }\n       _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n     }\n }\n \n-fn ty_fn_proto(cx: &ctxt, fty: &t) -> ast::proto {\n+fn ty_fn_proto(cx: &ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n       ty::ty_fn(p, _, _, _, _) { ret p; }\n       _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n     }\n }\n \n-fn ty_fn_abi(cx: &ctxt, fty: &t) -> ast::native_abi {\n+fn ty_fn_abi(cx: &ctxt, fty: t) -> ast::native_abi {\n     alt struct(cx, fty) {\n       ty::ty_native_fn(a, _, _) { ret a; }\n       _ { cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\"); }\n     }\n }\n \n-fn ty_fn_ret(cx: &ctxt, fty: &t) -> t {\n+fn ty_fn_ret(cx: &ctxt, fty: t) -> t {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, r, _, _) { ret r; }\n       ty::ty_native_fn(_, _, r) { ret r; }\n       _ { cx.sess.bug(\"ty_fn_ret() called on non-fn type\"); }\n     }\n }\n \n-fn is_fn_ty(cx: &ctxt, fty: &t) -> bool {\n+fn is_fn_ty(cx: &ctxt, fty: t) -> bool {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, _, _, _) { ret true; }\n       ty::ty_native_fn(_, _, _) { ret true; }\n@@ -1754,7 +1754,7 @@ fn pat_ty(cx: &ctxt, pat: &@ast::pat) -> t {\n //\n // NB: This type doesn't provide type parameter substitutions; e.g. if you\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n-// instead of \"fn(&T) -> T with T = int\". If this isn't what you want, see\n+// instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n fn expr_ty(cx: &ctxt, expr: &@ast::expr) -> t {\n     ret node_id_to_monotype(cx, expr.id);\n@@ -1812,7 +1812,7 @@ fn is_lval(expr: &@ast::expr) -> bool {\n     }\n }\n \n-fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: &t) ->\n+fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: t) ->\n    bool {\n     if !type_contains_vars(tcx, rt) {\n         // Fast path\n@@ -1947,7 +1947,7 @@ mod unify {\n \n     // Right now this just checks that the lists of constraints are\n     // pairwise equal.\n-    fn unify_constrs(base_t: &t, expected: [@type_constr],\n+    fn unify_constrs(base_t: t, expected: [@type_constr],\n                      actual: &[@type_constr]) -> result {\n         let expected_len = vec::len(expected);\n         let actual_len = vec::len(actual);\n@@ -1964,7 +1964,7 @@ mod unify {\n         }\n         ret ures_ok(base_t);\n     }\n-    fn unify_constr(base_t: &t, expected: @type_constr,\n+    fn unify_constr(base_t: t, expected: @type_constr,\n                     actual_constr: &@type_constr) -> result {\n         let ok_res = ures_ok(base_t);\n         let err_res = ures_err(terr_constr_mismatch(expected, actual_constr));\n@@ -2010,9 +2010,9 @@ mod unify {\n         fn_common_res_err(result);\n         fn_common_res_ok([arg], t);\n     }\n-    fn unify_fn_common(cx: &@ctxt, _expected: &t, _actual: &t,\n-                       expected_inputs: &[arg], expected_output: &t,\n-                       actual_inputs: &[arg], actual_output: &t) ->\n+    fn unify_fn_common(cx: &@ctxt, _expected: t, _actual: t,\n+                       expected_inputs: &[arg], expected_output: t,\n+                       actual_inputs: &[arg], actual_output: t) ->\n        fn_common_res {\n         let expected_len = vec::len::<arg>(expected_inputs);\n         let actual_len = vec::len::<arg>(actual_inputs);\n@@ -2050,8 +2050,8 @@ mod unify {\n         }\n     }\n     fn unify_fn(cx: &@ctxt, e_proto: &ast::proto, a_proto: &ast::proto,\n-                expected: &t, actual: &t, expected_inputs: &[arg],\n-                expected_output: &t, actual_inputs: &[arg], actual_output: &t,\n+                expected: t, actual: t, expected_inputs: &[arg],\n+                expected_output: t, actual_inputs: &[arg], actual_output: t,\n                 expected_cf: &controlflow, actual_cf: &controlflow,\n                 _expected_constrs: &[@constr], actual_constrs: &[@constr]) ->\n        result {\n@@ -2092,9 +2092,9 @@ mod unify {\n         }\n     }\n     fn unify_native_fn(cx: &@ctxt, e_abi: &ast::native_abi,\n-                       a_abi: &ast::native_abi, expected: &t, actual: &t,\n-                       expected_inputs: &[arg], expected_output: &t,\n-                       actual_inputs: &[arg], actual_output: &t) -> result {\n+                       a_abi: &ast::native_abi, expected: t, actual: t,\n+                       expected_inputs: &[arg], expected_output: t,\n+                       actual_inputs: &[arg], actual_output: t) -> result {\n         if e_abi != a_abi { ret ures_err(terr_mismatch); }\n         let t =\n             unify_fn_common(cx, expected, actual, expected_inputs,\n@@ -2107,7 +2107,7 @@ mod unify {\n           }\n         }\n     }\n-    fn unify_obj(cx: &@ctxt, expected: &t, actual: &t,\n+    fn unify_obj(cx: &@ctxt, expected: t, actual: t,\n                  expected_meths: &[method], actual_meths: &[method]) ->\n        result {\n         let result_meths: [method] = [];\n@@ -2159,7 +2159,7 @@ mod unify {\n           _ { ret fix_ok(typ); }\n         }\n     }\n-    fn unify_step(cx: &@ctxt, expected: &t, actual: &t) -> result {\n+    fn unify_step(cx: &@ctxt, expected: t, actual: t) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -2506,7 +2506,7 @@ mod unify {\n           }\n         }\n     }\n-    fn unify(expected: &t, actual: &t, vb: &@var_bindings, tcx: &ty_ctxt) ->\n+    fn unify(expected: t, actual: t, vb: &@var_bindings, tcx: &ty_ctxt) ->\n        result {\n         let cx = @{vb: vb, tcx: tcx};\n         ret unify_step(cx, expected, actual);"}, {"sha": "ff5de77ba0b53358f8d380d701dffba6a8043378", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10269dfaeb223f28421eb4564b03aa31ef49c5a1/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=10269dfaeb223f28421eb4564b03aa31ef49c5a1", "patch": "@@ -883,7 +883,7 @@ mod collect {\n \n // Type unification\n mod unify {\n-    fn unify(fcx: &@fn_ctxt, expected: &ty::t, actual: &ty::t) ->\n+    fn unify(fcx: &@fn_ctxt, expected: ty::t, actual: ty::t) ->\n        ty::unify::result {\n         ret ty::unify::unify(expected, actual, fcx.var_bindings, fcx.ccx.tcx);\n     }\n@@ -892,7 +892,7 @@ mod unify {\n \n // FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n // instead of ty::struct.\n-fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n+fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: ty::t) -> ty::t {\n     let t1 = t;\n     while true {\n         alt structure_of(fcx, sp, t1) {\n@@ -926,8 +926,8 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: &ty::t) -> ty::t {\n     fail;\n }\n \n-fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: &ty::t,\n-                      expected: &ty::t) -> ty::t {\n+fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: ty::t,\n+                      expected: ty::t) -> ty::t {\n \n     // fns can be silently coerced to blocks when being used as\n     // function call or bind arguments, but not the reverse.\n@@ -963,17 +963,17 @@ fn resolve_type_vars_if_possible(fcx: &@fn_ctxt, typ: ty::t) -> ty::t {\n type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n \n mod demand {\n-    fn simple(fcx: &@fn_ctxt, sp: &span, expected: &ty::t, actual: &ty::t) ->\n+    fn simple(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t) ->\n        ty::t {\n         full(fcx, sp, expected, actual, [], false).ty\n     }\n-    fn block_coerce(fcx: &@fn_ctxt, sp: &span, expected: &ty::t,\n-                    actual: &ty::t) -> ty::t {\n+    fn block_coerce(fcx: &@fn_ctxt, sp: &span, expected: ty::t,\n+                    actual: ty::t) -> ty::t {\n         full(fcx, sp, expected, actual, [], true).ty\n     }\n \n-    fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: &ty::t,\n-                   actual: &ty::t, ty_param_substs_0: &[ty::t]) ->\n+    fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: ty::t,\n+                   actual: ty::t, ty_param_substs_0: &[ty::t]) ->\n        ty_param_substs_and_ty {\n         full(fcx, sp, expected, actual, ty_param_substs_0, false)\n     }\n@@ -998,7 +998,7 @@ mod demand {\n             simple(fcx, sp, ty_param_subst, t_0);\n         }\n \n-        fn mk_result(fcx: &@fn_ctxt, result_ty: &ty::t,\n+        fn mk_result(fcx: &@fn_ctxt, result_ty: ty::t,\n                      ty_param_subst_var_ids: &[int]) ->\n            ty_param_substs_and_ty {\n             let result_ty_param_substs: [ty::t] = [];\n@@ -1029,7 +1029,7 @@ mod demand {\n \n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(fcx: &@fn_ctxt, expected: &ty::t, actual: &ty::t) -> bool {\n+fn are_compatible(fcx: &@fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     alt unify::unify(fcx, expected, actual) {\n       ures_ok(_) { ret true; }\n       ures_err(_) { ret false; }\n@@ -1519,22 +1519,22 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n     }\n }\n \n-type unifier = fn(&@fn_ctxt, &span, &ty::t, &ty::t) -> ty::t;\n+type unifier = fn(&@fn_ctxt, &span, ty::t, ty::t) -> ty::t;\n \n fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n-    fn dummy_unify(_fcx: &@fn_ctxt, _sp: &span, _expected: &ty::t,\n-                   actual: &ty::t) -> ty::t {\n+    fn dummy_unify(_fcx: &@fn_ctxt, _sp: &span, _expected: ty::t,\n+                   actual: ty::t) -> ty::t {\n         actual\n     }\n     ret check_expr_with_unifier(fcx, expr, dummy_unify, 0u);\n }\n-fn check_expr_with(fcx: &@fn_ctxt, expr: &@ast::expr, expected: &ty::t) ->\n+fn check_expr_with(fcx: &@fn_ctxt, expr: &@ast::expr, expected: ty::t) ->\n    bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n-                           expected: &ty::t) -> bool {\n+                           expected: ty::t) -> bool {\n     //log_err \"typechecking expr \" + syntax::print::pprust::expr_to_str(expr);\n \n     // A generic function to factor out common logic from call and bind"}]}