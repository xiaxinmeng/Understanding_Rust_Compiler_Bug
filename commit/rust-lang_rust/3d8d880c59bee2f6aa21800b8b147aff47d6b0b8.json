{"sha": "3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOGQ4ODBjNTliZWUyZjZhYTIxODAwYjhiMTQ3YWZmNDdkNmIwYjg=", "commit": {"author": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-03-02T19:05:37Z"}, "committer": {"name": "Jeremy Kolb", "email": "kjeremy@gmail.com", "date": "2019-03-04T13:27:08Z"}, "message": "Use ImplItems instead of just Function", "tree": {"sha": "2508f84434ff6ccdc6a0bc0bdce6c5cc5e9f0bb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2508f84434ff6ccdc6a0bc0bdce6c5cc5e9f0bb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "html_url": "https://github.com/rust-lang/rust/commit/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "url": "https://api.github.com/repos/rust-lang/rust/commits/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4", "html_url": "https://github.com/rust-lang/rust/commit/49da9a3e814a42a2f4dea0cd79dbdae86bea5ce4"}], "stats": {"total": 105, "additions": 65, "deletions": 40}, "files": [{"sha": "39a2c7a496eb8ea93ceba776c08087cbc05a5923", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 48, "deletions": 34, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "patch": "@@ -29,6 +29,7 @@ use crate::{\n     Function, StructField, Path, Name,\n     FnSignature, AdtDef,\n     HirDatabase,\n+    ImplItem,\n     type_ref::{TypeRef, Mutability},\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n@@ -54,8 +55,8 @@ pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     Arc::new(ctx.resolve_all())\n }\n \n-#[derive(Debug, Copy, Clone)]\n-enum ExprOrPatId {\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub enum ExprOrPatId {\n     Expr(ExprId),\n     Pat(PatId),\n }\n@@ -79,8 +80,8 @@ pub struct InferenceResult {\n     method_resolutions: FxHashMap<ExprId, Function>,\n     /// For each field access expr, records the field it resolves to.\n     field_resolutions: FxHashMap<ExprId, StructField>,\n-    /// For each associated function call expr, records the function it resolves to\n-    assoc_fn_resolutions: FxHashMap<ExprId, Function>,\n+    /// For each associated item record what it resolves to\n+    assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n }\n@@ -92,8 +93,8 @@ impl InferenceResult {\n     pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n         self.field_resolutions.get(&expr).map(|it| *it)\n     }\n-    pub fn assoc_fn_resolutions(&self, expr: ExprId) -> Option<Function> {\n-        self.assoc_fn_resolutions.get(&expr).map(|it| *it)\n+    pub fn assoc_resolutions(&self, id: ExprOrPatId) -> Option<ImplItem> {\n+        self.assoc_resolutions.get(&id).map(|it| *it)\n     }\n }\n \n@@ -122,7 +123,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n-    assoc_fn_resolutions: FxHashMap<ExprId, Function>,\n+    assoc_resolutions: FxHashMap<ExprOrPatId, ImplItem>,\n     type_of_expr: ArenaMap<ExprId, Ty>,\n     type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n@@ -134,7 +135,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n             field_resolutions: FxHashMap::default(),\n-            assoc_fn_resolutions: FxHashMap::default(),\n+            assoc_resolutions: FxHashMap::default(),\n             type_of_expr: ArenaMap::default(),\n             type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n@@ -160,7 +161,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         InferenceResult {\n             method_resolutions: self.method_resolutions,\n             field_resolutions: self.field_resolutions,\n-            assoc_fn_resolutions: self.assoc_fn_resolutions,\n+            assoc_resolutions: self.assoc_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -178,8 +179,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         self.field_resolutions.insert(expr, field);\n     }\n \n-    fn write_assoc_fn_resolution(&mut self, expr: ExprId, func: Function) {\n-        self.assoc_fn_resolutions.insert(expr, func);\n+    fn write_assoc_resolution(&mut self, id: ExprOrPatId, item: ImplItem) {\n+        self.assoc_resolutions.insert(id, item);\n     }\n \n     fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n@@ -423,41 +424,54 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             // Attempt to find an impl_item for the type which has a name matching\n             // the current segment\n             log::debug!(\"looking for path segment: {:?}\", segment);\n-            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, |item| match item {\n-                crate::ImplItem::Method(func) => {\n-                    let sig = func.signature(self.db);\n-                    if segment.name == *sig.name() {\n-                        return Some(func.into());\n+            let item: crate::ModuleDef = ty.iterate_impl_items(self.db, |item| {\n+                let matching_def: Option<crate::ModuleDef> = match item {\n+                    crate::ImplItem::Method(func) => {\n+                        let sig = func.signature(self.db);\n+                        if segment.name == *sig.name() {\n+                            Some(func.into())\n+                        } else {\n+                            None\n+                        }\n                     }\n-                    None\n-                }\n \n-                crate::ImplItem::Const(konst) => {\n-                    let sig = konst.signature(self.db);\n-                    if segment.name == *sig.name() {\n-                        return Some(konst.into());\n+                    crate::ImplItem::Const(konst) => {\n+                        let sig = konst.signature(self.db);\n+                        if segment.name == *sig.name() {\n+                            Some(konst.into())\n+                        } else {\n+                            None\n+                        }\n                     }\n-                    None\n-                }\n \n-                // TODO: Resolve associated types\n-                crate::ImplItem::TypeAlias(_) => None,\n+                    // TODO: Resolve associated types\n+                    crate::ImplItem::TypeAlias(_) => None,\n+                };\n+                match matching_def {\n+                    Some(_) => {\n+                        self.write_assoc_resolution(id, item);\n+                        return matching_def;\n+                    }\n+                    None => None,\n+                }\n             })?;\n+\n+            /*\n+            if let ExprOrPatId::Expr(expr) = id {\n+                match typable {\n+                    TypableDef::Function(func) => self.write_assoc_fn_resolution(expr, func),\n+                    _ => {}\n+                };\n+            }\n+            */\n+\n             resolved = Resolution::Def(item.into());\n         }\n \n         match resolved {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n-\n-                if let ExprOrPatId::Expr(expr) = id {\n-                    match typable {\n-                        TypableDef::Function(func) => self.write_assoc_fn_resolution(expr, func),\n-                        _ => {}\n-                    };\n-                }\n-\n                 let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n                 let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n                 let ty = self.insert_type_vars(ty);"}, {"sha": "3b66483cb13c9c5cc30314ba6ab110725bc0c636", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     SyntaxNode,\n };\n use test_utils::tested_by;\n-use hir::Resolution;\n+use hir::{ImplItem, Resolution};\n \n use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n \n@@ -131,14 +131,25 @@ pub(crate) fn reference_definition(\n                         name_ref.syntax().ancestors().find_map(ast::PathExpr::cast)\n                     {\n                         let infer_result = function.infer(db);\n-                        let syntax_mapping = function.body_syntax_mapping(db);\n+                        let source_map = function.body_source_map(db);\n                         let expr = ast::Expr::cast(path_expr.syntax()).unwrap();\n \n-                        if let Some(func) = syntax_mapping\n+                        if let Some(res) = source_map\n                             .node_expr(expr)\n-                            .and_then(|it| infer_result.assoc_fn_resolutions(it))\n+                            .and_then(|it| infer_result.assoc_resolutions(it.into()))\n                         {\n-                            return Exact(NavigationTarget::from_function(db, func));\n+                            match res {\n+                                ImplItem::Method(f) => {\n+                                    return Exact(NavigationTarget::from_function(db, f));\n+                                }\n+                                ImplItem::Const(c) => {\n+                                    let (file, node) = c.source(db);\n+                                    let file = file.original_file(db);\n+                                    let node = &*node;\n+                                    return Exact(NavigationTarget::from_named(file, node));\n+                                }\n+                                _ => {}\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "bcd052c8bc4744f0036eb6d8b7c09f9fc8305fe5", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8d880c59bee2f6aa21800b8b147aff47d6b0b8/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=3d8d880c59bee2f6aa21800b8b147aff47d6b0b8", "patch": "@@ -531,7 +531,7 @@ mod tests {\n             \",\n         );\n         let hover = analysis.hover(position).unwrap().unwrap();\n-        assert_eq!(hover.info.first(), Some(\"```rust\\nfn new() -> Thing\\n```\"));\n+        assert_eq!(trim_markup_opt(hover.info.first()), Some(\"fn new() -> Thing\"));\n         assert_eq!(hover.info.is_exact(), true);\n     }\n }"}]}