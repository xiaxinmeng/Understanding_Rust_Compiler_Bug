{"sha": "2550243b4183783e463fbb0bc141ab77f2898e64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1NTAyNDNiNDE4Mzc4M2U0NjNmYmIwYmMxNDFhYjc3ZjI4OThlNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-25T19:02:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-25T19:02:44Z"}, "message": "auto merge of #17466 : nikomatsakis/rust/oibt, r=pcwalton\n\nMoves the vast majority of builtin bound checking out of type contents and into the trait system.\r\n\r\nThis is a preliminary step for a lot of follow-on work:\r\n\r\n- opt-in builtin types, obviously\r\n- generalized where clauses, because TypeContents has this notion that a type parameter has a single set of builtin kinds, but with where clauses it depends on context\r\n- generalized coherence, because this adds support for recursive trait selection\r\n\r\nUnfortunately I wasn't able to completely remove Type Contents from the front-end checking in this PR. It's still used by EUV to decide what gets moved and what doesn't.\r\n\r\nr? @pcwalton", "tree": {"sha": "a34d71e3e339cec76c0972b39da8ee2430d7bda0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a34d71e3e339cec76c0972b39da8ee2430d7bda0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2550243b4183783e463fbb0bc141ab77f2898e64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2550243b4183783e463fbb0bc141ab77f2898e64", "html_url": "https://github.com/rust-lang/rust/commit/2550243b4183783e463fbb0bc141ab77f2898e64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2550243b4183783e463fbb0bc141ab77f2898e64/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3be6a2fba8bc3382df4b5a4f9391d9b2f28de9d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3be6a2fba8bc3382df4b5a4f9391d9b2f28de9d1", "html_url": "https://github.com/rust-lang/rust/commit/3be6a2fba8bc3382df4b5a4f9391d9b2f28de9d1"}, {"sha": "6473909a1b1ff5c435d75d4df844c4b08dafcee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6473909a1b1ff5c435d75d4df844c4b08dafcee9", "html_url": "https://github.com/rust-lang/rust/commit/6473909a1b1ff5c435d75d4df844c4b08dafcee9"}], "stats": {"total": 2306, "additions": 1194, "deletions": 1112}, "files": [{"sha": "ed3fce775f31e7aa8d4a652d2299df608a2e37c0", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -59,6 +59,7 @@ CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n \n DEPS_core :=\n+DEPS_libc := core\n DEPS_rlibc := core\n DEPS_unicode := core\n DEPS_alloc := core libc native:jemalloc"}, {"sha": "1e67c8a13e9dfd910a48f9a2c9ccdf603a0f6b79", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -466,7 +466,7 @@ fn start(_argc: int, _argv: *const *const u8) -> int {\n // provided by libstd.\n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"sized\"] trait Sized { }\n+#[lang = \"fail_fmt\"] fn fail_fmt() -> ! { loop {} }\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -489,32 +489,28 @@ pub extern fn main(argc: int, argv: *const *const u8) -> int {\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"sized\"] trait Sized { }\n+#[lang = \"fail_fmt\"] fn fail_fmt() -> ! { loop {} }\n # // fn main() {} tricked you, rustdoc!\n ```\n \n \n The compiler currently makes a few assumptions about symbols which are available\n in the executable to call. Normally these functions are provided by the standard\n-xlibrary, but without it you must define your own.\n+library, but without it you must define your own.\n \n-The first of these two functions, `stack_exhausted`, is invoked whenever stack\n+The first of these three functions, `stack_exhausted`, is invoked whenever stack\n overflow is detected.  This function has a number of restrictions about how it\n can be called and what it must do, but if the stack limit register is not being\n maintained then a task always has an \"infinite stack\" and this function\n shouldn't get triggered.\n \n-The second of these two functions, `eh_personality`, is used by the failure\n-mechanisms of the compiler. This is often mapped to GCC's personality function\n-(see the [libstd implementation](std/rt/unwind/index.html) for more\n-information), but crates which do not trigger failure can be assured that this\n-function is never called.\n-\n-The final item in the example is a trait called `Sized`. This a trait\n-that represents data of a known static size: it is integral to the\n-Rust type system, and so the compiler expects the standard library to\n-provide it. Since you are not using the standard library, you have to\n-provide it yourself.\n+The second of these three functions, `eh_personality`, is used by the\n+failure mechanisms of the compiler. This is often mapped to GCC's\n+personality function (see the\n+[libstd implementation](std/rt/unwind/index.html) for more\n+information), but crates which do not trigger failure can be assured\n+that this function is never called. The final function, `fail_fmt`, is\n+also used by the failure mechanisms of the compiler.\n \n ## Using libcore\n \n@@ -694,7 +690,7 @@ fn main(argc: int, argv: *const *const u8) -> int {\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"sized\"] trait Sized {}\n+#[lang = \"fail_fmt\"] fn fail_fmt() -> ! { loop {} }\n ```\n \n Note the use of `abort`: the `exchange_malloc` lang item is assumed to"}, {"sha": "b0206e73e47990aeed09feed8268c1d9c4c0c98c", "filename": "src/libcore/kinds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibcore%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibcore%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fkinds.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -25,19 +25,19 @@ pub use self::Sync as Share;\n \n /// Types able to be transferred across task boundaries.\n #[lang=\"send\"]\n-pub trait Send {\n+pub trait Send for Sized? {\n     // empty.\n }\n \n /// Types with a constant size known at compile-time.\n #[lang=\"sized\"]\n-pub trait Sized {\n+pub trait Sized for Sized? {\n     // Empty.\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n #[lang=\"copy\"]\n-pub trait Copy {\n+pub trait Copy for Sized? {\n     // Empty.\n }\n \n@@ -87,7 +87,7 @@ pub trait Copy {\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n #[lang=\"sync\"]\n-pub trait Sync {\n+pub trait Sync for Sized? {\n     // Empty\n }\n "}, {"sha": "eabc02e3e26eba628528ddc859d72f55a5a745be", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -79,6 +79,8 @@\n #![allow(missing_doc)]\n #![allow(non_snake_case)]\n \n+extern crate core;\n+\n #[cfg(test)] extern crate std;\n #[cfg(test)] extern crate test;\n #[cfg(test)] extern crate native;"}, {"sha": "36ba28dfc2a806456c6aaea1a83f0f07dcf15557", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -58,8 +58,6 @@ register_diagnostics!(\n     E0039,\n     E0040,\n     E0041,\n-    E0042,\n-    E0043,\n     E0044,\n     E0045,\n     E0046,\n@@ -92,7 +90,6 @@ register_diagnostics!(\n     E0075,\n     E0076,\n     E0077,\n-    E0078,\n     E0079,\n     E0080,\n     E0081,\n@@ -130,7 +127,6 @@ register_diagnostics!(\n     E0121,\n     E0122,\n     E0124,\n-    E0125,\n     E0126,\n     E0127,\n     E0128,\n@@ -147,12 +143,6 @@ register_diagnostics!(\n     E0139,\n     E0140,\n     E0141,\n-    E0143,\n-    E0144,\n-    E0145,\n-    E0146,\n-    E0148,\n-    E0151,\n     E0152,\n     E0153,\n     E0154,"}, {"sha": "33e6579fb87dc7b8fd051b05079c8242a7e62346", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -17,7 +17,7 @@ use lint;\n use llvm::{ContextRef, ModuleRef};\n use metadata::common::LinkMeta;\n use metadata::creader;\n-use middle::{trans, stability, kind, ty, typeck, reachable};\n+use middle::{trans, stability, ty, typeck, reachable};\n use middle::dependency_format;\n use middle;\n use plugin::load::Plugins;\n@@ -462,8 +462,12 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     time(time_passes, \"rvalue checking\", (), |_|\n          middle::check_rvalues::check_crate(&ty_cx, krate));\n \n-    time(time_passes, \"kind checking\", (), |_|\n-         kind::check_crate(&ty_cx));\n+    // Avoid overwhelming user with errors if type checking failed.\n+    // I'm not sure how helpful this is, to be honest, but it avoids a\n+    // lot of annoying errors in the compile-fail tests (basically,\n+    // lint warnings and so on -- kindck used to do this abort, but\n+    // kindck is gone now). -nmatsakis\n+    ty_cx.sess.abort_if_errors();\n \n     let reachable_map =\n         time(time_passes, \"reachability checking\", (), |_|"}, {"sha": "c67f673879e69332635064c5deff86e619f0eaab", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -95,7 +95,6 @@ pub mod middle {\n     pub mod expr_use_visitor;\n     pub mod graph;\n     pub mod intrinsicck;\n-    pub mod kind;\n     pub mod lang_items;\n     pub mod liveness;\n     pub mod mem_categorization;"}, {"sha": "f5d4ece3bcccf859ff39983f1005ef8f113ceccd", "filename": "src/librustc/middle/kind.rs", "status": "removed", "additions": 0, "deletions": 404, "changes": 404, "blob_url": "https://github.com/rust-lang/rust/blob/3be6a2fba8bc3382df4b5a4f9391d9b2f28de9d1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3be6a2fba8bc3382df4b5a4f9391d9b2f28de9d1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=3be6a2fba8bc3382df4b5a4f9391d9b2f28de9d1", "patch": "@@ -1,404 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use middle::mem_categorization::Typer;\n-use middle::subst;\n-use middle::ty;\n-use middle::ty_fold::TypeFoldable;\n-use middle::ty_fold;\n-use util::ppaux::{ty_to_string};\n-use util::ppaux::UserString;\n-\n-use syntax::ast::*;\n-use syntax::attr;\n-use syntax::codemap::Span;\n-use syntax::print::pprust::{expr_to_string, ident_to_string};\n-use syntax::visit::Visitor;\n-use syntax::visit;\n-\n-// Kind analysis pass. This pass does some ad-hoc checks that are more\n-// convenient to do after type checking is complete and all checks are\n-// known. These are generally related to the builtin bounds `Copy` and\n-// `Sized`. Note that many of the builtin bound properties that used\n-// to be checked here are actually checked by trait checking these\n-// days.\n-\n-pub struct Context<'a,'tcx:'a> {\n-    tcx: &'a ty::ctxt<'tcx>,\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n-        check_expr(self, ex);\n-    }\n-\n-    fn visit_fn(&mut self, fk: visit::FnKind, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n-        check_fn(self, fk, fd, b, s, n);\n-    }\n-\n-    fn visit_ty(&mut self, t: &Ty) {\n-        check_ty(self, t);\n-    }\n-\n-    fn visit_item(&mut self, i: &Item) {\n-        check_item(self, i);\n-    }\n-\n-    fn visit_pat(&mut self, p: &Pat) {\n-        check_pat(self, p);\n-    }\n-}\n-\n-pub fn check_crate(tcx: &ty::ctxt) {\n-    let mut ctx = Context {\n-        tcx: tcx,\n-    };\n-    visit::walk_crate(&mut ctx, tcx.map.krate());\n-    tcx.sess.abort_if_errors();\n-}\n-\n-struct EmptySubstsFolder<'a, 'tcx: 'a> {\n-    tcx: &'a ty::ctxt<'tcx>\n-}\n-impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for EmptySubstsFolder<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n-        self.tcx\n-    }\n-    fn fold_substs(&mut self, _: &subst::Substs) -> subst::Substs {\n-        subst::Substs::empty()\n-    }\n-}\n-\n-fn check_struct_safe_for_destructor(cx: &mut Context,\n-                                    span: Span,\n-                                    struct_did: DefId) {\n-    let struct_tpt = ty::lookup_item_type(cx.tcx, struct_did);\n-    if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n-      && !struct_tpt.generics.has_region_params(subst::TypeSpace) {\n-        let mut folder = EmptySubstsFolder { tcx: cx.tcx };\n-        if !ty::type_is_sendable(cx.tcx, struct_tpt.ty.fold_with(&mut folder)) {\n-            span_err!(cx.tcx.sess, span, E0125,\n-                      \"cannot implement a destructor on a \\\n-                       structure or enumeration that does not satisfy Send\");\n-            span_note!(cx.tcx.sess, span,\n-                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n-                        to force the compiler to allow this\");\n-        }\n-    } else {\n-        span_err!(cx.tcx.sess, span, E0141,\n-                  \"cannot implement a destructor on a structure \\\n-                   with type parameters\");\n-        span_note!(cx.tcx.sess, span,\n-                   \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n-                    to force the compiler to allow this\");\n-    }\n-}\n-\n-fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_type: &Ty) {\n-    let ast_trait_def = *cx.tcx.def_map.borrow()\n-                              .find(&trait_ref.ref_id)\n-                              .expect(\"trait ref not in def map!\");\n-    let trait_def_id = ast_trait_def.def_id();\n-\n-    // If this is a destructor, check kinds.\n-    if cx.tcx.lang_items.drop_trait() == Some(trait_def_id) &&\n-        !attr::contains_name(it.attrs.as_slice(), \"unsafe_destructor\")\n-    {\n-        match self_type.node {\n-            TyPath(_, ref bounds, path_node_id) => {\n-                assert!(bounds.is_none());\n-                let struct_def = cx.tcx.def_map.borrow().get_copy(&path_node_id);\n-                let struct_did = struct_def.def_id();\n-                check_struct_safe_for_destructor(cx, self_type.span, struct_did);\n-            }\n-            _ => {\n-                cx.tcx.sess.span_bug(self_type.span,\n-                    \"the self type for the Drop trait impl is not a path\");\n-            }\n-        }\n-    }\n-}\n-\n-fn check_item(cx: &mut Context, item: &Item) {\n-    match item.node {\n-        ItemImpl(_, Some(ref trait_ref), ref self_type, _) => {\n-            check_impl_of_trait(cx, item, trait_ref, &**self_type);\n-        }\n-        _ => {}\n-    }\n-\n-    visit::walk_item(cx, item)\n-}\n-\n-// Yields the appropriate function to check the kind of closed over\n-// variables. `id` is the NodeId for some expression that creates the\n-// closure.\n-fn with_appropriate_checker(cx: &Context,\n-                            id: NodeId,\n-                            fn_span: Span,\n-                            b: |checker: |&Context, &ty::Freevar||) {\n-    fn check_for_uniq(cx: &Context,\n-                      fn_span: Span,\n-                      fv: &ty::Freevar,\n-                      bounds: ty::BuiltinBounds) {\n-        // all captured data must be owned, regardless of whether it is\n-        // moved in or copied in.\n-        let id = fv.def.def_id().node;\n-        let var_t = ty::node_id_to_type(cx.tcx, id);\n-\n-        check_freevar_bounds(cx, fn_span, fv.span, var_t, bounds, None);\n-    }\n-\n-    fn check_for_block(cx: &Context,\n-                       fn_span: Span,\n-                       fn_id: NodeId,\n-                       fv: &ty::Freevar,\n-                       bounds: ty::BuiltinBounds) {\n-        let id = fv.def.def_id().node;\n-        let var_t = ty::node_id_to_type(cx.tcx, id);\n-        let upvar_id = ty::UpvarId { var_id: id, closure_expr_id: fn_id };\n-        let upvar_borrow = cx.tcx.upvar_borrow(upvar_id);\n-        let implicit_borrowed_type =\n-            ty::mk_rptr(cx.tcx,\n-                        upvar_borrow.region,\n-                        ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n-                                 ty: var_t });\n-        check_freevar_bounds(cx, fn_span, fv.span, implicit_borrowed_type,\n-                             bounds, Some(var_t));\n-    }\n-\n-    fn check_for_bare(cx: &Context, fv: &ty::Freevar) {\n-        span_err!(cx.tcx.sess, fv.span, E0143,\n-                  \"can't capture dynamic environment in a fn item; \\\n-                   use the || {} closure form instead\", \"{ ... }\");\n-    } // same check is done in resolve.rs, but shouldn't be done\n-\n-    let fty = ty::node_id_to_type(cx.tcx, id);\n-    match ty::get(fty).sty {\n-        ty::ty_closure(box ty::ClosureTy {\n-            store: ty::UniqTraitStore,\n-            bounds: bounds,\n-            ..\n-        }) => {\n-            b(|cx, fv| check_for_uniq(cx, fn_span, fv,\n-                                      bounds.builtin_bounds))\n-        }\n-\n-        ty::ty_closure(box ty::ClosureTy {\n-            store: ty::RegionTraitStore(..), bounds, ..\n-        }) => {\n-            b(|cx, fv| check_for_block(cx, fn_span, id, fv,\n-                                       bounds.builtin_bounds))\n-        }\n-\n-        ty::ty_bare_fn(_) => {\n-            b(check_for_bare)\n-        }\n-\n-        ty::ty_unboxed_closure(..) => {}\n-\n-        ref s => {\n-            cx.tcx.sess.bug(format!(\"expect fn type in kind checker, not \\\n-                                     {:?}\",\n-                                    s).as_slice());\n-        }\n-    }\n-}\n-\n-// Check that the free variables used in a shared/sendable closure conform\n-// to the copy/move kind bounds. Then recursively check the function body.\n-fn check_fn(\n-    cx: &mut Context,\n-    fk: visit::FnKind,\n-    decl: &FnDecl,\n-    body: &Block,\n-    sp: Span,\n-    fn_id: NodeId) {\n-\n-    // <Check kinds on free variables:\n-    with_appropriate_checker(cx, fn_id, sp, |chk| {\n-        ty::with_freevars(cx.tcx, fn_id, |freevars| {\n-            for fv in freevars.iter() {\n-                chk(cx, fv);\n-            }\n-        });\n-    });\n-\n-    match fk {\n-        visit::FkFnBlock(..) => {\n-            visit::walk_fn(cx, fk, decl, body, sp)\n-        }\n-        visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            visit::walk_fn(cx, fk, decl, body, sp);\n-        }\n-    }\n-}\n-\n-pub fn check_expr(cx: &mut Context, e: &Expr) {\n-    debug!(\"kind::check_expr({})\", expr_to_string(e));\n-\n-    match e.node {\n-        ExprRepeat(ref element, ref count_expr) => {\n-            let count = ty::eval_repeat_count(cx.tcx, &**count_expr);\n-            if count > 1 {\n-                let element_ty = ty::expr_ty(cx.tcx, &**element);\n-                check_copy(cx, element_ty, element.span,\n-                           \"repeated element will be copied\");\n-            }\n-        }\n-        ExprAssign(ref lhs, _) |\n-        ExprAssignOp(_, ref lhs, _) => {\n-            let lhs_ty = ty::expr_ty(cx.tcx, &**lhs);\n-            if !ty::type_is_sized(cx.tcx, lhs_ty) {\n-                cx.tcx.sess.span_err(lhs.span, \"dynamically sized type on lhs of assignment\");\n-            }\n-        }\n-        ExprStruct(..) => {\n-            let e_ty = ty::expr_ty(cx.tcx, e);\n-            if !ty::type_is_sized(cx.tcx, e_ty) {\n-                cx.tcx.sess.span_err(e.span, \"trying to initialise a dynamically sized struct\");\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    visit::walk_expr(cx, e);\n-}\n-\n-fn check_ty(cx: &mut Context, aty: &Ty) {\n-    match aty.node {\n-        TyPath(_, _, id) => {\n-            match cx.tcx.item_substs.borrow().find(&id) {\n-                None => {}\n-                Some(ref item_substs) => {\n-                    let def_map = cx.tcx.def_map.borrow();\n-                    let did = def_map.get_copy(&id).def_id();\n-                    let generics = ty::lookup_item_type(cx.tcx, did).generics;\n-                    for def in generics.types.iter() {\n-                        let ty = *item_substs.substs.types.get(def.space,\n-                                                               def.index);\n-                        check_typaram_bounds(cx, aty.span, ty, def);\n-                    }\n-                }\n-            }\n-        }\n-        _ => {}\n-    }\n-\n-    visit::walk_ty(cx, aty);\n-}\n-\n-// Calls \"any_missing\" if any bounds were missing.\n-pub fn check_builtin_bounds(cx: &Context,\n-                            ty: ty::t,\n-                            bounds: ty::BuiltinBounds,\n-                            any_missing: |ty::BuiltinBounds|) {\n-    let kind = ty::type_contents(cx.tcx, ty);\n-    let mut missing = ty::empty_builtin_bounds();\n-    for bound in bounds.iter() {\n-        if !kind.meets_builtin_bound(cx.tcx, bound) {\n-            missing.add(bound);\n-        }\n-    }\n-    if !missing.is_empty() {\n-        any_missing(missing);\n-    }\n-}\n-\n-pub fn check_typaram_bounds(cx: &Context,\n-                            sp: Span,\n-                            ty: ty::t,\n-                            type_param_def: &ty::TypeParameterDef) {\n-    check_builtin_bounds(cx,\n-                         ty,\n-                         type_param_def.bounds.builtin_bounds,\n-                         |missing| {\n-        span_err!(cx.tcx.sess, sp, E0144,\n-                  \"instantiating a type parameter with an incompatible type \\\n-                   `{}`, which does not fulfill `{}`\",\n-                   ty_to_string(cx.tcx, ty),\n-                   missing.user_string(cx.tcx));\n-    });\n-}\n-\n-pub fn check_freevar_bounds(cx: &Context, fn_span: Span, sp: Span, ty: ty::t,\n-                            bounds: ty::BuiltinBounds, referenced_ty: Option<ty::t>)\n-{\n-    check_builtin_bounds(cx, ty, bounds, |missing| {\n-        // Will be Some if the freevar is implicitly borrowed (stack closure).\n-        // Emit a less mysterious error message in this case.\n-        match referenced_ty {\n-            Some(rty) => {\n-                span_err!(cx.tcx.sess, sp, E0145,\n-                    \"cannot implicitly borrow variable of type `{}` in a \\\n-                     bounded stack closure (implicit reference does not fulfill `{}`)\",\n-                    ty_to_string(cx.tcx, rty), missing.user_string(cx.tcx));\n-            }\n-            None => {\n-                span_err!(cx.tcx.sess, sp, E0146,\n-                    \"cannot capture variable of type `{}`, which does \\\n-                     not fulfill `{}`, in a bounded closure\",\n-                    ty_to_string(cx.tcx, ty), missing.user_string(cx.tcx));\n-            }\n-        }\n-        span_note!(cx.tcx.sess, fn_span,\n-            \"this closure's environment must satisfy `{}`\",\n-            bounds.user_string(cx.tcx));\n-    });\n-}\n-\n-fn check_copy(cx: &Context, ty: ty::t, sp: Span, reason: &str) {\n-    debug!(\"type_contents({})={}\",\n-           ty_to_string(cx.tcx, ty),\n-           ty::type_contents(cx.tcx, ty).to_string());\n-    if ty::type_moves_by_default(cx.tcx, ty) {\n-        span_err!(cx.tcx.sess, sp, E0148,\n-            \"copying a value of non-copyable type `{}`\",\n-            ty_to_string(cx.tcx, ty));\n-        span_note!(cx.tcx.sess, sp, \"{}\", reason.as_slice());\n-    }\n-}\n-\n-// Ensure that `ty` has a statically known size (i.e., it has the `Sized` bound).\n-fn check_sized(tcx: &ty::ctxt, ty: ty::t, name: String, sp: Span) {\n-    if !ty::type_is_sized(tcx, ty) {\n-        span_err!(tcx.sess, sp, E0151,\n-            \"variable `{}` has dynamically sized type `{}`\",\n-            name, ty_to_string(tcx, ty));\n-    }\n-}\n-\n-// Check that any variables in a pattern have types with statically known size.\n-fn check_pat(cx: &mut Context, pat: &Pat) {\n-    let var_name = match pat.node {\n-        PatWild(PatWildSingle) => Some(\"_\".to_string()),\n-        PatIdent(_, ref path1, _) => Some(ident_to_string(&path1.node).to_string()),\n-        _ => None\n-    };\n-\n-    match var_name {\n-        Some(name) => {\n-            let types = cx.tcx.node_types.borrow();\n-            let ty = types.find(&(pat.id as uint));\n-            match ty {\n-                Some(ty) => {\n-                    debug!(\"kind: checking sized-ness of variable {}: {}\",\n-                           name, ty_to_string(cx.tcx, *ty));\n-                    check_sized(cx.tcx, *ty, name, pat.span);\n-                }\n-                None => {} // extern fn args\n-            }\n-        }\n-        None => {}\n-    }\n-\n-    visit::walk_pat(cx, pat);\n-}"}, {"sha": "9b179d3e8951728831136973cedc3ee22110cb60", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -10,9 +10,9 @@\n \n /*! See `doc.rs` for high-level documentation */\n \n-use super::DUMMY_CAUSE;\n use super::{EvaluatedToMatch, EvaluatedToAmbiguity, EvaluatedToUnmatch};\n use super::{evaluate_impl};\n+use super::ObligationCause;\n use super::util;\n \n use middle::subst;\n@@ -21,7 +21,6 @@ use middle::ty;\n use middle::typeck::infer::InferCtxt;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n-use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n pub fn impl_can_satisfy(infcx: &InferCtxt,\n@@ -40,8 +39,7 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n-    let unboxed_closures = DefIdMap::new();\n-    match evaluate_impl(infcx, &param_env, &unboxed_closures, DUMMY_CAUSE,\n+    match evaluate_impl(infcx, &param_env, infcx.tcx, ObligationCause::dummy(),\n                         impl2_def_id, impl1_self_ty) {\n         EvaluatedToMatch | EvaluatedToAmbiguity => true,\n         EvaluatedToUnmatch => false,"}, {"sha": "c0caa1d7c79fb638968938fefa552091cb8613a7", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 118, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::mem_categorization::Typer;\n use middle::ty;\n-use middle::typeck::infer::{InferCtxt, skolemize};\n-use util::nodemap::DefIdMap;\n+use middle::typeck::infer::InferCtxt;\n use util::ppaux::Repr;\n \n use super::CodeAmbiguity;\n use super::Obligation;\n use super::FulfillmentError;\n use super::CodeSelectionError;\n use super::select::SelectionContext;\n-use super::Unimplemented;\n \n /**\n  * The fulfillment context is used to drive trait resolution.  It\n@@ -36,17 +35,12 @@ pub struct FulfillmentContext {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     trait_obligations: Vec<Obligation>,\n-\n-    // For semi-hacky reasons (see FIXME below) we keep the builtin\n-    // trait obligations segregated.\n-    builtin_obligations: Vec<Obligation>,\n }\n \n impl FulfillmentContext {\n     pub fn new() -> FulfillmentContext {\n         FulfillmentContext {\n             trait_obligations: Vec::new(),\n-            builtin_obligations: Vec::new()\n         }\n     }\n \n@@ -55,24 +49,16 @@ impl FulfillmentContext {\n                                obligation: Obligation)\n     {\n         debug!(\"register_obligation({})\", obligation.repr(tcx));\n-        match tcx.lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n-            Some(_) => {\n-                self.builtin_obligations.push(obligation);\n-            }\n-            None => {\n-                self.trait_obligations.push(obligation);\n-            }\n-        }\n+        self.trait_obligations.push(obligation);\n     }\n \n-    pub fn select_all_or_error(&mut self,\n-                               infcx: &InferCtxt,\n-                               param_env: &ty::ParameterEnvironment,\n-                               unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n-                               -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_all_or_error<'a,'tcx>(&mut self,\n+                                        infcx: &InferCtxt<'a,'tcx>,\n+                                        param_env: &ty::ParameterEnvironment,\n+                                        typer: &Typer<'tcx>)\n+                                        -> Result<(),Vec<FulfillmentError>>\n     {\n-        try!(self.select_where_possible(infcx, param_env,\n-                                        unboxed_closures));\n+        try!(self.select_where_possible(infcx, param_env, typer));\n \n         // Anything left is ambiguous.\n         let errors: Vec<FulfillmentError> =\n@@ -88,15 +74,14 @@ impl FulfillmentContext {\n         }\n     }\n \n-    pub fn select_where_possible(&mut self,\n-                                 infcx: &InferCtxt,\n-                                 param_env: &ty::ParameterEnvironment,\n-                                 unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n-                                 -> Result<(),Vec<FulfillmentError>>\n+    pub fn select_where_possible<'a,'tcx>(&mut self,\n+                                          infcx: &InferCtxt<'a,'tcx>,\n+                                          param_env: &ty::ParameterEnvironment,\n+                                          typer: &Typer<'tcx>)\n+                                          -> Result<(),Vec<FulfillmentError>>\n     {\n         let tcx = infcx.tcx;\n-        let selcx = SelectionContext::new(infcx, param_env,\n-                                          unboxed_closures);\n+        let mut selcx = SelectionContext::new(infcx, param_env, typer);\n \n         debug!(\"select_where_possible({} obligations) start\",\n                self.trait_obligations.len());\n@@ -158,92 +143,4 @@ impl FulfillmentContext {\n             Err(errors)\n         }\n     }\n-\n-    pub fn check_builtin_bound_obligations(\n-        &self,\n-        infcx: &InferCtxt)\n-        -> Result<(),Vec<FulfillmentError>>\n-    {\n-        let tcx = infcx.tcx;\n-        let mut errors = Vec::new();\n-        debug!(\"check_builtin_bound_obligations\");\n-        for obligation in self.builtin_obligations.iter() {\n-            debug!(\"obligation={}\", obligation.repr(tcx));\n-\n-            let def_id = obligation.trait_ref.def_id;\n-            let bound = match tcx.lang_items.to_builtin_kind(def_id) {\n-                Some(bound) => { bound }\n-                None => { continue; }\n-            };\n-\n-            let unskol_self_ty = obligation.self_ty();\n-\n-            // Skolemize the self-type so that it no longer contains\n-            // inference variables. Note that this also replaces\n-            // regions with 'static. You might think that this is not\n-            // ok, because checking whether something is `Send`\n-            // implies checking whether it is 'static: that's true,\n-            // but in fact the region bound is fed into region\n-            // inference separately and enforced there (and that has\n-            // even already been done before this code executes,\n-            // generally speaking).\n-            let self_ty = skolemize(infcx, unskol_self_ty);\n-\n-            debug!(\"bound={} self_ty={}\", bound, self_ty.repr(tcx));\n-            if ty::type_is_error(self_ty) {\n-                // Indicates an error that was/will-be\n-                // reported elsewhere.\n-                continue;\n-            }\n-\n-            // Determine if builtin bound is met.\n-            let tc = ty::type_contents(tcx, self_ty);\n-            debug!(\"tc={}\", tc);\n-            let met = match bound {\n-                ty::BoundSend   => tc.is_sendable(tcx),\n-                ty::BoundSized  => tc.is_sized(tcx),\n-                ty::BoundCopy   => tc.is_copy(tcx),\n-                ty::BoundSync   => tc.is_sync(tcx),\n-            };\n-\n-            if met {\n-                continue;\n-            }\n-\n-            // FIXME -- This is kind of a hack: it requently happens\n-            // that some earlier error prevents types from being fully\n-            // inferred, and then we get a bunch of uninteresting\n-            // errors saying something like \"<generic #0> doesn't\n-            // implement Sized\".  It may even be true that we could\n-            // just skip over all checks where the self-ty is an\n-            // inference variable, but I was afraid that there might\n-            // be an inference variable created, registered as an\n-            // obligation, and then never forced by writeback, and\n-            // hence by skipping here we'd be ignoring the fact that\n-            // we don't KNOW the type works out. Though even that\n-            // would probably be harmless, given that we're only\n-            // talking about builtin traits, which are known to be\n-            // inhabited. But in any case I just threw in this check\n-            // for has_errors() to be sure that compilation isn't\n-            // happening anyway. In that case, why inundate the user.\n-            if ty::type_needs_infer(self_ty) &&\n-                tcx.sess.has_errors()\n-            {\n-                debug!(\"skipping printout because self_ty={}\",\n-                       self_ty.repr(tcx));\n-                continue;\n-            }\n-\n-            errors.push(\n-                FulfillmentError::new(\n-                    (*obligation).clone(),\n-                    CodeSelectionError(Unimplemented)));\n-        }\n-\n-        if errors.is_empty() {\n-            Ok(())\n-        } else {\n-            Err(errors)\n-        }\n-    }\n }"}, {"sha": "9d66108cfc99051f2073cba36fb46a36f41afa75", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 38, "deletions": 49, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -12,16 +12,17 @@\n  * Trait Resolution. See doc.rs.\n  */\n \n+use middle::mem_categorization::Typer;\n use middle::subst;\n use middle::ty;\n use middle::typeck::infer::InferCtxt;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n-use util::nodemap::DefIdMap;\n \n pub use self::fulfill::FulfillmentContext;\n pub use self::select::SelectionContext;\n+pub use self::select::SelectionCache;\n pub use self::util::supertraits;\n pub use self::util::transitive_bounds;\n pub use self::util::Supertraits;\n@@ -68,16 +69,22 @@ pub enum ObligationCauseCode {\n     /// Obligation incurred due to an object cast.\n     ObjectCastObligation(/* Object type */ ty::t),\n \n+    /// To implement drop, type must be sendable.\n+    DropTrait,\n+\n     /// Various cases where expressions must be sized/copy/etc:\n     AssignmentLhsSized,        // L = X implies that L is Sized\n     StructInitializerSized,    // S { ... } must be Sized\n     VariableType(ast::NodeId), // Type of each variable must be Sized\n     RepeatVec,                 // [T,..n] --> T must be Copy\n-}\n \n-pub static DUMMY_CAUSE: ObligationCause =\n-    ObligationCause { span: DUMMY_SP,\n-                      code: MiscObligation };\n+    // Captures of variable the given id by a closure (span is the\n+    // span of the closure)\n+    ClosureCapture(ast::NodeId, Span),\n+\n+    // Types of fields (other than the last) in a struct must be sized.\n+    FieldSized,\n+}\n \n pub type Obligations = subst::VecPerParamSpace<Obligation>;\n \n@@ -208,50 +215,29 @@ pub struct VtableParamData {\n     pub bound: Rc<ty::TraitRef>,\n }\n \n-pub fn try_select_obligation(infcx: &InferCtxt,\n-                             param_env: &ty::ParameterEnvironment,\n-                             unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n-                             obligation: &Obligation)\n-                             -> SelectionResult<Selection>\n-{\n-    /*!\n-     * Attempts to select the impl/bound/etc for the obligation\n-     * given. Returns `None` if we are unable to resolve, either\n-     * because of ambiguity or due to insufficient inference.  Note\n-     * that selection is a shallow process and hence the result may\n-     * contain nested obligations that must be resolved. The caller is\n-     * responsible for ensuring that those get resolved. (But see\n-     * `try_select_obligation_deep` below.)\n-     */\n-\n-    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n-    selcx.select(obligation)\n-}\n-\n-pub fn evaluate_obligation(infcx: &InferCtxt,\n-                           param_env: &ty::ParameterEnvironment,\n-                           obligation: &Obligation,\n-                           unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n-                           -> EvaluationResult\n+pub fn evaluate_obligation<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                    param_env: &ty::ParameterEnvironment,\n+                                    obligation: &Obligation,\n+                                    typer: &Typer<'tcx>)\n+                                    -> EvaluationResult\n {\n     /*!\n      * Attempts to resolve the obligation given. Returns `None` if\n      * we are unable to resolve, either because of ambiguity or\n      * due to insufficient inference.\n      */\n \n-    let selcx = select::SelectionContext::new(infcx, param_env,\n-                                              unboxed_closures);\n+    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n     selcx.evaluate_obligation(obligation)\n }\n \n-pub fn evaluate_impl(infcx: &InferCtxt,\n-                     param_env: &ty::ParameterEnvironment,\n-                     unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n-                     cause: ObligationCause,\n-                     impl_def_id: ast::DefId,\n-                     self_ty: ty::t)\n-                     -> EvaluationResult\n+pub fn evaluate_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                              param_env: &ty::ParameterEnvironment,\n+                              typer: &Typer<'tcx>,\n+                              cause: ObligationCause,\n+                              impl_def_id: ast::DefId,\n+                              self_ty: ty::t)\n+                              -> EvaluationResult\n {\n     /*!\n      * Tests whether the impl `impl_def_id` can be applied to the self\n@@ -264,17 +250,17 @@ pub fn evaluate_impl(infcx: &InferCtxt,\n      *   (yes/no/unknown).\n      */\n \n-    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n+    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n     selcx.evaluate_impl(impl_def_id, cause, self_ty)\n }\n \n-pub fn select_inherent_impl(infcx: &InferCtxt,\n-                            param_env: &ty::ParameterEnvironment,\n-                            unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n-                            cause: ObligationCause,\n-                            impl_def_id: ast::DefId,\n-                            self_ty: ty::t)\n-                            -> SelectionResult<VtableImplData<Obligation>>\n+pub fn select_inherent_impl<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                     param_env: &ty::ParameterEnvironment,\n+                                     typer: &Typer<'tcx>,\n+                                     cause: ObligationCause,\n+                                     impl_def_id: ast::DefId,\n+                                     self_ty: ty::t)\n+                                     -> SelectionResult<VtableImplData<Obligation>>\n {\n     /*!\n      * Matches the self type of the inherent impl `impl_def_id`\n@@ -293,8 +279,7 @@ pub fn select_inherent_impl(infcx: &InferCtxt,\n     // `try_resolve_obligation()`.\n     assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());\n \n-    let selcx = select::SelectionContext::new(infcx, param_env,\n-                                              unboxed_closures);\n+    let mut selcx = select::SelectionContext::new(infcx, param_env, typer);\n     selcx.select_inherent_impl(impl_def_id, cause, self_ty)\n }\n \n@@ -376,6 +361,10 @@ impl ObligationCause {\n     pub fn misc(span: Span) -> ObligationCause {\n         ObligationCause { span: span, code: MiscObligation }\n     }\n+\n+    pub fn dummy() -> ObligationCause {\n+        ObligationCause { span: DUMMY_SP, code: MiscObligation }\n+    }\n }\n \n impl<N> Vtable<N> {"}, {"sha": "63fbeb797c4d46e37ea80f8228b1551083d6ab8e", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 711, "deletions": 184, "changes": 895, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -21,32 +21,44 @@ use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n use super::{VtableImplData, VtableParamData};\n use super::{util};\n \n+use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty;\n+use middle::ty_fold::TypeFoldable;\n use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n-use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n+use std::cell::RefCell;\n+use std::collections::hashmap::HashMap;\n use std::rc::Rc;\n use syntax::ast;\n-use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     param_env: &'cx ty::ParameterEnvironment,\n-    unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>,\n+    typer: &'cx Typer<'tcx>+'cx,\n+    skolemizer: TypeSkolemizer<'cx, 'tcx>,\n }\n \n-// pub struct SelectionCache {\n-//     hashmap: RefCell<HashMap<CacheKey, Candidate>>,\n-// }\n+// A stack that walks back up the stack frame.\n+struct ObligationStack<'prev> {\n+    obligation: &'prev Obligation,\n+    skol_obligation_self_ty: ty::t,\n+    previous: Option<&'prev ObligationStack<'prev>>\n+}\n+\n+pub struct SelectionCache {\n+    hashmap: RefCell<HashMap<CacheKey, SelectionResult<Candidate>>>,\n+}\n \n-// #[deriving(Hash,Eq,PartialEq)]\n-// struct CacheKey {\n-//     trait_def_id: ast::DefId,\n-//     skol_obligation_self_ty: ty::t,\n-// }\n+#[deriving(Hash,Eq,PartialEq)]\n+struct CacheKey {\n+    trait_def_id: ast::DefId,\n+    skol_obligation_self_ty: ty::t,\n+}\n \n+#[deriving(PartialEq,Eq)]\n enum MatchResult<T> {\n     Matched(T),\n     AmbiguousMatch,\n@@ -86,7 +98,8 @@ enum Candidate {\n     MatchedParamCandidate(VtableParamData),\n     AmbiguousParamCandidate,\n     Impl(ImplCandidate),\n-    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId)\n+    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId),\n+    ErrorCandidate,\n }\n \n #[deriving(Clone)]\n@@ -98,10 +111,14 @@ enum ImplCandidate {\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n                param_env: &'cx ty::ParameterEnvironment,\n-               unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>)\n+               typer: &'cx Typer<'tcx>)\n                -> SelectionContext<'cx, 'tcx> {\n-        SelectionContext { infcx: infcx, param_env: param_env,\n-                           unboxed_closures: unboxed_closures }\n+        SelectionContext {\n+            infcx: infcx,\n+            param_env: param_env,\n+            typer: typer,\n+            skolemizer: infcx.skolemizer(),\n+        }\n     }\n \n     pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n@@ -123,7 +140,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    pub fn select(&self, obligation: &Obligation) -> SelectionResult<Selection> {\n+    pub fn select(&mut self, obligation: &Obligation) -> SelectionResult<Selection> {\n         /*!\n          * Evaluates whether the obligation can be satisfied. Returns\n          * an indication of whether the obligation can be satisfied\n@@ -133,13 +150,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"select({})\", obligation.repr(self.tcx()));\n \n-        match try!(self.candidate_from_obligation(obligation)) {\n+        let stack = self.new_stack(obligation);\n+        match try!(self.candidate_from_obligation(&stack)) {\n             None => Ok(None),\n             Some(candidate) => self.confirm_candidate(obligation, candidate),\n         }\n     }\n \n-    pub fn select_inherent_impl(&self,\n+    pub fn select_inherent_impl(&mut self,\n                                 impl_def_id: ast::DefId,\n                                 obligation_cause: ObligationCause,\n                                 obligation_self_ty: ty::t)\n@@ -177,7 +195,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // applied to particular types. It skips the \"confirmation\" step and\n     // hence completely ignores output type parameters.\n \n-    pub fn evaluate_obligation(&self,\n+    pub fn evaluate_obligation(&mut self,\n                                obligation: &Obligation)\n                                -> EvaluationResult\n     {\n@@ -189,14 +207,70 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n-        match self.candidate_from_obligation(obligation) {\n+        let stack = self.new_stack(obligation);\n+        match self.candidate_from_obligation(&stack) {\n             Ok(Some(c)) => c.to_evaluation_result(),\n             Ok(None) => EvaluatedToAmbiguity,\n             Err(_) => EvaluatedToUnmatch,\n         }\n     }\n \n-    pub fn evaluate_impl(&self,\n+    fn evaluate_builtin_bound_recursively(&mut self,\n+                                          bound: ty::BuiltinBound,\n+                                          previous_stack: &ObligationStack,\n+                                          ty: ty::t)\n+                                          -> EvaluationResult\n+    {\n+        let obligation =\n+            util::obligation_for_builtin_bound(\n+                self.tcx(),\n+                previous_stack.obligation.cause,\n+                bound,\n+                previous_stack.obligation.recursion_depth + 1,\n+                ty);\n+        self.evaluate_obligation_recursively(previous_stack, &obligation)\n+    }\n+\n+    fn evaluate_obligation_recursively(&mut self,\n+                                       previous_stack: &ObligationStack,\n+                                       obligation: &Obligation)\n+                                       -> EvaluationResult\n+    {\n+        debug!(\"evaluate_obligation_recursively({})\",\n+               obligation.repr(self.tcx()));\n+\n+        // If there is any previous entry on the stack that precisely\n+        // matches this obligation, then we can assume that the\n+        // obligation is satisfied for now (still all other conditions\n+        // must be met of course). One obvious case this comes up is\n+        // marker traits like `Send`. Think of a a linked list:\n+        //\n+        //    struct List<T> { data: T, next: Option<Box<List<T>>> {\n+        //\n+        // `Box<List<T>>` will be `Send` if `T` is `Send` and\n+        // `Option<Box<List<T>>>` is `Send`, and in turn\n+        // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n+        // `Send`.\n+        if\n+            previous_stack.iter()\n+            .filter(|e| e.obligation.trait_ref.def_id == obligation.trait_ref.def_id)\n+            .find(|e| self.match_self_types(obligation.cause,\n+                                            e.skol_obligation_self_ty,\n+                                            obligation.self_ty()) == Matched(()))\n+            .is_some()\n+        {\n+            return EvaluatedToMatch;\n+        }\n+\n+        let stack = self.push_stack(previous_stack, obligation);\n+        match self.candidate_from_obligation(&stack) {\n+            Ok(Some(c)) => c.to_evaluation_result(),\n+            Ok(None) => EvaluatedToAmbiguity,\n+            Err(_) => EvaluatedToUnmatch,\n+        }\n+    }\n+\n+    pub fn evaluate_impl(&mut self,\n                          impl_def_id: ast::DefId,\n                          obligation_cause: ObligationCause,\n                          obligation_self_ty: ty::t)\n@@ -227,30 +301,46 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // caller obligations, and so forth and assembling a list of\n     // candidates. See `doc.rs` and the `Candidate` type for more details.\n \n-    fn candidate_from_obligation(&self, obligation: &Obligation)\n+    fn candidate_from_obligation(&mut self,\n+                                 stack: &ObligationStack)\n                                  -> SelectionResult<Candidate>\n     {\n-        debug!(\"candidate_from_obligation({}, self_ty={})\",\n-               obligation.repr(self.tcx()),\n-               self.infcx.ty_to_string(obligation.self_ty()));\n-\n-        let skol_obligation_self_ty =\n-            infer::skolemize(self.infcx, obligation.self_ty());\n+        debug!(\"candidate_from_obligation({})\",\n+               stack.repr(self.tcx()));\n \n         // First, check the cache.\n-        match self.check_candidate_cache(obligation, skol_obligation_self_ty) {\n+        match self.check_candidate_cache(stack.obligation, stack.skol_obligation_self_ty) {\n             Some(c) => {\n-                return Ok(Some(c));\n+                debug!(\"check_candidate_cache(obligation={}, skol_obligation_self_ty={}, \\\n+                       candidate={})\",\n+                       stack.obligation.trait_ref.def_id,\n+                       stack.skol_obligation_self_ty.repr(self.tcx()),\n+                       c.repr(self.tcx()));\n+                return c;\n             }\n             None => { }\n         }\n \n-        let mut candidates =\n-            try!(self.assemble_candidates(obligation,\n-                                          skol_obligation_self_ty));\n+        // If no match, compute result and insert into cache.\n+        let result = self.pick_candidate(stack);\n+        self.insert_candidate_cache(stack.obligation,\n+                                    stack.skol_obligation_self_ty,\n+                                    result.clone());\n+        result\n+    }\n+\n+    fn pick_candidate(&mut self,\n+                      stack: &ObligationStack)\n+                      -> SelectionResult<Candidate>\n+    {\n+        if ty::type_is_error(stack.skol_obligation_self_ty) {\n+            return Ok(Some(ErrorCandidate));\n+        }\n+\n+        let mut candidates = try!(self.assemble_candidates(stack));\n \n-        debug!(\"candidate_from_obligation: {} candidates for {}\",\n-               candidates.len(), obligation.repr(self.tcx()));\n+        debug!(\"assembled {} candidates for {}\",\n+               candidates.len(), stack.repr(self.tcx()));\n \n         // Examine candidates to determine outcome. Ideally we will\n         // have exactly one candidate that is definitively applicable.\n@@ -262,131 +352,127 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // it is possible that one of those unbound variables will\n             // be bound to a new type from some other crate which will\n             // also contain impls.\n-            let trait_ref = &*obligation.trait_ref;\n-            return if !self.trait_ref_unconstrained(trait_ref) {\n-                debug!(\"candidate_from_obligation({}) -> 0 matches, unimpl\",\n-                       obligation.repr(self.tcx()));\n+            return if !self.contains_skolemized_types(stack.skol_obligation_self_ty) {\n+                debug!(\"0 matches, unimpl\");\n                 Err(Unimplemented)\n             } else {\n-                debug!(\"candidate_from_obligation({}) -> 0 matches, ambig\",\n-                       obligation.repr(self.tcx()));\n+                debug!(\"0 matches, ambig\");\n                 Ok(None)\n-            };\n-        }\n-\n-        if candidates.len() > 1 {\n+            }\n+        } else if candidates.len() > 1 {\n             // Ambiguity. Possibly we should report back more\n             // information on the potential candidates so we can give\n             // a better error message.\n-            debug!(\"candidate_from_obligation({}) -> multiple matches, ambig\",\n-                   obligation.repr(self.tcx()));\n-\n-            return Ok(None);\n+            debug!(\"multiple matches, ambig\");\n+            Ok(None)\n+        } else {\n+            let candidate = candidates.pop().unwrap();\n+            Ok(Some(candidate))\n         }\n+    }\n \n-        let candidate = candidates.pop().unwrap();\n-        self.insert_candidate_cache(obligation, skol_obligation_self_ty,\n-                                    candidate.clone());\n-        Ok(Some(candidate))\n+    fn pick_candidate_cache(&self,\n+                            _obligation: &Obligation,\n+                            skol_obligation_self_ty: ty::t)\n+                            -> &SelectionCache\n+    {\n+        if\n+            ty::type_has_self(skol_obligation_self_ty) ||\n+            ty::type_has_params(skol_obligation_self_ty)\n+        {\n+            &self.param_env.selection_cache\n+        } else {\n+            &self.tcx().selection_cache\n+        }\n     }\n \n-    fn check_candidate_cache(&self,\n-                             _obligation: &Obligation,\n-                             _skol_obligation_self_ty: ty::t)\n-                             -> Option<Candidate>\n+    fn check_candidate_cache(&mut self,\n+                             obligation: &Obligation,\n+                             skol_obligation_self_ty: ty::t)\n+                             -> Option<SelectionResult<Candidate>>\n     {\n-        // let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n-        //                               skol_obligation_self_ty);\n-        // let hashmap = self.tcx().selection_cache.hashmap.borrow();\n-        // hashmap.find(&cache_key).map(|c| (*c).clone())\n-        None\n+        let cache = self.pick_candidate_cache(obligation, skol_obligation_self_ty);\n+        let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+                                      skol_obligation_self_ty);\n+        let hashmap = cache.hashmap.borrow();\n+        hashmap.find(&cache_key).map(|c| (*c).clone())\n     }\n \n-    fn insert_candidate_cache(&self,\n-                              _obligation: &Obligation,\n-                              _skol_obligation_self_ty: ty::t,\n-                              _candidate: Candidate)\n+    fn insert_candidate_cache(&mut self,\n+                              obligation: &Obligation,\n+                              skol_obligation_self_ty: ty::t,\n+                              candidate: SelectionResult<Candidate>)\n     {\n-        // FIXME -- Enable caching. I think the right place to put the cache\n-        // is in the ParameterEnvironment, not the tcx, because otherwise\n-        // when there are distinct where clauses in scope the cache can get\n-        // confused.\n-        //\n-        //let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n-        //                              skol_obligation_self_ty);\n-        //let mut hashmap = self.tcx().selection_cache.hashmap.borrow_mut();\n-        //hashmap.insert(cache_key, candidate);\n+        debug!(\"insert_candidate_cache(obligation={}, skol_obligation_self_ty={}, candidate={})\",\n+               obligation.trait_ref.def_id,\n+               skol_obligation_self_ty.repr(self.tcx()),\n+               candidate.repr(self.tcx()));\n+\n+        let cache = self.pick_candidate_cache(obligation, skol_obligation_self_ty);\n+        let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+                                      skol_obligation_self_ty);\n+        let mut hashmap = cache.hashmap.borrow_mut();\n+        hashmap.insert(cache_key, candidate);\n     }\n \n-    fn assemble_candidates(&self,\n-                           obligation: &Obligation,\n-                           skol_obligation_self_ty: ty::t)\n+    fn assemble_candidates(&mut self,\n+                           stack: &ObligationStack)\n                            -> Result<Vec<Candidate>, SelectionError>\n     {\n         // Check for overflow.\n \n+        let ObligationStack { obligation, skol_obligation_self_ty, .. } = *stack;\n+\n         let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n         if obligation.recursion_depth >= recursion_limit {\n-            debug!(\"{} --> overflow\", obligation.repr(self.tcx()));\n+            debug!(\"{} --> overflow\", stack.obligation.repr(self.tcx()));\n             return Err(Overflow);\n         }\n \n         let mut candidates = Vec::new();\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n-            Some(_) => {\n-                // FIXME -- The treatment of builtin bounds is a bit\n-                // hacky right now. Eventually, the idea is to move\n-                // the logic for selection out of type_contents and\n-                // into this module (And make it based on the generic\n-                // mechanisms of OIBTT2).  However, I want to land\n-                // some code today, so we're going to cut a few\n-                // corners. What we do now is that the trait selection\n-                // code always considers builtin obligations to\n-                // match. The fulfillment code (which also has the job\n-                // of tracking all the traits that must hold) will\n-                // then just accumulate the various\n-                // builtin-bound-related obligations that must be met.\n-                // Later, at the end of typeck, after writeback etc,\n-                // we will rewalk this list and extract all the\n-                // builtin-bound-related obligations and test them\n-                // again using type contents. Part of the motivation\n-                // for this is that the type contents code requires\n-                // that writeback has been completed in some cases.\n-\n-                candidates.push(AmbiguousBuiltinCandidate);\n-            }\n+        // Other bounds. Consider both in-scope bounds from fn decl\n+        // and applicable impls. There is a certain set of precedence rules here.\n \n-            None => {\n-                // Other bounds. Consider both in-scope bounds from fn decl\n-                // and applicable impls.\n-\n-                try!(self.assemble_candidates_from_caller_bounds(\n-                    obligation,\n-                    skol_obligation_self_ty,\n-                    &mut candidates));\n-\n-                try!(self.assemble_unboxed_candidates(\n-                    obligation,\n-                    skol_obligation_self_ty,\n-                    &mut candidates));\n-\n-                // If there is a fn bound that applies, forego the\n-                // impl search. It can only generate conflicts.\n-\n-                if candidates.len() == 0 {\n-                    try!(self.assemble_candidates_from_impls(\n-                        obligation,\n-                        skol_obligation_self_ty,\n-                        &mut candidates));\n+        // Where clauses have highest precedence.\n+        try!(self.assemble_candidates_from_caller_bounds(\n+            obligation,\n+            skol_obligation_self_ty,\n+            &mut candidates));\n+\n+        // In the special case of builtin bounds, consider the \"compiler-supplied\" impls.\n+        if candidates.len() == 0 {\n+            match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+                Some(bound) => {\n+                    try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n                 }\n+\n+                None => { }\n             }\n         }\n \n+        // In the special case of fn traits and synthesized unboxed\n+        // closure types, consider the compiler-supplied impls. Note\n+        // that this is exclusive with the builtin bound case above.\n+        if candidates.len() == 0 {\n+            try!(self.assemble_unboxed_candidates(\n+                obligation,\n+                skol_obligation_self_ty,\n+                &mut candidates));\n+        }\n+\n+        // Finally, consider the actual impls found in the program.\n+        if candidates.len() == 0 {\n+            try!(self.assemble_candidates_from_impls(\n+                obligation,\n+                skol_obligation_self_ty,\n+                &mut candidates));\n+        }\n+\n         Ok(candidates)\n     }\n \n-    fn assemble_candidates_from_caller_bounds(&self,\n+    fn assemble_candidates_from_caller_bounds(&mut self,\n                                               obligation: &Obligation,\n                                               skol_obligation_self_ty: ty::t,\n                                               candidates: &mut Vec<Candidate>)\n@@ -398,28 +484,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          * them.\n          *\n          * Never affects inference environment.\n-v         */\n+         */\n \n-        debug!(\"assemble_candidates_from_caller_bounds({})\",\n-               obligation.repr(self.tcx()));\n+        debug!(\"assemble_candidates_from_caller_bounds({}, {})\",\n+               obligation.repr(self.tcx()),\n+               skol_obligation_self_ty.repr(self.tcx()));\n \n         for caller_obligation in self.param_env.caller_obligations.iter() {\n-            debug!(\"caller_obligation={}\",\n-                   caller_obligation.repr(self.tcx()));\n-\n             // Skip over obligations that don't apply to\n             // `self_ty`.\n             let caller_bound = &caller_obligation.trait_ref;\n             let caller_self_ty = caller_bound.substs.self_ty().unwrap();\n+            debug!(\"caller_obligation={}, caller_self_ty={}\",\n+                   caller_obligation.repr(self.tcx()),\n+                   self.infcx.ty_to_string(caller_self_ty));\n             match self.match_self_types(obligation.cause,\n                                         caller_self_ty,\n                                         skol_obligation_self_ty) {\n                 AmbiguousMatch => {\n-                    debug!(\"-> AmbiguousParamCandidate\");\n+                    debug!(\"-> AmbiguousMatch\");\n                     candidates.push(AmbiguousParamCandidate);\n                     return Ok(());\n                 }\n                 NoMatch => {\n+                    debug!(\"-> NoMatch\");\n                     continue;\n                 }\n                 Matched(()) => { }\n@@ -428,26 +516,22 @@ v         */\n             // Search through the trait (and its supertraits) to\n             // see if it matches the def-id we are looking for.\n             let caller_bound = (*caller_bound).clone();\n-            match util::search_trait_and_supertraits_from_bound(\n-                self.infcx.tcx, caller_bound,\n-                |d| d == obligation.trait_ref.def_id)\n-            {\n-                Some(vtable_param) => {\n+            for bound in util::transitive_bounds(self.tcx(), &[caller_bound]) {\n+                debug!(\"-> check bound={}\", bound.repr(self.tcx()));\n+                if bound.def_id == obligation.trait_ref.def_id {\n                     // If so, we're done!\n-                    debug!(\"-> MatchedParamCandidate({})\", vtable_param);\n+                    debug!(\"-> MatchedParamCandidate({})\", bound.repr(self.tcx()));\n+                    let vtable_param = VtableParamData { bound: bound };\n                     candidates.push(MatchedParamCandidate(vtable_param));\n                     return Ok(());\n                 }\n-\n-                None => {\n-                }\n             }\n         }\n \n         Ok(())\n     }\n \n-    fn assemble_unboxed_candidates(&self,\n+    fn assemble_unboxed_candidates(&mut self,\n                                    obligation: &Obligation,\n                                    skol_obligation_self_ty: ty::t,\n                                    candidates: &mut Vec<Candidate>)\n@@ -481,7 +565,7 @@ v         */\n             };\n \n             // Check to see whether the argument and return types match.\n-            let closure_kind = match self.unboxed_closures.find(&closure_def_id) {\n+            let closure_kind = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n                 Some(closure) => closure.kind,\n                 None => {\n                     self.tcx().sess.span_bug(\n@@ -501,7 +585,7 @@ v         */\n         Ok(())\n     }\n \n-    fn assemble_candidates_from_impls(&self,\n+    fn assemble_candidates_from_impls(&mut self,\n                                       obligation: &Obligation,\n                                       skol_obligation_self_ty: ty::t,\n                                       candidates: &mut Vec<Candidate>)\n@@ -528,7 +612,7 @@ v         */\n         Ok(())\n     }\n \n-    fn candidate_from_impl(&self,\n+    fn candidate_from_impl(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n                            skol_obligation_self_ty: ty::t)\n@@ -551,14 +635,406 @@ v         */\n         }\n     }\n \n+    ///////////////////////////////////////////////////////////////////////////\n+    // BUILTIN BOUNDS\n+    //\n+    // These cover the traits that are built-in to the language\n+    // itself.  This includes `Copy` and `Sized` for sure. For the\n+    // moment, it also includes `Send` / `Sync` and a few others, but\n+    // those will hopefully change to library-defined traits in the\n+    // future.\n+\n+    fn assemble_builtin_bound_candidates(&mut self,\n+                                         bound: ty::BuiltinBound,\n+                                         stack: &ObligationStack,\n+                                         candidates: &mut Vec<Candidate>)\n+                                         -> Result<(),SelectionError>\n+    {\n+        // Copy -- owned, dtor, managed, marker, &mut -- only INTERIOR?\n+        // Sized -- str, [T], Trait -- but only INTERIOR\n+        // Send -- managed data, nonsend annot, borrowed data -- REACHABILITY\n+        // Sync -- non-sync marker trait -- REACHABILITY\n+\n+        // Ideally, we'd only have to examine the immediate fields.\n+        // But think this through carefully I guess.\n+\n+        enum WhenOk<'a> {\n+            Always,\n+            Unknown,\n+            Never,\n+            If(ty::t),\n+            IfAll(&'a [ty::t]),\n+            IfTrue(bool)\n+        }\n+\n+        let ok = |this: &mut SelectionContext, w: WhenOk| {\n+            let r = match w {\n+                Always => EvaluatedToMatch,\n+                Unknown => EvaluatedToAmbiguity,\n+                Never => EvaluatedToUnmatch,\n+                IfTrue(true) => EvaluatedToMatch,\n+                IfTrue(false) => EvaluatedToUnmatch,\n+                If(ty) => this.evaluate_builtin_bound_recursively(bound, stack, ty),\n+                IfAll(tys) => {\n+                    let mut result = EvaluatedToMatch;\n+                    for &ty in tys.iter() {\n+                        match this.evaluate_builtin_bound_recursively(bound, stack, ty) {\n+                            EvaluatedToMatch => { }\n+                            EvaluatedToAmbiguity => {\n+                                result = EvaluatedToAmbiguity;\n+                            }\n+                            EvaluatedToUnmatch => {\n+                                result = EvaluatedToUnmatch;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    result\n+                }\n+            };\n+\n+            match r {\n+                EvaluatedToMatch => Ok(candidates.push(MatchedBuiltinCandidate)),\n+                EvaluatedToAmbiguity => Ok(candidates.push(AmbiguousBuiltinCandidate)),\n+                EvaluatedToUnmatch => Err(Unimplemented)\n+            }\n+        };\n+\n+        return match ty::get(stack.skol_obligation_self_ty).sty {\n+            ty::ty_uint(_) | ty::ty_int(_) | ty::ty_infer(ty::SkolemizedIntTy(_)) |\n+            ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_float(_) |\n+            ty::ty_bare_fn(_) | ty::ty_char => {\n+                // safe for everything\n+                ok(self, Always)\n+            }\n+\n+            ty::ty_box(_) => {\n+                match bound {\n+                    ty::BoundSync |\n+                    ty::BoundSend |\n+                    ty::BoundCopy => {\n+                        // Managed data is not copyable, sendable, nor\n+                        // synchronized, regardless of referent.\n+                        ok(self, Never)\n+                    }\n+\n+                    ty::BoundSized => {\n+                        // But it is sized, regardless of referent.\n+                        ok(self, Always)\n+                    }\n+                }\n+            }\n+\n+            ty::ty_uniq(referent_ty) => {  // Box<T>\n+                match bound {\n+                    ty::BoundCopy => {\n+                        ok(self, Never)\n+                    }\n+\n+                    ty::BoundSized => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, If(referent_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_ptr(ty::mt { ty: referent_ty, .. }) => {     // *const T, *mut T\n+                match bound {\n+                    ty::BoundCopy |\n+                    ty::BoundSized => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, If(referent_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_closure(ref c) => {\n+                match c.store {\n+                    ty::UniqTraitStore => {\n+                        // proc: Equivalent to `Box<FnOnce>`\n+                        match bound {\n+                            ty::BoundCopy => {\n+                                ok(self, Never)\n+                            }\n+\n+                            ty::BoundSized => {\n+                                ok(self, Always)\n+                            }\n+\n+                            ty::BoundSync |\n+                            ty::BoundSend => {\n+                                ok(self, IfTrue(c.bounds.builtin_bounds.contains_elem(bound)))\n+                            }\n+                        }\n+                    }\n+                    ty::RegionTraitStore(_, mutbl) => {\n+                        // ||: Equivalent to `&FnMut` or `&mut FnMut` or something like that.\n+                        match bound {\n+                            ty::BoundCopy => {\n+                                ok(self, match mutbl {\n+                                    ast::MutMutable => Never,  // &mut T is affine\n+                                    ast::MutImmutable => Always,  // &T is copyable\n+                                })\n+                            }\n+\n+                            ty::BoundSized => {\n+                                ok(self, Always)\n+                            }\n+\n+                            ty::BoundSync |\n+                            ty::BoundSend => {\n+                                ok(self, IfTrue(c.bounds.builtin_bounds.contains_elem(bound)))\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            ty::ty_trait(box ty::TyTrait { bounds, .. }) => {\n+                match bound {\n+                    ty::BoundSized => {\n+                        ok(self, Never)\n+                    }\n+                    ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n+                        ok(self, IfTrue(bounds.builtin_bounds.contains_elem(bound)))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_rptr(_, ty::mt { ty: referent_ty, mutbl: mutbl }) => {\n+                // &mut T or &T\n+                match bound {\n+                    ty::BoundCopy => {\n+                        ok(self, match mutbl {\n+                            ast::MutMutable => Never,  // &mut T is affine and hence never `Copy`\n+                            ast::MutImmutable => Always,  // &T is copyable\n+                        })\n+                    }\n+\n+                    ty::BoundSized => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        // Note: technically, a region pointer is only\n+                        // sendable if it has lifetime\n+                        // `'static`. However, we don't take regions\n+                        // into account when doing trait matching:\n+                        // instead, when we decide that `T : Send`, we\n+                        // will register a separate constraint with\n+                        // the region inferencer that `T : 'static`\n+                        // holds as well (because the trait `Send`\n+                        // requires it). This will ensure that there\n+                        // is no borrowed data in `T` (or else report\n+                        // an inference error). The reason we do it\n+                        // this way is that we do not yet *know* what\n+                        // lifetime the borrowed reference has, since\n+                        // we haven't finished running inference -- in\n+                        // other words, there's a kind of\n+                        // chicken-and-egg problem.\n+                        ok(self, If(referent_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_vec(element_ty, ref len) => {\n+                // [T, ..n] and [T]\n+                match bound {\n+                    ty::BoundCopy => {\n+                        match *len {\n+                            Some(_) => ok(self, If(element_ty)), // [T, ..n] is copy iff T is copy\n+                            None => ok(self, Never), // [T] is unsized and hence affine\n+                        }\n+                    }\n+\n+                    ty::BoundSized => {\n+                        ok(self, IfTrue(len.is_some()))\n+                    }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, If(element_ty))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_str => {\n+                // Equivalent to [u8]\n+                match bound {\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        ok(self, Always)\n+                    }\n+\n+                    ty::BoundCopy |\n+                    ty::BoundSized => {\n+                        ok(self, Never)\n+                    }\n+                }\n+            }\n+\n+            ty::ty_tup(ref tys) => {\n+                // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+                ok(self, IfAll(tys.as_slice()))\n+            }\n+\n+            ty::ty_unboxed_closure(def_id, _) => {\n+                // FIXME -- This case is tricky. In the case of by-ref\n+                // closures particularly, we need the results of\n+                // inference to decide how to reflect the type of each\n+                // upvar (the upvar may have type `T`, but the runtime\n+                // type could be `&mut`, `&`, or just `T`). For now,\n+                // though, we'll do this unsoundly and assume that all\n+                // captures are by value. Really what we ought to do\n+                // is reserve judgement and then intertwine this\n+                // analysis with closure inference.\n+                //\n+                // FIXME -- this is wrong with respect to\n+                // skolemization. We want to skolemize the types of\n+                // the variables, but to do THAT we need the ability\n+                // to \"start\" the skolemization numbering from a\n+                // higher point. Perhaps this just means creating a\n+                // single skolemizer and then using it again here?\n+                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+                match self.tcx().freevars.borrow().find(&def_id.node) {\n+                    None => {\n+                        // No upvars.\n+                        ok(self, Always)\n+                    }\n+\n+                    Some(freevars) => {\n+                        let tys: Vec<ty::t> =\n+                            freevars\n+                            .iter()\n+                            .map(|freevar| {\n+                                let freevar_def_id = freevar.def.def_id();\n+                                let freevar_ty = self.typer.node_ty(freevar_def_id.node)\n+                                    .unwrap_or(ty::mk_err());\n+                                freevar_ty.fold_with(&mut self.skolemizer)\n+                            })\n+                            .collect();\n+                        ok(self, IfAll(tys.as_slice()))\n+                    }\n+                }\n+            }\n+\n+            ty::ty_struct(def_id, ref substs) => {\n+                let types: Vec<ty::t> =\n+                    ty::struct_fields(self.tcx(), def_id, substs)\n+                    .iter()\n+                    .map(|f| f.mt.ty)\n+                    .collect();\n+                nominal(self, bound, def_id, types, ok)\n+            }\n+\n+            ty::ty_enum(def_id, ref substs) => {\n+                let types: Vec<ty::t> =\n+                    ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                    .iter()\n+                    .flat_map(|variant| variant.args.iter())\n+                    .map(|&ty| ty)\n+                    .collect();\n+                nominal(self, bound, def_id, types, ok)\n+            }\n+\n+            ty::ty_param(_) => {\n+                // Note: A type parameter is only considered to meet a\n+                // particular bound if there is a where clause telling\n+                // us that it does, and that case is handled by\n+                // `assemble_candidates_from_caller_bounds()`.\n+                ok(self, Never)\n+            }\n+\n+            ty::ty_infer(ty::SkolemizedTy(_)) => {\n+                // Skolemized types represent unbound type\n+                // variables. They might or might not have applicable\n+                // impls and so forth, depending on what those type\n+                // variables wind up being bound to.\n+                ok(self, Unknown)\n+            }\n+\n+            ty::ty_open(_) |\n+            ty::ty_infer(ty::TyVar(_)) |\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_err => {\n+                self.tcx().sess.span_bug(\n+                    stack.obligation.cause.span,\n+                    format!(\n+                        \"asked to compute contents of unexpected type: {}\",\n+                        stack.skol_obligation_self_ty.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        fn nominal(this: &mut SelectionContext,\n+                   bound: ty::BuiltinBound,\n+                   def_id: ast::DefId,\n+                   types: Vec<ty::t>,\n+                   ok: |&mut SelectionContext, WhenOk| -> Result<(),SelectionError>)\n+                   -> Result<(),SelectionError>\n+        {\n+            // First check for markers and other nonsense.\n+            let tcx = this.tcx();\n+            match bound {\n+                ty::BoundSend => {\n+                    if\n+                        Some(def_id) == tcx.lang_items.no_send_bound() ||\n+                        Some(def_id) == tcx.lang_items.managed_bound()\n+                    {\n+                        return ok(this, Never);\n+                    }\n+                }\n+\n+                ty::BoundCopy => {\n+                    if\n+                        Some(def_id) == tcx.lang_items.no_copy_bound() ||\n+                        Some(def_id) == tcx.lang_items.managed_bound() ||\n+                        ty::has_dtor(tcx, def_id)\n+                    {\n+                        return ok(this, Never);\n+                    }\n+                }\n+\n+                ty::BoundSync => {\n+                    if\n+                        Some(def_id) == tcx.lang_items.no_sync_bound() ||\n+                        Some(def_id) == tcx.lang_items.managed_bound()\n+                    {\n+                        return ok(this, Never);\n+                    } else if\n+                        Some(def_id) == tcx.lang_items.unsafe_type()\n+                    {\n+                        // FIXME(#13231) -- we currently consider `UnsafeCell<T>`\n+                        // to always be sync. This is allow for types like `Queue`\n+                        // and `Mutex`, where `Queue<T> : Sync` is `T : Send`.\n+                        return ok(this, Always);\n+                    }\n+                }\n+\n+                ty::BoundSized => { }\n+            }\n+\n+            ok(this, IfAll(types.as_slice()))\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // CONFIRMATION\n     //\n     // Confirmation unifies the output type parameters of the trait\n     // with the values found in the obligation, possibly yielding a\n     // type error.  See `doc.rs` for more details.\n \n-    fn confirm_candidate(&self,\n+    fn confirm_candidate(&mut self,\n                          obligation: &Obligation,\n                          candidate: Candidate)\n                          -> SelectionResult<Selection>\n@@ -574,6 +1050,7 @@ v         */\n                 Ok(None)\n             }\n \n+            ErrorCandidate |\n             MatchedBuiltinCandidate => {\n                 Ok(Some(VtableBuiltin))\n             }\n@@ -596,7 +1073,7 @@ v         */\n         }\n     }\n \n-    fn confirm_param_candidate(&self,\n+    fn confirm_param_candidate(&mut self,\n                                obligation: &Obligation,\n                                param: VtableParamData)\n                                -> Result<VtableParamData,SelectionError>\n@@ -611,7 +1088,7 @@ v         */\n         Ok(param)\n     }\n \n-    fn confirm_impl_candidate(&self,\n+    fn confirm_impl_candidate(&mut self,\n                               obligation: &Obligation,\n                               impl_def_id: ast::DefId)\n                               -> Result<VtableImplData<Obligation>,SelectionError>\n@@ -638,7 +1115,7 @@ v         */\n         Ok(vtable_impl)\n     }\n \n-    fn confirm_inherent_impl_candidate(&self,\n+    fn confirm_inherent_impl_candidate(&mut self,\n                                        impl_def_id: ast::DefId,\n                                        obligation_cause: ObligationCause,\n                                        obligation_self_ty: ty::t,\n@@ -671,7 +1148,7 @@ v         */\n         Ok(vtable_impl)\n     }\n \n-    fn confirm_unboxed_closure_candidate(&self,\n+    fn confirm_unboxed_closure_candidate(&mut self,\n                                          obligation: &Obligation,\n                                          closure_def_id: ast::DefId)\n                                          -> Result<(),SelectionError>\n@@ -680,7 +1157,7 @@ v         */\n                obligation.repr(self.tcx()),\n                closure_def_id.repr(self.tcx()));\n \n-        let closure_type = match self.unboxed_closures.find(&closure_def_id) {\n+        let closure_type = match self.typer.unboxed_closures().borrow().find(&closure_def_id) {\n             Some(closure) => closure.closure_type.clone(),\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -724,7 +1201,7 @@ v         */\n     // run inside of a `probe()` so that their side-effects are\n     // contained.\n \n-    fn match_impl_self_types(&self,\n+    fn match_impl_self_types(&mut self,\n                              impl_def_id: ast::DefId,\n                              obligation_cause: ObligationCause,\n                              obligation_self_ty: ty::t)\n@@ -776,7 +1253,7 @@ v         */\n         }\n     }\n \n-    fn match_self_types(&self,\n+    fn match_self_types(&mut self,\n                         cause: ObligationCause,\n \n                         // The self type provided by the impl/caller-obligation:\n@@ -821,7 +1298,7 @@ v         */\n     // the output type parameters from the obligation with those found\n     // on the impl/bound, which may yield type errors.\n \n-    fn confirm_impl_vtable(&self,\n+    fn confirm_impl_vtable(&mut self,\n                            impl_def_id: ast::DefId,\n                            obligation_cause: ObligationCause,\n                            obligation_trait_ref: Rc<ty::TraitRef>,\n@@ -851,7 +1328,7 @@ v         */\n         self.confirm(obligation_cause, obligation_trait_ref, impl_trait_ref)\n     }\n \n-    fn confirm(&self,\n+    fn confirm(&mut self,\n                obligation_cause: ObligationCause,\n                obligation_trait_ref: Rc<ty::TraitRef>,\n                expected_trait_ref: Rc<ty::TraitRef>)\n@@ -898,6 +1375,32 @@ v         */\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n+    fn new_stack<'o>(&mut self, obligation: &'o Obligation) -> ObligationStack<'o> {\n+        let skol_obligation_self_ty =\n+            obligation.self_ty().fold_with(&mut self.skolemizer);\n+\n+        ObligationStack {\n+            obligation: obligation,\n+            skol_obligation_self_ty: skol_obligation_self_ty,\n+            previous: None\n+        }\n+    }\n+\n+    fn push_stack<'o>(&self,\n+                      previous_stack: &'o ObligationStack<'o>,\n+                      obligation: &'o Obligation)\n+                      -> ObligationStack<'o>\n+    {\n+        // No need to skolemize obligation.self_ty, because we\n+        // guarantee the self-type for all recursive obligations are\n+        // already skolemized.\n+        ObligationStack {\n+            obligation: obligation,\n+            skol_obligation_self_ty: obligation.self_ty(),\n+            previous: Some(previous_stack)\n+        }\n+    }\n+\n     fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n         /*!\n          * Returns se tof all impls for a given trait.\n@@ -924,22 +1427,17 @@ v         */\n                                        &impl_generics, impl_substs)\n     }\n \n-    fn trait_ref_unconstrained(&self,\n-                               trait_ref: &ty::TraitRef)\n-                               -> bool\n+    fn contains_skolemized_types(&self,\n+                                 ty: ty::t)\n+                                 -> bool\n     {\n         /*!\n-         * True if the self type of the trait-ref contains\n-         * unconstrained type variables.\n+         * True if the type contains skolemized variables.\n          */\n \n         let mut found_skol = false;\n \n-        // Skolemization replaces all unconstrained type vars with\n-        // a SkolemizedTy instance. Then we search to see if we\n-        // found any.\n-        let skol_ty = infer::skolemize(self.infcx, trait_ref.self_ty());\n-        ty::walk_ty(skol_ty, |t| {\n+        ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n                 ty::ty_infer(ty::SkolemizedTy(_)) => { found_skol = true; }\n                 _ => { }\n@@ -955,6 +1453,7 @@ impl Candidate {\n         match *self {\n             Impl(ref i) => i.to_evaluation_result(),\n \n+            ErrorCandidate |\n             MatchedUnboxedClosureCandidate(..) |\n             MatchedBuiltinCandidate |\n             MatchedParamCandidate(..) => {\n@@ -981,6 +1480,7 @@ impl ImplCandidate {\n impl Repr for Candidate {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n+            ErrorCandidate => format!(\"ErrorCandidate\"),\n             MatchedBuiltinCandidate => format!(\"MatchedBuiltinCandidate\"),\n             AmbiguousBuiltinCandidate => format!(\"AmbiguousBuiltinCandidate\"),\n             MatchedUnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n@@ -1003,23 +1503,50 @@ impl Repr for ImplCandidate {\n     }\n }\n \n+impl SelectionCache {\n+    pub fn new() -> SelectionCache {\n+        SelectionCache {\n+            hashmap: RefCell::new(HashMap::new())\n+        }\n+    }\n+}\n+\n+impl<'o> ObligationStack<'o> {\n+    fn iter(&self) -> Option<&ObligationStack> {\n+        Some(self)\n+    }\n+}\n+\n+impl<'o> Iterator<&'o ObligationStack<'o>> for Option<&'o ObligationStack<'o>> {\n+    fn next(&mut self) -> Option<&'o ObligationStack<'o>> {\n+        match *self {\n+            Some(o) => {\n+                *self = o.previous;\n+                Some(o)\n+            }\n+            None => {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+impl<'o> Repr for ObligationStack<'o> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"ObligationStack({}, {})\",\n+                self.obligation.repr(tcx),\n+                self.skol_obligation_self_ty.repr(tcx))\n+    }\n+}\n \n-// impl SelectionCache {\n-//     pub fn new() -> SelectionCache {\n-//         SelectionCache {\n-//             hashmap: RefCell::new(HashMap::new())\n-//         }\n-//     }\n-// }\n-\n-// impl CacheKey {\n-//     pub fn new(trait_def_id: ast::DefId,\n-//                skol_obligation_self_ty: ty::t)\n-//                -> CacheKey\n-//     {\n-//         CacheKey {\n-//             trait_def_id: trait_def_id,\n-//             skol_obligation_self_ty: skol_obligation_self_ty\n-//         }\n-//     }\n-// }\n+impl CacheKey {\n+    pub fn new(trait_def_id: ast::DefId,\n+               skol_obligation_self_ty: ty::t)\n+               -> CacheKey\n+    {\n+        CacheKey {\n+            trait_def_id: trait_def_id,\n+            skol_obligation_self_ty: skol_obligation_self_ty\n+        }\n+    }\n+}"}, {"sha": "cad86003ce9dd920356263640e16172f875a0ba4", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 48, "deletions": 17, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -13,6 +13,7 @@ use middle::subst;\n use middle::subst::{ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::typeck::infer::InferCtxt;\n use middle::ty;\n+use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -27,6 +28,7 @@ use super::{Obligation, ObligationCause, VtableImpl, VtableParam, VtableParamDat\n pub struct Supertraits<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>,\n     stack: Vec<SupertraitEntry>,\n+    visited: HashSet<Rc<ty::TraitRef>>,\n }\n \n struct SupertraitEntry {\n@@ -62,15 +64,34 @@ pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n+\n+    let visited: HashSet<Rc<ty::TraitRef>> =\n+        bounds.iter()\n+              .map(|b| (*b).clone())\n+              .collect();\n+\n     let entry = SupertraitEntry { position: 0, supertraits: bounds };\n-    Supertraits { tcx: tcx, stack: vec![entry] }\n+    Supertraits { tcx: tcx, stack: vec![entry], visited: visited }\n }\n \n impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n     fn push(&mut self, trait_ref: &ty::TraitRef) {\n-        let bounds = ty::bounds_for_trait_ref(self.tcx, trait_ref);\n-        let entry = SupertraitEntry { position: 0,\n-                                      supertraits: bounds.trait_bounds };\n+        let ty::ParamBounds { builtin_bounds, mut trait_bounds, .. } =\n+            ty::bounds_for_trait_ref(self.tcx, trait_ref);\n+        for builtin_bound in builtin_bounds.iter() {\n+            let bound_trait_ref = trait_ref_for_builtin_bound(self.tcx,\n+                                                              builtin_bound,\n+                                                              trait_ref.self_ty());\n+            trait_bounds.push(bound_trait_ref);\n+        }\n+\n+        // Only keep those bounds that we haven't already seen.  This\n+        // is necessary to prevent infinite recursion in some cases.\n+        // One common case is when people define `trait Sized { }`\n+        // rather than `trait Sized for Sized? { }`.\n+        trait_bounds.retain(|r| self.visited.insert((*r).clone()));\n+\n+        let entry = SupertraitEntry { position: 0, supertraits: trait_bounds };\n         self.stack.push(entry);\n     }\n \n@@ -211,31 +232,41 @@ fn push_obligations_for_param_bounds(\n     }\n }\n \n-pub fn obligation_for_builtin_bound(\n+pub fn trait_ref_for_builtin_bound(\n     tcx: &ty::ctxt,\n-    cause: ObligationCause,\n     builtin_bound: ty::BuiltinBound,\n-    recursion_depth: uint,\n     param_ty: ty::t)\n-    -> Obligation\n+    -> Rc<ty::TraitRef>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Obligation {\n-                cause: cause,\n-                recursion_depth: recursion_depth,\n-                trait_ref: Rc::new(ty::TraitRef {\n-                    def_id: def_id,\n-                    substs: Substs::empty().with_self_ty(param_ty),\n-                }),\n-            }\n+            Rc::new(ty::TraitRef {\n+                def_id: def_id,\n+                substs: Substs::empty().with_self_ty(param_ty)\n+            })\n         }\n         Err(e) => {\n-            tcx.sess.span_bug(cause.span, e.as_slice());\n+            tcx.sess.bug(e.as_slice());\n         }\n     }\n }\n \n+pub fn obligation_for_builtin_bound(\n+    tcx: &ty::ctxt,\n+    cause: ObligationCause,\n+    builtin_bound: ty::BuiltinBound,\n+    recursion_depth: uint,\n+    param_ty: ty::t)\n+    -> Obligation\n+{\n+    let trait_ref = trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty);\n+    Obligation {\n+        cause: cause,\n+        recursion_depth: recursion_depth,\n+        trait_ref: trait_ref\n+    }\n+}\n+\n pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n                                                caller_bound: Rc<ty::TraitRef>,\n                                                test: |ast::DefId| -> bool)"}, {"sha": "30f91c82930e331097cfa72e236f96d02ea709ef", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -31,6 +31,7 @@ use middle::trans::type_of;\n use middle::traits;\n use middle::ty;\n use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n use middle::typeck;\n use middle::typeck::infer;\n use util::ppaux::Repr;\n@@ -791,12 +792,10 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     // Parameter environment is used to give details about type parameters,\n     // but since we are in trans, everything is fully monomorphized.\n     let param_env = ty::empty_parameter_environment();\n-    let unboxed_closures = tcx.unboxed_closures.borrow();\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    let selcx = traits::SelectionContext::new(&infcx, &param_env,\n-                                              &*unboxed_closures);\n+    let mut selcx = traits::SelectionContext::new(&infcx, &param_env, tcx);\n     let obligation = traits::Obligation::misc(span, trait_ref.clone());\n     let selection = match selcx.select(&obligation) {\n         Ok(Some(selection)) => selection,\n@@ -825,7 +824,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     let vtable = selection.map_move_nested(|obligation| {\n         fulfill_cx.register_obligation(tcx, obligation);\n     });\n-    match fulfill_cx.select_all_or_error(&infcx, &param_env, &*unboxed_closures) {\n+    match fulfill_cx.select_all_or_error(&infcx, &param_env, tcx) {\n         Ok(()) => { }\n         Err(e) => {\n             tcx.sess.span_bug(\n@@ -841,7 +840,7 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n     // sort of overkill because we do not expect there to be any\n     // unbound type variables, hence no skolemized types should ever\n     // be inserted.\n-    let vtable = infer::skolemize(&infcx, vtable);\n+    let vtable = vtable.fold_with(&mut infcx.skolemizer());\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,"}, {"sha": "85c43f3f281141d28837b3faa50ff12eafa93491", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -561,6 +561,9 @@ pub fn get_vtable(bcx: Block,\n                                         DUMMY_SP,\n                                         trait_ref.clone());\n         match vtable {\n+            traits::VtableBuiltin => {\n+                Vec::new().into_iter()\n+            }\n             traits::VtableImpl(\n                 traits::VtableImplData {\n                     impl_def_id: id,\n@@ -634,7 +637,6 @@ pub fn get_vtable(bcx: Block,\n \n                 (vec!(llfn)).into_iter()\n             }\n-            traits::VtableBuiltin |\n             traits::VtableParam(..) => {\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\","}, {"sha": "5ecf7c0d48d18274a4e271eee375ee5960eeb650", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -579,6 +579,10 @@ pub struct ctxt<'tcx> {\n     /// Maps def IDs of traits to information about their associated types.\n     pub trait_associated_types:\n         RefCell<DefIdMap<Rc<Vec<AssociatedTypeInfo>>>>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that do not have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache,\n }\n \n pub enum tbox_flag {\n@@ -1281,6 +1285,10 @@ pub struct ParameterEnvironment {\n     /// Note: This effectively *duplicates* the `bounds` array for\n     /// now.\n     pub caller_obligations: VecPerParamSpace<traits::Obligation>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache,\n }\n \n impl ParameterEnvironment {\n@@ -1524,7 +1532,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         capture_modes: capture_modes,\n         associated_types: RefCell::new(DefIdMap::new()),\n         trait_associated_types: RefCell::new(DefIdMap::new()),\n-    }\n+        selection_cache: traits::SelectionCache::new(),\n+   }\n }\n \n // Type constructors\n@@ -2235,35 +2244,25 @@ def_type_content_sets!(\n         OwnsAll                             = 0b0000_0000__1111_1111__0000,\n \n         // Things that are reachable by the value in any way (fourth nibble):\n-        ReachesNonsendAnnot                 = 0b0000_0001__0000_0000__0000,\n         ReachesBorrowed                     = 0b0000_0010__0000_0000__0000,\n         // ReachesManaged /* see [1] below */  = 0b0000_0100__0000_0000__0000,\n         ReachesMutable                      = 0b0000_1000__0000_0000__0000,\n-        ReachesNoSync                       = 0b0001_0000__0000_0000__0000,\n         ReachesFfiUnsafe                    = 0b0010_0000__0000_0000__0000,\n         ReachesAll                          = 0b0011_1111__0000_0000__0000,\n \n-        // Things that cause values to *move* rather than *copy*\n+        // Things that cause values to *move* rather than *copy*. This\n+        // is almost the same as the `Copy` trait, but for managed\n+        // data -- atm, we consider managed data to copy, not move,\n+        // but it does not impl Copy as a pure memcpy is not good\n+        // enough. Yuck.\n         Moves                               = 0b0000_0000__0000_1011__0000,\n \n         // Things that mean drop glue is necessary\n         NeedsDrop                           = 0b0000_0000__0000_0111__0000,\n \n-        // Things that prevent values from being sent\n-        //\n-        // Note: For checking whether something is sendable, it'd\n-        //       be sufficient to have ReachesManaged. However, we include\n-        //       both ReachesManaged and OwnsManaged so that when\n-        //       a parameter has a bound T:Send, we are able to deduce\n-        //       that it neither reaches nor owns a managed pointer.\n-        Nonsendable                         = 0b0000_0111__0000_0100__0000,\n-\n         // Things that prevent values from being considered sized\n         Nonsized                            = 0b0000_0000__0000_0000__0001,\n \n-        // Things that prevent values from being sync\n-        Nonsync                             = 0b0001_0000__0000_0000__0000,\n-\n         // Things that make values considered not POD (would be same\n         // as `Moves`, but for the fact that managed data `@` is\n         // not considered POD)\n@@ -2282,15 +2281,6 @@ def_type_content_sets!(\n )\n \n impl TypeContents {\n-    pub fn meets_builtin_bound(&self, cx: &ctxt, bb: BuiltinBound) -> bool {\n-        match bb {\n-            BoundSend => self.is_sendable(cx),\n-            BoundSized => self.is_sized(cx),\n-            BoundCopy => self.is_copy(cx),\n-            BoundSync => self.is_sync(cx),\n-        }\n-    }\n-\n     pub fn when(&self, cond: bool) -> TypeContents {\n         if cond {*self} else {TC::None}\n     }\n@@ -2299,14 +2289,6 @@ impl TypeContents {\n         (self.bits & tc.bits) != 0\n     }\n \n-    pub fn is_sendable(&self, _: &ctxt) -> bool {\n-        !self.intersects(TC::Nonsendable)\n-    }\n-\n-    pub fn is_sync(&self, _: &ctxt) -> bool {\n-        !self.intersects(TC::Nonsync)\n-    }\n-\n     pub fn owns_managed(&self) -> bool {\n         self.intersects(TC::OwnsManaged)\n     }\n@@ -2319,10 +2301,6 @@ impl TypeContents {\n         !self.intersects(TC::Nonsized)\n     }\n \n-    pub fn is_copy(&self, _: &ctxt) -> bool {\n-        !self.intersects(TC::Noncopy)\n-    }\n-\n     pub fn interior_unsafe(&self) -> bool {\n         self.intersects(TC::InteriorUnsafe)\n     }\n@@ -2407,10 +2385,6 @@ impl fmt::Show for TypeContents {\n     }\n }\n \n-pub fn type_is_sendable(cx: &ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).is_sendable(cx)\n-}\n-\n pub fn type_interior_is_unsafe(cx: &ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).interior_unsafe()\n }\n@@ -2652,19 +2626,14 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n     fn apply_lang_items(cx: &ctxt,\n                         did: ast::DefId,\n                         tc: TypeContents)\n-                        -> TypeContents {\n-        if Some(did) == cx.lang_items.no_send_bound() {\n-            tc | TC::ReachesNonsendAnnot\n-        } else if Some(did) == cx.lang_items.managed_bound() {\n+                        -> TypeContents\n+    {\n+        if Some(did) == cx.lang_items.managed_bound() {\n             tc | TC::Managed\n         } else if Some(did) == cx.lang_items.no_copy_bound() {\n             tc | TC::OwnsAffine\n-        } else if Some(did) == cx.lang_items.no_sync_bound() {\n-            tc | TC::ReachesNoSync\n         } else if Some(did) == cx.lang_items.unsafe_type() {\n-            // FIXME(#13231): This shouldn't be needed after\n-            // opt-in built-in bounds are implemented.\n-            (tc | TC::InteriorUnsafe) - TC::Nonsync\n+            tc | TC::InteriorUnsafe\n         } else {\n             tc\n         }\n@@ -2724,10 +2693,9 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         let mut tc = TC::All;\n         each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n             tc = tc - match bound {\n-                BoundSend => TC::Nonsendable,\n+                BoundSync | BoundSend => TC::None,\n                 BoundSized => TC::Nonsized,\n                 BoundCopy => TC::Noncopy,\n-                BoundSync => TC::Nonsync,\n             };\n         });\n         return tc;\n@@ -5324,7 +5292,8 @@ pub fn empty_parameter_environment() -> ParameterEnvironment {\n     ty::ParameterEnvironment { free_substs: Substs::empty(),\n                                bounds: VecPerParamSpace::empty(),\n                                caller_obligations: VecPerParamSpace::empty(),\n-                               implicit_region_bound: ty::ReEmpty }\n+                               implicit_region_bound: ty::ReEmpty,\n+                               selection_cache: traits::SelectionCache::new(), }\n }\n \n pub fn construct_parameter_environment(\n@@ -5396,6 +5365,7 @@ pub fn construct_parameter_environment(\n         bounds: bounds,\n         implicit_region_bound: ty::ReScope(free_id),\n         caller_obligations: obligations,\n+        selection_cache: traits::SelectionCache::new(),\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,"}, {"sha": "c7be2430cc98da5e1d4cffb36881bf5e6ee579e6", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 108, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -298,30 +298,29 @@ impl<'a, 'tcx> mem_categorization::Typer<'tcx> for FnCtxt<'a, 'tcx> {\n         self.ccx.tcx\n     }\n     fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n-        self.ccx.tcx.node_ty(id)\n+        Ok(self.node_ty(id))\n     }\n     fn node_method_ty(&self, method_call: typeck::MethodCall)\n                       -> Option<ty::t> {\n-        self.ccx.tcx.node_method_ty(method_call)\n+        self.inh.method_map.borrow().find(&method_call).map(|m| m.ty)\n     }\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>> {\n-        self.ccx.tcx.adjustments()\n+        &self.inh.adjustments\n     }\n     fn is_method_call(&self, id: ast::NodeId) -> bool {\n-        self.ccx.tcx.is_method_call(id)\n+        self.inh.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n     fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId> {\n-        self.ccx.tcx.temporary_scope(rvalue_id)\n+        self.tcx().temporary_scope(rvalue_id)\n     }\n     fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow {\n-        self.ccx.tcx.upvar_borrow(upvar_id)\n+        self.inh.upvar_borrow_map.borrow().get_copy(&upvar_id)\n     }\n     fn capture_mode(&self, closure_expr_id: ast::NodeId)\n                     -> ast::CaptureClause {\n         self.ccx.tcx.capture_mode(closure_expr_id)\n     }\n-    fn unboxed_closures<'a>(&'a self)\n-                        -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n+    fn unboxed_closures<'a>(&'a self) -> &'a RefCell<DefIdMap<ty::UnboxedClosure>> {\n         &self.inh.unboxed_closures\n     }\n }\n@@ -369,12 +368,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>)\n                                     -> Inherited<'a, 'tcx> {\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n-    let param_env = ty::ParameterEnvironment {\n-        free_substs: subst::Substs::empty(),\n-        bounds: subst::VecPerParamSpace::empty(),\n-        implicit_region_bound: ty::ReStatic,\n-        caller_obligations: subst::VecPerParamSpace::empty(),\n-    };\n+    let param_env = ty::empty_parameter_environment();\n     Inherited::new(ccx.tcx, param_env)\n }\n \n@@ -387,17 +381,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-struct CheckItemSizedTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CrateCtxt<'a, 'tcx>\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for CheckItemSizedTypesVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, i: &ast::Item) {\n-        check_item_sized(self.ccx, i);\n-        visit::walk_item(self, i);\n-    }\n-}\n-\n pub fn check_item_types(ccx: &CrateCtxt) {\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n@@ -411,9 +394,6 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n-\n-    let mut visit = CheckItemSizedTypesVisitor { ccx: ccx };\n-    visit::walk_crate(&mut visit, krate);\n }\n \n fn check_bare_fn(ccx: &CrateCtxt,\n@@ -435,7 +415,6 @@ fn check_bare_fn(ccx: &CrateCtxt,\n             vtable2::select_all_fcx_obligations_or_error(&fcx);\n             regionck::regionck_fn(&fcx, id, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n-            vtable2::check_builtin_bound_obligations(&fcx); // must happen after writeback\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -677,33 +656,6 @@ fn check_for_field_shadowing(tcx: &ty::ctxt,\n     }\n }\n \n-fn check_fields_sized(tcx: &ty::ctxt,\n-                      struct_def: &ast::StructDef) {\n-    let len = struct_def.fields.len();\n-    if len == 0 {\n-        return;\n-    }\n-    for f in struct_def.fields.slice_to(len - 1).iter() {\n-        let t = ty::node_id_to_type(tcx, f.node.id);\n-        if !ty::type_is_sized(tcx, t) {\n-            match f.node.kind {\n-                ast::NamedField(ident, _) => {\n-                    span_err!(tcx.sess, f.span, E0042,\n-                        \"type `{}` is dynamically sized. \\\n-                         dynamically sized types may only \\\n-                         appear as the type of the final \\\n-                         field in a struct\",\n-                        token::get_ident(ident));\n-                }\n-                ast::UnnamedField(_) => {\n-                    span_err!(tcx.sess, f.span, E0043,\n-                        \"dynamically sized type in field\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n@@ -718,24 +670,6 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     }\n }\n \n-pub fn check_item_sized(ccx: &CrateCtxt, it: &ast::Item) {\n-    debug!(\"check_item(it.id={}, it.ident={})\",\n-           it.id,\n-           ty::item_path_str(ccx.tcx, local_def(it.id)));\n-    let _indenter = indenter();\n-\n-    match it.node {\n-        ast::ItemEnum(ref enum_definition, _) => {\n-            check_enum_variants_sized(ccx,\n-                                      enum_definition.variants.as_slice());\n-        }\n-        ast::ItemStruct(..) => {\n-            check_fields_sized(ccx.tcx, &*ccx.tcx.map.expect_struct(it.id));\n-        }\n-        _ => {}\n-    }\n-}\n-\n pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n     debug!(\"check_item(it.id={}, it.ident={})\",\n            it.id,\n@@ -4866,7 +4800,6 @@ pub fn check_const_with_ty(fcx: &FnCtxt,\n     vtable2::select_all_fcx_obligations_or_error(fcx);\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n-    vtable2::check_builtin_bound_obligations(fcx);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -4954,39 +4887,6 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n }\n \n-\n-pub fn check_enum_variants_sized(ccx: &CrateCtxt,\n-                                 vs: &[P<ast::Variant>]) {\n-    for v in vs.iter() {\n-        match v.node.kind {\n-            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n-                let ctor_ty = ty::node_id_to_type(ccx.tcx, v.node.id);\n-                let arg_tys: Vec<ty::t> = ty::ty_fn_args(ctor_ty).iter().map(|a| *a).collect();\n-                let len = arg_tys.len();\n-                if len == 0 {\n-                    return;\n-                }\n-                for (i, t) in arg_tys.slice_to(len - 1).iter().enumerate() {\n-                    // Allow the last field in an enum to be unsized.\n-                    // We want to do this so that we can support smart pointers.\n-                    // A struct value with an unsized final field is itself\n-                    // unsized and we must track this in the type system.\n-                    if !ty::type_is_sized(ccx.tcx, *t) {\n-                        span_err!(ccx.tcx.sess, args.get(i).ty.span, E0078,\n-                            \"type `{}` is dynamically sized. dynamically sized types may only \\\n-                             appear as the final type in a variant\",\n-                             ppaux::ty_to_string(ccx.tcx, *t));\n-                    }\n-                }\n-            },\n-            ast::StructVariantKind(ref struct_def) => {\n-                check_fields_sized(ccx.tcx, &**struct_def)\n-            }\n-            _ => {}\n-        }\n-    }\n-}\n-\n pub fn check_enum_variants(ccx: &CrateCtxt,\n                            sp: Span,\n                            vs: &[P<ast::Variant>],"}, {"sha": "d45155c2ccd125e95e5442dab0b0c2442c757919", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -120,11 +120,13 @@ and report an error, and it just seems like more mess in the end.)\n \n use middle::def;\n use middle::mem_categorization as mc;\n+use middle::traits;\n use middle::ty::{ReScope};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::FnCtxt;\n use middle::typeck::check::regionmanip;\n+use middle::typeck::check::vtable2;\n use middle::typeck::infer::resolve_and_force_all_but_regions;\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n@@ -165,6 +167,11 @@ pub fn regionck_fn(fcx: &FnCtxt, id: ast::NodeId, blk: &ast::Block) {\n         // regionck assumes typeck succeeded\n         rcx.visit_fn_body(id, blk);\n     }\n+\n+    // Region checking a fn can introduce new trait obligations,\n+    // particularly around closure bounds.\n+    vtable2::select_all_fcx_obligations_or_error(fcx);\n+\n     fcx.infcx().resolve_regions_and_report_errors();\n }\n \n@@ -848,16 +855,6 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 }\n             });\n         }\n-        ty::ty_closure(box ty::ClosureTy{store: ty::UniqTraitStore,\n-                                         bounds: ref bounds,\n-                                         ..}) => {\n-            // For proc, ensure that the *types* of the variables\n-            // outlive region bound, since they are captured by value.\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                ensure_free_variable_types_outlive_closure_bound(\n-                    rcx, bounds.region_bound, expr, freevars);\n-            });\n-        }\n         ty::ty_unboxed_closure(_, region) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 // No free variables means that there is no environment and\n@@ -868,8 +865,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 // NDM -- this seems wrong, discuss with pcwalton, should\n                 // be straightforward enough.\n                 if !freevars.is_empty() {\n+                    let bounds = ty::region_existential_bound(region);\n                     ensure_free_variable_types_outlive_closure_bound(\n-                        rcx, region, expr, freevars);\n+                        rcx, bounds, expr, freevars);\n                 }\n             })\n         }\n@@ -881,20 +879,26 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n     rcx.set_repeating_scope(repeating_scope);\n \n     match ty::get(function_type).sty {\n-        ty::ty_closure(box ty::ClosureTy {\n-                store: ty::RegionTraitStore(..),\n-                ..\n-            }) => {\n+        ty::ty_closure(box ty::ClosureTy { store: ty::RegionTraitStore(..), .. }) => {\n             ty::with_freevars(tcx, expr.id, |freevars| {\n                 propagate_upupvar_borrow_kind(rcx, expr, freevars);\n             })\n         }\n-        _ => ()\n+        _ => {}\n+    }\n+\n+    match ty::get(function_type).sty {\n+        ty::ty_closure(box ty::ClosureTy {bounds, ..}) => {\n+            ty::with_freevars(tcx, expr.id, |freevars| {\n+                ensure_free_variable_types_outlive_closure_bound(rcx, bounds, expr, freevars);\n+            })\n+        }\n+        _ => {}\n     }\n \n     fn ensure_free_variable_types_outlive_closure_bound(\n         rcx: &mut Rcx,\n-        region_bound: ty::Region,\n+        bounds: ty::ExistentialBounds,\n         expr: &ast::Expr,\n         freevars: &[ty::Freevar])\n     {\n@@ -908,7 +912,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n         let tcx = rcx.fcx.ccx.tcx;\n \n         debug!(\"ensure_free_variable_types_outlive_closure_bound({}, {})\",\n-               region_bound.repr(tcx), expr.repr(tcx));\n+               bounds.region_bound.repr(tcx), expr.repr(tcx));\n \n         for freevar in freevars.iter() {\n             let var_node_id = {\n@@ -917,11 +921,35 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                 def_id.node\n             };\n \n-            let var_ty = rcx.resolve_node_type(var_node_id);\n+            // Compute the type of the field in the environment that\n+            // represents `var_node_id`.  For a by-value closure, this\n+            // will be the same as the type of the variable.  For a\n+            // by-reference closure, this will be `&T` where `T` is\n+            // the type of the variable.\n+            let raw_var_ty = rcx.resolve_node_type(var_node_id);\n+            let upvar_id = ty::UpvarId { var_id: var_node_id,\n+                                         closure_expr_id: expr.id };\n+            let var_ty = match rcx.fcx.inh.upvar_borrow_map.borrow().find(&upvar_id) {\n+                Some(upvar_borrow) => {\n+                    ty::mk_rptr(rcx.tcx(),\n+                                upvar_borrow.region,\n+                                ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n+                                         ty: raw_var_ty })\n+                }\n+                None => raw_var_ty\n+            };\n \n+            // Check that the type meets the criteria of the existential bounds:\n+            for builtin_bound in bounds.builtin_bounds.iter() {\n+                let code = traits::ClosureCapture(var_node_id, expr.span);\n+                let cause = traits::ObligationCause::new(freevar.span, code);\n+                let obligation = traits::obligation_for_builtin_bound(rcx.tcx(), cause,\n+                                                                      var_ty, builtin_bound);\n+                rcx.fcx.inh.fulfillment_cx.borrow_mut().register_obligation(rcx.tcx(), obligation);\n+            }\n             type_must_outlive(\n                 rcx, infer::RelateProcBound(expr.span, var_node_id, var_ty),\n-                var_ty, region_bound);\n+                var_ty, bounds.region_bound);\n         }\n     }\n "}, {"sha": "bcbcebc3f59279afd67f52bcbaf1dbc342f4bc6b", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 52, "deletions": 33, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -186,32 +186,15 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n     debug!(\"select_all_fcx_obligations_or_error\");\n \n     let mut fulfillment_cx = fcx.inh.fulfillment_cx.borrow_mut();\n-    let r =\n-        fulfillment_cx.select_all_or_error(\n-            fcx.infcx(),\n-            &fcx.inh.param_env,\n-            &*fcx.inh.unboxed_closures.borrow());\n+    let r = fulfillment_cx.select_all_or_error(fcx.infcx(),\n+                                               &fcx.inh.param_env,\n+                                               fcx);\n     match r {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n     }\n }\n \n-pub fn check_builtin_bound_obligations(fcx: &FnCtxt) {\n-    /*!\n-     * Hacky second pass to check builtin-bounds obligations *after*\n-     * writeback occurs.\n-     */\n-\n-    match\n-        fcx.inh.fulfillment_cx.borrow()\n-                              .check_builtin_bound_obligations(fcx.infcx())\n-    {\n-        Ok(()) => { }\n-        Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n-    }\n-}\n-\n fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n                      -> (ty::TraitRef, ty::t)\n {\n@@ -244,7 +227,8 @@ pub fn report_fulfillment_error(fcx: &FnCtxt,\n \n pub fn report_selection_error(fcx: &FnCtxt,\n                               obligation: &Obligation,\n-                              error: &SelectionError) {\n+                              error: &SelectionError)\n+{\n     match *error {\n         Unimplemented => {\n             let (trait_ref, self_ty) = resolve_trait_ref(fcx, obligation);\n@@ -309,15 +293,31 @@ pub fn maybe_report_ambiguity(fcx: &FnCtxt, obligation: &Obligation) {\n            obligation.repr(fcx.tcx()));\n     if ty::type_is_error(self_ty) {\n     } else if ty::type_needs_infer(self_ty) {\n-        fcx.tcx().sess.span_err(\n-            obligation.cause.span,\n-            format!(\n-                \"unable to infer enough type information to \\\n-             locate the impl of the trait `{}` for \\\n-             the type `{}`; type annotations required\",\n-            trait_ref.user_string(fcx.tcx()),\n-            self_ty.user_string(fcx.tcx())).as_slice());\n-        note_obligation_cause(fcx, obligation);\n+        // This is kind of a hack: it frequently happens that some earlier\n+        // error prevents types from being fully inferred, and then we get\n+        // a bunch of uninteresting errors saying something like \"<generic\n+        // #0> doesn't implement Sized\".  It may even be true that we\n+        // could just skip over all checks where the self-ty is an\n+        // inference variable, but I was afraid that there might be an\n+        // inference variable created, registered as an obligation, and\n+        // then never forced by writeback, and hence by skipping here we'd\n+        // be ignoring the fact that we don't KNOW the type works\n+        // out. Though even that would probably be harmless, given that\n+        // we're only talking about builtin traits, which are known to be\n+        // inhabited. But in any case I just threw in this check for\n+        // has_errors() to be sure that compilation isn't happening\n+        // anyway. In that case, why inundate the user.\n+        if !fcx.tcx().sess.has_errors() {\n+            fcx.tcx().sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"unable to infer enough type information to \\\n+                     locate the impl of the trait `{}` for \\\n+                     the type `{}`; type annotations required\",\n+                    trait_ref.user_string(fcx.tcx()),\n+                    self_ty.user_string(fcx.tcx())).as_slice());\n+            note_obligation_cause(fcx, obligation);\n+        }\n     } else if fcx.tcx().sess.err_count() == 0 {\n          // Ambiguity. Coherence should have reported an error.\n         fcx.tcx().sess.span_bug(\n@@ -337,9 +337,7 @@ pub fn select_fcx_obligations_where_possible(fcx: &FnCtxt) {\n     match\n         fcx.inh.fulfillment_cx\n         .borrow_mut()\n-        .select_where_possible(fcx.infcx(),\n-                               &fcx.inh.param_env,\n-                               &*fcx.inh.unboxed_closures.borrow())\n+        .select_where_possible(fcx.infcx(), &fcx.inh.param_env, fcx)\n     {\n         Ok(()) => { }\n         Err(errors) => { report_fulfillment_errors(fcx, &errors); }\n@@ -392,5 +390,26 @@ fn note_obligation_cause(fcx: &FnCtxt,\n                 obligation.cause.span,\n                 \"structs must have a statically known size to be initialized\");\n         }\n+        traits::DropTrait => {\n+            span_note!(tcx.sess, obligation.cause.span,\n+                      \"cannot implement a destructor on a \\\n+                      structure or enumeration that does not satisfy Send\");\n+            span_note!(tcx.sess, obligation.cause.span,\n+                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n+                       to force the compiler to allow this\");\n+        }\n+        traits::ClosureCapture(var_id, closure_span) => {\n+            let name = ty::local_var_name_str(tcx, var_id);\n+            span_note!(tcx.sess, closure_span,\n+                       \"the closure that captures `{}` requires that all captured variables \\\"\n+                       implement the trait `{}`\",\n+                       name,\n+                       trait_name);\n+        }\n+        traits::FieldSized => {\n+            span_note!(tcx.sess, obligation.cause.span,\n+                       \"only the last field of a struct or enum variant \\\n+                       may have a dynamically sized type\")\n+        }\n     }\n }"}, {"sha": "67f93feae41971affeb060707fe4b8af60f1d19a", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 128, "deletions": 23, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::subst;\n use middle::subst::{Subst};\n use middle::traits;\n use middle::ty;\n@@ -21,6 +22,7 @@ use util::ppaux::Repr;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::{local_def};\n+use syntax::attr;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -57,7 +59,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                item.id,\n                ty::item_path_str(ccx.tcx, local_def(item.id)));\n \n-        let ccx = self.ccx;\n         match item.node {\n             ast::ItemImpl(..) => {\n                 self.check_impl(item);\n@@ -68,26 +69,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ast::ItemStatic(..) => {\n                 self.check_item_type(item);\n             }\n-            ast::ItemStruct(..) => {\n+            ast::ItemStruct(ref struct_def, _) => {\n                 self.check_type_defn(item, |fcx| {\n-                    ty::struct_fields(ccx.tcx, local_def(item.id),\n-                                      &fcx.inh.param_env.free_substs)\n-                        .iter()\n-                        .map(|f| f.mt.ty)\n-                        .collect()\n+                    vec![struct_variant(fcx, &**struct_def)]\n                 });\n             }\n-            ast::ItemEnum(..) => {\n+            ast::ItemEnum(ref enum_def, _) => {\n                 self.check_type_defn(item, |fcx| {\n-                    ty::substd_enum_variants(ccx.tcx, local_def(item.id),\n-                                             &fcx.inh.param_env.free_substs)\n-                        .iter()\n-                        .flat_map(|variant| {\n-                            variant.args\n-                                .iter()\n-                                .map(|&arg_ty| arg_ty)\n-                        })\n-                        .collect()\n+                    enum_variants(fcx, enum_def)\n                 });\n             }\n             _ => {}\n@@ -110,27 +99,43 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         f(self, &fcx);\n         vtable2::select_all_fcx_obligations_or_error(&fcx);\n         regionck::regionck_item(&fcx, item);\n-        vtable2::check_builtin_bound_obligations(&fcx);\n     }\n \n     fn check_type_defn(&mut self,\n                        item: &ast::Item,\n-                       lookup_fields: |&FnCtxt| -> Vec<ty::t>)\n+                       lookup_fields: |&FnCtxt| -> Vec<AdtVariant>)\n     {\n         /*!\n          * In a type definition, we check that to ensure that the types of the fields are\n          * well-formed.\n          */\n \n         self.with_fcx(self.ccx, item, |this, fcx| {\n-            let field_tys = lookup_fields(fcx);\n+            let variants = lookup_fields(fcx);\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n-            for &ty in field_tys.iter() {\n-                // Regions are checked below.\n-                bounds_checker.check_traits_in_ty(ty);\n+            for variant in variants.iter() {\n+                for field in variant.fields.iter() {\n+                    // Regions are checked below.\n+                    bounds_checker.check_traits_in_ty(field.ty);\n+                }\n+\n+                // For DST, all intermediate types must be sized.\n+                if variant.fields.len() > 0 {\n+                    for field in variant.fields.init().iter() {\n+                        let cause = traits::ObligationCause::new(field.span, traits::FieldSized);\n+                        fcx.register_obligation(\n+                            traits::obligation_for_builtin_bound(fcx.tcx(),\n+                                                                 cause,\n+                                                                 field.ty,\n+                                                                 ty::BoundSized));\n+                    }\n+                }\n             }\n \n+            let field_tys: Vec<ty::t> =\n+                variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n+\n             regionck::regionck_ensure_component_tys_wf(\n                 fcx, item.span, field_tys.as_slice());\n         });\n@@ -166,6 +171,22 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             };\n             let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n \n+            // There are special rules that apply to drop.\n+            if\n+                fcx.tcx().lang_items.drop_trait() == Some(trait_ref.def_id) &&\n+                !attr::contains_name(item.attrs.as_slice(), \"unsafe_destructor\")\n+            {\n+                match ty::get(self_ty).sty {\n+                    ty::ty_struct(def_id, _) |\n+                    ty::ty_enum(def_id, _) => {\n+                        check_struct_safe_for_destructor(fcx, item.span, self_ty, def_id);\n+                    }\n+                    _ => {\n+                        // Coherence already reports an error in this case.\n+                    }\n+                }\n+            }\n+\n             // We are stricter on the trait-ref in an impl than the\n             // self-type.  In particular, we enforce region\n             // relationships. The reason for this is that (at least\n@@ -363,3 +384,87 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         t // we're not folding to produce a new type, so just return `t` here\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// ADT\n+\n+struct AdtVariant {\n+    fields: Vec<AdtField>,\n+}\n+\n+struct AdtField {\n+    ty: ty::t,\n+    span: Span,\n+}\n+\n+fn struct_variant(fcx: &FnCtxt, struct_def: &ast::StructDef) -> AdtVariant {\n+    let fields =\n+        struct_def.fields\n+        .iter()\n+        .map(|field| {\n+            let field_ty = ty::node_id_to_type(fcx.tcx(), field.node.id);\n+            let field_ty = field_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            AdtField { ty: field_ty, span: field.span }\n+        })\n+        .collect();\n+    AdtVariant { fields: fields }\n+}\n+\n+fn enum_variants(fcx: &FnCtxt, enum_def: &ast::EnumDef) -> Vec<AdtVariant> {\n+    enum_def.variants.iter()\n+        .map(|variant| {\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+                    let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n+                    let arg_tys = ty::ty_fn_args(ctor_ty);\n+                    AdtVariant {\n+                        fields: args.iter().enumerate().map(|(index, arg)| {\n+                            let arg_ty = arg_tys[index];\n+                            let arg_ty = arg_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+                            AdtField {\n+                                ty: arg_ty,\n+                                span: arg.ty.span\n+                            }\n+                        }).collect()\n+                    }\n+                }\n+                ast::TupleVariantKind(_) => {\n+                    AdtVariant {\n+                        fields: Vec::new()\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    struct_variant(fcx, &**struct_def)\n+                }\n+            }\n+        })\n+        .collect()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Special drop trait checking\n+\n+fn check_struct_safe_for_destructor(fcx: &FnCtxt,\n+                                    span: Span,\n+                                    self_ty: ty::t,\n+                                    struct_did: ast::DefId) {\n+    let struct_tpt = ty::lookup_item_type(fcx.tcx(), struct_did);\n+    if !struct_tpt.generics.has_type_params(subst::TypeSpace)\n+        && !struct_tpt.generics.has_region_params(subst::TypeSpace)\n+    {\n+        let cause = traits::ObligationCause::new(span, traits::DropTrait);\n+        fcx.register_obligation(\n+            traits::obligation_for_builtin_bound(\n+                fcx.tcx(),\n+                cause,\n+                self_ty,\n+                ty::BoundSend));\n+    } else {\n+        span_err!(fcx.tcx().sess, span, E0141,\n+                  \"cannot implement a destructor on a structure \\\n+                       with type parameters\");\n+            span_note!(fcx.tcx().sess, span,\n+                       \"use \\\"#[unsafe_destructor]\\\" on the implementation \\\n+                        to force the compiler to allow this\");\n+    }\n+}"}, {"sha": "2ad6a1f72e2cc53c20d39ef8656a2a55d1ad07db", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -1560,7 +1560,7 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                     \"...so that it can be closed over into an object\");\n             }\n             infer::RelateProcBound(span, var_node_id, _ty) => {\n-                self.tcx.sess.span_err(\n+                self.tcx.sess.span_note(\n                     span,\n                     format!(\n                         \"...so that the variable `{}` can be captured \\"}, {"sha": "c36192777f0a98c7caa4f88111d6a5df57d723da", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -13,20 +13,20 @@\n #![allow(non_camel_case_types)]\n \n pub use middle::ty::IntVarValue;\n-pub use middle::typeck::infer::resolve::resolve_and_force_all_but_regions;\n-pub use middle::typeck::infer::resolve::{force_all, not_regions};\n-pub use middle::typeck::infer::resolve::{force_ivar};\n-pub use middle::typeck::infer::resolve::{force_tvar, force_rvar};\n-pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n-pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n-pub use middle::typeck::infer::resolve::{resolve_rvar};\n+pub use self::resolve::resolve_and_force_all_but_regions;\n+pub use self::resolve::{force_all, not_regions};\n+pub use self::resolve::{force_ivar};\n+pub use self::resolve::{force_tvar, force_rvar};\n+pub use self::resolve::{resolve_ivar, resolve_all};\n+pub use self::resolve::{resolve_nested_tvar};\n+pub use self::resolve::{resolve_rvar};\n+pub use self::skolemize::TypeSkolemizer;\n \n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n-use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n@@ -382,13 +382,6 @@ pub fn verify_param_bound(cx: &InferCtxt,\n     cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n }\n \n-pub fn skolemize<T:TypeFoldable+Repr>(cx: &InferCtxt, a: T) -> T {\n-    let mut skol = skolemize::TypeSkolemizer::new(cx);\n-    let b = a.fold_with(&mut skol);\n-    debug!(\"skol(a={}) -> {}\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    b\n-}\n-\n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n@@ -513,6 +506,10 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn skolemizer<'a>(&'a self) -> TypeSkolemizer<'a, 'tcx> {\n+        skolemize::TypeSkolemizer::new(self)\n+    }\n+\n     pub fn combine_fields<'a>(&'a self, a_is_expected: bool, trace: TypeTrace)\n                               -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,"}, {"sha": "4002f5984497b8899301d52dcea39fe20fb93787", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -119,9 +119,16 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n                 self.probe_unifiable(v)\n             }\n \n-            ty::ty_infer(ty::SkolemizedTy(_)) |\n-            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n-                self.tcx().sess.bug(\"Cannot skolemize a skolemized type\");\n+            ty::ty_infer(ty::SkolemizedTy(c)) |\n+            ty::ty_infer(ty::SkolemizedIntTy(c)) => {\n+                if c >= self.skolemization_count {\n+                    self.tcx().sess.bug(\n+                        format!(\"Encountered a skolemized type with id {} \\\n+                                 but our counter is only at {}\",\n+                                c,\n+                                self.skolemization_count).as_slice());\n+                }\n+                t\n             }\n \n             ty::ty_open(..) => {"}, {"sha": "6769740294bc6c7892c78c9b55048c05c3ff3b20", "filename": "src/test/compile-fail/closure-bounds-static-cant-capture-borrowed.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-static-cant-capture-borrowed.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -12,8 +12,9 @@ fn bar(blk: ||:'static) {\n }\n \n fn foo(x: &()) {\n-    bar(|| {\n-        let _ = x; //~ ERROR captured variable `x` does not outlive\n+    bar(|| { //~ ERROR cannot infer an appropriate lifetime\n+        let _ = x;\n+        //~^ ERROR captured variable `x` does not outlive\n     })\n }\n "}, {"sha": "356d95452b3e1788789d9acfcdedd8b038479455", "filename": "src/test/compile-fail/issue-12187-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-1.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -14,5 +14,5 @@ fn new<T>() -> &'static T {\n \n fn main() {\n     let &v = new();\n-    //~^ ERROR cannot determine a type for this local variable: unconstrained type\n+    //~^ ERROR type annotations required\n }"}, {"sha": "a67d9dee9768f206e9e0ed6e9c1632f5c969b4c3", "filename": "src/test/compile-fail/issue-12187-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12187-2.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -14,5 +14,5 @@ fn new<'r, T>() -> &'r T {\n \n fn main() {\n     let &v = new();\n-    //~^ ERROR cannot determine a type for this local variable: unconstrained type\n+    //~^ ERROR type annotations required\n }"}, {"sha": "4512eb3f70aceeca7ac618493259cfa83192364b", "filename": "src/test/compile-fail/issue-14915.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14915.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -15,8 +15,5 @@ fn main() {\n     let y: Gc<int> = box (GC) 0;\n \n     println!(\"{}\", x + 1); //~ ERROR binary operation `+` cannot be applied to type `Box<int>`\n-    //~^ ERROR unable to infer enough type information\n-    println!(\"{}\", y + 1);\n-    //~^ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n-    //~^^ ERROR unable to infer enough type information\n+    println!(\"{}\", y + 1); //~ ERROR binary operation `+` cannot be applied to type `Gc<int>`\n }"}, {"sha": "df888fe78021bf9d3c804a5349c6786860ec5ddf", "filename": "src/test/compile-fail/issue-5062.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5062.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -10,4 +10,5 @@\n \n extern crate debug;\n \n-fn main() { format!(\"{:?}\", None); } //~ ERROR unconstrained type\n+fn main() { format!(\"{:?}\", None); }\n+    //~^ ERROR type annotations required"}, {"sha": "cb3ffae5dbae3df047b03159c3daeed3e38a0259", "filename": "src/test/compile-fail/issue-6458-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-1.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -9,4 +9,5 @@\n // except according to those terms.\n \n fn foo<T>(t: T) {}\n-fn main() { foo(fail!()) } //~ ERROR cannot determine a type for this expression: unconstrained type\n+fn main() { foo(fail!()) }\n+    //~^ ERROR type annotations required"}, {"sha": "94884c133b71645c130ee4162ba5aca850707605", "filename": "src/test/compile-fail/issue-6458-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-2.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -12,5 +12,6 @@ extern crate debug;\n \n fn main() {\n     // Unconstrained type:\n-    format!(\"{:?}\", None); //~ ERROR: E0101\n+    format!(\"{:?}\", None);\n+    //~^ ERROR type annotations required\n }"}, {"sha": "f96faeeec4bd198e696f93178b1df75d57ab3cf4", "filename": "src/test/compile-fail/issue-6458-3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-3.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -11,5 +11,6 @@\n use std::mem;\n \n fn main() {\n-    mem::transmute(0);  //~ ERROR: cannot determine a type for this expression: unconstrained type\n+    mem::transmute(0);\n+    //~^ ERROR type annotations required\n }"}, {"sha": "02274e5441e26bb8142e2b6714429827922cd716", "filename": "src/test/compile-fail/issue-6458-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458-4.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -10,7 +10,7 @@\n \n fn foo(b: bool) -> Result<bool,String> {\n     Err(\"bar\".to_string());\n-    //~^ ERROR: cannot determine a type for this expression: unconstrained type\n+    //~^ ERROR type annotations required\n }\n \n fn main() {"}, {"sha": "efa3100360b5c0e0c4c000ad09a1cd785ca22407", "filename": "src/test/compile-fail/issue-6458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6458.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -14,7 +14,7 @@ pub struct MyState;\n pub fn foo<State>(_: TypeWithState<State>) {}\n \n pub fn bar() {\n-   foo(TypeWithState); //~ ERROR: cannot determine a type for this expression: unconstrained type\n+   foo(TypeWithState);  //~ ERROR type annotations required\n }\n \n fn main() {"}, {"sha": "81421af4fa839a9f0dc00a4ef76540eb4f9e6a95", "filename": "src/test/compile-fail/issue-7813.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7813.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    let v = &[]; //~ ERROR cannot determine a type for this local variable: unconstrained type\n-    let it = v.iter();\n+    let v = &[];\n+    let it = v.iter(); //~ ERROR type annotations required\n }"}, {"sha": "e50bb8fbede657c63e537e6d596fa771a392c4eb", "filename": "src/test/compile-fail/kindck-destructor-owned.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -16,7 +16,27 @@ struct Foo {\n }\n \n impl Drop for Foo {\n-//~^ ERROR cannot implement a destructor on a structure or enumeration that does not satisfy Send\n+//~^ ERROR the trait `core::kinds::Send` is not implemented for the type `Foo`\n+//~^^ NOTE cannot implement a destructor on a structure or enumeration that does not satisfy Send\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct Bar<'a> {\n+    f: &'a int,\n+}\n+\n+impl<'a> Drop for Bar<'a> {\n+//~^ ERROR E0141\n+    fn drop(&mut self) {\n+    }\n+}\n+\n+struct Baz {\n+    f: &'static int,\n+}\n+\n+impl Drop for Baz {\n     fn drop(&mut self) {\n     }\n }"}, {"sha": "f292d1599823ffeffc8af60f1747be13d05cc71c", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -15,8 +15,8 @@ fn foo(_x: Gc<uint>) {}\n \n fn main() {\n     let x = box(GC) 3u;\n-    let _: proc():Send = proc() foo(x); //~ ERROR does not fulfill `Send`\n-    let _: proc():Send = proc() foo(x); //~ ERROR does not fulfill `Send`\n-    let _: proc():Send = proc() foo(x); //~ ERROR does not fulfill `Send`\n+    let _: proc():Send = proc() foo(x); //~ ERROR `core::kinds::Send` is not implemented\n+    let _: proc():Send = proc() foo(x); //~ ERROR `core::kinds::Send` is not implemented\n+    let _: proc():Send = proc() foo(x); //~ ERROR `core::kinds::Send` is not implemented\n     let _: proc() = proc() foo(x);\n }"}, {"sha": "ff8daa045c66d3b7c51a439a31e3cb0e0fefde6c", "filename": "src/test/compile-fail/kindck-send-object1.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-send-object1.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -17,11 +17,12 @@ trait Dummy { }\n \n // careful with object types, who knows what they close over...\n fn test51<'a>() {\n-    assert_send::<&'a Dummy>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a Dummy>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n fn test52<'a>() {\n-    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<&'a Dummy+Send>();\n+    //~^ ERROR does not fulfill the required lifetime\n }\n \n // ...unless they are properly bounded\n@@ -35,12 +36,12 @@ fn test61() {\n // closure and object types can have lifetime bounds which make\n // them not ok\n fn test_70<'a>() {\n-    assert_send::<proc():'a>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<proc():'a>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n \n fn test_71<'a>() {\n-    assert_send::<Box<Dummy+'a>>(); //~ ERROR does not fulfill the required lifetime\n+    assert_send::<Box<Dummy+'a>>();\n     //~^ ERROR the trait `core::kinds::Send` is not implemented\n }\n "}, {"sha": "ddbfbc41ecaf3cfd18bdca3a60ac004eb5359069", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -37,7 +37,7 @@ fn main() {\n \n     task::spawn(proc() {\n         let y = x;\n-        //~^ ERROR does not fulfill `Send`\n+        //~^ ERROR `core::kinds::Send` is not implemented\n         println!(\"{:?}\", y);\n     });\n }"}, {"sha": "182b40ceaae03d544a3ef7bda139b6320947587f", "filename": "src/test/compile-fail/regions-bounded-by-send.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounded-by-send.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -57,21 +57,22 @@ fn box_with_region_not_ok<'a>() {\n // objects with insufficient bounds no ok\n \n fn object_with_random_bound_not_ok<'a>() {\n-    assert_send::<&'a Dummy+'a>(); //~ ERROR does not fulfill\n+    assert_send::<&'a Dummy+'a>();\n     //~^ ERROR not implemented\n }\n \n fn object_with_send_bound_not_ok<'a>() {\n-    assert_send::<&'a Dummy+Send>(); //~ ERROR does not fulfill\n+    assert_send::<&'a Dummy+Send>();\n+    //~^ ERROR does not fulfill\n }\n \n fn proc_with_lifetime_not_ok<'a>() {\n-    assert_send::<proc():'a>(); //~ ERROR does not fulfill\n+    assert_send::<proc():'a>();\n     //~^ ERROR not implemented\n }\n \n fn closure_with_lifetime_not_ok<'a>() {\n-    assert_send::<||:'a>(); //~ ERROR does not fulfill\n+    assert_send::<||:'a>();\n     //~^ ERROR not implemented\n }\n "}, {"sha": "0691ad0de732315ecae9bfe702a8f9476c5fc203", "filename": "src/test/compile-fail/regions-enum-not-wf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-enum-not-wf.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -10,7 +10,6 @@\n \n // Various examples of structs whose fields are not well-formed.\n \n-#![no_std]\n #![allow(dead_code)]\n \n enum Ref1<'a, T> { //~ ERROR the parameter type `T` may not live long enough"}, {"sha": "9879766a8fa256431c80646c10ba03f85ccb0fd1", "filename": "src/test/compile-fail/unconstrained-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-none.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -11,5 +11,5 @@\n // Issue #5062\n \n fn main() {\n-    None; //~ ERROR cannot determine a type for this expression: unconstrained type\n+    None; //~ ERROR type annotations required\n }"}, {"sha": "e03f60e758ce2eebc043f68d75d956e5563056b4", "filename": "src/test/compile-fail/unconstrained-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -13,5 +13,5 @@ struct S<'a, T:'a> {\n }\n \n fn main() {\n-    S { o: &None }; //~ ERROR cannot determine a type for this expression: unconstrained type\n+    S { o: &None }; //~ ERROR type annotations required\n }"}, {"sha": "41196b60c8eba261273d0517708fc01401324a44", "filename": "src/test/compile-fail/unsized5.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Funsized5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsized5.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -12,25 +12,25 @@\n // Test `Sized?` types not allowed in fields (except the last one).\n \n struct S1<Sized? X> {\n-    f1: X, //~ ERROR type `f1` is dynamically sized. dynamically sized types may only appear as the\n+    f1: X, //~ ERROR `core::kinds::Sized` is not implemented\n     f2: int,\n }\n struct S2<Sized? X> {\n     f: int,\n-    g: X, //~ ERROR type `g` is dynamically sized. dynamically sized types may only appear as the ty\n+    g: X, //~ ERROR `core::kinds::Sized` is not implemented\n     h: int,\n }\n struct S3 {\n-    f: str, //~ ERROR type `f` is dynamically sized. dynamically sized types may only appear\n+    f: str, //~ ERROR `core::kinds::Sized` is not implemented\n     g: [uint]\n }\n struct S4 {\n-    f: str, //~ ERROR type `f` is dynamically sized. dynamically sized types may only appear\n+    f: str, //~ ERROR `core::kinds::Sized` is not implemented\n     g: uint\n }\n enum E<Sized? X> {\n-    V1(X, int), //~ERROR type `X` is dynamically sized. dynamically sized types may only appear as t\n-    V2{f1: X, f: int}, //~ERROR type `f1` is dynamically sized. dynamically sized types may only app\n+    V1(X, int), //~ERROR `core::kinds::Sized` is not implemented\n+    V2{f1: X, f: int}, //~ERROR `core::kinds::Sized` is not implemented\n }\n \n pub fn main() {"}, {"sha": "d48f5715ec1b980879c415842a6edd6b19f7f87a", "filename": "src/test/compile-fail/vector-no-ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-no-ann.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -10,5 +10,5 @@\n \n \n fn main() {\n-    let _foo = Vec::new(); //~ ERROR unconstrained type\n+    let _foo = Vec::new(); //~ ERROR type annotations required\n }"}, {"sha": "721d16b4810c8f708b0b4fc33ffc3fba632a2394", "filename": "src/test/run-make/no-duplicate-libs/bar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -19,3 +19,4 @@ pub extern fn bar() {}\n \n #[lang = \"stack_exhausted\"] fn stack_exhausted() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n+#[lang = \"fail_fmt\"] fn fail_fmt() -> ! { loop {} }"}, {"sha": "3382cc207997288494f09f77e0fade89e0ad9c8e", "filename": "src/test/run-make/no-duplicate-libs/foo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -19,3 +19,4 @@ pub extern fn foo() {}\n \n #[lang = \"stack_exhausted\"] fn stack_exhausted() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n+#[lang = \"fail_fmt\"] fn fail_fmt() -> ! { loop {} }"}, {"sha": "fdddac6bc375b1bc0aa6ab401008637f517a1410", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2550243b4183783e463fbb0bc141ab77f2898e64/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=2550243b4183783e463fbb0bc141ab77f2898e64", "patch": "@@ -22,7 +22,7 @@ extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n \n #[lang = \"stack_exhausted\"] extern fn stack_exhausted() {}\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-#[lang = \"sized\"] pub trait Sized {}\n+#[lang = \"fail_fmt\"] fn fail_fmt() -> ! { loop {} }\n \n #[start]\n #[no_split_stack]"}]}