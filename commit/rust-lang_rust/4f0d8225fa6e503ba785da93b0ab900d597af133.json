{"sha": "4f0d8225fa6e503ba785da93b0ab900d597af133", "node_id": "C_kwDOAAsO6NoAKDRmMGQ4MjI1ZmE2ZTUwM2JhNzg1ZGE5M2IwYWI5MDBkNTk3YWYxMzM", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2023-04-23T01:27:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-23T01:27:52Z"}, "message": "Implement dynamic byte-swizzle prototype (rust-lang/portable-simd#334)\n\nThis is meant to be an example that is used to test\r\na Rust intrinsic against, which will replace it.\r\nThe interface is fairly direct and doesn't address\r\nmore nuanced or interesting permutations one can do,\r\nnevermind on types other than bytes.\r\n\r\nThe ultimate goal is for direct LLVM support for this.", "tree": {"sha": "073679ab9cd43446d5cc011726e6dc244f5812f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/073679ab9cd43446d5cc011726e6dc244f5812f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f0d8225fa6e503ba785da93b0ab900d597af133", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkRImYCRBK7hj4Ov3rIwAA4AoIAEImkqI9OzSHBmGtt4NWRNdP\n/miRJg5+1RhXO7c2VT/8u5D5G89KOjr5phcEK9rR041+YPOtxSqjhKnxn90owTOU\nszGQo3SKGTE/bxK73IOgekP5SFO15fgl6e/iQWa+rKMZzCjTjWEhdJwlqppT7JET\nQQxoJVeP9d+GHZuxD53IsF+HROemhFyMtUetcqgLVkfIG+YrGWQNybRRgiuBYKuB\nFwSJayaQ62kBBEC46GuVtGg4kpPzK0EwnOyzzysB8QkphpuF6lIsHmPJ2dbNtdeC\novhiu5qhzlOj9JczYswvRvSofpRfFFpfuvgGtDMmaSc52jHmYjzHMvV3m6P1pTw=\n=I+dF\n-----END PGP SIGNATURE-----\n", "payload": "tree 073679ab9cd43446d5cc011726e6dc244f5812f7\nparent f916add75d58dd3310e4cc217a1982d385d975a5\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1682213272 -0700\ncommitter GitHub <noreply@github.com> 1682213272 -0700\n\nImplement dynamic byte-swizzle prototype (rust-lang/portable-simd#334)\n\nThis is meant to be an example that is used to test\r\na Rust intrinsic against, which will replace it.\r\nThe interface is fairly direct and doesn't address\r\nmore nuanced or interesting permutations one can do,\r\nnevermind on types other than bytes.\r\n\r\nThe ultimate goal is for direct LLVM support for this.\r\n\r\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f0d8225fa6e503ba785da93b0ab900d597af133", "html_url": "https://github.com/rust-lang/rust/commit/4f0d8225fa6e503ba785da93b0ab900d597af133", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f0d8225fa6e503ba785da93b0ab900d597af133/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f916add75d58dd3310e4cc217a1982d385d975a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f916add75d58dd3310e4cc217a1982d385d975a5", "html_url": "https://github.com/rust-lang/rust/commit/f916add75d58dd3310e4cc217a1982d385d975a5"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "35c659b7a429a6b151220f262dd1cc2072dcca41", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f0d8225fa6e503ba785da93b0ab900d597af133/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0d8225fa6e503ba785da93b0ab900d597af133/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=4f0d8225fa6e503ba785da93b0ab900d597af133", "patch": "@@ -17,6 +17,7 @@ mod masks;\n mod ops;\n mod ord;\n mod select;\n+mod swizzle_dyn;\n mod vector;\n mod vendor;\n \n@@ -32,5 +33,6 @@ pub mod simd {\n     pub use crate::core_simd::masks::*;\n     pub use crate::core_simd::ord::*;\n     pub use crate::core_simd::swizzle::*;\n+    pub use crate::core_simd::swizzle_dyn::*;\n     pub use crate::core_simd::vector::*;\n }"}, {"sha": "5c3a2c1824ff48d06c78b51476b38fd4a422b6a7", "filename": "crates/core_simd/src/swizzle_dyn.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4f0d8225fa6e503ba785da93b0ab900d597af133/crates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0d8225fa6e503ba785da93b0ab900d597af133/crates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs?ref=4f0d8225fa6e503ba785da93b0ab900d597af133", "patch": "@@ -0,0 +1,155 @@\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use core::mem;\n+\n+impl<const N: usize> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Swizzle a vector of bytes according to the index vector.\n+    /// Indices within range select the appropriate byte.\n+    /// Indices \"out of bounds\" instead select 0.\n+    ///\n+    /// Note that the current implementation is selected during build-time\n+    /// of the standard library, so `cargo build -Zbuild-std` may be necessary\n+    /// to unlock better performance, especially for larger vectors.\n+    /// A planned compiler improvement will enable using `#[target_feature]` instead.\n+    #[inline]\n+    pub fn swizzle_dyn(self, idxs: Simd<u8, N>) -> Self {\n+        #![allow(unused_imports, unused_unsafe)]\n+        #[cfg(target_arch = \"aarch64\")]\n+        use core::arch::aarch64::{uint8x8_t, vqtbl1q_u8, vtbl1_u8};\n+        #[cfg(all(target_arch = \"arm\", target_feature = \"v7\"))]\n+        use core::arch::arm::{uint8x8_t, vtbl1_u8};\n+        #[cfg(target_arch = \"wasm32\")]\n+        use core::arch::wasm32 as wasm;\n+        #[cfg(target_arch = \"x86\")]\n+        use core::arch::x86;\n+        #[cfg(target_arch = \"x86_64\")]\n+        use core::arch::x86_64 as x86;\n+        // SAFETY: Intrinsics covered by cfg\n+        unsafe {\n+            match N {\n+                #[cfg(target_feature = \"neon\")]\n+                8 => transize(vtbl1_u8, self, idxs),\n+                #[cfg(target_feature = \"ssse3\")]\n+                16 => transize(x86::_mm_shuffle_epi8, self, idxs),\n+                #[cfg(target_feature = \"simd128\")]\n+                16 => transize(wasm::i8x16_swizzle, self, idxs),\n+                #[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\n+                16 => transize(vqtbl1q_u8, self, idxs),\n+                #[cfg(all(target_feature = \"avx2\", not(target_feature = \"avx512vbmi\")))]\n+                32 => transize_raw(avx2_pshufb, self, idxs),\n+                #[cfg(target_feature = \"avx512vl,avx512vbmi\")]\n+                32 => transize(x86::_mm256_permutexvar_epi8, self, idxs),\n+                // Notable absence: avx512bw shuffle\n+                // If avx512bw is available, odds of avx512vbmi are good\n+                #[cfg(target_feature = \"avx512vbmi\")]\n+                64 => transize(x86::_mm512_permutexvar_epi8, self, idxs),\n+                _ => {\n+                    let mut array = [0; N];\n+                    for (i, k) in idxs.to_array().into_iter().enumerate() {\n+                        if (k as usize) < N {\n+                            array[i] = self[k as usize];\n+                        };\n+                    }\n+                    array.into()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// \"vpshufb like it was meant to be\" on AVX2\n+///\n+/// # Safety\n+/// This requires AVX2 to work\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[target_feature(enable = \"avx2\")]\n+#[allow(unused)]\n+#[inline]\n+unsafe fn avx2_pshufb(bytes: Simd<u8, 32>, idxs: Simd<u8, 32>) -> Simd<u8, 32> {\n+    use crate::simd::SimdPartialOrd;\n+    #[cfg(target_arch = \"x86\")]\n+    use core::arch::x86;\n+    #[cfg(target_arch = \"x86_64\")]\n+    use core::arch::x86_64 as x86;\n+    use x86::_mm256_permute2x128_si256 as avx2_cross_shuffle;\n+    use x86::_mm256_shuffle_epi8 as avx2_half_pshufb;\n+    let mid = Simd::splat(16u8);\n+    let high = mid + mid;\n+    // SAFETY: Caller promised AVX2\n+    unsafe {\n+        // This is ordering sensitive, and LLVM will order these how you put them.\n+        // Most AVX2 impls use ~5 \"ports\", and only 1 or 2 are capable of permutes.\n+        // But the \"compose\" step will lower to ops that can also use at least 1 other port.\n+        // So this tries to break up permutes so composition flows through \"open\" ports.\n+        // Comparative benches should be done on multiple AVX2 CPUs before reordering this\n+\n+        let hihi = avx2_cross_shuffle::<0x11>(bytes.into(), bytes.into());\n+        let hi_shuf = Simd::from(avx2_half_pshufb(\n+            hihi,        // duplicate the vector's top half\n+            idxs.into(), // so that using only 4 bits of an index still picks bytes 16-31\n+        ));\n+        // A zero-fill during the compose step gives the \"all-Neon-like\" OOB-is-0 semantics\n+        let compose = idxs.simd_lt(high).select(hi_shuf, Simd::splat(0));\n+        let lolo = avx2_cross_shuffle::<0x00>(bytes.into(), bytes.into());\n+        let lo_shuf = Simd::from(avx2_half_pshufb(lolo, idxs.into()));\n+        // Repeat, then pick indices < 16, overwriting indices 0-15 from previous compose step\n+        let compose = idxs.simd_lt(mid).select(lo_shuf, compose);\n+        compose\n+    }\n+}\n+\n+/// This sets up a call to an architecture-specific function, and in doing so\n+/// it persuades rustc that everything is the correct size. Which it is.\n+/// This would not be needed if one could convince Rust that, by matching on N,\n+/// N is that value, and thus it would be valid to substitute e.g. 16.\n+///\n+/// # Safety\n+/// The correctness of this function hinges on the sizes agreeing in actuality.\n+#[allow(dead_code)]\n+#[inline(always)]\n+unsafe fn transize<T, const N: usize>(\n+    f: unsafe fn(T, T) -> T,\n+    bytes: Simd<u8, N>,\n+    idxs: Simd<u8, N>,\n+) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    let idxs = zeroing_idxs(idxs);\n+    // SAFETY: Same obligation to use this function as to use mem::transmute_copy.\n+    unsafe { mem::transmute_copy(&f(mem::transmute_copy(&bytes), mem::transmute_copy(&idxs))) }\n+}\n+\n+/// Make indices that yield 0 for this architecture\n+#[inline(always)]\n+fn zeroing_idxs<const N: usize>(idxs: Simd<u8, N>) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    // On x86, make sure the top bit is set.\n+    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+    let idxs = {\n+        use crate::simd::SimdPartialOrd;\n+        idxs.simd_lt(Simd::splat(N as u8))\n+            .select(idxs, Simd::splat(u8::MAX))\n+    };\n+    // Simply do nothing on most architectures.\n+    idxs\n+}\n+\n+/// As transize but no implicit call to `zeroing_idxs`.\n+#[allow(dead_code)]\n+#[inline(always)]\n+unsafe fn transize_raw<T, const N: usize>(\n+    f: unsafe fn(T, T) -> T,\n+    bytes: Simd<u8, N>,\n+    idxs: Simd<u8, N>,\n+) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    // SAFETY: Same obligation to use this function as to use mem::transmute_copy.\n+    unsafe { mem::transmute_copy(&f(mem::transmute_copy(&bytes), mem::transmute_copy(&idxs))) }\n+}"}, {"sha": "646cd5f338335075624f5b747d0bb44856364eb1", "filename": "crates/core_simd/tests/swizzle_dyn.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4f0d8225fa6e503ba785da93b0ab900d597af133/crates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f0d8225fa6e503ba785da93b0ab900d597af133/crates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs?ref=4f0d8225fa6e503ba785da93b0ab900d597af133", "patch": "@@ -0,0 +1,74 @@\n+#![feature(portable_simd)]\n+use core::{fmt, ops::RangeInclusive};\n+use proptest;\n+use test_helpers::{self, biteq, make_runner, prop_assert_biteq};\n+\n+fn swizzle_dyn_scalar_ver<const N: usize>(values: [u8; N], idxs: [u8; N]) -> [u8; N] {\n+    let mut array = [0; N];\n+    for (i, k) in idxs.into_iter().enumerate() {\n+        if (k as usize) < N {\n+            array[i] = values[k as usize];\n+        };\n+    }\n+    array\n+}\n+\n+test_helpers::test_lanes! {\n+    fn swizzle_dyn<const N: usize>() {\n+        match_simd_with_fallback(\n+            &core_simd::simd::Simd::<u8, N>::swizzle_dyn,\n+            &swizzle_dyn_scalar_ver,\n+            &|_, _| true,\n+        );\n+    }\n+}\n+\n+fn match_simd_with_fallback<Scalar, ScalarResult, Vector, VectorResult, const N: usize>(\n+    fv: &dyn Fn(Vector, Vector) -> VectorResult,\n+    fs: &dyn Fn([Scalar; N], [Scalar; N]) -> [ScalarResult; N],\n+    check: &dyn Fn([Scalar; N], [Scalar; N]) -> bool,\n+) where\n+    Scalar: Copy + fmt::Debug + SwizzleStrategy,\n+    ScalarResult: Copy + biteq::BitEq + fmt::Debug + SwizzleStrategy,\n+    Vector: Into<[Scalar; N]> + From<[Scalar; N]> + Copy,\n+    VectorResult: Into<[ScalarResult; N]> + From<[ScalarResult; N]> + Copy,\n+{\n+    test_swizzles_2(&|x: [Scalar; N], y: [Scalar; N]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_v: [ScalarResult; N] = fv(x.into(), y.into()).into();\n+        let result_s: [ScalarResult; N] = fs(x, y);\n+        crate::prop_assert_biteq!(result_v, result_s);\n+        Ok(())\n+    });\n+}\n+\n+fn test_swizzles_2<A: fmt::Debug + SwizzleStrategy, B: fmt::Debug + SwizzleStrategy>(\n+    f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = make_runner();\n+    runner\n+        .run(\n+            &(A::swizzled_strategy(), B::swizzled_strategy()),\n+            |(a, b)| f(a, b),\n+        )\n+        .unwrap();\n+}\n+\n+pub trait SwizzleStrategy {\n+    type Strategy: proptest::strategy::Strategy<Value = Self>;\n+    fn swizzled_strategy() -> Self::Strategy;\n+}\n+\n+impl SwizzleStrategy for u8 {\n+    type Strategy = RangeInclusive<u8>;\n+    fn swizzled_strategy() -> Self::Strategy {\n+        0..=64\n+    }\n+}\n+\n+impl<T: fmt::Debug + SwizzleStrategy, const N: usize> SwizzleStrategy for [T; N] {\n+    type Strategy = test_helpers::array::UniformArrayStrategy<T::Strategy, Self>;\n+    fn swizzled_strategy() -> Self::Strategy {\n+        Self::Strategy::new(T::swizzled_strategy())\n+    }\n+}"}]}