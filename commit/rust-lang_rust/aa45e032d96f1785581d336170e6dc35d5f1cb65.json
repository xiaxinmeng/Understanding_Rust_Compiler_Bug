{"sha": "aa45e032d96f1785581d336170e6dc35d5f1cb65", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNDVlMDMyZDk2ZjE3ODU1ODFkMzM2MTcwZTZkYzM1ZDVmMWNiNjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-10T00:19:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-10T00:19:29Z"}, "message": "Auto merge of #64939 - nnethercote:snapshot-cleanups, r=nikomatsakis\n\nSnapshot clean-ups\n\nTwo minor clean-ups involving snapshots.", "tree": {"sha": "d0564425db3dc7f04a54c8814d7ca4d1c9f9ebca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0564425db3dc7f04a54c8814d7ca4d1c9f9ebca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa45e032d96f1785581d336170e6dc35d5f1cb65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa45e032d96f1785581d336170e6dc35d5f1cb65", "html_url": "https://github.com/rust-lang/rust/commit/aa45e032d96f1785581d336170e6dc35d5f1cb65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa45e032d96f1785581d336170e6dc35d5f1cb65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ece4977138a8eda96c234982e482fb43f67f1bee", "url": "https://api.github.com/repos/rust-lang/rust/commits/ece4977138a8eda96c234982e482fb43f67f1bee", "html_url": "https://github.com/rust-lang/rust/commit/ece4977138a8eda96c234982e482fb43f67f1bee"}, {"sha": "1b41f958c5d0d84b8dac385fb30bb7c7f12c13b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b41f958c5d0d84b8dac385fb30bb7c7f12c13b8", "html_url": "https://github.com/rust-lang/rust/commit/1b41f958c5d0d84b8dac385fb30bb7c7f12c13b8"}], "stats": {"total": 65, "additions": 28, "deletions": 37}, "files": [{"sha": "af74d13572431a147c3235666ce7ab470b9337e7", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa45e032d96f1785581d336170e6dc35d5f1cb65/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa45e032d96f1785581d336170e6dc35d5f1cb65/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=aa45e032d96f1785581d336170e6dc35d5f1cb65", "patch": "@@ -814,16 +814,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Executes `f` and commit the bindings.\n     pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n     where\n-        F: FnOnce() -> R,\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n-        debug!(\"commit()\");\n+        debug!(\"commit_unconditionally()\");\n         let snapshot = self.start_snapshot();\n-        let r = f();\n+        let r = f(&snapshot);\n         self.commit_from(snapshot);\n         r\n     }\n \n-    /// Executes `f` and commit the bindings if closure `f` returns `Ok(_)`.\n+    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n@@ -843,19 +843,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` in a snapshot, and commit the bindings it creates.\n-    pub fn in_snapshot<T, F>(&self, f: F) -> T\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T,\n-    {\n-        debug!(\"in_snapshot()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.commit_from(snapshot);\n-        r\n-    }\n-\n-    /// Executes `f` then unroll any bindings it creates.\n+    /// Execute `f` then unroll any bindings it creates.\n     pub fn probe<R, F>(&self, f: F) -> R\n     where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,"}, {"sha": "3d069425685c7761dd67a7f10e127297e238e54b", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa45e032d96f1785581d336170e6dc35d5f1cb65/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa45e032d96f1785581d336170e6dc35d5f1cb65/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=aa45e032d96f1785581d336170e6dc35d5f1cb65", "patch": "@@ -14,9 +14,11 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// retain the older (arguably incorrect) behavior of the\n     /// compiler.\n     ///\n-    /// NB. The use of snapshot here is mostly an efficiency thing --\n-    /// we could search *all* region constraints, but that'd be a\n-    /// bigger set and the data structures are not setup for that. If\n+    /// NB. Although `_snapshot` isn't used, it's passed in to prove\n+    /// that we are in a snapshot, which guarantees that we can just\n+    /// search the \"undo log\" for edges. This is mostly an efficiency\n+    /// thing -- we could search *all* region constraints, but that'd be\n+    /// a bigger set and the data structures are not setup for that. If\n     /// we wind up keeping some form of this check long term, it would\n     /// probably be better to remove the snapshot parameter and to\n     /// refactor the constraint set."}, {"sha": "44d611ace77d017abf94ebce568eb950cac09fa3", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aa45e032d96f1785581d336170e6dc35d5f1cb65/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa45e032d96f1785581d336170e6dc35d5f1cb65/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=aa45e032d96f1785581d336170e6dc35d5f1cb65", "patch": "@@ -2819,7 +2819,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // binder moved -\\\n                 let ty: ty::Binder<Ty<'tcx>> = ty::Binder::bind(ty); // <----/\n \n-                self.infcx.in_snapshot(|_| {\n+                self.infcx.commit_unconditionally(|_| {\n                     let (skol_ty, _) = self.infcx\n                         .replace_bound_vars_with_placeholders(&ty);\n                     let Normalized {\n@@ -2932,7 +2932,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn confirm_projection_candidate(&mut self, obligation: &TraitObligation<'tcx>) {\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.infcx.commit_unconditionally(|snapshot| {\n             let result =\n                 self.match_projection_obligation_against_definition_bounds(\n                     obligation,\n@@ -3054,19 +3054,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             nested,\n         );\n \n-        let trait_obligations: Vec<PredicateObligation<'_>> = self.infcx.in_snapshot(|_| {\n-            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-            let (trait_ref, _) = self.infcx\n-                .replace_bound_vars_with_placeholders(&poly_trait_ref);\n-            let cause = obligation.derived_cause(ImplDerivedObligation);\n-            self.impl_or_trait_obligations(\n-                cause,\n-                obligation.recursion_depth + 1,\n-                obligation.param_env,\n-                trait_def_id,\n-                &trait_ref.substs,\n-            )\n-        });\n+        let trait_obligations: Vec<PredicateObligation<'_>> =\n+            self.infcx.commit_unconditionally(|_| {\n+                let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+                let (trait_ref, _) = self.infcx\n+                    .replace_bound_vars_with_placeholders(&poly_trait_ref);\n+                let cause = obligation.derived_cause(ImplDerivedObligation);\n+                self.impl_or_trait_obligations(\n+                    cause,\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    trait_def_id,\n+                    &trait_ref.substs,\n+                )\n+            });\n \n         // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n         // predicate as usual.  It won't have any effect since auto traits are coinductive.\n@@ -3089,7 +3090,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.infcx.commit_unconditionally(|snapshot| {\n             let substs = self.rematch_impl(impl_def_id, obligation, snapshot);\n             debug!(\"confirm_impl_candidate: substs={:?}\", substs);\n             let cause = obligation.derived_cause(ImplDerivedObligation);\n@@ -3253,7 +3254,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligation, alias_def_id\n         );\n \n-        self.infcx.in_snapshot(|_| {\n+        self.infcx.commit_unconditionally(|_| {\n             let (predicate, _) = self.infcx()\n                 .replace_bound_vars_with_placeholders(&obligation.predicate);\n             let trait_ref = predicate.trait_ref;"}]}