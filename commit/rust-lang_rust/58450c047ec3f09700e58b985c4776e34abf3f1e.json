{"sha": "58450c047ec3f09700e58b985c4776e34abf3f1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NDUwYzA0N2VjM2YwOTcwMGU1OGI5ODVjNDc3NmUzNGFiZjNmMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-13T08:39:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-13T08:39:36Z"}, "message": "Auto merge of #36446 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 5 pull requests\n\n- Successful merges: #36357, #36380, #36389, #36397, #36402\n- Failed merges:", "tree": {"sha": "9b42cea19b1ea758f1f966bdb6768eb53d49fe3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b42cea19b1ea758f1f966bdb6768eb53d49fe3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58450c047ec3f09700e58b985c4776e34abf3f1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58450c047ec3f09700e58b985c4776e34abf3f1e", "html_url": "https://github.com/rust-lang/rust/commit/58450c047ec3f09700e58b985c4776e34abf3f1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58450c047ec3f09700e58b985c4776e34abf3f1e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09905b11776ac51a0ca3df84ef0363099dca6341", "url": "https://api.github.com/repos/rust-lang/rust/commits/09905b11776ac51a0ca3df84ef0363099dca6341", "html_url": "https://github.com/rust-lang/rust/commit/09905b11776ac51a0ca3df84ef0363099dca6341"}, {"sha": "c05424f250dcbf97bd88ea4d13735e48b05d0b02", "url": "https://api.github.com/repos/rust-lang/rust/commits/c05424f250dcbf97bd88ea4d13735e48b05d0b02", "html_url": "https://github.com/rust-lang/rust/commit/c05424f250dcbf97bd88ea4d13735e48b05d0b02"}], "stats": {"total": 443, "additions": 306, "deletions": 137}, "files": [{"sha": "2ec3a00c0df516ab73db23926639712697c0cd50", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -152,7 +152,7 @@ the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well\n If it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n \n You'll also notice we added an asterisk (`*`) in front of `y`, making it `*y`,\n-this is because `y` is a `&mut` reference. You'll need to use astrisks to\n+this is because `y` is a `&mut` reference. You'll need to use asterisks to\n access the contents of a reference as well.\n \n Otherwise, `&mut` references are like references. There _is_ a large"}, {"sha": "06b506ab014b4e77b1c09643fb17a204c486f5da", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -262,22 +262,25 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Reinterprets the bits of a value of one type as another type; both types\n-    /// must have the same size. Neither the original, nor the result, may be an\n-    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n+    /// Reinterprets the bits of a value of one type as another type.\n+    ///\n+    /// Both types must have the same size. Neither the original, nor the result,\n+    /// may be an [invalid value](../../nomicon/meet-safe-and-unsafe.html).\n     ///\n     /// `transmute` is semantically equivalent to a bitwise move of one type\n-    /// into another. It copies the bits from the destination type into the\n-    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n-    /// under the hood, just like `transmute_copy`.\n+    /// into another. It copies the bits from the source value into the\n+    /// destination value, then forgets the original. It's equivalent to C's\n+    /// `memcpy` under the hood, just like `transmute_copy`.\n     ///\n-    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n-    /// cause undefined behavior with this function. `transmute` should be\n+    /// `transmute` is **incredibly** unsafe. There are a vast number of ways to\n+    /// cause [undefined behavior][ub] with this function. `transmute` should be\n     /// the absolute last resort.\n     ///\n     /// The [nomicon](../../nomicon/transmutes.html) has additional\n     /// documentation.\n     ///\n+    /// [ub]: ../../reference.html#behavior-considered-undefined\n+    ///\n     /// # Examples\n     ///\n     /// There are a few things that `transmute` is really useful for.\n@@ -292,7 +295,8 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(bitpattern, 0x3F800000);\n     /// ```\n     ///\n-    /// Turning a pointer into a function pointer:\n+    /// Turning a pointer into a function pointer. This is *not* portable to\n+    /// machines where function pointers and data pointers have different sizes.\n     ///\n     /// ```\n     /// fn foo() -> i32 {\n@@ -305,8 +309,8 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(function(), 0);\n     /// ```\n     ///\n-    /// Extending a lifetime, or shortening an invariant lifetime; this is\n-    /// advanced, very unsafe rust:\n+    /// Extending a lifetime, or shortening an invariant lifetime. This is\n+    /// advanced, very unsafe Rust!\n     ///\n     /// ```\n     /// struct R<'a>(&'a i32);\n@@ -322,11 +326,9 @@ extern \"rust-intrinsic\" {\n     ///\n     /// # Alternatives\n     ///\n-    /// However, many uses of `transmute` can be achieved through other means.\n-    /// `transmute` can transform any type into any other, with just the caveat\n-    /// that they're the same size, and often interesting results occur. Below\n-    /// are common applications of `transmute` which can be replaced with safe\n-    /// applications of `as`:\n+    /// Don't despair: many uses of `transmute` can be achieved through other means.\n+    /// Below are common applications of `transmute` which can be replaced with safer\n+    /// constructs.\n     ///\n     /// Turning a pointer into a `usize`:\n     ///\n@@ -335,6 +337,7 @@ extern \"rust-intrinsic\" {\n     /// let ptr_num_transmute = unsafe {\n     ///     std::mem::transmute::<&i32, usize>(ptr)\n     /// };\n+    ///\n     /// // Use an `as` cast instead\n     /// let ptr_num_cast = ptr as *const i32 as usize;\n     /// ```\n@@ -346,6 +349,7 @@ extern \"rust-intrinsic\" {\n     /// let ref_transmuted = unsafe {\n     ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n     /// };\n+    ///\n     /// // Use a reborrow instead\n     /// let ref_casted = unsafe { &mut *ptr };\n     /// ```\n@@ -357,6 +361,7 @@ extern \"rust-intrinsic\" {\n     /// let val_transmuted = unsafe {\n     ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n     /// };\n+    ///\n     /// // Now, put together `as` and reborrowing - note the chaining of `as`\n     /// // `as` is not transitive\n     /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n@@ -368,9 +373,11 @@ extern \"rust-intrinsic\" {\n     /// // this is not a good way to do this.\n     /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n     /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    ///\n     /// // You could use `str::as_bytes`\n     /// let slice = \"Rust\".as_bytes();\n     /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    ///\n     /// // Or, just use a byte string, if you have control over the string\n     /// // literal\n     /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n@@ -381,18 +388,21 @@ extern \"rust-intrinsic\" {\n     /// ```\n     /// let store = [0, 1, 2, 3];\n     /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    ///\n     /// // Using transmute: this is Undefined Behavior, and a bad idea.\n     /// // However, it is no-copy.\n     /// let v_transmuted = unsafe {\n     ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n     ///         v_orig.clone())\n     /// };\n+    ///\n     /// // This is the suggested, safe way.\n-    /// // It does copy the entire Vector, though, into a new array.\n+    /// // It does copy the entire vector, though, into a new array.\n     /// let v_collected = v_orig.clone()\n     ///                         .into_iter()\n     ///                         .map(|r| Some(r))\n     ///                         .collect::<Vec<Option<&i32>>>();\n+    ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n     /// // same Vec internals. Therefore the new inner type must have the\n@@ -412,6 +422,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// ```\n     /// use std::{slice, mem};\n+    ///\n     /// // There are multiple ways to do this; and there are multiple problems\n     /// // with the following, transmute, way.\n     /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n@@ -426,6 +437,7 @@ extern \"rust-intrinsic\" {\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n+    ///\n     /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n     /// // you an `&mut T` from an `&mut T` or `*mut T`.\n     /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n@@ -439,6 +451,7 @@ extern \"rust-intrinsic\" {\n     ///         (&mut slice[0..mid], &mut slice2[mid..len])\n     ///     }\n     /// }\n+    ///\n     /// // This is how the standard library does it. This is the best method, if\n     /// // you need to do something like this\n     /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)"}, {"sha": "d3b8a60b79776c3f00a304e3430f006b1a4abc59", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 201, "deletions": 93, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -21,54 +21,39 @@ use ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n \n-/// Leaks a value into the void, consuming ownership and never running its\n-/// destructor.\n+/// Leaks a value: takes ownership and \"forgets\" about the value **without running\n+/// its destructor**.\n ///\n-/// This function will take ownership of its argument, but is distinct from the\n-/// `mem::drop` function in that it **does not run the destructor**, leaking the\n-/// value and any resources that it owns.\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state.\n ///\n-/// There's only a few reasons to use this function. They mainly come\n-/// up in unsafe code or FFI code.\n-///\n-/// * You have an uninitialized value, perhaps for performance reasons, and\n-///   need to prevent the destructor from running on it.\n-/// * You have two copies of a value (like when writing something like\n-///   [`mem::swap`][swap]), but need the destructor to only run once to\n-///   prevent a double `free`.\n-/// * Transferring resources across [FFI][ffi] boundaries.\n-///\n-/// [swap]: fn.swap.html\n-/// [ffi]: ../../book/ffi.html\n+/// If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n ///\n /// # Safety\n ///\n-/// This function is not marked as `unsafe` as Rust does not guarantee that the\n-/// `Drop` implementation for a value will always run. Note, however, that\n-/// leaking resources such as memory or I/O objects is likely not desired, so\n-/// this function is only recommended for specialized use cases.\n-///\n-/// The safety of this function implies that when writing `unsafe` code\n-/// yourself care must be taken when leveraging a destructor that is required to\n-/// run to preserve memory safety. There are known situations where the\n-/// destructor may not run (such as if ownership of the object with the\n-/// destructor is returned) which must be taken into account.\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process:exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n ///\n-/// # Other forms of Leakage\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n ///\n-/// It's important to point out that this function is not the only method by\n-/// which a value can be leaked in safe Rust code. Other known sources of\n-/// leakage are:\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n ///\n-/// * `Rc` and `Arc` cycles\n-/// * `mpsc::{Sender, Receiver}` cycles (they use `Arc` internally)\n-/// * Panicking destructors are likely to leak local resources\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n ///\n-/// # Example\n+/// # Examples\n ///\n /// Leak some heap memory by never deallocating it:\n ///\n-/// ```rust\n+/// ```\n /// use std::mem;\n ///\n /// let heap_memory = Box::new(3);\n@@ -77,17 +62,51 @@ pub use intrinsics::transmute;\n ///\n /// Leak an I/O object, never closing the file:\n ///\n-/// ```rust,no_run\n+/// ```no_run\n /// use std::mem;\n /// use std::fs::File;\n ///\n /// let file = File::open(\"foo.txt\").unwrap();\n /// mem::forget(file);\n /// ```\n ///\n-/// The `mem::swap` function uses `mem::forget` to good effect:\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// ## Use case 1\n+///\n+/// You have created an uninitialized value using [`mem::uninitialized`][uninit].\n+/// You must either initialize or `forget` it on every computation path before\n+/// Rust drops it automatically, like at the end of a scope or after a panic.\n+/// Running the destructor on an uninitialized value would be [undefined behavior][ub].\n+///\n+/// ```\n+/// use std::mem;\n+/// use std::ptr;\n+///\n+/// # let some_condition = false;\n+/// unsafe {\n+///     let mut uninit_vec: Vec<u32> = mem::uninitialized();\n+///\n+///     if some_condition {\n+///         // Initialize the variable.\n+///         ptr::write(&mut uninit_vec, Vec::new());\n+///     } else {\n+///         // Forget the uninitialized value so its destructor doesn't run.\n+///         mem::forget(uninit_vec);\n+///     }\n+/// }\n+/// ```\n+///\n+/// ## Use case 2\n+///\n+/// You have duplicated the bytes making up a value, without doing a proper\n+/// [`Clone`][clone]. You need the value's destructor to run only once,\n+/// because a double `free` is undefined behavior.\n ///\n-/// ```rust\n+/// An example is the definition of [`mem::swap`][swap] in this module:\n+///\n+/// ```\n /// use std::mem;\n /// use std::ptr;\n ///\n@@ -109,6 +128,41 @@ pub use intrinsics::transmute;\n ///     }\n /// }\n /// ```\n+///\n+/// ## Use case 3\n+///\n+/// You are transferring ownership across a [FFI] boundary to code written in\n+/// another language. You need to `forget` the value on the Rust side because Rust\n+/// code is no longer responsible for it.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// extern \"C\" {\n+///     fn my_c_function(x: *const u32);\n+/// }\n+///\n+/// let x: Box<u32> = Box::new(3);\n+///\n+/// // Transfer ownership into C code.\n+/// unsafe {\n+///     my_c_function(&*x);\n+/// }\n+/// mem::forget(x);\n+/// ```\n+///\n+/// In this case, C code must call back into Rust to free the object. Calling C's `free`\n+/// function on a [`Box`][box] is *not* safe! Also, `Box` provides an [`into_raw`][into_raw]\n+/// method which is the preferred way to do this in practice.\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [FFI]: ../../book/ffi.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n@@ -133,25 +187,40 @@ pub fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n \n-/// Returns the size of the given value in bytes.\n+/// Returns the size of the pointed-to value in bytes.\n+///\n+/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n+/// statically known size, e.g. a slice [`[T]`][slice] or a [trait object],\n+/// then `size_of_val` can be used to get the dynamically-known size.\n+///\n+/// [slice]: ../../std/primitive.slice.html\n+/// [trait object]: ../../book/trait-objects.html\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n /// assert_eq!(4, mem::size_of_val(&5i32));\n+///\n+/// let x: [u8; 13] = [0; 13];\n+/// let y: &[u8] = &x;\n+/// assert_eq!(13, mem::size_of_val(y));\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::size_of_val(val) }\n }\n \n-/// Returns the ABI-required minimum alignment of a type\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n /// # Examples\n ///\n /// ```\n@@ -167,7 +236,11 @@ pub fn min_align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n /// # Examples\n ///\n@@ -184,10 +257,14 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Returns the alignment in memory for a type.\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n ///\n /// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n ///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n /// # Examples\n ///\n /// ```\n@@ -201,7 +278,11 @@ pub fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }\n \n-/// Returns the ABI-required minimum alignment of the type of the value that `val` points to\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every valid address of a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n ///\n /// # Examples\n ///\n@@ -216,23 +297,31 @@ pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n     unsafe { intrinsics::min_align_of_val(val) }\n }\n \n-/// Creates a value initialized to zero.\n+/// Creates a value whose bytes are all zero.\n+///\n+/// This has the same effect as allocating space with\n+/// [`mem::uninitialized`][uninit] and then zeroing it out. It is useful for\n+/// [FFI] sometimes, but should generally be avoided.\n ///\n-/// This function is similar to allocating space for a local variable and zeroing it out (an unsafe\n-/// operation).\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n+/// some type `T`. If `T` has a destructor and the value is destroyed (due to\n+/// a panic or the end of a scope) before being initialized, then the destructor\n+/// will run on zeroed data, likely leading to [undefined behavior][ub].\n ///\n-/// Care must be taken when using this function, if the type `T` has a destructor and the value\n-/// falls out of scope (due to unwinding or returning) before being initialized, then the\n-/// destructor will run on zeroed data, likely leading to crashes.\n+/// See also the documentation for [`mem::uninitialized`][uninit], which has\n+/// many of the same caveats.\n ///\n-/// This is useful for FFI functions sometimes, but should generally be avoided.\n+/// [uninit]: fn.uninitialized.html\n+/// [FFI]: ../../book/ffi.html\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n /// let x: i32 = unsafe { mem::zeroed() };\n+/// assert_eq!(0, x);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -241,32 +330,38 @@ pub unsafe fn zeroed<T>() -> T {\n }\n \n /// Bypasses Rust's normal memory-initialization checks by pretending to\n-/// produce a value of type T, while doing nothing at all.\n+/// produce a value of type `T`, while doing nothing at all.\n ///\n /// **This is incredibly dangerous, and should not be done lightly. Deeply\n /// consider initializing your memory with a default value instead.**\n ///\n-/// This is useful for FFI functions and initializing arrays sometimes,\n+/// This is useful for [FFI] functions and initializing arrays sometimes,\n /// but should generally be avoided.\n ///\n-/// # Undefined Behavior\n+/// [FFI]: ../../book/ffi.html\n ///\n-/// It is Undefined Behavior to read uninitialized memory. Even just an\n+/// # Undefined behavior\n+///\n+/// It is [undefined behavior][ub] to read uninitialized memory, even just an\n /// uninitialized boolean. For instance, if you branch on the value of such\n-/// a boolean your program may take one, both, or neither of the branches.\n+/// a boolean, your program may take one, both, or neither of the branches.\n ///\n-/// Note that this often also includes *writing* to the uninitialized value.\n-/// Rust believes the value is initialized, and will therefore try to Drop\n-/// the uninitialized value and its fields if you try to overwrite the memory\n-/// in a normal manner. The only way to safely initialize an arbitrary\n-/// uninitialized value is with one of the `ptr` functions: `write`, `copy`, or\n-/// `copy_nonoverlapping`. This isn't necessary if `T` is a primitive\n-/// or otherwise only contains types that don't implement Drop.\n+/// Writing to the uninitialized value is similarly dangerous. Rust believes the\n+/// value is initialized, and will therefore try to [`Drop`][drop] the uninitialized\n+/// value and its fields if you try to overwrite it in a normal manner. The only way\n+/// to safely initialize an uninitialized value is with [`ptr::write`][write],\n+/// [`ptr::copy`][copy], or [`ptr::copy_nonoverlapping`][copy_no].\n ///\n-/// If this value *does* need some kind of Drop, it must be initialized before\n+/// If the value does implement `Drop`, it must be initialized before\n /// it goes out of scope (and therefore would be dropped). Note that this\n /// includes a `panic` occurring and unwinding the stack suddenly.\n ///\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [write]: ../ptr/fn.write.html\n+/// [copy]: ../intrinsics/fn.copy.html\n+/// [copy_no]: ../intrinsics/fn.copy_nonoverlapping.html\n+/// [drop]: ../ops/trait.Drop.html\n+///\n /// # Examples\n ///\n /// Here's how to safely initialize an array of `Vec`s.\n@@ -309,8 +404,8 @@ pub unsafe fn zeroed<T>() -> T {\n /// println!(\"{:?}\", &data[0]);\n /// ```\n ///\n-/// This example emphasizes exactly how delicate and dangerous doing this is.\n-/// Note that the `vec!` macro *does* let you initialize every element with a\n+/// This example emphasizes exactly how delicate and dangerous using `mem::uninitialized`\n+/// can be. Note that the `vec!` macro *does* let you initialize every element with a\n /// value that is only `Clone`, so the following is semantically equivalent and\n /// vastly less dangerous, as long as you can live with an extra heap\n /// allocation:\n@@ -325,21 +420,20 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without deinitializing or copying\n-/// either one.\n+/// Swaps the values at two mutable locations, without deinitializing either one.\n ///\n /// # Examples\n ///\n /// ```\n /// use std::mem;\n ///\n-/// let x = &mut 5;\n-/// let y = &mut 42;\n+/// let mut x = 5;\n+/// let mut y = 42;\n ///\n-/// mem::swap(x, y);\n+/// mem::swap(&mut x, &mut y);\n ///\n-/// assert_eq!(42, *x);\n-/// assert_eq!(5, *y);\n+/// assert_eq!(42, x);\n+/// assert_eq!(5, y);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -361,10 +455,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n }\n \n /// Replaces the value at a mutable location with a new one, returning the old value, without\n-/// deinitializing or copying either one.\n-///\n-/// This is primarily used for transferring and swapping ownership of a value in a mutable\n-/// location.\n+/// deinitializing either one.\n ///\n /// # Examples\n ///\n@@ -373,15 +464,17 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// ```\n /// use std::mem;\n ///\n-/// let mut v: Vec<i32> = Vec::new();\n+/// let mut v: Vec<i32> = vec![1, 2];\n ///\n-/// mem::replace(&mut v, Vec::new());\n+/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n+/// assert_eq!(2, old_v.len());\n+/// assert_eq!(3, v.len());\n /// ```\n ///\n-/// This function allows consumption of one field of a struct by replacing it with another value.\n-/// The normal approach doesn't always work:\n+/// `replace` allows consumption of a struct field by replacing it with another value.\n+/// Without `replace` you can run into issues like these:\n ///\n-/// ```rust,ignore\n+/// ```ignore\n /// struct Buffer<T> { buf: Vec<T> }\n ///\n /// impl<T> Buffer<T> {\n@@ -401,6 +494,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n /// ```\n /// # #![allow(dead_code)]\n /// use std::mem;\n+///\n /// # struct Buffer<T> { buf: Vec<T> }\n /// impl<T> Buffer<T> {\n ///     fn get_and_reset(&mut self) -> Vec<T> {\n@@ -417,14 +511,25 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n \n /// Disposes of a value.\n ///\n-/// While this does call the argument's implementation of `Drop`, it will not\n-/// release any borrows, as borrows are based on lexical scope.\n+/// While this does call the argument's implementation of [`Drop`][drop],\n+/// it will not release any borrows, as borrows are based on lexical scope.\n ///\n /// This effectively does nothing for\n /// [types which implement `Copy`](../../book/ownership.html#copy-types),\n /// e.g. integers. Such values are copied and _then_ moved into the function,\n /// so the value persists after this function call.\n ///\n+/// This function is not magic; it is literally defined as\n+///\n+/// ```\n+/// pub fn drop<T>(_x: T) { }\n+/// ```\n+///\n+/// Because `_x` is moved into the function, it is automatically dropped before\n+/// the function returns.\n+///\n+/// [drop]: ../ops/trait.Drop.html\n+///\n /// # Examples\n ///\n /// Basic usage:\n@@ -461,8 +566,8 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// v.push(4); // no problems\n /// ```\n ///\n-/// Since `RefCell` enforces the borrow rules at runtime, `drop()` can\n-/// seemingly release a borrow of one:\n+/// Since `RefCell` enforces the borrow rules at runtime, `drop` can\n+/// release a `RefCell` borrow:\n ///\n /// ```\n /// use std::cell::RefCell;\n@@ -478,7 +583,7 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n /// println!(\"{}\", *borrow);\n /// ```\n ///\n-/// Integers and other types implementing `Copy` are unaffected by `drop()`\n+/// Integers and other types implementing `Copy` are unaffected by `drop`.\n ///\n /// ```\n /// #[derive(Copy, Clone)]\n@@ -496,19 +601,22 @@ pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn drop<T>(_x: T) { }\n \n-/// Interprets `src` as `&U`, and then reads `src` without moving the contained\n-/// value.\n+/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// the contained value.\n ///\n /// This function will unsafely assume the pointer `src` is valid for\n-/// `sizeof(U)` bytes by transmuting `&T` to `&U` and then reading the `&U`. It\n-/// will also unsafely create a copy of the contained value instead of moving\n-/// out of `src`.\n+/// [`size_of::<U>()`][size_of] bytes by transmuting `&T` to `&U` and then reading\n+/// the `&U`. It will also unsafely create a copy of the contained value instead of\n+/// moving out of `src`.\n ///\n /// It is not a compile-time error if `T` and `U` have different sizes, but it\n /// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers undefined behavior if `U` is larger than\n+/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n /// `T`.\n ///\n+/// [ub]: ../../reference.html#behavior-considered-undefined\n+/// [size_of]: fn.size_of.html\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "a1e7d0a1e34deaa8031ce33f36b39216b5bf72d2", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -410,10 +410,13 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n                         },\n                         _ => bug!(),\n                     };\n-                    span_err!(cx.tcx.sess, sp, E0297,\n+                    let pattern_string = pat_to_string(witness);\n+                    struct_span_err!(cx.tcx.sess, sp, E0297,\n                         \"refutable pattern in `for` loop binding: \\\n                                 `{}` not covered\",\n-                                pat_to_string(witness));\n+                                pattern_string)\n+                        .span_label(sp, &format!(\"pattern `{}` not covered\", pattern_string))\n+                        .emit();\n                 },\n                 _ => {\n                     let pattern_strings: Vec<_> = witnesses.iter().map(|w| {"}, {"sha": "dbb45d54f38d185a57a5828d75b6d1927b25c8f0", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -468,8 +468,7 @@ impl<W: Write> Write for BufWriter<W> {\n             self.panicked = false;\n             r\n         } else {\n-            let amt = cmp::min(buf.len(), self.buf.capacity());\n-            Write::write(&mut self.buf, &buf[..amt])\n+            Write::write(&mut self.buf, buf)\n         }\n     }\n     fn flush(&mut self) -> io::Result<()> {"}, {"sha": "fdc84467015f90ca970796252524e6be03b6c537", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -249,37 +249,58 @@ mod prim_pointer { }\n #[doc(primitive = \"array\")]\n //\n /// A fixed-size array, denoted `[T; N]`, for the element type, `T`, and the\n-/// non-negative compile time constant size, `N`.\n+/// non-negative compile-time constant size, `N`.\n ///\n-/// Arrays values are created either with an explicit expression that lists\n-/// each element: `[x, y, z]` or a repeat expression: `[x; N]`. The repeat\n-/// expression requires that the element type is `Copy`.\n+/// There are two syntactic forms for creating an array:\n ///\n-/// The type `[T; N]` is `Copy` if `T: Copy`.\n+/// * A list with each element, i.e. `[x, y, z]`.\n+/// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n+///   The type of `x` must be [`Copy`][copy].\n ///\n /// Arrays of sizes from 0 to 32 (inclusive) implement the following traits if\n /// the element type allows it:\n ///\n-/// - `Clone` (only if `T: Copy`)\n-/// - `Debug`\n-/// - `IntoIterator` (implemented for `&[T; N]` and `&mut [T; N]`)\n-/// - `PartialEq`, `PartialOrd`, `Ord`, `Eq`\n-/// - `Hash`\n-/// - `AsRef`, `AsMut`\n-/// - `Borrow`, `BorrowMut`\n-/// - `Default`\n-///\n-/// This limitation to `N in 0..33` exists because Rust does not yet support\n-/// generics over the size of an array type. `[Foo; 3]` and `[Bar; 3]` are\n-/// instances of same generic type `[T; 3]`, but `[Foo; 3]` and `[Foo; 5]` are\n+/// - [`Clone`][clone] (only if `T: Copy`)\n+/// - [`Debug`][debug]\n+/// - [`IntoIterator`][intoiterator] (implemented for `&[T; N]` and `&mut [T; N]`)\n+/// - [`PartialEq`][partialeq], [`PartialOrd`][partialord], [`Eq`][eq], [`Ord`][ord]\n+/// - [`Hash`][hash]\n+/// - [`AsRef`][asref], [`AsMut`][asmut]\n+/// - [`Borrow`][borrow], [`BorrowMut`][borrowmut]\n+/// - [`Default`][default]\n+///\n+/// This limitation on the size `N` exists because Rust does not yet support\n+/// code that is generic over the size of an array type. `[Foo; 3]` and `[Bar; 3]`\n+/// are instances of same generic type `[T; 3]`, but `[Foo; 3]` and `[Foo; 5]` are\n /// entirely different types. As a stopgap, trait implementations are\n-/// statically generated for `N in 0..33`.\n+/// statically generated up to size 32.\n ///\n-/// Arrays coerce to [slices (`[T]`)][slice], so their methods can be called on\n-/// arrays. Slices are dynamic and do not coerce to arrays; consequently more\n-/// methods are defined on `slice` where they support both types.\n+/// Arrays of *any* size are [`Copy`][copy] if the element type is `Copy`. This\n+/// works because the `Copy` trait is specially known to the compiler.\n+///\n+/// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n+/// an array. Indeed, this provides most of the API for working with arrays.\n+/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// There is no way to move elements out of an array. See [`mem::replace`][replace]\n+/// for an alternative.\n ///\n /// [slice]: primitive.slice.html\n+/// [copy]: marker/trait.Copy.html\n+/// [clone]: clone/trait.Clone.html\n+/// [debug]: fmt/trait.Debug.html\n+/// [intoiterator]: iter/trait.IntoIterator.html\n+/// [partialeq]: cmp/trait.PartialEq.html\n+/// [partialord]: cmp/trait.PartialOrd.html\n+/// [eq]: cmp/trait.Eq.html\n+/// [ord]: cmp/trait.Ord.html\n+/// [hash]: hash/trait.Hash.html\n+/// [asref]: convert/trait.AsRef.html\n+/// [asmut]: convert/trait.AsMut.html\n+/// [borrow]: borrow/trait.Borrow.html\n+/// [borrowmut]: borrow/trait.BorrowMut.html\n+/// [default]: default/trait.Default.html\n+/// [replace]: mem/fn.replace.html\n ///\n /// # Examples\n ///\n@@ -295,7 +316,30 @@ mod prim_pointer { }\n /// for x in &array {\n ///     print!(\"{} \", x);\n /// }\n+/// ```\n+///\n+/// An array itself is not iterable:\n+///\n+/// ```ignore\n+/// let array: [i32; 3] = [0; 3];\n+///\n+/// for x in array { }\n+/// // error: the trait bound `[i32; 3]: std::iter::Iterator` is not satisfied\n+/// ```\n ///\n+/// The solution is to coerce the array to a slice by calling a slice method:\n+///\n+/// ```\n+/// # let array: [i32; 3] = [0; 3];\n+/// for x in array.iter() { }\n+/// ```\n+///\n+/// If the array has 32 or fewer elements (see above), you can also use the\n+/// array reference's `IntoIterator` implementation:\n+///\n+/// ```\n+/// # let array: [i32; 3] = [0; 3];\n+/// for x in &array { }\n /// ```\n ///\n mod prim_array { }"}, {"sha": "32c129b22a1668683cfc79252fbf2e8fdb9402db", "filename": "src/test/compile-fail/E0297.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Ftest%2Fcompile-fail%2FE0297.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58450c047ec3f09700e58b985c4776e34abf3f1e/src%2Ftest%2Fcompile-fail%2FE0297.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0297.rs?ref=58450c047ec3f09700e58b985c4776e34abf3f1e", "patch": "@@ -11,5 +11,7 @@\n fn main() {\n     let xs : Vec<Option<i32>> = vec!(Some(1), None);\n \n-    for Some(x) in xs {} //~ ERROR E0297\n+    for Some(x) in xs {}\n+    //~^ ERROR E0297\n+    //~| NOTE pattern `None` not covered\n }"}]}