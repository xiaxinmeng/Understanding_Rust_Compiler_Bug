{"sha": "e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YWIzM2U3YTYxZmYwNDZmMTczNmYxYjAyN2MxNmQ5NDk0ZTIwYjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-17T16:15:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-19T12:31:35Z"}, "message": "type_check/mod.rs: rustfmt", "tree": {"sha": "4bedbe5bb38601adbcb1cf1890eab8748bcc59bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bedbe5bb38601adbcb1cf1890eab8748bcc59bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "html_url": "https://github.com/rust-lang/rust/commit/e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7ab33e7a61ff046f1736f1b027c16d9494e20b8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0a3b4c0585129405c09a9be46a1a3f8d3411b3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a3b4c0585129405c09a9be46a1a3f8d3411b3b", "html_url": "https://github.com/rust-lang/rust/commit/a0a3b4c0585129405c09a9be46a1a3f8d3411b3b"}], "stats": {"total": 69, "additions": 29, "deletions": 40}, "files": [{"sha": "11ea46fdef238f336a89dd3445ffb8d1f23c2352", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 29, "deletions": 40, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e7ab33e7a61ff046f1736f1b027c16d9494e20b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7ab33e7a61ff046f1736f1b027c16d9494e20b8/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e7ab33e7a61ff046f1736f1b027c16d9494e20b8", "patch": "@@ -753,10 +753,8 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n \n     crate outlives_constraints: ConstraintSet,\n \n-    crate closure_bounds_mapping: FxHashMap<\n-        Location,\n-        FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n-    >,\n+    crate closure_bounds_mapping:\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     crate type_tests: Vec<TypeTest<'tcx>>,\n }\n@@ -866,7 +864,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         &mut self,\n         locations: Locations,\n         category: ConstraintCategory,\n-        op: impl type_op::TypeOp<'gcx, 'tcx, Output=R>,\n+        op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Fallible<R> {\n         let (r, opt_data) = op.fully_perform(self.infcx)?;\n \n@@ -979,11 +977,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )?;\n-        self.prove_predicate(\n-            ty::Predicate::WellFormed(ty),\n-            locations,\n-            category,\n-        );\n+        self.prove_predicate(ty::Predicate::WellFormed(ty), locations, category);\n         Ok(())\n     }\n \n@@ -1115,17 +1109,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n                 if let Err(terr) =\n-                self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n-                    {\n-                        span_mirbug!(\n+                    self.sub_types_or_anon(rv_ty, place_ty, location.to_locations(), category)\n+                {\n+                    span_mirbug!(\n                         self,\n                         stmt,\n                         \"bad assignment ({:?} = {:?}): {:?}\",\n                         place_ty,\n                         rv_ty,\n                         terr\n                     );\n-                    }\n+                }\n \n                 if let Some(user_ty) = self.rvalue_user_ty(rv) {\n                     if let Err(terr) = self.relate_type_and_user_type(\n@@ -1245,17 +1239,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n                 if let Err(terr) =\n-                self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n-                    {\n-                        span_mirbug!(\n+                    self.sub_types(rv_ty, place_ty, locations, ConstraintCategory::Assignment)\n+                {\n+                    span_mirbug!(\n                         self,\n                         term,\n                         \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                         place_ty,\n                         rv_ty,\n                         terr\n                     );\n-                    }\n+                }\n             }\n             TerminatorKind::SwitchInt {\n                 ref discr,\n@@ -1399,17 +1393,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let locations = term_location.to_locations();\n \n                 if let Err(terr) =\n-                self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n-                    {\n-                        span_mirbug!(\n+                    self.sub_types_or_anon(sig.output(), dest_ty, locations, category)\n+                {\n+                    span_mirbug!(\n                         self,\n                         term,\n                         \"call dest mismatch ({:?} <- {:?}): {:?}\",\n                         dest_ty,\n                         sig.output(),\n                         terr\n                     );\n-                    }\n+                }\n \n                 // When `#![feature(unsized_locals)]` is not enabled,\n                 // this check is done at `check_local`.\n@@ -2050,7 +2044,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             aggregate_kind, location\n         );\n \n-        let instantiated_predicates = match aggregate_kind  {\n+        let instantiated_predicates = match aggregate_kind {\n             AggregateKind::Adt(def, _, substs, _, _) => {\n                 tcx.predicates_of(def.did).instantiate(tcx, substs)\n             }\n@@ -2096,15 +2090,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(closure_region_requirements) =\n-            tcx.mir_borrowck(def_id).closure_requirements\n-        {\n-            let closure_constraints = closure_region_requirements.apply_requirements(\n-                tcx,\n-                location,\n-                def_id,\n-                substs,\n-            );\n+        if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+            let closure_constraints =\n+                closure_region_requirements.apply_requirements(tcx, location, def_id, substs);\n \n             if let Some(ref mut borrowck_context) = self.borrowck_context {\n                 let bounds_mapping = closure_constraints\n@@ -2113,19 +2101,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     .filter_map(|(idx, constraint)| {\n                         let ty::OutlivesPredicate(k1, r2) =\n                             constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                                bug!(\n-                                    \"query_constraint {:?} contained bound regions\",\n-                                    constraint,\n-                                );\n+                                bug!(\"query_constraint {:?} contained bound regions\", constraint,);\n                             });\n \n                         match k1.unpack() {\n                             UnpackedKind::Lifetime(r1) => {\n                                 // constraint is r1: r2\n                                 let r1_vid = borrowck_context.universal_regions.to_region_vid(r1);\n                                 let r2_vid = borrowck_context.universal_regions.to_region_vid(r2);\n-                                let outlives_requirements = &closure_region_requirements\n-                                    .outlives_requirements[idx];\n+                                let outlives_requirements =\n+                                    &closure_region_requirements.outlives_requirements[idx];\n                                 Some((\n                                     (r1_vid, r2_vid),\n                                     (\n@@ -2139,10 +2124,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     })\n                     .collect();\n \n-                let existing = borrowck_context.constraints\n+                let existing = borrowck_context\n+                    .constraints\n                     .closure_bounds_mapping\n                     .insert(location, bounds_mapping);\n-                assert!(existing.is_none(), \"Multiple closures at the same location.\");\n+                assert!(\n+                    existing.is_none(),\n+                    \"Multiple closures at the same location.\"\n+                );\n             }\n \n             self.push_region_constraints("}]}