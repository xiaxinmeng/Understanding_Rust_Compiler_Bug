{"sha": "361f668c4996c1f21aee39ea1a105a3067612c11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MWY2NjhjNDk5NmMxZjIxYWVlMzllYTFhMTA1YTMwNjc2MTJjMTE=", "commit": {"author": {"name": "Amos Onn", "email": "amosonn@gmail.com", "date": "2020-08-05T00:49:21Z"}, "committer": {"name": "Amos Onn", "email": "amosonn@gmail.com", "date": "2020-08-05T06:32:05Z"}, "message": "Use alloc_zeroed in {Rc,Arc}::new_zeroed", "tree": {"sha": "c3c73b3b6266941b63b0ea4e1c052c2a7f82e359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c73b3b6266941b63b0ea4e1c052c2a7f82e359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/361f668c4996c1f21aee39ea1a105a3067612c11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/361f668c4996c1f21aee39ea1a105a3067612c11", "html_url": "https://github.com/rust-lang/rust/commit/361f668c4996c1f21aee39ea1a105a3067612c11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/361f668c4996c1f21aee39ea1a105a3067612c11/comments", "author": {"login": "amosonn", "id": 3142573, "node_id": "MDQ6VXNlcjMxNDI1NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3142573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amosonn", "html_url": "https://github.com/amosonn", "followers_url": "https://api.github.com/users/amosonn/followers", "following_url": "https://api.github.com/users/amosonn/following{/other_user}", "gists_url": "https://api.github.com/users/amosonn/gists{/gist_id}", "starred_url": "https://api.github.com/users/amosonn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amosonn/subscriptions", "organizations_url": "https://api.github.com/users/amosonn/orgs", "repos_url": "https://api.github.com/users/amosonn/repos", "events_url": "https://api.github.com/users/amosonn/events{/privacy}", "received_events_url": "https://api.github.com/users/amosonn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "amosonn", "id": 3142573, "node_id": "MDQ6VXNlcjMxNDI1NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3142573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amosonn", "html_url": "https://github.com/amosonn", "followers_url": "https://api.github.com/users/amosonn/followers", "following_url": "https://api.github.com/users/amosonn/following{/other_user}", "gists_url": "https://api.github.com/users/amosonn/gists{/gist_id}", "starred_url": "https://api.github.com/users/amosonn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amosonn/subscriptions", "organizations_url": "https://api.github.com/users/amosonn/orgs", "repos_url": "https://api.github.com/users/amosonn/repos", "events_url": "https://api.github.com/users/amosonn/events{/privacy}", "received_events_url": "https://api.github.com/users/amosonn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "url": "https://api.github.com/repos/rust-lang/rust/commits/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "html_url": "https://github.com/rust-lang/rust/commit/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851"}], "stats": {"total": 78, "additions": 48, "deletions": 30}, "files": [{"sha": "9183beca55c3c887b8231204e8f8495fa9ff219e", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/361f668c4996c1f21aee39ea1a105a3067612c11/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361f668c4996c1f21aee39ea1a105a3067612c11/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=361f668c4996c1f21aee39ea1a105a3067612c11", "patch": "@@ -250,7 +250,7 @@ use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::slice::from_raw_parts_mut;\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::string::String;\n use crate::vec::Vec;\n@@ -352,9 +352,11 @@ impl<T> Rc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n-            Rc::from_ptr(Rc::allocate_for_layout(Layout::new::<T>(), |mem| {\n-                mem as *mut RcBox<mem::MaybeUninit<T>>\n-            }))\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -381,9 +383,11 @@ impl<T> Rc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Rc<mem::MaybeUninit<T>> {\n         unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(Rc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n-            uninit\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc_zeroed(layout),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -919,6 +923,7 @@ impl<T: ?Sized> Rc<T> {\n     /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocErr>,\n         mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>,\n     ) -> *mut RcBox<T> {\n         // Calculate layout using the given value layout.\n@@ -928,7 +933,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::new::<RcBox<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n         // Allocate for the layout.\n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n         let inner = mem_to_rcbox(ptr.as_non_null_ptr().as_ptr());\n@@ -946,9 +951,11 @@ impl<T: ?Sized> Rc<T> {\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n         // Allocate for the `RcBox<T>` using the given value.\n         unsafe {\n-            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-                set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::for_value(&*ptr),\n+                |layout| Global.alloc(layout),\n+                |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n+            )\n         }\n     }\n \n@@ -979,9 +986,11 @@ impl<T> Rc<[T]> {\n     /// Allocates an `RcBox<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n         unsafe {\n-            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::array::<T>(len).unwrap(),\n+                |layout| Global.alloc(layout),\n+                |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n+            )\n         }\n     }\n }\n@@ -2090,7 +2099,7 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> {}\n \n-/// Get the offset within an `ArcInner` for\n+/// Get the offset within an `RcBoRcBox` for\n /// a payload of type described by a pointer.\n ///\n /// # Safety"}, {"sha": "308b2e71c85d954c835f97b9da7c9703a611eab4", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/361f668c4996c1f21aee39ea1a105a3067612c11/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/361f668c4996c1f21aee39ea1a105a3067612c11/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=361f668c4996c1f21aee39ea1a105a3067612c11", "patch": "@@ -23,7 +23,7 @@ use core::slice::from_raw_parts_mut;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n \n-use crate::alloc::{box_free, handle_alloc_error, AllocRef, Global, Layout};\n+use crate::alloc::{box_free, handle_alloc_error, AllocErr, AllocRef, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n@@ -352,9 +352,11 @@ impl<T> Arc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n-            Arc::from_ptr(Arc::allocate_for_layout(Layout::new::<T>(), |mem| {\n-                mem as *mut ArcInner<mem::MaybeUninit<T>>\n-            }))\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -381,9 +383,11 @@ impl<T> Arc<T> {\n     #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed() -> Arc<mem::MaybeUninit<T>> {\n         unsafe {\n-            let mut uninit = Self::new_uninit();\n-            ptr::write_bytes::<T>(Arc::get_mut_unchecked(&mut uninit).as_mut_ptr(), 0, 1);\n-            uninit\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |layout| Global.alloc_zeroed(layout),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -437,7 +441,7 @@ impl<T> Arc<T> {\n }\n \n impl<T> Arc<[T]> {\n-    /// Constructs a new reference-counted slice with uninitialized contents.\n+    /// Constructs a new atomically reference-counted slice with uninitialized contents.\n     ///\n     /// # Examples\n     ///\n@@ -875,6 +879,7 @@ impl<T: ?Sized> Arc<T> {\n     /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n     unsafe fn allocate_for_layout(\n         value_layout: Layout,\n+        allocate: impl FnOnce(Layout) -> Result<NonNull<[u8]>, AllocErr>,\n         mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>,\n     ) -> *mut ArcInner<T> {\n         // Calculate layout using the given value layout.\n@@ -883,7 +888,7 @@ impl<T: ?Sized> Arc<T> {\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>().extend(value_layout).unwrap().0.pad_to_align();\n \n-        let ptr = Global.alloc(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr = allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n         let inner = mem_to_arcinner(ptr.as_non_null_ptr().as_ptr());\n@@ -901,9 +906,11 @@ impl<T: ?Sized> Arc<T> {\n     unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n         // Allocate for the `ArcInner<T>` using the given value.\n         unsafe {\n-            Self::allocate_for_layout(Layout::for_value(&*ptr), |mem| {\n-                set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::for_value(&*ptr),\n+                |layout| Global.alloc(layout),\n+                |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n+            )\n         }\n     }\n \n@@ -934,9 +941,11 @@ impl<T> Arc<[T]> {\n     /// Allocates an `ArcInner<[T]>` with the given length.\n     unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n         unsafe {\n-            Self::allocate_for_layout(Layout::array::<T>(len).unwrap(), |mem| {\n-                ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>\n-            })\n+            Self::allocate_for_layout(\n+                Layout::array::<T>(len).unwrap(),\n+                |layout| Global.alloc(layout),\n+                |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n+            )\n         }\n     }\n }"}]}