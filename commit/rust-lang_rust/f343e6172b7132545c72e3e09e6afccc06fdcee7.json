{"sha": "f343e6172b7132545c72e3e09e6afccc06fdcee7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNDNlNjE3MmI3MTMyNTQ1YzcyZTNlMDllNmFmY2NjMDZmZGNlZTc=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T00:25:29Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-30T00:25:29Z"}, "message": "core::rt: Fix an infinite recursion bug", "tree": {"sha": "3d148fdfc6babfa318cd998deb5d8f96785469c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d148fdfc6babfa318cd998deb5d8f96785469c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f343e6172b7132545c72e3e09e6afccc06fdcee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f343e6172b7132545c72e3e09e6afccc06fdcee7", "html_url": "https://github.com/rust-lang/rust/commit/f343e6172b7132545c72e3e09e6afccc06fdcee7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f343e6172b7132545c72e3e09e6afccc06fdcee7/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a373dad74d0bd89a9d5362bba1059d9cc25afb9a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a373dad74d0bd89a9d5362bba1059d9cc25afb9a", "html_url": "https://github.com/rust-lang/rust/commit/a373dad74d0bd89a9d5362bba1059d9cc25afb9a"}], "stats": {"total": 23, "additions": 21, "deletions": 2}, "files": [{"sha": "d108e20347a0583b1579a4fe6f9723954f3be091", "filename": "src/libcore/rt/comm.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f343e6172b7132545c72e3e09e6afccc06fdcee7/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f343e6172b7132545c72e3e09e6afccc06fdcee7/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=f343e6172b7132545c72e3e09e6afccc06fdcee7", "patch": "@@ -22,6 +22,7 @@ use ops::Drop;\n use kinds::Owned;\n use rt::sched::{Scheduler, Coroutine};\n use rt::local::Local;\n+use rt::rtio::EventLoop;\n use unstable::intrinsics::{atomic_xchg, atomic_load};\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n@@ -172,9 +173,17 @@ impl<T> PortOne<T> {\n                     }\n                     STATE_ONE => {\n                         // Channel is closed. Switch back and check the data.\n+                        // NB: We have to drop back into the scheduler event loop here\n+                        // instead of switching immediately back or we could end up\n+                        // triggering infinite recursion on the scheduler's stack.\n                         let task: ~Coroutine = cast::transmute(task_as_state);\n-                        let sched = Local::take::<Scheduler>();\n-                        sched.resume_task_immediately(task);\n+                        let task = Cell(task);\n+                        let mut sched = Local::take::<Scheduler>();\n+                        do sched.event_loop.callback {\n+                            let sched = Local::take::<Scheduler>();\n+                            sched.resume_task_immediately(task.take());\n+                        }\n+                        Local::put(sched);\n                     }\n                     _ => util::unreachable()\n                 }\n@@ -614,5 +623,15 @@ mod test {\n             }\n         }\n     }\n+\n+    #[test]\n+    fn recv_a_lot() {\n+        // Regression test that we don't run out of stack in scheduler context\n+        do run_in_newsched_task {\n+            let (port, chan) = stream();\n+            for 10000.times { chan.send(()) }\n+            for 10000.times { port.recv() }\n+        }\n+    }\n }\n "}]}