{"sha": "5c5b8afd80e6fa1d24632153cb2257c686041d41", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNWI4YWZkODBlNmZhMWQyNDYzMjE1M2NiMjI1N2M2ODYwNDFkNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-16T19:50:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-16T19:50:48Z"}, "message": "Auto merge of #64694 - petrochenkov:reshelp, r=matthewjasper\n\nFully integrate derive helpers into name resolution\n\n```rust\n#[derive(Foo)]\n#[foo_helper] // already goes through name resolution\nstruct S {\n    #[foo_helper] // goes through name resolution after this PR\n    field: u8\n}\n```\nHow name resolution normally works:\n- We have an identifier we need to resolve, take its location (in some sense) and look what names are in scope in that location.\n\nHow derive helper attributes are \"resolved\" (before this PR):\n- After resolving the derive `Foo` we visit the derive's input (`struct S { ... } `) as a piece of AST and mark attributes textually matching one of the derive's helper attributes (`foo_helper`) as \"known\", so they never go through name resolution.\n\nThis PR changes the rules for derive helpers, so they are not proactively marked as known (which is a big hack ignoring any ambiguities or hygiene), but go through regular name resolution instead.\nThis change was previously blocked by attributes not being resolved in some positions at all (fixed in https://github.com/rust-lang/rust/pull/63468).\n\n\"Where exactly are derive helpers in scope?\" is an interesting question, and I need some feedback from proc macro authors to answer it, see the post below (https://github.com/rust-lang/rust/pull/64694#issuecomment-533925160).", "tree": {"sha": "b63c656633b43294948a19c761bb5bde38b53b18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b63c656633b43294948a19c761bb5bde38b53b18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c5b8afd80e6fa1d24632153cb2257c686041d41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c5b8afd80e6fa1d24632153cb2257c686041d41", "html_url": "https://github.com/rust-lang/rust/commit/5c5b8afd80e6fa1d24632153cb2257c686041d41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c5b8afd80e6fa1d24632153cb2257c686041d41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f00849dc495f97ea9eeef07b958664bfb755ae3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f00849dc495f97ea9eeef07b958664bfb755ae3", "html_url": "https://github.com/rust-lang/rust/commit/5f00849dc495f97ea9eeef07b958664bfb755ae3"}, {"sha": "8668c1a19015148821c37255922f9a9b603dd148", "url": "https://api.github.com/repos/rust-lang/rust/commits/8668c1a19015148821c37255922f9a9b603dd148", "html_url": "https://github.com/rust-lang/rust/commit/8668c1a19015148821c37255922f9a9b603dd148"}], "stats": {"total": 252, "additions": 195, "deletions": 57}, "files": [{"sha": "f2858a62156421e3e69ec565307975debcfec21f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -368,7 +368,16 @@ impl<'a> Resolver<'a> {\n         let mut suggestions = Vec::new();\n         self.visit_scopes(scope_set, parent_scope, ident, |this, scope, use_prelude, _| {\n             match scope {\n-                Scope::DeriveHelpers => {\n+                Scope::DeriveHelpers(expn_id) => {\n+                    let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n+                    if filter_fn(res) {\n+                        suggestions.extend(this.helper_attrs.get(&expn_id)\n+                                               .into_iter().flatten().map(|ident| {\n+                            TypoSuggestion::from_res(ident.name, res)\n+                        }));\n+                    }\n+                }\n+                Scope::DeriveHelpersCompat => {\n                     let res = Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper);\n                     if filter_fn(res) {\n                         for derive in parent_scope.derives {"}, {"sha": "0f410c623bafab3e9f6a3287df077b734e720b70", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -45,7 +45,7 @@ use syntax::symbol::{kw, sym};\n use syntax::source_map::Spanned;\n use syntax::visit::{self, Visitor};\n use syntax_expand::base::SyntaxExtension;\n-use syntax_pos::hygiene::{MacroKind, ExpnId, Transparency, SyntaxContext};\n+use syntax_pos::hygiene::{MacroKind, ExpnId, ExpnKind, Transparency, SyntaxContext};\n use syntax_pos::{Span, DUMMY_SP};\n use errors::{Applicability, DiagnosticBuilder};\n \n@@ -97,7 +97,8 @@ impl Determinacy {\n /// but not for late resolution yet.\n #[derive(Clone, Copy)]\n enum Scope<'a> {\n-    DeriveHelpers,\n+    DeriveHelpers(ExpnId),\n+    DeriveHelpersCompat,\n     MacroRules(LegacyScope<'a>),\n     CrateRoot,\n     Module(Module<'a>),\n@@ -942,6 +943,8 @@ pub struct Resolver<'a> {\n     /// Legacy scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n     output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n+    /// Helper attributes that are in scope for the given expansion.\n+    helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n     /// Avoid duplicated errors for \"name already defined\".\n     name_already_seen: FxHashMap<Name, Span>,\n@@ -1219,6 +1222,7 @@ impl<'a> Resolver<'a> {\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocation_parent_scopes,\n             output_legacy_scopes: Default::default(),\n+            helper_attrs: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n             name_already_seen: FxHashMap::default(),\n@@ -1467,24 +1471,27 @@ impl<'a> Resolver<'a> {\n         //    in prelude, not sure where exactly (creates ambiguities with any other prelude names).\n \n         let rust_2015 = ident.span.rust_2015();\n-        let (ns, is_absolute_path) = match scope_set {\n-            ScopeSet::All(ns, _) => (ns, false),\n-            ScopeSet::AbsolutePath(ns) => (ns, true),\n-            ScopeSet::Macro(_) => (MacroNS, false),\n+        let (ns, macro_kind, is_absolute_path) = match scope_set {\n+            ScopeSet::All(ns, _) => (ns, None, false),\n+            ScopeSet::AbsolutePath(ns) => (ns, None, true),\n+            ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n         };\n         // Jump out of trait or enum modules, they do not act as scopes.\n         let module = parent_scope.module.nearest_item_scope();\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n             TypeNS | ValueNS => Scope::Module(module),\n-            MacroNS => Scope::DeriveHelpers,\n+            MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n         let mut ident = ident.modern();\n         let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n             let visit = match scope {\n-                Scope::DeriveHelpers => true,\n+                // Derive helpers are not in scope when resolving derives in the same container.\n+                Scope::DeriveHelpers(expn_id) =>\n+                    !(expn_id == parent_scope.expansion && macro_kind == Some(MacroKind::Derive)),\n+                Scope::DeriveHelpersCompat => true,\n                 Scope::MacroRules(..) => true,\n                 Scope::CrateRoot => true,\n                 Scope::Module(..) => true,\n@@ -1505,7 +1512,18 @@ impl<'a> Resolver<'a> {\n             }\n \n             scope = match scope {\n-                Scope::DeriveHelpers =>\n+                Scope::DeriveHelpers(expn_id) if expn_id != ExpnId::root() => {\n+                    // Derive helpers are not visible to code generated by bang or derive macros.\n+                    let expn_data = expn_id.expn_data();\n+                    match expn_data.kind {\n+                        ExpnKind::Root |\n+                        ExpnKind::Macro(MacroKind::Bang, _) |\n+                        ExpnKind::Macro(MacroKind::Derive, _) => Scope::DeriveHelpersCompat,\n+                        _ => Scope::DeriveHelpers(expn_data.parent),\n+                    }\n+                }\n+                Scope::DeriveHelpers(..) => Scope::DeriveHelpersCompat,\n+                Scope::DeriveHelpersCompat =>\n                     Scope::MacroRules(parent_scope.legacy),\n                 Scope::MacroRules(legacy_scope) => match legacy_scope {\n                     LegacyScope::Binding(binding) => Scope::MacroRules("}, {"sha": "cf549d5ba6f70914fa0ef35166a3cecab17788cf", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -237,15 +237,26 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 // - Derives in the container need to know whether one of them is a built-in `Copy`.\n                 // FIXME: Try to avoid repeated resolutions for derives here and in expansion.\n                 let mut exts = Vec::new();\n+                let mut helper_attrs = Vec::new();\n                 for path in derives {\n                     exts.push(match self.resolve_macro_path(\n                         path, Some(MacroKind::Derive), &parent_scope, true, force\n                     ) {\n-                        Ok((Some(ext), _)) => ext,\n+                        Ok((Some(ext), _)) => {\n+                            let span = path.segments.last().unwrap().ident.span.modern();\n+                            helper_attrs.extend(\n+                                ext.helper_attrs.iter().map(|name| Ident::new(*name, span))\n+                            );\n+                            if ext.is_derive_copy {\n+                                self.add_derive_copy(invoc_id);\n+                            }\n+                            ext\n+                        }\n                         Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n                         Err(Determinacy::Undetermined) => return Err(Indeterminate),\n                     })\n                 }\n+                self.helper_attrs.insert(invoc_id, helper_attrs);\n                 return Ok(InvocationRes::DeriveContainer(exts));\n             }\n         };\n@@ -498,7 +509,19 @@ impl<'a> Resolver<'a> {\n                 Flags::empty(),\n             ));\n             let result = match scope {\n-                Scope::DeriveHelpers => {\n+                Scope::DeriveHelpers(expn_id) => {\n+                    if let Some(attr) = this.helper_attrs.get(&expn_id).and_then(|attrs| {\n+                        attrs.iter().rfind(|i| ident == **i)\n+                    }) {\n+                        let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                       ty::Visibility::Public, attr.span, expn_id)\n+                                       .to_name_binding(this.arenas);\n+                        Ok((binding, Flags::empty()))\n+                    } else {\n+                        Err(Determinacy::Determined)\n+                    }\n+                }\n+                Scope::DeriveHelpersCompat => {\n                     let mut result = Err(Determinacy::Determined);\n                     for derive in parent_scope.derives {\n                         let parent_scope = &ParentScope { derives: &[], ..*parent_scope };"}, {"sha": "06aa5deb6e0184dd74231c0dd08aac951cd9a005", "filename": "src/libsyntax_expand/expand.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibsyntax_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibsyntax_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fexpand.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -1,5 +1,5 @@\n use crate::base::*;\n-use crate::proc_macro::{collect_derives, MarkAttrs};\n+use crate::proc_macro::collect_derives;\n use crate::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::mbe::macro_rules::annotate_err_with_kind;\n use crate::placeholders::{placeholder, PlaceholderExpander};\n@@ -394,7 +394,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let fragment = self.expand_invoc(invoc, &ext.kind);\n                     self.collect_invocations(fragment, &[])\n                 }\n-                InvocationRes::DeriveContainer(exts) => {\n+                InvocationRes::DeriveContainer(_exts) => {\n+                    // FIXME: Consider using the derive resolutions (`_exts`) immediately,\n+                    // instead of enqueuing the derives to be resolved again later.\n                     let (derives, item) = match invoc.kind {\n                         InvocationKind::DeriveContainer { derives, item } => (derives, item),\n                         _ => unreachable!(),\n@@ -421,20 +423,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                     let mut item = self.fully_configure(item);\n                     item.visit_attrs(|attrs| attrs.retain(|a| !a.has_name(sym::derive)));\n-                    let mut helper_attrs = Vec::new();\n-                    let mut has_copy = false;\n-                    for ext in exts {\n-                        helper_attrs.extend(&ext.helper_attrs);\n-                        has_copy |= ext.is_derive_copy;\n-                    }\n-                    // Mark derive helpers inside this item as known and used.\n-                    // FIXME: This is a hack, derive helpers should be integrated with regular name\n-                    // resolution instead. For example, helpers introduced by a derive container\n-                    // can be in scope for all code produced by that container's expansion.\n-                    item.visit_with(&mut MarkAttrs(&helper_attrs));\n-                    if has_copy {\n-                        self.cx.resolver.add_derive_copy(invoc.expansion_data.id);\n-                    }\n \n                     let mut derive_placeholders = Vec::with_capacity(derives.len());\n                     invocations.reserve(derives.len());"}, {"sha": "099cf0a4be9049bcb41d04f479eb5c8dd3bdba68", "filename": "src/libsyntax_expand/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibsyntax_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Flibsyntax_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fproc_macro.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -1,13 +1,11 @@\n use crate::base::{self, *};\n use crate::proc_macro_server;\n \n-use syntax::ast::{self, ItemKind, Attribute, Mac};\n-use syntax::attr::{mark_used, mark_known};\n+use syntax::ast::{self, ItemKind};\n use syntax::errors::{Applicability, FatalError};\n use syntax::symbol::sym;\n use syntax::token;\n use syntax::tokenstream::{self, TokenStream};\n-use syntax::visit::Visitor;\n \n use rustc_data_structures::sync::Lrc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -167,21 +165,6 @@ impl MultiItemModifier for ProcMacroDerive {\n     }\n }\n \n-crate struct MarkAttrs<'a>(crate &'a [ast::Name]);\n-\n-impl<'a> Visitor<'a> for MarkAttrs<'a> {\n-    fn visit_attribute(&mut self, attr: &Attribute) {\n-        if let Some(ident) = attr.ident() {\n-            if self.0.contains(&ident.name) {\n-                mark_used(attr);\n-                mark_known(attr);\n-            }\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _mac: &Mac) {}\n-}\n-\n crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>) -> Vec<ast::Path> {\n     let mut result = Vec::new();\n     attrs.retain(|attr| {"}, {"sha": "41d3a184640acaf373df5ee5e72b765f034c471f", "filename": "src/test/ui/proc-macro/auxiliary/derive-helper-shadowing.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -0,0 +1,15 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_derive(GenHelperUse)]\n+pub fn derive_a(_: TokenStream) -> TokenStream {\n+    \"\n+    #[empty_helper]\n+    struct Uwu;\n+    \".parse().unwrap()\n+}"}, {"sha": "f0ca34db414d441b539f851363813f9f4ff1b83c", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -1,33 +1,54 @@\n+// edition:2018\n // aux-build:test-macros.rs\n+// aux-build:derive-helper-shadowing.rs\n \n #[macro_use]\n extern crate test_macros;\n+#[macro_use]\n+extern crate derive_helper_shadowing;\n \n use test_macros::empty_attr as empty_helper;\n \n+macro_rules! gen_helper_use {\n+    () => {\n+        #[empty_helper] //~ ERROR cannot find attribute `empty_helper` in this scope\n+        struct W;\n+    }\n+}\n+\n #[empty_helper] //~ ERROR `empty_helper` is ambiguous\n #[derive(Empty)]\n struct S {\n-    // FIXME No ambiguity, attributes in non-macro positions are not resolved properly\n-    #[empty_helper]\n+    #[empty_helper] //~ ERROR `empty_helper` is ambiguous\n     field: [u8; {\n-        // FIXME No ambiguity, derive helpers are not put into scope for non-attributes\n-        use empty_helper;\n+        use empty_helper; //~ ERROR `empty_helper` is ambiguous\n \n-        // FIXME No ambiguity, derive helpers are not put into scope for inner items\n-        #[empty_helper]\n+        #[empty_helper] //~ ERROR `empty_helper` is ambiguous\n         struct U;\n \n         mod inner {\n-            // FIXME No ambiguity, attributes in non-macro positions are not resolved properly\n+            // OK, no ambiguity, the non-helper attribute is not in scope here, only the helper.\n             #[empty_helper]\n             struct V;\n+\n+            gen_helper_use!();\n+\n+            #[derive(GenHelperUse)] //~ ERROR cannot find attribute `empty_helper` in this scope\n+            struct Owo;\n+\n+            use empty_helper as renamed;\n+            #[renamed] //~ ERROR cannot use a derive helper attribute through an import\n+            struct Wow;\n         }\n \n         0\n     }]\n }\n \n+// OK, no ambiguity, only the non-helper attribute is in scope.\n+#[empty_helper]\n+struct Z;\n+\n fn main() {\n     let s = S { field: [] };\n }"}, {"sha": "9048830bee24d5f14d932025c1bfe2fffed5d4c6", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c5b8afd80e6fa1d24632153cb2257c686041d41/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=5c5b8afd80e6fa1d24632153cb2257c686041d41", "patch": "@@ -1,21 +1,102 @@\n+error: cannot use a derive helper attribute through an import\n+  --> $DIR/derive-helper-shadowing.rs:40:15\n+   |\n+LL |             #[renamed]\n+   |               ^^^^^^^\n+   |\n+note: the derive helper attribute imported here\n+  --> $DIR/derive-helper-shadowing.rs:39:17\n+   |\n+LL |             use empty_helper as renamed;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot find attribute `empty_helper` in this scope\n+  --> $DIR/derive-helper-shadowing.rs:36:22\n+   |\n+LL |             #[derive(GenHelperUse)]\n+   |                      ^^^^^^^^^^^^\n+\n+error: cannot find attribute `empty_helper` in this scope\n+  --> $DIR/derive-helper-shadowing.rs:14:11\n+   |\n+LL |         #[empty_helper]\n+   |           ^^^^^^^^^^^^\n+...\n+LL |             gen_helper_use!();\n+   |             ------------------ in this macro invocation\n+\n+error[E0659]: `empty_helper` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/derive-helper-shadowing.rs:24:13\n+   |\n+LL |         use empty_helper;\n+   |             ^^^^^^^^^^^^ ambiguous name\n+   |\n+note: `empty_helper` could refer to the derive helper attribute defined here\n+  --> $DIR/derive-helper-shadowing.rs:20:10\n+   |\n+LL | #[derive(Empty)]\n+   |          ^^^^^\n+note: `empty_helper` could also refer to the attribute macro imported here\n+  --> $DIR/derive-helper-shadowing.rs:10:5\n+   |\n+LL | use test_macros::empty_attr as empty_helper;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n+\n error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n-  --> $DIR/derive-helper-shadowing.rs:8:3\n+  --> $DIR/derive-helper-shadowing.rs:19:3\n    |\n LL | #[empty_helper]\n    |   ^^^^^^^^^^^^ ambiguous name\n    |\n note: `empty_helper` could refer to the derive helper attribute defined here\n-  --> $DIR/derive-helper-shadowing.rs:9:10\n+  --> $DIR/derive-helper-shadowing.rs:20:10\n+   |\n+LL | #[derive(Empty)]\n+   |          ^^^^^\n+note: `empty_helper` could also refer to the attribute macro imported here\n+  --> $DIR/derive-helper-shadowing.rs:10:5\n+   |\n+LL | use test_macros::empty_attr as empty_helper;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n+\n+error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n+  --> $DIR/derive-helper-shadowing.rs:22:7\n+   |\n+LL |     #[empty_helper]\n+   |       ^^^^^^^^^^^^ ambiguous name\n+   |\n+note: `empty_helper` could refer to the derive helper attribute defined here\n+  --> $DIR/derive-helper-shadowing.rs:20:10\n+   |\n+LL | #[derive(Empty)]\n+   |          ^^^^^\n+note: `empty_helper` could also refer to the attribute macro imported here\n+  --> $DIR/derive-helper-shadowing.rs:10:5\n+   |\n+LL | use test_macros::empty_attr as empty_helper;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n+\n+error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n+  --> $DIR/derive-helper-shadowing.rs:26:11\n+   |\n+LL |         #[empty_helper]\n+   |           ^^^^^^^^^^^^ ambiguous name\n+   |\n+note: `empty_helper` could refer to the derive helper attribute defined here\n+  --> $DIR/derive-helper-shadowing.rs:20:10\n    |\n LL | #[derive(Empty)]\n    |          ^^^^^\n note: `empty_helper` could also refer to the attribute macro imported here\n-  --> $DIR/derive-helper-shadowing.rs:6:5\n+  --> $DIR/derive-helper-shadowing.rs:10:5\n    |\n LL | use test_macros::empty_attr as empty_helper;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n-error: aborting due to previous error\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0659`."}]}