{"sha": "0c81d0158f70a48945203daa8447bb84a5d0f5cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjODFkMDE1OGY3MGE0ODk0NTIwM2RhYTg0NDdiYjg0YTVkMGY1Y2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-04T11:13:46Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-15T21:49:22Z"}, "message": "extract out the implied bounds code from `regionck`", "tree": {"sha": "931a2ea4b67433e1be25403e02703a99390a524f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/931a2ea4b67433e1be25403e02703a99390a524f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c81d0158f70a48945203daa8447bb84a5d0f5cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c81d0158f70a48945203daa8447bb84a5d0f5cf", "html_url": "https://github.com/rust-lang/rust/commit/0c81d0158f70a48945203daa8447bb84a5d0f5cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c81d0158f70a48945203daa8447bb84a5d0f5cf/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b587c1a024f6946ee31186447564a2e5cb4e7602", "url": "https://api.github.com/repos/rust-lang/rust/commits/b587c1a024f6946ee31186447564a2e5cb4e7602", "html_url": "https://github.com/rust-lang/rust/commit/b587c1a024f6946ee31186447564a2e5cb4e7602"}], "stats": {"total": 627, "additions": 357, "deletions": 270}, "files": [{"sha": "297feead61760f6a734aed7b02fb406f6dac5ca3", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=0c81d0158f70a48945203daa8447bb84a5d0f5cf", "patch": "@@ -139,9 +139,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         });\n     }\n \n-    pub fn register_predicate_obligations(&mut self,\n-                                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                          obligations: Vec<PredicateObligation<'tcx>>)\n+    pub fn register_predicate_obligations<I>(&mut self,\n+                                             infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                             obligations: I)\n+        where I: IntoIterator<Item = PredicateObligation<'tcx>>\n     {\n         for obligation in obligations {\n             self.register_predicate_obligation(infcx, obligation);"}, {"sha": "7d98a1c9246b6fc27994e00c6436b73160cdc945", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c81d0158f70a48945203daa8447bb84a5d0f5cf", "patch": "@@ -137,6 +137,7 @@ pub mod dropck;\n pub mod _match;\n pub mod writeback;\n mod regionck;\n+mod regionck_implied_bounds;\n pub mod coercion;\n pub mod demand;\n pub mod method;"}, {"sha": "5954a0f2ecdce20bae95414446f24fc2d9ee6ae2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 72, "deletions": 267, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0c81d0158f70a48945203daa8447bb84a5d0f5cf", "patch": "@@ -84,17 +84,14 @@\n \n use check::dropck;\n use check::FnCtxt;\n-use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TypeFoldable};\n-use rustc::infer::{self, GenericKind};\n+use rustc::ty::{self, Ty};\n+use rustc::infer;\n use rustc::ty::adjustment;\n-use rustc::ty::outlives::Component;\n-use rustc::ty::wf;\n \n use std::mem;\n use std::ops::Deref;\n@@ -104,6 +101,8 @@ use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, PatKind};\n \n+use super::regionck_implied_bounds::OutlivesEnvironment;\n+\n // a variation on try that just returns unit\n macro_rules! ignore_err {\n     ($e:expr) => (match $e { Ok(e) => e, Err(_) => return () })\n@@ -116,7 +115,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject));\n+        let mut rcx = RegionCtxt::new(self,\n+                                      RepeatingScope(id),\n+                                      id,\n+                                      Subject(subject),\n+                                      self.param_env);\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n@@ -125,7 +128,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         rcx.resolve_regions_and_report_errors();\n \n         assert!(self.tables.borrow().free_region_map.is_empty());\n-        self.tables.borrow_mut().free_region_map = rcx.free_region_map;\n+        self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n@@ -136,10 +139,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n         let subject = self.tcx.hir.local_def_id(item_id);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(subject));\n-        rcx.free_region_map.relate_free_regions_from_predicates(\n-            &self.param_env.caller_bounds);\n-        rcx.relate_free_regions(wf_tys, item_id, span);\n+        let mut rcx = RegionCtxt::new(self,\n+                                      RepeatingScope(item_id),\n+                                      item_id,\n+                                      Subject(subject),\n+                                      self.param_env);\n+        rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.visit_region_obligations(item_id);\n         rcx.resolve_regions_and_report_errors();\n     }\n@@ -158,23 +163,24 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(subject));\n+        let mut rcx = RegionCtxt::new(self,\n+                                      RepeatingScope(node_id),\n+                                      node_id,\n+                                      Subject(subject),\n+                                      self.param_env);\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir.span(fn_id));\n         }\n \n-        rcx.free_region_map.relate_free_regions_from_predicates(\n-            &self.param_env.caller_bounds);\n-\n         rcx.resolve_regions_and_report_errors();\n \n         // In this mode, we also copy the free-region-map into the\n         // tables of the enclosing fcx. In the other regionck modes\n         // (e.g., `regionck_item`), we don't have an enclosing tables.\n         assert!(self.tables.borrow().free_region_map.is_empty());\n-        self.tables.borrow_mut().free_region_map = rcx.free_region_map;\n+        self.tables.borrow_mut().free_region_map = rcx.outlives_environment.into_free_region_map();\n     }\n }\n \n@@ -184,11 +190,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n \n-    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n-\n     pub region_scope_tree: Rc<region::ScopeTree>,\n \n-    free_region_map: FreeRegionMap<'tcx>,\n+    outlives_environment: OutlivesEnvironment<'tcx>,\n \n     // id of innermost fn body id\n     body_id: ast::NodeId,\n@@ -204,24 +208,6 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n }\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-#[derive(Debug)]\n-enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n     type Target = FnCtxt<'a, 'gcx, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n@@ -236,29 +222,22 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n+               Subject(subject): Subject,\n+               param_env: ty::ParamEnv<'tcx>)\n+               -> RegionCtxt<'a, 'gcx, 'tcx> {\n         let region_scope_tree = fcx.tcx.region_scope_tree(subject);\n+        let outlives_environment = OutlivesEnvironment::new(param_env);\n         RegionCtxt {\n             fcx,\n             region_scope_tree,\n             repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             call_site_scope: None,\n             subject_def_id: subject,\n-            region_bound_pairs: Vec::new(),\n-            free_region_map: FreeRegionMap::new(),\n+            outlives_environment,\n         }\n     }\n \n-    fn set_call_site_scope(&mut self, call_site_scope: Option<region::Scope>)\n-                           -> Option<region::Scope> {\n-        mem::replace(&mut self.call_site_scope, call_site_scope)\n-    }\n-\n-    fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n-        mem::replace(&mut self.body_id, body_id)\n-    }\n-\n     fn set_repeating_scope(&mut self, scope: ast::NodeId) -> ast::NodeId {\n         mem::replace(&mut self.repeating_scope, scope)\n     }\n@@ -302,6 +281,18 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.resolve_type(ty)\n     }\n \n+    /// This is the \"main\" function when region-checking a function item or a closure\n+    /// within a function item. It begins by updating various fields (e.g., `call_site_scope`\n+    /// and `outlives_environment`) to be appropriate to the function and then adds constraints\n+    /// derived from the function body.\n+    ///\n+    /// Note that it does **not** restore the state of the fields that\n+    /// it updates! This is intentional, since -- for the main\n+    /// function -- we wish to be able to read the final\n+    /// `outlives_environment` and other fields from the caller. For\n+    /// closures, however, we save and restore any \"scoped state\"\n+    /// before we invoke this function. (See `visit_fn` in the\n+    /// `intravisit::Visitor` impl below.)\n     fn visit_fn_body(&mut self,\n                      id: ast::NodeId, // the id of the fn itself\n                      body: &'gcx hir::Body,\n@@ -311,9 +302,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"visit_fn_body(id={})\", id);\n \n         let body_id = body.id();\n+        self.body_id = body_id.node_id;\n \n         let call_site = region::Scope::CallSite(body.value.hir_id.local_id);\n-        let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n+        self.call_site_scope = Some(call_site);\n \n         let fn_sig = {\n             let fn_hir_id = self.tcx.hir.node_to_hir_id(id);\n@@ -325,8 +317,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let old_region_bounds_pairs_len = self.region_bound_pairs.len();\n-\n         // Collect the types from which we create inferred bounds.\n         // For the return type, if diverging, substitute `bool` just\n         // because it will have no effect.\n@@ -335,8 +325,11 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs().iter().cloned().chain(Some(fn_sig.output())).collect();\n \n-        let old_body_id = self.set_body_id(body_id.node_id);\n-        self.relate_free_regions(&fn_sig_tys[..], body_id.node_id, span);\n+        self.outlives_environment.add_implied_bounds(\n+            self.fcx,\n+            &fn_sig_tys[..],\n+            body_id.node_id,\n+            span);\n         self.link_fn_args(region::Scope::Node(body.value.hir_id.local_id), &body.arguments);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.node_id);\n@@ -349,11 +342,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n                                        body_hir_id,\n                                        call_site_region);\n-\n-        self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n-\n-        self.set_body_id(old_body_id);\n-        self.set_call_site_scope(old_call_site_scope);\n     }\n \n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n@@ -366,217 +354,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.select_all_obligations_or_error();\n \n         self.infcx.process_registered_region_obligations(\n-            &self.region_bound_pairs,\n+            self.outlives_environment.region_bound_pairs(),\n             self.implicit_region_bound,\n             self.param_env,\n             self.body_id);\n     }\n \n-    /// This method populates the region map's `free_region_map`. It walks over the transformed\n-    /// argument and return types for each function just before we check the body of that function,\n-    /// looking for types where you have a borrowed pointer to other borrowed data (e.g., `&'a &'b\n-    /// [usize]`.  We do not allow references to outlive the things they point at, so we can assume\n-    /// that `'a <= 'b`. This holds for both the argument and return types, basically because, on\n-    /// the caller side, the caller is responsible for checking that the type of every expression\n-    /// (including the actual values for the arguments, as well as the return type of the fn call)\n-    /// is well-formed.\n-    ///\n-    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n-    fn relate_free_regions(&mut self,\n-                           fn_sig_tys: &[Ty<'tcx>],\n-                           body_id: ast::NodeId,\n-                           span: Span) {\n-        debug!(\"relate_free_regions >>\");\n-\n-        for &ty in fn_sig_tys {\n-            let ty = self.resolve_type(ty);\n-            debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds = self.implied_bounds(body_id, ty, span);\n-\n-            // But also record other relationships, such as `T:'x`,\n-            // that don't go into the free-region-map but which we use\n-            // here.\n-            for implication in implied_bounds {\n-                debug!(\"implication: {:?}\", implication);\n-                match implication {\n-                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_),\n-                                                  &ty::ReVar(vid_b)) |\n-                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_),\n-                                                  &ty::ReVar(vid_b)) => {\n-                        self.add_given(r_a, vid_b);\n-                    }\n-                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n-                        self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n-                    }\n-                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n-                        self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n-                    }\n-                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        if body_id == self.fcx.body_id {\n-                            // Only modify `free_region_map` if these\n-                            // are parameters from the root\n-                            // function. That's because this data\n-                            // struture is shared across all functions\n-                            // and hence we don't want to take implied\n-                            // bounds from one closure and use them\n-                            // outside.\n-                            self.free_region_map.relate_regions(r_a, r_b);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        debug!(\"<< relate_free_regions\");\n-    }\n-\n-    /// Compute the implied bounds that a callee/impl can assume based on\n-    /// the fact that caller/projector has ensured that `ty` is WF.  See\n-    /// the `ImpliedBound` type for more details.\n-    fn implied_bounds(&mut self, body_id: ast::NodeId, ty: Ty<'tcx>, span: Span)\n-                      -> Vec<ImpliedBound<'tcx>> {\n-        // Sometimes when we ask what it takes for T: WF, we get back that\n-        // U: WF is required; in that case, we push U onto this stack and\n-        // process it next. Currently (at least) these resulting\n-        // predicates are always guaranteed to be a subset of the original\n-        // type, so we need not fear non-termination.\n-        let mut wf_types = vec![ty];\n-\n-        let mut implied_bounds = vec![];\n-\n-        while let Some(ty) = wf_types.pop() {\n-            // Compute the obligations for `ty` to be well-formed. If `ty` is\n-            // an unresolved inference variable, just substituted an empty set\n-            // -- because the return type here is going to be things we *add*\n-            // to the environment, it's always ok for this set to be smaller\n-            // than the ultimate set. (Note: normally there won't be\n-            // unresolved inference variables here anyway, but there might be\n-            // during typeck under some circumstances.)\n-            let obligations =\n-                wf::obligations(self, self.fcx.param_env, body_id, ty, span)\n-                .unwrap_or(vec![]);\n-\n-            // NB: All of these predicates *ought* to be easily proven\n-            // true. In fact, their correctness is (mostly) implied by\n-            // other parts of the program. However, in #42552, we had\n-            // an annoying scenario where:\n-            //\n-            // - Some `T::Foo` gets normalized, resulting in a\n-            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-            //   (not sure why it couldn't immediately get\n-            //   solved). This result of `_1` got cached.\n-            // - These obligations were dropped on the floor here,\n-            //   rather than being registered.\n-            // - Then later we would get a request to normalize\n-            //   `T::Foo` which would result in `_1` being used from\n-            //   the cache, but hence without the `T: Trait<Foo=_1>`\n-            //   constraint. As a result, `_1` never gets resolved,\n-            //   and we get an ICE (in dropck).\n-            //\n-            // Therefore, we register any predicates involving\n-            // inference variables. We restrict ourselves to those\n-            // involving inference variables both for efficiency and\n-            // to avoids duplicate errors that otherwise show up.\n-            self.fcx.register_predicates(\n-                obligations.iter()\n-                           .filter(|o| o.predicate.has_infer_types())\n-                           .cloned());\n-\n-            // From the full set of obligations, just filter down to the\n-            // region relationships.\n-            implied_bounds.extend(\n-                obligations\n-                    .into_iter()\n-                    .flat_map(|obligation| {\n-                        assert!(!obligation.has_escaping_regions());\n-                        match obligation.predicate {\n-                            ty::Predicate::Trait(..) |\n-                            ty::Predicate::Equate(..) |\n-                            ty::Predicate::Subtype(..) |\n-                            ty::Predicate::Projection(..) |\n-                            ty::Predicate::ClosureKind(..) |\n-                            ty::Predicate::ObjectSafe(..) |\n-                            ty::Predicate::ConstEvaluatable(..) =>\n-                                vec![],\n-\n-                            ty::Predicate::WellFormed(subty) => {\n-                                wf_types.push(subty);\n-                                vec![]\n-                            }\n-\n-                            ty::Predicate::RegionOutlives(ref data) =>\n-                                match self.tcx.no_late_bound_regions(data) {\n-                                    None =>\n-                                        vec![],\n-                                    Some(ty::OutlivesPredicate(r_a, r_b)) =>\n-                                        vec![ImpliedBound::RegionSubRegion(r_b, r_a)],\n-                                },\n-\n-                            ty::Predicate::TypeOutlives(ref data) =>\n-                                match self.tcx.no_late_bound_regions(data) {\n-                                    None => vec![],\n-                                    Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                        let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n-                                        let components = self.tcx.outlives_components(ty_a);\n-                                        self.implied_bounds_from_components(r_b, components)\n-                                    }\n-                                },\n-                        }}));\n-        }\n-\n-        implied_bounds\n-    }\n-\n-    /// When we have an implied bound that `T: 'a`, we can further break\n-    /// this down to determine what relationships would have to hold for\n-    /// `T: 'a` to hold. We get to assume that the caller has validated\n-    /// those relationships.\n-    fn implied_bounds_from_components(&self,\n-                                      sub_region: ty::Region<'tcx>,\n-                                      sup_components: Vec<Component<'tcx>>)\n-                                      -> Vec<ImpliedBound<'tcx>>\n-    {\n-        sup_components\n-            .into_iter()\n-            .flat_map(|component| {\n-                match component {\n-                    Component::Region(r) =>\n-                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n-                    Component::Param(p) =>\n-                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n-                    Component::Projection(p) =>\n-                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n-                    Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                        vec![],\n-                    Component::UnresolvedInferenceVariable(..) =>\n-                        vec![],\n-                }\n-            })\n-            .collect()\n-    }\n-\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_scope_tree,\n-                                                   &self.free_region_map);\n+                                                   self.outlives_environment.free_region_map());\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n@@ -632,10 +419,28 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n-                b: hir::BodyId, span: Span, id: ast::NodeId) {\n-        let body = self.tcx.hir.body(b);\n-        self.visit_fn_body(id, body, span)\n+    fn visit_fn(&mut self,\n+                fk: intravisit::FnKind<'gcx>,\n+                _: &'gcx hir::FnDecl,\n+                body_id: hir::BodyId,\n+                span: Span,\n+                id: ast::NodeId) {\n+        assert!(match fk { intravisit::FnKind::Closure(..) => true, _ => false },\n+                \"visit_fn invoked for something other than a closure\");\n+\n+        // Save state of current function before invoking\n+        // `visit_fn_body`.  We will restore afterwards.\n+        let outlives_environment = self.outlives_environment.clone();\n+        let old_body_id = self.body_id;\n+        let old_call_site_scope = self.call_site_scope;\n+\n+        let body = self.tcx.hir.body(body_id);\n+        self.visit_fn_body(id, body, span);\n+\n+        // Restore state from previous function.\n+        self.call_site_scope = old_call_site_scope;\n+        self.body_id = old_body_id;\n+        self.outlives_environment = outlives_environment;\n     }\n \n     //visit_pat: visit_pat, // (..) see above\n@@ -1144,7 +949,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                              ty: Ty<'tcx>,\n                              region: ty::Region<'tcx>)\n     {\n-        self.infcx.type_must_outlive(&self.region_bound_pairs,\n+        self.infcx.type_must_outlive(self.outlives_environment.region_bound_pairs(),\n                                      self.implicit_region_bound,\n                                      self.param_env,\n                                      origin,"}, {"sha": "f84e0dd880fcceca42316a8c1774c820c4e85652", "filename": "src/librustc_typeck/check/regionck_implied_bounds.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck_implied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c81d0158f70a48945203daa8447bb84a5d0f5cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck_implied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck_implied_bounds.rs?ref=0c81d0158f70a48945203daa8447bb84a5d0f5cf", "patch": "@@ -0,0 +1,280 @@\n+use middle::free_region::FreeRegionMap;\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::infer::{InferCtxt, GenericKind};\n+use rustc::traits::FulfillmentContext;\n+use rustc::ty::outlives::Component;\n+use rustc::ty::wf;\n+\n+use syntax::ast;\n+use syntax_pos::Span;\n+\n+#[derive(Clone)]\n+pub struct OutlivesEnvironment<'tcx> {\n+    param_env: ty::ParamEnv<'tcx>,\n+    free_region_map: FreeRegionMap<'tcx>,\n+    region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n+}\n+\n+/// Implied bounds are region relationships that we deduce\n+/// automatically.  The idea is that (e.g.) a caller must check that a\n+/// function's argument types are well-formed immediately before\n+/// calling that fn, and hence the *callee* can assume that its\n+/// argument types are well-formed. This may imply certain relationships\n+/// between generic parameters. For example:\n+///\n+///     fn foo<'a,T>(x: &'a T)\n+///\n+/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+#[derive(Debug)]\n+enum ImpliedBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n+    pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n+        let mut free_region_map = FreeRegionMap::new();\n+        free_region_map.relate_free_regions_from_predicates(&param_env.caller_bounds);\n+\n+        OutlivesEnvironment {\n+            param_env,\n+            free_region_map,\n+            region_bound_pairs: vec![],\n+        }\n+    }\n+\n+    /// Borrows current value of the `free_region_map`.\n+    pub fn free_region_map(&self) -> &FreeRegionMap<'tcx> {\n+        &self.free_region_map\n+    }\n+\n+    /// Borrows current value of the `region_bound_pairs`.\n+    pub fn region_bound_pairs(&self) -> &[(ty::Region<'tcx>, GenericKind<'tcx>)] {\n+        &self.region_bound_pairs\n+    }\n+\n+    /// Returns ownership of the `free_region_map`.\n+    pub fn into_free_region_map(self) -> FreeRegionMap<'tcx> {\n+        self.free_region_map\n+    }\n+\n+    /// This method adds \"implied bounds\" into the outlives environment.\n+    /// Implied bounds are outlives relationships that we can deduce\n+    /// on the basis that certain types must be well-formed -- these are\n+    /// either the types that appear in the function signature or else\n+    /// the input types to an impl. For example, if you have a function\n+    /// like\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n+    /// ```\n+    ///\n+    /// we can assume in the caller's body that `'b: 'a` and that `T:\n+    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n+    /// add those assumptions into the outlives-environment.\n+    ///\n+    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+    pub fn add_implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        fn_sig_tys: &[Ty<'tcx>],\n+        body_id: ast::NodeId,\n+        span: Span,\n+    ) {\n+        debug!(\"add_implied_bounds()\");\n+\n+        for &ty in fn_sig_tys {\n+            let ty = infcx.resolve_type_vars_if_possible(&ty);\n+            debug!(\"add_implied_bounds: ty = {}\", ty);\n+            let implied_bounds = self.implied_bounds(infcx, body_id, ty, span);\n+\n+            // But also record other relationships, such as `T:'x`,\n+            // that don't go into the free-region-map but which we use\n+            // here.\n+            for implication in implied_bounds {\n+                debug!(\"add_implied_bounds: implication={:?}\", implication);\n+                match implication {\n+                    ImpliedBound::RegionSubRegion(\n+                        r_a @ &ty::ReEarlyBound(_),\n+                        &ty::ReVar(vid_b),\n+                    ) |\n+                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n+                        infcx.add_given(r_a, vid_b);\n+                    }\n+                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n+                        self.region_bound_pairs\n+                            .push((r_a, GenericKind::Param(param_b)));\n+                    }\n+                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n+                        self.region_bound_pairs\n+                            .push((r_a, GenericKind::Projection(projection_b)));\n+                    }\n+                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n+                        // In principle, we could record (and take\n+                        // advantage of) every relationship here, but\n+                        // we are also free not to -- it simply means\n+                        // strictly less that we can successfully type\n+                        // check. Right now we only look for things\n+                        // relationships between free regions. (It may\n+                        // also be that we should revise our inference\n+                        // system to be more general and to make use\n+                        // of *every* relationship that arises here,\n+                        // but presently we do not.)\n+                        self.free_region_map.relate_regions(r_a, r_b);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Compute the implied bounds that a callee/impl can assume based on\n+    /// the fact that caller/projector has ensured that `ty` is WF.  See\n+    /// the `ImpliedBound` type for more details.\n+    fn implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+        body_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<ImpliedBound<'tcx>> {\n+        let tcx = infcx.tcx;\n+\n+        // Sometimes when we ask what it takes for T: WF, we get back that\n+        // U: WF is required; in that case, we push U onto this stack and\n+        // process it next. Currently (at least) these resulting\n+        // predicates are always guaranteed to be a subset of the original\n+        // type, so we need not fear non-termination.\n+        let mut wf_types = vec![ty];\n+\n+        let mut implied_bounds = vec![];\n+\n+        let mut fulfill_cx = FulfillmentContext::new();\n+\n+        while let Some(ty) = wf_types.pop() {\n+            // Compute the obligations for `ty` to be well-formed. If `ty` is\n+            // an unresolved inference variable, just substituted an empty set\n+            // -- because the return type here is going to be things we *add*\n+            // to the environment, it's always ok for this set to be smaller\n+            // than the ultimate set. (Note: normally there won't be\n+            // unresolved inference variables here anyway, but there might be\n+            // during typeck under some circumstances.)\n+            let obligations =\n+                wf::obligations(infcx, self.param_env, body_id, ty, span).unwrap_or(vec![]);\n+\n+            // NB: All of these predicates *ought* to be easily proven\n+            // true. In fact, their correctness is (mostly) implied by\n+            // other parts of the program. However, in #42552, we had\n+            // an annoying scenario where:\n+            //\n+            // - Some `T::Foo` gets normalized, resulting in a\n+            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+            //   (not sure why it couldn't immediately get\n+            //   solved). This result of `_1` got cached.\n+            // - These obligations were dropped on the floor here,\n+            //   rather than being registered.\n+            // - Then later we would get a request to normalize\n+            //   `T::Foo` which would result in `_1` being used from\n+            //   the cache, but hence without the `T: Trait<Foo=_1>`\n+            //   constraint. As a result, `_1` never gets resolved,\n+            //   and we get an ICE (in dropck).\n+            //\n+            // Therefore, we register any predicates involving\n+            // inference variables. We restrict ourselves to those\n+            // involving inference variables both for efficiency and\n+            // to avoids duplicate errors that otherwise show up.\n+            fulfill_cx.register_predicate_obligations(\n+                infcx,\n+                obligations\n+                    .iter()\n+                    .filter(|o| o.predicate.has_infer_types())\n+                    .cloned());\n+\n+            // From the full set of obligations, just filter down to the\n+            // region relationships.\n+            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+                assert!(!obligation.has_escaping_regions());\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => vec![],\n+\n+                    ty::Predicate::WellFormed(subty) => {\n+                        wf_types.push(subty);\n+                        vec![]\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref data) => {\n+                        match tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n+                            }\n+                        }\n+                    }\n+\n+                    ty::Predicate::TypeOutlives(ref data) => {\n+                        match tcx.no_late_bound_regions(data) {\n+                            None => vec![],\n+                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n+                                let components = tcx.outlives_components(ty_a);\n+                                self.implied_bounds_from_components(r_b, components)\n+                            }\n+                        }\n+                    }\n+                }\n+            }));\n+        }\n+\n+        // Ensure that those obligations that we had to solve\n+        // get solved *here*.\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => (),\n+            Err(errors) => infcx.report_fulfillment_errors(&errors, None),\n+        }\n+\n+        implied_bounds\n+    }\n+\n+    /// When we have an implied bound that `T: 'a`, we can further break\n+    /// this down to determine what relationships would have to hold for\n+    /// `T: 'a` to hold. We get to assume that the caller has validated\n+    /// those relationships.\n+    fn implied_bounds_from_components(\n+        &self,\n+        sub_region: ty::Region<'tcx>,\n+        sup_components: Vec<Component<'tcx>>,\n+    ) -> Vec<ImpliedBound<'tcx>> {\n+        sup_components\n+            .into_iter()\n+            .flat_map(|component| {\n+                match component {\n+                    Component::Region(r) =>\n+                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n+                    Component::Param(p) =>\n+                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n+                    Component::Projection(p) =>\n+                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n+                    Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                        vec![],\n+                    Component::UnresolvedInferenceVariable(..) =>\n+                        vec![],\n+                }\n+            })\n+            .collect()\n+    }\n+}"}]}