{"sha": "fc73e196d9cf045c722aff27b9a2e595357384db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNzNlMTk2ZDljZjA0NWM3MjJhZmYyN2I5YTJlNTk1MzU3Mzg0ZGI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-11T22:21:21Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-11T22:21:21Z"}, "message": "Review comments.", "tree": {"sha": "c6bfbb7dac0b1445eb2db5d1dc1588b9aa28e3a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6bfbb7dac0b1445eb2db5d1dc1588b9aa28e3a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc73e196d9cf045c722aff27b9a2e595357384db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc73e196d9cf045c722aff27b9a2e595357384db", "html_url": "https://github.com/rust-lang/rust/commit/fc73e196d9cf045c722aff27b9a2e595357384db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc73e196d9cf045c722aff27b9a2e595357384db/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "513eb744c0c2ead6b10a3a3e5f0267e4136a9b4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/513eb744c0c2ead6b10a3a3e5f0267e4136a9b4f", "html_url": "https://github.com/rust-lang/rust/commit/513eb744c0c2ead6b10a3a3e5f0267e4136a9b4f"}], "stats": {"total": 151, "additions": 76, "deletions": 75}, "files": [{"sha": "c8e284be6fc09cf5cad7615b2d19fd125163d61e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -31,7 +31,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn fn_trait_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+    pub fn fn_trait_kind_from_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n         let items = self.lang_items();\n         match Some(id) {\n             x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),"}, {"sha": "bf82d743c2b0466a5a7ccc8d5b4c010d2b656c58", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -1634,7 +1634,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n-        let kind = match self.tcx().fn_trait_lang_item(obligation.predicate.def_id()) {\n+        let kind = match self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => {\n                 return Ok(());\n@@ -1677,7 +1677,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         candidates: &mut SelectionCandidateSet<'tcx>,\n     ) -> Result<(), SelectionError<'tcx>> {\n         // We provide impl of all fn traits for fn pointers.\n-        if self.tcx().fn_trait_lang_item(obligation.predicate.def_id()).is_none() {\n+        if self.tcx().fn_trait_kind_from_lang_item(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n \n@@ -2889,7 +2889,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let kind = self\n             .tcx()\n-            .fn_trait_lang_item(obligation.predicate.def_id())\n+            .fn_trait_kind_from_lang_item(obligation.predicate.def_id())\n             .unwrap_or_else(|| bug!(\"closure candidate for non-fn trait {:?}\", obligation));\n \n         // Okay to skip binder because the substs on closure types never"}, {"sha": "b5e17661c5de1ed30c719bb23ea5765edc177e80", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -450,7 +450,7 @@ fn resolve_associated_item<'tcx>(\n             substs: generator_data.substs,\n         }),\n         traits::VtableClosure(closure_data) => {\n-            let trait_closure_kind = tcx.fn_trait_lang_item(trait_id).unwrap();\n+            let trait_closure_kind = tcx.fn_trait_kind_from_lang_item(trait_id).unwrap();\n             Some(Instance::resolve_closure(\n                 tcx,\n                 closure_data.closure_def_id,"}, {"sha": "274482cba64cc5d66c09ab21e40c503f0d734f1c", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -724,7 +724,7 @@ pub trait PrettyPrinter<'tcx>:\n             let mut resugared = false;\n \n             // Special-case `Fn(...) -> ...` and resugar it.\n-            let fn_trait_kind = self.tcx().fn_trait_lang_item(principal.def_id);\n+            let fn_trait_kind = self.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n             if !self.tcx().sess.verbose() && fn_trait_kind.is_some() {\n                 if let ty::Tuple(ref args) = principal.substs.type_at(0).kind {\n                     let mut projections = predicates.projection_bounds();"}, {"sha": "cb5ebba463394c08353fdf1699da288c915f1b88", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -28,76 +28,76 @@ macro_rules! language_item_table {\n         $( $variant:ident, $name:expr, $method:ident, $target:path; )*\n     ) => {\n \n-enum_from_u32! {\n-    /// A representation of all the valid language items in Rust.\n-    #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-    pub enum LangItem {\n-        $($variant,)*\n-    }\n-}\n-\n-impl LangItem {\n-    /// Returns the `name` in `#[lang = \"$name\"]`.\n-    /// For example, `LangItem::EqTraitLangItem`,\n-    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n-    pub fn name(self) -> &'static str {\n-        match self {\n-            $( $variant => $name, )*\n+        enum_from_u32! {\n+            /// A representation of all the valid language items in Rust.\n+            #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+            pub enum LangItem {\n+                $($variant,)*\n+            }\n         }\n-    }\n-}\n-\n-#[derive(HashStable_Generic)]\n-pub struct LanguageItems {\n-    /// Mappings from lang items to their possibly found `DefId`s.\n-    /// The index corresponds to the order in `LangItem`.\n-    pub items: Vec<Option<DefId>>,\n-    /// Lang items that were not found during collection.\n-    pub missing: Vec<LangItem>,\n-}\n-\n-impl LanguageItems {\n-    /// Construct an empty collection of lang items and no missing ones.\n-    pub fn new() -> Self {\n-        fn init_none(_: LangItem) -> Option<DefId> { None }\n \n-        Self {\n-            items: vec![$(init_none($variant)),*],\n-            missing: Vec::new(),\n+        impl LangItem {\n+            /// Returns the `name` in `#[lang = \"$name\"]`.\n+            /// For example, `LangItem::EqTraitLangItem`,\n+            /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n+            pub fn name(self) -> &'static str {\n+                match self {\n+                    $( $variant => $name, )*\n+                }\n+            }\n         }\n-    }\n-\n-    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n-    pub fn items(&self) -> &[Option<DefId>] {\n-        &*self.items\n-    }\n \n-    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n-    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n-    /// returns an error message as a string.\n-    pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n-        self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n-    }\n+        #[derive(HashStable_Generic)]\n+        pub struct LanguageItems {\n+            /// Mappings from lang items to their possibly found `DefId`s.\n+            /// The index corresponds to the order in `LangItem`.\n+            pub items: Vec<Option<DefId>>,\n+            /// Lang items that were not found during collection.\n+            pub missing: Vec<LangItem>,\n+        }\n \n-    $(\n-        /// Returns the corresponding `DefId` for the lang item\n-        #[doc = $name]\n-        /// if it exists.\n-        #[allow(dead_code)]\n-        pub fn $method(&self) -> Option<DefId> {\n-            self.items[$variant as usize]\n+        impl LanguageItems {\n+            /// Construct an empty collection of lang items and no missing ones.\n+            pub fn new() -> Self {\n+                fn init_none(_: LangItem) -> Option<DefId> { None }\n+\n+                Self {\n+                    items: vec![$(init_none($variant)),*],\n+                    missing: Vec::new(),\n+                }\n+            }\n+\n+            /// Returns the mappings to the possibly found `DefId`s for each lang item.\n+            pub fn items(&self) -> &[Option<DefId>] {\n+                &*self.items\n+            }\n+\n+            /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+            /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+            /// returns an error message as a string.\n+            pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n+                self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n+            }\n+\n+            $(\n+                /// Returns the corresponding `DefId` for the lang item\n+                #[doc = $name]\n+                /// if it exists.\n+                #[allow(dead_code)]\n+                pub fn $method(&self) -> Option<DefId> {\n+                    self.items[$variant as usize]\n+                }\n+            )*\n         }\n-    )*\n-}\n \n-lazy_static! {\n-    /// A mapping from the name of the lang item to its order and the form it must be of.\n-    pub static ref ITEM_REFS: FxHashMap<&'static str, (usize, Target)> = {\n-        let mut item_refs = FxHashMap::default();\n-        $( item_refs.insert($name, ($variant as usize, $target)); )*\n-        item_refs\n-    };\n-}\n+        lazy_static! {\n+            /// A mapping from the name of the lang item to its order and the form it must be of.\n+            pub static ref ITEM_REFS: FxHashMap<&'static str, (usize, Target)> = {\n+                let mut item_refs = FxHashMap::default();\n+                $( item_refs.insert($name, ($variant as usize, $target)); )*\n+                item_refs\n+            };\n+        }\n \n // End of the macro\n     }"}, {"sha": "bfd30ff5da553ee15c6c33ebe8f87b102a17e7f1", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -40,7 +40,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n         ),\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n-            let adjustment = match tcx.fn_trait_lang_item(trait_) {\n+            let adjustment = match tcx.fn_trait_kind_from_lang_item(trait_) {\n                 Some(ty::ClosureKind::FnOnce) => Adjustment::Identity,\n                 Some(ty::ClosureKind::FnMut) | Some(ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),"}, {"sha": "396534b3caeb7b63840254eeed815da3b4fd6e76", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -174,8 +174,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n-                let kind =\n-                    object_type.principal_def_id().and_then(|did| self.tcx.fn_trait_lang_item(did));\n+                let kind = object_type\n+                    .principal_def_id()\n+                    .and_then(|did| self.tcx.fn_trait_kind_from_lang_item(did));\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n@@ -213,7 +214,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // many viable options, so pick the most restrictive.\n         let expected_kind = self\n             .obligations_for_self_ty(expected_vid)\n-            .filter_map(|(tr, _)| self.tcx.fn_trait_lang_item(tr.def_id()))\n+            .filter_map(|(tr, _)| self.tcx.fn_trait_kind_from_lang_item(tr.def_id()))\n             .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n         (expected_sig, expected_kind)\n@@ -236,7 +237,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let trait_ref = projection.to_poly_trait_ref(tcx);\n \n-        let is_fn = tcx.fn_trait_lang_item(trait_ref.def_id()).is_some();\n+        let is_fn = tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some();\n         let gen_trait = tcx.require_lang_item(lang_items::GeneratorTraitLangItem, cause_span);\n         let is_gen = gen_trait == trait_ref.def_id();\n         if !is_fn && !is_gen {"}, {"sha": "ef357056504529f9dd5245575ba7e148d7687675", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc73e196d9cf045c722aff27b9a2e595357384db/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=fc73e196d9cf045c722aff27b9a2e595357384db", "patch": "@@ -138,7 +138,7 @@ pub fn external_generic_args(\n \n     match trait_did {\n         // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.fn_trait_lang_item(did).is_some() => {\n+        Some(did) if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() => {\n             assert!(ty_kind.is_some());\n             let inputs = match ty_kind {\n                 Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),"}]}