{"sha": "7d29cf12256921d63860402a2e7cd2936c22e01e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMjljZjEyMjU2OTIxZDYzODYwNDAyYTJlN2NkMjkzNmMyMmUwMWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T08:02:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-19T08:02:04Z"}, "message": "use quote! to generate syntax kinds", "tree": {"sha": "23b02abebde690e648e2a069b447178eccdc1f18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b02abebde690e648e2a069b447178eccdc1f18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d29cf12256921d63860402a2e7cd2936c22e01e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d29cf12256921d63860402a2e7cd2936c22e01e", "html_url": "https://github.com/rust-lang/rust/commit/7d29cf12256921d63860402a2e7cd2936c22e01e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d29cf12256921d63860402a2e7cd2936c22e01e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39f50e7bd7a7aa573e6777ca764c020f93aeb205", "url": "https://api.github.com/repos/rust-lang/rust/commits/39f50e7bd7a7aa573e6777ca764c020f93aeb205", "html_url": "https://github.com/rust-lang/rust/commit/39f50e7bd7a7aa573e6777ca764c020f93aeb205"}], "stats": {"total": 149, "additions": 148, "deletions": 1}, "files": [{"sha": "05d340e5f6fc6a5b5438223f88513b71620afd34", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d29cf12256921d63860402a2e7cd2936c22e01e/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7d29cf12256921d63860402a2e7cd2936c22e01e/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7d29cf12256921d63860402a2e7cd2936c22e01e", "patch": "@@ -1364,6 +1364,7 @@ dependencies = [\n  \"clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"heck 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"proc-macro2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ron 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "a40a452aaa52faecf43a1e252403059c3070f11d", "filename": "crates/ra_tools/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d29cf12256921d63860402a2e7cd2936c22e01e/crates%2Fra_tools%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7d29cf12256921d63860402a2e7cd2936c22e01e/crates%2Fra_tools%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tools%2FCargo.toml?ref=7d29cf12256921d63860402a2e7cd2936c22e01e", "patch": "@@ -11,6 +11,7 @@ walkdir = \"2.1.3\"\n itertools = \"0.8.0\"\n clap = \"2.32.0\"\n quote = \"1.0.2\"\n+proc-macro2 = \"1.0.1\"\n ron = \"0.5.1\"\n heck = \"0.3.0\"\n serde = { version = \"1.0.0\", features = [\"derive\"] }"}, {"sha": "c7f37e20cd0922d35f89d06f882e3a77ad821f02", "filename": "crates/ra_tools/src/codegen.rs", "status": "modified", "additions": 146, "deletions": 1, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7d29cf12256921d63860402a2e7cd2936c22e01e/crates%2Fra_tools%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d29cf12256921d63860402a2e7cd2936c22e01e/crates%2Fra_tools%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tools%2Fsrc%2Fcodegen.rs?ref=7d29cf12256921d63860402a2e7cd2936c22e01e", "patch": "@@ -7,6 +7,7 @@ use std::{\n };\n \n use heck::{ShoutySnakeCase, SnakeCase};\n+use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n use ron;\n use serde::Deserialize;\n@@ -23,7 +24,7 @@ pub fn generate(mode: Mode) -> Result<()> {\n     let _syntax_kinds = project_root().join(SYNTAX_KINDS);\n     let _ast = project_root().join(AST);\n \n-    let ast = generate_ast(&grammar)?;\n+    let ast = generate_syntax_kinds(&grammar)?;\n     println!(\"{}\", ast);\n     Ok(())\n }\n@@ -144,6 +145,149 @@ fn generate_ast(grammar: &Grammar) -> Result<String> {\n     Ok(pretty)\n }\n \n+fn generate_syntax_kinds(grammar: &Grammar) -> Result<String> {\n+    let single_byte_tokens_values =\n+        grammar.single_byte_tokens.iter().map(|(token, _name)| token.chars().next().unwrap());\n+    let single_byte_tokens = grammar\n+        .single_byte_tokens\n+        .iter()\n+        .map(|(_token, name)| format_ident!(\"{}\", name))\n+        .collect::<Vec<_>>();\n+\n+    let punctuation_values =\n+        grammar.single_byte_tokens.iter().chain(grammar.multi_byte_tokens.iter()).map(\n+            |(token, _name)| {\n+                if \"{}[]()\".contains(token) {\n+                    let c = token.chars().next().unwrap();\n+                    quote! { #c }\n+                } else {\n+                    let cs = token.chars().map(|c| Punct::new(c, Spacing::Joint));\n+                    quote! { #(#cs)* }\n+                }\n+            },\n+        );\n+    let punctuation = single_byte_tokens\n+        .clone()\n+        .into_iter()\n+        .chain(grammar.multi_byte_tokens.iter().map(|(_token, name)| format_ident!(\"{}\", name)))\n+        .collect::<Vec<_>>();\n+\n+    let keywords_values =\n+        grammar.keywords.iter().chain(grammar.contextual_keywords.iter()).collect::<Vec<_>>();\n+    let keywords_idents = keywords_values.iter().map(|kw| format_ident!(\"{}\", kw));\n+    let keywords = keywords_values\n+        .iter()\n+        .map(|name| format_ident!(\"{}_KW\", name.to_shouty_snake_case()))\n+        .collect::<Vec<_>>();\n+\n+    let literals =\n+        grammar.literals.iter().map(|name| format_ident!(\"{}\", name)).collect::<Vec<_>>();\n+\n+    let tokens = grammar.tokens.iter().map(|name| format_ident!(\"{}\", name)).collect::<Vec<_>>();\n+\n+    let nodes = grammar.nodes.iter().map(|name| format_ident!(\"{}\", name)).collect::<Vec<_>>();\n+\n+    let ast = quote! {\n+        #![allow(bad_style, missing_docs, unreachable_pub)]\n+        use super::SyntaxInfo;\n+\n+        /// The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT_DEF`.\n+        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+        #[repr(u16)]\n+        pub enum SyntaxKind {\n+            // Technical SyntaxKinds: they appear temporally during parsing,\n+            // but never end up in the final tree\n+            #[doc(hidden)]\n+            TOMBSTONE,\n+            #[doc(hidden)]\n+            EOF,\n+            #(#punctuation,)*\n+            #(#keywords,)*\n+            #(#literals,)*\n+            #(#tokens,)*\n+            #(#nodes,)*\n+\n+            // Technical kind so that we can cast from u16 safely\n+            #[doc(hidden)]\n+            __LAST,\n+        }\n+        use self::SyntaxKind::*;\n+\n+        impl From<u16> for SyntaxKind {\n+            fn from(d: u16) -> SyntaxKind {\n+                assert!(d <= (__LAST as u16));\n+                unsafe { std::mem::transmute::<u16, SyntaxKind>(d) }\n+            }\n+        }\n+\n+        impl From<SyntaxKind> for u16 {\n+            fn from(k: SyntaxKind) -> u16 {\n+                k as u16\n+            }\n+        }\n+\n+        impl SyntaxKind {\n+            pub fn is_keyword(self) -> bool {\n+                match self {\n+                    #(#keywords)|* => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            pub fn is_punct(self) -> bool {\n+                match self {\n+                    #(#punctuation)|* => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            pub fn is_literal(self) -> bool {\n+                match self {\n+                    #(#literals)|* => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            pub(crate) fn info(self) -> &'static SyntaxInfo {\n+                match self {\n+                    #(#punctuation => &SyntaxInfo { name: stringify!(#punctuation) },)*\n+                    #(#keywords => &SyntaxInfo { name: stringify!(#keywords) },)*\n+                    #(#literals => &SyntaxInfo { name: stringify!(#literals) },)*\n+                    #(#tokens => &SyntaxInfo { name: stringify!(#tokens) },)*\n+                    #(#nodes => &SyntaxInfo { name: stringify!(#nodes) },)*\n+                    TOMBSTONE => &SyntaxInfo { name: \"TOMBSTONE\" },\n+                    EOF => &SyntaxInfo { name: \"EOF\" },\n+                    __LAST => &SyntaxInfo { name: \"__LAST\" },\n+                }\n+            }\n+\n+            pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {\n+                let kw = match ident {\n+                    #(#keywords_values => #keywords,)*\n+                    _ => return None,\n+                };\n+                Some(kw)\n+            }\n+\n+            pub fn from_char(c: char) -> Option<SyntaxKind> {\n+                let tok = match c {\n+                    #(#single_byte_tokens_values => #single_byte_tokens,)*\n+                    _ => return None,\n+                };\n+                Some(tok)\n+            }\n+        }\n+\n+        #[macro_export]\n+        macro_rules! T {\n+            #((#punctuation_values) => { $crate::SyntaxKind::#punctuation };)*\n+            #((#keywords_idents) => { $crate::SyntaxKind::#keywords };)*\n+        }\n+    };\n+\n+    reformat(ast)\n+}\n+\n fn reformat(text: impl std::fmt::Display) -> Result<String> {\n     let mut rustfmt = Command::new(\"rustfmt\")\n         .arg(\"--config-path\")\n@@ -166,6 +310,7 @@ struct Grammar {\n     contextual_keywords: Vec<String>,\n     literals: Vec<String>,\n     tokens: Vec<String>,\n+    nodes: Vec<String>,\n     ast: BTreeMap<String, AstNode>,\n }\n "}]}