{"sha": "82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyZDVlYTRiMTJkODU0M2M2YzhmODcxODgxZmJiZWZiZjVlNjNkYzI=", "commit": {"author": {"name": "Tommy Ip", "email": "hkmp7tommy@gmail.com", "date": "2017-11-06T08:49:47Z"}, "committer": {"name": "Tommy Ip", "email": "hkmp7tommy@gmail.com", "date": "2017-11-06T16:28:30Z"}, "message": "Make format! positional argument errors clear", "tree": {"sha": "e2aab4bc2c39eb7916a5d08517807cf9cd0766a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2aab4bc2c39eb7916a5d08517807cf9cd0766a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2", "html_url": "https://github.com/rust-lang/rust/commit/82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2/comments", "author": {"login": "tommyip", "id": 18504232, "node_id": "MDQ6VXNlcjE4NTA0MjMy", "avatar_url": "https://avatars.githubusercontent.com/u/18504232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tommyip", "html_url": "https://github.com/tommyip", "followers_url": "https://api.github.com/users/tommyip/followers", "following_url": "https://api.github.com/users/tommyip/following{/other_user}", "gists_url": "https://api.github.com/users/tommyip/gists{/gist_id}", "starred_url": "https://api.github.com/users/tommyip/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tommyip/subscriptions", "organizations_url": "https://api.github.com/users/tommyip/orgs", "repos_url": "https://api.github.com/users/tommyip/repos", "events_url": "https://api.github.com/users/tommyip/events{/privacy}", "received_events_url": "https://api.github.com/users/tommyip/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tommyip", "id": 18504232, "node_id": "MDQ6VXNlcjE4NTA0MjMy", "avatar_url": "https://avatars.githubusercontent.com/u/18504232?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tommyip", "html_url": "https://github.com/tommyip", "followers_url": "https://api.github.com/users/tommyip/followers", "following_url": "https://api.github.com/users/tommyip/following{/other_user}", "gists_url": "https://api.github.com/users/tommyip/gists{/gist_id}", "starred_url": "https://api.github.com/users/tommyip/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tommyip/subscriptions", "organizations_url": "https://api.github.com/users/tommyip/orgs", "repos_url": "https://api.github.com/users/tommyip/repos", "events_url": "https://api.github.com/users/tommyip/events{/privacy}", "received_events_url": "https://api.github.com/users/tommyip/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74be072068737ae3ef30be66e34c1569cf652652", "url": "https://api.github.com/repos/rust-lang/rust/commits/74be072068737ae3ef30be66e34c1569cf652652", "html_url": "https://github.com/rust-lang/rust/commit/74be072068737ae3ef30be66e34c1569cf652652"}], "stats": {"total": 49, "additions": 41, "deletions": 8}, "files": [{"sha": "ceefbfc271cc679d6e1ab00ad253f2526c42ae90", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=82d5ea4b12d8543c6c8f871881fbbefbf5e63dc2", "patch": "@@ -110,6 +110,8 @@ struct Context<'a, 'b: 'a> {\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n     curarg: usize,\n+    /// Keep track of invalid references to positional arguments\n+    invalid_refs: Vec<usize>,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -251,23 +253,49 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     fn describe_num_args(&self) -> String {\n         match self.args.len() {\n-            0 => \"no arguments given\".to_string(),\n-            1 => \"there is 1 argument\".to_string(),\n-            x => format!(\"there are {} arguments\", x),\n+            0 => \"no arguments were given\".to_string(),\n+            1 => \"there is only 1 argument\".to_string(),\n+            x => format!(\"there are only {} arguments\", x),\n         }\n     }\n \n+    /// Handle invalid references to positional arguments. Output different\n+    /// errors for the case where all arguments are positional and for when\n+    /// there are named arguments in the format string.\n+    fn report_invalid_references(&self) {\n+        let mut refs: Vec<String> = self.invalid_refs\n+                                        .iter()\n+                                        .map(|r| r.to_string())\n+                                        .collect();\n+\n+        let msg = if self.names.is_empty() {\n+            format!(\"{} positional argument{} in format string, but {}\",\n+                    self.pieces.len(),\n+                    if self.pieces.len() > 1 { \"s\" } else { \"\" },\n+                    self.describe_num_args())\n+        } else {\n+            let arg_list = match refs.len() {\n+                1 => format!(\"argument {}\", refs.pop().unwrap()),\n+                _ => format!(\"arguments {head} and {tail}\",\n+                             tail=refs.pop().unwrap(),\n+                             head=refs.join(\", \"))\n+            };\n+\n+            format!(\"invalid reference to positional {} ({})\",\n+                    arg_list,\n+                    self.describe_num_args())\n+        };\n+\n+        self.ecx.span_err(self.fmtsp, &msg[..]);\n+    }\n+\n     /// Actually verifies and tracks a given format placeholder\n     /// (a.k.a. argument).\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n-                    let msg = format!(\"invalid reference to argument `{}` ({})\",\n-                                      arg,\n-                                      self.describe_num_args());\n-\n-                    self.ecx.span_err(self.fmtsp, &msg[..]);\n+                    self.invalid_refs.push(arg);\n                     return;\n                 }\n                 match ty {\n@@ -691,6 +719,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         all_pieces_simple: true,\n         macsp,\n         fmtsp: fmt.span,\n+        invalid_refs: Vec::new(),\n     };\n \n     let fmt_str = &*fmt.node.0.as_str();\n@@ -736,6 +765,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         cx.str_pieces.push(s);\n     }\n \n+    if cx.invalid_refs.len() >= 1 {\n+        cx.report_invalid_references();\n+    }\n+\n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n     let mut errs = vec![];"}]}