{"sha": "c4a3332d38c6c92394b5f7818f0a963fbcf86052", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YTMzMzJkMzhjNmM5MjM5NGI1Zjc4MThmMGE5NjNmYmNmODYwNTI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-13T22:39:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-13T22:39:43Z"}, "message": "Rollup merge of #59784 - davidtwco:issue-59764, r=estebank\n\nSuggest importing macros from the crate root\n\nFixes #59764.\n\nr? @estebank\ncc @varkor", "tree": {"sha": "2e29a7af3568bf4c17764588714b2e340b8c1ebc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e29a7af3568bf4c17764588714b2e340b8c1ebc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4a3332d38c6c92394b5f7818f0a963fbcf86052", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcsmUvCRBK7hj4Ov3rIwAAdHIIAK8uih3o4Gs2fFgA/aTLD/5l\nFO4OsMePpSkaVmZLHMb1dbHPnaG5r6k6CCvtkcwwLoPLhh0jppzxw0lakU14dFqH\nCV1nKcM6JOPMlmIPrG+nU1pAIAWGhzqXYbOx2P5TdYPvToHPIHmWFr06hNdugDM2\neE8j1VyljOS2vF1Mzcck1V/NYGCioNAtRftPVjzwjQlh3oOtR/bHQQ5Q+AhG4exm\nlh8fXl63dxZAX8wLfMmlogcRf68+Dn8LE52RuitUq/ApyvzlbRIxXNYSgjo0jTc1\n6ivYMuKn6WY62ukp8FHPQWaHKWzOVuyB1kTkE9RCcLbBMn0rRJQg/6efZTOSess=\n=D5By\n-----END PGP SIGNATURE-----\n", "payload": "tree 2e29a7af3568bf4c17764588714b2e340b8c1ebc\nparent ae0bf84a1402115b7af1ad1d327594f17ed2e72c\nparent 5158063c3ec1e1dc8d9b0a0806e29d6c6e54d765\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1555195183 +0200\ncommitter GitHub <noreply@github.com> 1555195183 +0200\n\nRollup merge of #59784 - davidtwco:issue-59764, r=estebank\n\nSuggest importing macros from the crate root\n\nFixes #59764.\n\nr? @estebank\ncc @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a3332d38c6c92394b5f7818f0a963fbcf86052", "html_url": "https://github.com/rust-lang/rust/commit/c4a3332d38c6c92394b5f7818f0a963fbcf86052", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4a3332d38c6c92394b5f7818f0a963fbcf86052/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae0bf84a1402115b7af1ad1d327594f17ed2e72c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae0bf84a1402115b7af1ad1d327594f17ed2e72c", "html_url": "https://github.com/rust-lang/rust/commit/ae0bf84a1402115b7af1ad1d327594f17ed2e72c"}, {"sha": "5158063c3ec1e1dc8d9b0a0806e29d6c6e54d765", "url": "https://api.github.com/repos/rust-lang/rust/commits/5158063c3ec1e1dc8d9b0a0806e29d6c6e54d765", "html_url": "https://github.com/rust-lang/rust/commit/5158063c3ec1e1dc8d9b0a0806e29d6c6e54d765"}], "stats": {"total": 865, "additions": 751, "deletions": 114}, "files": [{"sha": "931bce91d7d43afe158de1308d053b4d0d8a9cd9", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 297, "deletions": 16, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=c4a3332d38c6c92394b5f7818f0a963fbcf86052", "patch": "@@ -4,16 +4,17 @@ use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n use rustc::hir::def::{Def, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::session::config::nightly_options;\n-use syntax::ast::{Expr, ExprKind};\n-use syntax::symbol::keywords;\n-use syntax_pos::Span;\n+use rustc::session::{Session, config::nightly_options};\n+use syntax::ast::{Expr, ExprKind, Ident};\n+use syntax::ext::base::MacroKind;\n+use syntax::symbol::{Symbol, keywords};\n+use syntax_pos::{BytePos, Span};\n \n use crate::macros::ParentScope;\n-use crate::resolve_imports::ImportResolver;\n+use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::{import_candidate_to_enum_paths, is_self_type, is_self_value, path_names_to_string};\n use crate::{AssocSuggestion, CrateLint, ImportSuggestion, ModuleOrUniformRoot, PathResult,\n-            PathSource, Resolver, Segment};\n+            PathSource, Resolver, Segment, Suggestion};\n \n impl<'a> Resolver<'a> {\n     /// Handles error reporting for `smart_resolve_path_fragment` function.\n@@ -428,7 +429,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n \n         match (path.get(0), path.get(1)) {\n@@ -463,13 +464,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfLower.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some((path, None))\n+            Some((path, Vec::new()))\n         } else {\n             None\n         }\n@@ -487,19 +488,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n                 path,\n-                Some(\n+                vec![\n                     \"`use` statements changed in Rust 2018; read more at \\\n                      <https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-\\\n                      clarity.html>\".to_string()\n-                ),\n+                ],\n             ))\n         } else {\n             None\n@@ -518,13 +519,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n         let result = self.resolve_path(&path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n-            Some((path, None))\n+            Some((path, Vec::new()))\n         } else {\n             None\n         }\n@@ -545,7 +546,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n-    ) -> Option<(Vec<Segment>, Option<String>)> {\n+    ) -> Option<(Vec<Segment>, Vec<String>)> {\n         if path[1].ident.span.rust_2015() {\n             return None;\n         }\n@@ -564,10 +565,290 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {\n-                return Some((path, None));\n+                return Some((path, Vec::new()));\n             }\n         }\n \n         None\n     }\n+\n+    /// Suggests importing a macro from the root of the crate rather than a module within\n+    /// the crate.\n+    ///\n+    /// ```\n+    /// help: a macro with this name exists at the root of the crate\n+    ///    |\n+    /// LL | use issue_59764::makro;\n+    ///    |     ^^^^^^^^^^^^^^^^^^\n+    ///    |\n+    ///    = note: this could be because a macro annotated with `#[macro_export]` will be exported\n+    ///            at the root of the crate instead of the module where it is defined\n+    /// ```\n+    pub(crate) fn check_for_module_export_macro(\n+        &self,\n+        directive: &'b ImportDirective<'b>,\n+        module: ModuleOrUniformRoot<'b>,\n+        ident: Ident,\n+    ) -> Option<(Option<Suggestion>, Vec<String>)> {\n+        let mut crate_module = if let ModuleOrUniformRoot::Module(module) = module {\n+            module\n+        } else {\n+            return None;\n+        };\n+\n+        while let Some(parent) = crate_module.parent {\n+            crate_module = parent;\n+        }\n+\n+        if ModuleOrUniformRoot::same_def(ModuleOrUniformRoot::Module(crate_module), module) {\n+            // Don't make a suggestion if the import was already from the root of the\n+            // crate.\n+            return None;\n+        }\n+\n+        let resolutions = crate_module.resolutions.borrow();\n+        let resolution = resolutions.get(&(ident, MacroNS))?;\n+        let binding = resolution.borrow().binding()?;\n+        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n+            let module_name = crate_module.kind.name().unwrap();\n+            let import = match directive.subclass {\n+                ImportDirectiveSubclass::SingleImport { source, target, .. } if source != target =>\n+                    format!(\"{} as {}\", source, target),\n+                _ => format!(\"{}\", ident),\n+            };\n+\n+            let mut corrections: Vec<(Span, String)> = Vec::new();\n+            if !directive.is_nested() {\n+                // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n+                // intermediate segments.\n+                corrections.push((directive.span, format!(\"{}::{}\", module_name, import)));\n+            } else {\n+                // Find the binding span (and any trailing commas and spaces).\n+                //   ie. `use a::b::{c, d, e};`\n+                //                      ^^^\n+                let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n+                    self.resolver.session, directive.span, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n+                       found_closing_brace, binding_span);\n+\n+                let mut removal_span = binding_span;\n+                if found_closing_brace {\n+                    // If the binding span ended with a closing brace, as in the below example:\n+                    //   ie. `use a::b::{c, d};`\n+                    //                      ^\n+                    // Then expand the span of characters to remove to include the previous\n+                    // binding's trailing comma.\n+                    //   ie. `use a::b::{c, d};`\n+                    //                    ^^^\n+                    if let Some(previous_span) = extend_span_to_previous_binding(\n+                        self.resolver.session, binding_span,\n+                    ) {\n+                        debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n+                        removal_span = removal_span.with_lo(previous_span.lo());\n+                    }\n+                }\n+                debug!(\"check_for_module_export_macro: removal_span={:?}\", removal_span);\n+\n+                // Remove the `removal_span`.\n+                corrections.push((removal_span, \"\".to_string()));\n+\n+                // Find the span after the crate name and if it has nested imports immediatately\n+                // after the crate name already.\n+                //   ie. `use a::b::{c, d};`\n+                //               ^^^^^^^^^\n+                //   or  `use a::{b, c, d}};`\n+                //               ^^^^^^^^^^^\n+                let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n+                    self.resolver.session, module_name, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n+                       has_nested, after_crate_name);\n+\n+                let source_map = self.resolver.session.source_map();\n+\n+                // Add the import to the start, with a `{` if required.\n+                let start_point = source_map.start_point(after_crate_name);\n+                if let Ok(start_snippet) = source_map.span_to_snippet(start_point) {\n+                    corrections.push((\n+                        start_point,\n+                        if has_nested {\n+                            // In this case, `start_snippet` must equal '{'.\n+                            format!(\"{}{}, \", start_snippet, import)\n+                        } else {\n+                            // In this case, add a `{`, then the moved import, then whatever\n+                            // was there before.\n+                            format!(\"{{{}, {}\", import, start_snippet)\n+                        }\n+                    ));\n+                }\n+\n+                // Add a `};` to the end if nested, matching the `{` added at the start.\n+                if !has_nested {\n+                    corrections.push((source_map.end_point(after_crate_name),\n+                                     \"};\".to_string()));\n+                }\n+            }\n+\n+            let suggestion = Some((\n+                corrections,\n+                String::from(\"a macro with this name exists at the root of the crate\"),\n+                Applicability::MaybeIncorrect,\n+            ));\n+            let note = vec![\n+                \"this could be because a macro annotated with `#[macro_export]` will be exported \\\n+                 at the root of the crate instead of the module where it is defined\".to_string(),\n+            ];\n+            Some((suggestion, note))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Given a `binding_span` of a binding within a use statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^\n+/// ```\n+///\n+/// then return the span until the next binding or the end of the statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^^^\n+/// ```\n+pub(crate) fn find_span_of_binding_until_next_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    let source_map = sess.source_map();\n+\n+    // Find the span of everything after the binding.\n+    //   ie. `a, e};` or `a};`\n+    let binding_until_end = binding_span.with_hi(use_span.hi());\n+\n+    // Find everything after the binding but not including the binding.\n+    //   ie. `, e};` or `};`\n+    let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n+\n+    // Keep characters in the span until we encounter something that isn't a comma or\n+    // whitespace.\n+    //   ie. `, ` or ``.\n+    //\n+    // Also note whether a closing brace character was encountered. If there\n+    // was, then later go backwards to remove any trailing commas that are left.\n+    let mut found_closing_brace = false;\n+    let after_binding_until_next_binding = source_map.span_take_while(\n+        after_binding_until_end,\n+        |&ch| {\n+            if ch == '}' { found_closing_brace = true; }\n+            ch == ' ' || ch == ','\n+        }\n+    );\n+\n+    // Combine the two spans.\n+    //   ie. `a, ` or `a`.\n+    //\n+    // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n+    let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n+\n+    (found_closing_brace, span)\n+}\n+\n+/// Given a `binding_span`, return the span through to the comma or opening brace of the previous\n+/// binding.\n+///\n+/// ```\n+/// use foo::a::{a, b, c};\n+///               ^^--- binding span\n+///               |\n+///               returned span\n+///\n+/// use foo::{a, b, c};\n+///           --- binding span\n+/// ```\n+pub(crate) fn extend_span_to_previous_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+) -> Option<Span> {\n+    let source_map = sess.source_map();\n+\n+    // `prev_source` will contain all of the source that came before the span.\n+    // Then split based on a command and take the first (ie. closest to our span)\n+    // snippet. In the example, this is a space.\n+    let prev_source = source_map.span_to_prev_source(binding_span).ok()?;\n+\n+    let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n+    let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n+    if prev_comma.len() <= 1 || prev_starting_brace.len() <= 1 {\n+        return None;\n+    }\n+\n+    let prev_comma = prev_comma.first().unwrap();\n+    let prev_starting_brace = prev_starting_brace.first().unwrap();\n+\n+    // If the amount of source code before the comma is greater than\n+    // the amount of source code before the starting brace then we've only\n+    // got one item in the nested item (eg. `issue_52891::{self}`).\n+    if prev_comma.len() > prev_starting_brace.len() {\n+        return None;\n+    }\n+\n+    Some(binding_span.with_lo(BytePos(\n+        // Take away the number of bytes for the characters we've found and an\n+        // extra for the comma.\n+        binding_span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n+    )))\n+}\n+\n+/// Given a `use_span` of a binding within a use statement, returns the highlighted span and if\n+/// it is a nested use tree.\n+///\n+/// ```\n+/// use foo::a::{b, c};\n+///          ^^^^^^^^^^ // false\n+///\n+/// use foo::{a, b, c};\n+///          ^^^^^^^^^^ // true\n+///\n+/// use foo::{a, b::{c, d}};\n+///          ^^^^^^^^^^^^^^^ // true\n+/// ```\n+fn find_span_immediately_after_crate_name(\n+    sess: &Session,\n+    module_name: Symbol,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    debug!(\"find_span_immediately_after_crate_name: module_name={:?} use_span={:?}\",\n+           module_name, use_span);\n+    let source_map = sess.source_map();\n+\n+    // Using `use issue_59764::foo::{baz, makro};` as an example throughout..\n+    let mut num_colons = 0;\n+    // Find second colon.. `use issue_59764:`\n+    let until_second_colon = source_map.span_take_while(use_span, |c| {\n+        if *c == ':' { num_colons += 1; }\n+        match c {\n+            ':' if num_colons == 2 => false,\n+            _ => true,\n+        }\n+    });\n+    // Find everything after the second colon.. `foo::{baz, makro};`\n+    let from_second_colon = use_span.with_lo(until_second_colon.hi() + BytePos(1));\n+\n+    let mut found_a_non_whitespace_character = false;\n+    // Find the first non-whitespace character in `from_second_colon`.. `f`\n+    let after_second_colon = source_map.span_take_while(from_second_colon, |c| {\n+        if found_a_non_whitespace_character { return false; }\n+        if !c.is_whitespace() { found_a_non_whitespace_character = true; }\n+        true\n+    });\n+\n+    // Find the first `{` in from_second_colon.. `foo::{`\n+    let next_left_bracket = source_map.span_through_char(from_second_colon, '{');\n+\n+    (next_left_bracket == after_second_colon, from_second_colon)\n }"}, {"sha": "b34786d8f129a0a0cab872a0d2bcda80969410a6", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 29, "deletions": 69, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c4a3332d38c6c92394b5f7818f0a963fbcf86052", "patch": "@@ -50,7 +50,7 @@ use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::ptr::P;\n use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n-use syntax_pos::{BytePos, Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use log::debug;\n@@ -62,6 +62,7 @@ use std::mem::replace;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n \n+use error_reporting::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n \n@@ -138,8 +139,8 @@ impl Ord for BindingError {\n     }\n }\n \n-/// A span, message, replacement text, and applicability.\n-type Suggestion = (Span, String, String, Applicability);\n+/// A vector of spans and replacements, a message and applicability.\n+type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n enum ResolutionError<'a> {\n     /// Error E0401: can't use type or const parameters from outer function.\n@@ -389,8 +390,8 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                                            \"failed to resolve: {}\", &label);\n             err.span_label(span, label);\n \n-            if let Some((span, msg, suggestion, applicability)) = suggestion {\n-                err.span_suggestion(span, &msg, suggestion, applicability);\n+            if let Some((suggestions, msg, applicability)) = suggestion {\n+                err.multipart_suggestion(&msg, suggestions, applicability);\n             }\n \n             err\n@@ -1091,6 +1092,16 @@ enum ModuleKind {\n     Def(Def, Name),\n }\n \n+impl ModuleKind {\n+    /// Get name of the module.\n+    pub fn name(&self) -> Option<Name> {\n+        match self {\n+            ModuleKind::Block(..) => None,\n+            ModuleKind::Def(_, name) => Some(*name),\n+        }\n+    }\n+}\n+\n /// One node in the tree of modules.\n pub struct ModuleData<'a> {\n     parent: Option<Module<'a>>,\n@@ -3770,9 +3781,8 @@ impl<'a> Resolver<'a> {\n                             (\n                                 String::from(\"unresolved import\"),\n                                 Some((\n-                                    ident.span,\n+                                    vec![(ident.span, candidate.path.to_string())],\n                                     String::from(\"a similar path exists\"),\n-                                    candidate.path.to_string(),\n                                     Applicability::MaybeIncorrect,\n                                 )),\n                             )\n@@ -5141,7 +5151,6 @@ impl<'a> Resolver<'a> {\n     ) {\n         assert!(directive.is_nested());\n         let message = \"remove unnecessary import\";\n-        let source_map = self.session.source_map();\n \n         // Two examples will be used to illustrate the span manipulations we're doing:\n         //\n@@ -5150,73 +5159,24 @@ impl<'a> Resolver<'a> {\n         // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n         //   `a` and `directive.use_span` is `issue_52891::{d, e, a};`.\n \n-        // Find the span of everything after the binding.\n-        //   ie. `a, e};` or `a};`\n-        let binding_until_end = binding_span.with_hi(directive.use_span.hi());\n-\n-        // Find everything after the binding but not including the binding.\n-        //   ie. `, e};` or `};`\n-        let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n-\n-        // Keep characters in the span until we encounter something that isn't a comma or\n-        // whitespace.\n-        //   ie. `, ` or ``.\n-        //\n-        // Also note whether a closing brace character was encountered. If there\n-        // was, then later go backwards to remove any trailing commas that are left.\n-        let mut found_closing_brace = false;\n-        let after_binding_until_next_binding = source_map.span_take_while(\n-            after_binding_until_end,\n-            |&ch| {\n-                if ch == '}' { found_closing_brace = true; }\n-                ch == ' ' || ch == ','\n-            }\n+        let (found_closing_brace, span) = find_span_of_binding_until_next_binding(\n+            self.session, binding_span, directive.use_span,\n         );\n \n-        // Combine the two spans.\n-        //   ie. `a, ` or `a`.\n-        //\n-        // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n-        let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n-\n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n         if found_closing_brace {\n-            if let Ok(prev_source) = source_map.span_to_prev_source(span) {\n-                // `prev_source` will contain all of the source that came before the span.\n-                // Then split based on a command and take the first (ie. closest to our span)\n-                // snippet. In the example, this is a space.\n-                let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n-                let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n-                if prev_comma.len() > 1 && prev_starting_brace.len() > 1 {\n-                    let prev_comma = prev_comma.first().unwrap();\n-                    let prev_starting_brace = prev_starting_brace.first().unwrap();\n-\n-                    // If the amount of source code before the comma is greater than\n-                    // the amount of source code before the starting brace then we've only\n-                    // got one item in the nested item (eg. `issue_52891::{self}`).\n-                    if prev_comma.len() > prev_starting_brace.len() {\n-                        // So just remove the entire line...\n-                        err.span_suggestion(\n-                            directive.use_span_with_attributes,\n-                            message,\n-                            String::new(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return;\n-                    }\n-\n-                    let span = span.with_lo(BytePos(\n-                        // Take away the number of bytes for the characters we've found and an\n-                        // extra for the comma.\n-                        span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n-                    ));\n-                    err.tool_only_span_suggestion(\n-                        span, message, String::new(), Applicability::MaybeIncorrect,\n-                    );\n-                    return;\n-                }\n+            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+                err.tool_only_span_suggestion(span, message, String::new(),\n+                                              Applicability::MaybeIncorrect);\n+            } else {\n+                // Remove the entire line if we cannot extend the span back, this indicates a\n+                // `issue_52891::{self}` case.\n+                err.span_suggestion(directive.use_span_with_attributes, message, String::new(),\n+                                    Applicability::MaybeIncorrect);\n             }\n+\n+            return;\n         }\n \n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);"}, {"sha": "62af6e19603c4beeb29a184c5705ab8783857c54", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c4a3332d38c6c92394b5f7818f0a963fbcf86052", "patch": "@@ -145,7 +145,7 @@ pub struct NameResolution<'a> {\n \n impl<'a> NameResolution<'a> {\n     // Returns the binding for the name if it is known or None if it not known.\n-    fn binding(&self) -> Option<&'a NameBinding<'a>> {\n+    pub(crate) fn binding(&self) -> Option<&'a NameBinding<'a>> {\n         self.binding.and_then(|binding| {\n             if !binding.is_glob_import() ||\n                self.single_imports.is_empty() { Some(binding) } else { None }\n@@ -636,7 +636,7 @@ impl<'a> Resolver<'a> {\n struct UnresolvedImportError {\n     span: Span,\n     label: Option<String>,\n-    note: Option<String>,\n+    note: Vec<String>,\n     suggestion: Option<Suggestion>,\n }\n \n@@ -756,8 +756,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         /// Upper limit on the number of `span_label` messages.\n         const MAX_LABEL_COUNT: usize = 10;\n \n-        let (span, msg, note) = if errors.is_empty() {\n-            (span.unwrap(), \"unresolved import\".to_string(), None)\n+        let (span, msg) = if errors.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string())\n         } else {\n             let span = MultiSpan::from_spans(\n                 errors\n@@ -766,11 +766,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     .collect(),\n             );\n \n-            let note = errors\n-                .iter()\n-                .filter_map(|(_, err)| err.note.as_ref())\n-                .last();\n-\n             let paths = errors\n                 .iter()\n                 .map(|(path, _)| format!(\"`{}`\", path))\n@@ -782,22 +777,24 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 paths.join(\", \"),\n             );\n \n-            (span, msg, note)\n+            (span, msg)\n         };\n \n         let mut diag = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n \n-        if let Some(note) = &note {\n-            diag.note(note);\n+        if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n+            for message in note {\n+                diag.note(&message);\n+            }\n         }\n \n         for (_, err) in errors.into_iter().take(MAX_LABEL_COUNT) {\n             if let Some(label) = err.label {\n                 diag.span_label(err.span, label);\n             }\n \n-            if let Some((span, msg, suggestion, applicability)) = err.suggestion {\n-                diag.span_suggestion(span, &msg, suggestion, applicability);\n+            if let Some((suggestions, msg, applicability)) = err.suggestion {\n+                diag.multipart_suggestion(&msg, suggestions, applicability);\n             }\n         }\n \n@@ -950,9 +947,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                 label: None,\n                                 note,\n                                 suggestion: Some((\n-                                    span,\n+                                    vec![(span, Segment::names_to_string(&suggestion))],\n                                     String::from(\"a similar path exists\"),\n-                                    Segment::names_to_string(&suggestion),\n                                     Applicability::MaybeIncorrect,\n                                 )),\n                             }\n@@ -961,7 +957,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                             UnresolvedImportError {\n                                 span,\n                                 label: Some(label),\n-                                note: None,\n+                                note: Vec::new(),\n                                 suggestion,\n                             }\n                         }\n@@ -1006,7 +1002,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         return Some(UnresolvedImportError {\n                             span: directive.span,\n                             label: Some(String::from(\"cannot glob-import a module into itself\")),\n-                            note: None,\n+                            note: Vec::new(),\n                             suggestion: None,\n                         });\n                     }\n@@ -1114,15 +1110,19 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     }\n                 });\n \n-                let lev_suggestion =\n-                    find_best_match_for_name(names, &ident.as_str(), None).map(|suggestion| {\n-                        (\n-                            ident.span,\n-                            String::from(\"a similar name exists in the module\"),\n-                            suggestion.to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                    });\n+                let lev_suggestion = find_best_match_for_name(names, &ident.as_str(), None)\n+                   .map(|suggestion|\n+                        (vec![(ident.span, suggestion.to_string())],\n+                         String::from(\"a similar name exists in the module\"),\n+                         Applicability::MaybeIncorrect)\n+                    );\n+\n+                let (suggestion, note) = match self.check_for_module_export_macro(\n+                    directive, module, ident,\n+                ) {\n+                    Some((suggestion, note)) => (suggestion.or(lev_suggestion), note),\n+                    _ => (lev_suggestion, Vec::new()),\n+                };\n \n                 let label = match module {\n                     ModuleOrUniformRoot::Module(module) => {\n@@ -1143,11 +1143,12 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                         }\n                     }\n                 };\n+\n                 Some(UnresolvedImportError {\n                     span: directive.span,\n                     label: Some(label),\n-                    note: None,\n-                    suggestion: lev_suggestion,\n+                    note,\n+                    suggestion,\n                 })\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error."}, {"sha": "a92eed968d0607b7a1e1e0f81f0e43cc3e2ec79f", "filename": "src/test/ui/auxiliary/issue-59764.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs?ref=c4a3332d38c6c92394b5f7818f0a963fbcf86052", "patch": "@@ -0,0 +1,18 @@\n+pub mod foo {\n+    #[macro_export]\n+    macro_rules! makro {\n+        ($foo:ident) => {\n+            fn $foo() { }\n+        }\n+    }\n+\n+    pub fn baz() {}\n+\n+    pub fn foobar() {}\n+\n+    pub mod barbaz {\n+        pub fn barfoo() {}\n+    }\n+}\n+\n+pub fn foobaz() {}"}, {"sha": "09dee8c2732681e4f2298b3a1a51b58872c5ee9d", "filename": "src/test/ui/issue-59764.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Ftest%2Fui%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Ftest%2Fui%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.rs?ref=c4a3332d38c6c92394b5f7818f0a963fbcf86052", "patch": "@@ -0,0 +1,136 @@\n+// aux-build:issue-59764.rs\n+// compile-flags:--extern issue_59764\n+// edition:2018\n+\n+#![allow(warnings)]\n+\n+// This tests the suggestion to import macros from the root of a crate. This aims to capture\n+// the case where a user attempts to import a macro from the definition location instead of the\n+// root of the crate and the macro is annotated with `#![macro_export]`.\n+\n+// Edge cases..\n+\n+mod multiple_imports_same_line_at_end {\n+    use issue_59764::foo::{baz, makro};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_at_end_trailing_comma {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    };\n+}\n+\n+mod multiple_imports_multiline_at_end {\n+    use issue_59764::foo::{\n+        baz,\n+        makro //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    };\n+}\n+\n+mod multiple_imports_same_line_in_middle {\n+    use issue_59764::foo::{baz, makro, foobar};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_in_middle_trailing_comma {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar,\n+    };\n+}\n+\n+mod multiple_imports_multiline_in_middle {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar\n+    };\n+}\n+\n+mod nested_imports {\n+    use issue_59764::{foobaz, foo::makro};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiple_imports {\n+    use issue_59764::{foobaz, foo::{baz, makro}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiline_multiple_imports_trailing_comma {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        },\n+    };\n+}\n+\n+mod nested_multiline_multiple_imports {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        }\n+    };\n+}\n+\n+mod doubly_nested_multiple_imports {\n+    use issue_59764::{foobaz, foo::{baz, makro, barbaz::{barfoo}}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod doubly_multiline_nested_multiple_imports {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+            barbaz::{\n+                barfoo,\n+            }\n+        }\n+    };\n+}\n+\n+mod renamed_import {\n+    use issue_59764::foo::makro as baz;\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod renamed_multiple_imports {\n+    use issue_59764::foo::{baz, makro as foobar};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod lots_of_whitespace {\n+    use\n+        issue_59764::{\n+\n+            foobaz,\n+\n+\n+            foo::{baz,\n+\n+                makro as foobar} //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+\n+        };\n+}\n+\n+// Simple case..\n+\n+use issue_59764::foo::makro;\n+//~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+\n+makro!(bar);\n+//~^ ERROR cannot determine resolution for the macro `makro`\n+\n+fn main() {\n+    bar();\n+    //~^ ERROR cannot find function `bar` in this scope [E0425]\n+}"}, {"sha": "924e69f5f97033fb32a1d9368e62ff71b5cc98ff", "filename": "src/test/ui/issue-59764.stderr", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Ftest%2Fui%2Fissue-59764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c4a3332d38c6c92394b5f7818f0a963fbcf86052/src%2Ftest%2Fui%2Fissue-59764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.stderr?ref=c4a3332d38c6c92394b5f7818f0a963fbcf86052", "patch": "@@ -0,0 +1,241 @@\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:14:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro};\n+   |                                 ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{baz}};\n+   |                      ^^^^^^^^^       --^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:21:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:28:9\n+   |\n+LL |         makro\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:33:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro, foobar};\n+   |                                 ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{baz, foobar}};\n+   |                      ^^^^^^^^^         --      ^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:40:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |         foobar,\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:48:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |         foobar\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:54:31\n+   |\n+LL |     use issue_59764::{foobaz, foo::makro};\n+   |                               ^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz};\n+   |                      ^^^^^^^      --\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:59:42\n+   |\n+LL |     use issue_59764::{foobaz, foo::{baz, makro}};\n+   |                                          ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz, foo::{baz}};\n+   |                      ^^^^^^^                 --\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:68:13\n+   |\n+LL |             makro,\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:78:13\n+   |\n+LL |             makro\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:84:42\n+   |\n+LL |     use issue_59764::{foobaz, foo::{baz, makro, barbaz::{barfoo}}};\n+   |                                          ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz, foo::{baz, barbaz::{barfoo}}};\n+   |                      ^^^^^^^                   --\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:93:13\n+   |\n+LL |             makro,\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:102:9\n+   |\n+LL |     use issue_59764::foo::makro as baz;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::makro as baz;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:107:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro as foobar};\n+   |                                 ^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro as foobar, foo::{baz}};\n+   |                      ^^^^^^^^^^^^^^^^^^^       --^^\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:120:17\n+   |\n+LL |                 makro as foobar}\n+   |                 ^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |         issue_59764::{makro as foobar, \n+LL | \n+LL |             foobaz,\n+LL | \n+LL | \n+LL |             foo::{baz}\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:127:5\n+   |\n+LL | use issue_59764::foo::makro;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL | use issue_59764::makro;\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: cannot determine resolution for the macro `makro`\n+  --> $DIR/issue-59764.rs:130:1\n+   |\n+LL | makro!(bar);\n+   | ^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error[E0425]: cannot find function `bar` in this scope\n+  --> $DIR/issue-59764.rs:134:5\n+   |\n+LL |     bar();\n+   |     ^^^ not found in this scope\n+\n+error: aborting due to 18 previous errors\n+\n+Some errors occurred: E0425, E0432.\n+For more information about an error, try `rustc --explain E0425`."}]}