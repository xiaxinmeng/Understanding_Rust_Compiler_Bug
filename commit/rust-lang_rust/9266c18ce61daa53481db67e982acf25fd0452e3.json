{"sha": "9266c18ce61daa53481db67e982acf25fd0452e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNjZjMThjZTYxZGFhNTM0ODFkYjY3ZTk4MmFjZjI1ZmQwNDUyZTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-05T14:45:57Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-15T12:24:02Z"}, "message": "switch from volatile to untracked read", "tree": {"sha": "823d8fc808a80ef5305de028f46d7068d6e04f7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/823d8fc808a80ef5305de028f46d7068d6e04f7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9266c18ce61daa53481db67e982acf25fd0452e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9266c18ce61daa53481db67e982acf25fd0452e3", "html_url": "https://github.com/rust-lang/rust/commit/9266c18ce61daa53481db67e982acf25fd0452e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9266c18ce61daa53481db67e982acf25fd0452e3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ed6a13a2c81f24bd12cc74332f7e94301c73980", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ed6a13a2c81f24bd12cc74332f7e94301c73980", "html_url": "https://github.com/rust-lang/rust/commit/5ed6a13a2c81f24bd12cc74332f7e94301c73980"}], "stats": {"total": 63, "additions": 41, "deletions": 22}, "files": [{"sha": "7b7974f5bbef3cbfa124f00fa0b3f3a5b35f5de9", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9266c18ce61daa53481db67e982acf25fd0452e3/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266c18ce61daa53481db67e982acf25fd0452e3/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=9266c18ce61daa53481db67e982acf25fd0452e3", "patch": "@@ -1,6 +1,5 @@\n use std::sync::Arc;\n \n-use parking_lot::Mutex;\n use ra_db::{salsa, SourceDatabase};\n use ra_syntax::{ast, Parse, SmolStr, SyntaxNode};\n \n@@ -147,6 +146,7 @@ pub trait DefDatabase: InternDatabase {\n }\n \n #[salsa::query_group(HirDatabaseStorage)]\n+#[salsa::requires(salsa::Database)]\n pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(ExprScopes::expr_scopes_query)]\n     fn expr_scopes(&self, def: DefWithBody) -> Arc<ExprScopes>;\n@@ -187,11 +187,10 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     /// This provides the Chalk trait solver instance. Because Chalk always\n     /// works from a specific crate, this query is keyed on the crate; and\n     /// because Chalk does its own internal caching, the solver is wrapped in a\n-    /// Mutex and the query is marked volatile, to make sure the cached state is\n-    /// thrown away when input facts change.\n+    /// Mutex and the query does an untracked read internally, to make sure the\n+    /// cached state is thrown away when input facts change.\n     #[salsa::invoke(crate::ty::traits::trait_solver_query)]\n-    #[salsa::volatile]\n-    fn trait_solver(&self, krate: Crate) -> Arc<Mutex<crate::ty::traits::Solver>>;\n+    fn trait_solver(&self, krate: Crate) -> crate::ty::traits::TraitSolver;\n \n     #[salsa::invoke(crate::ty::traits::chalk::associated_ty_data_query)]\n     fn associated_ty_data(&self, id: chalk_ir::TypeId) -> Arc<chalk_rust_ir::AssociatedTyDatum>;"}, {"sha": "5406fb4a63a46ee0abc194f241f39a1b006b06b6", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9266c18ce61daa53481db67e982acf25fd0452e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266c18ce61daa53481db67e982acf25fd0452e3/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=9266c18ce61daa53481db67e982acf25fd0452e3", "patch": "@@ -4,6 +4,7 @@ use std::sync::Arc;\n use chalk_ir::cast::Cast;\n use log::debug;\n use parking_lot::Mutex;\n+use ra_db::salsa;\n use ra_prof::profile;\n use rustc_hash::FxHashSet;\n \n@@ -14,7 +15,34 @@ use self::chalk::{from_chalk, ToChalk};\n \n pub(crate) mod chalk;\n \n-pub(crate) type Solver = chalk_solve::Solver;\n+#[derive(Debug, Clone)]\n+pub struct TraitSolver {\n+    krate: Crate,\n+    inner: Arc<Mutex<chalk_solve::Solver>>,\n+}\n+\n+/// We need eq for salsa\n+impl PartialEq for TraitSolver {\n+    fn eq(&self, other: &TraitSolver) -> bool {\n+        Arc::ptr_eq(&self.inner, &other.inner)\n+    }\n+}\n+\n+impl Eq for TraitSolver {}\n+\n+impl TraitSolver {\n+    fn solve(\n+        &self,\n+        db: &impl HirDatabase,\n+        goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal>>,\n+    ) -> Option<chalk_solve::Solution> {\n+        let context = ChalkContext { db, krate: self.krate };\n+        debug!(\"solve goal: {:?}\", goal);\n+        let solution = self.inner.lock().solve_with_fuel(&context, goal, Some(1000));\n+        debug!(\"solve({:?}) => {:?}\", goal, solution);\n+        solution\n+    }\n+}\n \n /// This controls the maximum size of types Chalk considers. If we set this too\n /// high, we can run into slow edge cases; if we set it too low, Chalk won't\n@@ -27,11 +55,15 @@ struct ChalkContext<'a, DB> {\n     krate: Crate,\n }\n \n-pub(crate) fn trait_solver_query(_db: &impl HirDatabase, _krate: Crate) -> Arc<Mutex<Solver>> {\n+pub(crate) fn trait_solver_query(\n+    db: &(impl HirDatabase + salsa::Database),\n+    krate: Crate,\n+) -> TraitSolver {\n+    db.salsa_runtime().report_untracked_read();\n     // krate parameter is just so we cache a unique solver per crate\n     let solver_choice = chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE };\n-    debug!(\"Creating new solver for crate {:?}\", _krate);\n-    Arc::new(Mutex::new(solver_choice.into_solver()))\n+    debug!(\"Creating new solver for crate {:?}\", krate);\n+    TraitSolver { krate, inner: Arc::new(Mutex::new(solver_choice.into_solver())) }\n }\n \n /// Collects impls for the given trait in the whole dependency tree of `krate`.\n@@ -54,18 +86,6 @@ pub(crate) fn impls_for_trait_query(\n     impls.into_iter().collect::<Vec<_>>().into()\n }\n \n-fn solve(\n-    db: &impl HirDatabase,\n-    krate: Crate,\n-    goal: &chalk_ir::UCanonical<chalk_ir::InEnvironment<chalk_ir::Goal>>,\n-) -> Option<chalk_solve::Solution> {\n-    let context = ChalkContext { db, krate };\n-    let solver = db.trait_solver(krate);\n-    let solution = solver.lock().solve(&context, goal);\n-    debug!(\"solve({:?}) => {:?}\", goal, solution);\n-    solution\n-}\n-\n /// A set of clauses that we assume to be true. E.g. if we are inside this function:\n /// ```rust\n /// fn foo<T: Default>(t: T) {}\n@@ -127,7 +147,7 @@ pub(crate) fn trait_solve_query(\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n-    let solution = solve(db, krate, &u_canonical);\n+    let solution = db.trait_solver(krate).solve(db, &u_canonical);\n     solution.map(|solution| solution_from_chalk(db, solution))\n }\n "}]}