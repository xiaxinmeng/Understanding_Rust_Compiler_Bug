{"sha": "a66f359d91d2baf2d4224832456b1f9fa7ed0740", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NmYzNTlkOTFkMmJhZjJkNDIyNDgzMjQ1NmIxZjlmYTdlZDA3NDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-26T05:38:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:41:38Z"}, "message": "support TLS destructors", "tree": {"sha": "325034142b8dc61ba517bd791221423951de656b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/325034142b8dc61ba517bd791221423951de656b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a66f359d91d2baf2d4224832456b1f9fa7ed0740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a66f359d91d2baf2d4224832456b1f9fa7ed0740", "html_url": "https://github.com/rust-lang/rust/commit/a66f359d91d2baf2d4224832456b1f9fa7ed0740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a66f359d91d2baf2d4224832456b1f9fa7ed0740/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "238211e1b3a2412f2c36b043071663a17a8c3501", "url": "https://api.github.com/repos/rust-lang/rust/commits/238211e1b3a2412f2c36b043071663a17a8c3501", "html_url": "https://github.com/rust-lang/rust/commit/238211e1b3a2412f2c36b043071663a17a8c3501"}], "stats": {"total": 106, "additions": 84, "deletions": 22}, "files": [{"sha": "7b6542bff93456372441ca72657a0736514f9efa", "filename": "src/error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=a66f359d91d2baf2d4224832456b1f9fa7ed0740", "patch": "@@ -40,6 +40,7 @@ pub enum EvalError<'tcx> {\n     StackFrameLimitReached,\n     OutOfTls,\n     TlsOutOfBounds,\n+    AbiViolation(String),\n     AlignmentCheckFailed {\n         required: u64,\n         has: u64,\n@@ -107,6 +108,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"reached the maximum number of representable TLS keys\",\n             EvalError::TlsOutOfBounds =>\n                 \"accessed an invalid (unallocated) TLS key\",\n+            EvalError::AbiViolation(ref msg) => msg,\n             EvalError::AlignmentCheckFailed{..} =>\n                 \"tried to execute a misaligned read or write\",\n             EvalError::CalledClosureAsFunction =>"}, {"sha": "0280ad4c379bc97e48c7c2b082013d61738fd113", "filename": "src/memory.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=a66f359d91d2baf2d4224832456b1f9fa7ed0740", "patch": "@@ -15,8 +15,6 @@ use value::PrimVal;\n #[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n pub struct AllocId(pub u64);\n \n-pub type TlsKey = usize;\n-\n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.0)\n@@ -100,6 +98,19 @@ impl Pointer {\n     pub fn never_ptr() -> Self {\n         Pointer::new(NEVER_ALLOC_ID, 0)\n     }\n+    \n+    pub fn is_null_ptr(&self) -> bool {\n+        // FIXME: Is this the right way?\n+        return *self == Pointer::from_int(0)\n+    }\n+}\n+\n+pub type TlsKey = usize;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct TlsEntry<'tcx> {\n+    data: Pointer, // will eventually become a map from thread IDs to pointers\n+    dtor: Option<ty::Instance<'tcx>>,\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -153,7 +164,7 @@ pub struct Memory<'a, 'tcx> {\n     literal_alloc_cache: HashMap<Vec<u8>, AllocId>,\n     \n     /// pthreads-style Thread-local storage.  We only have one thread, so this is just a map from TLS keys (indices into the vector) to the pointer stored there.\n-    thread_local: HashMap<TlsKey, Pointer>,\n+    thread_local: HashMap<TlsKey, TlsEntry<'tcx>>,\n \n     /// The Key to use for the next thread-local allocation.\n     next_thread_local: TlsKey,\n@@ -356,11 +367,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.packed.clear();\n     }\n \n-    pub(crate) fn create_tls_key(&mut self) -> TlsKey {\n+    pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n-        self.thread_local.insert(new_key, Pointer::from_int(0));\n-        trace!(\"New TLS key allocated: {}\", new_key);\n+        self.thread_local.insert(new_key, TlsEntry { data: Pointer::from_int(0), dtor });\n+        trace!(\"New TLS key allocated: {} with dtor {:?}\", new_key, dtor);\n         return new_key;\n     }\n \n@@ -376,24 +387,38 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub(crate) fn load_tls(&mut self, key: TlsKey) -> EvalResult<'tcx, Pointer> {\n         return match self.thread_local.get(&key) {\n-            Some(&ptr) => {\n-                trace!(\"TLS key {} loaded: {:?}\", key, ptr);\n-                Ok(ptr)\n+            Some(&TlsEntry { data, .. }) => {\n+                trace!(\"TLS key {} loaded: {:?}\", key, data);\n+                Ok(data)\n             },\n             None => Err(EvalError::TlsOutOfBounds)\n         }\n     }\n \n-    pub(crate) fn store_tls(&mut self, key: TlsKey, new_ptr: Pointer) -> EvalResult<'tcx> {\n+    pub(crate) fn store_tls(&mut self, key: TlsKey, new_data: Pointer) -> EvalResult<'tcx> {\n         return match self.thread_local.get_mut(&key) {\n-            Some(ptr) => {\n-                trace!(\"TLS key {} stored: {:?}\", key, new_ptr);\n-                *ptr = new_ptr;\n+            Some(&mut TlsEntry { ref mut data, .. }) => {\n+                trace!(\"TLS key {} stored: {:?}\", key, new_data);\n+                *data = new_data;\n                 Ok(())\n             },\n             None => Err(EvalError::TlsOutOfBounds)\n         }\n     }\n+    \n+    // Returns a dtor and its argument, if one is supposed to run\n+    pub(crate) fn fetch_tls_dtor(&mut self) -> Option<(ty::Instance<'tcx>, Pointer)> {\n+        for (_, &mut TlsEntry { ref mut data, dtor }) in self.thread_local.iter_mut() {\n+            if !data.is_null_ptr() {\n+                if let Some(dtor) = dtor {\n+                    let old_data = *data;\n+                    *data = Pointer::from_int(0);\n+                    return Some((dtor, old_data));\n+                }\n+            }\n+        }\n+        return None;\n+    }\n }\n \n // The derived `Ord` impl sorts first by the first field, then, if the fields are the same"}, {"sha": "658a3445c4331e4b8f4309c1f4f02d0904c14692", "filename": "src/step.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=a66f359d91d2baf2d4224832456b1f9fa7ed0740", "patch": "@@ -14,7 +14,7 @@ use eval_context::{EvalContext, StackPopCleanup};\n use lvalue::{Global, GlobalId, Lvalue};\n use value::{Value, PrimVal};\n use memory::Pointer;\n-use syntax::codemap::Span;\n+use syntax::codemap::{Span, DUMMY_SP};\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub fn inc_step_counter_and_check_limit(&mut self, n: u64) -> EvalResult<'tcx> {\n@@ -32,6 +32,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.clear_packed();\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n+            if let Some((instance, ptr)) = self.memory.fetch_tls_dtor() {\n+                trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+                // TODO: Potientiually, this has to support all the other possible instances? See eval_fn_call in terminator/mod.rs\n+                let mir = self.load_mir(instance.def)?;\n+                // FIXME: Are these the right dummy values?\n+                self.push_stack_frame(\n+                    instance,\n+                    DUMMY_SP,\n+                    mir,\n+                    Lvalue::from_ptr(Pointer::zst_ptr()),\n+                    StackPopCleanup::None,\n+                )?;\n+                if let Some(arg_local) = self.frame().mir.args_iter().next() {\n+                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                    let ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n+                    self.write_value(Value::ByVal(PrimVal::Ptr(ptr)), dest, ty)?;\n+                } else {\n+                    return Err(EvalError::AbiViolation(\"TLS dtor does not take enough arguments.\".to_owned()));\n+                }\n+                \n+                return Ok(true);\n+            }\n             return Ok(false);\n         }\n \n@@ -49,11 +71,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 mir,\n                 new_constants: &mut new,\n             }.visit_statement(block, stmt, mir::Location { block, statement_index: stmt_id });\n+            // if ConstantExtractor added new frames, we don't execute anything here\n+            // but await the next call to step\n             if new? == 0 {\n                 self.statement(stmt)?;\n             }\n-            // if ConstantExtractor added new frames, we don't execute anything here\n-            // but await the next call to step\n             return Ok(true);\n         }\n \n@@ -66,11 +88,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir,\n             new_constants: &mut new,\n         }.visit_terminator(block, terminator, mir::Location { block, statement_index: stmt_id });\n+        // if ConstantExtractor added new frames, we don't execute anything here\n+        // but await the next call to step\n         if new? == 0 {\n             self.terminator(terminator)?;\n         }\n-        // if ConstantExtractor added new frames, we don't execute anything here\n-        // but await the next call to step\n         Ok(true)\n     }\n "}, {"sha": "aaf03ea665f68e040b3de2005eb2fcbb14afea05", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a66f359d91d2baf2d4224832456b1f9fa7ed0740/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=a66f359d91d2baf2d4224832456b1f9fa7ed0740", "patch": "@@ -221,6 +221,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     args.push((arg_val, arg_ty));\n                 }\n \n+                // Push the stack frame, and potentially be entirely done if the call got hooked\n                 if self.eval_fn_call_inner(\n                     instance,\n                     destination,\n@@ -229,6 +230,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     return Ok(());\n                 }\n \n+                // Pass the arguments\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 trace!(\"ABI: {:?}\", sig.abi);\n                 trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n@@ -595,19 +597,30 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key = self.memory.create_tls_key();\n                 let key_ptr = args[0].read_ptr(&self.memory)?;\n-\n+                \n+                // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n+                // FIXME: Or should we instead construct the type we expect it to have?\n+                let dtor_fn_ty = match self.operand_ty(&arg_operands[1]) {\n+                    &TyS { sty: TypeVariants::TyAdt(_, ref substs), .. } => {\n+                        substs.type_at(0)\n+                    }\n+                    _ => return Err(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: Second argument must be option of a function pointer.\".to_owned()))\n+                };\n+                let dtor_ptr = self.value_to_primval(args[1], dtor_fn_ty)?.to_ptr()?;\n+                let dtor = if dtor_ptr.is_null_ptr() { None } else { Some(self.memory.get_fn(dtor_ptr.alloc_id)?) };\n+                \n                 // Figure out how large a pthread TLS key actually is. This is libc::pthread_key_t.\n                 let key_size = match self.operand_ty(&arg_operands[0]) {\n                     &TyS { sty: TypeVariants::TyRawPtr(TypeAndMut { ty, .. }), .. } => {\n                         let layout = self.type_layout(ty)?;\n                         layout.size(&self.tcx.data_layout)\n                     }\n-                    _ => return Err(EvalError::Unimplemented(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))\n+                    _ => return Err(EvalError::AbiViolation(\"Wrong signature used for pthread_key_create: First argument must be a raw pointer.\".to_owned()))\n                 };\n                 \n-                // Write the key into the memory where key_ptr wants it\n+                // Create key and write it into the memory where key_ptr wants it\n+                let key = self.memory.create_tls_key(dtor);\n                 if key >= (1 << key_size.bits()) {\n                     return Err(EvalError::OutOfTls);\n                 }"}]}