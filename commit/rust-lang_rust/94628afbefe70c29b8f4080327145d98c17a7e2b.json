{"sha": "94628afbefe70c29b8f4080327145d98c17a7e2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NjI4YWZiZWZlNzBjMjliOGY0MDgwMzI3MTQ1ZDk4YzE3YTdlMmI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-24T21:45:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-24T21:45:15Z"}, "message": "Rollup merge of #63934 - Aaron1011:fix/impl-trait-coherence, r=nikomatsakis\n\nFix coherence checking for impl trait in type aliases\n\n**UPDATE**: This PR now treats all opaque types as remote. The original description appears below, but is no longer accurate.\n\nFixes #63677\n\n[RFC 2071](https://github.com/rust-lang/rfcs/pull/2071) (impl-trait-existential-types) does not explicitly state how `type_alias_impl_trait` should interact with coherence. However, there's only one choice which makes sense - coherence should look at the underlying type (i.e. the *\"defining\"* type of the `impl Trait`) of the type alias, just like we do for non-`impl Trait` type aliases.\n\nSpecifically, `impl Trait` type aliases that resolve to a local type should be treated like a local type with respect to coherence (e.g. `impl Trait` type aliases which resolve to a foreign type should be treated as a foreign type, and those that resolve to a local type should be treated as a local type).\n\nSince neither inherent impls nor direct trait impl (i.e. `impl MyType` or `impl MyTrait for MyType`) are allowed for type aliases, this usually does not come up. Before we ever attempt to do coherence checking, we will have errored out if an `impl Trait` type alias was used directly in an `impl` clause.\n\nHowever, during trait selection, we sometimes need to prove bounds like `T: Sized` for some type `T`. If `T` is an impl trait type alias, this requires to know the coherence behavior for `impl Trait` type aliases when we perform coherence checking.\n\nNote: Since determining the underlying type of an `impl Trait` type alias requires us to perform body type checking, this commit causes us to type check some bodies easier than we otherwise would have. However, since this is done through a query, this shouldn't cause any problems\n\nFor completeness, I've added an additional test of the coherence-related behavior of `impl Trait` type aliases.\n\ncc https://github.com/rust-lang/rust/issues/63063", "tree": {"sha": "683ab61fb585ff8cd8dafa77ec9eb591bc74e9ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/683ab61fb585ff8cd8dafa77ec9eb591bc74e9ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94628afbefe70c29b8f4080327145d98c17a7e2b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdio5rCRBK7hj4Ov3rIwAAdHIIACaw9eJfp6U8SdxN81kllRCt\nJc7fmO/SBc5KOidiwdTIdLAybNv30vup0oWU6J0SD4y6sjiqmmQVhsj36NQ3IlXO\no70Ol+ONhM3Y2u42hBtlVs74rFmUQXZ6Zlbz9bMJypttm4m+lleiyIJ2JUmxoYRF\nvDRk8pxV7fWjp4tTbH7kmIXycovpSSf9B3KB0WO+C6XapG8odkuHX0YrVhcwFbYG\n/INydgv+MdqDPmk+P5Wi1kX+FhscS55CrDI7evFFI1xoi4SiD8tNuL2OAQsqiRXe\nVSdO4XhVTNgVf69JqgLkJiS4JUS62F7d/9mPc9o66ud6UPYuslnE2opjzH2/T2s=\n=N/6i\n-----END PGP SIGNATURE-----\n", "payload": "tree 683ab61fb585ff8cd8dafa77ec9eb591bc74e9ce\nparent c623aa4a54c875287858d7f524a9e4483ca2de64\nparent 61cfe92a992f8cd8b1af8e443c442be9559c3a19\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1569361515 +0200\ncommitter GitHub <noreply@github.com> 1569361515 +0200\n\nRollup merge of #63934 - Aaron1011:fix/impl-trait-coherence, r=nikomatsakis\n\nFix coherence checking for impl trait in type aliases\n\n**UPDATE**: This PR now treats all opaque types as remote. The original description appears below, but is no longer accurate.\n\nFixes #63677\n\n[RFC 2071](https://github.com/rust-lang/rfcs/pull/2071) (impl-trait-existential-types) does not explicitly state how `type_alias_impl_trait` should interact with coherence. However, there's only one choice which makes sense - coherence should look at the underlying type (i.e. the *\"defining\"* type of the `impl Trait`) of the type alias, just like we do for non-`impl Trait` type aliases.\n\nSpecifically, `impl Trait` type aliases that resolve to a local type should be treated like a local type with respect to coherence (e.g. `impl Trait` type aliases which resolve to a foreign type should be treated as a foreign type, and those that resolve to a local type should be treated as a local type).\n\nSince neither inherent impls nor direct trait impl (i.e. `impl MyType` or `impl MyTrait for MyType`) are allowed for type aliases, this usually does not come up. Before we ever attempt to do coherence checking, we will have errored out if an `impl Trait` type alias was used directly in an `impl` clause.\n\nHowever, during trait selection, we sometimes need to prove bounds like `T: Sized` for some type `T`. If `T` is an impl trait type alias, this requires to know the coherence behavior for `impl Trait` type aliases when we perform coherence checking.\n\nNote: Since determining the underlying type of an `impl Trait` type alias requires us to perform body type checking, this commit causes us to type check some bodies easier than we otherwise would have. However, since this is done through a query, this shouldn't cause any problems\n\nFor completeness, I've added an additional test of the coherence-related behavior of `impl Trait` type aliases.\n\ncc https://github.com/rust-lang/rust/issues/63063\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94628afbefe70c29b8f4080327145d98c17a7e2b", "html_url": "https://github.com/rust-lang/rust/commit/94628afbefe70c29b8f4080327145d98c17a7e2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94628afbefe70c29b8f4080327145d98c17a7e2b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c623aa4a54c875287858d7f524a9e4483ca2de64", "url": "https://api.github.com/repos/rust-lang/rust/commits/c623aa4a54c875287858d7f524a9e4483ca2de64", "html_url": "https://github.com/rust-lang/rust/commit/c623aa4a54c875287858d7f524a9e4483ca2de64"}, {"sha": "61cfe92a992f8cd8b1af8e443c442be9559c3a19", "url": "https://api.github.com/repos/rust-lang/rust/commits/61cfe92a992f8cd8b1af8e443c442be9559c3a19", "html_url": "https://github.com/rust-lang/rust/commit/61cfe92a992f8cd8b1af8e443c442be9559c3a19"}], "stats": {"total": 140, "additions": 134, "deletions": 6}, "files": [{"sha": "ee318b127ae661158edf977172aab4a491f65880", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -432,7 +432,7 @@ fn orphan_check_trait_ref<'tcx>(\n }\n \n fn uncovered_tys<'tcx>(tcx: TyCtxt<'_>, ty: Ty<'tcx>, in_crate: InCrate) -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, in_crate) {\n+    if ty_is_local_constructor(tcx, ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(ty) {\n         ty.walk_shallow()\n@@ -451,7 +451,7 @@ fn is_possibly_remote_type(ty: Ty<'_>, _in_crate: InCrate) -> bool {\n }\n \n fn ty_is_local(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n-    ty_is_local_constructor(ty, in_crate) ||\n+    ty_is_local_constructor(tcx, ty, in_crate) ||\n         fundamental_ty(ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n@@ -472,7 +472,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n+fn ty_is_local_constructor(tcx: TyCtxt<'_>, ty: Ty<'_>, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -504,6 +504,15 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n \n         ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n+        ty::Opaque(did, _) => {\n+            // Check the underlying type that this opaque\n+            // type resolves to.\n+            // This recursion will eventually terminate,\n+            // since we've already managed to successfully\n+            // resolve all opaque types by this point\n+            let real_ty = tcx.type_of(did);\n+            ty_is_local_constructor(tcx, real_ty, in_crate)\n+        }\n \n         ty::Dynamic(ref tt, ..) => {\n             if let Some(principal) = tt.principal() {\n@@ -518,8 +527,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::UnnormalizedProjection(..) |\n         ty::Closure(..) |\n         ty::Generator(..) |\n-        ty::GeneratorWitness(..) |\n-        ty::Opaque(..) => {\n+        ty::GeneratorWitness(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "c9a40db41dfde03e9a53ee8328463c6003c37a95", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -395,7 +395,7 @@ impl<'tcx> Graph {\n     /// The parent of a given impl, which is the `DefId` of the trait when the\n     /// impl is a \"specialization root\".\n     pub fn parent(&self, child: DefId) -> DefId {\n-        *self.parent.get(&child).unwrap()\n+        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n     }\n }\n "}, {"sha": "c767578120883a01d34bb99957329727a95faba9", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,23 @@\n+// Tests that type alias impls traits do not leak auto-traits for\n+// the purposes of coherence checking\n+#![feature(type_alias_impl_trait)]\n+\n+trait OpaqueTrait { }\n+impl<T> OpaqueTrait for T { }\n+type OpaqueType = impl OpaqueTrait;\n+fn mk_opaque() -> OpaqueType { () }\n+\n+#[derive(Debug)]\n+struct D<T>(T);\n+\n+trait AnotherTrait { }\n+impl<T: Send> AnotherTrait for T { }\n+\n+// This is in error, because we cannot assume that `OpaqueType: !Send`.\n+// (We treat opaque types as \"foreign types\" that could grow more impls\n+// in the future.)\n+impl AnotherTrait for D<OpaqueType> {\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+}\n+\n+fn main() {}"}, {"sha": "5e72ca7a47ba1d82538efd9c17fece77a3000748", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,12 @@\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`:\n+  --> $DIR/auto-trait.rs:19:1\n+   |\n+LL | impl<T: Send> AnotherTrait for T { }\n+   | -------------------------------- first implementation here\n+...\n+LL | impl AnotherTrait for D<OpaqueType> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "4977f9bdbacd9a34fa72f9ad0414157c6dd4e504", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,22 @@\n+// Tests that we cannot assume that an opaque type does *not* implement some\n+// other trait\n+#![feature(type_alias_impl_trait)]\n+\n+trait OpaqueTrait { }\n+impl<T> OpaqueTrait for T { }\n+type OpaqueType = impl OpaqueTrait;\n+fn mk_opaque() -> OpaqueType { () }\n+\n+#[derive(Debug)]\n+struct D<T>(T);\n+\n+trait AnotherTrait { }\n+impl<T: std::fmt::Debug> AnotherTrait for T { }\n+\n+\n+// This is in error, because we cannot assume that `OpaqueType: !Debug`\n+impl AnotherTrait for D<OpaqueType> {\n+    //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n+}\n+\n+fn main() {}"}, {"sha": "526a664726ac26fa6da82b4b18b384f81be7b898", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,14 @@\n+error[E0119]: conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`:\n+  --> $DIR/negative-reasoning.rs:18:1\n+   |\n+LL | impl<T: std::fmt::Debug> AnotherTrait for T { }\n+   | ------------------------------------------- first implementation here\n+...\n+LL | impl AnotherTrait for D<OpaqueType> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n+   |\n+   = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "52802dd8fbb477b5e1ec4150693d1ea7bb32e0d2", "filename": "src/test/ui/type-alias-impl-trait/auxiliary/foreign-crate.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fauxiliary%2Fforeign-crate.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,2 @@\n+pub trait ForeignTrait {}\n+pub struct ForeignType<T>(pub T);"}, {"sha": "1c0f83d6c12da643ed6803a60db80bd303345c3a", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,17 @@\n+// aux-build:foreign-crate.rs\n+#![feature(type_alias_impl_trait)]\n+\n+extern crate foreign_crate;\n+\n+trait LocalTrait {}\n+impl<T> LocalTrait for foreign_crate::ForeignType<T> {}\n+\n+type AliasOfForeignType<T> = impl LocalTrait;\n+fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n+    foreign_crate::ForeignType(val)\n+}\n+\n+impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n+//~^ ERROR the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+\n+fn main() {}"}, {"sha": "6ede0fa14ba707abf6d2b180935d86e69d52ac19", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/coherence.rs:14:6\n+   |\n+LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n+   |      ^ unconstrained type parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "28f4a85c9f29039b45a1391c184361e67a43e2e2", "filename": "src/test/ui/type-alias-impl-trait/issue-63677-type-alias-coherence.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94628afbefe70c29b8f4080327145d98c17a7e2b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-63677-type-alias-coherence.rs?ref=94628afbefe70c29b8f4080327145d98c17a7e2b", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// Regression test for issue #63677 - ensure that\n+// coherence checking can properly handle 'impl trait'\n+// in type aliases\n+#![feature(type_alias_impl_trait)]\n+\n+pub trait Trait {}\n+pub struct S1<T>(T);\n+pub struct S2<T>(T);\n+\n+pub type T1 = impl Trait;\n+pub type T2 = S1<T1>;\n+pub type T3 = S2<T2>;\n+\n+impl<T> Trait for S1<T> {}\n+impl<T: Trait> S2<T> {}\n+impl T3 {}\n+\n+pub fn use_t1() -> T1 { S1(()) }\n+\n+fn main() {}"}]}