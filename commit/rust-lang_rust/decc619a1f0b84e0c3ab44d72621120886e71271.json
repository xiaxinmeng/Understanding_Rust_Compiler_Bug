{"sha": "decc619a1f0b84e0c3ab44d72621120886e71271", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlY2M2MTlhMWYwYjg0ZTBjM2FiNDRkNzI2MjExMjA4ODZlNzEyNzE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-05T17:12:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-05-15T20:24:16Z"}, "message": "Extend documentation and add review comments", "tree": {"sha": "22b557cf3701881d6879da20c1e48f728efaf33e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22b557cf3701881d6879da20c1e48f728efaf33e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/decc619a1f0b84e0c3ab44d72621120886e71271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/decc619a1f0b84e0c3ab44d72621120886e71271", "html_url": "https://github.com/rust-lang/rust/commit/decc619a1f0b84e0c3ab44d72621120886e71271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/decc619a1f0b84e0c3ab44d72621120886e71271/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27acb9b3c033e1dd74cc72310a5a346527d3e704", "url": "https://api.github.com/repos/rust-lang/rust/commits/27acb9b3c033e1dd74cc72310a5a346527d3e704", "html_url": "https://github.com/rust-lang/rust/commit/27acb9b3c033e1dd74cc72310a5a346527d3e704"}], "stats": {"total": 190, "additions": 152, "deletions": 38}, "files": [{"sha": "99d77038dd1dbaa288e05d3c2aeba4c180ca2825", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 152, "deletions": 38, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/decc619a1f0b84e0c3ab44d72621120886e71271/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/decc619a1f0b84e0c3ab44d72621120886e71271/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=decc619a1f0b84e0c3ab44d72621120886e71271", "patch": "@@ -62,11 +62,12 @@ use syntax_pos::{FileMap, Pos, SyntaxContext, FileName};\n use syntax_pos::hygiene::Mark;\n \n /// The main type provided by this crate, representing an abstract stream of\n-/// tokens.\n+/// tokens, or, more specifically, a sequence of token trees.\n+/// The type provide interfaces for iterating over those token trees and, conversely,\n+/// collecting a number of token trees into one stream.\n ///\n-/// This is both the input and output of `#[proc_macro_derive]` definitions.\n-/// Currently it's required to be a list of valid Rust items, but this\n-/// restriction may be lifted in the future.\n+/// This is both the input and output of `#[proc_macro]`, `#[proc_macro_attribute]`\n+/// and `#[proc_macro_derive]` definitions.\n ///\n /// The API of this type is intentionally bare-bones, but it'll be expanded over\n /// time!\n@@ -92,7 +93,7 @@ impl !Send for LexError {}\n impl !Sync for LexError {}\n \n impl TokenStream {\n-    /// Returns an empty `TokenStream`.\n+    /// Returns an empty `TokenStream` containing no token trees.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn empty() -> TokenStream {\n         TokenStream(tokenstream::TokenStream::empty())\n@@ -105,6 +106,12 @@ impl TokenStream {\n     }\n }\n \n+/// Attempts to break the string into tokens and parse those tokens into a token stream.\n+/// May fail for a number of reasons, for example, if the string contains unbalanced delimiters\n+/// or characters not existing in the language.\n+///\n+/// REVIEW The function actually panics on any error and never returns `LexError`.\n+/// REVIEW Should the panics be documented?\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n     type Err = LexError;\n@@ -125,13 +132,17 @@ impl FromStr for TokenStream {\n     }\n }\n \n+/// Prints the token stream as a string that should be losslessly convertible back\n+/// into the same token stream (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Display for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.0.fmt(f)\n     }\n }\n \n+/// Prints token in a form convenient for debugging.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl fmt::Debug for TokenStream {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -140,20 +151,27 @@ impl fmt::Debug for TokenStream {\n     }\n }\n \n+/// Creates a token stream containing a single token tree.\n+///\n+/// REVIEW We don't generally have impls `From<T> for Collection<T>`, but I see why this exists\n+/// REVIEW from practical point of view.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<TokenTree> for TokenStream {\n     fn from(tree: TokenTree) -> TokenStream {\n         TokenStream(tree.to_internal())\n     }\n }\n \n+/// Collects a number of token trees into a single stream.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl iter::FromIterator<TokenTree> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenTree>>(trees: I) -> Self {\n         trees.into_iter().map(TokenStream::from).collect()\n     }\n }\n \n+/// A \"flattening\" operation on token streams, collects token trees\n+/// from multiple token streams into a single stream.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl iter::FromIterator<TokenStream> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = TokenStream>>(streams: I) -> Self {\n@@ -165,15 +183,17 @@ impl iter::FromIterator<TokenStream> for TokenStream {\n     }\n }\n \n-/// Implementation details for the `TokenTree` type, such as iterators.\n+/// Public implementation details for the `TokenStream` type, such as iterators.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub mod token_stream {\n     use syntax::tokenstream;\n     use syntax_pos::DUMMY_SP;\n \n     use {TokenTree, TokenStream, Delimiter};\n \n-    /// An iterator over `TokenTree`s.\n+    /// An iterator over `TokenStream`'s `TokenTree`s.\n+    /// The iteration is \"shallow\", e.g. the iterator doesn't recurse into delimited groups,\n+    /// and returns whole groups as token trees.\n     #[derive(Clone)]\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub struct IntoIter {\n@@ -191,6 +211,15 @@ pub mod token_stream {\n                     let next = self.cursor.next_as_stream()?;\n                     Some(TokenTree::from_internal(next, &mut self.stack))\n                 })?;\n+                // HACK: The condition \"dummy span + group with empty delimiter\" represents an AST\n+                // fragment approximately converted into a token stream. This may happen, for\n+                // example, with inputs to proc macro attributes, including derives. Such \"groups\"\n+                // need to flattened during iteration over stream's token trees.\n+                // Eventually this needs to be removed in favor of keeping original token trees\n+                // and not doing the roundtrip through AST.\n+                //\n+                // REVIEW This may actually be observable if we can create a dummy span via\n+                // proc macro API, but it looks like we can't do it with 1.2 yet.\n                 if tree.span().0 == DUMMY_SP {\n                     if let TokenTree::Group(ref group) = tree {\n                         if group.delimiter() == Delimiter::None {\n@@ -237,6 +266,9 @@ pub fn quote_span(span: Span) -> TokenStream {\n }\n \n /// A region of source code, along with macro expansion information.\n+///\n+/// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n+/// REVIEW Do we want to guarantee `Span` to be `Copy`? Yes.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Copy, Clone)]\n pub struct Span(syntax_pos::Span);\n@@ -268,6 +300,9 @@ impl Span {\n     }\n \n     /// The span of the invocation of the current procedural macro.\n+    /// Identifiers created with this span will be resolved as if they were written\n+    /// directly at the macro call location (call-site hygiene) and other code\n+    /// at the macro call site will be able to refer to them as well.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn call_site() -> Span {\n         ::__internal::with_sess(|(_, mark)| Span(mark.expn_info().unwrap().call_site))\n@@ -355,6 +390,7 @@ impl Span {\n     diagnostic_method!(help, Level::Help);\n }\n \n+/// Prints a span in a form convenient for debugging.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -460,11 +496,19 @@ impl PartialEq<FileName> for SourceFile {\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Clone)]\n pub enum TokenTree {\n-    /// A delimited tokenstream\n+    /// A token stream surrounded by bracket delimiters.\n     Group(Group),\n-    /// A unicode identifier\n+    /// An identifier or lifetime identifier.\n+    ///\n+    /// REVIEW Maybe let's name it `Ident` instead of inventing a new term, it's named \"identifier\"\n+    /// REVIEW everywhere in the compiler, including `ident` in `macro`/`macro_rules!` DSL.\n     Term(Term),\n-    /// A punctuation character (`+`, `,`, `$`, etc.).\n+    /// A single punctuation character (`+`, `,`, `$`, etc.).\n+    ///\n+    /// REVIEW This is not an operator, operators are more narrow set, they also can be\n+    /// REVIEW multicharacter, this is punctuation, even the comment says so!\n+    /// REVIEW @dtolnay suggested `Punct` in the original implementation PR too, and it was\n+    /// REVIEW received positively, but the renaming never actually happened.\n     Op(Op),\n     /// A literal character (`'a'`), string (`\"hello\"`), number (`2.3`), etc.\n     Literal(Literal),\n@@ -476,8 +520,8 @@ impl !Send for TokenTree {}\n impl !Sync for TokenTree {}\n \n impl TokenTree {\n-    /// Returns the span of this token, accessing the `span` method of each of\n-    /// the internal tokens.\n+    /// Returns the span of this tree, delegating to the `span` method of\n+    /// the contained token or a delimited stream.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -504,6 +548,7 @@ impl TokenTree {\n     }\n }\n \n+/// Prints token treee in a form convenient for debugging.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Debug for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -518,6 +563,10 @@ impl fmt::Debug for TokenTree {\n     }\n }\n \n+/// REVIEW the impls below are kind of `From<T> for Option<T>`, not strictly necessary,\n+/// REVIEW but convenient. No harm, I guess. I'd actually like to see impls\n+/// REVIEW `From<Group/Term/Op/Literal> for TokenStream` to avoid stuttering like\n+/// REVIEW `TokenTree::Literal(Literal::string(\"lalala\")).into()`.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl From<Group> for TokenTree {\n     fn from(g: Group) -> TokenTree {\n@@ -546,6 +595,9 @@ impl From<Literal> for TokenTree {\n     }\n }\n \n+/// Prints the token tree as a string that should be losslessly convertible back\n+/// into the same token tree (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for TokenTree {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -558,11 +610,9 @@ impl fmt::Display for TokenTree {\n     }\n }\n \n-/// A delimited token stream\n+/// A delimited token stream.\n ///\n-/// A `Group` internally contains a `TokenStream` which is delimited by a\n-/// `Delimiter`. Groups represent multiple tokens internally and have a `Span`\n-/// for the entire stream.\n+/// A `Group` internally contains a `TokenStream` which is surrounded by `Delimiter`s.\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Group {\n@@ -586,12 +636,16 @@ pub enum Delimiter {\n     Brace,\n     /// `[ ... ]`\n     Bracket,\n-    /// An implicit delimiter, e.g. `$var`, where $var is  `...`.\n+    /// `\u00d8 ... \u00d8`\n+    /// An implicit delimiter, that may, for example, appear around tokens coming from a\n+    /// \"macro variable\" `$var`. It is important to preserve operator priorities in cases like\n+    /// `$var * 3` where `$var` is `1 + 2`.\n+    /// Implicit delimiters may not survive roundtrip of a token stream through a string.\n     None,\n }\n \n impl Group {\n-    /// Creates a new `group` with the given delimiter and token stream.\n+    /// Creates a new `Group` with the given delimiter and token stream.\n     ///\n     /// This constructor will set the span for this group to\n     /// `Span::call_site()`. To change the span you can use the `set_span`\n@@ -639,17 +693,33 @@ impl Group {\n     }\n }\n \n+/// Prints the group as a string that should be losslessly convertible back\n+/// into the same group (modulo spans), except for possibly `TokenTree::Group`s\n+/// with `Delimiter::None` delimiters.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Group {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n     }\n }\n \n-/// An `Op` is an operator like `+` or `-`, and only represents one character.\n+/// An `Op` is an single punctuation character like `+`, `-` or `#`.\n ///\n-/// Operators like `+=` are represented as two instance of `Op` with different\n+/// Multicharacter operators like `+=` are represented as two instances of `Op` with different\n /// forms of `Spacing` returned.\n+///\n+/// REVIEW This is not an operator, operators are more narrow set, they also can be\n+/// REVIEW multicharacter, this is punctuation, even the comment says so!\n+/// REVIEW @dtolnay suggested `Punct` in the original implementation PR too, and it was\n+/// REVIEW received positively, but the renaming never actually happened.\n+///\n+/// REVIEW We should guarantee that `Op` contains a valid punctuation character permitted by\n+/// REVIEW the language and not a random unicode code point. The check is already performed in\n+/// REVIEW `TokenTree::to_internal`, but we should do it on construction.\n+/// REVIEW `Op` can also avoid using `char` internally and keep an u8-like enum.\n+///\n+/// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n+/// REVIEW Do we want to guarantee `Op` to be `Copy`?\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n #[derive(Copy, Clone, Debug)]\n pub struct Op {\n@@ -663,13 +733,14 @@ impl !Send for Op {}\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl !Sync for Op {}\n \n-/// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n+/// Whether an `Op` is followed immediately by another `Op` or\n+/// followed by another token or whitespace.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub enum Spacing {\n-    /// e.g. `+` is `Alone` in `+ =`.\n+    /// e.g. `+` is `Alone` in `+ =`, `+ident` or `+()`.\n     Alone,\n-    /// e.g. `+` is `Joint` in `+=`.\n+    /// e.g. `+` is `Joint` in `+=` or `+#`.\n     Joint,\n }\n \n@@ -678,6 +749,12 @@ impl Op {\n     ///\n     /// The returned `Op` will have the default span of `Span::call_site()`\n     /// which can be further configured with the `set_span` method below.\n+    ///\n+    /// REVIEW Why we even use `char` here? There's no reason to use unicode here.\n+    /// REVIEW I guess because it's more convenient to write `new('+')` than `new(b'+')`, that's ok.\n+    ///\n+    /// REVIEW TO_DO Do input validation on construction, the argument should be a valid punctuation\n+    /// REVIEW character permitted by the language.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn new(op: char, spacing: Spacing) -> Op {\n         Op {\n@@ -687,44 +764,67 @@ impl Op {\n         }\n     }\n \n-    /// Returns the character this operation represents, for example `'+'`\n+    /// Returns the value of this punctuation character as `char`.\n+    ///\n+    /// REVIEW Again, there's no need for unicode here,\n+    /// REVIEW except for maybe future compatibility in case Rust turns into APL,\n+    /// REVIEW but if it's more convenient to use `char` then that's okay.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn op(&self) -> char {\n         self.op\n     }\n \n-    /// Returns the spacing of this operator, indicating whether it's a joint\n-    /// operator with more operators coming next in the token stream or an\n-    /// `Alone` meaning that the operator has ended.\n+    /// Returns the spacing of this punctuation character, indicating whether it's immediately\n+    /// followed by another `Op` in the token stream, so they can potentially be combined into\n+    /// a multicharacter operator (`Joint`), or it's followed by some other token or whitespace\n+    /// (`Alone`) so the operator has certainly ended.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn spacing(&self) -> Spacing {\n         self.spacing\n     }\n \n-    /// Returns the span for this operator character\n+    /// Returns the span for this punctuation character.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn span(&self) -> Span {\n         self.span\n     }\n \n-    /// Configure the span for this operator's character\n+    /// Configure the span for this punctuation character.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n+/// Prints the punctuation character as a string that should be losslessly convertible\n+/// back into the same character.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Op {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         TokenStream::from(TokenTree::from(self.clone())).fmt(f)\n     }\n }\n \n-/// An interned string.\n+/// An identifier (`ident`) or lifetime identifier (`'ident`).\n+///\n+/// REVIEW We should guarantee that `Term` contains a valid identifier permitted by\n+/// REVIEW the language and not a random unicode string, at least for a start.\n+///\n+/// REVIEW Maybe let's name it `Ident` instead of inventing a new term, it's named \"identifier\"\n+/// REVIEW everywhere in the compiler, including `ident` in `macro`/`macro_rules!` DSL.\n+///\n+/// REVIEW We need to support raw identifiers here (`r#ident`) or at least be future compatible\n+/// REVIEW with them. Currently they are supported using \"string typing\" - if string \"r#ident\" is\n+/// REVIEW passed to `Term::new` it will be interpreted as a raw identifier later on, we should add\n+/// REVIEW a field `is_raw` and a separate constructor for it (`Term::new_raw` or something) and\n+/// REVIEW keep it unstable until raw identifiers are stabilized.\n+///\n+/// REVIEW ATTENTION: `Copy` impl on a struct with private fields.\n+/// REVIEW Do we want to guarantee `Term` to be `Copy`?\n #[derive(Copy, Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Term {\n+    // REVIEW(INTERNAL) Symbol + Span is actually `ast::Ident`! We can use it here.\n     sym: Symbol,\n     span: Span,\n }\n@@ -739,14 +839,22 @@ impl Term {\n     /// `span`.\n     ///\n     /// Note that `span`, currently in rustc, configures the hygiene information\n-    /// for this identifier. As of this time `Span::call_site()` explicitly\n-    /// opts-in to **non-hygienic** information (aka copy/pasted code) while\n-    /// spans like `Span::def_site()` will opt-in to hygienic information,\n-    /// meaning that code at the call site of the macro can't access this\n-    /// identifier.\n+    /// for this identifier.\n+    ///\n+    /// As of this time `Span::call_site()` explicitly opts-in to \"call-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved as if they were written\n+    /// directly at the location of the macro call, and other code at the macro call site will be\n+    /// able to refer to them as well.\n+    ///\n+    /// Later spans like `Span::def_site()` will allow to opt-in to \"definition-site\" hygiene\n+    /// meaning that identifiers created with this span will be resolved at the location of the\n+    /// macro definition and other code at the macro call site will not be able to refer to them.\n     ///\n     /// Due to the current importance of hygiene this constructor, unlike other\n     /// tokens, requires a `Span` to be specified at construction.\n+    ///\n+    /// REVIEW TO_DO Do input validation, the argument should be a valid identifier or\n+    /// REVIEW lifetime identifier.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn new(string: &str, span: Span) -> Term {\n         Term {\n@@ -769,22 +877,26 @@ impl Term {\n         self.span\n     }\n \n-    /// Configures the span of this `Term`, possibly changing hygiene\n-    /// information.\n+    /// Configures the span of this `Term`, possibly changing its hygiene context.\n     #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n     pub fn set_span(&mut self, span: Span) {\n         self.span = span;\n     }\n }\n \n+/// Prints the identifier as a string that should be losslessly convertible\n+/// back into the same identifier.\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Term {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.sym.as_str().fmt(f)\n     }\n }\n \n-/// A literal character (`'a'`), string (`\"hello\"`), a number (`2.3`), etc.\n+/// A literal string (`\"hello\"`), byte string (`b\"hello\"`),\n+/// character (`'a'`), byte character (`b'a'`), an integer or floating point number\n+/// with or without a suffix (`1`, `1u8`, `2.3`, `2.3f32`).\n+/// Boolean literals like `true` and `false` do not belong here, they are `Term`s.\n #[derive(Clone, Debug)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub struct Literal {\n@@ -1016,6 +1128,8 @@ impl Literal {\n     }\n }\n \n+/// Prints the literal as a string that should be losslessly convertible\n+/// back into the same literal (except for possible rounding for floating point literals).\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Display for Literal {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}]}