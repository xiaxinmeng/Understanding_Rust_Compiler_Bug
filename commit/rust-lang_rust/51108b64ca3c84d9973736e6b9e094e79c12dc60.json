{"sha": "51108b64ca3c84d9973736e6b9e094e79c12dc60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxMTA4YjY0Y2EzYzg0ZDk5NzM3MzZlNmI5ZTA5NGU3OWMxMmRjNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-21T01:43:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-21T01:43:18Z"}, "message": "Auto merge of #31010 - petrochenkov:def, r=arielb1\n\nAll structs and their constructors are defined as `DefStruct`.\n`DefTy` is splitted into `DefEnum` and `DefTyAlias`.\nAd hoc flag `bool is_structure` is removed from `DefVariant`, it was required in one place in resolve and could be obtained by other means.\nFlag `bool is_ctor` is removed from `DefFn`, it wasn't really used for constructors outside of metadata decoding.\n\nObservable effects:\nMore specific error messages are selected in some cases.\nTwo name resolution bugs fixed (https://github.com/rust-lang/rust/issues/30992 and FIXME in compile-fail/empty-struct-braces-expr.rs).\n\nFixes https://github.com/rust-lang/rust/issues/30992\nCloses https://github.com/rust-lang/rust/issues/30361", "tree": {"sha": "822dd85b5aa9da12a90e48190be33afe0b01db89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/822dd85b5aa9da12a90e48190be33afe0b01db89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51108b64ca3c84d9973736e6b9e094e79c12dc60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51108b64ca3c84d9973736e6b9e094e79c12dc60", "html_url": "https://github.com/rust-lang/rust/commit/51108b64ca3c84d9973736e6b9e094e79c12dc60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51108b64ca3c84d9973736e6b9e094e79c12dc60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7dce32e65d53ff9cfd8dba89121efa4c977030de", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dce32e65d53ff9cfd8dba89121efa4c977030de", "html_url": "https://github.com/rust-lang/rust/commit/7dce32e65d53ff9cfd8dba89121efa4c977030de"}, {"sha": "2084c2c33a47407c5ec514898d72701cf0233ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2084c2c33a47407c5ec514898d72701cf0233ba9", "html_url": "https://github.com/rust-lang/rust/commit/2084c2c33a47407c5ec514898d72701cf0233ba9"}], "stats": {"total": 1396, "additions": 725, "deletions": 671}, "files": [{"sha": "8b1bdc31beb01bf916aed85ab623a9907edd9cc5", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -14,7 +14,7 @@\n  * Almost certainly this could (and should) be refactored out of existence.\n  */\n \n-use middle::def;\n+use middle::def::Def;\n use middle::ty::{self, Ty};\n \n use syntax::codemap::Span;\n@@ -72,7 +72,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n             }\n             Some(d) => d.full_def()\n         };\n-        if let def::DefPrimTy(nty) = def {\n+        if let Def::PrimTy(nty) = def {\n             Some(prim_ty_to_ty(tcx, &path.segments, nty))\n         } else {\n             None"}, {"sha": "a6bcf70925ca3eed134366574d61435b12e5d8de", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -10,7 +10,7 @@\n \n use rustc_data_structures::graph;\n use middle::cfg::*;\n-use middle::def;\n+use middle::def::Def;\n use middle::pat_util;\n use middle::ty;\n use syntax::ast;\n@@ -591,7 +591,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         }\n \n         match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-            Some(def::DefLabel(loop_id)) => {\n+            Some(Def::Label(loop_id)) => {\n                 for l in &self.loop_scopes {\n                     if l.loop_id == loop_id {\n                         return *l;"}, {"sha": "68016a153b03523ef584559cbf9fa6968b00172c", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -29,7 +29,7 @@ use middle::ty::cast::{CastKind};\n use middle::const_eval::{self, ConstEvalErr};\n use middle::const_eval::ErrKind::IndexOpFeatureGated;\n use middle::const_eval::EvalHint::ExprTypeChecked;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n@@ -610,21 +610,21 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         hir::ExprPath(..) => {\n             let def = v.tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n             match def {\n-                Some(def::DefVariant(_, _, _)) => {\n+                Some(Def::Variant(..)) => {\n                     // Count the discriminator or function pointer.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n-                Some(def::DefStruct(_)) => {\n+                Some(Def::Struct(..)) => {\n                     if let ty::TyBareFn(..) = node_ty.sty {\n                         // Count the function pointer.\n                         v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     }\n                 }\n-                Some(def::DefFn(..)) | Some(def::DefMethod(..)) => {\n+                Some(Def::Fn(..)) | Some(Def::Method(..)) => {\n                     // Count the function pointer.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                 }\n-                Some(def::DefStatic(..)) => {\n+                Some(Def::Static(..)) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n                         Mode::Const | Mode::ConstFn => {\n@@ -635,16 +635,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n                 }\n-                Some(def::DefConst(did)) |\n-                Some(def::DefAssociatedConst(did)) => {\n+                Some(Def::Const(did)) |\n+                Some(Def::AssociatedConst(did)) => {\n                     if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n                                                                        Some(e.id),\n                                                                        None) {\n                         let inner = v.global_expr(Mode::Const, expr);\n                         v.add_qualif(inner);\n                     }\n                 }\n-                Some(def::DefLocal(..)) if v.mode == Mode::ConstFn => {\n+                Some(Def::Local(..)) if v.mode == Mode::ConstFn => {\n                     // Sadly, we can't determine whether the types are zero-sized.\n                     v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n                 }\n@@ -672,16 +672,16 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n             let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n             let is_const = match def {\n-                Some(def::DefStruct(..)) => true,\n-                Some(def::DefVariant(..)) => {\n+                Some(Def::Struct(..)) => true,\n+                Some(Def::Variant(..)) => {\n                     // Count the discriminator.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     true\n                 }\n-                Some(def::DefFn(did, _)) => {\n+                Some(Def::Fn(did)) => {\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n-                Some(def::DefMethod(did)) => {\n+                Some(Def::Method(did)) => {\n                     match v.tcx.impl_or_trait_item(did).container() {\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(e, did, node_ty)"}, {"sha": "d52089dbeab5680b1a57567eac5150d9b3e5dd95", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -246,7 +246,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                 let pat_ty = cx.tcx.pat_ty(p);\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-                    if let Some(DefLocal(..)) = def {\n+                    if let Some(Def::Local(..)) = def {\n                         if edef.variants.iter().any(|variant|\n                             variant.name == ident.node.unhygienic_name\n                                 && variant.kind() == VariantKind::Unit\n@@ -454,8 +454,8 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n             hir::PatIdent(..) | hir::PatEnum(..) | hir::PatQPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(DefAssociatedConst(did)) |\n-                    Some(DefConst(did)) => match lookup_const_by_id(self.tcx, did,\n+                    Some(Def::AssociatedConst(did)) |\n+                    Some(Def::Const(did)) => match lookup_const_by_id(self.tcx, did,\n                                                                     Some(pat.id), None) {\n                         Some(const_expr) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n@@ -757,30 +757,30 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n     match pat.node {\n         hir::PatIdent(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(DefStruct(_)) => vec!(Single),\n-                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(Def::Struct(..)) => vec!(Single),\n+                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n                 _ => vec!()\n             },\n         hir::PatEnum(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         hir::PatQPath(..) =>\n             cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                             been rewritten\"),\n         hir::PatStruct(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(DefVariant(_, id, _)) => vec!(Variant(id)),\n+                Some(Def::Variant(_, id)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         hir::PatLit(ref expr) =>\n@@ -869,10 +869,10 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         hir::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).map(|d| d.full_def());\n             match opt_def {\n-                Some(DefConst(..)) | Some(DefAssociatedConst(..)) =>\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                Some(DefVariant(_, id, _)) => if *constructor == Variant(id) {\n+                Some(Def::Variant(_, id)) => if *constructor == Variant(id) {\n                     Some(vec!())\n                 } else {\n                     None\n@@ -884,11 +884,11 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         hir::PatEnum(_, ref args) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n-                DefConst(..) | DefAssociatedConst(..) =>\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n                                                     been rewritten\"),\n-                DefVariant(_, id, _) if *constructor != Variant(id) => None,\n-                DefVariant(..) | DefStruct(..) => {\n+                Def::Variant(_, id) if *constructor != Variant(id) => None,\n+                Def::Variant(..) | Def::Struct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n                         &None => vec![DUMMY_WILD_PAT; arity],"}, {"sha": "abea48f0bd67c210722eb1f58fc16b42c47d6cba", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -13,7 +13,7 @@\n \n use front::map as ast_map;\n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefVariant, DefMap};\n+use middle::def::{Def, DefMap};\n use util::nodemap::NodeMap;\n \n use syntax::{ast};\n@@ -238,9 +238,9 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         match e.node {\n             hir::ExprPath(..) => {\n                 match self.def_map.get(&e.id).map(|d| d.base_def) {\n-                    Some(DefStatic(def_id, _)) |\n-                    Some(DefAssociatedConst(def_id)) |\n-                    Some(DefConst(def_id)) => {\n+                    Some(Def::Static(def_id, _)) |\n+                    Some(Def::AssociatedConst(def_id)) |\n+                    Some(Def::Const(def_id)) => {\n                         if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n                             match self.ast_map.get(node_id) {\n                                 ast_map::NodeItem(item) =>\n@@ -263,7 +263,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(DefVariant(enum_id, variant_id, false)) => {\n+                    Some(Def::Variant(enum_id, variant_id)) => {\n                         if let Some(enum_node_id) = self.ast_map.as_local_node_id(enum_id) {\n                             if let hir::ItemEnum(ref enum_def, ref generics) =\n                                 self.ast_map.expect_item(enum_node_id).node\n@@ -276,7 +276,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                             } else {\n                                 self.sess.span_bug(e.span,\n                                                    \"`check_static_recursion` found \\\n-                                                    non-enum in DefVariant\");\n+                                                    non-enum in Def::Variant\");\n                             }\n                         }\n                     }"}, {"sha": "942f2d6efb1af7e4c7e511af737f0d9807a0afef", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -17,7 +17,8 @@ use self::EvalHint::*;\n use front::map as ast_map;\n use front::map::blocks::FnLikeNode;\n use middle::cstore::{self, CrateStore, InlinedItem};\n-use middle::{def, infer, subst, traits};\n+use middle::{infer, subst, traits};\n+use middle::def::Def;\n use middle::subst::Subst;\n use middle::def_id::DefId;\n use middle::pat_util::def_to_path;\n@@ -331,9 +332,9 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n                entry.insert(def);\n             }\n             let path = match def.full_def() {\n-                def::DefStruct(def_id) => def_to_path(tcx, def_id),\n-                def::DefVariant(_, variant_did, _) => def_to_path(tcx, variant_did),\n-                def::DefFn(..) => return P(hir::Pat {\n+                Def::Struct(def_id) => def_to_path(tcx, def_id),\n+                Def::Variant(_, variant_did) => def_to_path(tcx, variant_did),\n+                Def::Fn(..) => return P(hir::Pat {\n                     id: expr.id,\n                     node: hir::PatLit(P(expr.clone())),\n                     span: span,\n@@ -364,12 +365,12 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<hir::Pat>\n         hir::ExprPath(_, ref path) => {\n             let opt_def = tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def());\n             match opt_def {\n-                Some(def::DefStruct(..)) =>\n+                Some(Def::Struct(..)) =>\n                     hir::PatStruct(path.clone(), hir::HirVec::new(), false),\n-                Some(def::DefVariant(..)) =>\n+                Some(Def::Variant(..)) =>\n                     hir::PatEnum(path.clone(), None),\n-                Some(def::DefConst(def_id)) |\n-                Some(def::DefAssociatedConst(def_id)) => {\n+                Some(Def::Const(def_id)) |\n+                Some(Def::AssociatedConst(def_id)) => {\n                     let expr = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n                     return const_expr_to_pat(tcx, expr, span);\n                 },\n@@ -1002,7 +1003,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n               None\n           };\n           let (const_expr, const_ty) = match opt_def {\n-              Some(def::DefConst(def_id)) => {\n+              Some(Def::Const(def_id)) => {\n                   if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n                       match tcx.map.find(node_id) {\n                           Some(ast_map::NodeItem(it)) => match it.node {\n@@ -1017,7 +1018,7 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n                   }\n               }\n-              Some(def::DefAssociatedConst(def_id)) => {\n+              Some(Def::AssociatedConst(def_id)) => {\n                   if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n                       match tcx.impl_or_trait_item(def_id).container() {\n                           ty::TraitContainer(trait_id) => match tcx.map.find(node_id) {\n@@ -1052,21 +1053,21 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n                   }\n               }\n-              Some(def::DefVariant(enum_def, variant_def, _)) => {\n+              Some(Def::Variant(enum_def, variant_def)) => {\n                   (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n               }\n-              Some(def::DefStruct(_)) => {\n+              Some(Def::Struct(..)) => {\n                   return Ok(ConstVal::Struct(e.id))\n               }\n-              Some(def::DefLocal(_, id)) => {\n-                  debug!(\"DefLocal({:?}): {:?}\", id, fn_args);\n+              Some(Def::Local(_, id)) => {\n+                  debug!(\"Def::Local({:?}): {:?}\", id, fn_args);\n                   if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n                       return Ok(val.clone());\n                   } else {\n                       (None, None)\n                   }\n               },\n-              Some(def::DefMethod(id)) | Some(def::DefFn(id, _)) => return Ok(Function(id)),\n+              Some(Def::Method(id)) | Some(Def::Fn(id)) => return Ok(Function(id)),\n               _ => (None, None)\n           };\n           let const_expr = match const_expr {"}, {"sha": "27745a85935abf00d8c6668ca8da7b61754c81b3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -24,9 +24,9 @@\n \n use back::svh::Svh;\n use front::map as hir_map;\n-use middle::def;\n+use middle::def::{self, Def};\n use middle::lang_items;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, VariantKind};\n use middle::def_id::{DefId, DefIndex};\n use mir::repr::Mir;\n use session::Session;\n@@ -84,7 +84,7 @@ enum_from_u32! {\n // Something that a name can resolve to.\n #[derive(Copy, Clone, Debug)]\n pub enum DefLike {\n-    DlDef(def::Def),\n+    DlDef(Def),\n     DlImpl(DefId),\n     DlField\n }\n@@ -211,6 +211,8 @@ pub trait CrateStore<'tcx> : Any {\n \n     // resolve\n     fn def_path(&self, def: DefId) -> hir_map::DefPath;\n+    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind>;\n+    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>;\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>;\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name>;\n     fn item_children(&self, did: DefId) -> Vec<ChildItem>;\n@@ -380,6 +382,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n \n     // resolve\n     fn def_path(&self, def: DefId) -> hir_map::DefPath { unimplemented!() }\n+    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> { unimplemented!() }\n+    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n+        { unimplemented!() }\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n         { unimplemented!() }\n     fn struct_field_names(&self, def: DefId) -> Vec<ast::Name> { unimplemented!() }"}, {"sha": "1fa4093853b8199d10867094ac86307bc1c0609c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -17,7 +17,8 @@ use front::map as ast_map;\n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n \n-use middle::{def, pat_util, privacy, ty};\n+use middle::{pat_util, privacy, ty};\n+use middle::def::Def;\n use middle::def_id::{DefId};\n use lint;\n \n@@ -94,13 +95,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n         self.tcx.def_map.borrow().get(id).map(|def| {\n             match def.full_def() {\n-                def::DefConst(_) | def::DefAssociatedConst(..) => {\n+                Def::Const(_) | Def::AssociatedConst(..) => {\n                     self.check_def_id(def.def_id());\n                 }\n                 _ if self.ignore_non_const_paths => (),\n-                def::DefPrimTy(_) => (),\n-                def::DefSelfTy(..) => (),\n-                def::DefVariant(enum_id, variant_id, _) => {\n+                Def::PrimTy(_) => (),\n+                Def::SelfTy(..) => (),\n+                Def::Variant(enum_id, variant_id) => {\n                     self.check_def_id(enum_id);\n                     if !self.ignore_variant_stack.contains(&variant_id) {\n                         self.check_def_id(variant_id);"}, {"sha": "be967da2713b328b352c202d6d2cbb3f5adab7b5", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::Def::*;\n-\n use middle::def_id::DefId;\n use middle::privacy::LastPrivate;\n use middle::subst::ParamSpace;\n@@ -19,39 +17,36 @@ use rustc_front::hir;\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Def {\n-    DefFn(DefId, bool /* is_ctor */),\n-    DefSelfTy(Option<DefId>,                    // trait id\n+    Fn(DefId),\n+    SelfTy(Option<DefId>,                    // trait id\n               Option<(ast::NodeId, ast::NodeId)>),   // (impl id, self type id)\n-    DefMod(DefId),\n-    DefForeignMod(DefId),\n-    DefStatic(DefId, bool /* is_mutbl */),\n-    DefConst(DefId),\n-    DefAssociatedConst(DefId),\n-    DefLocal(DefId, // def id of variable\n+    Mod(DefId),\n+    ForeignMod(DefId),\n+    Static(DefId, bool /* is_mutbl */),\n+    Const(DefId),\n+    AssociatedConst(DefId),\n+    Local(DefId, // def id of variable\n              ast::NodeId), // node id of variable\n-    DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n-    DefTy(DefId, bool /* is_enum */),\n-    DefAssociatedTy(DefId /* trait */, DefId),\n-    DefTrait(DefId),\n-    DefPrimTy(hir::PrimTy),\n-    DefTyParam(ParamSpace, u32, DefId, ast::Name),\n-    DefUpvar(DefId,        // def id of closed over local\n+    Variant(DefId /* enum */, DefId /* variant */),\n+    Enum(DefId),\n+    TyAlias(DefId),\n+    AssociatedTy(DefId /* trait */, DefId),\n+    Trait(DefId),\n+    PrimTy(hir::PrimTy),\n+    TyParam(ParamSpace, u32, DefId, ast::Name),\n+    Upvar(DefId,        // def id of closed over local\n              ast::NodeId,  // node id of closed over local\n              usize,        // index in the freevars list of the closure\n              ast::NodeId), // expr node that creates the closure\n \n-    /// Note that if it's a tuple struct's definition, the node id of the DefId\n-    /// may either refer to the item definition's id or the VariantData.ctor_id.\n-    ///\n-    /// The cases that I have encountered so far are (this is not exhaustive):\n-    /// - If it's a ty_path referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the item definition's id.\n-    /// - If it's an ExprPath referring to some tuple struct, then DefMap maps\n-    ///   it to a def whose id is the VariantData.ctor_id.\n-    DefStruct(DefId),\n-    DefLabel(ast::NodeId),\n-    DefMethod(DefId),\n-    DefErr,\n+    // If Def::Struct lives in type namespace it denotes a struct item and its DefId refers\n+    // to NodeId of the struct itself.\n+    // If Def::Struct lives in value namespace (e.g. tuple struct, unit struct expressions)\n+    // it denotes a constructor and its DefId refers to NodeId of the struct's constructor.\n+    Struct(DefId),\n+    Label(ast::NodeId),\n+    Method(DefId),\n+    Err,\n }\n \n /// The result of resolving a path.\n@@ -115,43 +110,43 @@ pub struct Export {\n impl Def {\n     pub fn var_id(&self) -> ast::NodeId {\n         match *self {\n-            DefLocal(_, id) |\n-            DefUpvar(_, id, _, _) => {\n+            Def::Local(_, id) |\n+            Def::Upvar(_, id, _, _) => {\n                 id\n             }\n \n-            DefFn(..) | DefMod(..) | DefForeignMod(..) | DefStatic(..) |\n-            DefVariant(..) | DefTy(..) | DefAssociatedTy(..) |\n-            DefTyParam(..) | DefStruct(..) | DefTrait(..) |\n-            DefMethod(..) | DefConst(..) | DefAssociatedConst(..) |\n-            DefPrimTy(..) | DefLabel(..) | DefSelfTy(..) | DefErr => {\n+            Def::Fn(..) | Def::Mod(..) | Def::ForeignMod(..) | Def::Static(..) |\n+            Def::Variant(..) | Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) |\n+            Def::TyParam(..) | Def::Struct(..) | Def::Trait(..) |\n+            Def::Method(..) | Def::Const(..) | Def::AssociatedConst(..) |\n+            Def::PrimTy(..) | Def::Label(..) | Def::SelfTy(..) | Def::Err => {\n                 panic!(\"attempted .def_id() on invalid {:?}\", self)\n             }\n         }\n     }\n \n     pub fn def_id(&self) -> DefId {\n         match *self {\n-            DefFn(id, _) | DefMod(id) | DefForeignMod(id) | DefStatic(id, _) |\n-            DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(_, id) |\n-            DefTyParam(_, _, id, _) | DefStruct(id) | DefTrait(id) |\n-            DefMethod(id) | DefConst(id) | DefAssociatedConst(id) |\n-            DefLocal(id, _) | DefUpvar(id, _, _, _) => {\n+            Def::Fn(id) | Def::Mod(id) | Def::ForeignMod(id) | Def::Static(id, _) |\n+            Def::Variant(_, id) | Def::Enum(id) | Def::TyAlias(id) | Def::AssociatedTy(_, id) |\n+            Def::TyParam(_, _, id, _) | Def::Struct(id) | Def::Trait(id) |\n+            Def::Method(id) | Def::Const(id) | Def::AssociatedConst(id) |\n+            Def::Local(id, _) | Def::Upvar(id, _, _, _) => {\n                 id\n             }\n \n-            DefLabel(..)  |\n-            DefPrimTy(..) |\n-            DefSelfTy(..) |\n-            DefErr => {\n+            Def::Label(..)  |\n+            Def::PrimTy(..) |\n+            Def::SelfTy(..) |\n+            Def::Err => {\n                 panic!(\"attempted .def_id() on invalid def: {:?}\", self)\n             }\n         }\n     }\n \n     pub fn variant_def_ids(&self) -> Option<(DefId, DefId)> {\n         match *self {\n-            DefVariant(enum_id, var_id, _) => {\n+            Def::Variant(enum_id, var_id) => {\n                 Some((enum_id, var_id))\n             }\n             _ => None"}, {"sha": "055beac5428440d3e4cd0943692de0cd8e489031", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -12,7 +12,7 @@\n //! `unsafe`.\n use self::RootUnsafeContext::*;\n \n-use middle::def;\n+use middle::def::Def;\n use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n \n@@ -170,7 +170,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n             hir::ExprPath(..) => {\n-                if let def::DefStatic(_, true) = self.tcx.resolve_expr(expr) {\n+                if let Def::Static(_, true) = self.tcx.resolve_expr(expr) {\n                     self.require_unsafe(expr.span, \"use of mutable static\");\n                 }\n             }"}, {"sha": "b5baf84eef23da34faf5961af7e7c1d0755ee46c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -19,7 +19,8 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use middle::{def, pat_util};\n+use middle::pat_util;\n+use middle::def::Def;\n use middle::def_id::{DefId};\n use middle::infer;\n use middle::mem_categorization as mc;\n@@ -1077,7 +1078,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                             // struct or enum pattern.\n                         }\n \n-                        Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n+                        Some(Def::Variant(enum_did, variant_did)) => {\n                             let downcast_cmt =\n                                 if tcx.lookup_adt_def(enum_did).is_univariant() {\n                                     cmt_pat\n@@ -1093,7 +1094,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                             delegate.matched_pat(pat, downcast_cmt, match_mode);\n                         }\n \n-                        Some(def::DefStruct(..)) | Some(def::DefTy(_, false)) => {\n+                        Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => {\n                             // A struct (in either the value or type\n                             // namespace; we encounter the former on\n                             // e.g. patterns for unit structs).\n@@ -1105,28 +1106,17 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n                             delegate.matched_pat(pat, cmt_pat, match_mode);\n                         }\n \n-                        Some(def::DefConst(..)) |\n-                        Some(def::DefAssociatedConst(..)) |\n-                        Some(def::DefLocal(..)) => {\n+                        Some(Def::Const(..)) |\n+                        Some(Def::AssociatedConst(..)) |\n+                        Some(Def::Local(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call.\n                         }\n \n-                        Some(def @ def::DefTy(_, true)) => {\n-                            // An enum's type -- should never be in a\n-                            // pattern.\n-\n-                            if !tcx.sess.has_errors() {\n-                                let msg = format!(\"Pattern has unexpected type: {:?} and type {:?}\",\n-                                                  def,\n-                                                  cmt_pat.ty);\n-                                tcx.sess.span_bug(pat.span, &msg)\n-                            }\n-                        }\n-\n                         Some(def) => {\n-                            // Remaining cases are e.g. DefFn, to\n+                            // An enum type should never be in a pattern.\n+                            // Remaining cases are e.g. Def::Fn, to\n                             // which identifiers within patterns\n                             // should not resolve. However, we do\n                             // encouter this when using the\n@@ -1195,7 +1185,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n     fn cat_captured_var(&mut self,\n                         closure_id: ast::NodeId,\n                         closure_span: Span,\n-                        upvar_def: def::Def)\n+                        upvar_def: Def)\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective"}, {"sha": "b83cd60031d13f2736b7b1e551a2cdaa47ff46d4", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -77,7 +77,7 @@ use rustc_front::hir;\n use rustc_front::print::pprust;\n \n use middle::cstore::CrateStore;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer::{self, TypeOrigin};\n use middle::region;\n@@ -1404,7 +1404,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         Some(d) => d.full_def()\n                     };\n                     match a_def {\n-                        def::DefTy(did, _) | def::DefStruct(did) => {\n+                        Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n                             let generics = self.tcx.lookup_item_type(did).generics;\n \n                             let expected =\n@@ -1452,7 +1452,6 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         }\n                         _ => ()\n                     }\n-\n                 }\n \n                 hir::TyPtr(ref mut_ty) => {"}, {"sha": "9afc1e366eed5793fb96d95488f074c29cc8078c", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::DepNode;\n-use middle::def::DefFn;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, TyBareFn};\n@@ -235,7 +235,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         if let hir::ExprPath(..) = expr.node {\n             match self.tcx.resolve_expr(expr) {\n-                DefFn(did, _) if self.def_id_is_transmute(did) => {\n+                Def::Fn(did) if self.def_id_is_transmute(did) => {\n                     let typ = self.tcx.node_id_to_type(expr.id);\n                     match typ.sty {\n                         TyBareFn(_, ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {"}, {"sha": "90fa148e0084eb43bed1e683d668f2e453da86bb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -448,7 +448,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprPath(..) => {\n         let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if let DefLocal(..) = def {\n+        if let Def::Local(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n@@ -465,7 +465,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         let mut call_caps = Vec::new();\n         ir.tcx.with_freevars(expr.id, |freevars| {\n             for fv in freevars {\n-                if let DefLocal(_, rv) = fv.def {\n+                if let Def::Local(_, rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n                     call_caps.push(CaptureInfo {ln: fv_ln,\n                                                 var_nid: rv});\n@@ -697,7 +697,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // Refers to a labeled loop. Use the results of resolve\n                 // to find with one\n                 match self.ir.tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                    Some(DefLabel(loop_id)) => loop_id,\n+                    Some(Def::Label(loop_id)) => loop_id,\n                     _ => self.ir.tcx.sess.span_bug(sp, \"label on break/loop \\\n                                                         doesn't refer to a loop\")\n                 }\n@@ -1276,7 +1276,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n-          DefLocal(_, nid) => {\n+          Def::Local(_, nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n@@ -1531,7 +1531,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             hir::ExprPath(..) => {\n-                if let DefLocal(_, nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n+                if let Def::Local(_, nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n                                                                       .unwrap()\n                                                                       .full_def() {\n                     // Assignment to an immutable variable or argument: only legal"}, {"sha": "55bbde21514b8fd4cefbf99c4f196a2c0e5d1a3d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -75,7 +75,7 @@ use middle::def_id::DefId;\n use front::map as ast_map;\n use middle::infer;\n use middle::check_const;\n-use middle::def;\n+use middle::def::Def;\n use middle::ty::adjustment;\n use middle::ty::{self, Ty};\n \n@@ -542,32 +542,27 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: Ty<'tcx>,\n-                   def: def::Def)\n+                   def: Def)\n                    -> McResult<cmt<'tcx>> {\n         debug!(\"cat_def: id={} expr={:?} def={:?}\",\n                id, expr_ty, def);\n \n         match def {\n-          def::DefStruct(..) | def::DefVariant(..) | def::DefConst(..) |\n-          def::DefAssociatedConst(..) | def::DefFn(..) | def::DefMethod(..) => {\n+          Def::Struct(..) | Def::Variant(..) | Def::Const(..) |\n+          Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) => {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n-          def::DefMod(_) | def::DefForeignMod(_) |\n-          def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n-          def::DefTyParam(..) |\n-          def::DefLabel(_) | def::DefSelfTy(..) |\n-          def::DefAssociatedTy(..) => {\n-              Ok(Rc::new(cmt_ {\n-                  id:id,\n-                  span:span,\n-                  cat:Categorization::StaticItem,\n-                  mutbl: McImmutable,\n-                  ty:expr_ty,\n-                  note: NoteNone\n-              }))\n+\n+          Def::Mod(_) | Def::ForeignMod(_) |\n+          Def::Trait(_) | Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(_) |\n+          Def::TyParam(..) |\n+          Def::Label(_) | Def::SelfTy(..) |\n+          Def::AssociatedTy(..) => {\n+              self.tcx().sess.span_bug(span, &format!(\"Unexpected definition in \\\n+                                                       memory categorization: {:?}\", def));\n           }\n \n-          def::DefStatic(_, mutbl) => {\n+          Def::Static(_, mutbl) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -578,7 +573,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }))\n           }\n \n-          def::DefUpvar(_, var_id, _, fn_node_id) => {\n+          Def::Upvar(_, var_id, _, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n                   ty::TyClosure(closure_id, _) => {\n@@ -603,7 +598,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n               }\n           }\n \n-          def::DefLocal(_, vid) => {\n+          Def::Local(_, vid) => {\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n@@ -614,7 +609,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n             }))\n           }\n \n-          def::DefErr => panic!(\"DefErr in memory categorization\")\n+          Def::Err => panic!(\"Def::Err in memory categorization\")\n         }\n     }\n \n@@ -1202,7 +1197,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         (*op)(self, cmt.clone(), pat);\n \n         let opt_def = if let Some(path_res) = self.tcx().def_map.borrow().get(&pat.id) {\n-            if path_res.depth != 0 || path_res.base_def == def::DefErr {\n+            if path_res.depth != 0 || path_res.base_def == Def::Err {\n                 // Since patterns can be associated constants\n                 // which are resolved during typeck, we might have\n                 // some unresolved patterns reaching this stage\n@@ -1218,7 +1213,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         // alone) because struct patterns can refer to struct types or\n         // to struct variants within enums.\n         let cmt = match opt_def {\n-            Some(def::DefVariant(enum_did, variant_did, _))\n+            Some(Def::Variant(enum_did, variant_did))\n                 // univariant enums do not need downcasts\n                 if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n@@ -1236,7 +1231,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n           }\n           hir::PatEnum(_, Some(ref subpats)) => {\n             match opt_def {\n-                Some(def::DefVariant(..)) => {\n+                Some(Def::Variant(..)) => {\n                     // variant(x, y, z)\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n@@ -1249,7 +1244,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                         try!(self.cat_pattern_(subcmt, &**subpat, op));\n                     }\n                 }\n-                Some(def::DefStruct(..)) => {\n+                Some(Def::Struct(..)) => {\n                     for (i, subpat) in subpats.iter().enumerate() {\n                         let subpat_ty = try!(self.pat_ty(&**subpat)); // see (*2)\n                         let cmt_field =\n@@ -1259,7 +1254,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n                         try!(self.cat_pattern_(cmt_field, &**subpat, op));\n                     }\n                 }\n-                Some(def::DefConst(..)) | Some(def::DefAssociatedConst(..)) => {\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {\n                     for subpat in subpats {\n                         try!(self.cat_pattern_(cmt.clone(), &**subpat, op));\n                     }"}, {"sha": "41367b9361fbb2866d9979b536f65c73aa4753b4", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -39,7 +39,7 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n         hir::PatIdent(_, _, None) |\n         hir::PatStruct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefVariant(..)) => true,\n+                Some(Def::Variant(..)) => true,\n                 _ => false\n             }\n         }\n@@ -54,7 +54,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n         hir::PatIdent(_, _, None) |\n         hir::PatStruct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefVariant(..)) | Some(DefStruct(..)) => true,\n+                Some(Def::Variant(..)) | Some(Def::Struct(..)) => true,\n                 _ => false\n             }\n         }\n@@ -66,7 +66,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         hir::PatIdent(_, _, None) | hir::PatEnum(..) | hir::PatQPath(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n             }\n         }\n@@ -82,7 +82,7 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n             match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n-                Some(DefConst(..)) | Some(DefAssociatedConst(..)) => true,\n+                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n             }\n         }\n@@ -228,7 +228,7 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n             hir::PatIdent(_, _, None) |\n             hir::PatStruct(..) => {\n                 match dm.get(&p.id) {\n-                    Some(&PathResolution { base_def: DefVariant(_, id, _), .. }) => {\n+                    Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {\n                         variants.push(id);\n                     }\n                     _ => ()"}, {"sha": "6373bfbc55ee65c70e8276916c76d9ad50e6a057", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -17,7 +17,7 @@\n \n use dep_graph::DepNode;\n use front::map as ast_map;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::ty;\n use middle::privacy;\n@@ -108,7 +108,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n-                            def::DefConst(..) | def::DefAssociatedConst(..) => {\n+                            Def::Const(..) | Def::AssociatedConst(..) => {\n                                 self.worklist.push(node_id);\n                             }\n "}, {"sha": "af9d0987ff073e41be5363eac012eb4cafe4de56", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -19,7 +19,7 @@ pub use self::DefRegion::*;\n use self::ScopeChain::*;\n \n use session::Session;\n-use middle::def::{self, DefMap};\n+use middle::def::{Def, DefMap};\n use middle::region;\n use middle::subst;\n use middle::ty;\n@@ -205,7 +205,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n-                    Some((def::DefTrait(..), 0)) => {\n+                    Some((Def::Trait(..), 0)) => {\n                         self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });"}, {"sha": "e0d38f1c76f6ceea10b7fd3a0c53d72a5388667c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -17,7 +17,7 @@ use dep_graph::DepNode;\n use session::Session;\n use lint;\n use middle::cstore::{CrateStore, LOCAL_CRATE};\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n use middle::privacy::AccessLevels;\n@@ -561,8 +561,8 @@ pub fn check_expr(tcx: &ty::ctxt, e: &hir::Expr,\n pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-        Some(def::DefPrimTy(..)) => {}\n-        Some(def::DefSelfTy(..)) => {}\n+        Some(Def::PrimTy(..)) => {}\n+        Some(Def::SelfTy(..)) => {}\n         Some(def) => {\n             maybe_do_stability_check(tcx, def.def_id(), path.span, cb);\n         }\n@@ -573,7 +573,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &hir::Path, id: ast::NodeId,\n pub fn check_path_list_item(tcx: &ty::ctxt, item: &hir::PathListItem,\n                   cb: &mut FnMut(DefId, Span, &Option<&Stability>, &Option<Deprecation>)) {\n     match tcx.def_map.borrow().get(&item.node.id()).map(|d| d.full_def()) {\n-        Some(def::DefPrimTy(..)) => {}\n+        Some(Def::PrimTy(..)) => {}\n         Some(def) => {\n             maybe_do_stability_check(tcx, def.def_id(), item.span, cb);\n         }"}, {"sha": "a56752db137222f2c5eb125def36144278c1ffa2", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -24,7 +24,7 @@ use front::map as ast_map;\n use front::map::LinkedPath;\n use middle;\n use middle::cstore::{self, CrateStore, LOCAL_CRATE};\n-use middle::def::{self, ExportMap};\n+use middle::def::{self, Def, ExportMap};\n use middle::def_id::DefId;\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent};\n@@ -587,7 +587,7 @@ pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n \n #[derive(Copy, Clone)]\n pub struct ClosureUpvar<'tcx> {\n-    pub def: def::Def,\n+    pub def: Def,\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n }\n@@ -1429,9 +1429,19 @@ impl<'tcx> Decodable for AdtDef<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Enum }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum VariantKind { Struct, Tuple, Unit }\n \n+impl VariantKind {\n+    pub fn from_variant_data(vdata: &hir::VariantData) -> Self {\n+        match *vdata {\n+            hir::VariantData::Struct(..) => VariantKind::Struct,\n+            hir::VariantData::Tuple(..) => VariantKind::Tuple,\n+            hir::VariantData::Unit(..) => VariantKind::Unit,\n+        }\n+    }\n+}\n+\n impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n     fn new(tcx: &ctxt<'tcx>,\n            did: DefId,\n@@ -1575,10 +1585,10 @@ impl<'tcx, 'container> AdtDefData<'tcx, 'container> {\n             .expect(\"variant_index_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: def::Def) -> &VariantDefData<'tcx, 'container> {\n+    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'tcx, 'container> {\n         match def {\n-            def::DefVariant(_, vid, _) => self.variant_with_id(vid),\n-            def::DefStruct(..) | def::DefTy(..) => self.struct_variant(),\n+            Def::Variant(_, vid) => self.variant_with_id(vid),\n+            Def::Struct(..) | Def::TyAlias(..) => self.struct_variant(),\n             _ => panic!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }\n@@ -1924,7 +1934,7 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn resolve_expr(&self, expr: &hir::Expr) -> def::Def {\n+    pub fn resolve_expr(&self, expr: &hir::Expr) -> Def {\n         match self.def_map.borrow().get(&expr.id) {\n             Some(def) => def.full_def(),\n             None => {\n@@ -1942,15 +1952,15 @@ impl<'tcx> ctxt<'tcx> {\n                 // rvalues.\n                 match self.def_map.borrow().get(&expr.id) {\n                     Some(&def::PathResolution {\n-                        base_def: def::DefStatic(..), ..\n+                        base_def: Def::Static(..), ..\n                     }) | Some(&def::PathResolution {\n-                        base_def: def::DefUpvar(..), ..\n+                        base_def: Def::Upvar(..), ..\n                     }) | Some(&def::PathResolution {\n-                        base_def: def::DefLocal(..), ..\n+                        base_def: Def::Local(..), ..\n                     }) => {\n                         true\n                     }\n-                    Some(&def::PathResolution { base_def: def::DefErr, .. })=> true,\n+                    Some(&def::PathResolution { base_def: Def::Err, .. })=> true,\n                     Some(..) => false,\n                     None => self.sess.span_bug(expr.span, &format!(\n                         \"no def for path {}\", expr.id))\n@@ -2612,7 +2622,7 @@ pub enum ExplicitSelfCategory {\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n-    pub def: def::Def,\n+    pub def: Def,\n \n     // First span where it is accessed (there can be multiple).\n     pub span: Span"}, {"sha": "367475a14a2e6d64e26f60f03bb7758aa3594548", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::def;\n+use middle::def::Def;\n use middle::ty;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -274,7 +274,7 @@ impl LateLintPass for NonSnakeCase {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         if let &hir::PatIdent(_, ref path1, _) = &p.node {\n             let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(def::DefLocal(..)) = def {\n+            if let Some(Def::Local(..)) = def {\n                 self.check_snake_case(cx, \"variable\", &path1.node.name.as_str(), Some(p.span));\n             }\n         }\n@@ -362,7 +362,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&hir::PatIdent(_, ref path1, _), Some(def::DefConst(..))) => {\n+            (&hir::PatIdent(_, ref path1, _), Some(Def::Const(..))) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n                                                       path1.node.name, p.span);\n             }"}, {"sha": "8621743668b9386b58bf78110e233080724bfde9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -28,7 +28,8 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-use middle::{cfg, def, infer, stability, traits};\n+use middle::{cfg, infer, stability, traits};\n+use middle::def::Def;\n use middle::cstore::CrateStore;\n use middle::def_id::DefId;\n use middle::subst::Substs;\n@@ -163,7 +164,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n                 let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n                 if let Some(def_id) = cx.tcx.map.opt_local_def_id(fieldpat.node.pat.id) {\n-                    def == Some(def::DefLocal(def_id, fieldpat.node.pat.id))\n+                    def == Some(Def::Local(def_id, fieldpat.node.pat.id))\n                 } else {\n                     false\n                 }\n@@ -819,7 +820,7 @@ impl LateLintPass for UnconditionalRecursion {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     match tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def()) {\n-                        Some(def::DefMethod(def_id)) => {\n+                        Some(Def::Method(def_id)) => {\n                             let item_substs =\n                                 tcx.tables.borrow().item_substs\n                                                    .get(&callee.id)\n@@ -1060,7 +1061,7 @@ impl LateLintPass for MutableTransmutes {\n                 hir::ExprPath(..) => (),\n                 _ => return None\n             }\n-            if let def::DefFn(did, _) = cx.tcx.resolve_expr(expr) {\n+            if let Def::Fn(did) = cx.tcx.resolve_expr(expr) {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "f0cd75ba958ddcaced468d8555c7df94abe9a3a7", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -30,7 +30,7 @@ use middle::cstore::{InlinedItem, InlinedItemRef};\n use middle::ty::adjustment;\n use middle::ty::cast;\n use middle::check_const::ConstQualif;\n-use middle::def;\n+use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::privacy::{AllPublic, LastMod};\n use middle::region;\n@@ -368,49 +368,48 @@ fn decode_ast(par_doc: rbml::Doc) -> InlinedItem {\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn decode_def(dcx: &DecodeContext, dsr: &mut reader::Decoder) -> def::Def {\n-    let def: def::Def = Decodable::decode(dsr).unwrap();\n+fn decode_def(dcx: &DecodeContext, dsr: &mut reader::Decoder) -> Def {\n+    let def: Def = Decodable::decode(dsr).unwrap();\n     def.tr(dcx)\n }\n \n-impl tr for def::Def {\n-    fn tr(&self, dcx: &DecodeContext) -> def::Def {\n+impl tr for Def {\n+    fn tr(&self, dcx: &DecodeContext) -> Def {\n         match *self {\n-          def::DefFn(did, is_ctor) => def::DefFn(did.tr(dcx), is_ctor),\n-          def::DefMethod(did) => def::DefMethod(did.tr(dcx)),\n-          def::DefSelfTy(opt_did, impl_ids) => { def::DefSelfTy(opt_did.map(|did| did.tr(dcx)),\n+          Def::Fn(did) => Def::Fn(did.tr(dcx)),\n+          Def::Method(did) => Def::Method(did.tr(dcx)),\n+          Def::SelfTy(opt_did, impl_ids) => { Def::SelfTy(opt_did.map(|did| did.tr(dcx)),\n                                                                 impl_ids.map(|(nid1, nid2)| {\n                                                                     (dcx.tr_id(nid1),\n                                                                      dcx.tr_id(nid2))\n                                                                 })) }\n-          def::DefMod(did) => { def::DefMod(did.tr(dcx)) }\n-          def::DefForeignMod(did) => { def::DefForeignMod(did.tr(dcx)) }\n-          def::DefStatic(did, m) => { def::DefStatic(did.tr(dcx), m) }\n-          def::DefConst(did) => { def::DefConst(did.tr(dcx)) }\n-          def::DefAssociatedConst(did) => def::DefAssociatedConst(did.tr(dcx)),\n-          def::DefLocal(_, nid) => {\n+          Def::Mod(did) => { Def::Mod(did.tr(dcx)) }\n+          Def::ForeignMod(did) => { Def::ForeignMod(did.tr(dcx)) }\n+          Def::Static(did, m) => { Def::Static(did.tr(dcx), m) }\n+          Def::Const(did) => { Def::Const(did.tr(dcx)) }\n+          Def::AssociatedConst(did) => Def::AssociatedConst(did.tr(dcx)),\n+          Def::Local(_, nid) => {\n               let nid = dcx.tr_id(nid);\n               let did = dcx.tcx.map.local_def_id(nid);\n-              def::DefLocal(did, nid)\n+              Def::Local(did, nid)\n           }\n-          def::DefVariant(e_did, v_did, is_s) => {\n-            def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n-          },\n-          def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n-          def::DefTy(did, is_enum) => def::DefTy(did.tr(dcx), is_enum),\n-          def::DefAssociatedTy(trait_did, did) =>\n-              def::DefAssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n-          def::DefPrimTy(p) => def::DefPrimTy(p),\n-          def::DefTyParam(s, index, def_id, n) => def::DefTyParam(s, index, def_id.tr(dcx), n),\n-          def::DefUpvar(_, nid1, index, nid2) => {\n+          Def::Variant(e_did, v_did) => Def::Variant(e_did.tr(dcx), v_did.tr(dcx)),\n+          Def::Trait(did) => Def::Trait(did.tr(dcx)),\n+          Def::Enum(did) => Def::Enum(did.tr(dcx)),\n+          Def::TyAlias(did) => Def::TyAlias(did.tr(dcx)),\n+          Def::AssociatedTy(trait_did, did) =>\n+              Def::AssociatedTy(trait_did.tr(dcx), did.tr(dcx)),\n+          Def::PrimTy(p) => Def::PrimTy(p),\n+          Def::TyParam(s, index, def_id, n) => Def::TyParam(s, index, def_id.tr(dcx), n),\n+          Def::Upvar(_, nid1, index, nid2) => {\n               let nid1 = dcx.tr_id(nid1);\n               let nid2 = dcx.tr_id(nid2);\n               let did1 = dcx.tcx.map.local_def_id(nid1);\n-              def::DefUpvar(did1, nid1, index, nid2)\n+              Def::Upvar(did1, nid1, index, nid2)\n           }\n-          def::DefStruct(did) => def::DefStruct(did.tr(dcx)),\n-          def::DefLabel(nid) => def::DefLabel(dcx.tr_id(nid)),\n-          def::DefErr => def::DefErr,\n+          Def::Struct(did) => Def::Struct(did.tr(dcx)),\n+          Def::Label(nid) => Def::Label(dcx.tr_id(nid)),\n+          Def::Err => Def::Err,\n         }\n     }\n }"}, {"sha": "802629e8f3e8b8d49c1dbd11485a9eb6f6fdce83", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -18,7 +18,7 @@ use middle::cstore::{CrateStore, CrateSource, ChildItem, FoundAst};\n use middle::cstore::{NativeLibraryKind, LinkMeta, LinkagePreference};\n use middle::def;\n use middle::lang_items;\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, Ty, VariantKind};\n use middle::def_id::{DefId, DefIndex};\n \n use rustc::front::map as hir_map;\n@@ -377,6 +377,17 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         local_path.into_iter().chain(path).collect()\n     }\n \n+    fn variant_kind(&self, def_id: DefId) -> Option<VariantKind> {\n+        let cdata = self.get_crate_data(def_id.krate);\n+        decoder::get_variant_kind(&cdata, def_id.index)\n+    }\n+\n+    fn struct_ctor_def_id(&self, struct_def_id: DefId) -> Option<DefId>\n+    {\n+        let cdata = self.get_crate_data(struct_def_id.krate);\n+        decoder::get_struct_ctor_def_id(&cdata, struct_def_id.index)\n+    }\n+\n     fn tuple_struct_definition_if_ctor(&self, did: DefId) -> Option<DefId>\n     {\n         let cdata = self.get_crate_data(did.krate);"}, {"sha": "bca8cb3995ab1ed341b0c2f82615127f819f65ab", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -28,12 +28,12 @@ use rustc_front::hir;\n \n use middle::cstore::{LOCAL_CRATE, FoundAst, InlinedItem, LinkagePreference};\n use middle::cstore::{DefLike, DlDef, DlField, DlImpl, tls};\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::{DefId, DefIndex};\n use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n-use middle::ty::{self, Ty, TypeFoldable};\n+use middle::ty::{self, Ty, TypeFoldable, VariantKind};\n \n use rustc::mir;\n use rustc::mir::visit::MutVisitor;\n@@ -89,27 +89,22 @@ pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n     index::DenseIndex::from_buf(index.data, index.start, index.end)\n }\n \n-#[derive(Debug, PartialEq)]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n enum Family {\n     ImmStatic,             // c\n     MutStatic,             // b\n     Fn,                    // f\n-    CtorFn,                // o\n     StaticMethod,          // F\n     Method,                // h\n     Type,                  // y\n     Mod,                   // m\n     ForeignMod,            // n\n     Enum,                  // t\n-    StructVariant,         // V\n-    TupleVariant,          // v\n-    UnitVariant,           // w\n+    Variant(VariantKind),  // V, v, w\n     Impl,                  // i\n     DefaultImpl,           // d\n     Trait,                 // I\n-    Struct,                // S\n-    TupleStruct,           // s\n-    UnitStruct,            // u\n+    Struct(VariantKind),   // S, s, u\n     PublicField,           // g\n     InheritedField,        // N\n     Constant,              // C\n@@ -122,22 +117,21 @@ fn item_family(item: rbml::Doc) -> Family {\n       'c' => ImmStatic,\n       'b' => MutStatic,\n       'f' => Fn,\n-      'o' => CtorFn,\n       'F' => StaticMethod,\n       'h' => Method,\n       'y' => Type,\n       'm' => Mod,\n       'n' => ForeignMod,\n       't' => Enum,\n-      'V' => StructVariant,\n-      'v' => TupleVariant,\n-      'w' => UnitVariant,\n+      'V' => Variant(VariantKind::Struct),\n+      'v' => Variant(VariantKind::Tuple),\n+      'w' => Variant(VariantKind::Unit),\n       'i' => Impl,\n       'd' => DefaultImpl,\n       'I' => Trait,\n-      'S' => Struct,\n-      's' => TupleStruct,\n-      'u' => UnitStruct,\n+      'S' => Struct(VariantKind::Struct),\n+      's' => Struct(VariantKind::Tuple),\n+      'u' => Struct(VariantKind::Unit),\n       'g' => PublicField,\n       'N' => InheritedField,\n        c => panic!(\"unexpected family char: {}\", c)\n@@ -271,49 +265,56 @@ fn item_name(intr: &IdentInterner, item: rbml::Doc) -> ast::Name {\n     }\n }\n \n+fn family_to_variant_kind<'tcx>(family: Family) -> Option<ty::VariantKind> {\n+    match family {\n+        Struct(VariantKind::Struct) | Variant(VariantKind::Struct) =>\n+            Some(ty::VariantKind::Struct),\n+        Struct(VariantKind::Tuple) | Variant(VariantKind::Tuple) =>\n+            Some(ty::VariantKind::Tuple),\n+        Struct(VariantKind::Unit) | Variant(VariantKind::Unit) =>\n+            Some(ty::VariantKind::Unit),\n+        _ => None,\n+    }\n+}\n+\n fn item_to_def_like(cdata: Cmd, item: rbml::Doc, did: DefId) -> DefLike {\n     let fam = item_family(item);\n     match fam {\n         Constant  => {\n             // Check whether we have an associated const item.\n             match item_sort(item) {\n                 Some('C') | Some('c') => {\n-                    DlDef(def::DefAssociatedConst(did))\n+                    DlDef(Def::AssociatedConst(did))\n                 }\n                 _ => {\n                     // Regular const item.\n-                    DlDef(def::DefConst(did))\n+                    DlDef(Def::Const(did))\n                 }\n             }\n         }\n-        ImmStatic => DlDef(def::DefStatic(did, false)),\n-        MutStatic => DlDef(def::DefStatic(did, true)),\n-        Struct | TupleStruct | UnitStruct => DlDef(def::DefStruct(did)),\n-        Fn        => DlDef(def::DefFn(did, false)),\n-        CtorFn    => DlDef(def::DefFn(did, true)),\n+        ImmStatic => DlDef(Def::Static(did, false)),\n+        MutStatic => DlDef(Def::Static(did, true)),\n+        Struct(..) => DlDef(Def::Struct(did)),\n+        Fn        => DlDef(Def::Fn(did)),\n         Method | StaticMethod => {\n-            DlDef(def::DefMethod(did))\n+            DlDef(Def::Method(did))\n         }\n         Type => {\n             if item_sort(item) == Some('t') {\n                 let trait_did = item_require_parent_item(cdata, item);\n-                DlDef(def::DefAssociatedTy(trait_did, did))\n+                DlDef(Def::AssociatedTy(trait_did, did))\n             } else {\n-                DlDef(def::DefTy(did, false))\n+                DlDef(Def::TyAlias(did))\n             }\n         }\n-        Mod => DlDef(def::DefMod(did)),\n-        ForeignMod => DlDef(def::DefForeignMod(did)),\n-        StructVariant => {\n+        Mod => DlDef(Def::Mod(did)),\n+        ForeignMod => DlDef(Def::ForeignMod(did)),\n+        Variant(..) => {\n             let enum_did = item_require_parent_item(cdata, item);\n-            DlDef(def::DefVariant(enum_did, did, true))\n+            DlDef(Def::Variant(enum_did, did))\n         }\n-        TupleVariant | UnitVariant => {\n-            let enum_did = item_require_parent_item(cdata, item);\n-            DlDef(def::DefVariant(enum_did, did, false))\n-        }\n-        Trait => DlDef(def::DefTrait(did)),\n-        Enum => DlDef(def::DefTy(did, true)),\n+        Trait => DlDef(Def::Trait(did)),\n+        Enum => DlDef(Def::Enum(did)),\n         Impl | DefaultImpl => DlImpl(did),\n         PublicField | InheritedField => DlField,\n     }\n@@ -371,11 +372,9 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                          item_id: DefIndex,\n                          tcx: &ty::ctxt<'tcx>) -> ty::AdtDefMaster<'tcx>\n {\n-    fn family_to_variant_kind<'tcx>(family: Family, tcx: &ty::ctxt<'tcx>) -> ty::VariantKind {\n-        match family {\n-            Struct | StructVariant => ty::VariantKind::Struct,\n-            TupleStruct | TupleVariant => ty::VariantKind::Tuple,\n-            UnitStruct | UnitVariant => ty::VariantKind::Unit,\n+    fn expect_variant_kind<'tcx>(family: Family, tcx: &ty::ctxt<'tcx>) -> ty::VariantKind {\n+        match family_to_variant_kind(family) {\n+            Some(kind) => kind,\n             _ => tcx.sess.bug(&format!(\"unexpected family: {:?}\", family)),\n         }\n     }\n@@ -399,7 +398,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n                 name: item_name(intr, item),\n                 fields: get_variant_fields(intr, cdata, item, tcx),\n                 disr_val: disr,\n-                kind: family_to_variant_kind(item_family(item), tcx),\n+                kind: expect_variant_kind(item_family(item), tcx),\n             }\n         }).collect()\n     }\n@@ -433,7 +432,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             name: item_name(intr, doc),\n             fields: get_variant_fields(intr, cdata, doc, tcx),\n             disr_val: 0,\n-            kind: family_to_variant_kind(item_family(doc), tcx),\n+            kind: expect_variant_kind(item_family(doc), tcx),\n         }\n     }\n \n@@ -444,7 +443,7 @@ pub fn get_adt_def<'tcx>(intr: &IdentInterner,\n             (ty::AdtKind::Enum,\n              get_enum_variants(intr, cdata, doc, tcx))\n         }\n-        Struct | TupleStruct | UnitStruct => {\n+        Struct(..) => {\n             let ctor_did =\n                 reader::maybe_get_doc(doc, tag_items_data_item_struct_ctor).\n                 map_or(did, |ctor_doc| translated_def_id(cdata, ctor_doc));\n@@ -1086,6 +1085,19 @@ pub fn get_associated_consts<'tcx>(intr: Rc<IdentInterner>,\n     }).collect()\n }\n \n+pub fn get_variant_kind(cdata: Cmd, node_id: DefIndex) -> Option<VariantKind>\n+{\n+    let item = cdata.lookup_item(node_id);\n+    family_to_variant_kind(item_family(item))\n+}\n+\n+pub fn get_struct_ctor_def_id(cdata: Cmd, node_id: DefIndex) -> Option<DefId>\n+{\n+    let item = cdata.lookup_item(node_id);\n+    reader::maybe_get_doc(item, tag_items_data_item_struct_ctor).\n+        map(|ctor_doc| translated_def_id(cdata, ctor_doc))\n+}\n+\n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of\n /// the actual type definition, otherwise, return None\n pub fn get_tuple_struct_definition_if_ctor(cdata: Cmd,"}, {"sha": "45cbb22e6c95270f3e736125f42364efa5b69148", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -508,15 +508,20 @@ fn encode_field<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n fn encode_info_for_struct_ctor<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                          rbml_w: &mut Encoder,\n                                          name: Name,\n-                                         ctor_id: NodeId,\n+                                         struct_def: &hir::VariantData,\n                                          index: &mut CrateIndex<'tcx>,\n                                          struct_id: NodeId) {\n+    let ctor_id = struct_def.id();\n     let ctor_def_id = ecx.tcx.map.local_def_id(ctor_id);\n \n     index.record(ctor_def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ctor_def_id);\n-    encode_family(rbml_w, 'o');\n+    encode_family(rbml_w, match *struct_def {\n+        hir::VariantData::Struct(..) => 'S',\n+        hir::VariantData::Tuple(..) => 's',\n+        hir::VariantData::Unit(..) => 'u',\n+    });\n     encode_bounds_and_type_for_item(rbml_w, ecx, index, ctor_id);\n     encode_name(rbml_w, name);\n     ecx.tcx.map.with_path(ctor_id, |path| encode_path(rbml_w, path));\n@@ -1084,7 +1089,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n \n         // If this is a tuple-like struct, encode the type of the constructor.\n         if !struct_def.is_struct() {\n-            encode_info_for_struct_ctor(ecx, rbml_w, item.name, struct_def.id(), index, item.id);\n+            encode_info_for_struct_ctor(ecx, rbml_w, item.name, struct_def, index, item.id);\n         }\n       }\n       hir::ItemDefaultImpl(unsafety, _) => {"}, {"sha": "57a43c3a180f2192f67a486ae35fc345e4294c3a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -14,7 +14,7 @@ use hair::cx::Cx;\n use hair::cx::block;\n use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n-use rustc::middle::def;\n+use rustc::middle::def::Def;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::pat_util;\n use rustc::middle::ty::{self, VariantDef, Ty};\n@@ -67,10 +67,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                         expr_ty.ty_adt_def().and_then(|adt_def|{\n                             match cx.tcx.def_map.borrow()[&fun.id].full_def() {\n-                                def::DefVariant(_, variant_id, false) => {\n+                                Def::Variant(_, variant_id) => {\n                                     Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                                 },\n-                                def::DefStruct(_) => {\n+                                Def::Struct(..) => {\n                                     Some((adt_def, 0))\n                                 },\n                                 _ => None\n@@ -231,7 +231,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     }\n                     ty::TyEnum(adt, substs) => {\n                         match cx.tcx.def_map.borrow()[&self.id].full_def() {\n-                            def::DefVariant(enum_id, variant_id, _) => {\n+                            Def::Variant(enum_id, variant_id) => {\n                                 debug_assert!(adt.did == enum_id);\n                                 let index = adt.variant_index_with_id(variant_id);\n                                 let field_refs = field_refs(&adt.variants[index], fields);\n@@ -573,9 +573,9 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n     let def = cx.tcx.def_map.borrow()[&expr.id].full_def();\n     let (def_id, kind) = match def {\n         // A regular function.\n-        def::DefFn(def_id, _) => (def_id, ItemKind::Function),\n-        def::DefMethod(def_id) => (def_id, ItemKind::Method),\n-        def::DefStruct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n+        Def::Fn(def_id) => (def_id, ItemKind::Function),\n+        Def::Method(def_id) => (def_id, ItemKind::Method),\n+        Def::Struct(def_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A tuple-struct constructor. Should only be reached if not called in the same\n             // expression.\n             ty::TyBareFn(..) => (def_id, ItemKind::Function),\n@@ -590,7 +590,7 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n             },\n             ref sty => panic!(\"unexpected sty: {:?}\", sty)\n         },\n-        def::DefVariant(enum_id, variant_id, false) => match cx.tcx.node_id_to_type(expr.id).sty {\n+        Def::Variant(enum_id, variant_id) => match cx.tcx.node_id_to_type(expr.id).sty {\n             // A variant constructor. Should only be reached if not called in the same\n             // expression.\n             ty::TyBareFn(..) => (variant_id, ItemKind::Function),\n@@ -608,21 +608,21 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n             },\n             ref sty => panic!(\"unexpected sty: {:?}\", sty)\n         },\n-        def::DefConst(def_id) |\n-        def::DefAssociatedConst(def_id) => {\n+        Def::Const(def_id) |\n+        Def::AssociatedConst(def_id) => {\n             if let Some(v) = cx.try_const_eval_literal(expr) {\n                 return ExprKind::Literal { literal: v };\n             } else {\n                 (def_id, ItemKind::Constant)\n             }\n         }\n \n-        def::DefStatic(node_id, _) => return ExprKind::StaticRef {\n+        Def::Static(node_id, _) => return ExprKind::StaticRef {\n             id: node_id,\n         },\n \n-        def @ def::DefLocal(..) |\n-        def @ def::DefUpvar(..) => return convert_var(cx, expr, def),\n+        def @ Def::Local(..) |\n+        def @ Def::Upvar(..) => return convert_var(cx, expr, def),\n \n         def =>\n             cx.tcx.sess.span_bug(\n@@ -636,18 +636,18 @@ fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr)\n \n fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n                              expr: &'tcx hir::Expr,\n-                             def: def::Def)\n+                             def: Def)\n                              -> ExprKind<'tcx> {\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n-        def::DefLocal(_, node_id) => {\n+        Def::Local(_, node_id) => {\n             ExprKind::VarRef {\n                 id: node_id,\n             }\n         }\n \n-        def::DefUpvar(_, id_var, index, closure_expr_id) => {\n+        Def::Upvar(_, id_var, index, closure_expr_id) => {\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\", id_var, index, closure_expr_id);\n             let var_ty = cx.tcx.node_id_to_type(id_var);\n \n@@ -922,7 +922,7 @@ fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n \n fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> CodeExtent {\n     match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-        Some(def::DefLabel(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n+        Some(Def::Label(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n         d => {\n             cx.tcx.sess.span_bug(expr.span, &format!(\"loop scope resolved to {:?}\", d));\n         }"}, {"sha": "e1a533ce42cca8f7308b49dcf7051c79113f1fb9", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -12,7 +12,7 @@ use hair::*;\n use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::middle::const_eval;\n-use rustc::middle::def;\n+use rustc::middle::def::Def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n@@ -84,7 +84,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n-                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n+                    Def::Const(def_id) | Def::AssociatedConst(def_id) =>\n                         match const_eval::lookup_const_by_id(self.cx.tcx, def_id,\n                                                              Some(pat.id), None) {\n                             Some(const_expr) => {\n@@ -290,7 +290,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                        -> PatternKind<'tcx> {\n         let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n         match def {\n-            def::DefVariant(enum_id, variant_id, _) => {\n+            Def::Variant(enum_id, variant_id) => {\n                 let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n                     PatternKind::Variant {\n@@ -303,9 +303,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                 }\n             }\n \n-            // NB: resolving to DefStruct means the struct *constructor*,\n-            // not the struct as a type.\n-            def::DefStruct(..) | def::DefTy(..) => {\n+            Def::Struct(..) | Def::TyAlias(..) => {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n "}, {"sha": "cfd0540cc60e782227f5430e270e76c9c07f5f69", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -37,7 +37,7 @@ use rustc_front::intravisit::{self, Visitor};\n \n use rustc::dep_graph::DepNode;\n use rustc::lint;\n-use rustc::middle::def;\n+use rustc::middle::def::{self, Def};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::middle::privacy::ImportUse::*;\n@@ -172,7 +172,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n         if let hir::TyPath(..) = ty.node {\n             match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {\n+                Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     Some(AccessLevel::Public)\n                 }\n                 def => {\n@@ -294,7 +294,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemTy(ref ty, _) if item_level.is_some() => {\n                 if let hir::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                        def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {},\n+                        Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {},\n                         def => {\n                             if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n                                 self.update(node_id, Some(AccessLevel::Reachable));\n@@ -806,17 +806,17 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         // be accurate and we can get slightly wonky error messages (but type\n         // checking is always correct).\n         match path_res.full_def() {\n-            def::DefFn(..) => ck(\"function\"),\n-            def::DefStatic(..) => ck(\"static\"),\n-            def::DefConst(..) => ck(\"const\"),\n-            def::DefAssociatedConst(..) => ck(\"associated const\"),\n-            def::DefVariant(..) => ck(\"variant\"),\n-            def::DefTy(_, false) => ck(\"type\"),\n-            def::DefTy(_, true) => ck(\"enum\"),\n-            def::DefTrait(..) => ck(\"trait\"),\n-            def::DefStruct(..) => ck(\"struct\"),\n-            def::DefMethod(..) => ck(\"method\"),\n-            def::DefMod(..) => ck(\"module\"),\n+            Def::Fn(..) => ck(\"function\"),\n+            Def::Static(..) => ck(\"static\"),\n+            Def::Const(..) => ck(\"const\"),\n+            Def::AssociatedConst(..) => ck(\"associated const\"),\n+            Def::Variant(..) => ck(\"variant\"),\n+            Def::TyAlias(..) => ck(\"type\"),\n+            Def::Enum(..) => ck(\"enum\"),\n+            Def::Trait(..) => ck(\"trait\"),\n+            Def::Struct(..) => ck(\"struct\"),\n+            Def::Method(..) => ck(\"method\"),\n+            Def::Mod(..) => ck(\"module\"),\n             _ => {}\n         }\n     }\n@@ -887,7 +887,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n             }\n             hir::ExprPath(..) => {\n \n-                if let def::DefStruct(_) = self.tcx.resolve_expr(expr) {\n+                if let Def::Struct(..) = self.tcx.resolve_expr(expr) {\n                     let expr_ty = self.tcx.expr_ty(expr);\n                     let def = match expr_ty.sty {\n                         ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n             // `int` etc. (None doesn't seem to occur.)\n-            None | Some(def::DefPrimTy(..)) | Some(def::DefSelfTy(..)) => return false,\n+            None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => return false,\n             Some(def) => def.def_id(),\n         };\n \n@@ -1503,10 +1503,10 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n             match def {\n-                def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {\n+                Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n-                def::DefAssociatedTy(..) if self.is_quiet => {\n+                Def::AssociatedTy(..) if self.is_quiet => {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n@@ -1515,8 +1515,8 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     // free type aliases, but this isn't done yet.\n                     return\n                 }\n-                def::DefStruct(def_id) | def::DefTy(def_id, _) |\n-                def::DefTrait(def_id) | def::DefAssociatedTy(def_id, _) => {\n+                Def::Struct(def_id) | Def::Enum(def_id) | Def::TyAlias(def_id) |\n+                Def::Trait(def_id) | Def::AssociatedTy(def_id, _) => {\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                         let item = self.tcx.map.expect_item(node_id);"}, {"sha": "5fb33b1ed1777e42b5c188ee42f334c36ccc0f90", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -31,6 +31,7 @@ use self::DuplicateCheckingMode::*;\n use rustc::middle::cstore::{CrateStore, ChildItem, DlDef, DlField, DlImpl};\n use rustc::middle::def::*;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::middle::ty::VariantKind;\n \n use syntax::ast::{Name, NodeId};\n use syntax::attr::AttrMetaMethods;\n@@ -315,7 +316,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     };\n                     self.external_exports.insert(def_id);\n                     let parent_link = ModuleParentLink(parent, name);\n-                    let def = DefMod(def_id);\n+                    let def = Def::Mod(def_id);\n                     let external_module = self.new_module(parent_link, Some(def), false, true);\n \n                     debug!(\"(build reduced graph for item) found extern `{}`\",\n@@ -333,7 +334,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateTypes, sp);\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = DefMod(self.ast_map.local_def_id(item.id));\n+                let def = Def::Mod(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n                 module\n@@ -346,20 +347,20 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n                 let mutbl = m == hir::MutMutable;\n \n-                name_bindings.define_value(DefStatic(self.ast_map.local_def_id(item.id), mutbl),\n+                name_bindings.define_value(Def::Static(self.ast_map.local_def_id(item.id), mutbl),\n                                            sp,\n                                            modifiers);\n                 parent\n             }\n             ItemConst(_, _) => {\n                 self.add_child(name, parent, ForbidDuplicateValues, sp)\n-                    .define_value(DefConst(self.ast_map.local_def_id(item.id)), sp, modifiers);\n+                    .define_value(Def::Const(self.ast_map.local_def_id(item.id)), sp, modifiers);\n                 parent\n             }\n             ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n-                let def = DefFn(self.ast_map.local_def_id(item.id), false);\n+                let def = Def::Fn(self.ast_map.local_def_id(item.id));\n                 name_bindings.define_value(def, sp, modifiers);\n                 parent\n             }\n@@ -372,7 +373,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    sp);\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = DefTy(self.ast_map.local_def_id(item.id), false);\n+                let def = Def::TyAlias(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module, sp);\n                 parent\n@@ -385,7 +386,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                    sp);\n \n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = DefTy(self.ast_map.local_def_id(item.id), true);\n+                let def = Def::Enum(self.ast_map.local_def_id(item.id));\n                 let module = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n \n@@ -414,14 +415,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let name_bindings = self.add_child(name, parent, forbid, sp);\n \n                 // Define a name in the type namespace.\n-                name_bindings.define_type(DefTy(self.ast_map.local_def_id(item.id), false),\n+                name_bindings.define_type(Def::Struct(self.ast_map.local_def_id(item.id)),\n                                           sp,\n                                           modifiers);\n \n                 // If this is a newtype or unit-like struct, define a name\n                 // in the value namespace as well\n                 if let Some(cid) = ctor_id {\n-                    name_bindings.define_value(DefStruct(self.ast_map.local_def_id(cid)),\n+                    name_bindings.define_value(Def::Struct(self.ast_map.local_def_id(cid)),\n                                                sp,\n                                                modifiers);\n                 }\n@@ -455,7 +456,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 // Add all the items within to a new module.\n                 let parent_link = ModuleParentLink(parent, name);\n-                let def = DefTrait(def_id);\n+                let def = Def::Trait(def_id);\n                 let module_parent = self.new_module(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module_parent.clone(), sp);\n \n@@ -468,17 +469,18 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                     match trait_item.node {\n                         hir::ConstTraitItem(..) => {\n-                            let def = DefAssociatedConst(self.ast_map.local_def_id(trait_item.id));\n+                            let def = Def::AssociatedConst(self.ast_map.\n+                                                                local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         hir::MethodTraitItem(..) => {\n-                            let def = DefMethod(self.ast_map.local_def_id(trait_item.id));\n+                            let def = Def::Method(self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_value(def, trait_item.span, DefModifiers::PUBLIC);\n                         }\n                         hir::TypeTraitItem(..) => {\n-                            let def = DefAssociatedTy(self.ast_map.local_def_id(item.id),\n+                            let def = Def::AssociatedTy(self.ast_map.local_def_id(item.id),\n                                                       self.ast_map.local_def_id(trait_item.id));\n                             // NB: not DefModifiers::IMPORTABLE\n                             name_bindings.define_type(def, trait_item.span, DefModifiers::PUBLIC);\n@@ -502,26 +504,19 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                        parent: Module<'b>,\n                                        variant_modifiers: DefModifiers) {\n         let name = variant.node.name;\n-        let is_exported = if variant.node.data.is_struct() {\n+        if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n             let variant_def_id = self.ast_map.local_def_id(variant.node.data.id());\n             self.structs.insert(variant_def_id, Vec::new());\n-            true\n-        } else {\n-            false\n-        };\n+        }\n \n         let child = self.add_child(name, parent, ForbidDuplicateTypesAndValues, variant.span);\n         // variants are always treated as importable to allow them to be glob\n         // used\n-        child.define_value(DefVariant(item_id,\n-                                      self.ast_map.local_def_id(variant.node.data.id()),\n-                                      is_exported),\n+        child.define_value(Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id())),\n                            variant.span,\n                            DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers);\n-        child.define_type(DefVariant(item_id,\n-                                     self.ast_map.local_def_id(variant.node.data.id()),\n-                                     is_exported),\n+        child.define_type(Def::Variant(item_id, self.ast_map.local_def_id(variant.node.data.id())),\n                           variant.span,\n                           DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers);\n     }\n@@ -541,10 +536,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n         let def = match foreign_item.node {\n             ForeignItemFn(..) => {\n-                DefFn(self.ast_map.local_def_id(foreign_item.id), false)\n+                Def::Fn(self.ast_map.local_def_id(foreign_item.id))\n             }\n             ForeignItemStatic(_, m) => {\n-                DefStatic(self.ast_map.local_def_id(foreign_item.id), m)\n+                Def::Static(self.ast_map.local_def_id(foreign_item.id), m)\n             }\n         };\n         name_bindings.define_value(def, foreign_item.span, modifiers);\n@@ -591,12 +586,18 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         if is_exported {\n             self.external_exports.insert(def.def_id());\n         }\n+        let is_struct_ctor = if let Def::Struct(def_id) = def {\n+            self.session.cstore.tuple_struct_definition_if_ctor(def_id).is_some()\n+        } else {\n+            false\n+        };\n \n         match def {\n-            DefMod(_) |\n-            DefForeignMod(_) |\n-            DefStruct(_) |\n-            DefTy(..) => {\n+            Def::Mod(_) |\n+            Def::ForeignMod(_) |\n+            Def::Struct(..) |\n+            Def::Enum(..) |\n+            Def::TyAlias(..) if !is_struct_ctor => {\n                 if let Some(module_def) = child_name_bindings.type_ns.module() {\n                     debug!(\"(building reduced graph for external crate) already created module\");\n                     module_def.def.set(Some(def));\n@@ -613,31 +614,26 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         }\n \n         match def {\n-            DefMod(_) | DefForeignMod(_) => {}\n-            DefVariant(_, variant_id, is_struct) => {\n+            Def::Mod(_) | Def::ForeignMod(_) => {}\n+            Def::Variant(_, variant_id) => {\n                 debug!(\"(building reduced graph for external crate) building variant {}\",\n                        final_ident);\n                 // variants are always treated as importable to allow them to be\n                 // glob used\n                 let modifiers = DefModifiers::PUBLIC | DefModifiers::IMPORTABLE;\n-                if is_struct {\n+                if self.session.cstore.variant_kind(variant_id) == Some(VariantKind::Struct) {\n                     child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                     // Not adding fields for variants as they are not accessed with a self receiver\n                     self.structs.insert(variant_id, Vec::new());\n                 } else {\n                     child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n                 }\n             }\n-            DefFn(ctor_id, true) => {\n-                child_name_bindings.define_value(\n-                self.session.cstore.tuple_struct_definition_if_ctor(ctor_id)\n-                    .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, modifiers);\n-            }\n-            DefFn(..) |\n-            DefStatic(..) |\n-            DefConst(..) |\n-            DefAssociatedConst(..) |\n-            DefMethod(..) => {\n+            Def::Fn(..) |\n+            Def::Static(..) |\n+            Def::Const(..) |\n+            Def::AssociatedConst(..) |\n+            Def::Method(..) => {\n                 debug!(\"(building reduced graph for external crate) building value (fn/static) {}\",\n                        final_ident);\n                 // impl methods have already been defined with the correct importability\n@@ -652,7 +648,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 }\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n             }\n-            DefTrait(def_id) => {\n+            Def::Trait(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\",\n                        final_ident);\n \n@@ -680,7 +676,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let module = self.new_module(parent_link, Some(def), true, is_public);\n                 child_name_bindings.define_module(module, DUMMY_SP);\n             }\n-            DefTy(..) | DefAssociatedTy(..) => {\n+            Def::Enum(..) | Def::TyAlias(..) | Def::AssociatedTy(..) => {\n                 debug!(\"(building reduced graph for external crate) building type {}\",\n                        final_ident);\n \n@@ -689,33 +685,38 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     _ => modifiers & !DefModifiers::IMPORTABLE,\n                 };\n \n-                if let DefTy(..) = def {\n+                if let Def::Enum(..) = def {\n+                    child_name_bindings.type_ns.set_modifiers(modifiers);\n+                } else if let Def::TyAlias(..) = def {\n                     child_name_bindings.type_ns.set_modifiers(modifiers);\n                 } else {\n                     child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n                 }\n             }\n-            DefStruct(def_id) => {\n+            Def::Struct(..) if is_struct_ctor => {\n+                // Do nothing\n+            }\n+            Def::Struct(def_id) => {\n                 debug!(\"(building reduced graph for external crate) building type and value for \\\n                         {}\",\n                        final_ident);\n-                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n-                let fields = self.session.cstore.struct_field_names(def_id);\n \n-                if fields.is_empty() {\n-                    child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n+                child_name_bindings.define_type(def, DUMMY_SP, modifiers);\n+                if let Some(ctor_def_id) = self.session.cstore.struct_ctor_def_id(def_id) {\n+                    child_name_bindings.define_value(Def::Struct(ctor_def_id), DUMMY_SP, modifiers);\n                 }\n \n                 // Record the def ID and fields of this struct.\n+                let fields = self.session.cstore.struct_field_names(def_id);\n                 self.structs.insert(def_id, fields);\n             }\n-            DefLocal(..) |\n-            DefPrimTy(..) |\n-            DefTyParam(..) |\n-            DefUpvar(..) |\n-            DefLabel(..) |\n-            DefSelfTy(..) |\n-            DefErr => {\n+            Def::Local(..) |\n+            Def::PrimTy(..) |\n+            Def::TyParam(..) |\n+            Def::Upvar(..) |\n+            Def::Label(..) |\n+            Def::SelfTy(..) |\n+            Def::Err => {\n                 panic!(\"didn't expect `{:?}`\", def);\n             }\n         }\n@@ -729,7 +730,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             DlDef(def) => {\n                 // Add the new child item, if necessary.\n                 match def {\n-                    DefForeignMod(def_id) => {\n+                    Def::ForeignMod(def_id) => {\n                         // Foreign modules have no names. Recur and populate\n                         // eagerly.\n                         for child in self.session.cstore.item_children(def_id) {"}, {"sha": "444c43163e3c3ad4f1113e8b463ab98c4e0be5cf", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -737,7 +737,7 @@ enum TypeParameters<'a> {\n }\n \n // The rib kind controls the translation of local\n-// definitions (`DefLocal`) to upvars (`DefUpvar`).\n+// definitions (`Def::Local`) to upvars (`Def::Upvar`).\n #[derive(Copy, Clone, Debug)]\n enum RibKind {\n     // No translation needs to be applied.\n@@ -913,14 +913,14 @@ impl<'a> ModuleS<'a> {\n \n     fn is_normal(&self) -> bool {\n         match self.def.get() {\n-            Some(DefMod(_)) | Some(DefForeignMod(_)) => true,\n+            Some(Def::Mod(_)) | Some(Def::ForeignMod(_)) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n         match self.def.get() {\n-            Some(DefTrait(_)) => true,\n+            Some(Def::Trait(_)) => true,\n             _ => false,\n         }\n     }\n@@ -1243,7 +1243,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n            arenas: &'a ResolverArenas<'a>)\n            -> Resolver<'a, 'tcx> {\n         let root_def_id = ast_map.local_def_id(CRATE_NODE_ID);\n-        let graph_root = ModuleS::new(NoParentLink, Some(DefMod(root_def_id)), false, true);\n+        let graph_root = ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, true);\n         let graph_root = arenas.modules.alloc(graph_root);\n \n         Resolver {\n@@ -2020,7 +2020,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                ItemRibKind),\n                                              |this| {\n                     let local_def_id = this.ast_map.local_def_id(item.id);\n-                    this.with_self_rib(DefSelfTy(Some(local_def_id), None), |this| {\n+                    this.with_self_rib(Def::SelfTy(Some(local_def_id), None), |this| {\n                         this.visit_generics(generics);\n                         walk_list!(this, visit_ty_param_bound, bounds);\n \n@@ -2076,7 +2076,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // check for imports shadowing primitive types\n                 let check_rename = |this: &Self, id, name| {\n                     match this.def_map.borrow().get(&id).map(|d| d.full_def()) {\n-                        Some(DefTy(..)) | Some(DefStruct(..)) | Some(DefTrait(..)) | None => {\n+                        Some(Def::Enum(..)) | Some(Def::TyAlias(..)) | Some(Def::Struct(..)) |\n+                        Some(Def::Trait(..)) | None => {\n                             this.check_if_primitive_type_name(name, item.span);\n                         }\n                         _ => {}\n@@ -2142,7 +2143,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // plain insert (no renaming)\n                     function_type_rib.bindings\n                                      .insert(name,\n-                                             DlDef(DefTyParam(space,\n+                                             DlDef(Def::TyParam(space,\n                                                               index as u32,\n                                                               self.ast_map\n                                                                   .local_def_id(type_parameter.id),\n@@ -2225,7 +2226,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                path_depth: usize)\n                                -> Result<PathResolution, ()> {\n         if let Some(path_res) = self.resolve_path(id, trait_path, path_depth, TypeNS, true) {\n-            if let DefTrait(_) = path_res.base_def {\n+            if let Def::Trait(_) = path_res.base_def {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n@@ -2236,7 +2237,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                                       path_depth)));\n \n                 // If it's a typedef, give a note\n-                if let DefTy(..) = path_res.base_def {\n+                if let Def::TyAlias(..) = path_res.base_def {\n                     err.span_note(trait_path.span,\n                                   \"`type` aliases cannot be used for traits\");\n                 }\n@@ -2262,7 +2263,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 &hir::WherePredicate::RegionPredicate(_) => {}\n                 &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n                     let path_res = self.resolve_path(eq_pred.id, &eq_pred.path, 0, TypeNS, true);\n-                    if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n+                    if let Some(PathResolution { base_def: Def::TyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n                         resolve_error(self,\n@@ -2344,7 +2345,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // Resolve the self type.\n                 this.visit_ty(self_type);\n \n-                this.with_self_rib(DefSelfTy(trait_id, Some((item_id, self_type.id))), |this| {\n+                this.with_self_rib(Def::SelfTy(trait_id, Some((item_id, self_type.id))), |this| {\n                     this.with_current_self_type(self_type, |this| {\n                         for impl_item in impl_items {\n                             match impl_item.node {\n@@ -2680,7 +2681,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             debug!(\"(resolving pattern) binding `{}`\", renamed);\n \n                             let def_id = self.ast_map.local_def_id(pattern.id);\n-                            let def = DefLocal(def_id, pattern.id);\n+                            let def = Def::Local(def_id, pattern.id);\n \n                             // Record the definition so that later passes\n                             // will be able to distinguish variants from\n@@ -2751,10 +2752,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     if let Some(path_res) = resolution {\n                         match path_res.base_def {\n-                            DefVariant(..) | DefStruct(..) | DefConst(..) => {\n+                            Def::Struct(..) if path_res.depth == 0 => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n-                            DefStatic(..) => {\n+                            Def::Variant(..) | Def::Const(..) => {\n+                                self.record_def(pattern.id, path_res);\n+                            }\n+                            Def::Static(..) => {\n                                 resolve_error(&self,\n                                               path.span,\n                                               ResolutionError::StaticVariableReference);\n@@ -2829,7 +2833,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         match path_res.base_def {\n                             // All `<T as Trait>::CONST` should end up here, and\n                             // have the trait already selected.\n-                            DefAssociatedConst(..) => {\n+                            Def::AssociatedConst(..) => {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             _ => {\n@@ -2906,13 +2910,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // For the two success cases, this lookup can be\n                     // considered as not having a private component because\n                     // the lookup happened only within the current module.\n-                    Some(def @ DefVariant(..)) | Some(def @ DefStruct(..)) => {\n+                    Some(def @ Def::Variant(..)) | Some(def @ Def::Struct(..)) => {\n                         return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                     }\n-                    Some(def @ DefConst(..)) | Some(def @ DefAssociatedConst(..)) => {\n+                    Some(def @ Def::Const(..)) | Some(def @ Def::AssociatedConst(..)) => {\n                         return FoundConst(def, LastMod(AllPublic), name);\n                     }\n-                    Some(DefStatic(..)) => {\n+                    Some(Def::Static(..)) => {\n                         resolve_error(self, span, ResolutionError::StaticVariableReference);\n                         return BareIdentifierPatternUnresolved;\n                     }\n@@ -2972,7 +2976,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 resolution = this.resolve_path(id, path, depth, TypeNS, true);\n             });\n         }\n-        if let Some(DefMod(_)) = resolution.map(|r| r.base_def) {\n+        if let Some(Def::Mod(_)) = resolution.map(|r| r.base_def) {\n             // A module is not a valid type or value.\n             resolution = None;\n         }\n@@ -3038,7 +3042,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if let Some(&prim_ty) = self.primitive_type_table\n                                         .primitive_types\n                                         .get(&identifier.unhygienic_name) {\n-                return Some(LocalDef::from_def(DefPrimTy(prim_ty)));\n+                return Some(LocalDef::from_def(Def::PrimTy(prim_ty)));\n             }\n         }\n \n@@ -3062,10 +3066,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         };\n         let mut def = local_def.def;\n         match def {\n-            DefUpvar(..) => {\n+            Def::Upvar(..) => {\n                 self.session.span_bug(span, &format!(\"unexpected {:?} in bindings\", def))\n             }\n-            DefLocal(_, node_id) => {\n+            Def::Local(_, node_id) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind => {\n@@ -3079,7 +3083,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            .entry(function_id)\n                                            .or_insert_with(|| NodeMap());\n                             if let Some(&index) = seen.get(&node_id) {\n-                                def = DefUpvar(node_def_id, node_id, index, function_id);\n+                                def = Def::Upvar(node_def_id, node_id, index, function_id);\n                                 continue;\n                             }\n                             let vec = self.freevars\n@@ -3091,7 +3095,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 span: span,\n                             });\n \n-                            def = DefUpvar(node_def_id, node_id, depth, function_id);\n+                            def = Def::Upvar(node_def_id, node_id, depth, function_id);\n                             seen.insert(node_id, depth);\n                         }\n                         ItemRibKind | MethodRibKind => {\n@@ -3113,7 +3117,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 }\n             }\n-            DefTyParam(..) | DefSelfTy(..) => {\n+            Def::TyParam(..) | Def::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | MethodRibKind | ClosureRibKind(..) => {\n@@ -3425,9 +3429,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if allowed == Everything {\n             // Look for a field with the same name in the current self_type.\n             match self.def_map.borrow().get(&node_id).map(|d| d.full_def()) {\n-                Some(DefTy(did, _)) |\n-                Some(DefStruct(did)) |\n-                Some(DefVariant(_, did, _)) => match self.structs.get(&did) {\n+                Some(Def::Enum(did)) |\n+                Some(Def::TyAlias(did)) |\n+                Some(Def::Struct(did)) |\n+                Some(Def::Variant(_, did)) => match self.structs.get(&did) {\n                     None => {}\n                     Some(fields) => {\n                         if fields.iter().any(|&field_name| name == field_name) {\n@@ -3444,7 +3449,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n             if let Some(binding) = module.children.borrow().get(&name) {\n-                if let Some(DefMethod(did)) = binding.value_ns.def() {\n+                if let Some(Def::Method(did)) = binding.value_ns.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n                     }\n@@ -3518,7 +3523,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // scopes looking for it.\n                 if let Some(path_res) = resolution {\n                     // Check if struct variant\n-                    if let DefVariant(_, _, true) = path_res.base_def {\n+                    let is_struct_variant = if let Def::Variant(_, variant_id) = path_res.base_def {\n+                        self.structs.contains_key(&variant_id)\n+                    } else {\n+                        false\n+                    };\n+                    if is_struct_variant {\n+                        let _ = self.structs.contains_key(&path_res.base_def.def_id());\n                         let path_name = path_names_to_string(path, 0);\n \n                         let mut err = resolve_struct_error(self,\n@@ -3561,7 +3572,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     self.record_def(expr.id, err_path_resolution());\n                     match type_res.map(|r| r.base_def) {\n-                        Some(DefTy(struct_id, _)) if self.structs.contains_key(&struct_id) => {\n+                        Some(Def::Struct(..)) => {\n                             let mut err = resolve_struct_error(self,\n                                 expr.span,\n                                 ResolutionError::StructVariantUsedAsFunction(&*path_name));\n@@ -3673,7 +3684,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n             ExprLoop(_, Some(label)) | ExprWhile(_, _, Some(label)) => {\n                 self.with_label_rib(|this| {\n-                    let def_like = DlDef(DefLabel(expr.id));\n+                    let def_like = DlDef(Def::Label(expr.id));\n \n                     {\n                         let rib = this.label_ribs.last_mut().unwrap();\n@@ -3692,7 +3703,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                       label.span,\n                                       ResolutionError::UndeclaredLabel(&label.node.name.as_str()))\n                     }\n-                    Some(DlDef(def @ DefLabel(_))) => {\n+                    Some(DlDef(def @ Def::Label(_))) => {\n                         // Since this def is a label, it is never read.\n                         self.record_def(expr.id,\n                                         PathResolution {\n@@ -3768,7 +3779,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         None => continue,\n                     };\n                     let trait_def_id = match def {\n-                        DefTrait(trait_def_id) => trait_def_id,\n+                        Def::Trait(trait_def_id) => trait_def_id,\n                         _ => continue,\n                     };\n                     if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n@@ -3784,7 +3795,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(ref target) => target,\n                 };\n                 let did = match target.binding.def() {\n-                    Some(DefTrait(trait_def_id)) => trait_def_id,\n+                    Some(Def::Trait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {\n@@ -3939,7 +3950,7 @@ fn module_to_string<'a>(module: Module<'a>) -> String {\n \n fn err_path_resolution() -> PathResolution {\n     PathResolution {\n-        base_def: DefErr,\n+        base_def: Def::Err,\n         last_private: LastMod(AllPublic),\n         depth: 0,\n     }"}, {"sha": "7df71fadd89f2b015b623bd8fc26628c2ccc87bb", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -852,7 +852,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         if let Some(did) = target_module.def_id() {\n             self.resolver.def_map.borrow_mut().insert(id,\n                                                       PathResolution {\n-                                                          base_def: DefMod(did),\n+                                                          base_def: Def::Mod(did),\n                                                           last_private: lp,\n                                                           depth: 0,\n                                                       });"}, {"sha": "b109353fac0bf598a6b260d77580489659c91ef4", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 39, "deletions": 37, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -32,7 +32,7 @@ use super::{escape, generated_code, recorder, SaveContext, PathCollector, Data};\n \n use session::Session;\n \n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::ty;\n \n@@ -239,8 +239,8 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n-            def::DefPrimTy(..) => None,\n-            def::DefSelfTy(..) => None,\n+            Def::PrimTy(..) => None,\n+            Def::SelfTy(..) => None,\n             _ => Some(def.def_id()),\n         }\n     }\n@@ -254,27 +254,28 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n         let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n-            def::DefMod(_) |\n-            def::DefForeignMod(_) => Some(recorder::ModRef),\n-            def::DefStruct(_) => Some(recorder::TypeRef),\n-            def::DefTy(..) |\n-            def::DefAssociatedTy(..) |\n-            def::DefTrait(_) => Some(recorder::TypeRef),\n-            def::DefStatic(_, _) |\n-            def::DefConst(_) |\n-            def::DefAssociatedConst(..) |\n-            def::DefLocal(..) |\n-            def::DefVariant(_, _, _) |\n-            def::DefUpvar(..) => Some(recorder::VarRef),\n-\n-            def::DefFn(..) => Some(recorder::FnRef),\n-\n-            def::DefSelfTy(..) |\n-            def::DefLabel(_) |\n-            def::DefTyParam(..) |\n-            def::DefMethod(..) |\n-            def::DefPrimTy(_) |\n-            def::DefErr => {\n+            Def::Mod(_) |\n+            Def::ForeignMod(_) => Some(recorder::ModRef),\n+            Def::Struct(..) => Some(recorder::TypeRef),\n+            Def::Enum(..) |\n+            Def::TyAlias(..) |\n+            Def::AssociatedTy(..) |\n+            Def::Trait(_) => Some(recorder::TypeRef),\n+            Def::Static(_, _) |\n+            Def::Const(_) |\n+            Def::AssociatedConst(..) |\n+            Def::Local(..) |\n+            Def::Variant(..) |\n+            Def::Upvar(..) => Some(recorder::VarRef),\n+\n+            Def::Fn(..) => Some(recorder::FnRef),\n+\n+            Def::SelfTy(..) |\n+            Def::Label(_) |\n+            Def::TyParam(..) |\n+            Def::Method(..) |\n+            Def::PrimTy(_) |\n+            Def::Err => {\n                 self.sess.span_bug(span,\n                                    &format!(\"lookup_def_kind for unexpected item: {:?}\", def));\n             }\n@@ -679,21 +680,21 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let def_map = self.tcx.def_map.borrow();\n         let def = def_map.get(&id).unwrap().full_def();\n         match def {\n-            def::DefMethod(did) => {\n+            Def::Method(did) => {\n                 let ti = self.tcx.impl_or_trait_item(did);\n                 if let ty::MethodTraitItem(m) = ti {\n                     if m.explicit_self == ty::ExplicitSelfCategory::Static {\n                         self.write_sub_path_trait_truncated(path);\n                     }\n                 }\n             }\n-            def::DefLocal(..) |\n-            def::DefStatic(_,_) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefStruct(_) |\n-            def::DefVariant(..) |\n-            def::DefFn(..) => self.write_sub_paths_truncated(path, false),\n+            Def::Local(..) |\n+            Def::Static(_,_) |\n+            Def::Const(..) |\n+            Def::AssociatedConst(..) |\n+            Def::Struct(..) |\n+            Def::Variant(..) |\n+            Def::Fn(..) => self.write_sub_paths_truncated(path, false),\n             _ => {}\n         }\n     }\n@@ -1163,7 +1164,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {\n-                def::DefLocal(_, id) => {\n+                Def::Local(_, id) => {\n                     let value = if immut == ast::MutImmutable {\n                         self.span.snippet(p.span).to_string()\n                     } else {\n@@ -1174,13 +1175,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                             \"qualified path for local variable def in arm\");\n                     self.fmt.variable_str(p.span, Some(p.span), id, &path_to_string(p), &value, \"\")\n                 }\n-                def::DefVariant(..) | def::DefTy(..) | def::DefStruct(..) => {\n+                Def::Variant(..) | Def::Enum(..) |\n+                Def::TyAlias(..) | Def::Struct(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 // FIXME(nrc) what are these doing here?\n-                def::DefStatic(_, _) |\n-                def::DefConst(..) |\n-                def::DefAssociatedConst(..) => {}\n+                Def::Static(_, _) |\n+                Def::Const(..) |\n+                Def::AssociatedConst(..) => {}\n                 _ => error!(\"unexpected definition kind when processing collected paths: {:?}\",\n                             def),\n             }"}, {"sha": "00554419e649c673e7ccf9adda0ae4c86e387bb3", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::ty;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n \n use std::env;\n@@ -533,30 +533,31 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         match def {\n-            def::DefUpvar(..) |\n-            def::DefLocal(..) |\n-            def::DefStatic(..) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefVariant(..) => {\n+            Def::Upvar(..) |\n+            Def::Local(..) |\n+            Def::Static(..) |\n+            Def::Const(..) |\n+            Def::AssociatedConst(..) |\n+            Def::Variant(..) => {\n                 Some(Data::VariableRefData(VariableRefData {\n                     name: self.span_utils.snippet(sub_span.unwrap()),\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(id),\n                     ref_id: def.def_id(),\n                 }))\n             }\n-            def::DefStruct(def_id) |\n-            def::DefTy(def_id, _) |\n-            def::DefTrait(def_id) |\n-            def::DefTyParam(_, _, def_id, _) => {\n+            Def::Struct(def_id) |\n+            Def::Enum(def_id) |\n+            Def::TyAlias(def_id) |\n+            Def::Trait(def_id) |\n+            Def::TyParam(_, _, def_id, _) => {\n                 Some(Data::TypeRefData(TypeRefData {\n                     span: sub_span.unwrap(),\n                     ref_id: def_id,\n                     scope: self.enclosing_scope(id),\n                 }))\n             }\n-            def::DefMethod(decl_id) => {\n+            Def::Method(decl_id) => {\n                 let sub_span = self.span_utils.sub_span_for_meth_name(path.span);\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.impl_or_trait_item(decl_id);\n@@ -591,14 +592,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     decl_id: Some(decl_id),\n                 }))\n             }\n-            def::DefFn(def_id, _) => {\n+            Def::Fn(def_id) => {\n                 Some(Data::FunctionCallData(FunctionCallData {\n                     ref_id: def_id,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(id),\n                 }))\n             }\n-            def::DefMod(def_id) => {\n+            Def::Mod(def_id) => {\n                 Some(Data::ModRefData(ModRefData {\n                     ref_id: def_id,\n                     span: sub_span.unwrap(),\n@@ -651,7 +652,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n-            def::DefPrimTy(_) | def::DefSelfTy(..) => None,\n+            Def::PrimTy(_) | Def::SelfTy(..) => None,\n             _ => Some(def.def_id()),\n         }\n     }"}, {"sha": "9a05135b76e3163cfe8bf2763ed4f6fdbc59ca1e", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -192,7 +192,7 @@ use llvm::{ValueRef, BasicBlockRef};\n use middle::check_match::StaticInliner;\n use middle::check_match;\n use middle::const_eval;\n-use middle::def::{self, DefMap};\n+use middle::def::{Def, DefMap};\n use middle::def_id::DefId;\n use middle::expr_use_visitor as euv;\n use middle::infer;\n@@ -669,7 +669,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // This is either an enum variant or a variable binding.\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n-                    Some(def::DefVariant(enum_id, var_id, _)) => {\n+                    Some(Def::Variant(enum_id, var_id)) => {\n                         let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n                         Variant(Disr::from(variant.disr_val),\n                                 adt::represent_node(bcx, cur.id),\n@@ -800,13 +800,13 @@ fn any_irrefutable_adt_pat(tcx: &ty::ctxt, m: &[Match], col: usize) -> bool {\n             hir::PatTup(_) => true,\n             hir::PatStruct(..) => {\n                 match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                    Some(def::DefVariant(..)) => false,\n+                    Some(Def::Variant(..)) => false,\n                     _ => true,\n                 }\n             }\n             hir::PatEnum(..) | hir::PatIdent(_, _, None) => {\n                 match tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-                    Some(def::DefStruct(..)) => true,\n+                    Some(Def::Struct(..)) => true,\n                     _ => false\n                 }\n             }\n@@ -1452,19 +1452,19 @@ pub fn trans_match<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool {\n     let (vid, field) = match discr.node {\n         hir::ExprPath(..) => match bcx.def(discr.id) {\n-            def::DefLocal(_, vid) | def::DefUpvar(_, vid, _, _) => (vid, None),\n+            Def::Local(_, vid) | Def::Upvar(_, vid, _, _) => (vid, None),\n             _ => return false\n         },\n         hir::ExprField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n-                Some(def::DefLocal(_, vid)) | Some(def::DefUpvar(_, vid, _, _)) => vid,\n+                Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::NamedField(field.node)))\n         },\n         hir::ExprTupField(ref base, field) => {\n             let vid = match bcx.tcx().def_map.borrow().get(&base.id).map(|d| d.full_def()) {\n-                Some(def::DefLocal(_, vid)) | Some(def::DefUpvar(_, vid, _, _)) => vid,\n+                Some(Def::Local(_, vid)) | Some(Def::Upvar(_, vid, _, _)) => vid,\n                 _ => return false\n             };\n             (vid, Some(mc::PositionalField(field.node)))\n@@ -1851,7 +1851,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         hir::PatEnum(_, ref sub_pats) => {\n             let opt_def = bcx.tcx().def_map.borrow().get(&pat.id).map(|d| d.full_def());\n             match opt_def {\n-                Some(def::DefVariant(enum_id, var_id, _)) => {\n+                Some(Def::Variant(enum_id, var_id)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n                     let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n@@ -1868,7 +1868,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         }\n                     }\n                 }\n-                Some(def::DefStruct(..)) => {\n+                Some(Def::Struct(..)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here."}, {"sha": "2651b3576feb27faf9794b39dae0a8880109ea67", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -22,7 +22,7 @@ use arena::TypedArena;\n use back::link;\n use llvm::{self, ValueRef, get_params};\n use middle::cstore::LOCAL_CRATE;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::subst;\n@@ -133,13 +133,13 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n     }\n \n     fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             def: def::Def,\n+                             def: Def,\n                              ref_expr: &hir::Expr)\n                              -> Callee<'blk, 'tcx> {\n         debug!(\"trans_def(def={:?}, ref_expr={:?})\", def, ref_expr);\n         let expr_ty = common::node_id_type(bcx, ref_expr.id);\n         match def {\n-            def::DefFn(did, _) if {\n+            Def::Fn(did) if {\n                 let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n                 let maybe_ast_node = maybe_def_id.and_then(|def_id| {\n                     let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n@@ -156,7 +156,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                     ty: expr_ty\n                 }\n             }\n-            def::DefFn(did, _) if match expr_ty.sty {\n+            Def::Fn(did) if match expr_ty.sty {\n                 ty::TyBareFn(_, ref f) => f.abi == synabi::RustIntrinsic ||\n                                           f.abi == synabi::PlatformIntrinsic,\n                 _ => false\n@@ -168,11 +168,11 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                 let node_id = bcx.tcx().map.as_local_node_id(def_id).unwrap();\n                 Callee { bcx: bcx, data: Intrinsic(node_id, substs), ty: expr_ty }\n             }\n-            def::DefFn(did, _) => {\n+            Def::Fn(did) => {\n                 fn_callee(bcx, trans_fn_ref(bcx.ccx(), did, ExprId(ref_expr.id),\n                                             bcx.fcx.param_substs))\n             }\n-            def::DefMethod(meth_did) => {\n+            Def::Method(meth_did) => {\n                 let method_item = bcx.tcx().impl_or_trait_item(meth_did);\n                 let fn_datum = match method_item.container() {\n                     ty::ImplContainer(_) => {\n@@ -190,7 +190,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                 };\n                 fn_callee(bcx, fn_datum)\n             }\n-            def::DefVariant(tid, vid, _) => {\n+            Def::Variant(tid, vid) => {\n                 let vinfo = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n                 assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n \n@@ -200,24 +200,24 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &hir::Expr)\n                     ty: expr_ty\n                 }\n             }\n-            def::DefStruct(_) => {\n+            Def::Struct(..) => {\n                 Callee {\n                     bcx: bcx,\n                     data: NamedTupleConstructor(Disr(0)),\n                     ty: expr_ty\n                 }\n             }\n-            def::DefStatic(..) |\n-            def::DefConst(..) |\n-            def::DefAssociatedConst(..) |\n-            def::DefLocal(..) |\n-            def::DefUpvar(..) => {\n+            Def::Static(..) |\n+            Def::Const(..) |\n+            Def::AssociatedConst(..) |\n+            Def::Local(..) |\n+            Def::Upvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n-            def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n-            def::DefLabel(..) | def::DefTyParam(..) |\n-            def::DefSelfTy(..) | def::DefErr => {\n+            Def::Mod(..) | Def::ForeignMod(..) | Def::Trait(..) |\n+            Def::Enum(..) | Def::TyAlias(..) | Def::PrimTy(..) |\n+            Def::AssociatedTy(..) | Def::Label(..) | Def::TyParam(..) |\n+            Def::SelfTy(..) | Def::Err => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\"}, {"sha": "6c03916af6c5de7d3923c863d7920533f6567ecf", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -19,7 +19,7 @@ use llvm;\n use llvm::{ValueRef, BasicBlockRef, BuilderRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool};\n use middle::cfg;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::lang_items::LangItem;\n@@ -184,7 +184,7 @@ pub struct VariantInfo<'tcx> {\n impl<'tcx> VariantInfo<'tcx> {\n     pub fn from_ty(tcx: &ty::ctxt<'tcx>,\n                    ty: Ty<'tcx>,\n-                   opt_def: Option<def::Def>)\n+                   opt_def: Option<Def>)\n                    -> Self\n     {\n         match ty.sty {\n@@ -627,7 +627,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.tcx().map.node_to_string(id).to_string()\n     }\n \n-    pub fn def(&self, nid: ast::NodeId) -> def::Def {\n+    pub fn def(&self, nid: ast::NodeId) -> Def {\n         match self.tcx().def_map.borrow().get(&nid) {\n             Some(v) => v.full_def(),\n             None => {"}, {"sha": "2011f1b5352f1e6552761059fe80b059b49d6626", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -13,7 +13,7 @@ use back::abi;\n use llvm;\n use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n-use middle::{check_const, def};\n+use middle::check_const;\n use middle::cstore::LOCAL_CRATE;\n use middle::const_eval::{self, ConstVal, ConstEvalErr};\n use middle::const_eval::{const_int_checked_neg, const_uint_checked_neg};\n@@ -26,6 +26,7 @@ use middle::const_eval::{const_int_checked_shl, const_uint_checked_shl};\n use middle::const_eval::{const_int_checked_shr, const_uint_checked_shr};\n use middle::const_eval::EvalHint::ExprTypeChecked;\n use middle::const_eval::eval_const_expr_partial;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n@@ -297,7 +298,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // of just to get the `def` value\n         let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n         match def {\n-            def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n+            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                 if !ccx.tcx().tables.borrow().adjustments.contains_key(&expr.id) {\n                     debug!(\"get_const_expr_as_global ({:?}): found const {:?}\",\n                            expr.id, def_id);\n@@ -792,7 +793,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n             let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n-            if let Some(def::DefStatic(def_id, _)) = opt_def {\n+            if let Some(Def::Static(def_id, _)) = opt_def {\n                 common::get_static_val(cx, def_id, ety)\n             } else {\n                 // If this isn't the address of a static, then keep going through\n@@ -881,20 +882,20 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprPath(..) => {\n             let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n-                def::DefLocal(_, id) => {\n+                Def::Local(_, id) => {\n                     if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n                         val\n                     } else {\n                         cx.sess().span_bug(e.span, \"const fn argument not found\")\n                     }\n                 }\n-                def::DefFn(..) | def::DefMethod(..) => {\n+                Def::Fn(..) | Def::Method(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n-                def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n+                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     const_deref_ptr(cx, try!(get_const_val(cx, def_id, e, param_substs)))\n                 }\n-                def::DefVariant(enum_did, variant_did, _) => {\n+                Def::Variant(enum_did, variant_did) => {\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     match vinfo.kind() {\n                         ty::VariantKind::Unit => {\n@@ -909,7 +910,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         }\n                     }\n                 }\n-                def::DefStruct(_) => {\n+                Def::Struct(..) => {\n                     if let ty::TyBareFn(..) = ety.sty {\n                         // Tuple struct.\n                         expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -938,7 +939,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n             let arg_vals = try!(map_list(args));\n             match def {\n-                def::DefFn(did, _) | def::DefMethod(did) => {\n+                Def::Fn(did) | Def::Method(did) => {\n                     try!(const_fn_call(\n                         cx,\n                         ExprId(callee.id),\n@@ -948,15 +949,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         trueconst,\n                     ))\n                 }\n-                def::DefStruct(_) => {\n+                Def::Struct(..) => {\n                     if ety.is_simd() {\n                         C_vector(&arg_vals[..])\n                     } else {\n                         let repr = adt::represent_type(cx, ety);\n                         adt::trans_const(cx, &*repr, Disr(0), &arg_vals[..])\n                     }\n                 }\n-                def::DefVariant(enum_did, variant_did, _) => {\n+                Def::Variant(enum_did, variant_did) => {\n                     let repr = adt::represent_type(cx, ety);\n                     let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     adt::trans_const(cx,"}, {"sha": "fc3bd4f4d02330de8d693f339bb33b713d05849c", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use middle::def;\n+use middle::def::Def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n use trans::base::*;\n use trans::basic_block::BasicBlock;\n@@ -322,7 +322,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n             match bcx.tcx().def_map.borrow().get(&expr.id).map(|d| d.full_def())  {\n-                Some(def::DefLabel(loop_id)) => loop_id,\n+                Some(Def::Label(loop_id)) => loop_id,\n                 r => {\n                     bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\", r))\n                 }"}, {"sha": "60afcaa0fbfd7e2afa489360d9a7c8168d05c84b", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -54,7 +54,7 @@ use self::lazy_binop_ty::*;\n use back::abi;\n use llvm::{self, ValueRef, TypeKind};\n use middle::check_const;\n-use middle::def;\n+use middle::def::Def;\n use middle::lang_items::CoerceUnsizedTraitLangItem;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::traits;\n@@ -165,7 +165,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match expr.node {\n                 hir::ExprPath(..) => {\n                     match bcx.def(expr.id) {\n-                        def::DefConst(did) => {\n+                        Def::Const(did) => {\n                             let empty_substs = bcx.tcx().mk_substs(Substs::trans_empty());\n                             let const_expr = consts::get_const_expr(bcx.ccx(), did, expr,\n                                                                     empty_substs);\n@@ -903,25 +903,25 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                          ref_expr: &hir::Expr,\n-                         def: def::Def)\n+                         def: Def)\n                          -> DatumBlock<'blk, 'tcx, Expr> {\n     //! Translates a reference to a path.\n \n     let _icx = push_ctxt(\"trans_def_lvalue\");\n     match def {\n-        def::DefFn(..) | def::DefMethod(..) |\n-        def::DefStruct(_) | def::DefVariant(..) => {\n+        Def::Fn(..) | Def::Method(..) |\n+        Def::Struct(..) | Def::Variant(..) => {\n             let datum = trans_def_fn_unadjusted(bcx.ccx(), ref_expr, def,\n                                                 bcx.fcx.param_substs);\n             DatumBlock::new(bcx, datum.to_expr_datum())\n         }\n-        def::DefStatic(did, _) => {\n+        Def::Static(did, _) => {\n             let const_ty = expr_ty(bcx, ref_expr);\n             let val = get_static_val(bcx.ccx(), did, const_ty);\n             let lval = Lvalue::new(\"expr::trans_def\");\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr(lval)))\n         }\n-        def::DefConst(_) => {\n+        Def::Const(_) => {\n             bcx.sess().span_bug(ref_expr.span,\n                 \"constant expression should not reach expr::trans_def\")\n         }\n@@ -1272,7 +1272,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         ref_expr: &hir::Expr,\n-                                        def: def::Def,\n+                                        def: Def,\n                                         dest: Dest)\n                                         -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_def_dps_unadjusted\");\n@@ -1283,7 +1283,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n \n     match def {\n-        def::DefVariant(tid, vid, _) => {\n+        Def::Variant(tid, vid) => {\n             let variant = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n             if let ty::VariantKind::Tuple = variant.kind() {\n                 // N-ary variant.\n@@ -1300,7 +1300,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 return bcx;\n             }\n         }\n-        def::DefStruct(_) => {\n+        Def::Struct(..) => {\n             let ty = expr_ty(bcx, ref_expr);\n             match ty.sty {\n                 ty::TyStruct(def, _) if def.has_dtor() => {\n@@ -1321,17 +1321,17 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          ref_expr: &hir::Expr,\n-                                         def: def::Def,\n+                                         def: Def,\n                                          param_substs: &'tcx Substs<'tcx>)\n                                          -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     match def {\n-        def::DefFn(did, _) |\n-        def::DefStruct(did) | def::DefVariant(_, did, _) => {\n+        Def::Fn(did) |\n+        Def::Struct(did) | Def::Variant(_, did) => {\n             callee::trans_fn_ref(ccx, did, ExprId(ref_expr.id), param_substs)\n         }\n-        def::DefMethod(method_did) => {\n+        Def::Method(method_did) => {\n             match ccx.tcx().impl_or_trait_item(method_did).container() {\n                 ty::ImplContainer(_) => {\n                     callee::trans_fn_ref(ccx, method_did,\n@@ -1356,12 +1356,12 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n /// Translates a reference to a local variable or argument. This always results in an lvalue datum.\n pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   def: def::Def)\n+                                   def: Def)\n                                    -> Datum<'tcx, Lvalue> {\n     let _icx = push_ctxt(\"trans_local_var\");\n \n     match def {\n-        def::DefUpvar(_, nid, _, _) => {\n+        Def::Upvar(_, nid, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n             let lval = Lvalue::new_with_hint(\"expr::trans_local_var (upvar)\",\n@@ -1375,7 +1375,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             }\n         }\n-        def::DefLocal(_, nid) => {\n+        Def::Local(_, nid) => {\n             let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n@@ -2587,7 +2587,7 @@ fn expr_kind(tcx: &ty::ctxt, expr: &hir::Expr) -> ExprKind {\n     match expr.node {\n         hir::ExprPath(..) => {\n             match tcx.resolve_expr(expr) {\n-                def::DefStruct(_) | def::DefVariant(..) => {\n+                Def::Struct(..) | Def::Variant(..) => {\n                     if let ty::TyBareFn(..) = tcx.node_id_to_type(expr.id).sty {\n                         // ctor function\n                         ExprKind::RvalueDatum\n@@ -2596,24 +2596,18 @@ fn expr_kind(tcx: &ty::ctxt, expr: &hir::Expr) -> ExprKind {\n                     }\n                 }\n \n-                // Special case: A unit like struct's constructor must be called without () at the\n-                // end (like `UnitStruct`) which means this is an ExprPath to a DefFn. But in case\n-                // of unit structs this is should not be interpreted as function pointer but as\n-                // call to the constructor.\n-                def::DefFn(_, true) => ExprKind::RvalueDps,\n-\n                 // Fn pointers are just scalar values.\n-                def::DefFn(..) | def::DefMethod(..) => ExprKind::RvalueDatum,\n+                Def::Fn(..) | Def::Method(..) => ExprKind::RvalueDatum,\n \n                 // Note: there is actually a good case to be made that\n                 // DefArg's, particularly those of immediate type, ought to\n                 // considered rvalues.\n-                def::DefStatic(..) |\n-                def::DefUpvar(..) |\n-                def::DefLocal(..) => ExprKind::Lvalue,\n+                Def::Static(..) |\n+                Def::Upvar(..) |\n+                Def::Local(..) => ExprKind::Lvalue,\n \n-                def::DefConst(..) |\n-                def::DefAssociatedConst(..) => ExprKind::RvalueDatum,\n+                Def::Const(..) |\n+                Def::AssociatedConst(..) => ExprKind::RvalueDatum,\n \n                 def => {\n                     tcx.sess.span_bug("}, {"sha": "da4265dda54d7867b0db55fa47138a3f7c95ff0b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -51,7 +51,7 @@\n use middle::astconv_util::{prim_ty_to_ty, prohibit_type_params, prohibit_projection};\n use middle::const_eval::{self, ConstVal};\n use middle::const_eval::EvalHint::UncheckedExprHint;\n-use middle::def;\n+use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n@@ -718,8 +718,8 @@ pub fn instantiate_mono_trait_ref<'tcx>(\n fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &hir::TraitRef) -> DefId {\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n-        def::DefTrait(trait_def_id) => trait_def_id,\n-        def::DefErr => {\n+        Def::Trait(trait_def_id) => trait_def_id,\n+        Def::Err => {\n             this.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n         }\n         _ => {\n@@ -1028,7 +1028,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                 _ => None\n             };\n             match def {\n-                Some(def::DefTrait(trait_def_id)) => {\n+                Some(Def::Trait(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n                     let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                   rscope,\n@@ -1263,9 +1263,9 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    span: Span,\n                                    ty: Ty<'tcx>,\n-                                   ty_path_def: def::Def,\n+                                   ty_path_def: Def,\n                                    item_segment: &hir::PathSegment)\n-                                   -> (Ty<'tcx>, def::Def)\n+                                   -> (Ty<'tcx>, Def)\n {\n     let tcx = this.tcx();\n     let assoc_name = item_segment.identifier.name;\n@@ -1277,7 +1277,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     // Find the type of the associated item, and the trait where the associated\n     // item is declared.\n     let bound = match (&ty.sty, ty_path_def) {\n-        (_, def::DefSelfTy(Some(trait_did), Some((impl_id, _)))) => {\n+        (_, Def::SelfTy(Some(trait_did), Some((impl_id, _)))) => {\n             // `Self` in an impl of a trait - we have a concrete self type and a\n             // trait reference.\n             let trait_ref = tcx.impl_trait_ref(tcx.map.local_def_id(impl_id)).unwrap();\n@@ -1306,7 +1306,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n             }\n         }\n-        (&ty::TyParam(_), def::DefSelfTy(Some(trait_did), None)) => {\n+        (&ty::TyParam(_), Def::SelfTy(Some(trait_did), None)) => {\n             let trait_node_id = tcx.map.as_local_node_id(trait_did).unwrap();\n             match find_bound_for_assoc_item(this,\n                                             trait_node_id,\n@@ -1317,7 +1317,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 Err(ErrorReported) => return (tcx.types.err, ty_path_def),\n             }\n         }\n-        (&ty::TyParam(_), def::DefTyParam(_, _, param_did, param_name)) => {\n+        (&ty::TyParam(_), Def::TyParam(_, _, param_did, param_name)) => {\n             let param_node_id = tcx.map.as_local_node_id(param_did).unwrap();\n             match find_bound_for_assoc_item(this,\n                                             param_node_id,\n@@ -1359,7 +1359,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         item.expect(\"missing associated type\").def_id()\n     };\n \n-    (ty, def::DefAssociatedTy(trait_did, item_did))\n+    (ty, Def::AssociatedTy(trait_did, item_did))\n }\n \n fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n@@ -1443,14 +1443,14 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         rscope: &RegionScope,\n                         span: Span,\n                         param_mode: PathParamMode,\n-                        def: &def::Def,\n+                        def: &Def,\n                         opt_self_ty: Option<Ty<'tcx>>,\n                         base_segments: &[hir::PathSegment])\n                         -> Ty<'tcx> {\n     let tcx = this.tcx();\n \n     match *def {\n-        def::DefTrait(trait_def_id) => {\n+        Def::Trait(trait_def_id) => {\n             // N.B. this case overlaps somewhat with\n             // TyObjectSum, see that fn for details\n             let mut projection_bounds = Vec::new();\n@@ -1471,7 +1471,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                      projection_bounds,\n                                      &[])\n         }\n-        def::DefTy(did, _) | def::DefStruct(did) => {\n+        Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) => {\n             prohibit_type_params(tcx, base_segments.split_last().unwrap().1);\n             ast_path_to_ty(this,\n                            rscope,\n@@ -1480,11 +1480,11 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                            did,\n                            base_segments.last().unwrap())\n         }\n-        def::DefTyParam(space, index, _, name) => {\n+        Def::TyParam(space, index, _, name) => {\n             prohibit_type_params(tcx, base_segments);\n             tcx.mk_param(space, index, name)\n         }\n-        def::DefSelfTy(_, Some((_, self_ty_id))) => {\n+        Def::SelfTy(_, Some((_, self_ty_id))) => {\n             // Self in impl (we know the concrete type).\n             prohibit_type_params(tcx, base_segments);\n             if let Some(&ty) = tcx.ast_ty_to_ty_cache.borrow().get(&self_ty_id) {\n@@ -1497,12 +1497,12 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 tcx.sess.span_bug(span, \"self type has not been fully resolved\")\n             }\n         }\n-        def::DefSelfTy(Some(_), None) => {\n+        Def::SelfTy(Some(_), None) => {\n             // Self in trait.\n             prohibit_type_params(tcx, base_segments);\n             tcx.mk_self_type()\n         }\n-        def::DefAssociatedTy(trait_did, _) => {\n+        Def::AssociatedTy(trait_did, _) => {\n             prohibit_type_params(tcx, &base_segments[..base_segments.len()-2]);\n             qpath_to_ty(this,\n                         rscope,\n@@ -1513,7 +1513,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         &base_segments[base_segments.len()-2],\n                         base_segments.last().unwrap())\n         }\n-        def::DefMod(id) => {\n+        Def::Mod(id) => {\n             // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n             // FIXME(#22519) This part of the resolution logic should be\n             // avoided entirely for that form, once we stop needed a Def\n@@ -1534,10 +1534,10 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n             opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n         }\n-        def::DefPrimTy(prim_ty) => {\n+        Def::PrimTy(prim_ty) => {\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n-        def::DefErr => {\n+        Def::Err => {\n             return this.tcx().types.err;\n         }\n         _ => {\n@@ -1556,7 +1556,7 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                         rscope: &RegionScope,\n                                         span: Span,\n                                         param_mode: PathParamMode,\n-                                        def: &def::Def,\n+                                        def: &Def,\n                                         opt_self_ty: Option<Ty<'tcx>>,\n                                         base_segments: &[hir::PathSegment],\n                                         assoc_segments: &[hir::PathSegment])\n@@ -1658,7 +1658,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n             } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n+                    base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n@@ -2177,7 +2177,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n                 match ::lookup_full_def(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n-                    def::DefTrait(trait_did) => {\n+                    Def::Trait(trait_did) => {\n                         if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {\n                             let segments = &b.trait_ref.path.segments;"}, {"sha": "c43349f88104dd149522bcc6ee8f994db4cf2a54", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::def;\n+use middle::def::{self, Def};\n use middle::infer::{self, TypeOrigin};\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding};\n use middle::pat_util::pat_is_resolved_const;\n@@ -214,7 +214,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         hir::PatQPath(ref qself, ref path) => {\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n-                if d.base_def == def::DefErr {\n+                if d.base_def == Def::Err {\n                     fcx.write_error(pat.id);\n                     return;\n                 }\n@@ -223,7 +223,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                 // This is just a sentinel for finish_resolving_def_to_ty.\n                 let sentinel = fcx.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n-                    base_def: def::DefMod(sentinel),\n+                    base_def: Def::Mod(sentinel),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n@@ -410,10 +410,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     // subtyping.\n }\n \n-fn check_assoc_item_is_const(pcx: &pat_ctxt, def: def::Def, span: Span) -> bool {\n+fn check_assoc_item_is_const(pcx: &pat_ctxt, def: Def, span: Span) -> bool {\n     match def {\n-        def::DefAssociatedConst(..) => true,\n-        def::DefMethod(..) => {\n+        Def::AssociatedConst(..) => true,\n+        Def::Method(..) => {\n             span_err!(pcx.fcx.ccx.tcx.sess, span, E0327,\n                       \"associated items in match patterns must be constants\");\n             false\n@@ -616,7 +616,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let path_res = match tcx.def_map.borrow().get(&pat.id) {\n-        Some(&path_res) if path_res.base_def != def::DefErr => path_res,\n+        Some(&path_res) if path_res.base_def != Def::Err => path_res,\n         _ => {\n             fcx.write_error(pat.id);\n \n@@ -693,10 +693,12 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n     let real_path_ty = fcx.node_ty(pat.id);\n     let (arg_tys, kind_name): (Vec<_>, &'static str) = match real_path_ty.sty {\n-        ty::TyEnum(enum_def, expected_substs)\n-            if def == def::DefVariant(enum_def.did, def.def_id(), false) =>\n-        {\n+        ty::TyEnum(enum_def, expected_substs) => {\n             let variant = enum_def.variant_of_def(def);\n+            if variant.kind() == ty::VariantKind::Struct {\n+                report_bad_struct_kind(false);\n+                return;\n+            }\n             if is_tuple_struct_pat && variant.kind() != ty::VariantKind::Tuple {\n                 // Matching unit variants with tuple variant patterns (`UnitVariant(..)`)\n                 // is allowed for backward compatibility."}, {"sha": "84c436c59c1d29b35b3b9137ff1a606d9db96a0d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -26,7 +26,7 @@ use super::write_call;\n \n use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::infer;\n use middle::ty::{self, LvaluePreference, Ty};\n@@ -236,7 +236,7 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             if let hir::ExprCall(ref expr, _) = call_expr.node {\n                 let tcx = fcx.tcx();\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n-                    if pr.depth == 0 && pr.base_def != def::DefErr {\n+                    if pr.depth == 0 && pr.base_def != Def::Err {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n                             err.span_note(span, \"defined here\");\n                         }"}, {"sha": "fc2dd4475e3ffabf135a56b5fb95ac42b8427a70", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -12,7 +12,7 @@\n \n use astconv::AstConv;\n use check::FnCtxt;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n@@ -334,7 +334,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               method_name: ast::Name,\n                               self_ty: ty::Ty<'tcx>,\n                               expr_id: ast::NodeId)\n-                              -> Result<(def::Def, LastPrivate), MethodError<'tcx>>\n+                              -> Result<(Def, LastPrivate), MethodError<'tcx>>\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));\n@@ -346,8 +346,8 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n     let def_result = match pick.item {\n-        ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id),\n-        ty::ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id),\n+        ty::ImplOrTraitItem::MethodTraitItem(..) => Def::Method(def_id),\n+        ty::ImplOrTraitItem::ConstTraitItem(..) => Def::AssociatedConst(def_id),\n         ty::ImplOrTraitItem::TypeTraitItem(..) => {\n             fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n         }"}, {"sha": "21bf67d2d5c7529e911c0d9d4832bfe675d64410", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -18,7 +18,7 @@ use check::{self, FnCtxt};\n use front::map as hir_map;\n use middle::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use middle::cstore::{self, CrateStore, DefLike};\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use middle::subst::Substs;\n@@ -432,10 +432,10 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                                cstore: &for<'a> cstore::CrateStore<'a>,\n                                dl: cstore::DefLike) {\n             match dl {\n-                cstore::DlDef(def::DefTrait(did)) => {\n+                cstore::DlDef(Def::Trait(did)) => {\n                     traits.push(TraitInfo::new(did));\n                 }\n-                cstore::DlDef(def::DefMod(did)) => {\n+                cstore::DlDef(Def::Mod(did)) => {\n                     if !external_mods.insert(did) {\n                         return;\n                     }"}, {"sha": "f49b25df66e872341bcb0cbd79ce33cc6c82846b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -86,7 +86,7 @@ use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n use middle::astconv_util::prohibit_type_params;\n use middle::cstore::LOCAL_CRATE;\n-use middle::def;\n+use middle::def::{self, Def};\n use middle::def_id::DefId;\n use middle::infer;\n use middle::infer::{TypeOrigin, type_variable};\n@@ -1416,16 +1416,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Return the dict-like variant corresponding to a given `Def`.\n     pub fn def_struct_variant(&self,\n-                              def: def::Def,\n+                              def: Def,\n                               span: Span)\n                               -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n     {\n         let (adt, variant) = match def {\n-            def::DefVariant(enum_id, variant_id, _) => {\n+            Def::Variant(enum_id, variant_id) => {\n                 let adt = self.tcx().lookup_adt_def(enum_id);\n                 (adt, adt.variant_with_id(variant_id))\n             }\n-            def::DefTy(did, _) | def::DefStruct(did) => {\n+            Def::Struct(did) | Def::TyAlias(did) => {\n                 let typ = self.tcx().lookup_item_type(did);\n                 if let ty::TyStruct(adt, _) = typ.ty.sty {\n                     (adt, adt.struct_variant())\n@@ -3167,7 +3167,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n-        if def == def::DefErr {\n+        if def == Def::Err {\n             check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n             return;\n         }\n@@ -3337,7 +3337,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           } else if let Some(hir::QSelf { position: 0, .. }) = *maybe_qself {\n                 // Create some fake resolution that can't possibly be a type.\n                 def::PathResolution {\n-                    base_def: def::DefMod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n+                    base_def: Def::Mod(tcx.map.local_def_id(ast::CRATE_NODE_ID)),\n                     last_private: LastMod(AllPublic),\n                     depth: path.segments.len()\n                 }\n@@ -3349,7 +3349,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           if let Some((opt_ty, segments, def)) =\n                   resolve_ty_and_def_ufcs(fcx, path_res, opt_self_ty, path,\n                                           expr.span, expr.id) {\n-              if def != def::DefErr {\n+              if def != Def::Err {\n                   let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx,\n                                                                                 expr.span,\n                                                                                 def);\n@@ -3758,7 +3758,7 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n                                              node_id: ast::NodeId)\n                                              -> Option<(Option<Ty<'tcx>>,\n                                                         &'a [hir::PathSegment],\n-                                                        def::Def)>\n+                                                        Def)>\n {\n \n     // If fully resolved already, we don't have to do anything.\n@@ -4263,29 +4263,30 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n // Returns the type parameter count and the type for the given definition.\n fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 sp: Span,\n-                                                defn: def::Def)\n+                                                defn: Def)\n                                                 -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n     match defn {\n-        def::DefLocal(_, nid) | def::DefUpvar(_, nid, _, _) => {\n+        Def::Local(_, nid) | Def::Upvar(_, nid, _, _) => {\n             let typ = fcx.local_ty(sp, nid);\n             (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n              ty::GenericPredicates::empty())\n         }\n-        def::DefFn(id, _) | def::DefMethod(id) |\n-        def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-        def::DefStruct(id) | def::DefConst(id) | def::DefAssociatedConst(id) => {\n+        Def::Fn(id) | Def::Method(id) |\n+        Def::Static(id, _) | Def::Variant(_, id) |\n+        Def::Struct(id) | Def::Const(id) | Def::AssociatedConst(id) => {\n             (fcx.tcx().lookup_item_type(id), fcx.tcx().lookup_predicates(id))\n         }\n-        def::DefTrait(_) |\n-        def::DefTy(..) |\n-        def::DefAssociatedTy(..) |\n-        def::DefPrimTy(_) |\n-        def::DefTyParam(..) |\n-        def::DefMod(..) |\n-        def::DefForeignMod(..) |\n-        def::DefLabel(..) |\n-        def::DefSelfTy(..) |\n-        def::DefErr => {\n+        Def::Trait(_) |\n+        Def::Enum(..) |\n+        Def::TyAlias(..) |\n+        Def::AssociatedTy(..) |\n+        Def::PrimTy(_) |\n+        Def::TyParam(..) |\n+        Def::Mod(..) |\n+        Def::ForeignMod(..) |\n+        Def::Label(..) |\n+        Def::SelfTy(..) |\n+        Def::Err => {\n             fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n         }\n     }\n@@ -4298,7 +4299,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   type_scheme: TypeScheme<'tcx>,\n                                   type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n-                                  def: def::Def,\n+                                  def: Def,\n                                   span: Span,\n                                   node_id: ast::NodeId) {\n     debug!(\"instantiate_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n@@ -4382,30 +4383,31 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n-        def::DefSelfTy(..) |\n-        def::DefStruct(..) |\n-        def::DefVariant(..) |\n-        def::DefTy(..) |\n-        def::DefAssociatedTy(..) |\n-        def::DefTrait(..) |\n-        def::DefPrimTy(..) |\n-        def::DefTyParam(..) => {\n+        Def::SelfTy(..) |\n+        Def::Struct(..) |\n+        Def::Variant(..) |\n+        Def::Enum(..) |\n+        Def::TyAlias(..) |\n+        Def::AssociatedTy(..) |\n+        Def::Trait(..) |\n+        Def::PrimTy(..) |\n+        Def::TyParam(..) => {\n             // Everything but the final segment should have no\n             // parameters at all.\n             segment_spaces = vec![None; segments.len() - 1];\n             segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n         // Case 2. Reference to a top-level value.\n-        def::DefFn(..) |\n-        def::DefConst(..) |\n-        def::DefStatic(..) => {\n+        Def::Fn(..) |\n+        Def::Const(..) |\n+        Def::Static(..) => {\n             segment_spaces = vec![None; segments.len() - 1];\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n \n         // Case 3. Reference to a method.\n-        def::DefMethod(def_id) => {\n+        Def::Method(def_id) => {\n             let container = fcx.tcx().impl_or_trait_item(def_id).container();\n             match container {\n                 ty::TraitContainer(trait_did) => {\n@@ -4426,7 +4428,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n-        def::DefAssociatedConst(def_id) => {\n+        Def::AssociatedConst(def_id) => {\n             let container = fcx.tcx().impl_or_trait_item(def_id).container();\n             match container {\n                 ty::TraitContainer(trait_did) => {\n@@ -4450,12 +4452,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Other cases. Various nonsense that really shouldn't show up\n         // here. If they do, an error will have been reported\n         // elsewhere. (I hope)\n-        def::DefMod(..) |\n-        def::DefForeignMod(..) |\n-        def::DefLocal(..) |\n-        def::DefLabel(..) |\n-        def::DefUpvar(..) |\n-        def::DefErr => {\n+        Def::Mod(..) |\n+        Def::ForeignMod(..) |\n+        Def::Local(..) |\n+        Def::Label(..) |\n+        Def::Upvar(..) |\n+        Def::Err => {\n             segment_spaces = vec![None; segments.len()];\n         }\n     }\n@@ -4856,7 +4858,7 @@ pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &hir::Block) -> bool {\n     // <id> nested anywhere inside the loop?\n     (block_query(b, |e| {\n         if let hir::ExprBreak(Some(_)) = e.node {\n-            lookup_full_def(cx, e.span, e.id) == def::DefLabel(id)\n+            lookup_full_def(cx, e.span, e.id) == Def::Label(id)\n         } else {\n             false\n         }"}, {"sha": "0e095ed674d0e18080a5130c98edfbea2c734ef1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -60,7 +60,7 @@ There are some shortcomings in this design:\n \n use astconv::{self, AstConv, ty_of_arg, ast_ty_to_ty, ast_region_to_region};\n use lint;\n-use middle::def;\n+use middle::def::Def;\n use middle::def_id::DefId;\n use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n@@ -512,10 +512,10 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if let hir::TyPath(None, _) = ast_ty.node {\n         let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n-            def::DefSelfTy(Some(def_id), None) => {\n+            Def::SelfTy(Some(def_id), None) => {\n                 path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n             }\n-            def::DefTyParam(_, _, def_id, _) => {\n+            Def::TyParam(_, _, def_id, _) => {\n                 path_res.depth == 0 && def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => {\n@@ -1007,11 +1007,7 @@ fn convert_struct_variant<'tcx>(tcx: &ty::ctxt<'tcx>,\n         name: name,\n         disr_val: disr_val,\n         fields: fields,\n-        kind: match *def {\n-            hir::VariantData::Struct(..) => ty::VariantKind::Struct,\n-            hir::VariantData::Tuple(..) => ty::VariantKind::Tuple,\n-            hir::VariantData::Unit(..) => ty::VariantKind::Unit,\n-        }\n+        kind: VariantKind::from_variant_data(def),\n     }\n }\n "}, {"sha": "17d71fa7be9a6b38d585e7d36c978176928e639f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -100,7 +100,7 @@ pub use rustc::session;\n pub use rustc::util;\n \n use front::map as hir_map;\n-use middle::def;\n+use middle::def::Def;\n use middle::infer::{self, TypeOrigin};\n use middle::subst;\n use middle::ty::{self, Ty, TypeFoldable};\n@@ -162,7 +162,7 @@ fn write_substs_to_tcx<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n-fn lookup_full_def(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n+fn lookup_full_def(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) -> Def {\n     match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.full_def(),\n         None => {"}, {"sha": "9eac2fd41fa1e3a5863979d1a250b12dbe4fa8e2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -17,7 +17,7 @@ use syntax::attr::AttrMetaMethods;\n use rustc_front::hir;\n \n use rustc::middle::cstore::{self, CrateStore};\n-use rustc::middle::def;\n+use rustc::middle::def::Def;\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty;\n use rustc::middle::subst;\n@@ -68,46 +68,47 @@ pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n }\n \n fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n-                  def: def::Def) -> Option<Vec<clean::Item>> {\n+                  def: Def) -> Option<Vec<clean::Item>> {\n     let mut ret = Vec::new();\n     let did = def.def_id();\n     let inner = match def {\n-        def::DefTrait(did) => {\n+        Def::Trait(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n             clean::TraitItem(build_external_trait(cx, tcx, did))\n         }\n-        def::DefFn(did, false) => {\n-            // If this function is a tuple struct constructor, we just skip it\n+        Def::Fn(did) => {\n             record_extern_fqn(cx, did, clean::TypeFunction);\n             clean::FunctionItem(build_external_function(cx, tcx, did))\n         }\n-        def::DefStruct(did) => {\n+        Def::Struct(did)\n+                // If this is a struct constructor, we skip it\n+                if tcx.sess.cstore.tuple_struct_definition_if_ctor(did).is_none() => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n             ret.extend(build_impls(cx, tcx, did));\n             clean::StructItem(build_struct(cx, tcx, did))\n         }\n-        def::DefTy(did, false) => {\n+        Def::TyAlias(did) => {\n             record_extern_fqn(cx, did, clean::TypeTypedef);\n             ret.extend(build_impls(cx, tcx, did));\n             build_type(cx, tcx, did)\n         }\n-        def::DefTy(did, true) => {\n+        Def::Enum(did) => {\n             record_extern_fqn(cx, did, clean::TypeEnum);\n             ret.extend(build_impls(cx, tcx, did));\n             build_type(cx, tcx, did)\n         }\n         // Assume that the enum type is reexported next to the variant, and\n         // variants don't show up in documentation specially.\n-        def::DefVariant(..) => return Some(Vec::new()),\n-        def::DefMod(did) => {\n+        Def::Variant(..) => return Some(Vec::new()),\n+        Def::Mod(did) => {\n             record_extern_fqn(cx, did, clean::TypeModule);\n             clean::ModuleItem(build_module(cx, tcx, did))\n         }\n-        def::DefStatic(did, mtbl) => {\n+        Def::Static(did, mtbl) => {\n             record_extern_fqn(cx, did, clean::TypeStatic);\n             clean::StaticItem(build_static(cx, tcx, did, mtbl))\n         }\n-        def::DefConst(did) | def::DefAssociatedConst(did) => {\n+        Def::Const(did) | Def::AssociatedConst(did) => {\n             record_extern_fqn(cx, did, clean::TypeConst);\n             clean::ConstantItem(build_const(cx, tcx, did))\n         }\n@@ -258,7 +259,7 @@ pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n                           impls: &mut Vec<clean::Item>) {\n             match def {\n                 cstore::DlImpl(did) => build_impl(cx, tcx, did, impls),\n-                cstore::DlDef(def::DefMod(did)) => {\n+                cstore::DlDef(Def::Mod(did)) => {\n                     for item in tcx.sess.cstore.item_children(did) {\n                         populate_impls(cx, tcx, item.def, impls)\n                     }\n@@ -455,7 +456,7 @@ fn build_module(cx: &DocContext, tcx: &ty::ctxt,\n         let mut visited = HashSet::new();\n         for item in tcx.sess.cstore.item_children(did) {\n             match item.def {\n-                cstore::DlDef(def::DefForeignMod(did)) => {\n+                cstore::DlDef(Def::ForeignMod(did)) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n                 cstore::DlDef(def) if item.vis == hir::Public => {"}, {"sha": "03e2a7139b278c03c8ff67488a47998a94fc77e9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -36,7 +36,7 @@ use syntax::ptr::P;\n \n use rustc_trans::back::link;\n use rustc::middle::cstore::{self, CrateStore};\n-use rustc::middle::def;\n+use rustc::middle::def::Def;\n use rustc::middle::def_id::{DefId, DefIndex};\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n@@ -230,7 +230,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         cx.tcx_opt().map(|tcx| {\n             for item in tcx.sess.cstore.crate_top_level_items(self.0) {\n                 let did = match item.def {\n-                    cstore::DlDef(def::DefMod(did)) => did,\n+                    cstore::DlDef(Def::Mod(did)) => did,\n                     _ => continue\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n@@ -2607,7 +2607,7 @@ fn resolve_type(cx: &DocContext,\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n-        def::DefPrimTy(p) => match p {\n+        Def::PrimTy(p) => match p {\n             hir::TyStr => return Primitive(Str),\n             hir::TyBool => return Primitive(Bool),\n             hir::TyChar => return Primitive(Char),\n@@ -2624,30 +2624,30 @@ fn resolve_type(cx: &DocContext,\n             hir::TyFloat(ast::TyF32) => return Primitive(F32),\n             hir::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n-        def::DefSelfTy(..) if path.segments.len() == 1 => {\n+        Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(special_idents::type_self.name.to_string());\n         }\n-        def::DefSelfTy(..) | def::DefTyParam(..) => true,\n+        Def::SelfTy(..) | Def::TyParam(..) => true,\n         _ => false,\n     };\n     let did = register_def(&*cx, def);\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-fn register_def(cx: &DocContext, def: def::Def) -> DefId {\n+fn register_def(cx: &DocContext, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n-        def::DefFn(i, _) => (i, TypeFunction),\n-        def::DefTy(i, false) => (i, TypeTypedef),\n-        def::DefTy(i, true) => (i, TypeEnum),\n-        def::DefTrait(i) => (i, TypeTrait),\n-        def::DefStruct(i) => (i, TypeStruct),\n-        def::DefMod(i) => (i, TypeModule),\n-        def::DefStatic(i, _) => (i, TypeStatic),\n-        def::DefVariant(i, _, _) => (i, TypeEnum),\n-        def::DefSelfTy(Some(def_id), _) => (def_id, TypeTrait),\n-        def::DefSelfTy(_, Some((impl_id, _))) => return cx.map.local_def_id(impl_id),\n+        Def::Fn(i) => (i, TypeFunction),\n+        Def::TyAlias(i) => (i, TypeTypedef),\n+        Def::Enum(i) => (i, TypeEnum),\n+        Def::Trait(i) => (i, TypeTrait),\n+        Def::Struct(i) => (i, TypeStruct),\n+        Def::Mod(i) => (i, TypeModule),\n+        Def::Static(i, _) => (i, TypeStatic),\n+        Def::Variant(i, _) => (i, TypeEnum),\n+        Def::SelfTy(Some(def_id), _) => (def_id, TypeTrait),\n+        Def::SelfTy(_, Some((impl_id, _))) => return cx.map.local_def_id(impl_id),\n         _ => return def.def_id()\n     };\n     if did.is_local() { return did }"}, {"sha": "61e4a1ea3975ccd9d2f966421bd4ef2a92ad871d", "filename": "src/test/compile-fail/empty-struct-braces-expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-expr.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -29,9 +29,8 @@ fn main() {\n     let e3 = E::Empty3; //~ ERROR `E::Empty3` is the name of a struct or struct variant\n     let e3 = E::Empty3(); //~ ERROR `E::Empty3` is the name of a struct or struct variant\n \n-    // FIXME: non-local struct kind should be known early (e.g. kept in `DefStruct`)\n-    // let xe1 = XEmpty1; // ERROR `XEmpty1` is the name of a struct or struct variant\n-    let xe1 = XEmpty1(); //~ ERROR expected function, found `empty_struct::XEmpty1`\n+    let xe1 = XEmpty1; //~ ERROR `XEmpty1` is the name of a struct or struct variant\n+    let xe1 = XEmpty1(); //~ ERROR `XEmpty1` is the name of a struct or struct variant\n     let xe3 = XE::Empty3; //~ ERROR no associated item named `Empty3` found for type\n     let xe3 = XE::Empty3(); //~ ERROR no associated item named `Empty3` found for type\n }"}, {"sha": "ac6fbc7e06d5b68d60ff9fe3ad9c2d577904db17", "filename": "src/test/compile-fail/empty-struct-braces-pat-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-struct-braces-pat-2.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -34,6 +34,6 @@ fn main() {\n         Empty1(..) => () //~ ERROR unresolved enum variant, struct or const `Empty1`\n     }\n     match xe1 {\n-        XEmpty1(..) => () //~ ERROR `XEmpty1` does not name a tuple variant or a tuple struct\n+        XEmpty1(..) => () //~ ERROR unresolved enum variant, struct or const `XEmpty1`\n     }\n }"}, {"sha": "708eea39a9571b73dd58d24b5ebc4cd13cef3501", "filename": "src/test/compile-fail/issue-10545.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fissue-10545.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fissue-10545.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10545.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -14,7 +14,7 @@ mod a {\n     impl S { }\n }\n \n-fn foo(_: a::S) { //~ ERROR: type `S` is private\n+fn foo(_: a::S) { //~ ERROR: struct `S` is private\n }\n \n fn main() {}"}, {"sha": "593068c2aea9dcdc2e0b95e88d66fdc8b0036a74", "filename": "src/test/compile-fail/privacy1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivacy1.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -164,7 +164,7 @@ pub mod mytest {\n     // Even though the inner `A` struct is a publicly exported item (usable from\n     // external crates through `foo::foo`, it should not be accessible through\n     // its definition path (which has the private `i` module).\n-    use self::foo::i::A; //~ ERROR: type `A` is inaccessible\n+    use self::foo::i::A; //~ ERROR: struct `A` is inaccessible\n                          //~^ NOTE: module `i` is private\n \n     pub mod foo {"}, {"sha": "2ff48b73e294c415bcb02f51f05046d8dbb02f95", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -28,7 +28,7 @@ mod inner {\n }\n \n fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B) {\n-    //~^ ERROR: type `A` is private\n+    //~^ ERROR: struct `A` is private\n     //~^^ ERROR: struct `A` is private\n \n     a.a;"}, {"sha": "214a2a371baaf63d882403b03dc8b588e511d5e4", "filename": "src/test/compile-fail/xcrate-unit-struct.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fxcrate-unit-struct.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -16,6 +16,7 @@\n extern crate xcrate_unit_struct;\n \n fn main() {\n-    let _ = xcrate_unit_struct::StructWithFields; //~ ERROR: unresolved name\n+    let _ = xcrate_unit_struct::StructWithFields;\n+    //~^ ERROR: `xcrate_unit_struct::StructWithFields` is the name of a struct or struct variant\n     let _ = xcrate_unit_struct::Struct;\n }"}, {"sha": "605ca6b65e2cff94f7077cd8ef9e3609d77ecea2", "filename": "src/test/run-pass/associated-const-match-patterns.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51108b64ca3c84d9973736e6b9e094e79c12dc60/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs?ref=51108b64ca3c84d9973736e6b9e094e79c12dc60", "patch": "@@ -8,8 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// aux-build:empty-struct.rs\n+\n #![feature(associated_consts)]\n \n+extern crate empty_struct;\n+use empty_struct::XEmpty2 as XFoo;\n+\n struct Foo;\n \n enum Bar {\n@@ -30,6 +35,10 @@ impl HasBar for Foo {\n     const THEBAR: Bar = Bar::Var1;\n }\n \n+impl HasBar for XFoo {\n+    const THEBAR: Bar = Bar::Var1;\n+}\n+\n fn main() {\n     // Inherent impl\n     assert!(match Bar::Var2 {\n@@ -53,4 +62,16 @@ fn main() {\n         <Foo as HasBar>::THEBAR => true,\n         _ => false,\n     });\n+    assert!(match Bar::Var1 {\n+        XFoo::THEBAR => true,\n+        _ => false,\n+    });\n+    assert!(match Bar::Var1 {\n+        <XFoo>::THEBAR => true,\n+        _ => false,\n+    });\n+    assert!(match Bar::Var1 {\n+        <XFoo as HasBar>::THEBAR => true,\n+        _ => false,\n+    });\n }"}]}