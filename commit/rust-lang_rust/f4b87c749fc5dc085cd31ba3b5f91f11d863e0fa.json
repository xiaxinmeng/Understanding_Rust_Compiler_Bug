{"sha": "f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0Yjg3Yzc0OWZjNWRjMDg1Y2QzMWJhM2I1ZjkxZjExZDg2M2UwZmE=", "commit": {"author": {"name": "Rob Arnold", "email": "robarnold@cs.cmu.edu", "date": "2011-06-16T05:04:31Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-05T18:57:06Z"}, "message": "Basic async IO module using libuv", "tree": {"sha": "eda7bb0b2f57582791c7c60800a8c2d98d866ec3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eda7bb0b2f57582791c7c60800a8c2d98d866ec3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "html_url": "https://github.com/rust-lang/rust/commit/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/comments", "author": {"login": "robarnold", "id": 326113, "node_id": "MDQ6VXNlcjMyNjExMw==", "avatar_url": "https://avatars.githubusercontent.com/u/326113?v=4", "gravatar_id": "", "url": "https://api.github.com/users/robarnold", "html_url": "https://github.com/robarnold", "followers_url": "https://api.github.com/users/robarnold/followers", "following_url": "https://api.github.com/users/robarnold/following{/other_user}", "gists_url": "https://api.github.com/users/robarnold/gists{/gist_id}", "starred_url": "https://api.github.com/users/robarnold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/robarnold/subscriptions", "organizations_url": "https://api.github.com/users/robarnold/orgs", "repos_url": "https://api.github.com/users/robarnold/repos", "events_url": "https://api.github.com/users/robarnold/events{/privacy}", "received_events_url": "https://api.github.com/users/robarnold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b64a52df42feeb4fa59d11b19568e2aba5ef9e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/b64a52df42feeb4fa59d11b19568e2aba5ef9e65", "html_url": "https://github.com/rust-lang/rust/commit/b64a52df42feeb4fa59d11b19568e2aba5ef9e65"}], "stats": {"total": 736, "additions": 722, "deletions": 14}, "files": [{"sha": "ed3e5422923aa032b93c39990d10dfcb24aeb057", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -17,6 +17,7 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/rust_chan.cpp \\\n               rt/rust_port.cpp \\\n               rt/rust_upcall.cpp \\\n+              rt/rust_uv.cpp \\\n               rt/rust_log.cpp \\\n               rt/rust_timer.cpp \\\n               rt/circular_buffer.cpp \\"}, {"sha": "b6f5730d8505bc4154ec008a2b5c2c02197190e3", "filename": "src/lib/aio.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,184 @@\n+import str::sbuf;\n+import vec::vbuf;\n+\n+native \"rust\" mod rustrt {\n+    type socket;\n+    type server;\n+    fn aio_init();\n+    fn aio_run();\n+    fn aio_stop();\n+    fn aio_connect(host: sbuf, port: int, connected: chan[socket]);\n+    fn aio_serve(host: sbuf, port: int, acceptChan: chan[socket]) -> server;\n+    fn aio_writedata(s: socket, buf: *u8, size: uint, status: chan[bool]);\n+    fn aio_read(s: socket, reader: chan[u8[]]);\n+    fn aio_close_server(s: server, status: chan[bool]);\n+    fn aio_close_socket(s: socket);\n+    fn aio_is_null_client(s: socket) -> bool;\n+}\n+\n+type server = rustrt::server;\n+type client = rustrt::socket;\n+tag pending_connection {\n+    remote(str,int);\n+    incoming(server);\n+}\n+\n+tag socket_event {\n+    connected(client);\n+    closed;\n+    received(u8[]);\n+}\n+\n+tag server_event {\n+    pending(chan[chan[socket_event]]);\n+}\n+\n+tag request {\n+    quit;\n+    connect(pending_connection,chan[socket_event]);\n+    serve(str,int,chan[server_event],chan[server]);\n+    write(client,u8[],chan[bool]);\n+    close_server(server, chan[bool]);\n+    close_client(client);\n+}\n+\n+type ctx = chan[request];\n+\n+fn connect_task(ip: str, portnum: int, evt: chan[socket_event]) {\n+    let connecter: port[client] = port();\n+    rustrt::aio_connect(str::buf(ip), portnum, chan(connecter));\n+    let client: client;\n+    connecter |> client;\n+    new_client(client, evt);\n+}\n+\n+fn new_client(client: client, evt: chan[socket_event]) {\n+    // Start the read before notifying about the connect.  This avoids a race\n+    // condition where the receiver can close the socket before we start\n+    // reading.\n+    let reader: port[u8[]] = port();\n+    rustrt::aio_read(client, chan(reader));\n+\n+    evt <| connected(client);\n+\n+    while (true) {\n+        log \"waiting for bytes\";\n+        let data: u8[];\n+        reader |> data;\n+        log \"got some bytes\";\n+        log ivec::len[u8](data);\n+        if (ivec::len[u8](data) == 0u) {\n+            log \"got empty buffer, bailing\";\n+            break;\n+        }\n+        log \"got non-empty buffer, sending\";\n+        evt <| received(data);\n+        log \"sent non-empty buffer\";\n+    }\n+    log \"done reading\";\n+    evt <| closed;\n+    log \"close message sent\";\n+}\n+\n+fn accept_task(client: client, events: chan[server_event]) {\n+    log \"accept task was spawned\";\n+    let p: port[chan[socket_event]] = port();\n+    events <| pending(chan(p));\n+    let evt: chan[socket_event];\n+    p |> evt;\n+    new_client(client, evt);\n+    log \"done accepting\";\n+}\n+\n+fn server_task(ip: str, portnum: int, events: chan[server_event],\n+               server: chan[server]) {\n+    let accepter: port[client] = port();\n+    server <| rustrt::aio_serve(str::buf(ip), portnum, chan(accepter));\n+\n+    let client: client;\n+    while (true) {\n+        log \"preparing to accept a client\";\n+        accepter |> client;\n+        if (rustrt::aio_is_null_client(client)) {\n+          log \"client was actually null, returning\";\n+          ret;\n+        } else {\n+          spawn accept_task(client, events);\n+        }\n+    }\n+}\n+\n+fn request_task(c: chan[ctx]) {\n+    // Create a port to accept IO requests on\n+    let p: port[request] = port();\n+    // Hand of its channel to our spawner\n+    c <| chan(p);\n+    log \"uv run task spawned\";\n+    // Spin for requests\n+    let req: request;\n+    while (true) {\n+        p |> req;\n+        alt req {\n+            quit. {\n+                log \"got quit message\";\n+\n+                log \"stopping libuv\";\n+                rustrt::aio_stop();\n+                ret;\n+            }\n+            connect(remote(ip,portnum),client) {\n+                spawn connect_task(ip, portnum, client);\n+            }\n+            serve(ip,portnum,events,server) {\n+                spawn server_task(ip, portnum, events, server);\n+            }\n+            write(socket,v,status) {\n+                rustrt::aio_writedata(socket,\n+                                      ivec::to_ptr[u8](v), ivec::len[u8](v),\n+                                      status);\n+            }\n+            close_server(server,status) {\n+                log \"closing server\";\n+                rustrt::aio_close_server(server,status);\n+            }\n+            close_client(client) {\n+                log \"closing client\";\n+                rustrt::aio_close_socket(client);\n+            }\n+        }\n+    }\n+}\n+\n+fn iotask(c: chan[ctx]) {\n+    log \"io task spawned\";\n+    // Initialize before accepting requests\n+    rustrt::aio_init();\n+\n+    log \"io task init\";\n+    // Spawn our request task\n+    let reqtask: task = spawn request_task(c);\n+\n+    log \"uv run task init\";\n+    // Enter IO loop. This never returns until aio_stop is called.\n+    rustrt::aio_run();\n+    log \"waiting for request task to finish\";\n+\n+    task::join(reqtask);\n+}\n+\n+fn new() -> ctx {\n+    let p: port[ctx] = port();\n+    let t: task = spawn iotask(chan(p));\n+    let cx: ctx;\n+    p |> cx;\n+    ret cx;\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "1ba432c0e8f0334cd1cd2f89d090c8c370dcdc61", "filename": "src/lib/sio.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Flib%2Fsio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Flib%2Fsio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsio.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,104 @@\n+type ctx = aio::ctx;\n+type client = { ctx: ctx, client: aio::client, evt: port[aio::socket_event] };\n+type server = { ctx: ctx, server: aio::server, evt: port[aio::server_event] };\n+\n+fn new() -> ctx {\n+    ret aio::new();\n+}\n+\n+fn destroy(ctx: ctx) {\n+    ctx <| aio::quit;\n+}\n+\n+fn make_socket(ctx: ctx, p: port[aio::socket_event]) -> client {\n+    let evt: aio::socket_event;\n+    p |> evt;\n+    alt evt {\n+      aio::connected(client) {\n+        ret { ctx: ctx, client: client, evt: p };\n+      }\n+    }\n+    log_err (\"Could not connect to client\");\n+    fail;\n+}\n+\n+fn connect_to(ctx: ctx, ip: str, portnum: int) -> client {\n+    let p: port[aio::socket_event] = port();\n+    ctx <| aio::connect(aio::remote(ip, portnum), chan(p));\n+    ret make_socket(ctx, p);\n+}\n+\n+fn read(c: client) -> u8[] {\n+    let evt: aio::socket_event;\n+    c.evt |> evt;\n+    alt evt {\n+        aio::closed. {\n+            ret ~[];\n+        }\n+        aio::received(buf) {\n+            ret buf;\n+        }\n+    }\n+}\n+\n+fn create_server(ctx: ctx, ip: str, portnum: int) -> server {\n+    let evt: port[aio::server_event] = port();\n+    let p: port[aio::server] = port();\n+    ctx <| aio::serve(ip, portnum, chan(evt), chan(p));\n+    let srv: aio::server;\n+    p |> srv;\n+    ret { ctx: ctx, server: srv, evt: evt };\n+}\n+\n+fn accept_from(server: server) -> client {\n+    let evt: aio::server_event;\n+    server.evt |> evt;\n+    alt evt {\n+        aio::pending(callback) {\n+            let p: port[aio::socket_event] = port();\n+            callback <| chan(p);\n+            ret make_socket(server.ctx, p);\n+        }\n+    }\n+}\n+\n+fn write_data(c: client, data: u8[]) -> bool {\n+    let p: port[bool] = port();\n+    c.ctx <| aio::write(c.client, data, chan(p));\n+    let success: bool;\n+    p |> success;\n+    ret success;\n+}\n+\n+fn close_server(server: server) {\n+    // TODO: make this unit once we learn to send those from native code\n+    let p: port[bool] = port();\n+    server.ctx <| aio::close_server(server.server, chan(p));\n+    let success: bool;\n+    log \"Waiting for close\";\n+    p |> success;\n+    log \"Got close\";\n+}\n+\n+fn close_client(client: client) {\n+    client.ctx <| aio::close_client(client.client);\n+    let evt: aio::socket_event;\n+    do {\n+        client.evt |> evt;\n+        alt evt {\n+            aio::closed. {\n+                ret;\n+            }\n+            _ {}\n+        }\n+    } while (true);\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "bd864f3973a4036e8b246980e24d152a4241d84e", "filename": "src/lib/std.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -70,6 +70,8 @@ mod os_fs = \"posix_fs.rs\";\n \n mod run = \"run_program.rs\";\n mod fs;\n+mod aio;\n+mod sio;\n \n // FIXME: parametric\n mod map;"}, {"sha": "b4d26c780e6867156faa624140723aadea1d077c", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -197,6 +197,7 @@ size_t log_rt_gc;\n size_t log_rt_stdlib;\n size_t log_rt_kern;\n size_t log_rt_backtrace;\n+size_t log_rt_callback;\n \n static const mod_entry _rt_module_map[] =\n     {{\"::rt::mem\", &log_rt_mem},\n@@ -211,6 +212,7 @@ static const mod_entry _rt_module_map[] =\n      {\"::rt::stdlib\", &log_rt_stdlib},\n      {\"::rt::kern\", &log_rt_kern},\n      {\"::rt::backtrace\", &log_rt_backtrace},\n+     {\"::rt::callback\", &log_rt_callback},\n      {NULL, NULL}};\n \n void update_log_settings(void* crate_map, char* settings) {"}, {"sha": "8770fc2f7585601daa7919ad775c22b5a7792f7d", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -66,5 +66,6 @@ extern size_t log_rt_gc;\n extern size_t log_rt_stdlib;\n extern size_t log_rt_kern;\n extern size_t log_rt_backtrace;\n+extern size_t log_rt_callback;\n \n #endif /* RUST_LOG_H */"}, {"sha": "02fa7bc28466cf52e1035fd18e80f577e3b15990", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -1,21 +1,8 @@\n #include \"rust_internal.h\"\n+#include \"rust_upcall.h\"\n \n // Upcalls.\n \n-#ifdef __GNUC__\n-#define LOG_UPCALL_ENTRY(task)                            \\\n-    LOG(task, upcall,                                     \\\n-        \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n-        \" retpc: x%\" PRIxPTR,                             \\\n-        __FUNCTION__,                                     \\\n-        (task)->name, (task),                             \\\n-        __builtin_return_address(0));\n-#else\n-#define LOG_UPCALL_ENTRY(task)                            \\\n-    LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n-        (task)->name, (task));\n-#endif\n-\n extern \"C\" CDECL char const *\n str_buf(rust_task *task, rust_str *s);\n "}, {"sha": "e5ee5bb694823aef7acd461ac153f829b1bf57b1", "filename": "src/rt/rust_upcall.h", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_upcall.h", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_upcall.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.h?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,17 @@\n+#pragma once\n+\n+#ifdef __GNUC__\n+#define LOG_UPCALL_ENTRY(task)                            \\\n+    LOG(task, upcall,                                     \\\n+        \"> UPCALL %s - task: %s 0x%\" PRIxPTR              \\\n+        \" retpc: x%\" PRIxPTR,                             \\\n+        __FUNCTION__,                                     \\\n+        (task)->name, (task),                             \\\n+        __builtin_return_address(0));\n+#else\n+#define LOG_UPCALL_ENTRY(task)                            \\\n+    LOG(task, upcall, \"> UPCALL task: %s @x%\" PRIxPTR,    \\\n+        (task)->name, (task));\n+#endif\n+\n+"}, {"sha": "9e4e15b61aa1f363ae5f89e6c2059d55e315b747", "filename": "src/rt/rust_uv.cpp", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,300 @@\n+#include \"rust_internal.h\"\n+#include \"rust_upcall.h\"\n+// Disable libev prototypes - they will make inline compatability functions\n+// which are unused and so trigger a warning in gcc since -Wall is on.\n+#define EV_PROTOTYPES 0\n+#include \"libuv/uv.h\"\n+\n+#ifdef __GNUC__\n+#define LOG_CALLBACK_ENTRY(p) \\\n+    LOG(iotask, callback, \"> IO CALLBACK %s %p\", __FUNCTION__, p)\n+#else\n+#define LOG_CALLBACK_ENTRY(p) \\\n+    LOG(iotask, callback, \"> IO CALLBACK %s:%d %p\", __FILE__, __LINE__, p)\n+#endif\n+\n+// The primary task which is running the event loop. This is used to dispatch\n+// all the notifications back to rust so we clone all passed in channels to\n+// this task.\n+static rust_task *iotask = NULL;\n+\n+struct socket_data : public task_owned<socket_data> {\n+  // Either the task that the connection attempt was made from or the task\n+  // that the server was spawned on.\n+  rust_task *task;\n+  // Channel for reporting the status of a connection attempt\n+  // For connections from servers, this is always null\n+  // For server sockets, this is used to send the notification that the server\n+  // was closed.\n+  rust_chan *chan;\n+  // Channel to a port which receives bytes from this socket\n+  rust_chan *reader;\n+  uv_tcp_t socket;\n+\n+  ~socket_data() {\n+    if (chan)\n+      chan->deref();\n+    if (reader)\n+      reader->deref();\n+  }\n+};\n+\n+struct request : public uv_req_t, public task_owned<request> {\n+  rust_task *task;\n+  // Used for notifying about completion of connections, writes\n+  rust_chan *chan;\n+  request(socket_data *data, rust_chan *chan,\n+          void (*cb)(request *req, int status)) {\n+    uv_req_init(this, (uv_handle_t*)&data->socket, (void*)cb);\n+    this->data = data;\n+    this->task = data->task;\n+    this->chan = chan->clone(iotask);\n+  }\n+  socket_data *socket() {\n+    return (socket_data*)data;\n+  }\n+  void send_result(void *data) {\n+    chan->send(&data);\n+    chan->deref();\n+    chan = NULL;\n+  }\n+};\n+\n+extern \"C\" CDECL void aio_close_socket(rust_task *task, socket_data *);\n+\n+static uv_idle_s idle_handler;\n+\n+static void idle_callback(uv_handle_t* handle, int status) {\n+  rust_task *task = reinterpret_cast<rust_task*>(handle->data);\n+  task->yield();\n+}\n+\n+extern \"C\" CDECL void aio_init(rust_task *task) {\n+  LOG_UPCALL_ENTRY(task);\n+  iotask = task;\n+  uv_init();\n+  uv_idle_init(&idle_handler);\n+  uv_idle_start(&idle_handler, idle_callback);\n+}\n+\n+extern \"C\" CDECL void aio_run(rust_task *task) {\n+  LOG_UPCALL_ENTRY(task);\n+  idle_handler.data = task;\n+  uv_run();\n+}\n+\n+void nop_close(uv_handle_t* handle) {}\n+\n+extern \"C\" CDECL void aio_stop(rust_task *task) {\n+  LOG_UPCALL_ENTRY(task);\n+  uv_close((uv_handle_t*)&idle_handler, nop_close);\n+}\n+\n+static socket_data *make_socket(rust_task *task, rust_chan *chan) {\n+  socket_data *data = new (task, \"make_socket\") socket_data;\n+  if (!data ||\n+      uv_tcp_init(&data->socket)) {\n+    return NULL;\n+  }\n+  data->task = task;\n+  // Connections from servers don't have a channel\n+  if (chan) {\n+    data->chan = chan->clone(iotask);\n+  } else {\n+    data->chan = NULL;\n+  }\n+  data->socket.data = data;\n+  data->reader = NULL;\n+  return data;\n+}\n+\n+// We allocate the requested space + rust_vec but return a pointer at a\n+// +rust_vec offset so that it writes the bytes to the correct location.\n+static uv_buf_t alloc_buffer(uv_tcp_t *socket, size_t suggested_size) {\n+  LOG_CALLBACK_ENTRY(socket);\n+  uv_buf_t buf;\n+  size_t actual_size = suggested_size + sizeof (rust_ivec_heap);\n+  socket_data *data = (socket_data*)socket->data;\n+  char *base =\n+    reinterpret_cast<char*>(data->task->kernel->malloc(actual_size,\n+                                                       \"read buffer\"));\n+  buf.base = base + sizeof (rust_ivec_heap);\n+  buf.len = suggested_size;\n+  return buf;\n+}\n+\n+static void read_progress(uv_tcp_t *socket, ssize_t nread, uv_buf_t buf) {\n+  LOG_CALLBACK_ENTRY(socket);\n+  socket_data *data = (socket_data*)socket->data;\n+  I(data->task->sched, data->reader != NULL);\n+  I(data->task->sched, nread <= ssize_t(buf.len));\n+\n+  rust_ivec_heap *base = reinterpret_cast<rust_ivec_heap*>(\n+      reinterpret_cast<char*>(buf.base) - sizeof (rust_ivec_heap));\n+  rust_ivec v;\n+  v.fill = 0;\n+  v.alloc = buf.len;\n+  v.payload.ptr = base;\n+\n+  switch (nread) {\n+    case -1: // End of stream\n+      base->fill = 0;\n+      uv_read_stop(socket);\n+      break;\n+    case 0: // Nothing read\n+      data->task->kernel->free(base);\n+      return;\n+    default: // Got nread bytes\n+      base->fill = nread;\n+      break;\n+  }\n+  data->reader->send(&v);\n+}\n+\n+static void new_connection(uv_tcp_t *socket, int status) {\n+  LOG_CALLBACK_ENTRY(socket);\n+  socket_data *server = (socket_data*)socket->data;\n+  I(server->task->sched, socket == &server->socket);\n+  // Connections from servers don't have a channel\n+  socket_data *client = make_socket(server->task, NULL);\n+  if (!client) {\n+    server->task->fail();\n+    return;\n+  }\n+  if (uv_accept(socket, &client->socket)) {\n+    aio_close_socket(client->task, client);\n+    server->task->fail();\n+    return;\n+  }\n+  server->chan->send(&client);\n+}\n+\n+extern \"C\" CDECL socket_data *aio_serve(rust_task *task, const char *ip,\n+                                        int port, rust_chan *chan) {\n+  LOG_UPCALL_ENTRY(task);\n+  struct sockaddr_in addr = uv_ip4_addr(const_cast<char*>(ip), port);\n+  socket_data *server = make_socket(iotask, chan);\n+  if (!server)\n+    goto oom;\n+  if (uv_bind(&server->socket, addr) ||\n+      uv_listen(&server->socket, 128, new_connection)) {\n+    aio_close_socket(task, server);\n+    return NULL;\n+  }\n+  return server;\n+oom:\n+  task->fail();\n+  return NULL;\n+}\n+\n+static void free_socket(uv_handle_t *handle) {\n+  LOG_CALLBACK_ENTRY(socket);\n+  uv_tcp_t *socket = (uv_tcp_t*)handle;\n+  socket_data *data = (socket_data*)socket->data;\n+  I(data->task->sched, socket == &data->socket);\n+  // For client sockets, send a 0-size buffer to indicate that we're done\n+  // reading and should send the close notification.\n+  if (data->reader) {\n+    if (data->reader->is_associated()) {\n+      uv_buf_t buf = alloc_buffer(socket, 0);\n+      read_progress(socket, -1, buf);\n+      uv_read_stop(socket);\n+    }\n+  } else {\n+    // This is a server socket\n+    bool closed = true;\n+    I(data->task->sched, data->chan != NULL);\n+    data->task->kill();\n+    data->chan->send(&closed);\n+  }\n+  delete data;\n+}\n+\n+extern \"C\" CDECL void aio_close_socket(rust_task *task, socket_data *client) {\n+  LOG_UPCALL_ENTRY(task);\n+  if (uv_close((uv_handle_t*)&client->socket, free_socket)) {\n+    task->fail();\n+  }\n+}\n+\n+extern \"C\" CDECL void aio_close_server(rust_task *task, socket_data *server,\n+                                       rust_chan *chan) {\n+  LOG_UPCALL_ENTRY(task);\n+  // XXX: hax until rust_task::kill\n+  // send null and the receiver knows to call back into native code to check\n+  void* null_client = NULL;\n+  server->chan->send(&null_client);\n+  server->chan->deref();\n+  server->chan = chan->clone(iotask);\n+  aio_close_socket(task, server);\n+}\n+\n+extern \"C\" CDECL bool aio_is_null_client(rust_task *task,\n+                                         socket_data *server) {\n+  LOG_UPCALL_ENTRY(task);\n+  return server == NULL;\n+}\n+\n+static void connection_complete(request *req, int status) {\n+  LOG_CALLBACK_ENTRY(socket);\n+  socket_data *client = req->socket();\n+  req->send_result(client);\n+  delete req;\n+}\n+\n+extern \"C\" CDECL void aio_connect(rust_task *task, const char *host,\n+                                  int port, rust_chan *chan) {\n+  LOG_UPCALL_ENTRY(task);\n+  struct sockaddr_in addr = uv_ip4_addr(const_cast<char*>(host), port);\n+  request *req;\n+  socket_data *client = make_socket(iotask, NULL);\n+  if (!client) {\n+    goto oom_client;\n+  }\n+  req = new (client->task, \"connection request\")\n+    request(client, chan, connection_complete);\n+  if (!req) {\n+    goto oom_req;\n+  }\n+  if (0 == uv_connect(req, addr)) {\n+    return;\n+  }\n+oom_req:\n+  aio_close_socket(task, client);\n+oom_client:\n+  task->fail();\n+  return;\n+}\n+\n+static void write_complete(request *req, int status) {\n+  LOG_CALLBACK_ENTRY(socket);\n+  bool success = status == 0;\n+  req->send_result(&success);\n+  delete req;\n+}\n+\n+extern \"C\" CDECL void aio_writedata(rust_task *task, socket_data *data,\n+                                    char *buf, size_t size, rust_chan *chan) {\n+  LOG_UPCALL_ENTRY(task);\n+  uv_buf_t buffer = { buf, size };\n+  request *req = new (data->task, \"write request\")\n+    request(data, chan, write_complete);\n+  if (!req) {\n+    goto fail;\n+  }\n+  if (uv_write(req, &buffer, 1)) {\n+    delete req;\n+    goto fail;\n+  }\n+  return;\n+fail:\n+  task->fail();\n+}\n+\n+extern \"C\" CDECL void aio_read(rust_task *task, socket_data *data,\n+                               rust_chan *reader) {\n+  LOG_UPCALL_ENTRY(task);\n+  I(task->sched, data->reader == NULL);\n+  data->reader = reader->clone(iotask);\n+  uv_read_start(&data->socket, alloc_buffer, read_progress);\n+}"}, {"sha": "6860dbee8d67988e619039afaa6185da1bdd915c", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -1,3 +1,13 @@\n+aio_close_socket\n+aio_close_server\n+aio_connect\n+aio_init\n+aio_is_null_client\n+aio_read\n+aio_run\n+aio_serve\n+aio_stop\n+aio_writedata\n align_of\n chan_send\n check_claims"}, {"sha": "4d59964f6c6daed9b49fed1bbdac5df62b502c8e", "filename": "src/test/run-pass/ivec-tag.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,14 @@\n+use std;\n+\n+fn producer(c: chan[u8[]]) {\n+    c <| ~[1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8,\n+           8u8, 9u8, 10u8, 11u8, 12u8, 13u8 ];\n+}\n+\n+fn main() {\n+    let p: port[u8[]] = port();\n+    let prod: task = spawn producer(chan(p));\n+\n+    let data: u8[];\n+    p |> data;\n+}"}, {"sha": "847d04c8776af892a1b4e8fb6cd4d20f71d55429", "filename": "src/test/run-pass/sio-client.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-client.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-client.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-client.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,21 @@\n+use std;\n+import std::sio;\n+import std::task;\n+\n+fn connectTask(cx: sio::ctx, ip: str, portnum: int) {\n+  let client: sio::client;\n+  client = sio::connect_to(cx, ip, portnum);\n+  sio::close_client(client);\n+}\n+\n+fn main() {\n+  let cx: sio::ctx = sio::new();\n+  let srv: sio::server = sio::create_server(cx, \"0.0.0.0\", 9090);\n+  let child: task = spawn connectTask(cx, \"127.0.0.1\", 9090);\n+  let client: sio::client = sio::accept_from(srv);\n+  task::join(child);\n+  sio::close_client(client);\n+  sio::close_server(srv);\n+  sio::destroy(cx);\n+}\n+"}, {"sha": "4cbc71016a64fabcbadcedce7913143d32b86637", "filename": "src/test/run-pass/sio-ctx.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-ctx.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,7 @@\n+use std;\n+import std::sio;\n+\n+fn main() {\n+  let cx: sio::ctx = sio::new();\n+  sio::destroy(cx);\n+}"}, {"sha": "a2fc95b2c1abd6667af64c340ff03d802e565733", "filename": "src/test/run-pass/sio-read.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-read.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,25 @@\n+use std;\n+import std::sio;\n+import std::task;\n+import std::str;\n+\n+fn connectTask(cx: sio::ctx, ip: str, portnum: int) {\n+  let client: sio::client;\n+  client = sio::connect_to(cx, ip, portnum);\n+  let data = sio::read(client);\n+  sio::close_client(client);\n+}\n+\n+fn main() {\n+  let cx: sio::ctx = sio::new();\n+  let srv: sio::server = sio::create_server(cx, \"0.0.0.0\", 9090);\n+  let child: task = spawn connectTask(cx, \"127.0.0.1\", 9090);\n+  let client: sio::client = sio::accept_from(srv);\n+  sio::write_data(client, str::bytes_ivec(\"hello, world\\n\"));\n+  task::join(child);\n+  sio::close_client(client);\n+  sio::close_server(srv);\n+  sio::destroy(cx);\n+}\n+\n+"}, {"sha": "8a6fdccf484b4e8adc54dd367b860f758e3961ff", "filename": "src/test/run-pass/sio-srv.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-srv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-srv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-srv.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,9 @@\n+use std;\n+import std::sio;\n+\n+fn main() {\n+  let cx: sio::ctx = sio::new();\n+  let srv: sio::server = sio::create_server(cx, \"0.0.0.0\", 9090);\n+  sio::close_server(srv);\n+  sio::destroy(cx);\n+}"}, {"sha": "1094db7885c269863a5af1c771af4de3f2260af5", "filename": "src/test/run-pass/sio-write.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa/src%2Ftest%2Frun-pass%2Fsio-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsio-write.rs?ref=f4b87c749fc5dc085cd31ba3b5f91f11d863e0fa", "patch": "@@ -0,0 +1,24 @@\n+use std;\n+import std::sio;\n+import std::task;\n+import std::str;\n+\n+fn connectTask(cx: sio::ctx, ip: str, portnum: int) {\n+  let client: sio::client;\n+  client = sio::connect_to(cx, ip, portnum);\n+  sio::close_client(client);\n+}\n+\n+fn main() {\n+  let cx: sio::ctx = sio::new();\n+  let srv: sio::server = sio::create_server(cx, \"0.0.0.0\", 9090);\n+  let child: task = spawn connectTask(cx, \"127.0.0.1\", 9090);\n+  let client: sio::client = sio::accept_from(srv);\n+  sio::write_data(client, str::bytes_ivec(\"hello, world\\n\"));\n+  task::join(child);\n+  sio::close_client(client);\n+  sio::close_server(srv);\n+  sio::destroy(cx);\n+}\n+\n+"}]}