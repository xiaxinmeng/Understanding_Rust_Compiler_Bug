{"sha": "c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YjE2OTg3NjQ1ZGQ4OTgwZjQwZWZlN2M3MmQ0ZjNmZDRiMzk5ZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-05T15:28:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-05T15:28:08Z"}, "message": "Auto merge of #60541 - RalfJung:miri-visitor-generators, r=oli-obk\n\nfix Miri visiting generators\n\nFixes fall-out caused by https://github.com/rust-lang/rust/pull/59897.\n\nr? @oli-obk", "tree": {"sha": "a05f1662a3af8c8912d9ec1609341a4cc6c84557", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a05f1662a3af8c8912d9ec1609341a4cc6c84557"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "html_url": "https://github.com/rust-lang/rust/commit/c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6b16987645dd8980f40efe7c72d4f3fd4b399d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d8fd98d347239bc7e29c19988d7c19cf860cced", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d8fd98d347239bc7e29c19988d7c19cf860cced", "html_url": "https://github.com/rust-lang/rust/commit/5d8fd98d347239bc7e29c19988d7c19cf860cced"}, {"sha": "c5c161e39497887abf78ef7da0d53c3dcf22a059", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c161e39497887abf78ef7da0d53c3dcf22a059", "html_url": "https://github.com/rust-lang/rust/commit/c5c161e39497887abf78ef7da0d53c3dcf22a059"}], "stats": {"total": 71, "additions": 29, "deletions": 42}, "files": [{"sha": "772cbcf9447ef9e688e4dd182dfb583917db147d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c6b16987645dd8980f40efe7c72d4f3fd4b399d3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b16987645dd8980f40efe7c72d4f3fd4b399d3/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "patch": "@@ -66,6 +66,7 @@ macro_rules! try_validation {\n pub enum PathElem {\n     Field(Symbol),\n     Variant(Symbol),\n+    GeneratoreState(VariantIdx),\n     ClosureVar(Symbol),\n     ArrayElem(usize),\n     TupleElem(usize),\n@@ -100,6 +101,7 @@ fn path_format(path: &Vec<PathElem>) -> String {\n         match elem {\n             Field(name) => write!(out, \".{}\", name),\n             Variant(name) => write!(out, \".<downcast-variant({})>\", name),\n+            GeneratoreState(idx) => write!(out, \".<generator-state({})>\", idx.index()),\n             ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n@@ -262,8 +264,13 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n         variant_id: VariantIdx,\n         new_op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx> {\n-        let name = old_op.layout.ty.ty_adt_def().unwrap().variants[variant_id].ident.name;\n-        self.visit_elem(new_op, PathElem::Variant(name))\n+        let name = match old_op.layout.ty.sty {\n+            ty::Adt(adt, _) => PathElem::Variant(adt.variants[variant_id].ident.name),\n+            // Generators also have variants\n+            ty::Generator(..) => PathElem::GeneratoreState(variant_id),\n+            _ => bug!(\"Unexpected type with variant: {:?}\", old_op.layout.ty),\n+        };\n+        self.visit_elem(new_op, name)\n     }\n \n     #[inline]"}, {"sha": "cf67b0a97bcf8dd23ee1b7ca7369f4ebe15e2139", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 20, "deletions": 40, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c6b16987645dd8980f40efe7c72d4f3fd4b399d3/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6b16987645dd8980f40efe7c72d4f3fd4b399d3/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=c6b16987645dd8980f40efe7c72d4f3fd4b399d3", "patch": "@@ -147,7 +147,7 @@ macro_rules! make_value_visitor {\n             {\n                 Ok(())\n             }\n-            /// Visits this vale as an aggregate, you are even getting an iterator yielding\n+            /// Visits this value as an aggregate, you are getting an iterator yielding\n             /// all the fields (still in an `EvalResult`, you have to do error handling yourself).\n             /// Recurses into the fields.\n             #[inline(always)]\n@@ -160,7 +160,8 @@ macro_rules! make_value_visitor {\n             }\n \n             /// Called each time we recurse down to a field of a \"product-like\" aggregate\n-            /// (structs, tuples, arrays and the like, but not enums), passing in old and new value.\n+            /// (structs, tuples, arrays and the like, but not enums), passing in old (outer)\n+            /// and new (inner) value.\n             /// This gives the visitor the chance to track the stack of nested fields that\n             /// we are descending through.\n             #[inline(always)]\n@@ -173,18 +174,6 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n-            /// Called for recursing into the field of a generator. These are not known to be\n-            /// initialized, so we treat them like unions.\n-            #[inline(always)]\n-            fn visit_generator_field(\n-                &mut self,\n-                _old_val: Self::V,\n-                _field: usize,\n-                new_val: Self::V,\n-            ) -> EvalResult<'tcx> {\n-                self.visit_union(new_val)\n-            }\n-\n             /// Called when recursing into an enum variant.\n             #[inline(always)]\n             fn visit_variant(\n@@ -238,7 +227,7 @@ macro_rules! make_value_visitor {\n             fn walk_value(&mut self, v: Self::V) -> EvalResult<'tcx>\n             {\n                 trace!(\"walk_value: type: {}\", v.layout().ty);\n-                // If this is a multi-variant layout, we have find the right one and proceed with\n+                // If this is a multi-variant layout, we have to find the right one and proceed with\n                 // that.\n                 match v.layout().variants {\n                     layout::Variants::Multiple { .. } => {\n@@ -263,6 +252,13 @@ macro_rules! make_value_visitor {\n                         // recurse with the inner type\n                         return self.visit_field(v, 0, Value::from_mem_place(inner));\n                     },\n+                    ty::Generator(..) => {\n+                        // FIXME: Generator layout is lying: it claims a whole bunch of fields exist\n+                        // when really many of them can be uninitialized.\n+                        // Just treat them as a union for now, until hopefully the layout\n+                        // computation is fixed.\n+                        return self.visit_union(v);\n+                    }\n                     _ => {},\n                 };\n \n@@ -304,34 +300,18 @@ macro_rules! make_value_visitor {\n                         // Empty unions are not accepted by rustc. That's great, it means we can\n                         // use that as an unambiguous signal for detecting primitives.  Make sure\n                         // we did not miss any primitive.\n-                        debug_assert!(fields > 0);\n+                        assert!(fields > 0);\n                         self.visit_union(v)\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                        // Special handling needed for generators: All but the first field\n-                        // (which is the state) are actually implicitly `MaybeUninit`, i.e.,\n-                        // they may or may not be initialized, so we cannot visit them.\n-                        match v.layout().ty.sty {\n-                            ty::Generator(..) => {\n-                                let field = v.project_field(self.ecx(), 0)?;\n-                                self.visit_aggregate(v, std::iter::once(Ok(field)))?;\n-                                for i in 1..offsets.len() {\n-                                    let field = v.project_field(self.ecx(), i as u64)?;\n-                                    self.visit_generator_field(v, i, field)?;\n-                                }\n-                                Ok(())\n-                            }\n-                            _ => {\n-                                // FIXME: We collect in a vec because otherwise there are lifetime\n-                                // errors: Projecting to a field needs access to `ecx`.\n-                                let fields: Vec<EvalResult<'tcx, Self::V>> =\n-                                    (0..offsets.len()).map(|i| {\n-                                        v.project_field(self.ecx(), i as u64)\n-                                    })\n-                                    .collect();\n-                                self.visit_aggregate(v, fields.into_iter())\n-                            }\n-                        }\n+                        // FIXME: We collect in a vec because otherwise there are lifetime\n+                        // errors: Projecting to a field needs access to `ecx`.\n+                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                            (0..offsets.len()).map(|i| {\n+                                v.project_field(self.ecx(), i as u64)\n+                            })\n+                            .collect();\n+                        self.visit_aggregate(v, fields.into_iter())\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first."}]}