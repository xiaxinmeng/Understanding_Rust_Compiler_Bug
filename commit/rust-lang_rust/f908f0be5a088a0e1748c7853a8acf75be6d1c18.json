{"sha": "f908f0be5a088a0e1748c7853a8acf75be6d1c18", "node_id": "C_kwDOAAsO6NoAKGY5MDhmMGJlNWEwODhhMGUxNzQ4Yzc4NTNhOGFjZjc1YmU2ZDFjMTg", "commit": {"author": {"name": "Robin Schroer", "email": "git@sulami.xyz", "date": "2023-01-18T10:58:50Z"}, "committer": {"name": "Robin Schroer", "email": "git@sulami.xyz", "date": "2023-01-23T01:07:10Z"}, "message": "Consider doc(alias) when providing typo suggestions\n\nThis means that\n\n```rust\nimpl Foo {\n    #[doc(alias = \"quux\")]\n    fn bar(&self) {}\n}\n\nfn main() {\n    (Foo {}).quux();\n}\n```\n\nwill suggest `bar`. This currently uses the \"there is a method with a\nsimilar name\" help text, because the point where we choose and emit a\nsuggestion is different from where we gather the suggestions. Changes\nhave mainly been made to the latter.\n\nThe selection code will now fall back to aliased candidates, but\ngenerally only if there is no candidate that matches based on the\nexisting Levenshtein methodology.\n\nFixes #83968.", "tree": {"sha": "d13ae9355ba15f7eda05b95da729cb0b02476bef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d13ae9355ba15f7eda05b95da729cb0b02476bef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f908f0be5a088a0e1748c7853a8acf75be6d1c18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEv1TxOhn3wIfLNaL12sndJk0dKYoFAmPN3b4ACgkQ2sndJk0d\nKYpXPg//UYpsKCk2FW/9SbUebPHBTkuXl8UzdtIXHMUlwwNeqU8MKfxE9QCtTjOi\naF/UhIOQ4D+daBClunjM6xbFHVvTBzQNlt+9rApc6noTJecym0zhzla+XOxzY4Ix\nYYMrQT53iFV12reZm7uVqkfMIwB1C60qIcsWjRUSOvsqxK56oeZPESlHKf4t7fgi\n7QFW6yzCAiqMVThPAlZuxL1xGBhr0rCUgiJrWDwdN7n5O9+TGYllT6+os/kpr2ZX\nJMj7qf248T9ruWhWgdlo8gzLgfYi+M+OvN7rTj8oI1pPloyVdQ84vDCMYgMhkt2N\n9jDwns60noreAISH+z6bJh5xvlAlTIjaPMrnIUiW6aFy1CKNrfSSsboWwNK7tPr9\ng2DhSX4ilMxU73+KJHBeQLSEfUGNp44frBD9lVDAz/gqQrW46//t3bylI3JktaIx\nDU4hWSeI9InOZZXtgmNdxFZsqdl49AvO/MufQuwHlRwz2yU0C3WM0hYpiWiazSMI\nJJxgswToiSe94uBOAxexDCAUfRLXJAuB8AD5ObOwm2vUlZWrBljsMo+/q81zAl6S\nGfj5UE0wV6Q4cZStbSFKwaNMiE/hckIJCmoOc+hld4q66uxHG1j0t5y8SFB15/7H\nCGdAL7jpPza1QUCp5ayoIUoflh1yt2xPKPUb0CCBxETSDdJmsMc=\n=Mo22\n-----END PGP SIGNATURE-----", "payload": "tree d13ae9355ba15f7eda05b95da729cb0b02476bef\nparent 51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906\nauthor Robin Schroer <git@sulami.xyz> 1674039530 +0900\ncommitter Robin Schroer <git@sulami.xyz> 1674436030 +0900\n\nConsider doc(alias) when providing typo suggestions\n\nThis means that\n\n```rust\nimpl Foo {\n    #[doc(alias = \"quux\")]\n    fn bar(&self) {}\n}\n\nfn main() {\n    (Foo {}).quux();\n}\n```\n\nwill suggest `bar`. This currently uses the \"there is a method with a\nsimilar name\" help text, because the point where we choose and emit a\nsuggestion is different from where we gather the suggestions. Changes\nhave mainly been made to the latter.\n\nThe selection code will now fall back to aliased candidates, but\ngenerally only if there is no candidate that matches based on the\nexisting Levenshtein methodology.\n\nFixes #83968.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f908f0be5a088a0e1748c7853a8acf75be6d1c18", "html_url": "https://github.com/rust-lang/rust/commit/f908f0be5a088a0e1748c7853a8acf75be6d1c18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f908f0be5a088a0e1748c7853a8acf75be6d1c18/comments", "author": {"login": "sulami", "id": 1843193, "node_id": "MDQ6VXNlcjE4NDMxOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1843193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sulami", "html_url": "https://github.com/sulami", "followers_url": "https://api.github.com/users/sulami/followers", "following_url": "https://api.github.com/users/sulami/following{/other_user}", "gists_url": "https://api.github.com/users/sulami/gists{/gist_id}", "starred_url": "https://api.github.com/users/sulami/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sulami/subscriptions", "organizations_url": "https://api.github.com/users/sulami/orgs", "repos_url": "https://api.github.com/users/sulami/repos", "events_url": "https://api.github.com/users/sulami/events{/privacy}", "received_events_url": "https://api.github.com/users/sulami/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sulami", "id": 1843193, "node_id": "MDQ6VXNlcjE4NDMxOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1843193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sulami", "html_url": "https://github.com/sulami", "followers_url": "https://api.github.com/users/sulami/followers", "following_url": "https://api.github.com/users/sulami/following{/other_user}", "gists_url": "https://api.github.com/users/sulami/gists{/gist_id}", "starred_url": "https://api.github.com/users/sulami/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sulami/subscriptions", "organizations_url": "https://api.github.com/users/sulami/orgs", "repos_url": "https://api.github.com/users/sulami/repos", "events_url": "https://api.github.com/users/sulami/events{/privacy}", "received_events_url": "https://api.github.com/users/sulami/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "url": "https://api.github.com/repos/rust-lang/rust/commits/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906", "html_url": "https://github.com/rust-lang/rust/commit/51d50ea96ecc9c681a0054e5eb8e5e1d4ab38906"}], "stats": {"total": 90, "additions": 77, "deletions": 13}, "files": [{"sha": "47396204b14e7c50314d32a35ef9ecbd8bc7bb01", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f908f0be5a088a0e1748c7853a8acf75be6d1c18/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f908f0be5a088a0e1748c7853a8acf75be6d1c18/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=f908f0be5a088a0e1748c7853a8acf75be6d1c18", "patch": "@@ -76,7 +76,7 @@ pub struct NoMatchData<'tcx> {\n     pub unsatisfied_predicates:\n         Vec<(ty::Predicate<'tcx>, Option<ty::Predicate<'tcx>>, Option<ObligationCause<'tcx>>)>,\n     pub out_of_scope_traits: Vec<DefId>,\n-    pub lev_candidate: Option<ty::AssocItem>,\n+    pub similar_candidate: Option<ty::AssocItem>,\n     pub mode: probe::Mode,\n }\n "}, {"sha": "9c06a22315bcba12189377e2770e9884588d5e5f", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f908f0be5a088a0e1748c7853a8acf75be6d1c18/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f908f0be5a088a0e1748c7853a8acf75be6d1c18/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=f908f0be5a088a0e1748c7853a8acf75be6d1c18", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     static_candidates: Vec::new(),\n                     unsatisfied_predicates: Vec::new(),\n                     out_of_scope_traits: Vec::new(),\n-                    lev_candidate: None,\n+                    similar_candidate: None,\n                     mode,\n                 }));\n             }\n@@ -1076,13 +1076,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         if let Some((kind, def_id)) = private_candidate {\n             return Err(MethodError::PrivateMatch(kind, def_id, out_of_scope_traits));\n         }\n-        let lev_candidate = self.probe_for_lev_candidate()?;\n+        let similar_candidate = self.probe_for_similar_candidate()?;\n \n         Err(MethodError::NoMatch(NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n-            lev_candidate,\n+            similar_candidate,\n             mode: self.mode,\n         }))\n     }\n@@ -1787,7 +1787,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     /// Similarly to `probe_for_return_type`, this method attempts to find the best matching\n     /// candidate method where the method name may have been misspelled. Similarly to other\n     /// Levenshtein based suggestions, we provide at most one such suggestion.\n-    fn probe_for_lev_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n+    fn probe_for_similar_candidate(&mut self) -> Result<Option<ty::AssocItem>, MethodError<'tcx>> {\n         debug!(\"probing for method names similar to {:?}\", self.method_name);\n \n         let steps = self.steps.clone();\n@@ -1831,6 +1831,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         None,\n                     )\n                 }\n+                .or_else(|| {\n+                    applicable_close_candidates\n+                        .iter()\n+                        .find(|cand| self.matches_by_doc_alias(cand.def_id))\n+                        .map(|cand| cand.name)\n+                })\n                 .unwrap();\n                 Ok(applicable_close_candidates.into_iter().find(|method| method.name == best_name))\n             }\n@@ -1981,6 +1987,38 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n+    /// Determine if the associated item withe the given DefId matches\n+    /// the desired name via a doc alias.\n+    fn matches_by_doc_alias(&self, def_id: DefId) -> bool {\n+        let Some(name) = self.method_name else { return false; };\n+        let Some(local_def_id) = def_id.as_local() else { return false; };\n+        let hir_id = self.fcx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let attrs = self.fcx.tcx.hir().attrs(hir_id);\n+        for attr in attrs {\n+            let sym::doc = attr.name_or_empty() else { continue; };\n+            let Some(values) = attr.meta_item_list() else { continue; };\n+            for v in values {\n+                if v.name_or_empty() != sym::alias {\n+                    continue;\n+                }\n+                if let Some(nested) = v.meta_item_list() {\n+                    // #[doc(alias(\"foo\", \"bar\"))]\n+                    for n in nested {\n+                        if let Some(lit) = n.lit() && name.as_str() == lit.symbol.as_str() {\n+                            return true;\n+                        }\n+                    }\n+                } else if let Some(meta) = v.meta_item()\n+                    && let Some(lit) = meta.name_value_literal()\n+                    && name.as_str() == lit.symbol.as_str() {\n+                        // #[doc(alias = \"foo\")]\n+                        return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     /// Finds the method with the appropriate name (or return type, as the case may be). If\n     /// `allow_similar_names` is set, find methods with close-matching names.\n     // The length of the returned iterator is nearly always 0 or 1 and this\n@@ -1996,6 +2034,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         if !self.is_relevant_kind_for_mode(x.kind) {\n                             return false;\n                         }\n+                        if self.matches_by_doc_alias(x.def_id) {\n+                            return true;\n+                        }\n                         match lev_distance_with_substrings(name.as_str(), x.name.as_str(), max_dist)\n                         {\n                             Some(d) => d > 0,"}, {"sha": "8c54e9bdb5fb3a3ae7670f01c5d8e3b66c346b98", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f908f0be5a088a0e1748c7853a8acf75be6d1c18/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f908f0be5a088a0e1748c7853a8acf75be6d1c18/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=f908f0be5a088a0e1748c7853a8acf75be6d1c18", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty_str = with_forced_trimmed_paths!(self.ty_to_string(rcvr_ty));\n         let is_method = mode == Mode::MethodCall;\n         let unsatisfied_predicates = &no_match_data.unsatisfied_predicates;\n-        let lev_candidate = no_match_data.lev_candidate;\n+        let similar_candidate = no_match_data.similar_candidate;\n         let item_kind = if is_method {\n             \"method\"\n         } else if rcvr_ty.is_enum() {\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // give a helping note that it has to be called as `(x.f)(...)`.\n         if let SelfSource::MethodCall(expr) = source {\n             if !self.suggest_calling_field_as_fn(span, rcvr_ty, expr, item_name, &mut err)\n-                && lev_candidate.is_none()\n+                && similar_candidate.is_none()\n                 && !custom_span_label\n             {\n                 label_span_not_found(&mut err);\n@@ -1015,20 +1015,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if fallback_span {\n                 err.span_label(span, msg);\n             }\n-        } else if let Some(lev_candidate) = lev_candidate {\n+        } else if let Some(similar_candidate) = similar_candidate {\n             // Don't emit a suggestion if we found an actual method\n             // that had unsatisfied trait bounds\n             if unsatisfied_predicates.is_empty() {\n-                let def_kind = lev_candidate.kind.as_def_kind();\n+                let def_kind = similar_candidate.kind.as_def_kind();\n                 // Methods are defined within the context of a struct and their first parameter is always self,\n                 // which represents the instance of the struct the method is being called on\n                 // Associated functions don\u2019t take self as a parameter and\n                 // they are not methods because they don\u2019t have an instance of the struct to work with.\n-                if def_kind == DefKind::AssocFn && lev_candidate.fn_has_self_parameter {\n+                if def_kind == DefKind::AssocFn && similar_candidate.fn_has_self_parameter {\n                     err.span_suggestion(\n                         span,\n                         \"there is a method with a similar name\",\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 } else {\n@@ -1037,9 +1037,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &format!(\n                             \"there is {} {} with a similar name\",\n                             def_kind.article(),\n-                            def_kind.descr(lev_candidate.def_id),\n+                            def_kind.descr(similar_candidate.def_id),\n                         ),\n-                        lev_candidate.name,\n+                        similar_candidate.name,\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "9c6d10029239b8035c92ab6a48d5136f15fe4866", "filename": "tests/ui/methods/method-not-found-but-doc-alias.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f908f0be5a088a0e1748c7853a8acf75be6d1c18/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f908f0be5a088a0e1748c7853a8acf75be6d1c18/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.rs?ref=f908f0be5a088a0e1748c7853a8acf75be6d1c18", "patch": "@@ -0,0 +1,11 @@\n+struct Foo;\n+\n+impl Foo {\n+    #[doc(alias = \"quux\")]\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    Foo.quux();\n+    //~^ ERROR  no method named `quux` found for struct `Foo` in the current scope\n+}"}, {"sha": "5102a452f0c28c7267fe2d72cb241ddd211673fc", "filename": "tests/ui/methods/method-not-found-but-doc-alias.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f908f0be5a088a0e1748c7853a8acf75be6d1c18/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f908f0be5a088a0e1748c7853a8acf75be6d1c18/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods%2Fmethod-not-found-but-doc-alias.stderr?ref=f908f0be5a088a0e1748c7853a8acf75be6d1c18", "patch": "@@ -0,0 +1,12 @@\n+error[E0599]: no method named `quux` found for struct `Foo` in the current scope\n+  --> $DIR/method-not-found-but-doc-alias.rs:9:9\n+   |\n+LL | struct Foo;\n+   | ---------- method `quux` not found for this struct\n+...\n+LL |     Foo.quux();\n+   |         ^^^^ help: there is a method with a similar name: `bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}]}