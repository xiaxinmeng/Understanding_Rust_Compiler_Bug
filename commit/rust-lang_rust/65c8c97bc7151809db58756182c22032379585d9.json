{"sha": "65c8c97bc7151809db58756182c22032379585d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YzhjOTdiYzcxNTE4MDlkYjU4NzU2MTgyYzIyMDMyMzc5NTg1ZDk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-10T21:28:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-10T21:30:44Z"}, "message": "resolve: Skip bang macros when resolving potentially built-in attributes", "tree": {"sha": "a33308311620aaf5db54bd7d3b7024303099ec67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a33308311620aaf5db54bd7d3b7024303099ec67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65c8c97bc7151809db58756182c22032379585d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65c8c97bc7151809db58756182c22032379585d9", "html_url": "https://github.com/rust-lang/rust/commit/65c8c97bc7151809db58756182c22032379585d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65c8c97bc7151809db58756182c22032379585d9/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0aaf895ee74d23445bbe98a601b544d953c4c0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0aaf895ee74d23445bbe98a601b544d953c4c0b", "html_url": "https://github.com/rust-lang/rust/commit/d0aaf895ee74d23445bbe98a601b544d953c4c0b"}], "stats": {"total": 61, "additions": 29, "deletions": 32}, "files": [{"sha": "8c769094f521181d3314d0180443c9c189804916", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65c8c97bc7151809db58756182c22032379585d9/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c8c97bc7151809db58756182c22032379585d9/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=65c8c97bc7151809db58756182c22032379585d9", "patch": "@@ -1270,6 +1270,7 @@ impl<'a> NameBinding<'a> {\n     fn macro_kind(&self) -> Option<MacroKind> {\n         match self.def_ignoring_ambiguity() {\n             Def::Macro(_, kind) => Some(kind),\n+            Def::NonMacroAttr(..) => Some(MacroKind::Attr),\n             _ => None,\n         }\n     }\n@@ -3596,8 +3597,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, parent_expansion, record_used,\n-                                                        record_used, false, path_span)\n+                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_expansion,\n+                                                        record_used, record_used, path_span)\n                                                         .map(|(binding, _)| binding)\n             } else {\n                 let record_used_id ="}, {"sha": "351963bff5bf3d152b4ddbe09daa15b5543fa6ba", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/65c8c97bc7151809db58756182c22032379585d9/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65c8c97bc7151809db58756182c22032379585d9/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=65c8c97bc7151809db58756182c22032379585d9", "patch": "@@ -109,6 +109,13 @@ pub struct ProcMacError {\n     warn_msg: &'static str,\n }\n \n+// For compatibility bang macros are skipped when resolving potentially built-in attributes.\n+fn macro_kind_mismatch(name: Name, requirement: Option<MacroKind>, candidate: Option<MacroKind>)\n+                       -> bool {\n+    requirement == Some(MacroKind::Attr) && candidate == Some(MacroKind::Bang) &&\n+    (name == \"test\" || name == \"bench\" || is_builtin_attr_name(name))\n+}\n+\n impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -479,13 +486,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let legacy_resolution = self.resolve_legacy_scope(\n-            path[0], parent_expansion, parent_legacy_scope, false, kind == MacroKind::Attr\n+            path[0], Some(kind), parent_expansion, parent_legacy_scope, false\n         );\n         let result = if let Some(legacy_binding) = legacy_resolution {\n             Ok(legacy_binding.def())\n         } else {\n-            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, parent_expansion, false,\n-                                                          force, kind == MacroKind::Attr, span) {\n+            match self.resolve_lexical_macro_path_segment(path[0], MacroNS, Some(kind),\n+                                                          parent_expansion, false, force, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n@@ -543,10 +550,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         &mut self,\n         mut ident: Ident,\n         ns: Namespace,\n+        kind: Option<MacroKind>,\n         parent_expansion: Mark,\n         record_used: bool,\n         force: bool,\n-        is_attr: bool,\n         path_span: Span,\n     ) -> Result<(&'a NameBinding<'a>, FromPrelude), Determinacy> {\n         // General principles:\n@@ -622,19 +629,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n                 WhereToResolve::MacroUsePrelude => {\n                     match self.macro_use_prelude.get(&ident.name).cloned() {\n-                        Some(binding) => {\n-                            let mut result = Ok((binding, FromPrelude(true)));\n-                            // FIXME: Keep some built-in macros working even if they are\n-                            // shadowed by non-attribute macros imported with `macro_use`.\n-                            // We need to come up with some more principled approach instead.\n-                            if is_attr && (ident.name == \"test\" || ident.name == \"bench\") {\n-                                if let Def::Macro(_, MacroKind::Bang) =\n-                                        binding.def_ignoring_ambiguity() {\n-                                    result = Err(Determinacy::Determined);\n-                                }\n-                            }\n-                            result\n-                        }\n+                        Some(binding) => Ok((binding, FromPrelude(true))),\n                         None => Err(Determinacy::Determined),\n                     }\n                 }\n@@ -648,7 +643,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     // FIXME: Only built-in attributes are not considered as candidates for\n                     // non-attributes to fight off regressions on stable channel (#53205).\n                     // We need to come up with some more principled approach instead.\n-                    if is_attr && is_builtin_attr_name(ident.name) {\n+                    if kind == Some(MacroKind::Attr) && is_builtin_attr_name(ident.name) {\n                         let binding = (Def::NonMacroAttr(NonMacroAttrKind::Builtin),\n                                        ty::Visibility::Public, ident.span, Mark::root())\n                                        .to_name_binding(self.arenas);\n@@ -748,6 +743,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n             match result {\n                 Ok(result) => {\n+                    if macro_kind_mismatch(ident.name, kind, result.0.macro_kind()) {\n+                        continue_search!();\n+                    }\n+\n                     if !record_used {\n                         return Ok(result);\n                     }\n@@ -784,9 +783,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         let determinacy = Determinacy::determined(force);\n-        if determinacy == Determinacy::Determined && is_attr {\n+        if determinacy == Determinacy::Determined && kind == Some(MacroKind::Attr) {\n             // For single-segment attributes interpret determinate \"no resolution\" as a custom\n-            // attribute. (Lexical resolution implies the first segment and is_attr should imply\n+            // attribute. (Lexical resolution implies the first segment and attr kind should imply\n             // the last segment, so we are certainly working with a single-segment attribute here.)\n             assert!(ns == MacroNS);\n             let binding = (Def::NonMacroAttr(NonMacroAttrKind::Custom),\n@@ -800,15 +799,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     fn resolve_legacy_scope(&mut self,\n                             ident: Ident,\n+                            kind: Option<MacroKind>,\n                             parent_expansion: Mark,\n                             parent_legacy_scope: LegacyScope<'a>,\n-                            record_used: bool,\n-                            is_attr: bool)\n+                            record_used: bool)\n                             -> Option<&'a NameBinding<'a>> {\n-        if is_attr && (ident.name == \"test\" || ident.name == \"bench\") {\n-            // FIXME: Keep some built-in macros working even if they are\n-            // shadowed by user-defined `macro_rules`.\n-            // We need to come up with some more principled approach instead.\n+        if macro_kind_mismatch(ident.name, kind, Some(MacroKind::Bang)) {\n             return None;\n         }\n \n@@ -897,10 +893,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 in module.legacy_macro_resolutions.borrow().iter() {\n             let span = ident.span;\n             let legacy_resolution = self.resolve_legacy_scope(\n-                ident, parent_expansion, parent_legacy_scope, true, kind == MacroKind::Attr\n+                ident, Some(kind), parent_expansion, parent_legacy_scope, true\n             );\n             let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, parent_expansion, true, true, kind == MacroKind::Attr, span\n+                ident, MacroNS, Some(kind), parent_expansion, true, true, span\n             );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n@@ -960,10 +956,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         for &(ident, parent_expansion, parent_legacy_scope)\n                 in module.builtin_attrs.borrow().iter() {\n             let resolve_legacy = |this: &mut Self| this.resolve_legacy_scope(\n-                ident, parent_expansion, parent_legacy_scope, true, true\n+                ident, Some(MacroKind::Attr), parent_expansion, parent_legacy_scope, true\n             );\n             let resolve_modern = |this: &mut Self| this.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, parent_expansion, true, true, true, ident.span\n+                ident, MacroNS, Some(MacroKind::Attr), parent_expansion, true, true, ident.span\n             ).map(|(binding, _)| binding).ok();\n \n             if let Some(binding) = resolve_legacy(self).or_else(|| resolve_modern(self)) {"}]}