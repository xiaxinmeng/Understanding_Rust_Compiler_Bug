{"sha": "cf69f9e2206c708cb0c4535cab9e7a64c23add06", "node_id": "C_kwDOAAsO6NoAKGNmNjlmOWUyMjA2YzcwOGNiMGM0NTM1Y2FiOWU3YTY0YzIzYWRkMDY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-11-20T00:09:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-20T00:09:41Z"}, "message": "Rollup merge of #90999 - RalfJung:miri_simd, r=oli-obk\n\nfix CTFE/Miri simd_insert/extract on array-style repr(simd) types\n\nThe changed test would previously fail since `place_index` would just return the only field of `f32x4`, i.e., the array -- rather than *indexing into* the array which is what we have to do.\n\nThe new helper methods will also be needed for https://github.com/rust-lang/miri/issues/1912.\n\nr? ``````@oli-obk``````", "tree": {"sha": "6ac00c06b0824c37dc2b3e673d764ab5468df9ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ac00c06b0824c37dc2b3e673d764ab5468df9ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf69f9e2206c708cb0c4535cab9e7a64c23add06", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmDzGCRBK7hj4Ov3rIwAAoToIAENgxSFgalzm2IzYGqwEMYp6\n66bW46I8V7KVlYsbijBGdbsRHLZ79C3sZSsD8P7AlhgtZLeVR+lRlPXhcqk3IiY0\ngC1TVbgSZLPexzKBCQIPFCUdci3R94G2TZuxaIx55Wza6HGPE1eBtXaOa+eCqs2z\ny63bjxrPefSlkm1rbWGWV8fZYJIfiV+k2qM4bic5fXa+lz4gGxQCZh3F/7NaO4g+\n99qxfzor5hEcZcQvALfqCBlqeNNxAM/b27zujXomXhXGU0F+Rm7ve2Qbayb4mg15\nl2ek6en0R74fWbkx/gkFT539rLGQWnOC2HxKSMdQyAYtVAmZHhH/rggSNJTmjoY=\n=Y7+n\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ac00c06b0824c37dc2b3e673d764ab5468df9ba\nparent 5c98cf145dc6e71a33f4c20b64a9d8eeeaf8b1b3\nparent 0304e16f3b357c3df48b25277127c658b5169fd4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1637366981 +0100\ncommitter GitHub <noreply@github.com> 1637366981 +0100\n\nRollup merge of #90999 - RalfJung:miri_simd, r=oli-obk\n\nfix CTFE/Miri simd_insert/extract on array-style repr(simd) types\n\nThe changed test would previously fail since `place_index` would just return the only field of `f32x4`, i.e., the array -- rather than *indexing into* the array which is what we have to do.\n\nThe new helper methods will also be needed for https://github.com/rust-lang/miri/issues/1912.\n\nr? ``````@oli-obk``````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf69f9e2206c708cb0c4535cab9e7a64c23add06", "html_url": "https://github.com/rust-lang/rust/commit/cf69f9e2206c708cb0c4535cab9e7a64c23add06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf69f9e2206c708cb0c4535cab9e7a64c23add06/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c98cf145dc6e71a33f4c20b64a9d8eeeaf8b1b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c98cf145dc6e71a33f4c20b64a9d8eeeaf8b1b3", "html_url": "https://github.com/rust-lang/rust/commit/5c98cf145dc6e71a33f4c20b64a9d8eeeaf8b1b3"}, {"sha": "0304e16f3b357c3df48b25277127c658b5169fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0304e16f3b357c3df48b25277127c658b5169fd4", "html_url": "https://github.com/rust-lang/rust/commit/0304e16f3b357c3df48b25277127c658b5169fd4"}], "stats": {"total": 114, "additions": 76, "deletions": 38}, "files": [{"sha": "9bbb42eb01961b509829655517085073e622163f", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 16, "deletions": 31, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=cf69f9e2206c708cb0c4535cab9e7a64c23add06", "patch": "@@ -419,48 +419,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::simd_insert => {\n                 let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n                 let elem = &args[2];\n-                let input = &args[0];\n-                let (len, e_ty) = input.layout.ty.simd_size_and_type(*self.tcx);\n+                let (input, input_len) = self.operand_to_simd(&args[0])?;\n+                let (dest, dest_len) = self.place_to_simd(dest)?;\n+                assert_eq!(input_len, dest_len, \"Return vector length must match input length\");\n                 assert!(\n-                    index < len,\n-                    \"Index `{}` must be in bounds of vector type `{}`: `[0, {})`\",\n+                    index < dest_len,\n+                    \"Index `{}` must be in bounds of vector with length {}`\",\n                     index,\n-                    e_ty,\n-                    len\n-                );\n-                assert_eq!(\n-                    input.layout, dest.layout,\n-                    \"Return type `{}` must match vector type `{}`\",\n-                    dest.layout.ty, input.layout.ty\n-                );\n-                assert_eq!(\n-                    elem.layout.ty, e_ty,\n-                    \"Scalar element type `{}` must match vector element type `{}`\",\n-                    elem.layout.ty, e_ty\n+                    dest_len\n                 );\n \n-                for i in 0..len {\n-                    let place = self.place_index(dest, i)?;\n-                    let value = if i == index { *elem } else { self.operand_index(input, i)? };\n-                    self.copy_op(&value, &place)?;\n+                for i in 0..dest_len {\n+                    let place = self.mplace_index(&dest, i)?;\n+                    let value =\n+                        if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n+                    self.copy_op(&value, &place.into())?;\n                 }\n             }\n             sym::simd_extract => {\n                 let index = u64::from(self.read_scalar(&args[1])?.to_u32()?);\n-                let (len, e_ty) = args[0].layout.ty.simd_size_and_type(*self.tcx);\n+                let (input, input_len) = self.operand_to_simd(&args[0])?;\n                 assert!(\n-                    index < len,\n-                    \"index `{}` is out-of-bounds of vector type `{}` with length `{}`\",\n+                    index < input_len,\n+                    \"index `{}` must be in bounds of vector with length `{}`\",\n                     index,\n-                    e_ty,\n-                    len\n-                );\n-                assert_eq!(\n-                    e_ty, dest.layout.ty,\n-                    \"Return type `{}` must match vector element type `{}`\",\n-                    dest.layout.ty, e_ty\n+                    input_len\n                 );\n-                self.copy_op(&self.operand_index(&args[0], index)?, dest)?;\n+                self.copy_op(&self.mplace_index(&input, index)?.into(), dest)?;\n             }\n             sym::likely | sym::unlikely | sym::black_box => {\n                 // These just return their argument"}, {"sha": "de9e94ce2ac0c820137e5edcb9c3f68ce20f848e", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=cf69f9e2206c708cb0c4535cab9e7a64c23add06", "patch": "@@ -437,6 +437,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         })\n     }\n \n+    /// Converts a repr(simd) operand into an operand where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn operand_to_simd(\n+        &self,\n+        base: &OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        // Basically we just transmute this place into an array following simd_size_and_type.\n+        // This only works in memory, but repr(simd) types should never be immediates anyway.\n+        assert!(base.layout.ty.is_simd());\n+        self.mplace_to_simd(&base.assert_mem_place())\n+    }\n+\n     /// Read from a local. Will not actually access the local if reading from a ZST.\n     /// Will not access memory, instead an indirect `Operand` is returned.\n     ///"}, {"sha": "d7f2853fc86f508a26d70aa3b61580c97db0a2f6", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=cf69f9e2206c708cb0c4535cab9e7a64c23add06", "patch": "@@ -200,7 +200,7 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n             }\n         } else {\n             // Go through the layout.  There are lots of types that support a length,\n-            // e.g., SIMD types.\n+            // e.g., SIMD types. (But not all repr(simd) types even have FieldsShape::Array!)\n             match self.layout.fields {\n                 FieldsShape::Array { count, .. } => Ok(count),\n                 _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n@@ -533,6 +533,22 @@ where\n         })\n     }\n \n+    /// Converts a repr(simd) place into a place where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn mplace_to_simd(\n+        &self,\n+        base: &MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        // Basically we just transmute this place into an array following simd_size_and_type.\n+        // (Transmuting is okay since this is an in-memory place. We also double-check the size\n+        // stays the same.)\n+        let (len, e_ty) = base.layout.ty.simd_size_and_type(*self.tcx);\n+        let array = self.tcx.mk_array(e_ty, len);\n+        let layout = self.layout_of(array)?;\n+        assert_eq!(layout.size, base.layout.size);\n+        Ok((MPlaceTy { layout, ..*base }, len))\n+    }\n+\n     /// Gets the place of a field inside the place, and also the field's type.\n     /// Just a convenience function, but used quite a bit.\n     /// This is the only projection that might have a side-effect: We cannot project\n@@ -594,6 +610,16 @@ where\n         })\n     }\n \n+    /// Converts a repr(simd) place into a place where `place_index` accesses the SIMD elements.\n+    /// Also returns the number of elements.\n+    pub fn place_to_simd(\n+        &mut self,\n+        base: &PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (MPlaceTy<'tcx, M::PointerTag>, u64)> {\n+        let mplace = self.force_allocation(base)?;\n+        self.mplace_to_simd(&mplace)\n+    }\n+\n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place("}, {"sha": "c79e25f4781c83e0e03d90b5b4c8f4cd90dd0fd4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf69f9e2206c708cb0c4535cab9e7a64c23add06/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=cf69f9e2206c708cb0c4535cab9e7a64c23add06", "patch": "@@ -1805,17 +1805,22 @@ impl<'tcx> TyS<'tcx> {\n     pub fn simd_size_and_type(&self, tcx: TyCtxt<'tcx>) -> (u64, Ty<'tcx>) {\n         match self.kind() {\n             Adt(def, substs) => {\n+                assert!(def.repr.simd(), \"`simd_size_and_type` called on non-SIMD type\");\n                 let variant = def.non_enum_variant();\n                 let f0_ty = variant.fields[0].ty(tcx, substs);\n \n                 match f0_ty.kind() {\n+                    // If the first field is an array, we assume it is the only field and its\n+                    // elements are the SIMD components.\n                     Array(f0_elem_ty, f0_len) => {\n                         // FIXME(repr_simd): https://github.com/rust-lang/rust/pull/78863#discussion_r522784112\n                         // The way we evaluate the `N` in `[T; N]` here only works since we use\n                         // `simd_size_and_type` post-monomorphization. It will probably start to ICE\n                         // if we use it in generic code. See the `simd-array-trait` ui test.\n                         (f0_len.eval_usize(tcx, ParamEnv::empty()) as u64, f0_elem_ty)\n                     }\n+                    // Otherwise, the fields of this Adt are the SIMD components (and we assume they\n+                    // all have the same type).\n                     _ => (variant.fields.len() as u64, f0_ty),\n                 }\n             }"}, {"sha": "a1d6c5e51b49896726271f4f207da931fdc1fe06", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf69f9e2206c708cb0c4535cab9e7a64c23add06/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf69f9e2206c708cb0c4535cab9e7a64c23add06/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=cf69f9e2206c708cb0c4535cab9e7a64c23add06", "patch": "@@ -7,7 +7,9 @@\n \n #[repr(simd)] struct i8x1(i8);\n #[repr(simd)] struct u16x2(u16, u16);\n-#[repr(simd)] struct f32x4(f32, f32, f32, f32);\n+// Make some of them array types to ensure those also work.\n+#[repr(simd)] struct i8x1_arr([i8; 1]);\n+#[repr(simd)] struct f32x4([f32; 4]);\n \n extern \"platform-intrinsic\" {\n     #[rustc_const_stable(feature = \"foo\", since = \"1.3.37\")]\n@@ -25,6 +27,14 @@ fn main() {\n         assert_eq!(X0, 42);\n         assert_eq!(Y0, 42);\n     }\n+    {\n+        const U: i8x1_arr = i8x1_arr([13]);\n+        const V: i8x1_arr = unsafe { simd_insert(U, 0_u32, 42_i8) };\n+        const X0: i8 = V.0[0];\n+        const Y0: i8 = unsafe { simd_extract(V, 0) };\n+        assert_eq!(X0, 42);\n+        assert_eq!(Y0, 42);\n+    }\n     {\n         const U: u16x2 = u16x2(13, 14);\n         const V: u16x2 = unsafe { simd_insert(U, 1_u32, 42_u16) };\n@@ -38,12 +48,12 @@ fn main() {\n         assert_eq!(Y1, 42);\n     }\n     {\n-        const U: f32x4 = f32x4(13., 14., 15., 16.);\n+        const U: f32x4 = f32x4([13., 14., 15., 16.]);\n         const V: f32x4 = unsafe { simd_insert(U, 1_u32, 42_f32) };\n-        const X0: f32 = V.0;\n-        const X1: f32 = V.1;\n-        const X2: f32 = V.2;\n-        const X3: f32 = V.3;\n+        const X0: f32 = V.0[0];\n+        const X1: f32 = V.0[1];\n+        const X2: f32 = V.0[2];\n+        const X3: f32 = V.0[3];\n         const Y0: f32 = unsafe { simd_extract(V, 0) };\n         const Y1: f32 = unsafe { simd_extract(V, 1) };\n         const Y2: f32 = unsafe { simd_extract(V, 2) };"}]}