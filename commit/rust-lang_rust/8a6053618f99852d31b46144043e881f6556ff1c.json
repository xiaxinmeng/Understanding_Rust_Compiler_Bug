{"sha": "8a6053618f99852d31b46144043e881f6556ff1c", "node_id": "C_kwDOAAsO6NoAKDhhNjA1MzYxOGY5OTg1MmQzMWI0NjE0NDA0M2U4ODFmNjU1NmZmMWM", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-09T19:18:00Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-11-19T15:47:42Z"}, "message": "docs cleanup\n\n* Fix doc examples for Platforms with underaligned integer primitives.\n* Mutable pointer doc examples use mutable pointers.\n* Fill out tracking issue.\n* Minor formatting changes.", "tree": {"sha": "bd2b33c1113525a2b005e90471857abc8cf7057b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd2b33c1113525a2b005e90471857abc8cf7057b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a6053618f99852d31b46144043e881f6556ff1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6053618f99852d31b46144043e881f6556ff1c", "html_url": "https://github.com/rust-lang/rust/commit/8a6053618f99852d31b46144043e881f6556ff1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a6053618f99852d31b46144043e881f6556ff1c/comments", "author": null, "committer": null, "parents": [{"sha": "daccb8c11a464040acd744729231429dcb2e4d4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/daccb8c11a464040acd744729231429dcb2e4d4b", "html_url": "https://github.com/rust-lang/rust/commit/daccb8c11a464040acd744729231429dcb2e4d4b"}], "stats": {"total": 212, "additions": 140, "deletions": 72}, "files": [{"sha": "8a3eee0dc529f59988bdaa1fdaa8f9f8c5ddb843", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 68, "deletions": 36, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/8a6053618f99852d31b46144043e881f6556ff1c/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6053618f99852d31b46144043e881f6556ff1c/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=8a6053618f99852d31b46144043e881f6556ff1c", "patch": "@@ -1367,8 +1367,12 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(pointer_byte_offsets)]\n     ///\n-    /// let data: i32 = 42;\n-    /// let ptr: *const i32 = &data;\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let data = AlignedI32(42);\n+    /// let ptr = &data as *const AlignedI32;\n     ///\n     /// assert!(ptr.is_aligned());\n     /// assert!(!ptr.wrapping_byte_add(1).is_aligned());\n@@ -1389,15 +1393,20 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n     /// const _: () = {\n-    ///     let data: i32 = 42;\n-    ///     let ptr: *const i32 = &data;\n+    ///     let data = AlignedI32(42);\n+    ///     let ptr = &data as *const AlignedI32;\n     ///     assert!(ptr.is_aligned());\n     ///\n-    ///     // At runtime either `ptr1` or `ptr2` would be aligned,\n-    ///     // but at compiletime neither is aligned.\n-    ///     let ptr1: *const i64 = ptr.cast();\n-    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     // At runtime either `ptr1` or `ptr2` would be aligned, but at compiletime neither is aligned.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n     ///     assert!(!ptr1.is_aligned());\n     ///     assert!(!ptr2.is_aligned());\n     /// };\n@@ -1411,16 +1420,22 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n-    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n-    /// const CONST_PTR: *const i32 = &42;\n-    /// const _: () = assert!(!CONST_PTR.cast::<i64>().is_aligned());\n-    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).cast::<i64>().is_aligned());\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// const COMPTIME_PTR: *const AlignedI32 = &AlignedI32(42);\n+    /// const _: () = assert!(!COMPTIME_PTR.cast::<AlignedI64>().is_aligned());\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).cast::<AlignedI64>().is_aligned());\n     ///\n     /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n-    /// let runtime_ptr = CONST_PTR;\n+    /// let runtime_ptr = COMPTIME_PTR;\n     /// assert_ne!(\n-    ///     runtime_ptr.cast::<i64>().is_aligned(),\n-    ///     runtime_ptr.wrapping_add(1).cast::<i64>().is_aligned(),\n+    ///     runtime_ptr.cast::<AlignedI64>().is_aligned(),\n+    ///     runtime_ptr.wrapping_add(1).cast::<AlignedI64>().is_aligned(),\n     /// );\n     /// ```\n     ///\n@@ -1432,29 +1447,34 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n     /// const _: () = {\n-    ///     let ptr = 40 as *const i32;\n+    ///     let ptr = 40 as *const AlignedI32;\n     ///     assert!(ptr.is_aligned());\n     ///\n-    ///     // For pointers with a known address, runtime and\n-    ///     // compiletime behavior are identical.\n-    ///     let ptr1: *const i64 = ptr.cast();\n-    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     // For pointers with a known address, runtime and compiletime behavior are identical.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n     ///     assert!(ptr1.is_aligned());\n     ///     assert!(!ptr2.is_aligned());\n     /// };\n     /// ```\n     ///\n-    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n     pub const fn is_aligned(self) -> bool\n     where\n         T: Sized,\n     {\n-        self.is_aligned_to(core::mem::align_of::<T>())\n+        self.is_aligned_to(mem::align_of::<T>())\n     }\n \n     /// Returns whether the pointer is aligned to `align`.\n@@ -1473,8 +1493,12 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(pointer_byte_offsets)]\n     ///\n-    /// let data: i32 = 42;\n-    /// let ptr: *const i32 = &data;\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let data = AlignedI32(42);\n+    /// let ptr = &data as *const AlignedI32;\n     ///\n     /// assert!(ptr.is_aligned_to(1));\n     /// assert!(ptr.is_aligned_to(2));\n@@ -1500,9 +1524,13 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n     /// const _: () = {\n-    ///     let data: i32 = 42;\n-    ///     let ptr: *const i32 = &data;\n+    ///     let data = AlignedI32(42);\n+    ///     let ptr = &data as *const AlignedI32;\n     ///\n     ///     assert!(ptr.is_aligned_to(1));\n     ///     assert!(ptr.is_aligned_to(2));\n@@ -1522,13 +1550,17 @@ impl<T: ?Sized> *const T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n-    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n-    /// const CONST_PTR: *const i32 = &42;\n-    /// const _: () = assert!(!CONST_PTR.is_aligned_to(8));\n-    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).is_aligned_to(8));\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// const COMPTIME_PTR: *const AlignedI32 = &AlignedI32(42);\n+    /// const _: () = assert!(!COMPTIME_PTR.is_aligned_to(8));\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).is_aligned_to(8));\n     ///\n     /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n-    /// let runtime_ptr = CONST_PTR;\n+    /// let runtime_ptr = COMPTIME_PTR;\n     /// assert_ne!(\n     ///     runtime_ptr.is_aligned_to(8),\n     ///     runtime_ptr.wrapping_add(1).is_aligned_to(8),\n@@ -1544,7 +1576,7 @@ impl<T: ?Sized> *const T {\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n     /// const _: () = {\n-    ///     let ptr = 40 as *const i32;\n+    ///     let ptr = 40 as *const u8;\n     ///     assert!(ptr.is_aligned_to(1));\n     ///     assert!(ptr.is_aligned_to(2));\n     ///     assert!(ptr.is_aligned_to(4));\n@@ -1553,14 +1585,14 @@ impl<T: ?Sized> *const T {\n     /// };\n     /// ```\n     ///\n-    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n     pub const fn is_aligned_to(self, align: usize) -> bool {\n         if !align.is_power_of_two() {\n-            panic!(\"is_aligned_to: align is not a power-of-two\")\n+            panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n         // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead."}, {"sha": "8472b05ddbd40a595f6b1d3bdb8d2b2ba98a5438", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8a6053618f99852d31b46144043e881f6556ff1c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6053618f99852d31b46144043e881f6556ff1c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=8a6053618f99852d31b46144043e881f6556ff1c", "patch": "@@ -1635,8 +1635,12 @@ impl<T: ?Sized> *mut T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(pointer_byte_offsets)]\n     ///\n-    /// let data: i32 = 42;\n-    /// let ptr: *const i32 = &data;\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let mut data = AlignedI32(42);\n+    /// let ptr = &mut data as *mut AlignedI32;\n     ///\n     /// assert!(ptr.is_aligned());\n     /// assert!(!ptr.wrapping_byte_add(1).is_aligned());\n@@ -1656,16 +1660,22 @@ impl<T: ?Sized> *mut T {\n     #[cfg_attr(not(bootstrap), doc = \"```\")]\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n+    /// #![feature(const_mut_refs)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n     ///\n     /// const _: () = {\n-    ///     let data: i32 = 42;\n-    ///     let ptr: *const i32 = &data;\n+    ///     let mut data = AlignedI32(42);\n+    ///     let ptr = &mut data as *mut AlignedI32;\n     ///     assert!(ptr.is_aligned());\n     ///\n-    ///     // At runtime either `ptr1` or `ptr2` would be aligned,\n-    ///     // but at compiletime neither is aligned.\n-    ///     let ptr1: *const i64 = ptr.cast();\n-    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     // At runtime either `ptr1` or `ptr2` would be aligned, but at compiletime neither is aligned.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n     ///     assert!(!ptr1.is_aligned());\n     ///     assert!(!ptr2.is_aligned());\n     /// };\n@@ -1679,16 +1689,23 @@ impl<T: ?Sized> *mut T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n-    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n-    /// const CONST_PTR: *const i32 = &42;\n-    /// const _: () = assert!(!CONST_PTR.cast::<i64>().is_aligned());\n-    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).cast::<i64>().is_aligned());\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// // Also, note that mutable references are not allowed in the final value of constants.\n+    /// const COMPTIME_PTR: *mut AlignedI32 = (&AlignedI32(42) as *const AlignedI32).cast_mut();\n+    /// const _: () = assert!(!COMPTIME_PTR.cast::<AlignedI64>().is_aligned());\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).cast::<AlignedI64>().is_aligned());\n     ///\n     /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n-    /// let runtime_ptr = CONST_PTR;\n+    /// let runtime_ptr = COMPTIME_PTR;\n     /// assert_ne!(\n-    ///     runtime_ptr.cast::<i64>().is_aligned(),\n-    ///     runtime_ptr.wrapping_add(1).cast::<i64>().is_aligned(),\n+    ///     runtime_ptr.cast::<AlignedI64>().is_aligned(),\n+    ///     runtime_ptr.wrapping_add(1).cast::<AlignedI64>().is_aligned(),\n     /// );\n     /// ```\n     ///\n@@ -1700,29 +1717,34 @@ impl<T: ?Sized> *mut T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n     /// const _: () = {\n-    ///     let ptr = 40 as *const i32;\n+    ///     let ptr = 40 as *mut AlignedI32;\n     ///     assert!(ptr.is_aligned());\n     ///\n-    ///     // For pointers with a known address, runtime and\n-    ///     // compiletime behavior are identical.\n-    ///     let ptr1: *const i64 = ptr.cast();\n-    ///     let ptr2: *const i64 = ptr.wrapping_add(1).cast();\n+    ///     // For pointers with a known address, runtime and compiletime behavior are identical.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n     ///     assert!(ptr1.is_aligned());\n     ///     assert!(!ptr2.is_aligned());\n     /// };\n     /// ```\n     ///\n-    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n     pub const fn is_aligned(self) -> bool\n     where\n         T: Sized,\n     {\n-        self.is_aligned_to(core::mem::align_of::<T>())\n+        self.is_aligned_to(mem::align_of::<T>())\n     }\n \n     /// Returns whether the pointer is aligned to `align`.\n@@ -1741,8 +1763,12 @@ impl<T: ?Sized> *mut T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(pointer_byte_offsets)]\n     ///\n-    /// let data: i32 = 42;\n-    /// let ptr: *const i32 = &data;\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let mut data = AlignedI32(42);\n+    /// let ptr = &mut data as *mut AlignedI32;\n     ///\n     /// assert!(ptr.is_aligned_to(1));\n     /// assert!(ptr.is_aligned_to(2));\n@@ -1767,10 +1793,15 @@ impl<T: ?Sized> *mut T {\n     #[cfg_attr(not(bootstrap), doc = \"```\")]\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n+    /// #![feature(const_mut_refs)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n     ///\n     /// const _: () = {\n-    ///     let data: i32 = 42;\n-    ///     let ptr: *const i32 = &data;\n+    ///     let mut data = AlignedI32(42);\n+    ///     let ptr = &mut data as *mut AlignedI32;\n     ///\n     ///     assert!(ptr.is_aligned_to(1));\n     ///     assert!(ptr.is_aligned_to(2));\n@@ -1790,13 +1821,18 @@ impl<T: ?Sized> *mut T {\n     /// #![feature(pointer_is_aligned)]\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n-    /// // At compiletime, neither `CONST_PTR` nor `CONST_PTR + 1` is aligned.\n-    /// const CONST_PTR: *const i32 = &42;\n-    /// const _: () = assert!(!CONST_PTR.is_aligned_to(8));\n-    /// const _: () = assert!(!CONST_PTR.wrapping_add(1).is_aligned_to(8));\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// // Also, note that mutable references are not allowed in the final value of constants.\n+    /// const COMPTIME_PTR: *mut AlignedI32 = (&AlignedI32(42) as *const AlignedI32).cast_mut();\n+    /// const _: () = assert!(!COMPTIME_PTR.is_aligned_to(8));\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).is_aligned_to(8));\n     ///\n     /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n-    /// let runtime_ptr = CONST_PTR;\n+    /// let runtime_ptr = COMPTIME_PTR;\n     /// assert_ne!(\n     ///     runtime_ptr.is_aligned_to(8),\n     ///     runtime_ptr.wrapping_add(1).is_aligned_to(8),\n@@ -1812,7 +1848,7 @@ impl<T: ?Sized> *mut T {\n     /// #![feature(const_pointer_is_aligned)]\n     ///\n     /// const _: () = {\n-    ///     let ptr = 40 as *const i32;\n+    ///     let ptr = 40 as *mut u8;\n     ///     assert!(ptr.is_aligned_to(1));\n     ///     assert!(ptr.is_aligned_to(2));\n     ///     assert!(ptr.is_aligned_to(4));\n@@ -1821,14 +1857,14 @@ impl<T: ?Sized> *mut T {\n     /// };\n     /// ```\n     ///\n-    /// [tracking issue]: https://github.com/rust-lang/rust/issues/comming-soon\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"none\")]\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n     pub const fn is_aligned_to(self, align: usize) -> bool {\n         if !align.is_power_of_two() {\n-            panic!(\"is_aligned_to: align is not a power-of-two\")\n+            panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n         // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead."}]}