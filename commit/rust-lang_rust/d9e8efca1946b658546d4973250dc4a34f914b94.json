{"sha": "d9e8efca1946b658546d4973250dc4a34f914b94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZThlZmNhMTk0NmI2NTg1NDZkNDk3MzI1MGRjNGEzNGY5MTRiOTQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-25T04:47:25Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-25T17:22:43Z"}, "message": "Handle notification channels in task.rs", "tree": {"sha": "f16bafb9c22bc92f0dde4618163a81c9dfa72df9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f16bafb9c22bc92f0dde4618163a81c9dfa72df9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9e8efca1946b658546d4973250dc4a34f914b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9e8efca1946b658546d4973250dc4a34f914b94", "html_url": "https://github.com/rust-lang/rust/commit/d9e8efca1946b658546d4973250dc4a34f914b94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9e8efca1946b658546d4973250dc4a34f914b94/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e241b5abd79bb7e69734f5e4b3a1bf2afc5ff08", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e241b5abd79bb7e69734f5e4b3a1bf2afc5ff08", "html_url": "https://github.com/rust-lang/rust/commit/1e241b5abd79bb7e69734f5e4b3a1bf2afc5ff08"}], "stats": {"total": 51, "additions": 34, "deletions": 17}, "files": [{"sha": "04ff9058b37c1be374c35ae19346034525025389", "filename": "src/libcore/task.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d9e8efca1946b658546d4973250dc4a34f914b94/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9e8efca1946b658546d4973250dc4a34f914b94/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=d9e8efca1946b658546d4973250dc4a34f914b94", "patch": "@@ -612,18 +612,23 @@ class taskgroup {\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n     let parents:    option<(taskgroup_arc,uint)>;\n     let is_main:    bool;\n+    let notifier:   option<auto_notify>;\n     new(me: *rust_task, -tasks: taskgroup_arc, my_pos: uint,\n-        -parents: option<(taskgroup_arc,uint)>, is_main: bool) {\n-        self.me      = me;\n-        self.tasks   = tasks;\n-        self.my_pos  = my_pos;\n-        self.parents = parents;\n-        self.is_main = is_main;\n+        -parents: option<(taskgroup_arc,uint)>, is_main: bool,\n+        -notifier: option<auto_notify>) {\n+        self.me       = me;\n+        self.tasks    = tasks;\n+        self.my_pos   = my_pos;\n+        self.parents  = parents;\n+        self.is_main  = is_main;\n+        self.notifier = notifier;\n+        self.notifier.iter(|x| { x.failed = false; });\n     }\n     // Runs on task exit.\n     drop {\n         // If we are failing, the whole taskgroup needs to die.\n         if rustrt::rust_task_is_unwinding(self.me) {\n+            self.notifier.iter(|x| { x.failed = true; });\n             // Take everybody down with us.\n             kill_taskgroup(self.tasks, self.me, self.my_pos, self.is_main);\n         } else {\n@@ -641,6 +646,19 @@ class taskgroup {\n     }\n }\n \n+class auto_notify {\n+    let notify_chan: comm::chan<notification>;\n+    let mut failed:  bool;\n+    new(chan: comm::chan<notification>) {\n+        self.notify_chan = chan;\n+        self.failed = true; // Un-set above when taskgroup successfully made.\n+    }\n+    drop {\n+        let result = if self.failed { failure } else { success };\n+        comm::send(self.notify_chan, exit(get_task(), result));\n+    }\n+}\n+\n fn enlist_in_taskgroup(group_arc: taskgroup_arc,\n                        me: *rust_task) -> option<uint> {\n     do group_arc.with |_c, state| {\n@@ -750,7 +768,7 @@ fn share_spawner_taskgroup(linked: bool)\n             let tasks = arc::exclusive(some((dvec::from_elem(some(me)),\n                                              dvec::dvec())));\n             // Main group has no parent group.\n-            let group = @taskgroup(me, tasks.clone(), 0, none, true);\n+            let group = @taskgroup(me, tasks.clone(), 0, none, true, none);\n             unsafe { local_set(me, taskgroup_key(), group); }\n             // Tell child task it's also in the main group.\n             // Whether or not it wanted our parent group, we haven't got one.\n@@ -796,15 +814,11 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // Getting killed after here would leak the task.\n \n             let child_wrapper =\n-                make_child_wrapper(new_task, child_tg, parent_tg, is_main, f);\n+                make_child_wrapper(new_task, child_tg, parent_tg, is_main,\n+                                   opts.notify_chan, f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n \n-            do option::iter(opts.notify_chan) |c| {\n-                // FIXME (#1087): Would like to do notification in Rust\n-                rustrt::rust_task_config_notify(new_task, c);\n-            }\n-\n             // Getting killed between these two calls would free the child's\n             // closure. (Reordering them wouldn't help - then getting killed\n             // between them would leak.)\n@@ -829,6 +843,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     //     }\n     fn make_child_wrapper(child: *rust_task, -child_tg: taskgroup_arc,\n                           -parent_tg: option<taskgroup_arc>, is_main: bool,\n+                          notify_chan: option<comm::chan<notification>>,\n                           -f: fn~()) -> fn~() {\n         let child_tg_ptr = ~mut some((child_tg, parent_tg));\n         fn~() {\n@@ -837,6 +852,11 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             *child_tg_ptr <-> tg_data_opt;\n             let (child_tg, parent_tg) = option::unwrap(tg_data_opt);\n             // Child task runs this code.\n+\n+            // Even if the below code fails to kick the child off, we must\n+            // send something on the notify channel.\n+            let notifier = notify_chan.map(|c| auto_notify(c));\n+\n             // Set up membership in taskgroup. If this returns none, some\n             // task was already failing, so don't bother doing anything.\n             alt enlist_in_taskgroup(child_tg, child) {\n@@ -862,7 +882,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n                     };\n                     if enlist_ok {\n                         let group = @taskgroup(child, child_tg, my_pos,\n-                                               pg, is_main);\n+                                               pg, is_main, notifier);\n                         unsafe { local_set(child, taskgroup_key(), group); }\n                         // Run the child's body.\n                         f();\n@@ -1129,9 +1149,6 @@ extern mod rustrt {\n     fn new_task() -> *rust_task;\n     fn rust_new_task_in_sched(id: sched_id) -> *rust_task;\n \n-    fn rust_task_config_notify(\n-        task: *rust_task, &&chan: comm::chan<notification>);\n-\n     fn start_task(task: *rust_task, closure: *rust_closure);\n \n     fn rust_task_is_unwinding(task: *rust_task) -> bool;"}]}