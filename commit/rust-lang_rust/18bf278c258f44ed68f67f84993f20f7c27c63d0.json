{"sha": "18bf278c258f44ed68f67f84993f20f7c27c63d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4YmYyNzhjMjU4ZjQ0ZWQ2OGY2N2Y4NDk5M2YyMGY3YzI3YzYzZDA=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-22T18:01:12Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-22T18:02:32Z"}, "message": "Handle associated type shorthand (`T::Item`)\n\nThis is only allowed for generic parameters (including `Self` in traits), and\nspecial care needs to be taken to not run into cycles while resolving it,\nbecause we use the where clauses of the generic parameter to find candidates for\nthe trait containing the associated type, but the where clauses may themselves\ncontain instances of short-hand associated types.\n\nIn some cases this is even fine, e.g. we might have `T: Trait<U::Item>, U:\nIterator`. If there is a cycle, we'll currently panic, which isn't great, but\nbetter than overflowing the stack...", "tree": {"sha": "3c07347cee581c61107950b1ed9daed191027f5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c07347cee581c61107950b1ed9daed191027f5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18bf278c258f44ed68f67f84993f20f7c27c63d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18bf278c258f44ed68f67f84993f20f7c27c63d0", "html_url": "https://github.com/rust-lang/rust/commit/18bf278c258f44ed68f67f84993f20f7c27c63d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18bf278c258f44ed68f67f84993f20f7c27c63d0/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "468e1d14c1a4b3d646207ae919082dc17753cd31", "url": "https://api.github.com/repos/rust-lang/rust/commits/468e1d14c1a4b3d646207ae919082dc17753cd31", "html_url": "https://github.com/rust-lang/rust/commit/468e1d14c1a4b3d646207ae919082dc17753cd31"}], "stats": {"total": 930, "additions": 538, "deletions": 392}, "files": [{"sha": "965a64c9870c1836327baa741f1cba7768b66e9e", "filename": "crates/ra_assists/src/raw_string.rs", "status": "modified", "additions": 370, "deletions": 370, "changes": 740, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_assists%2Fsrc%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_assists%2Fsrc%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fraw_string.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -1,370 +1,370 @@\n-use hir::db::HirDatabase;\r\n-use ra_syntax::{ast::AstNode, ast::Literal, TextRange, TextUnit};\r\n-\r\n-use crate::{Assist, AssistCtx, AssistId};\r\n-\r\n-pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n-    let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() != ra_syntax::SyntaxKind::STRING {\r\n-        return None;\r\n-    }\r\n-    ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\r\n-        edit.target(literal.syntax().text_range());\r\n-        edit.insert(literal.syntax().text_range().start(), \"r\");\r\n-    });\r\n-    ctx.build()\r\n-}\r\n-\r\n-fn find_usual_string_range(s: &str) -> Option<TextRange> {\r\n-    Some(TextRange::from_to(\r\n-        TextUnit::from(s.find('\"')? as u32),\r\n-        TextUnit::from(s.rfind('\"')? as u32),\r\n-    ))\r\n-}\r\n-\r\n-pub(crate) fn make_usual_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n-    let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\r\n-        return None;\r\n-    }\r\n-    let token = literal.token();\r\n-    let text = token.text().as_str();\r\n-    let usual_string_range = find_usual_string_range(text)?;\r\n-    ctx.add_action(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\r\n-        edit.target(literal.syntax().text_range());\r\n-        // parse inside string to escape `\"`\r\n-        let start_of_inside = usual_string_range.start().to_usize() + 1;\r\n-        let end_of_inside = usual_string_range.end().to_usize();\r\n-        let inside_str = &text[start_of_inside..end_of_inside];\r\n-        let escaped = inside_str.escape_default().to_string();\r\n-        edit.replace(literal.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\r\n-    });\r\n-    ctx.build()\r\n-}\r\n-\r\n-pub(crate) fn add_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n-    let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\r\n-        return None;\r\n-    }\r\n-    ctx.add_action(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\r\n-        edit.target(literal.syntax().text_range());\r\n-        edit.insert(literal.syntax().text_range().start() + TextUnit::of_char('r'), \"#\");\r\n-        edit.insert(literal.syntax().text_range().end(), \"#\");\r\n-    });\r\n-    ctx.build()\r\n-}\r\n-\r\n-pub(crate) fn remove_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\r\n-    let literal = ctx.node_at_offset::<Literal>()?;\r\n-    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\r\n-        return None;\r\n-    }\r\n-    let token = literal.token();\r\n-    let text = token.text().as_str();\r\n-    if text.starts_with(\"r\\\"\") {\r\n-        // no hash to remove\r\n-        return None;\r\n-    }\r\n-    ctx.add_action(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\r\n-        edit.target(literal.syntax().text_range());\r\n-        let result = &text[2..text.len() - 1];\r\n-        let result = if result.starts_with(\"\\\"\") {\r\n-            // no more hash, escape\r\n-            let internal_str = &result[1..result.len() - 1];\r\n-            format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\r\n-        } else {\r\n-            result.to_owned()\r\n-        };\r\n-        edit.replace(literal.syntax().text_range(), format!(\"r{}\", result));\r\n-    });\r\n-    ctx.build()\r\n-}\r\n-\r\n-#[cfg(test)]\r\n-mod test {\r\n-    use super::*;\r\n-    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\r\n-\r\n-    #[test]\r\n-    fn make_raw_string_target() {\r\n-        check_assist_target(\r\n-            make_raw_string,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"#,\r\n-            r#\"\"random string\"\"#,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_raw_string_works() {\r\n-        check_assist(\r\n-            make_raw_string,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"#,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random string\";\r\n-            }\r\n-            \"#,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_raw_string_with_escaped_works() {\r\n-        check_assist(\r\n-            make_raw_string,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random\\nstring\";\r\n-            }\r\n-            \"#,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random\\nstring\";\r\n-            }\r\n-            \"#,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_raw_string_not_works() {\r\n-        check_assist_not_applicable(\r\n-            make_raw_string,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random string\";\r\n-            }\r\n-            \"#,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn add_hash_target() {\r\n-        check_assist_target(\r\n-            add_hash,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random string\";\r\n-            }\r\n-            \"#,\r\n-            r#\"r\"random string\"\"#,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn add_hash_works() {\r\n-        check_assist(\r\n-            add_hash,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random string\";\r\n-            }\r\n-            \"#,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random string\"#;\r\n-            }\r\n-            \"##,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn add_more_hash_works() {\r\n-        check_assist(\r\n-            add_hash,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random\"string\"#;\r\n-            }\r\n-            \"##,\r\n-            r###\"\r\n-            fn f() {\r\n-                let s = <|>r##\"random\"string\"##;\r\n-            }\r\n-            \"###,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn add_hash_not_works() {\r\n-        check_assist_not_applicable(\r\n-            add_hash,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"#,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn remove_hash_target() {\r\n-        check_assist_target(\r\n-            remove_hash,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random string\"#;\r\n-            }\r\n-            \"##,\r\n-            r##\"r#\"random string\"#\"##,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn remove_hash_works() {\r\n-        check_assist(\r\n-            remove_hash,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random string\"#;\r\n-            }\r\n-            \"##,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random string\";\r\n-            }\r\n-            \"#,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn remove_hash_with_quote_works() {\r\n-        check_assist(\r\n-            remove_hash,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random\"str\"ing\"#;\r\n-            }\r\n-            \"##,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random\\\"str\\\"ing\";\r\n-            }\r\n-            \"#,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn remove_more_hash_works() {\r\n-        check_assist(\r\n-            remove_hash,\r\n-            r###\"\r\n-            fn f() {\r\n-                let s = <|>r##\"random string\"##;\r\n-            }\r\n-            \"###,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random string\"#;\r\n-            }\r\n-            \"##,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn remove_hash_not_works() {\r\n-        check_assist_not_applicable(\r\n-            remove_hash,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"#,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn remove_hash_no_hash_not_works() {\r\n-        check_assist_not_applicable(\r\n-            remove_hash,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>r\"random string\";\r\n-            }\r\n-            \"#,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_usual_string_target() {\r\n-        check_assist_target(\r\n-            make_usual_string,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random string\"#;\r\n-            }\r\n-            \"##,\r\n-            r##\"r#\"random string\"#\"##,\r\n-        );\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_usual_string_works() {\r\n-        check_assist(\r\n-            make_usual_string,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random string\"#;\r\n-            }\r\n-            \"##,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"#,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_usual_string_with_quote_works() {\r\n-        check_assist(\r\n-            make_usual_string,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>r#\"random\"str\"ing\"#;\r\n-            }\r\n-            \"##,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random\\\"str\\\"ing\";\r\n-            }\r\n-            \"#,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_usual_string_more_hash_works() {\r\n-        check_assist(\r\n-            make_usual_string,\r\n-            r###\"\r\n-            fn f() {\r\n-                let s = <|>r##\"random string\"##;\r\n-            }\r\n-            \"###,\r\n-            r##\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"##,\r\n-        )\r\n-    }\r\n-\r\n-    #[test]\r\n-    fn make_usual_string_not_works() {\r\n-        check_assist_not_applicable(\r\n-            make_usual_string,\r\n-            r#\"\r\n-            fn f() {\r\n-                let s = <|>\"random string\";\r\n-            }\r\n-            \"#,\r\n-        );\r\n-    }\r\n-}\r\n+use hir::db::HirDatabase;\n+use ra_syntax::{ast::AstNode, ast::Literal, TextRange, TextUnit};\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+\n+pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let literal = ctx.node_at_offset::<Literal>()?;\n+    if literal.token().kind() != ra_syntax::SyntaxKind::STRING {\n+        return None;\n+    }\n+    ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n+        edit.target(literal.syntax().text_range());\n+        edit.insert(literal.syntax().text_range().start(), \"r\");\n+    });\n+    ctx.build()\n+}\n+\n+fn find_usual_string_range(s: &str) -> Option<TextRange> {\n+    Some(TextRange::from_to(\n+        TextUnit::from(s.find('\"')? as u32),\n+        TextUnit::from(s.rfind('\"')? as u32),\n+    ))\n+}\n+\n+pub(crate) fn make_usual_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let literal = ctx.node_at_offset::<Literal>()?;\n+    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n+        return None;\n+    }\n+    let token = literal.token();\n+    let text = token.text().as_str();\n+    let usual_string_range = find_usual_string_range(text)?;\n+    ctx.add_action(AssistId(\"make_usual_string\"), \"make usual string\", |edit| {\n+        edit.target(literal.syntax().text_range());\n+        // parse inside string to escape `\"`\n+        let start_of_inside = usual_string_range.start().to_usize() + 1;\n+        let end_of_inside = usual_string_range.end().to_usize();\n+        let inside_str = &text[start_of_inside..end_of_inside];\n+        let escaped = inside_str.escape_default().to_string();\n+        edit.replace(literal.syntax().text_range(), format!(\"\\\"{}\\\"\", escaped));\n+    });\n+    ctx.build()\n+}\n+\n+pub(crate) fn add_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let literal = ctx.node_at_offset::<Literal>()?;\n+    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n+        return None;\n+    }\n+    ctx.add_action(AssistId(\"add_hash\"), \"add hash to raw string\", |edit| {\n+        edit.target(literal.syntax().text_range());\n+        edit.insert(literal.syntax().text_range().start() + TextUnit::of_char('r'), \"#\");\n+        edit.insert(literal.syntax().text_range().end(), \"#\");\n+    });\n+    ctx.build()\n+}\n+\n+pub(crate) fn remove_hash(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let literal = ctx.node_at_offset::<Literal>()?;\n+    if literal.token().kind() != ra_syntax::SyntaxKind::RAW_STRING {\n+        return None;\n+    }\n+    let token = literal.token();\n+    let text = token.text().as_str();\n+    if text.starts_with(\"r\\\"\") {\n+        // no hash to remove\n+        return None;\n+    }\n+    ctx.add_action(AssistId(\"remove_hash\"), \"remove hash from raw string\", |edit| {\n+        edit.target(literal.syntax().text_range());\n+        let result = &text[2..text.len() - 1];\n+        let result = if result.starts_with(\"\\\"\") {\n+            // no more hash, escape\n+            let internal_str = &result[1..result.len() - 1];\n+            format!(\"\\\"{}\\\"\", internal_str.escape_default().to_string())\n+        } else {\n+            result.to_owned()\n+        };\n+        edit.replace(literal.syntax().text_range(), format!(\"r{}\", result));\n+    });\n+    ctx.build()\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    #[test]\n+    fn make_raw_string_target() {\n+        check_assist_target(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"#,\n+            r#\"\"random string\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn make_raw_string_works() {\n+        check_assist(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"#,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random string\";\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn make_raw_string_with_escaped_works() {\n+        check_assist(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random\\nstring\";\n+            }\n+            \"#,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random\\nstring\";\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn make_raw_string_not_works() {\n+        check_assist_not_applicable(\n+            make_raw_string,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random string\";\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_hash_target() {\n+        check_assist_target(\n+            add_hash,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random string\";\n+            }\n+            \"#,\n+            r#\"r\"random string\"\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn add_hash_works() {\n+        check_assist(\n+            add_hash,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random string\";\n+            }\n+            \"#,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random string\"#;\n+            }\n+            \"##,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_more_hash_works() {\n+        check_assist(\n+            add_hash,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random\"string\"#;\n+            }\n+            \"##,\n+            r###\"\n+            fn f() {\n+                let s = <|>r##\"random\"string\"##;\n+            }\n+            \"###,\n+        )\n+    }\n+\n+    #[test]\n+    fn add_hash_not_works() {\n+        check_assist_not_applicable(\n+            add_hash,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_hash_target() {\n+        check_assist_target(\n+            remove_hash,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random string\"#;\n+            }\n+            \"##,\n+            r##\"r#\"random string\"#\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_hash_works() {\n+        check_assist(\n+            remove_hash,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random string\"#;\n+            }\n+            \"##,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random string\";\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn remove_hash_with_quote_works() {\n+        check_assist(\n+            remove_hash,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random\"str\"ing\"#;\n+            }\n+            \"##,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random\\\"str\\\"ing\";\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn remove_more_hash_works() {\n+        check_assist(\n+            remove_hash,\n+            r###\"\n+            fn f() {\n+                let s = <|>r##\"random string\"##;\n+            }\n+            \"###,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random string\"#;\n+            }\n+            \"##,\n+        )\n+    }\n+\n+    #[test]\n+    fn remove_hash_not_works() {\n+        check_assist_not_applicable(\n+            remove_hash,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_hash_no_hash_not_works() {\n+        check_assist_not_applicable(\n+            remove_hash,\n+            r#\"\n+            fn f() {\n+                let s = <|>r\"random string\";\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn make_usual_string_target() {\n+        check_assist_target(\n+            make_usual_string,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random string\"#;\n+            }\n+            \"##,\n+            r##\"r#\"random string\"#\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn make_usual_string_works() {\n+        check_assist(\n+            make_usual_string,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random string\"#;\n+            }\n+            \"##,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn make_usual_string_with_quote_works() {\n+        check_assist(\n+            make_usual_string,\n+            r##\"\n+            fn f() {\n+                let s = <|>r#\"random\"str\"ing\"#;\n+            }\n+            \"##,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random\\\"str\\\"ing\";\n+            }\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn make_usual_string_more_hash_works() {\n+        check_assist(\n+            make_usual_string,\n+            r###\"\n+            fn f() {\n+                let s = <|>r##\"random string\"##;\n+            }\n+            \"###,\n+            r##\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"##,\n+        )\n+    }\n+\n+    #[test]\n+    fn make_usual_string_not_works() {\n+        check_assist_not_applicable(\n+            make_usual_string,\n+            r#\"\n+            fn f() {\n+                let s = <|>\"random string\";\n+            }\n+            \"#,\n+        );\n+    }\n+}"}, {"sha": "05259dcbb7e1104d10b4887b7fb36a8d2fccd81e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -164,6 +164,13 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::callable_item_sig)]\n     fn callable_item_signature(&self, def: CallableDef) -> FnSig;\n \n+    #[salsa::invoke(crate::ty::generic_predicates_for_param_query)]\n+    fn generic_predicates_for_param(\n+        &self,\n+        def: GenericDef,\n+        param_idx: u32,\n+    ) -> Arc<[GenericPredicate]>;\n+\n     #[salsa::invoke(crate::ty::generic_predicates_query)]\n     fn generic_predicates(&self, def: GenericDef) -> Arc<[GenericPredicate]>;\n "}, {"sha": "ccb7774920091259b7eac5d5cc0b652c58cd5291", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -26,8 +26,9 @@ pub struct GenericParam {\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n-#[derive(Clone, PartialEq, Eq, Debug, Default)]\n+#[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParams {\n+    pub(crate) def: GenericDef,\n     pub(crate) parent_params: Option<Arc<GenericParams>>,\n     pub(crate) params: Vec<GenericParam>,\n     pub(crate) where_predicates: Vec<WherePredicate>,\n@@ -69,15 +70,19 @@ impl GenericParams {\n         db: &(impl DefDatabase + AstDatabase),\n         def: GenericDef,\n     ) -> Arc<GenericParams> {\n-        let mut generics = GenericParams::default();\n         let parent = match def {\n             GenericDef::Function(it) => it.container(db).map(GenericDef::from),\n             GenericDef::TypeAlias(it) => it.container(db).map(GenericDef::from),\n             GenericDef::EnumVariant(it) => Some(it.parent_enum(db).into()),\n             GenericDef::Adt(_) | GenericDef::Trait(_) => None,\n             GenericDef::ImplBlock(_) => None,\n         };\n-        generics.parent_params = parent.map(|p| db.generic_params(p));\n+        let mut generics = GenericParams {\n+            def,\n+            params: Vec::new(),\n+            parent_params: parent.map(|p| db.generic_params(p)),\n+            where_predicates: Vec::new(),\n+        };\n         let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         match def {"}, {"sha": "39f8e1d8a519659e3c681d7d21c5566cf76b27e6", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -344,6 +344,13 @@ impl Resolver {\n             })\n             .flat_map(|params| params.where_predicates.iter())\n     }\n+\n+    pub(crate) fn generic_def(&self) -> Option<crate::generics::GenericDef> {\n+        self.scopes.iter().find_map(|scope| match scope {\n+            Scope::GenericParams(params) => Some(params.def),\n+            _ => None,\n+        })\n+    }\n }\n \n impl Resolver {"}, {"sha": "36bfb10cef61f3045382195a437c40368b41dfc1", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -23,8 +23,8 @@ pub(crate) use autoderef::autoderef;\n pub(crate) use infer::{infer_query, InferTy, InferenceResult};\n pub use lower::CallableDef;\n pub(crate) use lower::{\n-    callable_item_sig, generic_defaults_query, generic_predicates_query, type_for_def,\n-    type_for_field, TypableDef,\n+    callable_item_sig, generic_defaults_query, generic_predicates_for_param_query,\n+    generic_predicates_query, type_for_def, type_for_field, TypableDef,\n };\n pub(crate) use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n "}, {"sha": "8d71abc95d2103fd50aeb51f79980c258147410f", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 88, "deletions": 9, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -86,6 +86,35 @@ impl Ty {\n         }\n     }\n \n+    /// This is only for `generic_predicates_for_param`, where we can't just\n+    /// lower the self types of the predicates since that could lead to cycles.\n+    /// So we just check here if the `type_ref` resolves to a generic param, and which.\n+    fn from_hir_only_param(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        type_ref: &TypeRef,\n+    ) -> Option<u32> {\n+        let path = match type_ref {\n+            TypeRef::Path(path) => path,\n+            _ => return None,\n+        };\n+        if let crate::PathKind::Type(_) = &path.kind {\n+            return None;\n+        }\n+        if path.segments.len() > 1 {\n+            return None;\n+        }\n+        let resolution = match resolver.resolve_path_in_type_ns(db, path) {\n+            Some((it, None)) => it,\n+            _ => return None,\n+        };\n+        if let TypeNs::GenericParam(idx) = resolution {\n+            Some(idx)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub(crate) fn from_type_relative_path(\n         db: &impl HirDatabase,\n         resolver: &Resolver,\n@@ -189,11 +218,37 @@ impl Ty {\n     }\n \n     fn select_associated_type(\n-        _db: &impl HirDatabase,\n-        _resolver: &Resolver,\n-        _self_ty: Ty,\n-        _segment: &PathSegment,\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        self_ty: Ty,\n+        segment: &PathSegment,\n     ) -> Ty {\n+        let param_idx = match self_ty {\n+            Ty::Param { idx, .. } => idx,\n+            _ => return Ty::Unknown, // Error: Ambiguous associated type\n+        };\n+        let def = match resolver.generic_def() {\n+            Some(def) => def,\n+            None => return Ty::Unknown, // this can't actually happen\n+        };\n+        let predicates = db.generic_predicates_for_param(def, param_idx);\n+        let traits_from_env = predicates.iter().filter_map(|pred| match pred {\n+            GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n+            _ => None,\n+        });\n+        let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n+        for t in traits {\n+            if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n+                let generics = t.generic_params(db);\n+                let mut substs = Vec::new();\n+                substs.push(self_ty.clone());\n+                substs.extend(\n+                    iter::repeat(Ty::Unknown).take(generics.count_params_including_parent() - 1),\n+                );\n+                // FIXME handle type parameters on the segment\n+                return Ty::Projection(ProjectionTy { associated_ty, parameters: substs.into() });\n+            }\n+        }\n         Ty::Unknown\n     }\n \n@@ -269,9 +324,10 @@ pub(super) fn substs_from_path_segment(\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| def.generic_params(db)).unwrap_or_default();\n+    let def_generics = def_generic.map(|def| def.generic_params(db));\n \n-    let parent_param_count = def_generics.count_parent_params();\n+    let (parent_param_count, param_count) =\n+        def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n     substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n     if add_self_param {\n         // FIXME this add_self_param argument is kind of a hack: Traits have the\n@@ -283,7 +339,7 @@ pub(super) fn substs_from_path_segment(\n     if let Some(generic_args) = &segment.args_and_bindings {\n         // if args are provided, it should be all of them, but we can't rely on that\n         let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let param_count = def_generics.params.len() - self_param_correction;\n+        let param_count = param_count - self_param_correction;\n         for arg in generic_args.args.iter().take(param_count) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n@@ -295,10 +351,10 @@ pub(super) fn substs_from_path_segment(\n     }\n     // add placeholders for args that were not provided\n     let supplied_params = substs.len();\n-    for _ in supplied_params..def_generics.count_params_including_parent() {\n+    for _ in supplied_params..parent_param_count + param_count {\n         substs.push(Ty::Unknown);\n     }\n-    assert_eq!(substs.len(), def_generics.count_params_including_parent());\n+    assert_eq!(substs.len(), parent_param_count + param_count);\n \n     // handle defaults\n     if let Some(def_generic) = def_generic {\n@@ -491,6 +547,29 @@ pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     Ty::from_hir(db, &resolver, type_ref)\n }\n \n+/// This query exists only to be used when resolving short-hand associated types\n+/// like `T::Item`.\n+///\n+/// See the analogous query in rustc and its comment:\n+/// https://github.com/rust-lang/rust/blob/9150f844e2624eb013ec78ca08c1d416e6644026/src/librustc_typeck/astconv.rs#L46\n+/// This is a query mostly to handle cycles somewhat gracefully; e.g. the\n+/// following bounds are disallowed: `T: Foo<U::Item>, U: Foo<T::Item>`, but\n+/// these are fine: `T: Foo<U::Item>, U: Foo<()>`.\n+pub(crate) fn generic_predicates_for_param_query(\n+    db: &impl HirDatabase,\n+    def: GenericDef,\n+    param_idx: u32,\n+) -> Arc<[GenericPredicate]> {\n+    let resolver = def.resolver(db);\n+    let predicates = resolver\n+        .where_predicates_in_scope()\n+        // we have to filter out all other predicates *first*, before attempting to lower them\n+        .filter(|pred| Ty::from_hir_only_param(db, &resolver, &pred.type_ref) == Some(param_idx))\n+        .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n+        .collect::<Vec<_>>();\n+    predicates.into()\n+}\n+\n pub(crate) fn trait_env(\n     db: &impl HirDatabase,\n     resolver: &Resolver,"}, {"sha": "3ac1fbdd50df364144b79e12714e04b5c5ac0a6c", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18bf278c258f44ed68f67f84993f20f7c27c63d0/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=18bf278c258f44ed68f67f84993f20f7c27c63d0", "patch": "@@ -2740,17 +2740,17 @@ fn test() {\n     [202; 203) 't': T\n     [221; 223) '{}': ()\n     [234; 300) '{     ...(S); }': ()\n-    [244; 245) 'x': {unknown}\n-    [248; 252) 'foo1': fn foo1<S>(T) -> {unknown}\n-    [248; 255) 'foo1(S)': {unknown}\n+    [244; 245) 'x': u32\n+    [248; 252) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [248; 255) 'foo1(S)': u32\n     [253; 254) 'S': S\n     [265; 266) 'y': u32\n     [269; 273) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item\n     [269; 276) 'foo2(S)': u32\n     [274; 275) 'S': S\n-    [286; 287) 'z': {unknown}\n-    [290; 294) 'foo3': fn foo3<S>(T) -> {unknown}\n-    [290; 297) 'foo3(S)': {unknown}\n+    [286; 287) 'z': u32\n+    [290; 294) 'foo3': fn foo3<S>(T) -> <T as Iterable>::Item\n+    [290; 297) 'foo3(S)': u32\n     [295; 296) 'S': S\n     \"###\n     );\n@@ -4080,7 +4080,7 @@ fn test<F: FnOnce(u32) -> u64>(f: F) {\n }\n \n #[test]\n-fn unselected_projection_in_trait_env() {\n+fn unselected_projection_in_trait_env_1() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -4102,7 +4102,33 @@ fn test<T: Trait>() where T::Item: Trait2 {\n }\n \n #[test]\n-fn unselected_projection_in_trait_env_cycle() {\n+fn unselected_projection_in_trait_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+trait Trait2 {\n+    fn foo(&self) -> u32;\n+}\n+\n+fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n+    let x: T::Item = no_matter;\n+    x.foo()<|>;\n+}\n+\"#,\n+    );\n+    assert_eq!(t, \"u32\");\n+}\n+\n+#[test]\n+// FIXME this is currently a Salsa panic; it would be nicer if it just returned\n+// in Unknown, and we should be able to do that once Salsa allows us to handle\n+// the cycle. But at least it doesn't overflow for now.\n+#[should_panic]\n+fn unselected_projection_in_trait_env_cycle_1() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n@@ -4121,6 +4147,28 @@ fn test<T: Trait>() where T: Trait2<T::Item> {\n     assert_eq!(t, \"{unknown}\");\n }\n \n+#[test]\n+// FIXME this is currently a Salsa panic; it would be nicer if it just returned\n+// in Unknown, and we should be able to do that once Salsa allows us to handle\n+// the cycle. But at least it doesn't overflow for now.\n+#[should_panic]\n+fn unselected_projection_in_trait_env_cycle_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait<T> {\n+    type Item;\n+}\n+\n+fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n+    let x: T::Item = no_matter<|>;\n+}\n+\"#,\n+    );\n+    // this is a legitimate cycle\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}]}