{"sha": "25d8a9494ca6d77361e47c1505ecf640b168819e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDhhOTQ5NGNhNmQ3NzM2MWU0N2MxNTA1ZWNmNjQwYjE2ODgxOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T18:11:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T18:11:33Z"}, "message": "Auto merge of #66321 - ninjasource:async-fn-resume-after-completion, r=oli-obk\n\nAsync fn resume after completion\n\n#65419 -- Attempting to run an async fn after completion mentions generators\nNot yet ready for review - work in progress\nJust need to run the tests on a proper build server", "tree": {"sha": "01cf867d7bd46c03741be57376bb6e28bf011f08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01cf867d7bd46c03741be57376bb6e28bf011f08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d8a9494ca6d77361e47c1505ecf640b168819e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d8a9494ca6d77361e47c1505ecf640b168819e", "html_url": "https://github.com/rust-lang/rust/commit/25d8a9494ca6d77361e47c1505ecf640b168819e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d8a9494ca6d77361e47c1505ecf640b168819e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d99e0c6d02b159f305474f58c8c38027bb06e051", "url": "https://api.github.com/repos/rust-lang/rust/commits/d99e0c6d02b159f305474f58c8c38027bb06e051", "html_url": "https://github.com/rust-lang/rust/commit/d99e0c6d02b159f305474f58c8c38027bb06e051"}, {"sha": "851492c3724204834d833f940ed5447813fda672", "url": "https://api.github.com/repos/rust-lang/rust/commits/851492c3724204834d833f940ed5447813fda672", "html_url": "https://github.com/rust-lang/rust/commit/851492c3724204834d833f940ed5447813fda672"}], "stats": {"total": 298, "additions": 232, "deletions": 66}, "files": [{"sha": "98e6770c70d1b07c83c8ba05d8c666318acc5588", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -13,7 +13,7 @@ use rustc_macros::HashStable;\n use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n-\n+use hir::GeneratorKind;\n use std::{fmt, env};\n \n use rustc_error_codes::*;\n@@ -264,8 +264,8 @@ pub enum PanicInfo<O> {\n     OverflowNeg,\n     DivisionByZero,\n     RemainderByZero,\n-    GeneratorResumedAfterReturn,\n-    GeneratorResumedAfterPanic,\n+    ResumedAfterReturn(GeneratorKind),\n+    ResumedAfterPanic(GeneratorKind),\n }\n \n /// Type for MIR `Assert` terminator error messages.\n@@ -300,10 +300,14 @@ impl<O> PanicInfo<O> {\n                 \"attempt to divide by zero\",\n             RemainderByZero =>\n                 \"attempt to calculate the remainder with a divisor of zero\",\n-            GeneratorResumedAfterReturn =>\n+            ResumedAfterReturn(GeneratorKind::Gen) =>\n                 \"generator resumed after completion\",\n-            GeneratorResumedAfterPanic =>\n+            ResumedAfterReturn(GeneratorKind::Async(_)) =>\n+                \"`async fn` resumed after completion\",\n+            ResumedAfterPanic(GeneratorKind::Gen) =>\n                 \"generator resumed after panicking\",\n+            ResumedAfterPanic(GeneratorKind::Async(_)) =>\n+                \"`async fn` resumed after panicking\",\n             Panic { .. } | BoundsCheck { .. } =>\n                 bug!(\"Unexpected PanicInfo\"),\n         }"}, {"sha": "8c1690a177bde150b5bec4ea5845159e1be66b75", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -6,7 +6,7 @@\n \n use crate::hir::def::{CtorKind, Namespace};\n use crate::hir::def_id::DefId;\n-use crate::hir;\n+use crate::hir::{self, GeneratorKind};\n use crate::mir::interpret::{GlobalAlloc, PanicInfo, Scalar};\n use crate::mir::visit::MirVisitable;\n use crate::ty::adjustment::PointerCast;\n@@ -117,6 +117,10 @@ pub struct Body<'tcx> {\n     /// The layout of a generator. Produced by the state transformation.\n     pub generator_layout: Option<GeneratorLayout<'tcx>>,\n \n+    /// If this is a generator then record the type of source expression that caused this generator\n+    /// to be created.\n+    pub generator_kind: Option<GeneratorKind>,\n+\n     /// Declarations of locals.\n     ///\n     /// The first local is the return value pointer, followed by `arg_count`\n@@ -170,6 +174,7 @@ impl<'tcx> Body<'tcx> {\n         var_debug_info: Vec<VarDebugInfo<'tcx>>,\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n+        generator_kind : Option<GeneratorKind>,\n     ) -> Self {\n         // We need `arg_count` locals, and one for the return place.\n         assert!(\n@@ -187,6 +192,7 @@ impl<'tcx> Body<'tcx> {\n             yield_ty: None,\n             generator_drop: None,\n             generator_layout: None,\n+            generator_kind,\n             local_decls,\n             user_type_annotations,\n             arg_count,\n@@ -2975,7 +2981,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                             index: index.fold_with(folder),\n                         },\n                     Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n-                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic =>\n+                    ResumedAfterReturn(_) | ResumedAfterPanic(_)  =>\n                         msg.clone(),\n                 };\n                 Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n@@ -3021,7 +3027,7 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n                             len.visit_with(visitor) || index.visit_with(visitor),\n                         Panic { .. } | Overflow(_) | OverflowNeg |\n                         DivisionByZero | RemainderByZero |\n-                        GeneratorResumedAfterReturn | GeneratorResumedAfterPanic =>\n+                        ResumedAfterReturn(_) | ResumedAfterPanic(_) =>\n                             false\n                     }\n                 } else {\n@@ -3040,6 +3046,16 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Place {"}, {"sha": "58c12ef2501559ed514b44a90fd5d6547c75aab3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -517,7 +517,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(index, location);\n                     }\n                     Panic { .. } | Overflow(_) | OverflowNeg | DivisionByZero | RemainderByZero |\n-                    GeneratorResumedAfterReturn | GeneratorResumedAfterPanic => {\n+                    ResumedAfterReturn(_) | ResumedAfterPanic(_) => {\n                         // Nothing to visit\n                     }\n                 }"}, {"sha": "91ddd5a5623c0e48946ec9e4301af3aefa04c367", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -5,7 +5,7 @@ use crate::hair::{LintLevel, BindingMode, PatKind};\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use rustc::hir;\n-use rustc::hir::Node;\n+use rustc::hir::{Node, GeneratorKind};\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items;\n use rustc::middle::region;\n@@ -279,7 +279,7 @@ struct Builder<'a, 'tcx> {\n \n     fn_span: Span,\n     arg_count: usize,\n-    is_generator: bool,\n+    generator_kind: Option<GeneratorKind>,\n \n     /// The current set of scopes, updated as we traverse;\n     /// see the `scope` module for more details.\n@@ -570,7 +570,7 @@ where\n         safety,\n         return_ty,\n         return_ty_span,\n-        body.generator_kind.is_some());\n+        body.generator_kind);\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n@@ -647,7 +647,7 @@ fn construct_const<'a, 'tcx>(\n         Safety::Safe,\n         const_ty,\n         const_ty_span,\n-        false,\n+        None,\n     );\n \n     let mut block = START_BLOCK;\n@@ -678,7 +678,7 @@ fn construct_error<'a, 'tcx>(\n     let owner_id = hir.tcx().hir().body_owner(body_id);\n     let span = hir.tcx().hir().span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, false);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, None);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish()\n@@ -691,15 +691,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n            return_span: Span,\n-           is_generator: bool)\n+           generator_kind: Option<GeneratorKind>)\n            -> Builder<'a, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n             hir,\n             cfg: CFG { basic_blocks: IndexVec::new() },\n             fn_span: span,\n             arg_count,\n-            is_generator,\n+            generator_kind,\n             scopes: Default::default(),\n             block_context: BlockContext::new(),\n             source_scopes: IndexVec::new(),\n@@ -748,6 +748,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             self.var_debug_info,\n             self.fn_span,\n             self.hir.control_flow_destroyed(),\n+            self.generator_kind\n         )\n     }\n "}, {"sha": "bb25b28526960190446b4ced7ef36f0a6ee0f5c4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -91,6 +91,7 @@ use syntax_pos::{DUMMY_SP, Span};\n use rustc_data_structures::fx::FxHashMap;\n use std::collections::hash_map::Entry;\n use std::mem;\n+use rustc::hir::GeneratorKind;\n \n #[derive(Debug)]\n struct Scope {\n@@ -219,7 +220,12 @@ impl Scope {\n     /// `storage_only` controls whether to invalidate only drop paths that run `StorageDead`.\n     /// `this_scope_only` controls whether to invalidate only drop paths that refer to the current\n     /// top-of-scope (as opposed to dependent scopes).\n-    fn invalidate_cache(&mut self, storage_only: bool, is_generator: bool, this_scope_only: bool) {\n+    fn invalidate_cache(\n+        &mut self,\n+        storage_only: bool,\n+        generator_kind: Option<GeneratorKind>,\n+        this_scope_only: bool\n+    ) {\n         // FIXME: maybe do shared caching of `cached_exits` etc. to handle functions\n         // with lots of `try!`?\n \n@@ -229,7 +235,7 @@ impl Scope {\n         // the current generator drop and unwind refer to top-of-scope\n         self.cached_generator_drop = None;\n \n-        let ignore_unwinds = storage_only && !is_generator;\n+        let ignore_unwinds = storage_only && generator_kind.is_none();\n         if !ignore_unwinds {\n             self.cached_unwind.invalidate();\n         }\n@@ -481,7 +487,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         unpack!(block = build_scope_drops(\n             &mut self.cfg,\n-            self.is_generator,\n+            self.generator_kind,\n             &scope,\n             block,\n             unwind_to,\n@@ -574,7 +580,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n-                self.is_generator,\n+                self.generator_kind,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -625,7 +631,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             unpack!(block = build_scope_drops(\n                 &mut self.cfg,\n-                self.is_generator,\n+                self.generator_kind,\n                 scope,\n                 block,\n                 unwind_to,\n@@ -809,7 +815,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // invalidating caches of each scope visited. This way bare minimum of the\n             // caches gets invalidated. i.e., if a new drop is added into the middle scope, the\n             // cache of outer scope stays intact.\n-            scope.invalidate_cache(!needs_drop, self.is_generator, this_scope);\n+            scope.invalidate_cache(!needs_drop, self.generator_kind, this_scope);\n             if this_scope {\n                 let region_scope_span = region_scope.span(self.hir.tcx(),\n                                                           &self.hir.region_scope_tree);\n@@ -958,7 +964,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     }\n \n-                    top_scope.invalidate_cache(true, self.is_generator, true);\n+                    top_scope.invalidate_cache(true, self.generator_kind, true);\n                 } else {\n                     bug!(\"Expected as_local_operand to produce a temporary\");\n                 }\n@@ -1016,7 +1022,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         for scope in self.scopes.top_scopes(first_uncached) {\n             target = build_diverge_scope(&mut self.cfg, scope.region_scope_span,\n-                                         scope, target, generator_drop, self.is_generator);\n+                                         scope, target, generator_drop, self.generator_kind);\n         }\n \n         target\n@@ -1079,14 +1085,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         assert_eq!(top_scope.region_scope, region_scope);\n \n         top_scope.drops.clear();\n-        top_scope.invalidate_cache(false, self.is_generator, true);\n+        top_scope.invalidate_cache(false, self.generator_kind, true);\n     }\n }\n \n /// Builds drops for pop_scope and exit_scope.\n fn build_scope_drops<'tcx>(\n     cfg: &mut CFG<'tcx>,\n-    is_generator: bool,\n+    generator_kind: Option<GeneratorKind>,\n     scope: &Scope,\n     mut block: BasicBlock,\n     last_unwind_to: BasicBlock,\n@@ -1130,7 +1136,7 @@ fn build_scope_drops<'tcx>(\n                     continue;\n                 }\n \n-                let unwind_to = get_unwind_to(scope, is_generator, drop_idx, generator_drop)\n+                let unwind_to = get_unwind_to(scope, generator_kind, drop_idx, generator_drop)\n                     .unwrap_or(last_unwind_to);\n \n                 let next = cfg.start_new_block();\n@@ -1156,19 +1162,19 @@ fn build_scope_drops<'tcx>(\n \n fn get_unwind_to(\n     scope: &Scope,\n-    is_generator: bool,\n+    generator_kind: Option<GeneratorKind>,\n     unwind_from: usize,\n     generator_drop: bool,\n ) -> Option<BasicBlock> {\n     for drop_idx in (0..unwind_from).rev() {\n         let drop_data = &scope.drops[drop_idx];\n-        match (is_generator, &drop_data.kind) {\n-            (true, DropKind::Storage) => {\n+        match (generator_kind, &drop_data.kind) {\n+            (Some(_), DropKind::Storage) => {\n                 return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n                     span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n                 }));\n             }\n-            (false, DropKind::Value) => {\n+            (None, DropKind::Value) => {\n                 return Some(drop_data.cached_block.get(generator_drop).unwrap_or_else(|| {\n                     span_bug!(drop_data.span, \"cached block not present for {:?}\", drop_data)\n                 }));\n@@ -1184,7 +1190,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n                              scope: &mut Scope,\n                              mut target: BasicBlock,\n                              generator_drop: bool,\n-                             is_generator: bool)\n+                             generator_kind: Option<GeneratorKind>)\n                              -> BasicBlock\n {\n     // Build up the drops in **reverse** order. The end result will\n@@ -1224,7 +1230,7 @@ fn build_diverge_scope<'tcx>(cfg: &mut CFG<'tcx>,\n         // match the behavior of clang, but on inspection eddyb says\n         // this is not what clang does.\n         match drop_data.kind {\n-            DropKind::Storage if is_generator => {\n+            DropKind::Storage if generator_kind.is_some() => {\n                 storage_deads.push(Statement {\n                     source_info: source_info(drop_data.span),\n                     kind: StatementKind::StorageDead(drop_data.local)"}, {"sha": "50cd3188510777fe48f442a4812352438d7aacb8", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -142,8 +142,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         OverflowNeg => err_panic!(OverflowNeg),\n                         DivisionByZero => err_panic!(DivisionByZero),\n                         RemainderByZero => err_panic!(RemainderByZero),\n-                        GeneratorResumedAfterReturn => err_panic!(GeneratorResumedAfterReturn),\n-                        GeneratorResumedAfterPanic => err_panic!(GeneratorResumedAfterPanic),\n+                        ResumedAfterReturn(generator_kind)\n+                            => err_panic!(ResumedAfterReturn(*generator_kind)),\n+                        ResumedAfterPanic(generator_kind)\n+                            => err_panic!(ResumedAfterPanic(*generator_kind)),\n                         Panic { .. } => bug!(\"`Panic` variant cannot occur in MIR\"),\n                     }\n                     .into());"}, {"sha": "08af271ff46e06fd024e6512a7b88dbe59507e65", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -196,19 +196,14 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     block(&mut blocks, TerminatorKind::Goto { target: return_block });\n     block(&mut blocks, TerminatorKind::Return);\n \n-    let mut body = Body::new(\n+    let mut body = new_body(\n         blocks,\n         IndexVec::from_elem_n(\n-            SourceScopeData { span: span, parent_scope: None }, 1\n+            SourceScopeData { span, parent_scope: None }, 1\n         ),\n-        ClearCrossCrate::Clear,\n         local_decls_for_sig(&sig, span),\n-        IndexVec::new(),\n         sig.inputs().len(),\n-        vec![],\n-        span,\n-        vec![],\n-    );\n+        span);\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n@@ -247,6 +242,27 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     body\n }\n \n+fn new_body<'tcx>(\n+    basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    source_scopes: IndexVec<SourceScope, SourceScopeData>,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    arg_count: usize,\n+    span: Span,\n+) -> Body<'tcx> {\n+    Body::new(\n+        basic_blocks,\n+        source_scopes,\n+        ClearCrossCrate::Clear,\n+        local_decls,\n+        IndexVec::new(),\n+        arg_count,\n+        vec![],\n+        span,\n+        vec![],\n+        None,\n+    )\n+}\n+\n pub struct DropShimElaborator<'a, 'tcx> {\n     pub body: &'a Body<'tcx>,\n     pub patch: MirPatch<'tcx>,\n@@ -362,18 +378,14 @@ impl CloneShimBuilder<'tcx> {\n     }\n \n     fn into_mir(self) -> Body<'tcx> {\n-        Body::new(\n+        new_body(\n             self.blocks,\n             IndexVec::from_elem_n(\n                 SourceScopeData { span: self.span, parent_scope: None }, 1\n             ),\n-            ClearCrossCrate::Clear,\n             self.local_decls,\n-            IndexVec::new(),\n             self.sig.inputs().len(),\n-            vec![],\n             self.span,\n-            vec![],\n         )\n     }\n \n@@ -822,19 +834,16 @@ fn build_call_shim<'tcx>(\n         block(&mut blocks, vec![], TerminatorKind::Resume, true);\n     }\n \n-    let mut body = Body::new(\n+    let mut body = new_body(\n         blocks,\n         IndexVec::from_elem_n(\n-            SourceScopeData { span: span, parent_scope: None }, 1\n+            SourceScopeData { span, parent_scope: None }, 1\n         ),\n-        ClearCrossCrate::Clear,\n         local_decls,\n-        IndexVec::new(),\n         sig.inputs().len(),\n-        vec![],\n         span,\n-        vec![],\n     );\n+\n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n     }\n@@ -908,18 +917,14 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> &Body<'_> {\n         is_cleanup: false\n     };\n \n-    let body = Body::new(\n+    let body = new_body(\n         IndexVec::from_elem_n(start_block, 1),\n         IndexVec::from_elem_n(\n-            SourceScopeData { span: span, parent_scope: None }, 1\n+            SourceScopeData { span, parent_scope: None }, 1\n         ),\n-        ClearCrossCrate::Clear,\n         local_decls,\n-        IndexVec::new(),\n         sig.inputs().len(),\n-        vec![],\n         span,\n-        vec![],\n     );\n \n     crate::util::dump_mir("}, {"sha": "d2740cf3771a8780cc0ebca19e725e5121fb5f77", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -91,6 +91,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n                 Default::default(),\n                 tcx.def_span(source.def_id()),\n                 Default::default(),\n+                body.generator_kind,\n             );\n \n         // FIXME(oli-obk, eddyb) Optimize locals (or even local paths) to hold"}, {"sha": "5d88629435bf1a2a76c2f5b19fe213bfd07b90e0", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -1056,16 +1056,23 @@ fn create_generator_resume_function<'tcx>(\n     let mut cases = create_cases(body, &transform, |point| Some(point.resume));\n \n     use rustc::mir::interpret::PanicInfo::{\n-        GeneratorResumedAfterPanic,\n-        GeneratorResumedAfterReturn,\n+        ResumedAfterPanic,\n+        ResumedAfterReturn,\n     };\n \n     // Jump to the entry point on the unresumed\n     cases.insert(0, (UNRESUMED, BasicBlock::new(0)));\n-    // Panic when resumed on the returned state\n-    cases.insert(1, (RETURNED, insert_panic_block(tcx, body, GeneratorResumedAfterReturn)));\n-    // Panic when resumed on the poisoned state\n-    cases.insert(2, (POISONED, insert_panic_block(tcx, body, GeneratorResumedAfterPanic)));\n+\n+    // Panic when resumed on the returned or poisoned state\n+    let generator_kind = body.generator_kind.unwrap();\n+    cases.insert(1, (RETURNED, insert_panic_block(\n+        tcx,\n+        body,\n+        ResumedAfterReturn(generator_kind))));\n+    cases.insert(2, (POISONED, insert_panic_block(\n+        tcx,\n+        body,\n+        ResumedAfterPanic(generator_kind))));\n \n     insert_switch(body, cases, &transform, TerminatorKind::Unreachable);\n "}, {"sha": "cc6108c7dc095db26b5a4cca769d2973ee932adf", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -1088,6 +1088,7 @@ pub fn promote_candidates<'tcx>(\n                 vec![],\n                 body.span,\n                 vec![],\n+                body.generator_kind,\n             ),\n             tcx,\n             source: body,"}, {"sha": "ade386a605dca61a4082c6db83d4462266670178", "filename": "src/test/ui/async-await/issues/issue-65419/issue-65419-async-fn-resume-after-completion.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-completion.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -0,0 +1,46 @@\n+// issue 65419 - Attempting to run an async fn after completion mentions generators when it should\n+// be talking about `async fn`s instead.\n+\n+// run-fail\n+// error-pattern: thread 'main' panicked at '`async fn` resumed after completion'\n+// edition:2018\n+// ignore-wasm no panic or subprocess support\n+// ignore-emscripten no panic or subprocess support\n+\n+#![feature(generators, generator_trait)]\n+\n+async fn foo() {\n+}\n+\n+fn main() {\n+    let mut future = Box::pin(foo());\n+    executor::block_on(future.as_mut());\n+    executor::block_on(future.as_mut());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+            |_| unimplemented!(\"clone\"),\n+            |_| unimplemented!(\"wake\"),\n+            |_| unimplemented!(\"wake_by_ref\"),\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}, {"sha": "f8caebcb8764efe3f2a552e74a2efe23ef28460a", "filename": "src/test/ui/async-await/issues/issue-65419/issue-65419-async-fn-resume-after-panic.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-async-fn-resume-after-panic.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -0,0 +1,52 @@\n+// issue 65419 - Attempting to run an async fn after completion mentions generators when it should\n+// be talking about `async fn`s instead. Should also test what happens when it panics.\n+\n+// run-fail\n+// error-pattern: thread 'main' panicked at '`async fn` resumed after panicking'\n+// edition:2018\n+// ignore-wasm no panic or subprocess support\n+// ignore-emscripten no panic or subprocess support\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::panic;\n+\n+async fn foo() {\n+    panic!();\n+}\n+\n+fn main() {\n+    let mut future = Box::pin(foo());\n+    panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+        executor::block_on(future.as_mut());\n+    }));\n+\n+    executor::block_on(future.as_mut());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+            |_| unimplemented!(\"clone\"),\n+            |_| unimplemented!(\"wake\"),\n+            |_| unimplemented!(\"wake_by_ref\"),\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}, {"sha": "23e3483e01c7d6d730c5dfd1ddd47c459a64138a", "filename": "src/test/ui/async-await/issues/issue-65419/issue-65419-generator-resume-after-completion.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d8a9494ca6d77361e47c1505ecf640b168819e/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-65419%2Fissue-65419-generator-resume-after-completion.rs?ref=25d8a9494ca6d77361e47c1505ecf640b168819e", "patch": "@@ -0,0 +1,25 @@\n+// issue 65419 - Attempting to run an `async fn` after completion mentions generators when it should\n+// be talking about `async fn`s instead. Regression test added to make sure generators still\n+// panic when resumed after completion.\n+\n+// run-fail\n+// error-pattern:generator resumed after completion\n+// edition:2018\n+// ignore-wasm no panic or subprocess support\n+// ignore-emscripten no panic or subprocess support\n+\n+#![feature(generators, generator_trait)]\n+\n+use std::{\n+    ops::Generator,\n+    pin::Pin,\n+};\n+\n+fn main() {\n+    let mut g = || {\n+        yield;\n+    };\n+    Pin::new(&mut g).resume(); // Yields once.\n+    Pin::new(&mut g).resume(); // Completes here.\n+    Pin::new(&mut g).resume(); // Panics here.\n+}"}]}