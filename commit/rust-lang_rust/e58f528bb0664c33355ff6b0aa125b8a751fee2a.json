{"sha": "e58f528bb0664c33355ff6b0aa125b8a751fee2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OGY1MjhiYjA2NjRjMzMzNTVmZjZiMGFhMTI1YjhhNzUxZmVlMmE=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-09-11T14:29:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-09-26T15:55:52Z"}, "message": "merge fixes, addressing CR comments", "tree": {"sha": "2bea64ce73bddceed3317e3d00ed1d715a3c0c2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bea64ce73bddceed3317e3d00ed1d715a3c0c2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e58f528bb0664c33355ff6b0aa125b8a751fee2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e58f528bb0664c33355ff6b0aa125b8a751fee2a", "html_url": "https://github.com/rust-lang/rust/commit/e58f528bb0664c33355ff6b0aa125b8a751fee2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e58f528bb0664c33355ff6b0aa125b8a751fee2a/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "html_url": "https://github.com/rust-lang/rust/commit/1c4510adc81bd7623bc2993b42ee7d87320f1f2b"}], "stats": {"total": 296, "additions": 138, "deletions": 158}, "files": [{"sha": "687b518ef6aff425572445eac410509e9104d30f", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "modified", "additions": 80, "deletions": 52, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -18,6 +18,7 @@ use infer::region_inference::RegionResolutionError;\n use hir::map as hir_map;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use infer::error_reporting::util::AnonymousArgInfo;\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // This method prints the error message for lifetime errors when both the concerned regions\n@@ -57,6 +58,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let ty_sup = or_false!(self.find_anon_type(sup, &bregion_sup));\n \n         let ty_sub = or_false!(self.find_anon_type(sub, &bregion_sub));\n+\n         debug!(\"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n                ty_sub,\n                sup,\n@@ -66,56 +68,78 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                sub,\n                bregion_sub);\n \n-        let (main_label, label1, label2) = if let (Some(sup_arg), Some(sub_arg)) =\n-            (self.find_arg_with_region(sup, sup), self.find_arg_with_region(sub, sub)) {\n+        let (ty_sup, ty_fndecl_sup) = ty_sup;\n+        let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-            let (anon_arg_sup, is_first_sup, anon_arg_sub, is_first_sub) =\n-                (sup_arg.arg, sup_arg.is_first, sub_arg.arg, sub_arg.is_first);\n-            if self.is_self_anon(is_first_sup, scope_def_id_sup) ||\n-               self.is_self_anon(is_first_sub, scope_def_id_sub) {\n-                return false;\n-            }\n+        let AnonymousArgInfo { arg: anon_arg_sup, .. } =\n+            or_false!(self.find_arg_with_region(sup, sup));\n+        let AnonymousArgInfo { arg: anon_arg_sub, .. } =\n+            or_false!(self.find_arg_with_region(sub, sub));\n \n-            if self.is_return_type_anon(scope_def_id_sup, bregion_sup) ||\n-               self.is_return_type_anon(scope_def_id_sub, bregion_sub) {\n-                return false;\n-            }\n+        let sup_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n+        let sub_is_ret_type =\n+            self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-            if anon_arg_sup == anon_arg_sub {\n-                (format!(\"this type was declared with multiple lifetimes...\"),\n-                 format!(\" with one lifetime\"),\n-                 format!(\" into the other\"))\n-            } else {\n-                let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n-                    format!(\" from `{}`\", simple_name)\n-                } else {\n-                    format!(\"\")\n-                };\n+        let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n+            format!(\" flows from `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n+\n+        let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n+            format!(\" into `{}`\", simple_name)\n+        } else {\n+            format!(\"\")\n+        };\n \n-                let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n-                    format!(\" into `{}`\", simple_name)\n-                } else {\n-                    format!(\"\")\n-                };\n \n-                let span_label =\n-                    format!(\"these two types are declared with different lifetimes...\",);\n+        let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n+            (None, None) => {\n+                let (main_label_1, span_label_1) = if ty_sup == ty_sub {\n \n-                (span_label, span_label_var1, span_label_var2)\n+                    (format!(\"this type was declared with multiple lifetimes...\"),\n+                     format!(\"...but data{} flows{} here\",\n+                             format!(\" with one lifetime\"),\n+                             format!(\" into the other\")))\n+                } else {\n+                    (format!(\"these two types was declared with multiple lifetimes...\"),\n+                     format!(\"...but data{} flows{} here\",\n+                             span_label_var1,\n+                             span_label_var2))\n+                };\n+                (ty_sup.span, ty_sub.span, main_label_1, span_label_1)\n+            }\n+            (Some(ret_span1), Some(ret_span2)) => {\n+                (ret_span1,\n+                 ret_span2,\n+                 format!(\"the return type is declared with different lifetimes...\"),\n+                 format!(\"...but data{} flows{} here\",\n+                         format!(\" with one lifetime\"),\n+                         format!(\" into the other\")))\n+            }\n+            \n+            (Some(ret_span), _) => {\n+                (ty_sub.span,\n+                 ret_span,\n+                 format!(\"this parameter and the return type are declared\n+                  with different lifetimes...\",),\n+                 format!(\"...but data{} is returned here\", span_label_var1))\n+            }\n+            (_, Some(ret_span)) => {\n+                (ty_sup.span,\n+                 ret_span,\n+                 format!(\"this parameter and the return type are declared\n+                  with different lifetimes...\",),\n+                 format!(\"...but data{} is returned here\", span_label_var1))\n             }\n-        } else {\n-            debug!(\"no arg with anon region found\");\n-            debug!(\"try_report_anon_anon_conflict: is_suitable(sub) = {:?}\",\n-                   self.is_suitable_region(sub));\n-            debug!(\"try_report_anon_anon_conflict: is_suitable(sup) = {:?}\",\n-                   self.is_suitable_region(sup));\n-            return false;\n         };\n \n+\n         struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n-            .span_label(ty_sup.span, main_label)\n-            .span_label(ty_sub.span, format!(\"\"))\n-            .span_label(span, format!(\"...but data{} flows{} here\", label1, label2))\n+            .span_label(span_1, main_label)\n+            .span_label(span_2, format!(\"\"))\n+            .span_label(span, span_label)\n             .emit();\n         return true;\n     }\n@@ -135,28 +159,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     /// The function returns the nested type corresponding to the anonymous region\n     /// for e.g. `&u8` and Vec<`&u8`.\n-    pub fn find_anon_type(&self, region: Region<'tcx>, br: &ty::BoundRegion) -> Option<&hir::Ty> {\n+    pub fn find_anon_type(&self,\n+                          region: Region<'tcx>,\n+                          br: &ty::BoundRegion)\n+                          -> Option<(&hir::Ty, &hir::FnDecl)> {\n         if let Some(anon_reg) = self.is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let inputs: &[_] = match self.tcx.hir.get(node_id) {\n+                let fndecl = match self.tcx.hir.get(node_id) {\n                     hir_map::NodeItem(&hir::Item { node: hir::ItemFn(ref fndecl, ..), .. }) => {\n-                        &fndecl.inputs\n+                        &fndecl\n                     }\n                     hir_map::NodeTraitItem(&hir::TraitItem {\n-                                               node: hir::TraitItemKind::Method(ref fndecl, ..), ..\n-                                           }) => &fndecl.decl.inputs,\n+                                               node: hir::TraitItemKind::Method(ref m, ..), ..\n+                                           }) |\n                     hir_map::NodeImplItem(&hir::ImplItem {\n-                                              node: hir::ImplItemKind::Method(ref fndecl, ..), ..\n-                                          }) => &fndecl.decl.inputs,\n-\n-                    _ => &[],\n+                                              node: hir::ImplItemKind::Method(ref m, ..), ..\n+                                          }) => &m.decl,\n+                    _ => return None,\n                 };\n \n-                return inputs\n+                return fndecl\n+                           .inputs\n                            .iter()\n-                           .filter_map(|arg| self.find_component_for_bound_region(&**arg, br))\n-                           .next();\n+                           .filter_map(|arg| self.find_component_for_bound_region(arg, br))\n+                           .next()\n+                           .map(|ty| (ty, &**fndecl));\n             }\n         }\n         None"}, {"sha": "7027c868e6efe8d6372b6d9fdc421d52b916d86b", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -35,15 +35,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon_arg_info, region_info) =\n+        let (named, anon, anon_arg_info, region_info) =\n             if self.is_named_region(sub) && self.is_suitable_region(sup).is_some() &&\n                self.find_arg_with_region(sup, sub).is_some() {\n                 (sub,\n+                 sup,\n                  self.find_arg_with_region(sup, sub).unwrap(),\n                  self.is_suitable_region(sup).unwrap())\n             } else if self.is_named_region(sup) && self.is_suitable_region(sub).is_some() &&\n                       self.find_arg_with_region(sub, sup).is_some() {\n                 (sup,\n+                 sub,\n                  self.find_arg_with_region(sub, sup).unwrap(),\n                  self.is_suitable_region(sub).unwrap())\n             } else {\n@@ -76,33 +78,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             return false;\n         }\n \n-        if self.is_return_type_anon(scope_def_id, br) {\n-            debug!(\"try_report_named_anon_conflict: is_return_type_anon({:?}, {:?}) = true\",\n-                   scope_def_id,\n-                   br);\n-            return false;\n-        } else if self.is_self_anon(is_first, scope_def_id) {\n-            debug!(\"try_report_named_anon_conflict: is_self_anon({:?}, {:?}) = true\",\n-                   is_first,\n-                   scope_def_id);\n-            return false;\n+        if let Some(anon_ty) = self.find_anon_type(anon, &br) {\n+            let (_, fndecl) = anon_ty;\n+            if self.is_return_type_anon(scope_def_id, br, fndecl).is_some() ||\n+               self.is_self_anon(is_first, scope_def_id) {\n+                return false;\n+            }\n+        }\n+\n+        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+            (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n         } else {\n-            let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n-                (format!(\"the type of `{}`\", simple_name), format!(\"the type of `{}`\", simple_name))\n-            } else {\n-                (\"parameter type\".to_owned(), \"type\".to_owned())\n-            };\n+            (\"parameter type\".to_owned(), \"type\".to_owned())\n+        };\n+\n+        struct_span_err!(self.tcx.sess,\n+                         span,\n+                         E0621,\n+                         \"explicit lifetime required in {}\",\n+                         error_var)\n+                .span_label(arg.pat.span,\n+                            format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n+                .span_label(span, format!(\"lifetime `{}` required\", named))\n+                .emit();\n+        return true;\n \n-            struct_span_err!(self.tcx.sess,\n-                             span,\n-                             E0621,\n-                             \"explicit lifetime required in {}\",\n-                             error_var)\n-                    .span_label(arg.pat.span,\n-                                format!(\"consider changing {} to `{}`\", span_label_var, new_ty))\n-                    .span_label(span, format!(\"lifetime `{}` required\", named))\n-                    .emit();\n-            return true;\n-        }\n     }\n }"}, {"sha": "47db3f1b7926af1aa38c3b0991edb795cfe6f987", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -15,6 +15,7 @@ use infer::InferCtxt;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n use hir::map as hir_map;\n+use syntax_pos::Span;\n \n macro_rules! or_false {\n      ($v:expr) => {\n@@ -163,20 +164,24 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // Here, we check for the case where the anonymous region\n     // is in the return type.\n     // FIXME(#42703) - Need to handle certain cases here.\n-    pub fn is_return_type_anon(&self, scope_def_id: DefId, br: ty::BoundRegion) -> bool {\n+    pub fn is_return_type_anon(&self,\n+                               scope_def_id: DefId,\n+                               br: ty::BoundRegion,\n+                               decl: &hir::FnDecl)\n+                               -> Option<Span> {\n         let ret_ty = self.tcx.type_of(scope_def_id);\n         match ret_ty.sty {\n             ty::TyFnDef(_, _) => {\n                 let sig = ret_ty.fn_sig(self.tcx);\n                 let late_bound_regions = self.tcx\n                     .collect_referenced_late_bound_regions(&sig.output());\n                 if late_bound_regions.iter().any(|r| *r == br) {\n-                    return true;\n+                    return Some(decl.output.span());\n                 }\n             }\n             _ => {}\n         }\n-        false\n+        None\n     }\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312."}, {"sha": "4a1673a531d34af751248a97d3b7dfae276f0db1", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.stderr", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -1,27 +1,11 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0621]: explicit lifetime required in the type of `self`\n   --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:18:5\n    |\n+16 |   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n+   |              ----- consider changing the type of `self` to `&'a Foo`\n+17 | \n 18 |     x\n-   |     ^\n-   |\n-note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n-  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n-17 | |\n-18 | |     x\n-19 | |\n-20 | |   }\n-   | |___^\n-note: ...but the borrowed content is only valid for the lifetime 'a as defined on the method body at 16:3\n-  --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n-17 | |\n-18 | |     x\n-19 | |\n-20 | |   }\n-   | |___^\n+   |     ^ lifetime `'a` required\n \n error: aborting due to previous error\n "}, {"sha": "973c5ed72f87547bfae7222ace76e1bd877a1893", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-self-is-anon.stderr", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -1,27 +1,11 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0621]: explicit lifetime required in the type of `self`\n   --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:18:30\n    |\n+16 |     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+   |                ----- consider changing the type of `self` to `&'a Foo`\n+17 | \n 18 |         if true { x } else { self }\n-   |                              ^^^^\n-   |\n-note: ...the reference is valid for the lifetime 'a as defined on the method body at 16:5...\n-  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n-17 | |\n-18 | |         if true { x } else { self }\n-19 | |\n-20 | |     }\n-   | |_____^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body at 16:5\n-  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n-17 | |\n-18 | |         if true { x } else { self }\n-19 | |\n-20 | |     }\n-   | |_____^\n+   |                              ^^^^ lifetime `'a` required\n \n error: aborting due to previous error\n "}, {"sha": "c6b1280ca95aa677ed3df8b7a92bd00345ae88ba", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-return-type-is-anon.stderr", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-return-type-is-anon.stderr?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -1,23 +1,13 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0621]: explicit lifetime required in the type of `self`\n   --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:17:5\n    |\n+16 |   fn foo<'a>(&self, x: &i32) -> &i32 {\n+   |                        ----     ----\n+   |                        |\n+   |                        this parameter and the return type are\n+                            declared with different lifetimes...\n 17 |     x\n-   |     ^\n-   |\n-note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:3...\n-  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n-17 | |     x\n-18 | |   }\n-   | |___^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:3\n-  --> $DIR/ex3-both-anon-regions-return-type-is-anon.rs:16:3\n-   |\n-16 | /   fn foo<'a>(&self, x: &i32) -> &i32 {\n-17 | |     x\n-18 | |   }\n-   | |___^\n+   |     ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "9b15de1b1738f4bc762df7d1216633b825c69cc6", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-self-is-anon.stderr", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e58f528bb0664c33355ff6b0aa125b8a751fee2a/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-self-is-anon.stderr?ref=e58f528bb0664c33355ff6b0aa125b8a751fee2a", "patch": "@@ -1,23 +1,13 @@\n-error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-self-is-anon.rs:17:19\n    |\n+16 |     fn foo<'a>(&self, x: &Foo) -> &Foo {\n+   |                          ----     ----\n+   |                          |\n+   |                          this parameter and the return type are\n+                            declared with different lifetimes...\n 17 |         if true { x } else { self }\n-   |                   ^\n-   |\n-note: ...the reference is valid for the anonymous lifetime #1 defined on the method body at 16:5...\n-  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n-17 | |         if true { x } else { self }\n-18 | |     }\n-   | |_____^\n-note: ...but the borrowed content is only valid for the anonymous lifetime #2 defined on the method body at 16:5\n-  --> $DIR/ex3-both-anon-regions-self-is-anon.rs:16:5\n-   |\n-16 | /     fn foo<'a>(&self, x: &Foo) -> &Foo {\n-17 | |         if true { x } else { self }\n-18 | |     }\n-   | |_____^\n+   |                   ^ ...but data from `x` is returned here\n \n error: aborting due to previous error\n "}]}