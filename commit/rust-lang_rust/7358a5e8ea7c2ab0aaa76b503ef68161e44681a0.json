{"sha": "7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNThhNWU4ZWE3YzJhYjBhYWE3NmI1MDNlZjY4MTYxZTQ0NjgxYTA=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-09-11T14:17:15Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2015-09-12T22:38:36Z"}, "message": "Add part of new error codes in librustc", "tree": {"sha": "18623bcdd9fec3a36f9a11533f8821b32da40a95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18623bcdd9fec3a36f9a11533f8821b32da40a95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "html_url": "https://github.com/rust-lang/rust/commit/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc", "html_url": "https://github.com/rust-lang/rust/commit/1a1e6b85f6f0976aad5bf3bd6aec7403163c62cc"}], "stats": {"total": 331, "additions": 203, "deletions": 128}, "files": [{"sha": "702df073092c3473c5ac235e9e89751d9a0c0e76", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 84, "deletions": 2, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -1886,7 +1886,52 @@ This explicitly states that you expect the trait object `SomeTrait` to\n contain references (with a maximum lifetime of `'a`).\n \n [1]: https://github.com/rust-lang/rfcs/pull/1156\n-\"##\n+\"##,\n+\n+E0454: r##\"\n+A link name was given with an empty name. Erroneous code example:\n+\n+```\n+#[link(name = \"\")] extern {} // error: #[link(name = \"\")] given with empty name\n+```\n+\n+The rust compiler cannot link to an external library if you don't give it its\n+name. Example:\n+\n+```\n+#[link(name = \"some_lib\")] extern {} // ok!\n+```\n+\"##,\n+\n+E0458: r##\"\n+An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n+\n+```\n+#[link(kind = \"wonderful_unicorn\")] extern {}\n+// error: unknown kind: `wonderful_unicorn`\n+```\n+\n+Please specify a valid \"kind\" value, from one of the following:\n+ * static\n+ * dylib\n+ * framework\n+\"##,\n+\n+E0459: r##\"\n+A link was used without a name parameter. Erroneous code example:\n+\n+```\n+#[link(kind = \"dylib\")] extern {}\n+// error: #[link(...)] specified without `name = \"foo\"`\n+```\n+\n+Please add the name parameter to allow the rust compiler to find the library\n+you want. Example:\n+\n+```\n+#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n+```\n+\"##,\n \n }\n \n@@ -1913,5 +1958,42 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n-    E0400  // overloaded derefs are not allowed in constants\n+    E0400, // overloaded derefs are not allowed in constants\n+    E0452, // malformed lint attribute\n+    E0453, // overruled by outer forbid\n+    E0455, // native frameworks are only available on OSX targets\n+    E0456, // plugin `..` is not available for triple `..`\n+    E0457, // plugin `..` only found in rlib format, but must be available...\n+    E0460, // found possibly newer version of crate `..`\n+    E0461, // couldn't find crate `..` with expected target triple ..\n+    E0462, // found staticlib `..` instead of rlib or dylib\n+    E0463, // can't find crate for `..`\n+    E0464, // multiple matching crates for `..`\n+    E0465, // multiple .. candidates for `..` found\n+    E0466, // bad macro import\n+    E0467, // bad macro reexport\n+    E0468, // an `extern crate` loading macros must be at the crate root\n+    E0469, // imported macro not found\n+    E0470, // reexported macro not found\n+    E0471, // constant evaluation error: ..\n+    E0472, // asm! is unsupported on this target\n+    E0473, // dereference of reference outside its lifetime\n+    E0474, // captured variable `..` does not outlive the enclosing closure\n+    E0475, // index of slice outside its lifetime\n+    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n+    E0477, // the type `..` does not fulfill the required lifetime...\n+    E0478, // lifetime bound not satisfied\n+    E0479, // the type `..` (provided as the value of a type parameter) is...\n+    E0480, // lifetime of method receiver does not outlive the method call\n+    E0481, // lifetime of function argument does not outlive the function call\n+    E0482, // lifetime of return value does not outlive the function call\n+    E0483, // lifetime of operand does not outlive the operation\n+    E0484, // reference is not valid at the time of borrow\n+    E0485, // automatically reference is not valid at the time of borrow\n+    E0486, // type of expression contains references that are not valid during...\n+    E0487, // unsafe use of destructor: destructor might be called while...\n+    E0488, // lifetime of variable does not enclose its declaration\n+    E0489, // type/lifetime parameter not in scope here\n+    E0490, // a value of type `..` is borrowed for too long\n+    E0491, // in type `..`, reference has a longer lifetime than the data it...\n }"}, {"sha": "2cce9ef9145f60fab1344518cb4138c5d38dc626", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -467,7 +467,8 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n         for result in gather_attrs(attrs) {\n             let v = match result {\n                 Err(span) => {\n-                    self.tcx.sess.span_err(span, \"malformed lint attribute\");\n+                    span_err!(self.tcx.sess, span, E0452,\n+                              \"malformed lint attribute\");\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n@@ -496,10 +497,10 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 let now = self.lints.get_level_source(lint_id).0;\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n-                    self.tcx.sess.span_err(span,\n-                                           &format!(\"{}({}) overruled by outer forbid({})\",\n-                                                   level.as_str(), lint_name,\n-                                                   lint_name));\n+                    span_err!(self.tcx.sess, span, E0453,\n+                              \"{}({}) overruled by outer forbid({})\",\n+                              level.as_str(), lint_name,\n+                              lint_name);\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));"}, {"sha": "c8298c3504c09e342f2484dd14cf84fce2f571b7", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -122,8 +122,8 @@ fn register_native_lib(sess: &Session,\n     if name.is_empty() {\n         match span {\n             Some(span) => {\n-                sess.span_err(span, \"#[link(name = \\\"\\\")] given with \\\n-                                     empty name\");\n+                span_err!(sess, span, E0454,\n+                          \"#[link(name = \\\"\\\")] given with empty name\");\n             }\n             None => {\n                 sess.err(\"empty library name given via `-l`\");\n@@ -135,7 +135,10 @@ fn register_native_lib(sess: &Session,\n     if kind == cstore::NativeFramework && !is_osx {\n         let msg = \"native frameworks are only available on OSX targets\";\n         match span {\n-            Some(span) => sess.span_err(span, msg),\n+            Some(span) => {\n+                span_err!(sess, span, E0455,\n+                          \"{}\", msg)\n+            }\n             None => sess.err(msg),\n         }\n     }\n@@ -517,7 +520,7 @@ impl<'a> CrateReader<'a> {\n                                   name,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(span, &message[..]);\n+            span_err!(self.sess, span, E0456, \"{}\", &message[..]);\n             self.sess.abort_if_errors();\n         }\n \n@@ -527,10 +530,10 @@ impl<'a> CrateReader<'a> {\n         match (ekrate.dylib.as_ref(), registrar) {\n             (Some(dylib), Some(reg)) => Some((dylib.to_path_buf(), reg)),\n             (None, Some(_)) => {\n-                let message = format!(\"plugin `{}` only found in rlib format, \\\n-                                       but must be available in dylib format\",\n-                                       name);\n-                self.sess.span_err(span, &message[..]);\n+                span_err!(self.sess, span, E0457,\n+                          \"plugin `{}` only found in rlib format, but must be available \\\n+                           in dylib format\",\n+                          name);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None\n@@ -763,7 +766,8 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n                 Some(\"dylib\") => cstore::NativeUnknown,\n                 Some(\"framework\") => cstore::NativeFramework,\n                 Some(k) => {\n-                    self.sess.span_err(m.span, &format!(\"unknown kind: `{}`\", k));\n+                    span_err!(self.sess, m.span, E0458,\n+                              \"unknown kind: `{}`\", k);\n                     cstore::NativeUnknown\n                 }\n                 None => cstore::NativeUnknown\n@@ -774,8 +778,8 @@ impl<'a, 'b> LocalCrateReader<'a, 'b> {\n             let n = match n {\n                 Some(n) => n,\n                 None => {\n-                    self.sess.span_err(m.span, \"#[link(...)] specified without \\\n-                                                `name = \\\"foo\\\"`\");\n+                    span_err!(self.sess, m.span, E0459,\n+                              \"#[link(...)] specified without `name = \\\"foo\\\"`\");\n                     InternedString::new(\"foo\")\n                 }\n             };"}, {"sha": "99d1eaebdb2518da848f9b4c7ee34d196ca0fdb8", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -308,23 +308,28 @@ impl<'a> Context<'a> {\n     }\n \n     pub fn report_load_errs(&mut self) {\n-        let message = if !self.rejected_via_hash.is_empty() {\n-            format!(\"found possibly newer version of crate `{}`\",\n-                    self.ident)\n+        let add = match self.root {\n+            &None => String::new(),\n+            &Some(ref r) => format!(\" which `{}` depends on\",\n+                                    r.ident)\n+        };\n+        if !self.rejected_via_hash.is_empty() {\n+            span_err!(self.sess, self.span, E0460,\n+                      \"found possibly newer version of crate `{}`{}\",\n+                      self.ident, add);\n         } else if !self.rejected_via_triple.is_empty() {\n-            format!(\"couldn't find crate `{}` with expected target triple {}\",\n-                    self.ident, self.triple)\n+            span_err!(self.sess, self.span, E0461,\n+                      \"couldn't find crate `{}` with expected target triple {}{}\",\n+                      self.ident, self.triple, add);\n         } else if !self.rejected_via_kind.is_empty() {\n-            format!(\"found staticlib `{}` instead of rlib or dylib\", self.ident)\n+            span_err!(self.sess, self.span, E0462,\n+                      \"found staticlib `{}` instead of rlib or dylib{}\",\n+                      self.ident, add);\n         } else {\n-            format!(\"can't find crate for `{}`\", self.ident)\n-        };\n-        let message = match self.root {\n-            &None => message,\n-            &Some(ref r) => format!(\"{} which `{}` depends on\",\n-                                    message, r.ident)\n-        };\n-        self.sess.span_err(self.span, &message[..]);\n+            span_err!(self.sess, self.span, E0463,\n+                      \"can't find crate for `{}`{}\",\n+                      self.ident, add);\n+        }\n \n         if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n@@ -473,9 +478,9 @@ impl<'a> Context<'a> {\n             0 => None,\n             1 => Some(libraries.into_iter().next().unwrap()),\n             _ => {\n-                self.sess.span_err(self.span,\n-                    &format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name));\n+                span_err!(self.sess, self.span, E0464,\n+                          \"multiple matching crates for `{}`\",\n+                          self.crate_name);\n                 self.sess.note(\"candidates:\");\n                 for lib in &libraries {\n                     match lib.dylib {\n@@ -543,11 +548,9 @@ impl<'a> Context<'a> {\n                 }\n             };\n             if ret.is_some() {\n-                self.sess.span_err(self.span,\n-                                   &format!(\"multiple {} candidates for `{}` \\\n-                                            found\",\n-                                           flavor,\n-                                           self.crate_name));\n+                span_err!(self.sess, self.span, E0465,\n+                          \"multiple {} candidates for `{}` found\",\n+                          flavor, self.crate_name);\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap().0"}, {"sha": "5105426392b2c9c2d28dd70f60f64811a0a4b767", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -41,6 +41,10 @@ impl<'a> MacroLoader<'a> {\n     }\n }\n \n+pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n+    span_err!(a, b, E0467, \"bad macro reexport\");\n+}\n+\n /// Read exported macros.\n pub fn read_macro_defs(sess: &Session, krate: &ast::Crate) -> Vec<ast::MacroDef> {\n     let mut loader = MacroLoader::new(sess);\n@@ -91,7 +95,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                             if let ast::MetaWord(ref name) = attr.node {\n                                 sel.insert(name.clone(), attr.span);\n                             } else {\n-                                self.sess.span_err(attr.span, \"bad macro import\");\n+                                span_err!(self.sess, attr.span, E0466, \"bad macro import\");\n                             }\n                         }\n                     }\n@@ -100,7 +104,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                     let names = match attr.meta_item_list() {\n                         Some(names) => names,\n                         None => {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            call_bad_macro_reexport(self.sess, attr.span);\n                             continue;\n                         }\n                     };\n@@ -109,7 +113,7 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n                         if let ast::MetaWord(ref name) = attr.node {\n                             reexport.insert(name.clone(), attr.span);\n                         } else {\n-                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            call_bad_macro_reexport(self.sess, attr.span);\n                         }\n                     }\n                 }\n@@ -141,8 +145,8 @@ impl<'a> MacroLoader<'a> {\n         }\n \n         if !self.span_whitelist.contains(&vi.span) {\n-            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n-                                         the crate root\");\n+            span_err!(self.sess, vi.span, E0468,\n+                      \"an `extern crate` loading macros must be at the crate root\");\n             return;\n         }\n \n@@ -167,14 +171,16 @@ impl<'a> MacroLoader<'a> {\n         if let Some(sel) = import.as_ref() {\n             for (name, span) in sel {\n                 if !seen.contains(&name) {\n-                    self.sess.span_err(*span, \"imported macro not found\");\n+                    span_err!(self.sess, *span, E0469,\n+                              \"imported macro not found\");\n                 }\n             }\n         }\n \n         for (name, span) in &reexport {\n             if !seen.contains(&name) {\n-                self.sess.span_err(*span, \"reexported macro not found\");\n+                span_err!(self.sess, *span, E0470,\n+                          \"reexported macro not found\");\n             }\n         }\n     }"}, {"sha": "bf2d2fee20e5b5ee7f1c2fc5a776ccdaacabf321", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -282,9 +282,9 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n \n                 Err(err) => {\n                     let subspan = p.span.lo <= err.span.lo && err.span.hi <= p.span.hi;\n-                    cx.tcx.sess.span_err(err.span,\n-                                         &format!(\"constant evaluation error: {}\",\n-                                                  err.description()));\n+                    span_err!(cx.tcx.sess, err.span, E0471,\n+                              \"constant evaluation error: {}\",\n+                              err.description());\n                     if !subspan {\n                         cx.tcx.sess.span_note(p.span,\n                                               \"in pattern here\")"}, {"sha": "b9f8f20536a132ce2272958707a2e708bf076815", "filename": "src/librustc/middle/check_no_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmiddle%2Fcheck_no_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmiddle%2Fcheck_no_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_no_asm.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -32,8 +32,8 @@ struct CheckNoAsm<'a> {\n impl<'a, 'v> Visitor<'v> for CheckNoAsm<'a> {\n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprInlineAsm(_) => self.sess.span_err(e.span,\n-                                                        \"asm! is unsupported on this target\"),\n+            ast::ExprInlineAsm(_) => span_err!(self.sess, e.span, E0472,\n+                                               \"asm! is unsupported on this target\"),\n             _ => {},\n         }\n         visit::walk_expr(self, e)"}, {"sha": "3d5c568ad312a881aa0cb23e72a6f51b3fed8b8f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 55, "deletions": 76, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7358a5e8ea7c2ab0aaa76b503ef68161e44681a0/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=7358a5e8ea7c2ab0aaa76b503ef68161e44681a0", "patch": "@@ -717,20 +717,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::DerefPointer(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"dereference of reference outside its lifetime\");\n+                span_err!(self.tcx.sess, span, E0473,\n+                          \"dereference of reference outside its lifetime\");\n                 self.tcx.note_and_explain_region(\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::FreeVariable(span, id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"captured variable `{}` does not \\\n-                              outlive the enclosing closure\",\n-                             self.tcx.local_var_name_str(id)));\n+                span_err!(self.tcx.sess, span, E0474,\n+                          \"captured variable `{}` does not outlive the enclosing closure\",\n+                          self.tcx.local_var_name_str(id));\n                 self.tcx.note_and_explain_region(\n                     \"captured variable is valid for \",\n                     sup,\n@@ -741,18 +738,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::IndexSlice(span) => {\n-                self.tcx.sess.span_err(span,\n-                                       \"index of slice outside its lifetime\");\n+                span_err!(self.tcx.sess, span, E0475,\n+                          \"index of slice outside its lifetime\");\n                 self.tcx.note_and_explain_region(\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::RelateObjectBound(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of the source pointer does not outlive \\\n-                     lifetime bound of the object type\");\n+                span_err!(self.tcx.sess, span, E0476,\n+                          \"lifetime of the source pointer does not outlive \\\n+                           lifetime bound of the object type\");\n                 self.tcx.note_and_explain_region(\n                     \"object type is valid for \",\n                     sub,\n@@ -763,20 +759,17 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::RelateParamBound(span, ty) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"the type `{}` does not fulfill the \\\n-                             required lifetime\",\n-                            self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0477,\n+                          \"the type `{}` does not fulfill the required lifetime\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n             }\n             infer::RelateRegionParamBound(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime bound not satisfied\");\n+                span_err!(self.tcx.sess, span, E0478,\n+                          \"lifetime bound not satisfied\");\n                 self.tcx.note_and_explain_region(\n                     \"lifetime parameter instantiated with \",\n                     sup,\n@@ -787,92 +780,82 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::RelateDefaultParamBound(span, ty) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"the type `{}` (provided as the value of \\\n-                             a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0479,\n+                          \"the type `{}` (provided as the value of \\\n+                           a type parameter) is not valid at this point\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n             }\n             infer::CallRcvr(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of method receiver does not outlive \\\n-                     the method call\");\n+                span_err!(self.tcx.sess, span, E0480,\n+                          \"lifetime of method receiver does not outlive \\\n+                           the method call\");\n                 self.tcx.note_and_explain_region(\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::CallArg(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of function argument does not outlive \\\n-                     the function call\");\n+                span_err!(self.tcx.sess, span, E0481,\n+                          \"lifetime of function argument does not outlive \\\n+                           the function call\");\n                 self.tcx.note_and_explain_region(\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::CallReturn(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of return value does not outlive \\\n-                     the function call\");\n+                span_err!(self.tcx.sess, span, E0482,\n+                          \"lifetime of return value does not outlive \\\n+                           the function call\");\n                 self.tcx.note_and_explain_region(\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::Operand(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of operand does not outlive \\\n-                     the operation\");\n+                span_err!(self.tcx.sess, span, E0483,\n+                          \"lifetime of operand does not outlive \\\n+                           the operation\");\n                 self.tcx.note_and_explain_region(\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::AddrOf(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"reference is not valid \\\n-                     at the time of borrow\");\n+                span_err!(self.tcx.sess, span, E0484,\n+                          \"reference is not valid at the time of borrow\");\n                 self.tcx.note_and_explain_region(\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::AutoBorrow(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"automatically reference is not valid \\\n-                     at the time of borrow\");\n+                span_err!(self.tcx.sess, span, E0485,\n+                          \"automatically reference is not valid \\\n+                           at the time of borrow\");\n                 self.tcx.note_and_explain_region(\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"type of expression contains references \\\n-                             that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t)));\n+                span_err!(self.tcx.sess, span, E0486,\n+                          \"type of expression contains references \\\n+                           that are not valid during the expression: `{}`\",\n+                          self.ty_to_string(t));\n                 self.tcx.note_and_explain_region(\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::SafeDestructor(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"unsafe use of destructor: destructor might be called \\\n-                     while references are dead\");\n+                span_err!(self.tcx.sess, span, E0487,\n+                          \"unsafe use of destructor: destructor might be called \\\n+                           while references are dead\");\n                 // FIXME (22171): terms \"super/subregion\" are suboptimal\n                 self.tcx.note_and_explain_region(\n                     \"superregion: \",\n@@ -884,37 +867,33 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    \"lifetime of variable does not enclose its declaration\");\n+                span_err!(self.tcx.sess, span, E0488,\n+                          \"lifetime of variable does not enclose its declaration\");\n                 self.tcx.note_and_explain_region(\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n             }\n             infer::ParameterInScope(_, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"type/lifetime parameter not in scope here\"));\n+                span_err!(self.tcx.sess, span, E0489,\n+                          \"type/lifetime parameter not in scope here\");\n                 self.tcx.note_and_explain_region(\n                     \"the parameter is only valid for \",\n                     sub,\n                     \"\");\n             }\n             infer::DataBorrowed(ty, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"a value of type `{}` is borrowed for too long\",\n-                             self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0490,\n+                          \"a value of type `{}` is borrowed for too long\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\"the type is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(\"but the borrow lasts for \", sup, \"\");\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"in type `{}`, reference has a longer lifetime \\\n-                             than the data it references\",\n-                            self.ty_to_string(ty)));\n+                span_err!(self.tcx.sess, span, E0491,\n+                          \"in type `{}`, reference has a longer lifetime \\\n+                           than the data it references\",\n+                          self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(\n                     \"the pointer is valid for \",\n                     sub,\n@@ -1778,7 +1757,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"...so that return value is valid for the call\");\n             }\n             infer::Operand(span) => {\n-                self.tcx.sess.span_err(\n+                self.tcx.sess.span_note(\n                     span,\n                     \"...so that operand is valid for operation\");\n             }"}]}