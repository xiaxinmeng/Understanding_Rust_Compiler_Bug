{"sha": "f83d20eff734310a0381b7c71e0192988b6b0847", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4M2QyMGVmZjczNDMxMGEwMzgxYjdjNzFlMDE5Mjk4OGI2YjA4NDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-06T00:28:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-06T00:28:15Z"}, "message": "Auto merge of #43426 - qnighy:intercrate-ambiguity-hints, r=nikomatsakis\n\nAdd hints when intercrate ambiguity causes overlap.\n\nI'm going to tackle #23980.\n\n# Examples\n\n## Trait impl overlap caused by possible downstream impl\n\n```rust\ntrait Foo<X> {}\ntrait Bar<X> {}\nimpl<X, T> Foo<X> for T where T: Bar<X> {}\nimpl<X> Foo<X> for i32 {}\n\nfn main() {}\n```\n\n```\nerror[E0119]: conflicting implementations of trait `Foo<_>` for type `i32`:\n --> test1.rs:4:1\n  |\n3 | impl<X, T> Foo<X> for T where T: Bar<X> {}\n  | ------------------------------------------ first implementation here\n4 | impl<X> Foo<X> for i32 {}\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `i32`\n  |\n  = note: downstream crates may implement Bar\n\nerror: aborting due to previous error\n```\n\n## Trait impl overlap caused by possible upstream update\n\n```rust\ntrait Foo {}\nimpl<T> Foo for T where T: ::std::fmt::Octal {}\nimpl Foo for () {}\n\nfn main() {}\n```\n\n```\nerror[E0119]: conflicting implementations of trait `Foo` for type `()`:\n --> test2.rs:3:1\n  |\n2 | impl<T> Foo for T where T: ::std::fmt::Octal {}\n  | ----------------------------------------------- first implementation here\n3 | impl Foo for () {}\n  | ^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n  |\n  = note: upstream crates may add new impl for std::fmt::Octal in future versions\n\nerror: aborting due to previous error\n```\n\n## Inherent impl overlap caused by possible downstream impl\n\n```rust\ntrait Bar<X> {}\n\nstruct A<T, X>(T, X);\nimpl<X, T> A<T, X> where T: Bar<X> { fn f(&self) {} }\nimpl<X> A<i32, X> { fn f(&self) {} }\n\nfn main() {}\n```\n\n```\nerror[E0592]: duplicate definitions with name `f`\n --> test3.rs:4:38\n  |\n4 | impl<X, T> A<T, X> where T: Bar<X> { fn f(&self) {} }\n  |                                      ^^^^^^^^^^^^^^ duplicate definitions for `f`\n5 | impl<X> A<i32, X> { fn f(&self) {} }\n  |                     -------------- other definition for `f`\n  |\n  = note: downstream crates may implement Bar\n\nerror: aborting due to previous error\n```\n\n## Inherent impl overlap caused by possible upstream update\n\n```rust\nstruct A<T>(T);\n\nimpl<T> A<T> where T: ::std::fmt::Octal { fn f(&self) {} }\nimpl A<()> { fn f(&self) {} }\n\nfn main() {}\n```\n\n```\nerror[E0592]: duplicate definitions with name `f`\n --> test4.rs:3:43\n  |\n3 | impl<T> A<T> where T: ::std::fmt::Octal { fn f(&self) {} }\n  |                                           ^^^^^^^^^^^^^^ duplicate definitions for `f`\n4 | impl A<()> { fn f(&self) {} }\n  |              -------------- other definition for `f`\n  |\n  = note: upstream crates may add new impl for std::fmt::Octal in future versions\n\nerror: aborting due to previous error\n```", "tree": {"sha": "635928e4d001ca2b5f88d4f8a497c7cd94db50d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/635928e4d001ca2b5f88d4f8a497c7cd94db50d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83d20eff734310a0381b7c71e0192988b6b0847", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83d20eff734310a0381b7c71e0192988b6b0847", "html_url": "https://github.com/rust-lang/rust/commit/f83d20eff734310a0381b7c71e0192988b6b0847", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83d20eff734310a0381b7c71e0192988b6b0847/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1ef9ef1181298d46e79d5dde6bafeb6483926f", "html_url": "https://github.com/rust-lang/rust/commit/2f1ef9ef1181298d46e79d5dde6bafeb6483926f"}, {"sha": "37c9a60a7d24d5b8c51f647e8c39e48965cd2b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/37c9a60a7d24d5b8c51f647e8c39e48965cd2b82", "html_url": "https://github.com/rust-lang/rust/commit/37c9a60a7d24d5b8c51f647e8c39e48965cd2b82"}], "stats": {"total": 321, "additions": 290, "deletions": 31}, "files": [{"sha": "f3682f8d35d84d901f32e49132977c1a00075973", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -13,6 +13,7 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n+use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n use ty::subst::Subst;\n \n@@ -21,12 +22,17 @@ use infer::{InferCtxt, InferOk};\n #[derive(Copy, Clone)]\n struct InferIsLocal(bool);\n \n+pub struct OverlapResult<'tcx> {\n+    pub impl_header: ty::ImplHeader<'tcx>,\n+    pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+}\n+\n /// If there are types that satisfy both impls, returns a suitably-freshened\n /// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n                                           impl1_def_id: DefId,\n                                           impl2_def_id: DefId)\n-                                          -> Option<ty::ImplHeader<'tcx>>\n+                                          -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n@@ -65,7 +71,7 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n                             a_def_id: DefId,\n                             b_def_id: DefId)\n-                            -> Option<ty::ImplHeader<'tcx>>\n+                            -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"overlap(a_def_id={:?}, b_def_id={:?})\",\n            a_def_id,\n@@ -113,11 +119,14 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n         return None\n     }\n \n-    Some(selcx.infcx().resolve_type_vars_if_possible(&a_impl_header))\n+    Some(OverlapResult {\n+        impl_header: selcx.infcx().resolve_type_vars_if_possible(&a_impl_header),\n+        intercrate_ambiguity_causes: selcx.intercrate_ambiguity_causes().to_vec(),\n+    })\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                             trait_ref: &ty::TraitRef<'tcx>) -> bool\n+                                             trait_ref: ty::TraitRef<'tcx>) -> bool\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n \n@@ -131,10 +140,7 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     // if the trait is not marked fundamental, then it's always possible that\n     // an ancestor crate will impl this in the future, if they haven't\n     // already\n-    if\n-        trait_ref.def_id.krate != LOCAL_CRATE &&\n-        !tcx.has_attr(trait_ref.def_id, \"fundamental\")\n-    {\n+    if !trait_ref_is_local_or_fundamental(tcx, trait_ref) {\n         debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n         return false;\n     }\n@@ -148,6 +154,12 @@ pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n }\n \n+pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                                         trait_ref: ty::TraitRef<'tcx>)\n+                                                         -> bool {\n+    trait_ref.def_id.krate == LOCAL_CRATE || tcx.has_attr(trait_ref.def_id, \"fundamental\")\n+}\n+\n pub enum OrphanCheckErr<'tcx> {\n     NoLocalInputType,\n     UncoveredTy(Ty<'tcx>),\n@@ -177,11 +189,11 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, &trait_ref, InferIsLocal(false))\n+    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false))\n }\n \n fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n-                                trait_ref: &ty::TraitRef<'tcx>,\n+                                trait_ref: ty::TraitRef<'tcx>,\n                                 infer_is_local: InferIsLocal)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {"}, {"sha": "22c92776c5e4e01a9516a1bdfb2c6fd592abfa07", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -28,9 +28,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n \n-pub use self::coherence::orphan_check;\n-pub use self::coherence::overlapping_impls;\n-pub use self::coherence::OrphanCheckErr;\n+pub use self::coherence::{orphan_check, overlapping_impls, OrphanCheckErr, OverlapResult};\n pub use self::fulfill::{FulfillmentContext, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n@@ -39,6 +37,7 @@ pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n+pub use self::select::IntercrateAmbiguityCause;\n pub use self::specialize::{OverlapError, specialization_graph, translate_substs};\n pub use self::specialize::{SpecializesCache, find_associated_item};\n pub use self::util::elaborate_predicates;"}, {"sha": "cd259fc2528e5d3143574a2d733a50c5875db552", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -90,6 +90,45 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     intercrate: bool,\n \n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n+\n+    intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n+}\n+\n+#[derive(Clone)]\n+pub enum IntercrateAmbiguityCause {\n+    DownstreamCrate {\n+        trait_desc: String,\n+        self_desc: Option<String>,\n+    },\n+    UpstreamCrateUpdate {\n+        trait_desc: String,\n+        self_desc: Option<String>,\n+    },\n+}\n+\n+impl IntercrateAmbiguityCause {\n+    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n+    /// See #23980 for details.\n+    pub fn add_intercrate_ambiguity_hint<'a, 'tcx>(&self,\n+                                                   err: &mut ::errors::DiagnosticBuilder) {\n+        match self {\n+            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else { \"\".to_string() };\n+                err.note(&format!(\"downstream crates may implement trait `{}`{}\",\n+                                  trait_desc, self_desc));\n+            }\n+            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else { \"\".to_string() };\n+                err.note(&format!(\"upstream crates may add new impl of trait `{}`{} \\\n+                                  in future versions\",\n+                                  trait_desc, self_desc));\n+            }\n+        }\n+    }\n }\n \n // A stack that walks back up the stack frame.\n@@ -380,6 +419,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             freshener: infcx.freshener(),\n             intercrate: false,\n             inferred_obligations: SnapshotVec::new(),\n+            intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n@@ -389,6 +429,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             freshener: infcx.freshener(),\n             intercrate: true,\n             inferred_obligations: SnapshotVec::new(),\n+            intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n@@ -404,6 +445,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n+    pub fn intercrate_ambiguity_causes(&self) -> &[IntercrateAmbiguityCause] {\n+        &self.intercrate_ambiguity_causes\n+    }\n+\n     /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n     /// context's self.\n     fn in_snapshot<R, F>(&mut self, f: F) -> R\n@@ -757,6 +802,22 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         if unbound_input_types && self.intercrate {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n+            // Heuristics: show the diagnostics when there are no candidates in crate.\n+            if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                    let self_ty = trait_ref.self_ty();\n+                    let cause = IntercrateAmbiguityCause::DownstreamCrate {\n+                        trait_desc: trait_ref.to_string(),\n+                        self_desc: if self_ty.has_concrete_skeleton() {\n+                            Some(self_ty.to_string())\n+                        } else {\n+                            None\n+                        },\n+                    };\n+                    self.intercrate_ambiguity_causes.push(cause);\n+                }\n+            }\n             return EvaluatedToAmbig;\n         }\n         if unbound_input_types &&\n@@ -1003,6 +1064,25 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if !self.is_knowable(stack) {\n             debug!(\"coherence stage: not knowable\");\n+            // Heuristics: show the diagnostics when there are no candidates in crate.\n+            let candidate_set = self.assemble_candidates(stack)?;\n+            if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n+                let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                let self_ty = trait_ref.self_ty();\n+                let trait_desc = trait_ref.to_string();\n+                let self_desc = if self_ty.has_concrete_skeleton() {\n+                    Some(self_ty.to_string())\n+                } else {\n+                    None\n+                };\n+                let cause = if !coherence::trait_ref_is_local_or_fundamental(self.tcx(),\n+                                                                             trait_ref) {\n+                    IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                } else {\n+                    IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                };\n+                self.intercrate_ambiguity_causes.push(cause);\n+            }\n             return Ok(None);\n         }\n \n@@ -1124,7 +1204,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // ok to skip binder because of the nature of the\n         // trait-ref-is-knowable check, which does not care about\n         // bound regions\n-        let trait_ref = &predicate.skip_binder().trait_ref;\n+        let trait_ref = predicate.skip_binder().trait_ref;\n \n         coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n     }"}, {"sha": "f9332fc6697e02bff8cc67f6fcf98b8167d9883c", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -25,6 +25,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk};\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n+use traits::select::IntercrateAmbiguityCause;\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n@@ -36,6 +37,7 @@ pub struct OverlapError {\n     pub with_impl: DefId,\n     pub trait_desc: String,\n     pub self_desc: Option<String>,\n+    pub intercrate_ambiguity_causes: Vec<IntercrateAmbiguityCause>,\n }\n \n /// Given a subst for the requested impl, translate it to a subst\n@@ -337,6 +339,10 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n                     }\n                 }\n \n+                for cause in &overlap.intercrate_ambiguity_causes {\n+                    cause.add_intercrate_ambiguity_hint(&mut err);\n+                }\n+\n                 err.emit();\n             }\n         } else {"}, {"sha": "2640542ad10593366fd782c176dae7ed1eb04504", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);\n-                if let Some(impl_header) = overlap {\n+                if let Some(overlap) = overlap {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n                     }\n@@ -123,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Children {\n \n                     if le == ge {\n                         // overlap, but no specialization; error out\n-                        let trait_ref = impl_header.trait_ref.unwrap();\n+                        let trait_ref = overlap.impl_header.trait_ref.unwrap();\n                         let self_ty = trait_ref.self_ty();\n                         Err(OverlapError {\n                             with_impl: possible_sibling,\n@@ -135,7 +135,8 @@ impl<'a, 'gcx, 'tcx> Children {\n                                 Some(self_ty.to_string())\n                             } else {\n                                 None\n-                            }\n+                            },\n+                            intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n                         })\n                     } else {\n                         Ok((le, ge))"}, {"sha": "76dcfe36e4fcdc80e8d07763964cda2ffc575a2e", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -26,7 +26,8 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n-    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n+    fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n+                                       overlap: traits::OverlapResult) {\n         #[derive(Copy, Clone, PartialEq)]\n         enum Namespace {\n             Type,\n@@ -50,16 +51,22 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    struct_span_err!(self.tcx.sess,\n-                                     self.tcx.span_of_impl(item1).unwrap(),\n-                                     E0592,\n-                                     \"duplicate definitions with name `{}`\",\n-                                     name)\n-                        .span_label(self.tcx.span_of_impl(item1).unwrap(),\n-                                    format!(\"duplicate definitions for `{}`\", name))\n-                        .span_label(self.tcx.span_of_impl(item2).unwrap(),\n-                                    format!(\"other definition for `{}`\", name))\n-                        .emit();\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   self.tcx.span_of_impl(item1).unwrap(),\n+                                                   E0592,\n+                                                   \"duplicate definitions with name `{}`\",\n+                                                   name);\n+\n+                    err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n+                                   format!(\"duplicate definitions for `{}`\", name));\n+                    err.span_label(self.tcx.span_of_impl(item2).unwrap(),\n+                                   format!(\"other definition for `{}`\", name));\n+\n+                    for cause in &overlap.intercrate_ambiguity_causes {\n+                        cause.add_intercrate_ambiguity_hint(&mut err);\n+                    }\n+\n+                    err.emit();\n                 }\n             }\n         }\n@@ -71,8 +78,9 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n                 self.tcx.infer_ctxt().enter(|infcx| {\n-                    if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n+                    if let Some(overlap) =\n+                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n+                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap)\n                     }\n                 });\n             }"}, {"sha": "66068b535556cafd9a86e130d6e40e18dc21fbdd", "filename": "src/test/compile-fail/coherence-overlap-downstream-inherent.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-downstream-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-downstream-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-downstream-inherent.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `T: Sugar + Fruit` to be ambiguous, even\n+// though no impls are found.\n+\n+struct Sweet<X>(X);\n+pub trait Sugar {}\n+pub trait Fruit {}\n+impl<T:Sugar> Sweet<T> { fn dummy(&self) { } }\n+//~^ ERROR E0592\n+//~| NOTE duplicate definitions for `dummy`\n+impl<T:Fruit> Sweet<T> { fn dummy(&self) { } }\n+//~^ NOTE other definition for `dummy`\n+\n+trait Bar<X> {}\n+struct A<T, X>(T, X);\n+impl<X, T> A<T, X> where T: Bar<X> { fn f(&self) {} }\n+//~^ ERROR E0592\n+//~| NOTE duplicate definitions for `f`\n+//~| NOTE downstream crates may implement trait `Bar<_>` for type `i32`\n+impl<X> A<i32, X> { fn f(&self) {} }\n+//~^ NOTE other definition for `f`\n+\n+fn main() {}"}, {"sha": "1df02737dec58282f628cbe95d9921f6a1f7c703", "filename": "src/test/compile-fail/coherence-overlap-downstream.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-downstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-downstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-downstream.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `T: Sugar + Fruit` to be ambiguous, even\n+// though no impls are found.\n+\n+pub trait Sugar {}\n+pub trait Fruit {}\n+pub trait Sweet {}\n+impl<T:Sugar> Sweet for T { }\n+//~^ NOTE first implementation here\n+impl<T:Fruit> Sweet for T { }\n+//~^ ERROR E0119\n+//~| NOTE conflicting implementation\n+\n+pub trait Foo<X> {}\n+pub trait Bar<X> {}\n+impl<X, T> Foo<X> for T where T: Bar<X> {}\n+//~^ NOTE first implementation here\n+impl<X> Foo<X> for i32 {}\n+//~^ ERROR E0119\n+//~| NOTE conflicting implementation for `i32`\n+//~| NOTE downstream crates may implement trait `Bar<_>` for type `i32`\n+\n+fn main() { }"}, {"sha": "355af60710a9bab90adcd28673d626d366632102", "filename": "src/test/compile-fail/coherence-overlap-issue-23516-inherent.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516-inherent.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `Box<U>: !Sugar` to be ambiguous, even\n+// though we see no impl of `Sugar` for `Box`. Therefore, an overlap\n+// error is reported for the following pair of impls (#23516).\n+\n+pub trait Sugar {}\n+\n+struct Cake<X>(X);\n+\n+impl<T:Sugar> Cake<T> { fn dummy(&self) { } }\n+//~^ ERROR E0592\n+//~| NOTE duplicate definitions for `dummy`\n+//~| NOTE downstream crates may implement trait `Sugar` for type `std::boxed::Box<_>`\n+impl<U:Sugar> Cake<Box<U>> { fn dummy(&self) { } }\n+//~^ NOTE other definition for `dummy`\n+\n+fn main() { }"}, {"sha": "ffef5bf10871a09b33c4db27a16e492159a0c794", "filename": "src/test/compile-fail/coherence-overlap-issue-23516.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -15,5 +15,10 @@\n pub trait Sugar { fn dummy(&self) { } }\n pub trait Sweet { fn dummy(&self) { } }\n impl<T:Sugar> Sweet for T { }\n-impl<U:Sugar> Sweet for Box<U> { } //~ ERROR E0119\n+//~^ NOTE first implementation here\n+impl<U:Sugar> Sweet for Box<U> { }\n+//~^ ERROR E0119\n+//~| NOTE conflicting implementation for `std::boxed::Box<_>`\n+//~| NOTE downstream crates may implement trait `Sugar` for type `std::boxed::Box<_>`\n+\n fn main() { }"}, {"sha": "1d0c63110cecd41a3d9f515ec73a4817a07ba610", "filename": "src/test/compile-fail/coherence-overlap-upstream-inherent.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream-inherent.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `i16: Remote` to be ambiguous, even\n+// though the upstream crate doesn't implement it for now.\n+\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib;\n+\n+use coherence_lib::Remote;\n+\n+struct A<X>(X);\n+impl<T> A<T> where T: Remote { fn dummy(&self) { } }\n+//~^ ERROR E0592\n+//~| NOTE duplicate definitions for `dummy`\n+//~| NOTE upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16`\n+impl A<i16> { fn dummy(&self) { } }\n+//~^ NOTE other definition for `dummy`\n+\n+fn main() {}"}, {"sha": "e978143a067c547f3aa6a0a0a09d88fc770198f6", "filename": "src/test/compile-fail/coherence-overlap-upstream.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-upstream.rs?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `i16: Remote` to be ambiguous, even\n+// though the upstream crate doesn't implement it for now.\n+\n+// aux-build:coherence_lib.rs\n+\n+extern crate coherence_lib;\n+\n+use coherence_lib::Remote;\n+\n+trait Foo {}\n+impl<T> Foo for T where T: Remote {}\n+//~^ NOTE first implementation here\n+impl Foo for i16 {}\n+//~^ ERROR E0119\n+//~| NOTE conflicting implementation for `i16`\n+//~| NOTE upstream crates may add new impl of trait `coherence_lib::Remote` for type `i16`\n+\n+fn main() {}"}, {"sha": "eaf42cde22f762c44a64688bbadbce5f3302c97e", "filename": "src/test/ui/codemap_tests/overlapping_inherent_impls.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f83d20eff734310a0381b7c71e0192988b6b0847/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_inherent_impls.stderr?ref=f83d20eff734310a0381b7c71e0192988b6b0847", "patch": "@@ -24,6 +24,8 @@ error[E0592]: duplicate definitions with name `baz`\n ...\n 43 |     fn baz(&self) {}\n    |     ---------------- other definition for `baz`\n+   |\n+   = note: upstream crates may add new impl of trait `std::marker::Copy` for type `std::vec::Vec<_>` in future versions\n \n error: aborting due to 3 previous errors\n "}]}