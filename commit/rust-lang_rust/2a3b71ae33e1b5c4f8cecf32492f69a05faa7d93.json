{"sha": "2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhM2I3MWFlMzNlMWI1YzRmOGNlY2YzMjQ5MmY2OWEwNWZhYTdkOTM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-04-20T15:42:06Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-08-05T21:08:28Z"}, "message": "* Rename 'move_span' into 'local_span_to_global_span'\n* Add documentation on new arguments/functions", "tree": {"sha": "0c877ecd9ef2df205d5e4fc3e728c121ada1f513", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c877ecd9ef2df205d5e4fc3e728c121ada1f513"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "html_url": "https://github.com/rust-lang/rust/commit/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5c27b49d02d5b6538e40e19e0dd1365cd7632d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c27b49d02d5b6538e40e19e0dd1365cd7632d5", "html_url": "https://github.com/rust-lang/rust/commit/b5c27b49d02d5b6538e40e19e0dd1365cd7632d5"}], "stats": {"total": 102, "additions": 85, "deletions": 17}, "files": [{"sha": "d79fcdd5fcee577accb6a1ae42555ccbe94a46f8", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "patch": "@@ -1943,14 +1943,18 @@ crate enum Variant {\n crate struct Span(rustc_span::Span);\n \n impl Span {\n+    /// Wraps a [`rustc_span::Span`]. In case this span is the result of a macro expansion, the\n+    /// span will be updated to point to the macro invocation instead of the macro definition.\n+    ///\n+    /// (See rust-lang/rust#39726)\n     crate fn from_rustc_span(sp: rustc_span::Span) -> Self {\n-        // Get the macro invocation instead of the definition,\n-        // in case the span is result of a macro expansion.\n-        // (See rust-lang/rust#39726)\n         Self(sp.source_callsite())\n     }\n \n     /// Unless you know what you're doing, use [`Self::from_rustc_span`] instead!\n+    ///\n+    /// Contrary to [`Self::from_rustc_span`], this constructor wraps the span as is and don't\n+    /// perform any operation on it, even if it's from a macro expansion.\n     crate fn wrap(sp: rustc_span::Span) -> Span {\n         Self(sp)\n     }"}, {"sha": "8ab6aa775d2e4fb09eda2bb004828903d6ba13e4", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "patch": "@@ -494,10 +494,7 @@ crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Str\n     if !did.is_local() && !cache.access_levels.is_public(did) && !cache.document_private {\n         return Err(HrefError::Private);\n     }\n-    // href_with_depth_inner(did, cache, || {\n-    //     let depth = CURRENT_DEPTH.with(|l| l.get());\n-    //     \"../\".repeat(depth)\n-    // })\n+\n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => (fqp, shortty, {\n             let module_fqp = to_module_fqp(shortty, fqp);"}, {"sha": "62f8618b8c6e78eb253a234b403ebafbf7acb060", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "patch": "@@ -63,6 +63,24 @@ fn write_header(out: &mut Buffer, class: Option<&str>, extra_content: Option<Buf\n     }\n }\n \n+/// Convert the given `src` source code into HTML by adding classes for highlighting.\n+///\n+/// This code is used to render code blocks (in the documentation) as well as the source code pages.\n+///\n+/// Some explanations on the last arguments:\n+///\n+/// In case we are rendering a code block and not a source code file, `file_span_lo` value doesn't\n+/// matter and `context` will be `None`. To put it more simply: if `context` is `None`, the code\n+/// won't try to generate links to an ident definition.\n+///\n+/// More explanations about spans and how we use them here are provided in the\n+/// [`local_span_to_global_span`] function documentation about how it works.\n+///\n+/// As for `root_path`, it's used to know \"how far\" from the top of the directory we are to link\n+/// to either documentation pages or other source pages.\n+///\n+/// Same as `file_span_lo`: its value doesn't matter in case you are not rendering a source code\n+/// file.\n fn write_code(\n     out: &mut Buffer,\n     src: &str,\n@@ -135,6 +153,8 @@ impl Class {\n         }\n     }\n \n+    /// In case this is an item which can be converted into a link to a definition, it'll contain\n+    /// a \"span\" (a tuple representing `(lo, hi)` equivalent of `Span`).\n     fn get_span(self) -> Option<(u32, u32)> {\n         match self {\n             Self::Ident(sp) | Self::Self_(sp) => Some(sp),\n@@ -166,7 +186,7 @@ impl Iterator for TokenIter<'a> {\n     }\n }\n \n-/// Returns `None` if this is a `Class::Ident`.\n+/// Classifies into identifier class; returns `None` if this is a non-keyword identifier.\n fn get_real_ident_class(text: &str, edition: Edition, allow_path_keywords: bool) -> Option<Class> {\n     let ignore: &[&str] =\n         if allow_path_keywords { &[\"self\", \"Self\", \"super\", \"crate\"] } else { &[\"self\", \"Self\"] };\n@@ -181,7 +201,20 @@ fn get_real_ident_class(text: &str, edition: Edition, allow_path_keywords: bool)\n     })\n }\n \n-fn move_span(file_span_lo: u32, start: u32, end: u32) -> (u32, u32) {\n+/// Before explaining what this function does, some global explanations on rust's `Span`:\n+///\n+/// Each source code file is stored in the source map in the compiler and has a\n+/// `lo` and a `hi` (lowest and highest bytes in this source map which can be seen as one huge\n+/// string to simplify things). So in this case, this represents the starting byte of the current\n+/// file. It'll be used later on to retrieve the \"definition span\" from the\n+/// `span_correspondance_map` (which is inside `context`).\n+///\n+/// This when we transform the \"span\" we have from reading the input into a \"span\" which can be\n+/// used as index to the `span_correspondance_map` to get the definition of this item.\n+///\n+/// So in here, `file_span_lo` is representing the \"lo\" byte in the global source map, and to make\n+/// our \"span\" works in there, we simply add `file_span_lo` to our values.\n+fn local_span_to_global_span(file_span_lo: u32, start: u32, end: u32) -> (u32, u32) {\n     (start + file_span_lo, end + file_span_lo)\n }\n \n@@ -199,6 +232,9 @@ struct Classifier<'a> {\n }\n \n impl<'a> Classifier<'a> {\n+    /// Takes as argument the source code to HTML-ify, the rust edition to use and the source code\n+    /// file \"lo\" byte which we be used later on by the `span_correspondance_map`. More explanations\n+    /// are provided in the [`local_span_to_global_span`] function documentation about how it works.\n     fn new(src: &str, edition: Edition, file_span_lo: u32) -> Classifier<'_> {\n         let tokens = TokenIter { src }.peekable();\n         Classifier {\n@@ -263,7 +299,10 @@ impl<'a> Classifier<'a> {\n         }\n     }\n \n-    /// Wraps the tokens iteration to ensure that the byte_pos is always correct.\n+    /// Wraps the tokens iteration to ensure that the `byte_pos` is always correct.\n+    ///\n+    /// It returns the token's kind, the token as a string and its byte position in the source\n+    /// string.\n     fn next(&mut self) -> Option<(TokenKind, &'a str, u32)> {\n         if let Some((kind, text)) = self.tokens.next() {\n             let before = self.byte_pos;\n@@ -306,8 +345,12 @@ impl<'a> Classifier<'a> {\n         }\n     }\n \n-    /// Single step of highlighting. This will classify `token`, but maybe also\n-    /// a couple of following ones as well.\n+    /// Single step of highlighting. This will classify `token`, but maybe also a couple of\n+    /// following ones as well.\n+    ///\n+    /// `before` is the position of the given token in the `source` string and is used as \"lo\" byte\n+    /// in case we want to try to generate a link for this token using the\n+    /// `span_correspondance_map`.\n     fn advance(\n         &mut self,\n         token: TokenKind,\n@@ -453,22 +496,24 @@ impl<'a> Classifier<'a> {\n                         self.in_macro_nonterminal = false;\n                         Class::MacroNonTerminal\n                     }\n-                    \"self\" | \"Self\" => Class::Self_(move_span(\n+                    \"self\" | \"Self\" => Class::Self_(local_span_to_global_span(\n                         self.file_span_lo,\n                         before,\n                         before + text.len() as u32,\n                     )),\n-                    _ => Class::Ident(move_span(\n+                    _ => Class::Ident(local_span_to_global_span(\n                         self.file_span_lo,\n                         before,\n                         before + text.len() as u32,\n                     )),\n                 },\n                 Some(c) => c,\n             },\n-            TokenKind::RawIdent | TokenKind::UnknownPrefix => {\n-                Class::Ident(move_span(self.file_span_lo, before, before + text.len() as u32))\n-            }\n+            TokenKind::RawIdent | TokenKind::UnknownPrefix => Class::Ident(local_span_to_global_span(\n+                self.file_span_lo,\n+                before,\n+                before + text.len() as u32,\n+            )),\n             TokenKind::Lifetime { .. } => Class::Lifetime,\n         };\n         // Anything that didn't return above is the simple case where we the\n@@ -501,8 +546,13 @@ fn exit_span(out: &mut Buffer) {\n ///     enter_span(Foo), string(\"text\", None), exit_span()\n ///     string(\"text\", Foo)\n /// ```\n+///\n /// The latter can be thought of as a shorthand for the former, which is more\n /// flexible.\n+///\n+/// Note that if `context` is not `None` and that the given `klass` contains a `Span`, the function\n+/// will then try to find this `span` in the `span_correspondance_map`. If found, it'll then\n+/// generate a link for this element (which corresponds to where its definition is located).\n fn string<T: Display>(\n     out: &mut Buffer,\n     text: T,"}, {"sha": "9e16c451626f7a203b9aa43337194f67d6eafb36", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=2a3b71ae33e1b5c4f8cecf32492f69a05faa7d93", "patch": "@@ -9,12 +9,29 @@ use rustc_hir::{ExprKind, GenericParam, GenericParamKind, HirId, Mod, Node};\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n \n+/// This enum allows us to store two different kinds of information:\n+///\n+/// In case the `span` definition comes from the same crate, we can simply get the `span` and use\n+/// it as is.\n+///\n+/// Otherwise, we store the definition `DefId` and will generate a link to the documentation page\n+/// instead of the source code directly.\n #[derive(Debug)]\n crate enum LinkFromSrc {\n     Local(Span),\n     External(DefId),\n }\n \n+/// This function will do at most two things:\n+///\n+/// 1. Generate a `span` correspondance map which links an item `span` to its definition `span`.\n+/// 2. Collect the source code files.\n+///\n+/// It returns the `krate`, the source code files and the `span` correspondance map.\n+///\n+/// Note about the `span` correspondance map: the keys are actually `(lo, hi)` of `span`s. We don't\n+/// need the `span` context later on, only their position, so instead of keep a whole `Span`, we\n+/// only keep the `lo` and `hi`.\n crate fn collect_spans_and_sources(\n     tcx: TyCtxt<'_>,\n     krate: clean::Crate,"}]}