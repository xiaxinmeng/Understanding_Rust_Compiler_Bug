{"sha": "5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTE5ZWFhNmU5YTU4MzI1N2IyZjllMjhhNzQzYWI4NWQxY2FiYzU=", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2021-02-02T02:20:44Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2021-02-13T03:01:04Z"}, "message": "Rename `Range::ensure_subset_of` to `slice::range`", "tree": {"sha": "f7c58cd480bae318802adfb646a5838effa53df3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c58cd480bae318802adfb646a5838effa53df3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "html_url": "https://github.com/rust-lang/rust/commit/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6111a256e94855f18f36f02930f8b0ae0012542", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6111a256e94855f18f36f02930f8b0ae0012542", "html_url": "https://github.com/rust-lang/rust/commit/f6111a256e94855f18f36f02930f8b0ae0012542"}], "stats": {"total": 227, "additions": 115, "deletions": 112}, "files": [{"sha": "f7cefdce27856dc587be96392f27f02ade4ed011", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -1063,7 +1063,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = Range::ensure_subset_of(range, ..self.len());\n+        let Range { start, end } = slice::range(range, ..self.len());\n         let tail = self.wrap_add(self.tail, start);\n         let head = self.wrap_add(self.tail, end);\n         (tail, head)"}, {"sha": "c020a969f1fb956f6434cd58f57bb4e97debbecf", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -115,14 +115,14 @@\n #![feature(or_patterns)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n-#![feature(range_ensure_subset_of)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n #![cfg_attr(bootstrap, feature(min_const_generics))]\n #![feature(min_specialization)]\n #![feature(set_ptr_value)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n+#![feature(slice_range)]\n #![feature(staged_api)]\n #![feature(str_internals)]\n #![feature(trusted_len)]"}, {"sha": "c5ffade12619f5f58708289eb5e5bb37e9244b99", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -92,6 +92,8 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[unstable(feature = \"slice_range\", issue = \"76393\")]\n+pub use core::slice::range;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub use core::slice::ArrayChunks;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]"}, {"sha": "b4deedc52638cb0856433ccb12c07e841a023be4", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -49,6 +49,7 @@ use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n+use core::slice;\n use core::str::{lossy, pattern::Pattern};\n \n use crate::borrow::{Cow, ToOwned};\n@@ -1510,14 +1511,14 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let Range { start, end } = Range::ensure_subset_of(range, ..self.len());\n+        let Range { start, end } = slice::range(range, ..self.len());\n         assert!(self.is_char_boundary(start));\n         assert!(self.is_char_boundary(end));\n \n         // Take out two simultaneous borrows. The &mut String won't be accessed\n         // until iteration is over, in Drop.\n         let self_ptr = self as *mut _;\n-        // SAFETY: `ensure_subset_of` and `is_char_boundary` do the appropriate bounds checks.\n+        // SAFETY: `slice::range` and `is_char_boundary` do the appropriate bounds checks.\n         let chars_iter = unsafe { self.get_unchecked(start..end) }.chars();\n \n         Drain { start, end, iter: chars_iter, string: self_ptr }"}, {"sha": "a8474f8ca5921305bd5762ca29282ce56d7891af", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -1650,7 +1650,7 @@ impl<T, A: Allocator> Vec<T, A> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let Range { start, end } = Range::ensure_subset_of(range, ..len);\n+        let Range { start, end } = slice::range(range, ..len);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked"}, {"sha": "dbeb3912130061cb8ab951f672f06f1e133ad6ff", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 0, "deletions": 101, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -1,9 +1,5 @@\n use crate::fmt;\n use crate::hash::Hash;\n-use crate::slice::index::{\n-    slice_end_index_len_fail, slice_end_index_overflow_fail, slice_index_order_fail,\n-    slice_start_index_overflow_fail,\n-};\n \n /// An unbounded range (`..`).\n ///\n@@ -151,103 +147,6 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     }\n }\n \n-impl Range<usize> {\n-    /// Performs bounds-checking of a range.\n-    ///\n-    /// This method is similar to [`Index::index`] for slices, but it returns a\n-    /// `Range` equivalent to `range`. You can use this method to turn any range\n-    /// into `start` and `end` values.\n-    ///\n-    /// `bounds` is the range of the slice to use for bounds-checking. It should\n-    /// be a [`RangeTo`] range that ends at the length of the slice.\n-    ///\n-    /// The returned `Range` is safe to pass to [`slice::get_unchecked`] and\n-    /// [`slice::get_unchecked_mut`] for slices with the given range.\n-    ///\n-    /// [`slice::get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n-    /// [`slice::get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `range` would be out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_ensure_subset_of)]\n-    ///\n-    /// use std::ops::Range;\n-    ///\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(1..2, Range::ensure_subset_of(1..2, ..v.len()));\n-    /// assert_eq!(0..2, Range::ensure_subset_of(..2, ..v.len()));\n-    /// assert_eq!(1..3, Range::ensure_subset_of(1.., ..v.len()));\n-    /// ```\n-    ///\n-    /// Panics when [`Index::index`] would panic:\n-    ///\n-    /// ```should_panic\n-    /// #![feature(range_ensure_subset_of)]\n-    ///\n-    /// use std::ops::Range;\n-    ///\n-    /// Range::ensure_subset_of(2..1, ..3);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(range_ensure_subset_of)]\n-    ///\n-    /// use std::ops::Range;\n-    ///\n-    /// Range::ensure_subset_of(1..4, ..3);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(range_ensure_subset_of)]\n-    ///\n-    /// use std::ops::Range;\n-    ///\n-    /// Range::ensure_subset_of(1..=usize::MAX, ..3);\n-    /// ```\n-    ///\n-    /// [`Index::index`]: crate::ops::Index::index\n-    #[track_caller]\n-    #[unstable(feature = \"range_ensure_subset_of\", issue = \"76393\")]\n-    pub fn ensure_subset_of<R>(range: R, bounds: RangeTo<usize>) -> Self\n-    where\n-        R: RangeBounds<usize>,\n-    {\n-        let len = bounds.end;\n-\n-        let start: Bound<&usize> = range.start_bound();\n-        let start = match start {\n-            Bound::Included(&start) => start,\n-            Bound::Excluded(start) => {\n-                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n-            }\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let end: Bound<&usize> = range.end_bound();\n-        let end = match end {\n-            Bound::Included(end) => {\n-                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n-            }\n-            Bound::Excluded(&end) => end,\n-            Bound::Unbounded => len,\n-        };\n-\n-        if start > end {\n-            slice_index_order_fail(start, end);\n-        }\n-        if end > len {\n-            slice_end_index_len_fail(end, len);\n-        }\n-\n-        Self { start, end }\n-    }\n-}\n-\n /// A range only bounded inclusively below (`start..`).\n ///\n /// The `RangeFrom` `start..` contains all values with `x >= start`."}, {"sha": "d20986bb724fc6e57f59c882f27a21d937293400", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 101, "deletions": 4, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -37,28 +37,28 @@ fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(crate) fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n+fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n     panic!(\"range end index {} out of range for slice of length {}\", index, len);\n }\n \n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(crate) fn slice_index_order_fail(index: usize, end: usize) -> ! {\n+fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(crate) fn slice_start_index_overflow_fail() -> ! {\n+fn slice_start_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice from after maximum usize\");\n }\n \n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(crate) fn slice_end_index_overflow_fail() -> ! {\n+fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n \n@@ -449,3 +449,100 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n         (0..=self.end).index_mut(slice)\n     }\n }\n+\n+/// Performs bounds-checking of a range.\n+///\n+/// This method is similar to [`Index::index`] for slices, but it returns a\n+/// [`Range`] equivalent to `range`. You can use this method to turn any range\n+/// into `start` and `end` values.\n+///\n+/// `bounds` is the range of the slice to use for bounds-checking. It should\n+/// be a [`RangeTo`] range that ends at the length of the slice.\n+///\n+/// The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and\n+/// [`slice::get_unchecked_mut`] for slices with the given range.\n+///\n+/// [`Range`]: ops::Range\n+/// [`RangeTo`]: ops::RangeTo\n+/// [`slice::get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n+/// [`slice::get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n+///\n+/// # Panics\n+///\n+/// Panics if `range` would be out of bounds.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(slice_range)]\n+///\n+/// use std::slice;\n+///\n+/// let v = [10, 40, 30];\n+/// assert_eq!(1..2, slice::range(1..2, ..v.len()));\n+/// assert_eq!(0..2, slice::range(..2, ..v.len()));\n+/// assert_eq!(1..3, slice::range(1.., ..v.len()));\n+/// ```\n+///\n+/// Panics when [`Index::index`] would panic:\n+///\n+/// ```should_panic\n+/// #![feature(slice_range)]\n+///\n+/// use std::slice;\n+///\n+/// slice::range(2..1, ..3);\n+/// ```\n+///\n+/// ```should_panic\n+/// #![feature(slice_range)]\n+///\n+/// use std::slice;\n+///\n+/// slice::range(1..4, ..3);\n+/// ```\n+///\n+/// ```should_panic\n+/// #![feature(slice_range)]\n+///\n+/// use std::slice;\n+///\n+/// slice::range(1..=usize::MAX, ..3);\n+/// ```\n+///\n+/// [`Index::index`]: ops::Index::index\n+#[track_caller]\n+#[unstable(feature = \"slice_range\", issue = \"76393\")]\n+pub fn range<R>(range: R, bounds: ops::RangeTo<usize>) -> ops::Range<usize>\n+where\n+    R: ops::RangeBounds<usize>,\n+{\n+    let len = bounds.end;\n+\n+    let start: ops::Bound<&usize> = range.start_bound();\n+    let start = match start {\n+        ops::Bound::Included(&start) => start,\n+        ops::Bound::Excluded(start) => {\n+            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+        }\n+        ops::Bound::Unbounded => 0,\n+    };\n+\n+    let end: ops::Bound<&usize> = range.end_bound();\n+    let end = match end {\n+        ops::Bound::Included(end) => {\n+            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+        }\n+        ops::Bound::Excluded(&end) => end,\n+        ops::Bound::Unbounded => len,\n+    };\n+\n+    if start > end {\n+        slice_index_order_fail(start, end);\n+    }\n+    if end > len {\n+        slice_end_index_len_fail(end, len);\n+    }\n+\n+    ops::Range { start, end }\n+}"}, {"sha": "8256d2cc6070e1541fa103ecfa5bec22cbf62b5f", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d519eaa6e9a583257b2f9e28a743ab85d1cabc5/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=5d519eaa6e9a583257b2f9e28a743ab85d1cabc5", "patch": "@@ -18,6 +18,7 @@ use crate::option::Option::{None, Some};\n use crate::ptr;\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n+use crate::slice;\n \n #[unstable(\n     feature = \"slice_internals\",\n@@ -29,7 +30,7 @@ pub mod memchr;\n \n mod ascii;\n mod cmp;\n-pub(crate) mod index;\n+mod index;\n mod iter;\n mod raw;\n mod rotate;\n@@ -76,6 +77,9 @@ pub use sort::heapsort;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use index::SliceIndex;\n \n+#[unstable(feature = \"slice_range\", issue = \"76393\")]\n+pub use index::range;\n+\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -3052,7 +3056,7 @@ impl<T> [T] {\n     where\n         T: Copy,\n     {\n-        let Range { start: src_start, end: src_end } = Range::ensure_subset_of(src, ..self.len());\n+        let Range { start: src_start, end: src_end } = slice::range(src, ..self.len());\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         // SAFETY: the conditions for `ptr::copy` have all been checked above,"}]}