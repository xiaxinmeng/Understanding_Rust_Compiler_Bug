{"sha": "e2bc383383b211c63e5edf136c47e6d4449c8a6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYmMzODMzODNiMjExYzYzZTVlZGYxMzZjNDdlNmQ0NDQ5YzhhNmY=", "commit": {"author": {"name": "HMPerson1", "email": "hmperson1@gmail.com", "date": "2017-12-01T00:38:29Z"}, "committer": {"name": "HMPerson1", "email": "hmperson1@gmail.com", "date": "2017-12-01T00:40:40Z"}, "message": "Add linting for empty blocks too", "tree": {"sha": "62b2e702e10daec772c3d4a8f1c103d10a70009a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62b2e702e10daec772c3d4a8f1c103d10a70009a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2bc383383b211c63e5edf136c47e6d4449c8a6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2bc383383b211c63e5edf136c47e6d4449c8a6f", "html_url": "https://github.com/rust-lang/rust/commit/e2bc383383b211c63e5edf136c47e6d4449c8a6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2bc383383b211c63e5edf136c47e6d4449c8a6f/comments", "author": {"login": "HMPerson1", "id": 2219904, "node_id": "MDQ6VXNlcjIyMTk5MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2219904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HMPerson1", "html_url": "https://github.com/HMPerson1", "followers_url": "https://api.github.com/users/HMPerson1/followers", "following_url": "https://api.github.com/users/HMPerson1/following{/other_user}", "gists_url": "https://api.github.com/users/HMPerson1/gists{/gist_id}", "starred_url": "https://api.github.com/users/HMPerson1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HMPerson1/subscriptions", "organizations_url": "https://api.github.com/users/HMPerson1/orgs", "repos_url": "https://api.github.com/users/HMPerson1/repos", "events_url": "https://api.github.com/users/HMPerson1/events{/privacy}", "received_events_url": "https://api.github.com/users/HMPerson1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HMPerson1", "id": 2219904, "node_id": "MDQ6VXNlcjIyMTk5MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2219904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HMPerson1", "html_url": "https://github.com/HMPerson1", "followers_url": "https://api.github.com/users/HMPerson1/followers", "following_url": "https://api.github.com/users/HMPerson1/following{/other_user}", "gists_url": "https://api.github.com/users/HMPerson1/gists{/gist_id}", "starred_url": "https://api.github.com/users/HMPerson1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HMPerson1/subscriptions", "organizations_url": "https://api.github.com/users/HMPerson1/orgs", "repos_url": "https://api.github.com/users/HMPerson1/repos", "events_url": "https://api.github.com/users/HMPerson1/events{/privacy}", "received_events_url": "https://api.github.com/users/HMPerson1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fca6eb89eebe00238c66bc57b1ab2ecf236dfdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fca6eb89eebe00238c66bc57b1ab2ecf236dfdd", "html_url": "https://github.com/rust-lang/rust/commit/5fca6eb89eebe00238c66bc57b1ab2ecf236dfdd"}], "stats": {"total": 113, "additions": 53, "deletions": 60}, "files": [{"sha": "90e2ef760f752171f5e38cb6dfb505463dd3a066", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "modified", "additions": 50, "deletions": 59, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e2bc383383b211c63e5edf136c47e6d4449c8a6f/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bc383383b211c63e5edf136c47e6d4449c8a6f/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=e2bc383383b211c63e5edf136c47e6d4449c8a6f", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use syntax::ast::*;\n use syntax::ext::quote::rt::Span;\n-use utils::span_note_and_lint;\n+use utils::{span_lint, span_note_and_lint};\n \n /// **What it does:** Checks for\n ///  - () being assigned to a variable\n@@ -24,6 +24,12 @@ declare_lint! {\n     \"unintended assignment or use of a unit typed value\"\n }\n \n+#[derive(Copy, Clone)]\n+enum UnitCause {\n+    SemiColon,\n+    EmptyBlock,\n+}\n+\n #[derive(Copy, Clone)]\n pub struct UnitExpr;\n \n@@ -36,43 +42,16 @@ impl LintPass for UnitExpr {\n impl EarlyLintPass for UnitExpr {\n     fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n         if let ExprKind::Assign(ref _left, ref right) = expr.node {\n-            if let Some(span) = is_unit_expr(right) {\n-                span_note_and_lint(\n-                    cx,\n-                    UNIT_EXPR,\n-                    expr.span,\n-                    \"This expression evaluates to the Unit type ()\",\n-                    span,\n-                    \"Consider removing the trailing semicolon\",\n-                );\n-            }\n+            check_for_unit(cx, right);\n         }\n         if let ExprKind::MethodCall(ref _left, ref args) = expr.node {\n             for arg in args {\n-                if let Some(span) = is_unit_expr(arg) {\n-                    span_note_and_lint(\n-                        cx,\n-                        UNIT_EXPR,\n-                        expr.span,\n-                        \"This expression evaluates to the Unit type ()\",\n-                        span,\n-                        \"Consider removing the trailing semicolon\",\n-                    );\n-                }\n+                check_for_unit(cx, arg);\n             }\n         }\n         if let ExprKind::Call(_, ref args) = expr.node {\n             for arg in args {\n-                if let Some(span) = is_unit_expr(arg) {\n-                    span_note_and_lint(\n-                        cx,\n-                        UNIT_EXPR,\n-                        expr.span,\n-                        \"This expression evaluates to the Unit type ()\",\n-                        span,\n-                        \"Consider removing the trailing semicolon\",\n-                    );\n-                }\n+                check_for_unit(cx, arg);\n             }\n         }\n     }\n@@ -83,28 +62,41 @@ impl EarlyLintPass for UnitExpr {\n                 return;\n             }\n             if let Some(ref expr) = local.init {\n-                if let Some(span) = is_unit_expr(expr) {\n-                    span_note_and_lint(\n-                        cx,\n-                        UNIT_EXPR,\n-                        expr.span,\n-                        \"This expression evaluates to the Unit type ()\",\n-                        span,\n-                        \"Consider removing the trailing semicolon\",\n-                    );\n-                }\n+                check_for_unit(cx, expr);\n             }\n         }\n     }\n }\n \n-fn is_unit_expr(expr: &Expr) -> Option<Span> {\n+fn check_for_unit(cx: &EarlyContext, expr: &Expr) {\n+    match is_unit_expr(expr) {\n+        Some((span, UnitCause::SemiColon)) => span_note_and_lint(\n+            cx,\n+            UNIT_EXPR,\n+            expr.span,\n+            \"This expression evaluates to the Unit type ()\",\n+            span,\n+            \"Consider removing the trailing semicolon\",\n+        ),\n+        Some((_span, UnitCause::EmptyBlock)) => span_lint(\n+            cx,\n+            UNIT_EXPR,\n+            expr.span,\n+            \"This expression evaluates to the Unit type ()\",\n+        ),\n+        None => (),\n+    }\n+}\n+\n+fn is_unit_expr(expr: &Expr) -> Option<(Span, UnitCause)> {\n     match expr.node {\n-        ExprKind::Block(ref block) => if check_last_stmt_in_block(block) {\n-            Some(block.stmts[block.stmts.len() - 1].span)\n-        } else {\n-            None\n-        },\n+        ExprKind::Block(ref block) => match check_last_stmt_in_block(block) {\n+            Some(UnitCause::SemiColon) =>\n+                Some((block.stmts[block.stmts.len() - 1].span, UnitCause::SemiColon)),\n+            Some(UnitCause::EmptyBlock) =>\n+                Some((block.span, UnitCause::EmptyBlock)),\n+            None => None\n+        }\n         ExprKind::If(_, ref then, ref else_) => {\n             let check_then = check_last_stmt_in_block(then);\n             if let Some(ref else_) = *else_ {\n@@ -113,16 +105,15 @@ fn is_unit_expr(expr: &Expr) -> Option<Span> {\n                     return Some(*expr_else);\n                 }\n             }\n-            if check_then {\n-                Some(expr.span)\n-            } else {\n-                None\n+            match check_then {\n+                Some(c) => Some((expr.span, c)),\n+                None => None,\n             }\n         },\n         ExprKind::Match(ref _pattern, ref arms) => {\n             for arm in arms {\n-                if let Some(expr) = is_unit_expr(&arm.body) {\n-                    return Some(expr);\n+                if let Some(r) = is_unit_expr(&arm.body) {\n+                    return Some(r);\n                 }\n             }\n             None\n@@ -131,19 +122,19 @@ fn is_unit_expr(expr: &Expr) -> Option<Span> {\n     }\n }\n \n-fn check_last_stmt_in_block(block: &Block) -> bool {\n-    if block.stmts.is_empty() { return false; }\n+fn check_last_stmt_in_block(block: &Block) -> Option<UnitCause> {\n+    if block.stmts.is_empty() { return Some(UnitCause::EmptyBlock); }\n     let final_stmt = &block.stmts[block.stmts.len() - 1];\n \n \n     // Made a choice here to risk false positives on divergent macro invocations\n     // like `panic!()`\n     match final_stmt.node {\n-        StmtKind::Expr(_) => false,\n+        StmtKind::Expr(_) => None,\n         StmtKind::Semi(ref expr) => match expr.node {\n-            ExprKind::Break(_, _) | ExprKind::Continue(_) | ExprKind::Ret(_) => false,\n-            _ => true,\n+            ExprKind::Break(_, _) | ExprKind::Continue(_) | ExprKind::Ret(_) => None,\n+            _ => Some(UnitCause::SemiColon),\n         },\n-        _ => true,\n+        _ => Some(UnitCause::SemiColon), // not sure what's happening here\n     }\n }"}, {"sha": "6c8f108d9f6e4089db623854e38a7c4515ca6115", "filename": "tests/ui/is_unit_expr.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2bc383383b211c63e5edf136c47e6d4449c8a6f/tests%2Fui%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bc383383b211c63e5edf136c47e6d4449c8a6f/tests%2Fui%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_unit_expr.rs?ref=e2bc383383b211c63e5edf136c47e6d4449c8a6f", "patch": "@@ -73,5 +73,7 @@ pub fn foo() -> i32 {\n }\n \n pub fn issue_2160() {\n-    let x = {};\n+    let x1 = {};\n+    let x2 = if true {} else {};\n+    let x3 = match None { Some(_) => {}, None => {}, };\n }"}]}