{"sha": "cb4f8153d8285ac2bf2145c569c09014f3ba317d", "node_id": "C_kwDOAAsO6NoAKGNiNGY4MTUzZDgyODVhYzJiZjIxNDVjNTY5YzA5MDE0ZjNiYTMxN2Q", "commit": {"author": {"name": "Charisee", "email": "chiw@google.com", "date": "2023-04-22T01:00:36Z"}, "committer": {"name": "Charisee", "email": "chiw@google.com", "date": "2023-04-22T01:00:36Z"}, "message": "Add GNU Property Note", "tree": {"sha": "04e8455e8c4f975ed5e4a012b57a812c12f86614", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04e8455e8c4f975ed5e4a012b57a812c12f86614"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb4f8153d8285ac2bf2145c569c09014f3ba317d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4f8153d8285ac2bf2145c569c09014f3ba317d", "html_url": "https://github.com/rust-lang/rust/commit/cb4f8153d8285ac2bf2145c569c09014f3ba317d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb4f8153d8285ac2bf2145c569c09014f3ba317d/comments", "author": null, "committer": null, "parents": [{"sha": "a41fc00eaf352541008965fec0dee811e44373b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a41fc00eaf352541008965fec0dee811e44373b3", "html_url": "https://github.com/rust-lang/rust/commit/a41fc00eaf352541008965fec0dee811e44373b3"}], "stats": {"total": 42, "additions": 42, "deletions": 0}, "files": [{"sha": "baf674cf9eba6fe1e03bc8557d0fc55ba78a7565", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cb4f8153d8285ac2bf2145c569c09014f3ba317d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4f8153d8285ac2bf2145c569c09014f3ba317d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=cb4f8153d8285ac2bf2145c569c09014f3ba317d", "patch": "@@ -12,6 +12,7 @@ use object::{\n \n use snap::write::FrameEncoder;\n \n+use object::elf::NT_GNU_PROPERTY_TYPE_0;\n use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::owned_slice::try_slice_owned;\n use rustc_data_structures::sync::MetadataRef;\n@@ -93,6 +94,46 @@ pub(super) fn search_for_section<'a>(\n         .map_err(|e| format!(\"failed to read {} section in '{}': {}\", section, path.display(), e))\n }\n \n+fn add_gnu_property_note(\n+    file: &mut write::Object<'static>,\n+    architecture: Architecture,\n+    binary_format: BinaryFormat,\n+) {\n+    // check bti protection\n+    if binary_format != BinaryFormat::Elf\n+        || !matches!(architecture, Architecture::X86_64 | Architecture::Aarch64)\n+    {\n+        return;\n+    }\n+\n+    let section = file.add_section(\n+        file.segment_name(StandardSegment::Data).to_vec(),\n+        b\".note.gnu.property\".to_vec(),\n+        SectionKind::Note,\n+    );\n+    let mut data: Vec<u8> = Vec::new();\n+    let n_namsz: u32 = 4; // Size of the n_name field\n+    let n_descsz: u32 = 16; // Size of the n_desc field\n+    let n_type: u32 = NT_GNU_PROPERTY_TYPE_0; // Type of note descriptor\n+    let values = [n_namsz, n_descsz, n_type];\n+    values.map(|v| data.extend_from_slice(&(v.to_le_bytes())));\n+    data.push(b'G'); // Owner of the program property note\n+    data.push(b'N');\n+    data.push(b'U');\n+    data.push(0);\n+    let pr_type: u32 = match architecture {\n+        Architecture::X86_64 => 0xc0000002,\n+        Architecture::Aarch64 => 0xc0000000,\n+        _ => unreachable!(),\n+    };\n+    let pr_datasz: u32 = 4; //size of the pr_data field\n+    let pr_data: u32 = 3; //program property descriptor\n+    let pr_padding: u32 = 3;\n+    let values = [pr_type, pr_datasz, pr_data, pr_padding];\n+    values.map(|v| data.extend_from_slice(&(v.to_le_bytes())));\n+    file.append_section_data(section, &data, 4);\n+}\n+\n pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     let endianness = match sess.target.options.endian {\n         Endian::Little => Endianness::Little,\n@@ -205,6 +246,7 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         _ => elf::ELFOSABI_NONE,\n     };\n     let abi_version = 0;\n+    add_gnu_property_note(&mut file, architecture, binary_format);\n     file.flags = FileFlags::Elf { os_abi, abi_version, e_flags };\n     Some(file)\n }"}]}