{"sha": "ded860c0e89e6f33dece7f65bb71419b515314eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlZDg2MGMwZTg5ZTZmMzNkZWNlN2Y2NWJiNzE0MTliNTE1MzE0ZWI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-14T00:26:41Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-05-15T01:29:13Z"}, "message": "libterm: Remove all uses of `~str` from `libterm`", "tree": {"sha": "0faf10cc076c3ead5da9ae4c1c252e2fd611e332", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0faf10cc076c3ead5da9ae4c1c252e2fd611e332"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ded860c0e89e6f33dece7f65bb71419b515314eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ded860c0e89e6f33dece7f65bb71419b515314eb", "html_url": "https://github.com/rust-lang/rust/commit/ded860c0e89e6f33dece7f65bb71419b515314eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ded860c0e89e6f33dece7f65bb71419b515314eb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/93499b1eaf74a58ff7de3ac9240afc4796ef57c8", "html_url": "https://github.com/rust-lang/rust/commit/93499b1eaf74a58ff7de3ac9240afc4796ef57c8"}], "stats": {"total": 213, "additions": 120, "deletions": 93}, "files": [{"sha": "2d1b938ec3781733a3a84756fe3a2618529f8407", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=ded860c0e89e6f33dece7f65bb71419b515314eb", "patch": "@@ -126,10 +126,12 @@ impl<T: Writer> Terminal<T> {\n     /// Returns `Err()` on failure to open the terminfo database correctly.\n     /// Also, in the event that the individual terminfo database entry can not\n     /// be parsed.\n-    pub fn new(out: T) -> Result<Terminal<T>, ~str> {\n+    pub fn new(out: T) -> Result<Terminal<T>, StrBuf> {\n         let term = match os::getenv(\"TERM\") {\n             Some(t) => t,\n-            None => return Err(\"TERM environment variable undefined\".to_owned())\n+            None => {\n+                return Err(\"TERM environment variable undefined\".to_strbuf())\n+            }\n         };\n \n         let mut file = match open(term) {\n@@ -251,7 +253,8 @@ impl<T: Writer> Terminal<T> {\n                 cap = self.ti.strings.find_equiv(&(\"op\"));\n             }\n         }\n-        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_owned()), |op| {\n+        let s = cap.map_or(Err(\"can't find terminfo capability \\\n+                                `sgr0`\".to_strbuf()), |op| {\n             expand(op.as_slice(), [], &mut Variables::new())\n         });\n         if s.is_ok() {"}, {"sha": "46dd397853157cb889a45dc097e2fc679713b561", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=ded860c0e89e6f33dece7f65bb71419b515314eb", "patch": "@@ -15,13 +15,13 @@ use collections::HashMap;\n /// A parsed terminfo database entry.\n pub struct TermInfo {\n     /// Names for the terminal\n-    pub names: Vec<~str> ,\n+    pub names: Vec<StrBuf> ,\n     /// Map of capability name to boolean value\n-    pub bools: HashMap<~str, bool>,\n+    pub bools: HashMap<StrBuf, bool>,\n     /// Map of capability name to numeric value\n-    pub numbers: HashMap<~str, u16>,\n+    pub numbers: HashMap<StrBuf, u16>,\n     /// Map of capability name to raw (unexpanded) string\n-    pub strings: HashMap<~str, Vec<u8> >\n+    pub strings: HashMap<StrBuf, Vec<u8> >\n }\n \n pub mod searcher;"}, {"sha": "ed94de8e81ddd2d7c3143af4ce8e503f0d72152e", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 68, "deletions": 59, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=ded860c0e89e6f33dece7f65bb71419b515314eb", "patch": "@@ -41,7 +41,7 @@ enum FormatState {\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub enum Param {\n-    String(~str),\n+    String(StrBuf),\n     Number(int)\n }\n \n@@ -89,7 +89,7 @@ impl Variables {\n   multiple capabilities for the same terminal.\n   */\n pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n-    -> Result<Vec<u8> , ~str> {\n+    -> Result<Vec<u8> , StrBuf> {\n     let mut state = Nothing;\n \n     // expanded cap will only rarely be larger than the cap itself\n@@ -124,9 +124,9 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n-                            _       => return Err(\"a non-char was used with %c\".to_owned())\n+                            _       => return Err(\"a non-char was used with %c\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'p' => state = PushParam,\n                     'P' => state = SetVar,\n                     'g' => state = GetVar,\n@@ -135,112 +135,112 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             String(s) => stack.push(Number(s.len() as int)),\n-                            _         => return Err(\"a non-str was used with %l\".to_owned())\n+                            _         => return Err(\"a non-str was used with %l\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '+' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n-                            _ => return Err(\"non-numbers on stack with +\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with +\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '-' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n-                            _ => return Err(\"non-numbers on stack with -\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with -\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '*' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n-                            _ => return Err(\"non-numbers on stack with *\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with *\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '/' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n-                            _ => return Err(\"non-numbers on stack with /\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with /\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'm' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n-                            _ => return Err(\"non-numbers on stack with %\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with %\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '&' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n-                            _ => return Err(\"non-numbers on stack with &\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with &\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '|' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n-                            _ => return Err(\"non-numbers on stack with |\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with |\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '^' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n-                            _ => return Err(\"non-numbers on stack with ^\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with ^\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '=' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with =\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with =\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '>' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with >\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with >\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '<' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n-                            _ => return Err(\"non-numbers on stack with <\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with <\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'A' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical and\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with logical and\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'O' => if stack.len() > 1 {\n                         match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n-                            _ => return Err(\"non-numbers on stack with logical or\".to_owned())\n+                            _ => return Err(\"non-numbers on stack with logical or\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '!' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n-                            _ => return Err(\"non-number on stack with logical not\".to_owned())\n+                            _ => return Err(\"non-number on stack with logical not\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     '~' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n-                            _         => return Err(\"non-number on stack with %~\".to_owned())\n+                            _         => return Err(\"non-number on stack with %~\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'i' => match (mparams[0].clone(), mparams[1].clone()) {\n                         (Number(x), Number(y)) => {\n                             mparams[0] = Number(x+1);\n                             mparams[1] = Number(y+1);\n                         },\n-                        (_, _) => return Err(\"first two params not numbers with %i\".to_owned())\n+                        (_, _) => return Err(\"first two params not numbers with %i\".to_strbuf())\n                     },\n \n                     // printf-style support for %doxXs\n@@ -249,7 +249,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice())\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     ':'|'#'|' '|'.'|'0'..'9' => {\n                         let mut flags = Flags::new();\n                         let mut fstate = FormatStateFlags;\n@@ -274,35 +274,39 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n                             _         => return Err(\"non-number on stack \\\n-                                                    with conditional\".to_owned())\n+                                                    with conditional\".to_strbuf())\n                         }\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     'e' => state = SeekIfEnd(0),\n                     ';' => (),\n \n-                    _ => return Err(format!(\"unrecognized format option {}\", cur))\n+                    _ => {\n+                        return Err(format_strbuf!(\"unrecognized format \\\n+                                                   option {}\",\n+                                                  cur))\n+                    }\n                 }\n             },\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match char::to_digit(cur, 10) {\n                     Some(d) => d - 1,\n-                    None => return Err(\"bad param number\".to_owned())\n+                    None => return Err(\"bad param number\".to_strbuf())\n                 }].clone());\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n                         vars.sta[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_owned()) }\n+                    } else { return Err(\"stack is empty\".to_strbuf()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n                         vars.dyn[idx as uint] = stack.pop().unwrap();\n-                    } else { return Err(\"stack is empty\".to_owned()) }\n+                    } else { return Err(\"stack is empty\".to_strbuf()) }\n                 } else {\n-                    return Err(\"bad variable name in %P\".to_owned());\n+                    return Err(\"bad variable name in %P\".to_strbuf());\n                 }\n             },\n             GetVar => {\n@@ -313,7 +317,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     let idx = (cur as u8) - ('a' as u8);\n                     stack.push(vars.dyn[idx as uint].clone());\n                 } else {\n-                    return Err(\"bad variable name in %g\".to_owned());\n+                    return Err(\"bad variable name in %g\".to_strbuf());\n                 }\n             },\n             CharConstant => {\n@@ -322,7 +326,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             CharClose => {\n                 if cur != '\\'' {\n-                    return Err(\"malformed character constant\".to_owned());\n+                    return Err(\"malformed character constant\".to_strbuf());\n                 }\n             },\n             IntConstant(i) => {\n@@ -335,7 +339,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         state = IntConstant(i*10 + (cur as int - '0' as int));\n                         old_state = Nothing;\n                     }\n-                    _ => return Err(\"bad int constant\".to_owned())\n+                    _ => return Err(\"bad int constant\".to_strbuf())\n                 }\n             }\n             FormatPattern(ref mut flags, ref mut fstate) => {\n@@ -346,7 +350,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap().as_slice());\n                         old_state = state; // will cause state to go to Nothing\n-                    } else { return Err(\"stack is empty\".to_owned()) },\n+                    } else { return Err(\"stack is empty\".to_strbuf()) },\n                     (FormatStateFlags,'#') => {\n                         flags.alternate = true;\n                     }\n@@ -369,7 +373,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     (FormatStateWidth,'0'..'9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as uint - '0' as uint);\n-                        if flags.width < old { return Err(\"format width overflow\".to_owned()) }\n+                        if flags.width < old { return Err(\"format width overflow\".to_strbuf()) }\n                     }\n                     (FormatStateWidth,'.') => {\n                         *fstate = FormatStatePrecision;\n@@ -378,10 +382,10 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as uint - '0' as uint);\n                         if flags.precision < old {\n-                            return Err(\"format precision overflow\".to_owned())\n+                            return Err(\"format precision overflow\".to_strbuf())\n                         }\n                     }\n-                    _ => return Err(\"invalid format specifier\".to_owned())\n+                    _ => return Err(\"invalid format specifier\".to_strbuf())\n                 }\n             }\n             SeekIfElse(level) => {\n@@ -479,7 +483,7 @@ impl FormatOp {\n     }\n }\n \n-fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,StrBuf> {\n     let mut s = match val {\n         Number(d) => {\n             let s = match (op, flags.sign) {\n@@ -488,7 +492,9 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n                 (FormatOctal, _)     => format!(\"{:o}\", d).into_bytes(),\n                 (FormatHex, _)       => format!(\"{:x}\", d).into_bytes(),\n                 (FormatHEX, _)       => format!(\"{:X}\", d).into_bytes(),\n-                (FormatString, _)    => return Err(\"non-number on stack with %s\".to_owned()),\n+                (FormatString, _)    => {\n+                    return Err(\"non-number on stack with %s\".to_strbuf())\n+                }\n             };\n             let mut s: Vec<u8> = s.move_iter().collect();\n             if flags.precision > s.len() {\n@@ -543,7 +549,8 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,~str> {\n                     s\n                 }\n                 _ => {\n-                    return Err(format!(\"non-string on stack with %{}\", op.to_char()))\n+                    return Err(format_strbuf!(\"non-string on stack with %{}\",\n+                                              op.to_char()))\n                 }\n             }\n         }\n@@ -600,7 +607,7 @@ mod test {\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" {\n-                String(\"foo\".to_owned())\n+                String(\"foo\".to_strbuf())\n             } else {\n                 Number(97)\n             };\n@@ -678,10 +685,12 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n-                          [String(\"foo\".to_owned()), String(\"foo\".to_owned()),\n-                           String(\"f\".to_owned()), String(\"foo\".to_owned())], vars),\n+                          [String(\"foo\".to_strbuf()),\n+                           String(\"foo\".to_strbuf()),\n+                           String(\"f\".to_strbuf()),\n+                           String(\"foo\".to_strbuf())], vars),\n                    Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_owned())], vars),\n+        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_strbuf())], vars),\n                    Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n \n         assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),"}, {"sha": "5a1c8ea02e2219920a53b4f5b49c7f2eb9466ad1", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=ded860c0e89e6f33dece7f65bb71419b515314eb", "patch": "@@ -160,9 +160,12 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader, longnames: bool)\n-             -> Result<Box<TermInfo>, ~str> {\n+             -> Result<Box<TermInfo>, StrBuf> {\n     macro_rules! try( ($e:expr) => (\n-        match $e { Ok(e) => e, Err(e) => return Err(format!(\"{}\", e)) }\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(format_strbuf!(\"{}\", e))\n+        }\n     ) )\n \n     let bnames;\n@@ -182,8 +185,10 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n     // Check magic number\n     let magic = try!(file.read_le_u16());\n     if magic != 0x011A {\n-        return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n-                           0x011A, magic as uint));\n+        return Err(format_strbuf!(\"invalid magic number: expected {:x} but \\\n+                                   found {:x}\",\n+                                  0x011A,\n+                                  magic as uint));\n     }\n \n     let names_bytes          = try!(file.read_le_i16()) as int;\n@@ -195,24 +200,30 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n     assert!(names_bytes          > 0);\n \n     if (bools_bytes as uint) > boolnames.len() {\n-        return Err(\"incompatible file: more booleans than expected\".to_owned());\n+        return Err(\"incompatible file: more booleans than \\\n+                    expected\".to_strbuf());\n     }\n \n     if (numbers_count as uint) > numnames.len() {\n-        return Err(\"incompatible file: more numbers than expected\".to_owned());\n+        return Err(\"incompatible file: more numbers than \\\n+                    expected\".to_strbuf());\n     }\n \n     if (string_offsets_count as uint) > stringnames.len() {\n-        return Err(\"incompatible file: more string offsets than expected\".to_owned());\n+        return Err(\"incompatible file: more string offsets than \\\n+                    expected\".to_strbuf());\n     }\n \n     // don't read NUL\n     let bytes = try!(file.read_exact(names_bytes as uint - 1));\n     let names_str = match str::from_utf8(bytes.as_slice()) {\n-        Some(s) => s.to_owned(), None => return Err(\"input not utf-8\".to_owned()),\n+        Some(s) => s.to_owned(),\n+        None => return Err(\"input not utf-8\".to_strbuf()),\n     };\n \n-    let term_names: Vec<~str> = names_str.split('|').map(|s| s.to_owned()).collect();\n+    let term_names: Vec<StrBuf> = names_str.split('|')\n+                                           .map(|s| s.to_strbuf())\n+                                           .collect();\n \n     try!(file.read_byte()); // consume NUL\n \n@@ -221,7 +232,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         for i in range(0, bools_bytes) {\n             let b = try!(file.read_byte());\n             if b == 1 {\n-                bools_map.insert(bnames[i as uint].to_owned(), true);\n+                bools_map.insert(bnames[i as uint].to_strbuf(), true);\n             }\n         }\n     }\n@@ -235,7 +246,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         for i in range(0, numbers_count) {\n             let n = try!(file.read_le_u16());\n             if n != 0xFFFF {\n-                numbers_map.insert(nnames[i as uint].to_owned(), n);\n+                numbers_map.insert(nnames[i as uint].to_strbuf(), n);\n             }\n         }\n     }\n@@ -251,7 +262,8 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n         let string_table = try!(file.read_exact(string_table_bytes as uint));\n \n         if string_table.len() != string_table_bytes as uint {\n-            return Err(\"error: hit EOF before end of string table\".to_owned());\n+            return Err(\"error: hit EOF before end of string \\\n+                        table\".to_strbuf());\n         }\n \n         for (i, v) in string_offsets.iter().enumerate() {\n@@ -269,7 +281,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n             if offset == 0xFFFE {\n                 // undocumented: FFFE indicates cap@, which means the capability is not present\n                 // unsure if the handling for this is correct\n-                string_map.insert(name.to_owned(), Vec::new());\n+                string_map.insert(name.to_strbuf(), Vec::new());\n                 continue;\n             }\n \n@@ -279,13 +291,14 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n-                    string_map.insert(name.to_owned(),\n+                    string_map.insert(name.to_strbuf(),\n                                       Vec::from_slice(\n                                           string_table.slice(offset as uint,\n                                           offset as uint + len)))\n                 },\n                 None => {\n-                    return Err(\"invalid file: missing NUL in string_table\".to_owned());\n+                    return Err(\"invalid file: missing NUL in \\\n+                                string_table\".to_strbuf());\n                 }\n             };\n         }\n@@ -303,12 +316,12 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n-    strings.insert(\"bold\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n-    strings.insert(\"setaf\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n-    strings.insert(\"setab\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n+    strings.insert(\"sgr0\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n+    strings.insert(\"bold\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n+    strings.insert(\"setaf\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n+    strings.insert(\"setab\".to_strbuf(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n     box TermInfo {\n-        names: vec!(\"cygwin\".to_owned()), // msys is a fork of an older cygwin version\n+        names: vec!(\"cygwin\".to_strbuf()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),\n         strings: strings"}, {"sha": "a7365102f96cadbfdc9246d005f9063352110cde", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ded860c0e89e6f33dece7f65bb71419b515314eb/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=ded860c0e89e6f33dece7f65bb71419b515314eb", "patch": "@@ -76,15 +76,17 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n }\n \n /// Return open file for `term`\n-pub fn open(term: &str) -> Result<File, ~str> {\n+pub fn open(term: &str) -> Result<File, StrBuf> {\n     match get_dbpath_for_term(term) {\n         Some(x) => {\n             match File::open(x) {\n                 Ok(file) => Ok(file),\n-                Err(e) => Err(format!(\"error opening file: {}\", e)),\n+                Err(e) => Err(format_strbuf!(\"error opening file: {}\", e)),\n             }\n         }\n-        None => Err(format!(\"could not find terminfo entry for {}\", term))\n+        None => {\n+            Err(format_strbuf!(\"could not find terminfo entry for {}\", term))\n+        }\n     }\n }\n \n@@ -95,14 +97,14 @@ fn test_get_dbpath_for_term() {\n     // note: current tests won't work with non-standard terminfo hierarchies (e.g. OS X's)\n     use std::os::{setenv, unsetenv};\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    fn x(t: &str) -> ~str {\n+    fn x(t: &str) -> StrBuf {\n         let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n-        p.as_str().unwrap().to_owned()\n+        p.as_str().unwrap().to_strbuf()\n     };\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_owned());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_strbuf());\n     assert!(get_dbpath_for_term(\"\") == None);\n     setenv(\"TERMINFO_DIRS\", \":\");\n-    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_owned());\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\".to_strbuf());\n     unsetenv(\"TERMINFO_DIRS\");\n }\n "}]}