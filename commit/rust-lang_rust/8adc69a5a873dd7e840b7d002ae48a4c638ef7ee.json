{"sha": "8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhZGM2OWE1YTg3M2RkN2U4NDBiN2QwMDJhZTQ4YTRjNjM4ZWY3ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-31T01:18:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-31T01:18:42Z"}, "message": "Auto merge of #53779 - RalfJung:miri-refactor, r=oli-obk\n\nMiri refactor: Final round\n\nTying up some loose ends that I noticed in the previous PRs -- and finally getting argument passing into a shape where @eddyb says it is \"okay\", which is a big improvement over the previous verdict that I cannot quote in public. ;)\n\nAlso move a bunch of useful helpers to construct `Scalar` from miri to here.\n\nCc @eddyb\nr? @oli-obk", "tree": {"sha": "69123d86afecc2acfee158771cbc769bf598939e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69123d86afecc2acfee158771cbc769bf598939e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "html_url": "https://github.com/rust-lang/rust/commit/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6047ea192c37d63a5c36a67112ce708e221c101", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6047ea192c37d63a5c36a67112ce708e221c101", "html_url": "https://github.com/rust-lang/rust/commit/c6047ea192c37d63a5c36a67112ce708e221c101"}, {"sha": "97d693a19a001a38f18cfd49a89ddfb8b7d3fa94", "url": "https://api.github.com/repos/rust-lang/rust/commits/97d693a19a001a38f18cfd49a89ddfb8b7d3fa94", "html_url": "https://github.com/rust-lang/rust/commit/97d693a19a001a38f18cfd49a89ddfb8b7d3fa94"}], "stats": {"total": 1151, "additions": 595, "deletions": 556}, "files": [{"sha": "6250e12f43043beac2ba90a37fb0e8d286733542", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -512,6 +512,7 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n         mem::discriminant(&self).hash_stable(hcx, hasher);\n \n         match *self {\n+            FunctionArgCountMismatch |\n             DanglingPointerDeref |\n             DoubleFree |\n             InvalidMemoryAccess |\n@@ -558,7 +559,11 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             },\n             ReferencedConstant(ref err) => err.hash_stable(hcx, hasher),\n             MachineError(ref err) => err.hash_stable(hcx, hasher),\n-            FunctionPointerTyMismatch(a, b) => {\n+            FunctionAbiMismatch(a, b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher)\n+            },\n+            FunctionArgMismatch(a, b) => {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher)\n             },"}, {"sha": "84d55c84ce154b8e23dd643c5f571ca3e53c55d3", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -11,9 +11,10 @@\n use std::{fmt, env};\n \n use mir;\n-use ty::{FnSig, Ty, layout};\n+use ty::{Ty, layout};\n use ty::layout::{Size, Align};\n use rustc_data_structures::sync::Lrc;\n+use rustc_target::spec::abi::Abi;\n \n use super::{\n     Pointer, Lock, AccessKind\n@@ -182,7 +183,10 @@ pub enum EvalErrorKind<'tcx, O> {\n     /// This variant is used by machines to signal their own errors that do not\n     /// match an existing variant\n     MachineError(String),\n-    FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n+\n+    FunctionAbiMismatch(Abi, Abi),\n+    FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n+    FunctionArgCountMismatch,\n     NoMirFor(String),\n     UnterminatedCString(Pointer),\n     DanglingPointerDeref,\n@@ -290,8 +294,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n         use self::EvalErrorKind::*;\n         match *self {\n             MachineError(ref inner) => inner,\n-            FunctionPointerTyMismatch(..) =>\n-                \"tried to call a function through a function pointer of a different type\",\n+            FunctionAbiMismatch(..) | FunctionArgMismatch(..) | FunctionArgCountMismatch =>\n+                \"tried to call a function through a function pointer of incompatible type\",\n             InvalidMemoryAccess =>\n                 \"tried to access memory through an invalid pointer\",\n             DanglingPointerDeref =>\n@@ -459,9 +463,15 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                 write!(f, \"type validation failed: {}\", err)\n             }\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            FunctionPointerTyMismatch(sig, got) =>\n-                write!(f, \"tried to call a function with sig {} through a \\\n-                       function pointer of type {}\", sig, got),\n+            FunctionAbiMismatch(caller_abi, callee_abi) =>\n+                write!(f, \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n+                    callee_abi, caller_abi),\n+            FunctionArgMismatch(caller_ty, callee_ty) =>\n+                write!(f, \"tried to call a function with argument of type {:?} \\\n+                           passing data of type {:?}\",\n+                    callee_ty, caller_ty),\n+            FunctionArgCountMismatch =>\n+                write!(f, \"tried to call a function with incorrect number of arguments\"),\n             BoundsCheck { ref len, ref index } =>\n                 write!(f, \"index out of bounds: the len is {:?} but the index is {:?}\", len, index),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>"}, {"sha": "d40dbae09d2cb60f8b27420e38b9453aeb39ec21", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -85,9 +85,14 @@ pub struct GlobalId<'tcx> {\n pub trait PointerArithmetic: layout::HasDataLayout {\n     // These are not supposed to be overridden.\n \n+    #[inline(always)]\n+    fn pointer_size(self) -> Size {\n+        self.data_layout().pointer_size\n+    }\n+\n     //// Trunace the given value to the pointer size; also return whether there was an overflow\n     fn truncate_to_ptr(self, val: u128) -> (u64, bool) {\n-        let max_ptr_plus_1 = 1u128 << self.data_layout().pointer_size.bits();\n+        let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n         ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n     }\n \n@@ -491,7 +496,9 @@ pub struct Allocation {\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n     /// Maps from byte addresses to allocations.\n-    /// Only the first byte of a pointer is inserted into the map.\n+    /// Only the first byte of a pointer is inserted into the map; i.e.,\n+    /// every entry in this map applies to `pointer_size` consecutive bytes starting\n+    /// at the given offset.\n     pub relocations: Relocations,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,"}, {"sha": "11a4f8b884e7f1b46d3fa910e801f3e807563053", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -14,7 +14,7 @@ use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n use hir::def_id::DefId;\n \n-use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend};\n+use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n@@ -58,6 +58,7 @@ impl<'tcx> ConstValue<'tcx> {\n         self.try_to_scalar()?.to_ptr().ok()\n     }\n \n+    #[inline]\n     pub fn new_slice(\n         val: Scalar,\n         len: u64,\n@@ -69,23 +70,27 @@ impl<'tcx> ConstValue<'tcx> {\n         }.into())\n     }\n \n+    #[inline]\n     pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n         ConstValue::ScalarPair(val, Scalar::Ptr(vtable).into())\n     }\n }\n \n impl<'tcx> Scalar {\n+    #[inline]\n     pub fn ptr_null(cx: impl HasDataLayout) -> Self {\n         Scalar::Bits {\n             bits: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n+    #[inline]\n     pub fn zst() -> Self {\n         Scalar::Bits { bits: 0, size: 0 }\n     }\n \n+    #[inline]\n     pub fn ptr_signed_offset(self, i: i64, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n@@ -100,6 +105,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn ptr_offset(self, i: Size, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n@@ -114,6 +120,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: impl HasDataLayout) -> Self {\n         let layout = cx.data_layout();\n         match self {\n@@ -128,6 +135,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn is_null_ptr(self, cx: impl HasDataLayout) -> bool {\n         match self {\n             Scalar::Bits { bits, size } =>  {\n@@ -138,14 +146,53 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n+    pub fn is_null(self) -> bool {\n+        match self {\n+            Scalar::Bits { bits, .. } => bits == 0,\n+            Scalar::Ptr(_) => false\n+        }\n+    }\n+\n+    #[inline]\n     pub fn from_bool(b: bool) -> Self {\n         Scalar::Bits { bits: b as u128, size: 1 }\n     }\n \n+    #[inline]\n     pub fn from_char(c: char) -> Self {\n         Scalar::Bits { bits: c as u128, size: 4 }\n     }\n \n+    #[inline]\n+    pub fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n+        let i = i.into();\n+        debug_assert_eq!(truncate(i, size), i,\n+                    \"Unsigned value {} does not fit in {} bits\", i, size.bits());\n+        Scalar::Bits { bits: i, size: size.bytes() as u8 }\n+    }\n+\n+    #[inline]\n+    pub fn from_int(i: impl Into<i128>, size: Size) -> Self {\n+        let i = i.into();\n+        // `into` performed sign extension, we have to truncate\n+        let truncated = truncate(i as u128, size);\n+        debug_assert_eq!(sign_extend(truncated, size) as i128, i,\n+                    \"Signed value {} does not fit in {} bits\", i, size.bits());\n+        Scalar::Bits { bits: truncated, size: size.bytes() as u8 }\n+    }\n+\n+    #[inline]\n+    pub fn from_f32(f: f32) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n+    }\n+\n+    #[inline]\n+    pub fn from_f64(f: f64) -> Self {\n+        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n+    }\n+\n+    #[inline]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -157,6 +204,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n             Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n@@ -165,13 +213,15 @@ impl<'tcx> Scalar {\n         }\n     }\n \n+    #[inline]\n     pub fn is_bits(self) -> bool {\n         match self {\n             Scalar::Bits { .. } => true,\n             _ => false,\n         }\n     }\n \n+    #[inline]\n     pub fn is_ptr(self) -> bool {\n         match self {\n             Scalar::Ptr(_) => true,\n@@ -209,6 +259,13 @@ impl<'tcx> Scalar {\n         Ok(b as u32)\n     }\n \n+    pub fn to_u64(self) -> EvalResult<'static, u64> {\n+        let sz = Size::from_bits(64);\n+        let b = self.to_bits(sz)?;\n+        assert_eq!(b as u64 as u128, b);\n+        Ok(b as u64)\n+    }\n+\n     pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         assert_eq!(b as u64 as u128, b);\n@@ -231,12 +288,30 @@ impl<'tcx> Scalar {\n         Ok(b as i32)\n     }\n \n+    pub fn to_i64(self) -> EvalResult<'static, i64> {\n+        let sz = Size::from_bits(64);\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n+        assert_eq!(b as i64 as i128, b);\n+        Ok(b as i64)\n+    }\n+\n     pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n         assert_eq!(b as i64 as i128, b);\n         Ok(b as i64)\n     }\n+\n+    #[inline]\n+    pub fn to_f32(self) -> EvalResult<'static, f32> {\n+        Ok(f32::from_bits(self.to_u32()?))\n+    }\n+\n+    #[inline]\n+    pub fn to_f64(self) -> EvalResult<'static, f64> {\n+        Ok(f64::from_bits(self.to_u64()?))\n+    }\n }\n \n impl From<Pointer> for Scalar {\n@@ -308,6 +383,16 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_char()\n     }\n \n+    #[inline(always)]\n+    pub fn to_f32(self) -> EvalResult<'tcx, f32> {\n+        self.not_undef()?.to_f32()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_f64(self) -> EvalResult<'tcx, f64> {\n+        self.not_undef()?.to_f64()\n+    }\n+\n     #[inline(always)]\n     pub fn to_u8(self) -> EvalResult<'tcx, u8> {\n         self.not_undef()?.to_u8()\n@@ -318,6 +403,11 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_u32()\n     }\n \n+    #[inline(always)]\n+    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n+        self.not_undef()?.to_u64()\n+    }\n+\n     #[inline(always)]\n     pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n         self.not_undef()?.to_usize(cx)\n@@ -333,6 +423,11 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_i32()\n     }\n \n+    #[inline(always)]\n+    pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n+        self.not_undef()?.to_i64()\n+    }\n+\n     #[inline(always)]\n     pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, i64> {\n         self.not_undef()?.to_isize(cx)"}, {"sha": "60b85e8a8eb9aad5c4eed9938a5caeabb07009f6", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -487,10 +487,12 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n         use ::mir::interpret::EvalErrorKind::*;\n         Some(match *self {\n             MachineError(ref err) => MachineError(err.clone()),\n-            FunctionPointerTyMismatch(a, b) => FunctionPointerTyMismatch(\n+            FunctionAbiMismatch(a, b) => FunctionAbiMismatch(a, b),\n+            FunctionArgMismatch(a, b) => FunctionArgMismatch(\n                 tcx.lift(&a)?,\n                 tcx.lift(&b)?,\n             ),\n+            FunctionArgCountMismatch => FunctionArgCountMismatch,\n             NoMirFor(ref s) => NoMirFor(s.clone()),\n             UnterminatedCString(ptr) => UnterminatedCString(ptr),\n             DanglingPointerDeref => DanglingPointerDeref,"}, {"sha": "70addf2c907e65ebeabff542e3a6c7b1735b013c", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -288,21 +288,17 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         )\n     }\n \n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n-        left: Scalar,\n+        _left: Scalar,\n         _left_layout: TyLayout<'tcx>,\n-        right: Scalar,\n+        _right: Scalar,\n         _right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n-        if left.is_bits() && right.is_bits() {\n-            Ok(None)\n-        } else {\n-            Err(\n-                ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n-            )\n-        }\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        Err(\n+            ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n+        )\n     }\n \n     fn find_foreign_static<'a>("}, {"sha": "83264acf76a31809d7d4047713c592be56c72700", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 42, "deletions": 64, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -14,8 +14,7 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind,\n-    truncate, sign_extend\n+    Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind, truncate\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -49,13 +48,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Misc => {\n                 let src = self.read_value(src)?;\n                 if self.type_is_fat_ptr(src_layout.ty) {\n-                    match (src.value, self.type_is_fat_ptr(dest.layout.ty)) {\n+                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Value::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Value::ScalarPair(..), true) => {\n                             // No change to value\n-                            self.write_value(src.value, dest)?;\n+                            self.write_value(*src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Value::ScalarPair(data, _), false) => {\n@@ -70,10 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n                                 return self.write_scalar(\n-                                    Scalar::Bits {\n-                                        bits: discr_val,\n-                                        size: dst_layout.size.bytes() as u8,\n-                                    },\n+                                    Scalar::from_uint(discr_val, dst_layout.size),\n                                     dest);\n                             }\n                         }\n@@ -198,41 +194,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_layout.ty.sty {\n             Int(_) | Uint(_) => {\n                 let v = self.truncate(v, dest_layout);\n-                Ok(Scalar::Bits {\n-                    bits: v,\n-                    size: dest_layout.size.bytes() as u8,\n-                })\n+                Ok(Scalar::from_uint(v, dest_layout.size))\n             }\n \n-            Float(FloatTy::F32) if signed => Ok(Scalar::Bits {\n-                bits: Single::from_i128(v as i128).value.to_bits(),\n-                size: 4,\n-            }),\n-            Float(FloatTy::F64) if signed => Ok(Scalar::Bits {\n-                bits: Double::from_i128(v as i128).value.to_bits(),\n-                size: 8,\n-            }),\n-            Float(FloatTy::F32) => Ok(Scalar::Bits {\n-                bits: Single::from_u128(v).value.to_bits(),\n-                size: 4,\n-            }),\n-            Float(FloatTy::F64) => Ok(Scalar::Bits {\n-                bits: Double::from_u128(v).value.to_bits(),\n-                size: 8,\n-            }),\n+            Float(FloatTy::F32) if signed => Ok(Scalar::from_uint(\n+                Single::from_i128(v as i128).value.to_bits(),\n+                Size::from_bits(32)\n+            )),\n+            Float(FloatTy::F64) if signed => Ok(Scalar::from_uint(\n+                Double::from_i128(v as i128).value.to_bits(),\n+                Size::from_bits(64)\n+            )),\n+            Float(FloatTy::F32) => Ok(Scalar::from_uint(\n+                Single::from_u128(v).value.to_bits(),\n+                Size::from_bits(32)\n+            )),\n+            Float(FloatTy::F64) => Ok(Scalar::from_uint(\n+                Double::from_u128(v).value.to_bits(),\n+                Size::from_bits(64)\n+            )),\n \n             Char => {\n-                assert_eq!(v as u8 as u128, v);\n-                Ok(Scalar::Bits { bits: v, size: 4 })\n+                // `u8` to `char` cast\n+                debug_assert_eq!(v as u8 as u128, v);\n+                Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n             },\n \n             // No alignment check needed for raw pointers.\n             // But we have to truncate to target ptr size.\n             RawPtr(_) => {\n-                Ok(Scalar::Bits {\n-                    bits: self.memory.truncate_to_ptr(v).0 as u128,\n-                    size: self.memory.pointer_size().bytes() as u8,\n-                })\n+                Ok(Scalar::from_uint(\n+                    self.truncate_to_ptr(v).0,\n+                    self.pointer_size(),\n+                ))\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n@@ -251,56 +245,40 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         match dest_ty.sty {\n             // float -> uint\n             Uint(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.pointer_size().bits() as usize);\n                 let v = match fty {\n                     FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n                     FloatTy::F64 => Double::from_bits(bits).to_u128(width).value,\n                 };\n                 // This should already fit the bit width\n-                Ok(Scalar::Bits {\n-                    bits: v,\n-                    size: (width / 8) as u8,\n-                })\n+                Ok(Scalar::from_uint(v, Size::from_bits(width as u64)))\n             },\n             // float -> int\n             Int(t) => {\n-                let width = t.bit_width().unwrap_or(self.memory.pointer_size().bits() as usize);\n+                let width = t.bit_width().unwrap_or(self.pointer_size().bits() as usize);\n                 let v = match fty {\n                     FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n                     FloatTy::F64 => Double::from_bits(bits).to_i128(width).value,\n                 };\n-                // We got an i128, but we may need something smaller. We have to truncate ourselves.\n-                let truncated = truncate(v as u128, Size::from_bits(width as u64));\n-                assert_eq!(sign_extend(truncated, Size::from_bits(width as u64)) as i128, v,\n-                    \"truncating and extending changed the value?!?\");\n-                Ok(Scalar::Bits {\n-                    bits: truncated,\n-                    size: (width / 8) as u8,\n-                })\n+                Ok(Scalar::from_int(v, Size::from_bits(width as u64)))\n             },\n             // f64 -> f32\n             Float(FloatTy::F32) if fty == FloatTy::F64 => {\n-                Ok(Scalar::Bits {\n-                    bits: Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n-                    size: 4,\n-                })\n+                Ok(Scalar::from_uint(\n+                    Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n+                    Size::from_bits(32),\n+                ))\n             },\n             // f32 -> f64\n             Float(FloatTy::F64) if fty == FloatTy::F32 => {\n-                Ok(Scalar::Bits {\n-                    bits: Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n-                    size: 8,\n-                })\n+                Ok(Scalar::from_uint(\n+                    Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n+                    Size::from_bits(64),\n+                ))\n             },\n             // identity cast\n-            Float(FloatTy:: F64) => Ok(Scalar::Bits {\n-                bits,\n-                size: 8,\n-            }),\n-            Float(FloatTy:: F32) => Ok(Scalar::Bits {\n-                bits,\n-                size: 4,\n-            }),\n+            Float(FloatTy:: F64) => Ok(Scalar::from_uint(bits, Size::from_bits(64))),\n+            Float(FloatTy:: F32) => Ok(Scalar::from_uint(bits, Size::from_bits(32))),\n             _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n         }\n     }"}, {"sha": "6e144ba7ed2ee7627e74d0b9fd87f5518127f916", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -270,7 +270,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'\n }\n \n impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout"}, {"sha": "e8fd43afa1c7adb6e8470b9d668182ce8b30c023", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -41,7 +41,7 @@ fn numeric_intrinsic<'tcx>(\n         \"bswap\" => (bits << extra).swap_bytes(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n-    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n+    Ok(Scalar::from_uint(bits_out, size))\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -59,30 +59,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.layout_of(elem_ty)?.align.abi();\n-                let align_val = Scalar::Bits {\n-                    bits: elem_align as u128,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n+                let align_val = Scalar::from_uint(elem_align, dest.layout.size);\n                 self.write_scalar(align_val, dest)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = self.layout_of(ty)?.size.bytes() as u128;\n-                let size_val = Scalar::Bits {\n-                    bits: size,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n+                let size_val = Scalar::from_uint(size, dest.layout.size);\n                 self.write_scalar(size_val, dest)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = self.tcx.type_id_hash(ty) as u128;\n-                let id_val = Scalar::Bits {\n-                    bits: type_id,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n+                let id_val = Scalar::from_uint(type_id, dest.layout.size);\n                 self.write_scalar(id_val, dest)?;\n             }\n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {"}, {"sha": "57af63d63d9c47d074d9572b4c642b588c97345d", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -69,20 +69,18 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         def_id: DefId,\n     ) -> EvalResult<'tcx, &'tcx Allocation>;\n \n-    /// Called for all binary operations except on float types.\n-    ///\n-    /// Returns `None` if the operation should be handled by the integer\n-    /// op code in order to share more code between machines\n+    /// Called for all binary operations on integer(-like) types when one operand is a pointer\n+    /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n-    fn try_ptr_op<'a>(\n+    fn ptr_op<'a>(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n         left_layout: TyLayout<'tcx>,\n         right: Scalar,\n         right_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n+    ) -> EvalResult<'tcx, (Scalar, bool)>;\n \n     /// Heap allocations via the `box` keyword\n     ///"}, {"sha": "91fc6453446a89dc5ab566289ce42ca9c0e7e098", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 146, "deletions": 124, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -23,7 +23,8 @@ use std::ptr;\n use rustc::ty::{self, Instance, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n use rustc::mir::interpret::{Pointer, AllocId, Allocation, ScalarMaybeUndef, GlobalId,\n-                            EvalResult, Scalar, EvalErrorKind, AllocType, truncate};\n+                            EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+                            truncate};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n@@ -60,6 +61,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a Memory<'a, 'm\n         &self.tcx.data_layout\n     }\n }\n+impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+    for &'b &'c mut Memory<'a, 'mir, 'tcx, M>\n+{\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n \n impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n@@ -113,45 +122,6 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n     }\n }\n \n-/// Helper function to obtain the global (tcx) allocation for a static\n-fn const_eval_static<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n-    tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n-    id: AllocId\n-) -> EvalResult<'tcx, &'tcx Allocation> {\n-    let alloc = tcx.alloc_map.lock().get(id);\n-    let def_id = match alloc {\n-        Some(AllocType::Memory(mem)) => {\n-            return Ok(mem)\n-        }\n-        Some(AllocType::Function(..)) => {\n-            return err!(DerefFunctionPointer)\n-        }\n-        Some(AllocType::Static(did)) => {\n-            did\n-        }\n-        None =>\n-            return err!(DanglingPointerDeref),\n-    };\n-    // We got a \"lazy\" static that has not been computed yet, do some work\n-    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n-    if tcx.is_foreign_item(def_id) {\n-        return M::find_foreign_static(tcx, def_id);\n-    }\n-    let instance = Instance::mono(tcx.tcx, def_id);\n-    let gid = GlobalId {\n-        instance,\n-        promoted: None,\n-    };\n-    tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-        // no need to report anything, the const_eval call takes care of that for statics\n-        assert!(tcx.is_static(def_id).is_some());\n-        EvalErrorKind::ReferencedConstant(err).into()\n-    }).map(|val| {\n-        // FIXME We got our static (will be a ByRef), now we make a *copy*?!?\n-        tcx.const_to_allocation(val)\n-    })\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n@@ -277,14 +247,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn pointer_size(&self) -> Size {\n-        self.tcx.data_layout.pointer_size\n-    }\n-\n-    pub fn endianness(&self) -> layout::Endian {\n-        self.tcx.data_layout.endian\n-    }\n-\n     /// Check that the pointer is aligned AND non-NULL. This supports scalars\n     /// for the benefit of other parts of miri that need to check alignment even for ZST.\n     pub fn check_align(&self, ptr: Scalar, required_align: Align) -> EvalResult<'tcx> {\n@@ -296,13 +258,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n-                // FIXME: what on earth does this line do? docs or fix needed!\n-                let v = ((bits as u128) % (1 << self.pointer_size().bytes())) as u64;\n-                if v == 0 {\n+                assert!(bits < (1u128 << self.pointer_size().bits()));\n+                if bits == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n-                // the base address if the \"integer allocation\" is 0 and hence always aligned\n-                (v, required_align)\n+                // the \"base address\" is 0 and hence always aligned\n+                (bits as u64, required_align)\n             }\n         };\n         // Check alignment\n@@ -325,7 +286,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n     /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n-    /// in-bounds!  This follows C's/LLVM's rules.\n+    /// in-bounds!  This follows C's/LLVM's rules.  The `access` boolean is just used\n+    /// for the error message.\n+    /// If you want to check bounds before doing a memory access, be sure to\n+    /// check the pointer one past the end of your access, then everything will\n+    /// work out exactly.\n     pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n@@ -342,13 +307,52 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    /// Helper function to obtain the global (tcx) allocation for a static\n+    fn get_static_alloc(\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        id: AllocId,\n+    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+        let alloc = tcx.alloc_map.lock().get(id);\n+        let def_id = match alloc {\n+            Some(AllocType::Memory(mem)) => {\n+                return Ok(mem)\n+            }\n+            Some(AllocType::Function(..)) => {\n+                return err!(DerefFunctionPointer)\n+            }\n+            Some(AllocType::Static(did)) => {\n+                did\n+            }\n+            None =>\n+                return err!(DanglingPointerDeref),\n+        };\n+        // We got a \"lazy\" static that has not been computed yet, do some work\n+        trace!(\"static_alloc: Need to compute {:?}\", def_id);\n+        if tcx.is_foreign_item(def_id) {\n+            return M::find_foreign_static(tcx, def_id);\n+        }\n+        let instance = Instance::mono(tcx.tcx, def_id);\n+        let gid = GlobalId {\n+            instance,\n+            promoted: None,\n+        };\n+        tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+            // no need to report anything, the const_eval call takes care of that for statics\n+            assert!(tcx.is_static(def_id).is_some());\n+            EvalErrorKind::ReferencedConstant(err).into()\n+        }).map(|val| {\n+            // FIXME We got our static (will be a ByRef), now we make a *copy*?!?\n+            tcx.const_to_allocation(val)\n+        })\n+    }\n+\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         match self.alloc_map.get(&id) {\n             // Normal alloc?\n             Some(alloc) => Ok(&alloc.1),\n             // Static. No need to make any copies, just provide read access to the global static\n             // memory in tcx.\n-            None => const_eval_static::<M>(self.tcx, id),\n+            None => Self::get_static_alloc(self.tcx, id),\n         }\n     }\n \n@@ -380,7 +384,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n-        debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n+        trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n         match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n             Some(AllocType::Function(instance)) => Ok(instance),\n             _ => Err(EvalErrorKind::ExecuteMemory.into()),\n@@ -497,70 +501,75 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Byte accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// This checks alignment!\n-    fn get_bytes_unchecked(\n+    /// The last argument controls whether we error out when there are undefined\n+    /// or pointer bytes.  You should never call this, call `get_bytes` or\n+    /// `get_bytes_with_undef_and_ptr` instead,\n+    fn get_bytes_internal(\n         &self,\n         ptr: Pointer,\n         size: Size,\n         align: Align,\n+        check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]> {\n-        // Zero-sized accesses can use dangling pointers,\n-        // but they still have to be aligned and non-NULL\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        if size.bytes() == 0 {\n-            return Ok(&[]);\n-        }\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, self)?, true)?;\n+        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n+\n+        if check_defined_and_ptr {\n+            self.check_defined(ptr, size)?;\n+            self.check_relocations(ptr, size)?;\n+        } else {\n+            // We still don't want relocations on the *edges*\n+            self.check_relocation_edges(ptr, size)?;\n+        }\n+\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n         Ok(&alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n \n-    /// This checks alignment!\n-    fn get_bytes_unchecked_mut(\n+    #[inline]\n+    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(ptr, size, align, true)\n+    }\n+\n+    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// However, this still checks that there are no relocations on the egdes.\n+    #[inline]\n+    fn get_bytes_with_undef_and_ptr(\n+        &self,\n+        ptr: Pointer,\n+        size: Size,\n+        align: Align\n+    ) -> EvalResult<'tcx, &[u8]> {\n+        self.get_bytes_internal(ptr, size, align, false)\n+    }\n+\n+    /// Just calling this already marks everything as defined and removes relocations,\n+    /// so be sure to actually put data there!\n+    fn get_bytes_mut(\n         &mut self,\n         ptr: Pointer,\n         size: Size,\n         align: Align,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n-        // Zero-sized accesses can use dangling pointers,\n-        // but they still have to be aligned and non-NULL\n+        assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_align(ptr.into(), align)?;\n-        if size.bytes() == 0 {\n-            return Ok(&mut []);\n-        }\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n-        self.check_bounds(ptr.offset(size, &*self)?, true)?;\n+        self.check_bounds(ptr.offset(size, &self)?, true)?;\n+\n+        self.mark_definedness(ptr, size, true)?;\n+        self.clear_relocations(ptr, size)?;\n+\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n         Ok(&mut alloc.bytes[offset..offset + size.bytes() as usize])\n     }\n-\n-    fn get_bytes(&self, ptr: Pointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n-        assert_ne!(size.bytes(), 0);\n-        if self.relocations(ptr, size)?.len() != 0 {\n-            return err!(ReadPointerAsBytes);\n-        }\n-        self.check_defined(ptr, size)?;\n-        self.get_bytes_unchecked(ptr, size, align)\n-    }\n-\n-    fn get_bytes_mut(\n-        &mut self,\n-        ptr: Pointer,\n-        size: Size,\n-        align: Align,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n-        assert_ne!(size.bytes(), 0);\n-        self.clear_relocations(ptr, size)?;\n-        self.mark_definedness(ptr, size, true)?;\n-        self.get_bytes_unchecked_mut(ptr, size, align)\n-    }\n }\n \n /// Reading and writing\n@@ -609,7 +618,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         id: AllocId,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n-        let alloc = const_eval_static::<M>(self.tcx, id)?;\n+        let alloc = Self::get_static_alloc(self.tcx, id)?;\n         if alloc.mutability == Mutability::Immutable {\n             return err!(ModifiedConstantMemory);\n         }\n@@ -648,11 +657,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n         let src = src.to_ptr()?;\n         let dest = dest.to_ptr()?;\n-        self.check_relocation_edges(src, size)?;\n \n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n+        // (`get_bytes_with_undef_and_ptr` below checks that there are no\n+        // relocations overlapping the edges; those would not be handled correctly).\n         let relocations = {\n             let relocations = self.relocations(src, size)?;\n             let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n@@ -670,8 +680,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_relocations\n         };\n \n-        // This also checks alignment.\n-        let src_bytes = self.get_bytes_unchecked(src, size, src_align)?.as_ptr();\n+        // This also checks alignment, and relocation edges on the src.\n+        let src_bytes = self.get_bytes_with_undef_and_ptr(src, size, src_align)?.as_ptr();\n         let dest_bytes = self.get_bytes_mut(dest, size * length, dest_align)?.as_mut_ptr();\n \n         // SAFE: The above indexing would have panicked if there weren't at least `size` bytes\n@@ -704,8 +714,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n+        // copy definedness to the destination\n         self.copy_undef_mask(src, dest, size, length)?;\n-        // copy back the relocations\n+        // copy the relocations to the destination\n         self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n \n         Ok(())\n@@ -718,9 +729,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 let p1 = Size::from_bytes((size + 1) as u64);\n-                if self.relocations(ptr, p1)?.len() != 0 {\n-                    return err!(ReadPointerAsBytes);\n-                }\n+                self.check_relocations(ptr, p1)?;\n                 self.check_defined(ptr, p1)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n@@ -771,11 +780,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         ptr_align: Align,\n         size: Size\n     ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n-        // Make sure we don't read part of a pointer as a pointer\n-        self.check_relocation_edges(ptr, size)?;\n-        let endianness = self.endianness();\n-        // get_bytes_unchecked tests alignment\n-        let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n+        // get_bytes_unchecked tests alignment and relocation edges\n+        let bytes = self.get_bytes_with_undef_and_ptr(\n+            ptr, size, ptr_align.min(self.int_align(size))\n+        )?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n         if !self.is_defined(ptr, size)? {\n@@ -784,12 +792,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n-        let bits = read_target_uint(endianness, bytes).unwrap();\n+        let bits = read_target_uint(self.tcx.data_layout.endian, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n-            if self.relocations(ptr, size)?.len() != 0 {\n-                return err!(ReadPointerAsBytes);\n-            }\n+            // *Now* better make sure that the inside also is free of relocations.\n+            self.check_relocations(ptr, size)?;\n         } else {\n             let alloc = self.get(ptr.alloc_id)?;\n             match alloc.relocations.get(&ptr.offset) {\n@@ -801,10 +808,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n         // We don't. Just return the bits.\n-        Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-            bits,\n-            size: size.bytes() as u8,\n-        }))\n+        Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n     pub fn read_ptr_sized(&self, ptr: Pointer, ptr_align: Align)\n@@ -820,8 +824,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         val: ScalarMaybeUndef,\n         type_size: Size,\n     ) -> EvalResult<'tcx> {\n-        let endianness = self.endianness();\n-\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n@@ -835,16 +837,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n             Scalar::Bits { bits, size } => {\n                 assert_eq!(size as u64, type_size.bytes());\n-                assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n                     \"Unexpected value of size {} when writing to memory\", size);\n                 bits\n             },\n         };\n \n         {\n             // get_bytes_mut checks alignment\n+            let endian = self.tcx.data_layout.endian;\n             let dst = self.get_bytes_mut(ptr, type_size, ptr_align)?;\n-            write_target_uint(endianness, dst, bytes).unwrap();\n+            write_target_uint(endian, dst, bytes).unwrap();\n         }\n \n         // See if we have to also write a relocation\n@@ -884,16 +887,35 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Relocations\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+    /// Return all relocations overlapping with the given ptr-offset pair.\n     fn relocations(\n         &self,\n         ptr: Pointer,\n         size: Size,\n     ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n+        // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n+        // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n-        let end = ptr.offset + size;\n+        let end = ptr.offset + size; // this does overflow checking\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n+    /// Check that there ar eno relocations overlapping with the given range.\n+    #[inline(always)]\n+    fn check_relocations(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+        if self.relocations(ptr, size)?.len() != 0 {\n+            err!(ReadPointerAsBytes)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    /// Remove all relocations inside the given range.\n+    /// If there are relocations overlapping with the edges, they\n+    /// are removed as well *and* the bytes they cover are marked as\n+    /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n+    /// but it allows strictly more code to run than if we would just error\n+    /// immediately in that case.\n     fn clear_relocations(&mut self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n@@ -926,12 +948,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n+    /// Error if there are relocations overlapping with the egdes of the\n+    /// given memory range.\n+    #[inline]\n     fn check_relocation_edges(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, Size::ZERO)?.len();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::ZERO)?.len();\n-        if overlapping_start + overlapping_end != 0 {\n-            return err!(ReadPointerAsBytes);\n-        }\n+        self.check_relocations(ptr, Size::ZERO)?;\n+        self.check_relocations(ptr.offset(size, self)?, Size::ZERO)?;\n         Ok(())\n     }\n }"}, {"sha": "6f9e0cf3e37b60f8d4e0ac636121d23c5c554ed2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 35, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -15,7 +15,7 @@ use std::hash::{Hash, Hasher};\n use std::convert::TryInto;\n \n use rustc::{mir, ty};\n-use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n@@ -42,10 +42,7 @@ impl<'tcx> Value {\n         len: u64,\n         cx: impl HasDataLayout\n     ) -> Self {\n-        Value::ScalarPair(val.into(), Scalar::Bits {\n-            bits: len as u128,\n-            size: cx.data_layout().pointer_size.bytes() as u8,\n-        }.into())\n+        Value::ScalarPair(val.into(), Scalar::from_uint(len, cx.data_layout().pointer_size).into())\n     }\n \n     pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n@@ -88,7 +85,7 @@ impl<'tcx> Value {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ValTy<'tcx> {\n-    pub value: Value,\n+    value: Value,\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -110,16 +107,6 @@ pub enum Operand {\n }\n \n impl Operand {\n-    #[inline]\n-    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n-        Operand::Indirect(MemPlace::from_ptr(ptr, align))\n-    }\n-\n-    #[inline]\n-    pub fn from_scalar_value(val: Scalar) -> Self {\n-        Operand::Immediate(Value::Scalar(val.into()))\n-    }\n-\n     #[inline]\n     pub fn to_mem_place(self) -> MemPlace {\n         match self {\n@@ -141,7 +128,7 @@ impl Operand {\n \n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n-    crate op: Operand, // ideally we'd make this private, but we are not there yet\n+    crate op: Operand, // ideally we'd make this private, but const_prop needs this\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -187,23 +174,6 @@ impl<'tcx> PartialEq for OpTy<'tcx> {\n }\n impl<'tcx> Eq for OpTy<'tcx> {}\n \n-impl<'tcx> OpTy<'tcx> {\n-    #[inline]\n-    pub fn from_ptr(ptr: Pointer, align: Align, layout: TyLayout<'tcx>) -> Self {\n-        OpTy { op: Operand::from_ptr(ptr, align), layout }\n-    }\n-\n-    #[inline]\n-    pub fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n-        OpTy { op: Operand::from_ptr(ptr, layout.align), layout }\n-    }\n-\n-    #[inline]\n-    pub fn from_scalar_value(val: Scalar, layout: TyLayout<'tcx>) -> Self {\n-        OpTy { op: Operand::Immediate(Value::Scalar(val.into())), layout }\n-    }\n-}\n-\n // Use the existing layout if given (but sanity check in debug mode),\n // or compute the layout.\n #[inline(always)]\n@@ -510,7 +480,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ConstValue::ByRef(id, alloc, offset) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n-                Ok(Operand::from_ptr(Pointer::new(id, offset), alloc.align))\n+                Ok(Operand::Indirect(MemPlace::from_ptr(Pointer::new(id, offset), alloc.align)))\n             },\n             ConstValue::ScalarPair(a, b) =>\n                 Ok(Operand::Immediate(Value::ScalarPair(a.into(), b))),"}, {"sha": "d07d37d43b13e64a7eaa958bacae83018b10e185", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout};\n+use rustc::ty::{self, layout::{Size, TyLayout}};\n use syntax::ast::FloatTy;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         right: ValTy<'tcx>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binary_op(op, left, right)?;\n+        let (val, overflowed) = self.binary_op_val(op, left, right)?;\n         let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n         self.write_value(val, dest)\n     }\n@@ -42,7 +42,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         right: ValTy<'tcx>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        let (val, _overflowed) = self.binary_op_val(op, left, right)?;\n         self.write_scalar(val, dest)\n     }\n }\n@@ -105,10 +105,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ($ty:path, $size:expr) => {{\n                 let l = <$ty>::from_bits(l);\n                 let r = <$ty>::from_bits(r);\n-                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n-                    bits: res.value.to_bits(),\n-                    size: $size,\n-                };\n+                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>|\n+                    Scalar::from_uint(res.value.to_bits(), Size::from_bytes($size));\n                 let val = match bin_op {\n                     Eq => Scalar::from_bool(l == r),\n                     Ne => Scalar::from_bool(l != r),\n@@ -169,10 +167,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             };\n             let truncated = self.truncate(result, left_layout);\n-            return Ok((Scalar::Bits {\n-                bits: truncated,\n-                size: size.bytes() as u8,\n-            }, oflo));\n+            return Ok((Scalar::from_uint(truncated, size), oflo));\n         }\n \n         // For the remaining ops, the types must be the same on both sides\n@@ -220,7 +215,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Rem | Div => {\n                         // int_min / -1\n                         if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::Bits { bits: l, size: size.bytes() as u8 }, true));\n+                            return Ok((Scalar::from_uint(l, size), true));\n                         }\n                     },\n                     _ => {},\n@@ -232,16 +227,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     let max = 1 << (size.bits() - 1);\n                     oflo = result >= max || result < -max;\n                 }\n+                // this may be out-of-bounds for the result type, so we have to truncate ourselves\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::Bits {\n-                    bits: truncated,\n-                    size: size.bytes() as u8,\n-                }, oflo));\n+                return Ok((Scalar::from_uint(truncated, size), oflo));\n             }\n         }\n \n-        let size = left_layout.size.bytes() as u8;\n+        let size = left_layout.size;\n \n         // only ints left\n         let val = match bin_op {\n@@ -253,11 +246,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Gt => Scalar::from_bool(l > r),\n             Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => Scalar::Bits { bits: l | r, size },\n-            BitAnd => Scalar::Bits { bits: l & r, size },\n-            BitXor => Scalar::Bits { bits: l ^ r, size },\n+            BitOr => Scalar::from_uint(l | r, size),\n+            BitAnd => Scalar::from_uint(l & r, size),\n+            BitXor => Scalar::from_uint(l ^ r, size),\n \n             Add | Sub | Mul | Rem | Div => {\n+                debug_assert!(!left_layout.abi.is_signed());\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n                     Add => u128::overflowing_add,\n                     Sub => u128::overflowing_sub,\n@@ -270,10 +264,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n                 let (result, oflo) = op(l, r);\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::Bits {\n-                    bits: truncated,\n-                    size,\n-                }, oflo || truncated != result));\n+                return Ok((Scalar::from_uint(truncated, size), oflo || truncated != result));\n             }\n \n             _ => {\n@@ -291,16 +282,31 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok((val, false))\n     }\n \n+    /// Convenience wrapper that's useful when keeping the layout together with the\n+    /// value.\n+    #[inline]\n+    pub fn binary_op_val(\n+        &self,\n+        bin_op: mir::BinOp,\n+        left: ValTy<'tcx>,\n+        right: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        self.binary_op(\n+            bin_op,\n+            left.to_scalar()?, left.layout,\n+            right.to_scalar()?, right.layout,\n+        )\n+    }\n+\n     /// Returns the result of the specified operation and whether it overflowed.\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n-        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n+        left: Scalar,\n+        left_layout: TyLayout<'tcx>,\n+        right: Scalar,\n+        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n-        let left = left.to_scalar()?;\n-        let right = right.to_scalar()?;\n-\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n             bin_op, left, left_layout.ty, right, right_layout.ty);\n \n@@ -331,15 +337,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     right_layout.ty.is_fn());\n \n                 // Handle operations that support pointer values\n-                if let Some(handled) =\n-                    M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n-                {\n-                    return Ok(handled);\n+                if left.is_ptr() || right.is_ptr() || bin_op == mir::BinOp::Offset {\n+                    return M::ptr_op(self, bin_op, left, left_layout, right, right_layout);\n                 }\n \n                 // Everything else only works with \"proper\" bits\n-                let left = left.to_bits(left_layout.size)?;\n-                let right = right.to_bits(right_layout.size)?;\n+                let left = left.to_bits(left_layout.size).expect(\"we checked is_ptr\");\n+                let right = right.to_bits(right_layout.size).expect(\"we checked is_ptr\");\n                 self.binary_int_op(bin_op, left, left_layout, right, right_layout)\n             }\n         }\n@@ -373,7 +377,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     (Neg, FloatTy::F64) => Double::to_bits(-Double::from_bits(val)),\n                     _ => bug!(\"Invalid float op {:?}\", un_op)\n                 };\n-                Ok(Scalar::Bits { bits: res, size: layout.size.bytes() as u8 })\n+                Ok(Scalar::from_uint(res, layout.size))\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n@@ -386,10 +390,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                 };\n                 // res needs tuncating\n-                Ok(Scalar::Bits {\n-                    bits: self.truncate(res, layout),\n-                    size: layout.size.bytes() as u8,\n-                })\n+                Ok(Scalar::from_uint(self.truncate(res, layout), layout.size))\n             }\n         }\n     }"}, {"sha": "5bf6b2b46b7a6f6975be33a88d4145925d20ccbf", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n-    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef\n+    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n };\n use super::{EvalContext, Machine, Value, ValTy, Operand, OpTy, MemoryKind};\n \n@@ -344,10 +344,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::Array(inner, _) =>\n                 (None, self.tcx.mk_array(inner, inner_len)),\n             ty::Slice(..) => {\n-                let len = Scalar::Bits {\n-                    bits: inner_len.into(),\n-                    size: self.memory.pointer_size().bytes() as u8\n-                };\n+                let len = Scalar::from_uint(inner_len, self.pointer_size());\n                 (Some(len), base.layout.ty)\n             }\n             _ =>\n@@ -716,10 +713,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let discr_val = (discr_val << shift) >> shift;\n \n                 let discr_dest = self.place_field(dest, 0)?;\n-                self.write_scalar(Scalar::Bits {\n-                    bits: discr_val,\n-                    size: size.bytes() as u8,\n-                }, discr_dest)?;\n+                self.write_scalar(Scalar::from_uint(discr_val, size), discr_dest)?;\n             }\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -733,10 +727,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         self.place_field(dest, 0)?;\n                     let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n-                    self.write_scalar(Scalar::Bits {\n-                        bits: niche_value,\n-                        size: niche_dest.layout.size.bytes() as u8,\n-                    }, niche_dest)?;\n+                    self.write_scalar(\n+                        Scalar::from_uint(niche_value, niche_dest.layout.size),\n+                        niche_dest\n+                    )?;\n                 }\n             }\n         }\n@@ -766,11 +760,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let layout = self.layout_of(ty)?;\n \n         // More sanity checks\n-        let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n-        assert_eq!(size, layout.size);\n-        assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n-        // FIXME: More checks for the vtable? We could make sure it is exactly\n-        // the one one would expect for this type.\n+        if cfg!(debug_assertions) {\n+            let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n+            assert_eq!(size, layout.size);\n+            assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+        }\n \n         let mplace = MPlaceTy {\n             mplace: MemPlace { extra: None, ..*mplace },"}, {"sha": "114ef093ec2fddd90327a2cfcbfe9326b36ad91c", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n-use rustc::mir::interpret::{EvalResult, Scalar};\n+use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n use super::{EvalContext, Machine};\n \n@@ -269,12 +269,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n                 let len = mplace.len(&self)?;\n-                let size = self.memory.pointer_size().bytes() as u8;\n+                let size = self.pointer_size();\n                 self.write_scalar(\n-                    Scalar::Bits {\n-                        bits: len as u128,\n-                        size,\n-                    },\n+                    Scalar::from_uint(len, size),\n                     dest,\n                 )?;\n             }\n@@ -294,12 +291,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let layout = self.layout_of(ty)?;\n                 assert!(!layout.is_unsized(),\n                         \"SizeOf nullary MIR operator called for unsized type\");\n-                let size = self.memory.pointer_size().bytes() as u8;\n+                let size = self.pointer_size();\n                 self.write_scalar(\n-                    Scalar::Bits {\n-                        bits: layout.size.bytes() as u128,\n-                        size,\n-                    },\n+                    Scalar::from_uint(layout.size.bytes(), size),\n                     dest,\n                 )?;\n             }\n@@ -313,11 +307,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Discriminant(ref place) => {\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant(self.place_to_op(place)?)?.0;\n-                let size = dest.layout.size.bytes() as u8;\n-                self.write_scalar(Scalar::Bits {\n-                    bits: discr_val,\n-                    size,\n-                }, dest)?;\n+                let size = dest.layout.size;\n+                self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n             }\n         }\n "}, {"sha": "de8681062740938f62df21db9c279c3b17cfd5d3", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 165, "deletions": 191, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -10,15 +10,14 @@\n \n use std::borrow::Cow;\n \n-use rustc::mir;\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::LayoutOf;\n+use rustc::{mir, ty};\n+use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar};\n+use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Value, OpTy, Place, PlaceTy, Operand, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -59,14 +58,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n-                    // Compare using binary_op\n-                    let const_int = Scalar::Bits {\n-                        bits: const_int,\n-                        size: discr.layout.size.bytes() as u8\n-                    };\n+                    // Compare using binary_op, to also support pointer values\n+                    let const_int = Scalar::from_uint(const_int, discr.layout.size);\n                     let (res, _) = self.binary_op(mir::BinOp::Eq,\n-                        discr,\n-                        ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n+                        discr.to_scalar()?, discr.layout,\n+                        const_int, discr.layout,\n                     )?;\n                     if res.to_bool()? {\n                         target_block = targets[index];\n@@ -89,37 +85,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n-                let (fn_def, sig) = match func.layout.ty.sty {\n+                let (fn_def, abi) = match func.layout.ty.sty {\n                     ty::FnPtr(sig) => {\n+                        let caller_abi = sig.abi();\n                         let fn_ptr = self.read_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n-                        let instance_ty = instance.ty(*self.tcx);\n-                        match instance_ty.sty {\n-                            ty::FnDef(..) => {\n-                                let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    self.param_env,\n-                                    &sig,\n-                                );\n-                                let real_sig = instance_ty.fn_sig(*self.tcx);\n-                                let real_sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    self.param_env,\n-                                    &real_sig,\n-                                );\n-                                if !self.check_sig_compat(sig, real_sig)? {\n-                                    return err!(FunctionPointerTyMismatch(real_sig, sig));\n-                                }\n-                                (instance, sig)\n-                            }\n-                            _ => bug!(\"unexpected fn ptr to ty: {:?}\", instance_ty),\n-                        }\n+                        (instance, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n-                        let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                            self.param_env,\n-                            &sig,\n-                        );\n-                        (self.resolve(def_id, substs)?, sig)\n+                        (self.resolve(def_id, substs)?, sig.abi())\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n@@ -129,11 +104,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let args = self.eval_operands(args)?;\n                 self.eval_fn_call(\n                     fn_def,\n+                    terminator.source_info.span,\n+                    abi,\n                     &args[..],\n                     dest,\n                     ret,\n-                    terminator.source_info.span,\n-                    Some(sig),\n                 )?;\n             }\n \n@@ -168,6 +143,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 if expected == cond_val {\n                     self.goto_block(Some(target))?;\n                 } else {\n+                    // Compute error message\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n@@ -190,11 +166,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             }\n \n-            Yield { .. } => unimplemented!(\"{:#?}\", terminator.kind),\n-            GeneratorDrop => unimplemented!(),\n-            DropAndReplace { .. } => unimplemented!(),\n-            Resume => unimplemented!(),\n-            Abort => unimplemented!(),\n+            Yield { .. } |\n+            GeneratorDrop |\n+            DropAndReplace { .. } |\n+            Resume |\n+            Abort => unimplemented!(\"{:#?}\", terminator.kind),\n             FalseEdges { .. } => bug!(\"should have been eliminated by\\\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n@@ -205,91 +181,67 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Decides whether it is okay to call the method with signature `real_sig`\n-    /// using signature `sig`.\n-    /// FIXME: This should take into account the platform-dependent ABI description.\n-    fn check_sig_compat(\n-        &mut self,\n-        sig: ty::FnSig<'tcx>,\n-        real_sig: ty::FnSig<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        fn check_ty_compat<'tcx>(ty: Ty<'tcx>, real_ty: Ty<'tcx>) -> bool {\n-            if ty == real_ty {\n-                return true;\n-            } // This is actually a fast pointer comparison\n-            return match (&ty.sty, &real_ty.sty) {\n-                // Permit changing the pointer type of raw pointers and references as well as\n-                // mutability of raw pointers.\n-                // FIXME: Should not be allowed when fat pointers are involved.\n-                (&ty::RawPtr(_), &ty::RawPtr(_)) => true,\n-                (&ty::Ref(_, _, _), &ty::Ref(_, _, _)) => {\n-                    ty.is_mutable_pointer() == real_ty.is_mutable_pointer()\n-                }\n-                // rule out everything else\n-                _ => false,\n-            };\n+    fn check_argument_compat(\n+        caller: TyLayout<'tcx>,\n+        callee: TyLayout<'tcx>,\n+    ) -> bool {\n+        if caller.ty == callee.ty {\n+            // No question\n+            return true;\n         }\n-\n-        if sig.abi == real_sig.abi && sig.variadic == real_sig.variadic &&\n-            sig.inputs_and_output.len() == real_sig.inputs_and_output.len() &&\n-            sig.inputs_and_output\n-                .iter()\n-                .zip(real_sig.inputs_and_output)\n-                .all(|(ty, real_ty)| check_ty_compat(ty, real_ty))\n-        {\n-            // Definitely good.\n-            return Ok(true);\n+        // Compare layout\n+        match (&caller.abi, &callee.abi) {\n+            (layout::Abi::Scalar(ref caller), layout::Abi::Scalar(ref callee)) =>\n+                // Different valid ranges are okay (once we enforce validity,\n+                // that will take care to make it UB to leave the range, just\n+                // like for transmute).\n+                caller.value == callee.value,\n+            // Be conservative\n+            _ => false\n         }\n+    }\n \n-        if sig.variadic || real_sig.variadic {\n-            // We're not touching this\n-            return Ok(false);\n+    /// Pass a single argument, checking the types for compatibility.\n+    fn pass_argument(\n+        &mut self,\n+        skip_zst: bool,\n+        caller_arg: &mut impl Iterator<Item=OpTy<'tcx>>,\n+        callee_arg: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        if skip_zst && callee_arg.layout.is_zst() {\n+            // Nothing to do.\n+            trace!(\"Skipping callee ZST\");\n+            return Ok(());\n         }\n-\n-        // We need to allow what comes up when a non-capturing closure is cast to a fn().\n-        match (sig.abi, real_sig.abi) {\n-            (Abi::Rust, Abi::RustCall) // check the ABIs.  This makes the test here non-symmetric.\n-                if check_ty_compat(sig.output(), real_sig.output())\n-                    && real_sig.inputs_and_output.len() == 3 => {\n-                // First argument of real_sig must be a ZST\n-                let fst_ty = real_sig.inputs_and_output[0];\n-                if self.layout_of(fst_ty)?.is_zst() {\n-                    // Second argument must be a tuple matching the argument list of sig\n-                    let snd_ty = real_sig.inputs_and_output[1];\n-                    match snd_ty.sty {\n-                        ty::Tuple(tys) if sig.inputs().len() == tys.len() =>\n-                            if sig.inputs()\n-                                .iter()\n-                                .zip(tys)\n-                                .all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n-                                return Ok(true)\n-                            },\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            _ => {}\n-        };\n-\n-        // Nope, this doesn't work.\n-        return Ok(false);\n+        let caller_arg = caller_arg.next()\n+            .ok_or_else(|| EvalErrorKind::FunctionArgCountMismatch)?;\n+        if skip_zst {\n+            debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n+        }\n+        // Now, check\n+        if !Self::check_argument_compat(caller_arg.layout, callee_arg.layout) {\n+            return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n+        }\n+        self.copy_op(caller_arg, callee_arg)\n     }\n \n     /// Call this function -- pushing the stack frame and initializing the arguments.\n-    /// `sig` is optional in case of FnPtr/FnDef -- but mandatory for closures!\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n+        span: Span,\n+        caller_abi: Abi,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n         ret: Option<mir::BasicBlock>,\n-        span: Span,\n-        sig: Option<ty::FnSig<'tcx>>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n+                if caller_abi != Abi::RustIntrinsic {\n+                    return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g. for transmute returning `!`)\n                 let dest = match dest {\n@@ -308,6 +260,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n+                // ABI check\n+                {\n+                    let callee_abi = {\n+                        let instance_ty = instance.ty(*self.tcx);\n+                        match instance_ty.sty {\n+                            ty::FnDef(..) =>\n+                                instance_ty.fn_sig(*self.tcx).abi(),\n+                            ty::Closure(..) => Abi::RustCall,\n+                            ty::Generator(..) => Abi::Rust,\n+                            _ => bug!(\"unexpected callee ty: {:?}\", instance_ty),\n+                        }\n+                    };\n+                    // Rust and RustCall are compatible\n+                    let normalize_abi = |abi| if abi == Abi::RustCall { Abi::Rust } else { abi };\n+                    if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n+                        return err!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                    }\n+                }\n+\n+                // We need MIR for this fn\n                 let mir = match M::find_fn(self, instance, args, dest, ret)? {\n                     Some(mir) => mir,\n                     None => return Ok(()),\n@@ -325,93 +297,95 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     StackPopCleanup::Goto(ret),\n                 )?;\n \n-                // If we didn't get a signture, ask `fn_sig`\n-                let sig = sig.unwrap_or_else(|| {\n-                    let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n-                    self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig)\n-                });\n-                assert_eq!(sig.inputs().len(), args.len());\n-                // We can't test the types, as it is fine if the types are ABI-compatible but\n-                // not equal.\n-\n-                // Figure out how to pass which arguments.\n-                // FIXME: Somehow this is horribly full of special cases here, and codegen has\n-                // none of that.  What is going on?\n-                trace!(\n-                    \"ABI: {:?}, args: {:#?}\",\n-                    sig.abi,\n-                    args.iter()\n-                        .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n-                        .collect::<Vec<_>>()\n-                );\n-                trace!(\n-                    \"spread_arg: {:?}, locals: {:#?}\",\n-                    mir.spread_arg,\n-                    mir.args_iter()\n-                        .map(|local|\n-                            (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n-                        )\n-                        .collect::<Vec<_>>()\n-                );\n-\n-                // We have two iterators: Where the arguments come from,\n-                // and where they go to.\n-\n-                // For where they come from: If the ABI is RustCall, we untuple the\n-                // last incoming argument.  These do not have the same type,\n-                // so to keep the code paths uniform we accept an allocation\n-                // (for RustCall ABI only).\n-                let args_effective : Cow<[OpTy<'tcx>]> =\n-                    if sig.abi == Abi::RustCall && !args.is_empty() {\n-                        // Untuple\n-                        let (&untuple_arg, args) = args.split_last().unwrap();\n-                        trace!(\"eval_fn_call: Will pass last argument by untupling\");\n-                        Cow::from(args.iter().map(|&a| Ok(a))\n-                            .chain((0..untuple_arg.layout.fields.count()).into_iter()\n-                                .map(|i| self.operand_field(untuple_arg, i as u64))\n+                // We want to pop this frame again in case there was an error, to put\n+                // the blame in the right location.  Until the 2018 edition is used in\n+                // the compiler, we have to do this with an immediately invoked function.\n+                let res = (||{\n+                    trace!(\n+                        \"caller ABI: {:?}, args: {:#?}\",\n+                        caller_abi,\n+                        args.iter()\n+                            .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n+                            .collect::<Vec<_>>()\n+                    );\n+                    trace!(\n+                        \"spread_arg: {:?}, locals: {:#?}\",\n+                        mir.spread_arg,\n+                        mir.args_iter()\n+                            .map(|local|\n+                                (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n                             )\n-                            .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n-                    } else {\n-                        // Plain arg passing\n-                        Cow::from(args)\n+                            .collect::<Vec<_>>()\n+                    );\n+\n+                    // Figure out how to pass which arguments.\n+                    // We have two iterators: Where the arguments come from,\n+                    // and where they go to.\n+                    let skip_zst = match caller_abi {\n+                        Abi::Rust | Abi::RustCall => true,\n+                        _ => false\n                     };\n \n-                // Now we have to spread them out across the callee's locals,\n-                // taking into account the `spread_arg`.\n-                let mut args_iter = args_effective.iter();\n-                let mut local_iter = mir.args_iter();\n-                // HACK: ClosureOnceShim calls something that expects a ZST as\n-                // first argument, but the callers do not actually pass that ZST.\n-                // Codegen doesn't care because ZST arguments do not even exist there.\n-                match instance.def {\n-                    ty::InstanceDef::ClosureOnceShim { .. } if sig.abi == Abi::Rust => {\n-                        let local = local_iter.next().unwrap();\n+                    // For where they come from: If the ABI is RustCall, we untuple the\n+                    // last incoming argument.  These two iterators do not have the same type,\n+                    // so to keep the code paths uniform we accept an allocation\n+                    // (for RustCall ABI only).\n+                    let caller_args : Cow<[OpTy<'tcx>]> =\n+                        if caller_abi == Abi::RustCall && !args.is_empty() {\n+                            // Untuple\n+                            let (&untuple_arg, args) = args.split_last().unwrap();\n+                            trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                            Cow::from(args.iter().map(|&a| Ok(a))\n+                                .chain((0..untuple_arg.layout.fields.count()).into_iter()\n+                                    .map(|i| self.operand_field(untuple_arg, i as u64))\n+                                )\n+                                .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n+                        } else {\n+                            // Plain arg passing\n+                            Cow::from(args)\n+                        };\n+                    // Skip ZSTs\n+                    let mut caller_iter = caller_args.iter()\n+                        .filter(|op| !skip_zst || !op.layout.is_zst())\n+                        .map(|op| *op);\n+\n+                    // Now we have to spread them out across the callee's locals,\n+                    // taking into account the `spread_arg`.  If we could write\n+                    // this is a single iterator (that handles `spread_arg`), then\n+                    // `pass_argument` would be the loop body. It takes care to\n+                    // not advance `caller_iter` for ZSTs.\n+                    let mut locals_iter = mir.args_iter();\n+                    while let Some(local) = locals_iter.next() {\n                         let dest = self.eval_place(&mir::Place::Local(local))?;\n-                        assert!(dest.layout.is_zst());\n-                    }\n-                    _ => {}\n-                }\n-                // Now back to norml argument passing.\n-                while let Some(local) = local_iter.next() {\n-                    let dest = self.eval_place(&mir::Place::Local(local))?;\n-                    if Some(local) == mir.spread_arg {\n-                        // Must be a tuple\n-                        for i in 0..dest.layout.fields.count() {\n-                            let dest = self.place_field(dest, i as u64)?;\n-                            self.copy_op(*args_iter.next().unwrap(), dest)?;\n+                        if Some(local) == mir.spread_arg {\n+                            // Must be a tuple\n+                            for i in 0..dest.layout.fields.count() {\n+                                let dest = self.place_field(dest, i as u64)?;\n+                                self.pass_argument(skip_zst, &mut caller_iter, dest)?;\n+                            }\n+                        } else {\n+                            // Normal argument\n+                            self.pass_argument(skip_zst, &mut caller_iter, dest)?;\n                         }\n-                    } else {\n-                        // Normal argument\n-                        self.copy_op(*args_iter.next().unwrap(), dest)?;\n                     }\n+                    // Now we should have no more caller args\n+                    if caller_iter.next().is_some() {\n+                        trace!(\"Caller has too many args over\");\n+                        return err!(FunctionArgCountMismatch);\n+                    }\n+                    Ok(())\n+                })();\n+                match res {\n+                    Err(err) => {\n+                        self.stack.pop();\n+                        Err(err)\n+                    }\n+                    Ok(v) => Ok(v)\n                 }\n-                // Now we should be done\n-                assert!(args_iter.next().is_none());\n-                Ok(())\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n                 let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n                 let vtable = ptr.vtable()?;\n@@ -431,7 +405,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 args[0].op = Operand::Immediate(Value::Scalar(ptr.ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, &args, dest, ret, span, sig)\n+                self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n             }\n         }\n     }\n@@ -467,11 +441,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         self.eval_fn_call(\n             instance,\n+            span,\n+            Abi::Rust,\n             &[arg],\n             Some(dest),\n             Some(target),\n-            span,\n-            None,\n         )\n     }\n }"}, {"sha": "0e09f65f0a8eaba3b4f370b13cfbfa582401ed7f", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n-use rustc::mir::interpret::{Scalar, Pointer, EvalResult};\n+use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n use syntax::ast::Mutability;\n \n@@ -35,7 +35,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let size = layout.size.bytes();\n         let align = layout.align.abi();\n \n-        let ptr_size = self.memory.pointer_size();\n+        let ptr_size = self.pointer_size();\n         let ptr_align = self.tcx.data_layout.pointer_align;\n         let methods = self.tcx.vtable_methods(trait_ref);\n         let vtable = self.memory.allocate(\n@@ -49,15 +49,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.memory.write_ptr_sized(vtable, ptr_align, Scalar::Ptr(drop).into())?;\n \n         let size_ptr = vtable.offset(ptr_size, &self)?;\n-        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::Bits {\n-            bits: size as u128,\n-            size: ptr_size.bytes() as u8,\n-        }.into())?;\n+        self.memory.write_ptr_sized(size_ptr, ptr_align, Scalar::from_uint(size, ptr_size).into())?;\n         let align_ptr = vtable.offset(ptr_size * 2, &self)?;\n-        self.memory.write_ptr_sized(align_ptr, ptr_align, Scalar::Bits {\n-            bits: align as u128,\n-            size: ptr_size.bytes() as u8,\n-        }.into())?;\n+        self.memory.write_ptr_sized(align_ptr, ptr_align,\n+            Scalar::from_uint(align, ptr_size).into())?;\n \n         for (i, method) in methods.iter().enumerate() {\n             if let Some((def_id, substs)) = *method {\n@@ -97,7 +92,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         vtable: Pointer,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let pointer_size = self.memory.pointer_size();\n+        let pointer_size = self.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?,pointer_align)?\n             .to_bits(pointer_size)? as u64;"}, {"sha": "ef2ae8f5337c6285ade520bd185e436796765f40", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::layout::{self, Size, Primitive};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::mir::interpret::{\n-    Scalar, AllocType, EvalResult, ScalarMaybeUndef, EvalErrorKind\n+    Scalar, AllocType, EvalResult, ScalarMaybeUndef, EvalErrorKind, PointerArithmetic\n };\n \n use super::{\n@@ -118,7 +118,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 bits\n             },\n             Scalar::Ptr(_) => {\n-                let ptr_size = self.memory.pointer_size();\n+                let ptr_size = self.pointer_size();\n                 let ptr_max = u128::max_value() >> (128 - ptr_size.bits());\n                 return if lo > hi {\n                     if lo - hi == 1 {\n@@ -376,6 +376,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                         \"non-pointer vtable in fat pointer\", path\n                                     ),\n                             }\n+                            // FIXME: More checks for the vtable.\n                         }\n                         ty::Slice(..) | ty::Str => {\n                             match ptr.extra.unwrap().to_usize(self) {"}, {"sha": "e2b1a255eaca29fba90b48c664c84f5b27b2e5c0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8adc69a5a873dd7e840b7d002ae48a4c638ef7ee/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=8adc69a5a873dd7e840b7d002ae48a4c638ef7ee", "patch": "@@ -22,7 +22,7 @@ use rustc::mir::interpret::{\n };\n use rustc::ty::{TyCtxt, self, Instance};\n use interpret::{EvalContext, CompileTimeEvaluator, eval_promoted, mk_borrowck_eval_cx};\n-use interpret::{Value, OpTy, MemoryKind};\n+use interpret::{self, Value, OpTy, MemoryKind};\n use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n@@ -153,7 +153,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     | MachineError(_)\n                     // at runtime these transformations might make sense\n                     // FIXME: figure out the rules and start linting\n-                    | FunctionPointerTyMismatch(..)\n+                    | FunctionAbiMismatch(..)\n+                    | FunctionArgMismatch(..)\n+                    | FunctionArgCountMismatch\n                     // fine at runtime, might be a register address or sth\n                     | ReadBytesAsPointer\n                     // fine at runtime\n@@ -356,13 +358,15 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    OpTy::from_scalar_value(\n-                        Scalar::Bits {\n-                            bits: n as u128,\n-                            size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                        },\n-                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    ),\n+                    OpTy {\n+                        op: interpret::Operand::Immediate(Value::Scalar(\n+                            Scalar::Bits {\n+                                bits: n as u128,\n+                                size: self.tcx.data_layout.pointer_size.bytes() as u8,\n+                            }.into()\n+                        )),\n+                        layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    },\n                     span,\n                 )))\n             }\n@@ -397,7 +401,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     // Now run the actual operation.\n                     this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n-                Some((OpTy::from_scalar_value(val, place_layout), span))\n+                let res = OpTy {\n+                    op: interpret::Operand::Immediate(Value::Scalar(val.into())),\n+                    layout: place_layout,\n+                };\n+                Some((res, span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -452,7 +460,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, r)\n+                    this.ecx.binary_op_val(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ScalarPair(\n@@ -468,7 +476,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     Value::Scalar(val.into())\n                 };\n                 let res = OpTy {\n-                    op: ::interpret::Operand::Immediate(val),\n+                    op: interpret::Operand::Immediate(val),\n                     layout: place_layout,\n                 };\n                 Some((res, span))"}]}