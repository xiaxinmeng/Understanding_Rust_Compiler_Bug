{"sha": "994b91ac73016e2671138115ecd7fbbb31f13d28", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NGI5MWFjNzMwMTZlMjY3MTEzODExNWVjZDdmYmJiMzFmMTNkMjg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-12-09T18:55:11Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-12-09T18:55:11Z"}, "message": "Optimize branches when the target is statically known to a jump\n\nThis can happen in generic code", "tree": {"sha": "b374cbc9701983271b10c5990c1c60f8bb699132", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b374cbc9701983271b10c5990c1c60f8bb699132"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/994b91ac73016e2671138115ecd7fbbb31f13d28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/994b91ac73016e2671138115ecd7fbbb31f13d28", "html_url": "https://github.com/rust-lang/rust/commit/994b91ac73016e2671138115ecd7fbbb31f13d28", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/994b91ac73016e2671138115ecd7fbbb31f13d28/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f21ff20b3ab8cfce37a3dfc4641bf0d8e1b1c74", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f21ff20b3ab8cfce37a3dfc4641bf0d8e1b1c74", "html_url": "https://github.com/rust-lang/rust/commit/5f21ff20b3ab8cfce37a3dfc4641bf0d8e1b1c74"}], "stats": {"total": 63, "additions": 56, "deletions": 7}, "files": [{"sha": "3af4897b4f0b0774cd634e2695c4364bfef05b3a", "filename": "src/base.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/994b91ac73016e2671138115ecd7fbbb31f13d28/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994b91ac73016e2671138115ecd7fbbb31f13d28/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=994b91ac73016e2671138115ecd7fbbb31f13d28", "patch": "@@ -307,7 +307,9 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n             } => {\n                 let discr = codegen_operand(fx, discr).load_scalar(fx);\n \n-                if switch_ty.kind() == fx.tcx.types.bool.kind() {\n+                let use_bool_opt = switch_ty.kind() == fx.tcx.types.bool.kind()\n+                    || (targets.iter().count() == 1 && targets.iter().next().unwrap().0 == 0);\n+                if use_bool_opt {\n                     assert_eq!(targets.iter().count(), 1);\n                     let (then_value, then_block) = targets.iter().next().unwrap();\n                     let then_block = fx.get_block(then_block);\n@@ -325,12 +327,22 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, impl Module>) {\n                     let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let discr =\n                         crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n-                    if test_zero {\n-                        fx.bcx.ins().brz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                    if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n+                        &fx.bcx, discr, test_zero,\n+                    ) {\n+                        if taken {\n+                            fx.bcx.ins().jump(then_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     } else {\n-                        fx.bcx.ins().brnz(discr, then_block, &[]);\n-                        fx.bcx.ins().jump(else_block, &[]);\n+                        if test_zero {\n+                            fx.bcx.ins().brz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        } else {\n+                            fx.bcx.ins().brnz(discr, then_block, &[]);\n+                            fx.bcx.ins().jump(else_block, &[]);\n+                        }\n                     }\n                 } else {\n                     let mut switch = ::cranelift_frontend::Switch::new();"}, {"sha": "a575ed8dc35f80b0a3662df42cade581ab5cf672", "filename": "src/optimize/peephole.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/994b91ac73016e2671138115ecd7fbbb31f13d28/src%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994b91ac73016e2671138115ecd7fbbb31f13d28/src%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fpeephole.rs?ref=994b91ac73016e2671138115ecd7fbbb31f13d28", "patch": "@@ -73,11 +73,48 @@ pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n     })()\n     .unwrap_or_else(|| {\n         match bcx.func.dfg.value_type(arg) {\n-            types::I8 | types::I32 => {\n+            types::I8 | types::I16 => {\n                 // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n                 bcx.ins().uextend(types::I32, arg)\n             }\n             _ => arg,\n         }\n     })\n }\n+\n+/// Returns whether the branch is statically known to be taken or `None` if it isn't statically known.\n+pub(crate) fn maybe_known_branch_taken(\n+    bcx: &FunctionBuilder<'_>,\n+    arg: Value,\n+    test_zero: bool,\n+) -> Option<bool> {\n+    let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n+        arg_inst\n+    } else {\n+        return None;\n+    };\n+\n+    match bcx.func.dfg[arg_inst] {\n+        InstructionData::UnaryBool {\n+            opcode: Opcode::Bconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(!imm)\n+            } else {\n+                Some(imm)\n+            }\n+        }\n+        InstructionData::UnaryImm {\n+            opcode: Opcode::Iconst,\n+            imm,\n+        } => {\n+            if test_zero {\n+                Some(imm.bits() == 0)\n+            } else {\n+                Some(imm.bits() != 0)\n+            }\n+        }\n+        _ => None,\n+    }\n+}"}]}