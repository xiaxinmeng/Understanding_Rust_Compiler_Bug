{"sha": "45d50216a9fbf2943a370939e959de5a60d00c56", "node_id": "C_kwDOAAsO6NoAKDQ1ZDUwMjE2YTlmYmYyOTQzYTM3MDkzOWU5NTlkZTVhNjBkMDBjNTY", "commit": {"author": {"name": "Ayush Singh", "email": "ayushsingh1325@gmail.com", "date": "2023-03-09T16:25:29Z"}, "committer": {"name": "Ayush Singh", "email": "ayushsingh1325@gmail.com", "date": "2023-03-10T12:05:24Z"}, "message": "Split __thread_local_inner macro\n\nSplit the __thread_local_inner macro to make it more readable. Also move\neverything to crate::sys::common::thread_local.\n\nSigned-off-by: Ayush Singh <ayushsingh1325@gmail.com>", "tree": {"sha": "0d0b93a8812b3824f0384cf1fed831e464263947", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d0b93a8812b3824f0384cf1fed831e464263947"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45d50216a9fbf2943a370939e959de5a60d00c56", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEPXedWmbgyJF/geU7Z/nHg7Wh49UFAmQLHQUACgkQZ/nHg7Wh\n49VGqg/7BMrrLgt0G/p0MEFK8fdtpp2sQr+BiLSiI6IoMvHoPREiWwZ22UCIek0Q\nML9QoKEqpK3WmVaaAmyXDGTcj2nV4RruEqnkDZBR6Yh1jrmsjBEhlKZ8S3UkyMb8\nwDVWXiPAadkjJ+1T/6JcmOf4mTj2g5qJ/Np0WbtE5XHh+F9BPyrPxGHUonN4R3RP\nDXMoT2mzZK8Ezcl4MEWzgYWREG853EIUYmHWntVyjmXNBJHWNC3pCLyp/pYc+W/W\nxaI3uD/GQxXVKOtF1OChvV4VlYcQ6u4/iIOeJbRrh5yi9bljsdQjdfzoszUZGgPj\nsHsBqdO+ZJ+d4Ss2rhmLXSxRYSoJqsINTmz73Rmjgl1wDMI1GNb16UODd39xWGhl\n730UifQ2HXdudt2vcKpKt26z4rSHY5F8yAw44PsgDYko5BnpVPyHfsQNTjwEycLT\ndKLjsZURGtveF80GrzAvxMETbgq83Ecna2U0yFLqmY1ACB9HKrMFAJ7t8/yo0RAo\nDWwzJ4oZhu1GWcxEiXKe9p7kRGRCRDrbZGtiw2Y9abASppKsuiCpHwzoEU+3emkr\nfzRQV2pVSq15CJyer2wOVRsmnccsS6127zpFDzE3OBUGTGDbNeb1qxgQOdW6uUp2\nAIfMTLi4kDEW5f6XICCVR+iA1dC0IT4o8WRZdZ4Qxd0SpBpvCKw=\n=HmKr\n-----END PGP SIGNATURE-----", "payload": "tree 0d0b93a8812b3824f0384cf1fed831e464263947\nparent ffa901913487e999832c050f7c42da17ad7982ca\nauthor Ayush Singh <ayushsingh1325@gmail.com> 1678379129 +0530\ncommitter Ayush Singh <ayushsingh1325@gmail.com> 1678449924 +0530\n\nSplit __thread_local_inner macro\n\nSplit the __thread_local_inner macro to make it more readable. Also move\neverything to crate::sys::common::thread_local.\n\nSigned-off-by: Ayush Singh <ayushsingh1325@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45d50216a9fbf2943a370939e959de5a60d00c56", "html_url": "https://github.com/rust-lang/rust/commit/45d50216a9fbf2943a370939e959de5a60d00c56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45d50216a9fbf2943a370939e959de5a60d00c56/comments", "author": {"login": "Ayush1325", "id": 22546812, "node_id": "MDQ6VXNlcjIyNTQ2ODEy", "avatar_url": "https://avatars.githubusercontent.com/u/22546812?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ayush1325", "html_url": "https://github.com/Ayush1325", "followers_url": "https://api.github.com/users/Ayush1325/followers", "following_url": "https://api.github.com/users/Ayush1325/following{/other_user}", "gists_url": "https://api.github.com/users/Ayush1325/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ayush1325/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ayush1325/subscriptions", "organizations_url": "https://api.github.com/users/Ayush1325/orgs", "repos_url": "https://api.github.com/users/Ayush1325/repos", "events_url": "https://api.github.com/users/Ayush1325/events{/privacy}", "received_events_url": "https://api.github.com/users/Ayush1325/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ayush1325", "id": 22546812, "node_id": "MDQ6VXNlcjIyNTQ2ODEy", "avatar_url": "https://avatars.githubusercontent.com/u/22546812?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ayush1325", "html_url": "https://github.com/Ayush1325", "followers_url": "https://api.github.com/users/Ayush1325/followers", "following_url": "https://api.github.com/users/Ayush1325/following{/other_user}", "gists_url": "https://api.github.com/users/Ayush1325/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ayush1325/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ayush1325/subscriptions", "organizations_url": "https://api.github.com/users/Ayush1325/orgs", "repos_url": "https://api.github.com/users/Ayush1325/repos", "events_url": "https://api.github.com/users/Ayush1325/events{/privacy}", "received_events_url": "https://api.github.com/users/Ayush1325/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffa901913487e999832c050f7c42da17ad7982ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffa901913487e999832c050f7c42da17ad7982ca", "html_url": "https://github.com/rust-lang/rust/commit/ffa901913487e999832c050f7c42da17ad7982ca"}], "stats": {"total": 510, "additions": 316, "deletions": 194}, "files": [{"sha": "2b8782ddf4482c6ba242e79730a81a1896c81cc6", "filename": "library/std/src/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45d50216a9fbf2943a370939e959de5a60d00c56/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d50216a9fbf2943a370939e959de5a60d00c56/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs?ref=45d50216a9fbf2943a370939e959de5a60d00c56", "patch": "@@ -12,6 +12,7 @@\n \n pub mod alloc;\n pub mod small_c_string;\n+pub mod thread_local;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "cddf09893486acdb8a740b3a35f0958ee1485522", "filename": "library/std/src/sys/common/thread_local.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/45d50216a9fbf2943a370939e959de5a60d00c56/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d50216a9fbf2943a370939e959de5a60d00c56/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local.rs?ref=45d50216a9fbf2943a370939e959de5a60d00c56", "patch": "@@ -0,0 +1,315 @@\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+#[macro_export]\n+#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n+#[allow_internal_unsafe]\n+#[cfg(all(\n+    not(target_thread_local),\n+    not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))\n+))]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+                        // On platforms without `#[thread_local]` we fall back to the\n+            // same implementation as below for os thread locals.\n+            #[inline]\n+            const fn __init() -> $t { INIT_EXPR }\n+            static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                $crate::thread::__OsLocalKeyInner::new();\n+            #[allow(unused_unsafe)]\n+            unsafe {\n+                __KEY.get(move || {\n+                    if let $crate::option::Option::Some(init) = _init {\n+                        if let $crate::option::Option::Some(value) = init.take() {\n+                            return value;\n+                        } else if $crate::cfg!(debug_assertions) {\n+                            $crate::unreachable!(\"missing initial value\");\n+                        }\n+                    }\n+                    __init()\n+                })\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n+                    $crate::thread::__OsLocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+#[macro_export]\n+#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n+#[allow_internal_unsafe]\n+#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+            // If the platform has support for `#[thread_local]`, use it.\n+            #[thread_local]\n+            static mut VAL: $t = INIT_EXPR;\n+\n+            // If a dtor isn't needed we can do something \"very raw\" and\n+            // just get going.\n+            if !$crate::mem::needs_drop::<$t>() {\n+                unsafe {\n+                    return $crate::option::Option::Some(&VAL)\n+                }\n+            }\n+\n+            // 0 == dtor not registered\n+            // 1 == dtor registered, dtor not run\n+            // 2 == dtor registered and is running or has run\n+            #[thread_local]\n+            static mut STATE: $crate::primitive::u8 = 0;\n+\n+            unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n+                let ptr = ptr as *mut $t;\n+\n+                unsafe {\n+                    $crate::debug_assert_eq!(STATE, 1);\n+                    STATE = 2;\n+                    $crate::ptr::drop_in_place(ptr);\n+                }\n+            }\n+\n+            unsafe {\n+                match STATE {\n+                    // 0 == we haven't registered a destructor, so do\n+                    //   so now.\n+                    0 => {\n+                        $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n+                            $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n+                            destroy,\n+                        );\n+                        STATE = 1;\n+                        $crate::option::Option::Some(&VAL)\n+                    }\n+                    // 1 == the destructor is registered and the value\n+                    //   is valid, so return the pointer.\n+                    1 => $crate::option::Option::Some(&VAL),\n+                    // otherwise the destructor has already run, so we\n+                    // can't give access.\n+                    _ => $crate::option::Option::None,\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                #[thread_local]\n+                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n+                    $crate::thread::__FastLocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+#[macro_export]\n+#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n+#[allow_internal_unsafe]\n+#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[inline] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+            // wasm without atomics maps directly to `static mut`, and dtors\n+            // aren't implemented because thread dtors aren't really a thing\n+            // on wasm right now\n+            //\n+            // FIXME(#84224) this should come after the `target_thread_local`\n+            // block.\n+            static mut VAL: $t = INIT_EXPR;\n+            unsafe { $crate::option::Option::Some(&VAL) }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+            #[inline]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n+                    $crate::thread::__StaticLocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}"}, {"sha": "c080c176a2acef8ad0ecae01e008779ebaaa0789", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 0, "deletions": 194, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/45d50216a9fbf2943a370939e959de5a60d00c56/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45d50216a9fbf2943a370939e959de5a60d00c56/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=45d50216a9fbf2943a370939e959de5a60d00c56", "patch": "@@ -76,197 +76,3 @@ cfg_if::cfg_if! {\n         pub mod c;\n     }\n }\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n-#[macro_export]\n-#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n-#[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n-    // used to generate the `LocalKey` value for const-initialized thread locals\n-    (@key $t:ty, const $init:expr) => {{\n-        #[cfg_attr(not(windows), inline)] // see comments below\n-        #[deny(unsafe_op_in_unsafe_fn)]\n-        unsafe fn __getit(\n-            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-        ) -> $crate::option::Option<&'static $t> {\n-            const INIT_EXPR: $t = $init;\n-\n-            // wasm without atomics maps directly to `static mut`, and dtors\n-            // aren't implemented because thread dtors aren't really a thing\n-            // on wasm right now\n-            //\n-            // FIXME(#84224) this should come after the `target_thread_local`\n-            // block.\n-            #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-            {\n-                static mut VAL: $t = INIT_EXPR;\n-                unsafe { $crate::option::Option::Some(&VAL) }\n-            }\n-\n-            // If the platform has support for `#[thread_local]`, use it.\n-            #[cfg(all(\n-                target_thread_local,\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[thread_local]\n-                static mut VAL: $t = INIT_EXPR;\n-\n-                // If a dtor isn't needed we can do something \"very raw\" and\n-                // just get going.\n-                if !$crate::mem::needs_drop::<$t>() {\n-                    unsafe {\n-                        return $crate::option::Option::Some(&VAL)\n-                    }\n-                }\n-\n-                // 0 == dtor not registered\n-                // 1 == dtor registered, dtor not run\n-                // 2 == dtor registered and is running or has run\n-                #[thread_local]\n-                static mut STATE: $crate::primitive::u8 = 0;\n-\n-                unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n-                    let ptr = ptr as *mut $t;\n-\n-                    unsafe {\n-                        $crate::debug_assert_eq!(STATE, 1);\n-                        STATE = 2;\n-                        $crate::ptr::drop_in_place(ptr);\n-                    }\n-                }\n-\n-                unsafe {\n-                    match STATE {\n-                        // 0 == we haven't registered a destructor, so do\n-                        //   so now.\n-                        0 => {\n-                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n-                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n-                                destroy,\n-                            );\n-                            STATE = 1;\n-                            $crate::option::Option::Some(&VAL)\n-                        }\n-                        // 1 == the destructor is registered and the value\n-                        //   is valid, so return the pointer.\n-                        1 => $crate::option::Option::Some(&VAL),\n-                        // otherwise the destructor has already run, so we\n-                        // can't give access.\n-                        _ => $crate::option::Option::None,\n-                    }\n-                }\n-            }\n-\n-            // On platforms without `#[thread_local]` we fall back to the\n-            // same implementation as below for os thread locals.\n-            #[cfg(all(\n-                not(target_thread_local),\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[inline]\n-                const fn __init() -> $t { INIT_EXPR }\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = _init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing initial value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-        }\n-\n-        unsafe {\n-            $crate::thread::LocalKey::new(__getit)\n-        }\n-    }};\n-\n-    // used to generate the `LocalKey` value for `thread_local!`\n-    (@key $t:ty, $init:expr) => {\n-        {\n-            #[inline]\n-            fn __init() -> $t { $init }\n-\n-            // When reading this function you might ask \"why is this inlined\n-            // everywhere other than Windows?\", and that's a very reasonable\n-            // question to ask. The short story is that it segfaults rustc if\n-            // this function is inlined. The longer story is that Windows looks\n-            // to not support `extern` references to thread locals across DLL\n-            // boundaries. This appears to at least not be supported in the ABI\n-            // that LLVM implements.\n-            //\n-            // Because of this we never inline on Windows, but we do inline on\n-            // other platforms (where external references to thread locals\n-            // across DLLs are supported). A better fix for this would be to\n-            // inline this function on Windows, but only for \"statically linked\"\n-            // components. For example if two separately compiled rlibs end up\n-            // getting linked into a DLL then it's fine to inline this function\n-            // across that boundary. It's only not fine to inline this function\n-            // across a DLL boundary. Unfortunately rustc doesn't currently\n-            // have this sort of logic available in an attribute, and it's not\n-            // clear that rustc is even equipped to answer this (it's more of a\n-            // Cargo question kinda). This means that, unfortunately, Windows\n-            // gets the pessimistic path for now where it's never inlined.\n-            //\n-            // The issue of \"should enable on Windows sometimes\" is #84933\n-            #[cfg_attr(not(windows), inline)]\n-            unsafe fn __getit(\n-                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-            ) -> $crate::option::Option<&'static $t> {\n-                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n-                    $crate::thread::__StaticLocalKeyInner::new();\n-\n-                #[thread_local]\n-                #[cfg(all(\n-                    target_thread_local,\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n-                    $crate::thread::__FastLocalKeyInner::new();\n-\n-                #[cfg(all(\n-                    not(target_thread_local),\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-\n-                // FIXME: remove the #[allow(...)] marker when macros don't\n-                // raise warning for missing/extraneous unsafe blocks anymore.\n-                // See https://github.com/rust-lang/rust/issues/74838.\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing default value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-\n-            unsafe {\n-                $crate::thread::LocalKey::new(__getit)\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n-        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n-}"}]}