{"sha": "0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhYzZlNWFmZGEyYTk3NDFkNTBkNmI1YzU1N2VlMTZmZWU0NDg3OGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-11T23:06:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-11T23:06:49Z"}, "message": "auto merge of #12158 : nikomatsakis/rust/issue-6801-borrowck-closures, r=pcwalton\n\nI factored the commits by affected files, for the most part. The last 7 or 8 contain the meat of the PR. The rest are small changes to closures found in the codebase. Maybe interesting to read to see some of the impact of the rules.\r\n\r\nr? @pcwalton\r\n\r\nFixes #6801", "tree": {"sha": "f3911877e062ef2c5a2188a91b38a128dbd35c2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3911877e062ef2c5a2188a91b38a128dbd35c2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "html_url": "https://github.com/rust-lang/rust/commit/0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ab248af38c982f42a0a1acf0769e71fa7e77db7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ab248af38c982f42a0a1acf0769e71fa7e77db7", "html_url": "https://github.com/rust-lang/rust/commit/2ab248af38c982f42a0a1acf0769e71fa7e77db7"}, {"sha": "484f0f11e6e49c530cd0351e76989ec6706fa2ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/484f0f11e6e49c530cd0351e76989ec6706fa2ce", "html_url": "https://github.com/rust-lang/rust/commit/484f0f11e6e49c530cd0351e76989ec6706fa2ce"}], "stats": {"total": 5497, "additions": 2967, "deletions": 2530}, "files": [{"sha": "ebad650a5340b8511e35b95ff803c105df883f74", "filename": "src/doc/guide-container.md", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Fdoc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Fdoc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-container.md?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -181,19 +181,25 @@ never call its underlying iterator again once `None` has been returned:\n ~~~\n let xs = [1,2,3,4,5];\n let mut calls = 0;\n-let it = xs.iter().scan((), |_, x| {\n-    calls += 1;\n-    if *x < 3 { Some(x) } else { None }});\n-// the iterator will only yield 1 and 2 before returning None\n-// If we were to call it 5 times, calls would end up as 5, despite only 2 values\n-// being yielded (and therefore 3 unique calls being made). The fuse() adaptor\n-// can fix this.\n-let mut it = it.fuse();\n-it.next();\n-it.next();\n-it.next();\n-it.next();\n-it.next();\n+\n+{\n+    let it = xs.iter().scan((), |_, x| {\n+        calls += 1;\n+        if *x < 3 { Some(x) } else { None }});\n+        \n+    // the iterator will only yield 1 and 2 before returning None\n+    // If we were to call it 5 times, calls would end up as 5, despite\n+    // only 2 values being yielded (and therefore 3 unique calls being\n+    // made). The fuse() adaptor can fix this.\n+    \n+    let mut it = it.fuse();\n+    it.next();\n+    it.next();\n+    it.next();\n+    it.next();\n+    it.next();\n+}\n+\n assert_eq!(calls, 3);\n ~~~\n "}, {"sha": "34e09ac1913db23a645e5edf45188f8df7e395fa", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -775,14 +775,13 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n     let mut lim = lim;\n \n     let mut cont = true;\n-    let slice: || = || { cont = it(ss.slice(slice_start, last_end)) };\n \n     // if the limit is larger than the string, lower it to save cycles\n     if lim >= fake_i {\n         lim = fake_i;\n     }\n \n-    let machine: |(uint, char)| -> bool = |(i, c)| {\n+    let machine: |&mut bool, (uint, char)| -> bool = |cont, (i, c)| {\n         let whitespace = if ::std::char::is_whitespace(c) { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n \n@@ -794,24 +793,49 @@ fn each_split_within<'a>(ss: &'a str, lim: uint, it: |&'a str| -> bool)\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => fail!(\"word starting with {} longer than limit!\",\n                                     ss.slice(last_start, i + 1)),\n-            (B, Cr, OverLim)  => { slice(); slice_start = last_start; B }\n-            (B, Ws, UnderLim) => { last_end = i; C }\n-            (B, Ws, OverLim)  => { last_end = i; slice(); A }\n-\n-            (C, Cr, UnderLim) => { last_start = i; B }\n-            (C, Cr, OverLim)  => { slice(); slice_start = i; last_start = i; last_end = i; B }\n-            (C, Ws, OverLim)  => { slice(); A }\n-            (C, Ws, UnderLim) => { C }\n+            (B, Cr, OverLim)  => {\n+                *cont = it(ss.slice(slice_start, last_end));\n+                slice_start = last_start;\n+                B\n+            }\n+            (B, Ws, UnderLim) => {\n+                last_end = i;\n+                C\n+            }\n+            (B, Ws, OverLim)  => {\n+                last_end = i;\n+                *cont = it(ss.slice(slice_start, last_end));\n+                A\n+            }\n+\n+            (C, Cr, UnderLim) => {\n+                last_start = i;\n+                B\n+            }\n+            (C, Cr, OverLim)  => {\n+                *cont = it(ss.slice(slice_start, last_end));\n+                slice_start = i;\n+                last_start = i;\n+                last_end = i;\n+                B\n+            }\n+            (C, Ws, OverLim)  => {\n+                *cont = it(ss.slice(slice_start, last_end));\n+                A\n+            }\n+            (C, Ws, UnderLim) => {\n+                C\n+            }\n         };\n \n-        cont\n+        *cont\n     };\n \n-    ss.char_indices().advance(|x| machine(x));\n+    ss.char_indices().advance(|x| machine(&mut cont, x));\n \n     // Let the automaton 'run out' by supplying trailing whitespace\n     while cont && match state { B | C => true, A => false } {\n-        machine((fake_i, ' '));\n+        machine(&mut cont, (fake_i, ' '));\n         fake_i += 1;\n     }\n     return cont;"}, {"sha": "25634b1808de2d608f33bd926f93c304025f31ee", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -28,6 +28,7 @@\n #[crate_type = \"dylib\"];\n #[license = \"MIT/ASL2\"];\n \n+use std::cell::Cell;\n use std::{os, path};\n use std::io::fs;\n use std::path::is_sep;\n@@ -342,22 +343,24 @@ impl Pattern {\n     }\n \n     fn matches_from(&self,\n-                    mut prev_char: Option<char>,\n+                    prev_char: Option<char>,\n                     mut file: &str,\n                     i: uint,\n                     options: MatchOptions) -> MatchResult {\n \n+        let prev_char = Cell::new(prev_char);\n+\n         let require_literal = |c| {\n             (options.require_literal_separator && is_sep(c)) ||\n             (options.require_literal_leading_dot && c == '.'\n-             && is_sep(prev_char.unwrap_or('/')))\n+             && is_sep(prev_char.get().unwrap_or('/')))\n         };\n \n         for (ti, token) in self.tokens.slice_from(i).iter().enumerate() {\n             match *token {\n                 AnySequence => {\n                     loop {\n-                        match self.matches_from(prev_char, file, i + ti + 1, options) {\n+                        match self.matches_from(prev_char.get(), file, i + ti + 1, options) {\n                             SubPatternDoesntMatch => (), // keep trying\n                             m => return m,\n                         }\n@@ -370,7 +373,7 @@ impl Pattern {\n                         if require_literal(c) {\n                             return SubPatternDoesntMatch;\n                         }\n-                        prev_char = Some(c);\n+                        prev_char.set(Some(c));\n                         file = next;\n                     }\n                 }\n@@ -400,7 +403,7 @@ impl Pattern {\n                     if !matches {\n                         return SubPatternDoesntMatch;\n                     }\n-                    prev_char = Some(c);\n+                    prev_char.set(Some(c));\n                     file = next;\n                 }\n             }"}, {"sha": "099f376aded6cb4b683671b429375035707b62fb", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -361,21 +361,23 @@ pub mod write {\n \n         let mut llvm_c_strs = ~[];\n         let mut llvm_args = ~[];\n-        let add = |arg: &str| {\n-            let s = arg.to_c_str();\n-            llvm_args.push(s.with_ref(|p| p));\n-            llvm_c_strs.push(s);\n-        };\n-        add(\"rustc\"); // fake program name\n-        add(\"-arm-enable-ehabi\");\n-        add(\"-arm-enable-ehabi-descriptors\");\n-        if vectorize_loop { add(\"-vectorize-loops\"); }\n-        if vectorize_slp  { add(\"-vectorize-slp\");   }\n-        if sess.time_llvm_passes() { add(\"-time-passes\"); }\n-        if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n-\n-        for arg in sess.opts.cg.llvm_args.iter() {\n-            add(*arg);\n+        {\n+            let add = |arg: &str| {\n+                let s = arg.to_c_str();\n+                llvm_args.push(s.with_ref(|p| p));\n+                llvm_c_strs.push(s);\n+            };\n+            add(\"rustc\"); // fake program name\n+            add(\"-arm-enable-ehabi\");\n+            add(\"-arm-enable-ehabi-descriptors\");\n+            if vectorize_loop { add(\"-vectorize-loops\"); }\n+            if vectorize_slp  { add(\"-vectorize-slp\");   }\n+            if sess.time_llvm_passes() { add(\"-time-passes\"); }\n+            if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n+\n+            for arg in sess.opts.cg.llvm_args.iter() {\n+                add(*arg);\n+            }\n         }\n \n         INIT.doit(|| {\n@@ -631,7 +633,7 @@ pub fn mangle(sess: Session, ss: ast_map::Path,\n \n     let mut n = ~\"_ZN\"; // _Z == Begin name-sequence, N == nested\n \n-    let push = |s: &str| {\n+    let push = |n: &mut ~str, s: &str| {\n         let sani = sanitize(s);\n         n.push_str(format!(\"{}{}\", sani.len(), sani));\n     };\n@@ -640,7 +642,7 @@ pub fn mangle(sess: Session, ss: ast_map::Path,\n     for s in ss.iter() {\n         match *s {\n             PathName(s) | PathMod(s) | PathPrettyName(s, _) => {\n-                push(sess.str_of(s))\n+                push(&mut n, sess.str_of(s))\n             }\n         }\n     }\n@@ -665,10 +667,10 @@ pub fn mangle(sess: Session, ss: ast_map::Path,\n         }\n     }\n     if hash.len() > 0 {\n-        push(hash);\n+        push(&mut n, hash);\n     }\n     match vers {\n-        Some(s) => push(s),\n+        Some(s) => push(&mut n, s),\n         None => {}\n     }\n "}, {"sha": "4fd72a4bbfc69ff2064d4ade796733a65cbf1480", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -58,16 +58,18 @@ fn filter_view_item<'r>(cx: &Context, view_item: &'r ast::ViewItem)\n }\n \n fn fold_mod(cx: &mut Context, m: &ast::Mod) -> ast::Mod {\n-    let filtered_items = m.items.iter()\n+    let filtered_items: ~[&@ast::Item] = m.items.iter()\n             .filter(|&a| item_in_cfg(cx, *a))\n+            .collect();\n+    let flattened_items = filtered_items.move_iter()\n             .flat_map(|&x| cx.fold_item(x).move_iter())\n             .collect();\n     let filtered_view_items = m.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n     ast::Mod {\n         view_items: filtered_view_items,\n-        items: filtered_items\n+        items: flattened_items\n     }\n }\n \n@@ -113,23 +115,26 @@ fn fold_item_underscore(cx: &mut Context, item: &ast::Item_) -> ast::Item_ {\n             ast::ItemStruct(fold_struct(cx, def), generics.clone())\n         }\n         ast::ItemEnum(ref def, ref generics) => {\n-            let mut variants = def.variants.iter().map(|c| c.clone()).filter(|m| {\n-                (cx.in_cfg)(m.node.attrs)\n-            }).map(|v| {\n-                match v.node.kind {\n-                    ast::TupleVariantKind(..) => v,\n-                    ast::StructVariantKind(def) => {\n-                        let def = fold_struct(cx, def);\n-                        @codemap::Spanned {\n-                            node: ast::Variant_ {\n-                                kind: ast::StructVariantKind(def),\n-                                ..v.node.clone()\n-                            },\n-                            ..*v\n-                        }\n+            let mut variants = def.variants.iter().map(|c| c.clone()).\n+            filter_map(|v| {\n+                if !(cx.in_cfg)(v.node.attrs) {\n+                    None\n+                } else {\n+                    Some(match v.node.kind {\n+                                ast::TupleVariantKind(..) => v,\n+                                ast::StructVariantKind(def) => {\n+                                    let def = fold_struct(cx, def);\n+                                    @codemap::Spanned {\n+                                        node: ast::Variant_ {\n+                                            kind: ast::StructVariantKind(def),\n+                                            ..v.node.clone()\n+                                        },\n+                                        ..*v\n+                                    }\n+                                }\n+                            })\n                     }\n-                }\n-            });\n+                });\n             ast::ItemEnum(ast::EnumDef {\n                 variants: variants.collect(),\n             }, generics.clone())\n@@ -165,10 +170,11 @@ fn retain_stmt(cx: &Context, stmt: @ast::Stmt) -> bool {\n }\n \n fn fold_block(cx: &mut Context, b: ast::P<ast::Block>) -> ast::P<ast::Block> {\n-    let resulting_stmts = b.stmts.iter()\n-            .filter(|&a| retain_stmt(cx, *a))\n-            .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n-            .collect();\n+    let resulting_stmts: ~[&@ast::Stmt] =\n+        b.stmts.iter().filter(|&a| retain_stmt(cx, *a)).collect();\n+    let resulting_stmts = resulting_stmts.move_iter()\n+        .flat_map(|&stmt| cx.fold_stmt(stmt).move_iter())\n+        .collect();\n     let filtered_view_items = b.view_items.iter().filter_map(|a| {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();"}, {"sha": "ea4d6d3b252f3eb6f11764737b08a8201d2b0901", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -924,15 +924,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             pos: ebml_w.writer.tell().unwrap(),\n         });\n     }\n-    let add_to_index: || = || add_to_index(item, ebml_w, index);\n \n     debug!(\"encoding info for item at {}\",\n            ecx.tcx.sess.codemap.span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n     match item.node {\n       ItemStatic(_, m, _) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         if m == ast::MutMutable {\n@@ -959,7 +958,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n       }\n       ItemFn(_, purity, _, ref generics, _) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, purity_fn_family(purity));\n@@ -977,7 +976,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n       }\n       ItemMod(ref m) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         encode_info_for_mod(ecx,\n                             ebml_w,\n                             m,\n@@ -987,7 +986,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                             item.vis);\n       }\n       ItemForeignMod(ref fm) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'n');\n@@ -1004,7 +1003,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n       }\n       ItemTy(..) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'y');\n@@ -1015,7 +1014,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n       }\n       ItemEnum(ref enum_definition, ref generics) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n \n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -1053,7 +1052,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                          struct_def.fields, index);\n \n         /* Index the class*/\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n \n         /* Now, make an item for the class itself */\n         ebml_w.start_tag(tag_items_data_item);\n@@ -1106,7 +1105,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let impls = tcx.impls.borrow();\n         let imp = impls.get().get(&def_id);\n \n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'i');\n@@ -1170,7 +1169,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n       }\n       ItemTrait(_, ref super_traits, ref ms) => {\n-        add_to_index();\n+        add_to_index(item, ebml_w, index);\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'I');"}, {"sha": "00e189cdc792d20c482f51935371308efcbd88cd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -96,8 +96,9 @@ pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n }\n \n fn parse_ident_(st: &mut PState, is_last: |char| -> bool) -> ast::Ident {\n+    let tcx = st.tcx;\n     scan(st, is_last, |bytes| {\n-            st.tcx.sess.ident_of(str::from_utf8(bytes).unwrap())\n+            tcx.sess.ident_of(str::from_utf8(bytes).unwrap())\n         })\n }\n "}, {"sha": "cb1a803c35a0f4475420ebf1d2411532943a9020", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 183, "deletions": 120, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -52,9 +52,11 @@ impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n     fn visit_pat(&mut self, p: &ast::Pat, _: ()) {\n         check_loans_in_pat(self, p);\n     }\n-    fn visit_fn(&mut self, fk: &visit::FnKind, fd: &ast::FnDecl,\n-                b: &ast::Block, s: Span, n: ast::NodeId, _: ()) {\n-        check_loans_in_fn(self, fk, fd, b, s, n);\n+    fn visit_fn(&mut self, _fk: &visit::FnKind, _fd: &ast::FnDecl,\n+                _b: &ast::Block, _s: Span, _n: ast::NodeId, _: ()) {\n+        // Don't process nested items or closures here,\n+        // the outer loop will take care of it.\n+        return;\n     }\n \n     // FIXME(#10894) should continue recursing\n@@ -218,57 +220,127 @@ impl<'a> CheckLoanCtxt<'a> {\n                loan2.repr(self.tcx()));\n \n         // Restrictions that would cause the new loan to be illegal:\n-        let illegal_if = match loan2.mutbl {\n-            MutableMutability   => RESTR_FREEZE | RESTR_CLAIM,\n-            ImmutableMutability => RESTR_FREEZE,\n+        let illegal_if = match loan2.kind {\n+            // Look for restrictions against mutation. These are\n+            // generated by all other borrows.\n+            ty::MutBorrow => RESTR_MUTATE,\n+\n+            // Look for restrictions against freezing (immutable borrows).\n+            // These are generated by `&mut` borrows.\n+            ty::ImmBorrow => RESTR_FREEZE,\n+\n+            // No matter how the data is borrowed (as `&`, as `&mut`,\n+            // or as `&unique imm`) it will always generate a\n+            // restriction against mutating the data. So look for those.\n+            ty::UniqueImmBorrow => RESTR_MUTATE,\n         };\n         debug!(\"illegal_if={:?}\", illegal_if);\n \n         for restr in loan1.restrictions.iter() {\n             if !restr.set.intersects(illegal_if) { continue; }\n             if restr.loan_path != loan2.loan_path { continue; }\n \n-            match (new_loan.mutbl, old_loan.mutbl) {\n-                (_, MutableMutability) => {\n-                    let var = self.bccx.loan_path_to_str(new_loan.loan_path);\n+            let old_pronoun = if new_loan.loan_path == old_loan.loan_path {\n+                ~\"it\"\n+            } else {\n+                format!(\"`{}`\",\n+                        self.bccx.loan_path_to_str(old_loan.loan_path))\n+            };\n+\n+            match (new_loan.kind, old_loan.kind) {\n+                (ty::MutBorrow, ty::MutBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}` because it is already \\\n-                                 borrowed as mutable\", var));\n-                    self.bccx.span_note(\n-                        old_loan.span,\n-                        format!(\"previous borrow of `{0}` as mutable occurs \\\n-                                 here; the mutable borrow prevents subsequent \\\n-                                 moves, borrows, or modification of `{0}` \\\n-                                 until the borrow ends\", var));\n+                        format!(\"cannot borrow `{}` as mutable \\\n+                                more than once at a time\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                }\n+\n+                (ty::UniqueImmBorrow, _) => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        format!(\"closure requires unique access to `{}` \\\n+                                but {} is already borrowed\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                old_pronoun));\n                 }\n \n-                (_, mutability) => {\n+                (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}` as {} because \\\n-                              it is already borrowed as {}\",\n-                             self.bccx.loan_path_to_str(new_loan.loan_path),\n-                             self.bccx.mut_to_str(new_loan.mutbl),\n-                             self.bccx.mut_to_str(old_loan.mutbl)));\n-\n-                    let var = self.bccx.loan_path_to_str(new_loan.loan_path);\n-                    let mut note = format!(\"previous borrow of `{}` occurs \\\n-                                            here\", var);\n-                    if mutability == ImmutableMutability {\n-                        note.push_str(format!(\"; the immutable borrow prevents \\\n-                                               subsequent moves or mutable\n-                                               borrows of `{}` until the\n-                                               borrow ends\", var));\n-                    }\n-                    self.bccx.span_note(old_loan.span, note);\n+                                previous closure requires unique access\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                new_loan.kind.to_user_str()));\n+                }\n+\n+                (_, _) => {\n+                    self.bccx.span_err(\n+                        new_loan.span,\n+                        format!(\"cannot borrow `{}` as {} because \\\n+                                {} is also borrowed as {}\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path),\n+                                new_loan.kind.to_user_str(),\n+                                old_pronoun,\n+                                old_loan.kind.to_user_str()));\n                 }\n             }\n \n+            match new_loan.cause {\n+                ClosureCapture(span) => {\n+                    self.bccx.span_note(\n+                        span,\n+                        format!(\"borrow occurs due to use of `{}` in closure\",\n+                                self.bccx.loan_path_to_str(new_loan.loan_path)));\n+                }\n+                _ => { }\n+            }\n+\n+            let rule_summary = match old_loan.kind {\n+                ty::MutBorrow => {\n+                    format!(\"the mutable borrow prevents subsequent \\\n+                            moves, borrows, or modification of `{0}` \\\n+                            until the borrow ends\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+\n+                ty::ImmBorrow => {\n+                    format!(\"the immutable borrow prevents subsequent \\\n+                            moves or mutable borrows of `{0}` \\\n+                            until the borrow ends\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+\n+                ty::UniqueImmBorrow => {\n+                    format!(\"the unique capture prevents subsequent \\\n+                            moves or borrows of `{0}` \\\n+                            until the borrow ends\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+            };\n+\n+            let borrow_summary = match old_loan.cause {\n+                ClosureCapture(_) => {\n+                    format!(\"previous borrow of `{}` occurs here due to \\\n+                            use in closure\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+\n+                AddrOf | AutoRef | RefBinding => {\n+                    format!(\"previous borrow of `{}` occurs here\",\n+                            self.bccx.loan_path_to_str(old_loan.loan_path))\n+                }\n+            };\n+\n+            self.bccx.span_note(\n+                old_loan.span,\n+                format!(\"{}; {}\", borrow_summary, rule_summary));\n+\n             let old_loan_span = ast_map::node_span(self.tcx().items,\n                                                    old_loan.kill_scope);\n             self.bccx.span_end_note(old_loan_span,\n                                     \"previous borrow ends here\");\n+\n             return false;\n         }\n \n@@ -349,11 +421,23 @@ impl<'a> CheckLoanCtxt<'a> {\n         }\n \n         // Otherwise, just a plain error.\n-        self.bccx.span_err(\n-            expr.span,\n-            format!(\"cannot assign to {} {}\",\n-                 cmt.mutbl.to_user_str(),\n-                 self.bccx.cmt_to_str(cmt)));\n+        match opt_loan_path(cmt) {\n+            Some(lp) => {\n+                self.bccx.span_err(\n+                    expr.span,\n+                    format!(\"cannot assign to {} {} `{}`\",\n+                            cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(cmt),\n+                            self.bccx.loan_path_to_str(lp)));\n+            }\n+            None => {\n+                self.bccx.span_err(\n+                    expr.span,\n+                    format!(\"cannot assign to {} {}\",\n+                            cmt.mutbl.to_user_str(),\n+                            self.bccx.cmt_to_str(cmt)));\n+            }\n+        }\n         return;\n \n         fn mark_variable_as_used_mut(this: &CheckLoanCtxt,\n@@ -377,37 +461,34 @@ impl<'a> CheckLoanCtxt<'a> {\n                         return;\n                     }\n \n-                    mc::cat_stack_upvar(b) => {\n-                        cmt = b;\n+                    mc::cat_upvar(..) => {\n+                        return;\n                     }\n \n-                    mc::cat_deref(_, _, mc::gc_ptr) => {\n+                    mc::cat_deref(_, _, mc::GcPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McImmutable);\n                         return;\n                     }\n \n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_copied_upvar(..) |\n-                    mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-                    mc::cat_deref(_, _, mc::region_ptr(..)) => {\n+                    mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n                     }\n \n                     mc::cat_discr(b, _) |\n-                    mc::cat_deref(b, _, mc::uniq_ptr) => {\n+                    mc::cat_deref(b, _, mc::OwnedPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;\n                     }\n \n                     mc::cat_downcast(b) |\n                     mc::cat_interior(b, _) => {\n-                        if cmt.mutbl == mc::McInherited {\n-                            cmt = b;\n-                        } else {\n-                            return; // field declared as mutable or some such\n-                        }\n+                        assert_eq!(cmt.mutbl, mc::McInherited);\n+                        cmt = b;\n                     }\n                 }\n             }\n@@ -422,7 +503,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::region_ptr(ast::MutMutable, _)) => {\n+                mc::cat_deref(b, _, mc::BorrowedPtr(ty::MutBorrow, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n                     check_for_aliasability_violation(this, expr, b);\n@@ -557,7 +638,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     // with inherited mutability and with `&mut`\n                     // pointers.\n                     LpExtend(lp_base, mc::McInherited, _) |\n-                    LpExtend(lp_base, _, LpDeref(mc::region_ptr(ast::MutMutable, _))) => {\n+                    LpExtend(lp_base, _, LpDeref(mc::BorrowedPtr(ty::MutBorrow, _))) => {\n                         loan_path = lp_base;\n                     }\n \n@@ -572,9 +653,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                 // Check for a non-const loan of `loan_path`\n                 let cont = this.each_in_scope_loan(expr.id, |loan| {\n                     if loan.loan_path == loan_path {\n-                        this.report_illegal_mutation(expr,\n-                                                     full_loan_path,\n-                                                     loan);\n+                        this.report_illegal_mutation(expr, full_loan_path, loan);\n                         false\n                     } else {\n                         true\n@@ -603,9 +682,10 @@ impl<'a> CheckLoanCtxt<'a> {\n     fn check_move_out_from_expr(&self, expr: &ast::Expr) {\n         match expr.node {\n             ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-                // moves due to capture clauses are checked\n-                // in `check_loans_in_fn`, so that we can\n-                // give a better error message\n+                // Moves due to captures are checked in\n+                // check_captured_variables() because it allows\n+                // us to give a more precise error message with\n+                // a more precise span.\n             }\n             _ => {\n                 self.check_move_out_from_id(expr.id, expr.span)\n@@ -621,18 +701,59 @@ impl<'a> CheckLoanCtxt<'a> {\n                     self.bccx.span_err(\n                         span,\n                         format!(\"cannot move out of `{}` \\\n-                              because it is borrowed\",\n+                                because it is borrowed\",\n                              self.bccx.loan_path_to_str(move_path)));\n                     self.bccx.span_note(\n                         loan_span,\n                         format!(\"borrow of `{}` occurs here\",\n-                             self.bccx.loan_path_to_str(loan_path)));\n+                                self.bccx.loan_path_to_str(loan_path)));\n                 }\n             }\n             true\n         });\n     }\n \n+    fn check_captured_variables(&self,\n+                                closure_id: ast::NodeId,\n+                                span: Span) {\n+        let capture_map = self.bccx.capture_map.borrow();\n+        let cap_vars = capture_map.get().get(&closure_id);\n+        for cap_var in cap_vars.borrow().iter() {\n+            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n+            let var_path = @LpVar(var_id);\n+            self.check_if_path_is_moved(closure_id, span,\n+                                        MovedInCapture, var_path);\n+            match cap_var.mode {\n+                moves::CapRef | moves::CapCopy => {}\n+                moves::CapMove => {\n+                    check_by_move_capture(self, closure_id, cap_var, var_path);\n+                }\n+            }\n+        }\n+        return;\n+\n+        fn check_by_move_capture(this: &CheckLoanCtxt,\n+                                 closure_id: ast::NodeId,\n+                                 cap_var: &moves::CaptureVar,\n+                                 move_path: @LoanPath) {\n+            let move_err = this.analyze_move_out_from(closure_id, move_path);\n+            match move_err {\n+                MoveOk => {}\n+                MoveWhileBorrowed(loan_path, loan_span) => {\n+                    this.bccx.span_err(\n+                        cap_var.span,\n+                        format!(\"cannot move `{}` into closure \\\n+                                because it is borrowed\",\n+                                this.bccx.loan_path_to_str(move_path)));\n+                    this.bccx.span_note(\n+                        loan_span,\n+                        format!(\"borrow of `{}` occurs here\",\n+                                this.bccx.loan_path_to_str(loan_path)));\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn analyze_move_out_from(&self,\n                                  expr_id: ast::NodeId,\n                                  mut move_path: @LoanPath)\n@@ -681,67 +802,6 @@ impl<'a> CheckLoanCtxt<'a> {\n     }\n }\n \n-fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n-                         fk: &visit::FnKind,\n-                         decl: &ast::FnDecl,\n-                         body: &ast::Block,\n-                         sp: Span,\n-                         id: ast::NodeId) {\n-    match *fk {\n-        visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            // Don't process nested items.\n-            return;\n-        }\n-\n-        visit::FkFnBlock(..) => {\n-            check_captured_variables(this, id, sp);\n-        }\n-    }\n-\n-    visit::walk_fn(this, fk, decl, body, sp, id, ());\n-\n-    fn check_captured_variables(this: &CheckLoanCtxt,\n-                                closure_id: ast::NodeId,\n-                                span: Span) {\n-        let capture_map = this.bccx.capture_map.borrow();\n-        let cap_vars = capture_map.get().get(&closure_id);\n-        for cap_var in cap_vars.borrow().iter() {\n-            let var_id = ast_util::def_id_of_def(cap_var.def).node;\n-            let var_path = @LpVar(var_id);\n-            this.check_if_path_is_moved(closure_id, span,\n-                                        MovedInCapture, var_path);\n-            match cap_var.mode {\n-                moves::CapRef | moves::CapCopy => {}\n-                moves::CapMove => {\n-                    check_by_move_capture(this, closure_id, cap_var, var_path);\n-                }\n-            }\n-        }\n-        return;\n-\n-        fn check_by_move_capture(this: &CheckLoanCtxt,\n-                                 closure_id: ast::NodeId,\n-                                 cap_var: &moves::CaptureVar,\n-                                 move_path: @LoanPath) {\n-            let move_err = this.analyze_move_out_from(closure_id, move_path);\n-            match move_err {\n-                MoveOk => {}\n-                MoveWhileBorrowed(loan_path, loan_span) => {\n-                    this.bccx.span_err(\n-                        cap_var.span,\n-                        format!(\"cannot move `{}` into closure \\\n-                              because it is borrowed\",\n-                             this.bccx.loan_path_to_str(move_path)));\n-                    this.bccx.span_note(\n-                        loan_span,\n-                        format!(\"borrow of `{}` occurs here\",\n-                             this.bccx.loan_path_to_str(loan_path)));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn check_loans_in_local<'a>(this: &mut CheckLoanCtxt<'a>,\n                             local: &ast::Local) {\n     visit::walk_local(this, local, ());\n@@ -769,6 +829,9 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n               }\n           }\n       }\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n+          this.check_captured_variables(expr.id, expr.span)\n+      }\n       ast::ExprAssign(dest, _) |\n       ast::ExprAssignOp(_, _, dest, _) => {\n         this.check_assignment(dest);"}, {"sha": "49b12a6db1fb5afe8d660f1e3451308094122bc1", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -18,9 +18,8 @@ use middle::borrowck::move_data::*;\n use middle::moves;\n use middle::ty;\n use syntax::ast;\n-use syntax::ast_util;\n use syntax::codemap::Span;\n-use util::ppaux::{UserString};\n+use util::ppaux::{Repr, UserString};\n \n pub fn gather_decl(bccx: &BorrowckCtxt,\n                    move_data: &MoveData,\n@@ -35,33 +34,14 @@ pub fn gather_move_from_expr(bccx: &BorrowckCtxt,\n                              move_data: &MoveData,\n                              move_expr: &ast::Expr,\n                              cmt: mc::cmt) {\n-    gather_move_from_expr_or_pat(bccx, move_data, move_expr.id, MoveExpr, cmt);\n+    gather_move(bccx, move_data, move_expr.id, MoveExpr, cmt);\n }\n \n pub fn gather_move_from_pat(bccx: &BorrowckCtxt,\n                             move_data: &MoveData,\n                             move_pat: &ast::Pat,\n                             cmt: mc::cmt) {\n-    gather_move_from_expr_or_pat(bccx, move_data, move_pat.id, MovePat, cmt);\n-}\n-\n-fn gather_move_from_expr_or_pat(bccx: &BorrowckCtxt,\n-                                move_data: &MoveData,\n-                                move_id: ast::NodeId,\n-                                move_kind: MoveKind,\n-                                cmt: mc::cmt) {\n-    if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n-        return;\n-    }\n-\n-    match opt_loan_path(cmt) {\n-        Some(loan_path) => {\n-            move_data.add_move(bccx.tcx, loan_path, move_id, move_kind);\n-        }\n-        None => {\n-            // move from rvalue or unsafe pointer, hence ok\n-        }\n-    }\n+    gather_move(bccx, move_data, move_pat.id, MovePat, cmt);\n }\n \n pub fn gather_captures(bccx: &BorrowckCtxt,\n@@ -72,16 +52,38 @@ pub fn gather_captures(bccx: &BorrowckCtxt,\n     for captured_var in captured_vars.borrow().iter() {\n         match captured_var.mode {\n             moves::CapMove => {\n-                let fvar_id = ast_util::def_id_of_def(captured_var.def).node;\n-                let loan_path = @LpVar(fvar_id);\n-                move_data.add_move(bccx.tcx, loan_path, closure_expr.id,\n-                                   Captured);\n+                let cmt = bccx.cat_captured_var(closure_expr.id,\n+                                                closure_expr.span,\n+                                                captured_var);\n+                gather_move(bccx, move_data, closure_expr.id, Captured, cmt);\n             }\n             moves::CapCopy | moves::CapRef => {}\n         }\n     }\n }\n \n+fn gather_move(bccx: &BorrowckCtxt,\n+               move_data: &MoveData,\n+               move_id: ast::NodeId,\n+               move_kind: MoveKind,\n+               cmt: mc::cmt) {\n+    debug!(\"gather_move(move_id={}, cmt={})\",\n+           move_id, cmt.repr(bccx.tcx));\n+\n+    if !check_is_legal_to_move_from(bccx, cmt, cmt) {\n+        return;\n+    }\n+\n+    match opt_loan_path(cmt) {\n+        Some(loan_path) => {\n+            move_data.add_move(bccx.tcx, loan_path, move_id, move_kind);\n+        }\n+        None => {\n+            // move from rvalue or unsafe pointer, hence ok\n+        }\n+    }\n+}\n+\n pub fn gather_assignment(bccx: &BorrowckCtxt,\n                          move_data: &MoveData,\n                          assignment_id: ast::NodeId,\n@@ -99,15 +101,15 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n-        mc::cat_deref(_, _, mc::region_ptr(..)) |\n-        mc::cat_deref(_, _, mc::gc_ptr) |\n-        mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-        mc::cat_stack_upvar(..) |\n+        mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n+        mc::cat_deref(_, _, mc::GcPtr) |\n+        mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+        mc::cat_upvar(..) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n             bccx.span_err(\n                 cmt0.span,\n                 format!(\"cannot move out of {}\",\n-                     bccx.cmt_to_str(cmt)));\n+                        bccx.cmt_to_str(cmt)));\n             false\n         }\n \n@@ -158,7 +160,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n             }\n         }\n \n-        mc::cat_deref(b, _, mc::uniq_ptr) |\n+        mc::cat_deref(b, _, mc::OwnedPtr) |\n         mc::cat_discr(b, _) => {\n             check_is_legal_to_move_from(bccx, cmt0, b)\n         }"}, {"sha": "c47affac683f4fcedddc9739bdde9e05cc4ec6d3", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -26,16 +26,19 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n                           root_scope_id: ast::NodeId,\n                           span: Span,\n+                          cause: LoanCause,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n-                          loan_mutbl: LoanMutability) -> R {\n+                          loan_kind: ty::BorrowKind)\n+                          -> Result<(),()> {\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n                                          item_scope_id: item_scope_id,\n                                          span: span,\n+                                         cause: cause,\n                                          loan_region: loan_region,\n-                                         loan_mutbl: loan_mutbl,\n+                                         loan_kind: loan_kind,\n                                          cmt_original: cmt,\n                                          root_scope_id: root_scope_id};\n     ctxt.check(cmt, None)\n@@ -55,8 +58,9 @@ struct GuaranteeLifetimeContext<'a> {\n     root_scope_id: ast::NodeId,\n \n     span: Span,\n+    cause: LoanCause,\n     loan_region: ty::Region,\n-    loan_mutbl: LoanMutability,\n+    loan_kind: ty::BorrowKind,\n     cmt_original: mc::cmt\n }\n \n@@ -76,21 +80,18 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_copied_upvar(..) |                  // L-Local\n             mc::cat_local(..) |                         // L-Local\n             mc::cat_arg(..) |                           // L-Local\n-            mc::cat_deref(_, _, mc::region_ptr(..)) |   // L-Deref-Borrowed\n-            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n+            mc::cat_upvar(..) |\n+            mc::cat_deref(_, _, mc::BorrowedPtr(..)) |  // L-Deref-Borrowed\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n                 let scope = self.scope(cmt);\n                 self.check_scope(scope)\n             }\n \n-            mc::cat_stack_upvar(cmt) => {\n-                self.check(cmt, discr_scope)\n-            }\n-\n             mc::cat_static_item => {\n                 Ok(())\n             }\n \n-            mc::cat_deref(base, derefs, mc::gc_ptr) => {\n+            mc::cat_deref(base, derefs, mc::GcPtr) => {\n                 let base_scope = self.scope(base);\n \n                 // L-Deref-Managed-Imm-User-Root\n@@ -112,7 +113,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr) |     // L-Deref-Send\n+            mc::cat_deref(base, _, mc::OwnedPtr) |     // L-Deref-Send\n             mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }\n@@ -269,12 +270,12 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_rvalue(..) |\n             mc::cat_static_item |\n             mc::cat_copied_upvar(..) |\n-            mc::cat_deref(..) => {\n+            mc::cat_deref(..) |\n+            mc::cat_upvar(..) => {\n                 false\n             }\n             r @ mc::cat_downcast(..) |\n             r @ mc::cat_interior(..) |\n-            r @ mc::cat_stack_upvar(..) |\n             r @ mc::cat_discr(..) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n@@ -294,6 +295,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_rvalue(temp_scope) => {\n                 temp_scope\n             }\n+            mc::cat_upvar(..) |\n             mc::cat_copied_upvar(_) => {\n                 ty::ReScope(self.item_scope_id)\n             }\n@@ -304,28 +306,26 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             mc::cat_arg(local_id) => {\n                 ty::ReScope(self.bccx.tcx.region_maps.var_scope(local_id))\n             }\n-            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n                 ty::ReStatic\n             }\n-            mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n+            mc::cat_deref(_, _, mc::BorrowedPtr(_, r)) => {\n                 r\n             }\n             mc::cat_downcast(cmt) |\n-            mc::cat_deref(cmt, _, mc::uniq_ptr) |\n-            mc::cat_deref(cmt, _, mc::gc_ptr) |\n+            mc::cat_deref(cmt, _, mc::OwnedPtr) |\n+            mc::cat_deref(cmt, _, mc::GcPtr) |\n             mc::cat_interior(cmt, _) |\n-            mc::cat_stack_upvar(cmt) |\n             mc::cat_discr(cmt, _) => {\n                 self.scope(cmt)\n             }\n         }\n     }\n \n     fn report_error(&self, code: bckerr_code) {\n-        self.bccx.report(BckError {\n-            cmt: self.cmt_original,\n-            span: self.span,\n-            code: code\n-        });\n+        self.bccx.report(BckError { cmt: self.cmt_original,\n+                                    span: self.span,\n+                                    cause: self.cause,\n+                                    code: code });\n     }\n }"}, {"sha": "c6a77988bced91dbee36b5a8ec24bf4827682cef", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 166, "deletions": 130, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -16,10 +16,10 @@\n // their associated scopes.  In phase two, checking loans, we will then make\n // sure that all of these loans are honored.\n \n-\n use middle::borrowck::*;\n use middle::borrowck::move_data::MoveData;\n use mc = middle::mem_categorization;\n+use middle::moves;\n use middle::pat_util;\n use middle::ty::{ty_region};\n use middle::ty;\n@@ -28,6 +28,7 @@ use util::ppaux::{Repr};\n \n use std::cell::RefCell;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::ast_util::IdRange;\n use syntax::codemap::Span;\n use syntax::print::pprust;\n@@ -127,22 +128,15 @@ fn add_pat_to_id_range(this: &mut GatherLoanCtxt,\n     visit::walk_pat(this, p, ());\n }\n \n-fn gather_loans_in_fn(this: &mut GatherLoanCtxt, fk: &FnKind,\n-                      decl: &ast::FnDecl, body: &ast::Block,\n-                      sp: Span, id: ast::NodeId) {\n-    match fk {\n-        &visit::FkItemFn(..) | &visit::FkMethod(..) => {\n-            fail!(\"cannot occur, due to visit_item override\");\n-        }\n-\n-        // Visit closures as part of the containing item.\n-        &visit::FkFnBlock(..) => {\n-            this.push_repeating_id(body.id);\n-            visit::walk_fn(this, fk, decl, body, sp, id, ());\n-            this.pop_repeating_id(body.id);\n-            this.gather_fn_arg_patterns(decl, body);\n-        }\n-    }\n+fn gather_loans_in_fn(_v: &mut GatherLoanCtxt,\n+                      _fk: &FnKind,\n+                      _decl: &ast::FnDecl,\n+                      _body: &ast::Block,\n+                      _sp: Span,\n+                      _id: ast::NodeId) {\n+    // Do not visit closures or fn items here, the outer loop in\n+    // borrowck/mod will visit them for us in turn.\n+    return;\n }\n \n fn gather_loans_in_block(this: &mut GatherLoanCtxt,\n@@ -232,8 +226,9 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n             this.guarantee_valid(ex.id,\n                                  ex.span,\n                                  base_cmt,\n-                                 LoanMutability::from_ast_mutability(mutbl),\n-                                 scope_r);\n+                                 mutbl,\n+                                 scope_r,\n+                                 AddrOf);\n         }\n         visit::walk_expr(this, ex, ());\n       }\n@@ -278,8 +273,9 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           this.guarantee_valid(arg.id,\n                                arg.span,\n                                arg_cmt,\n-                               ImmutableMutability,\n-                               scope_r);\n+                               ast::MutImmutable,\n+                               scope_r,\n+                               AutoRef);\n           visit::walk_expr(this, ex, ());\n       }\n \n@@ -305,6 +301,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n \n       ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n           gather_moves::gather_captures(this.bccx, &this.move_data, ex);\n+          this.guarantee_captures(ex);\n           visit::walk_expr(this, ex, ());\n       }\n \n@@ -367,49 +364,48 @@ impl<'a> GatherLoanCtxt<'a> {\n                 ty::AutoDerefRef {\n                     autoref: Some(ref autoref),\n                     autoderefs: autoderefs}) => {\n-                let mcx = &mc::mem_categorization_ctxt {\n-                    tcx: self.tcx(),\n-                    method_map: self.bccx.method_map};\n-                let cmt = mcx.cat_expr_autoderefd(expr, autoderefs);\n+                let mut mc = self.bccx.mc();\n+                let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n+                    Ok(v) => v,\n+                    Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n+                };\n                 debug!(\"after autoderef, cmt={}\", cmt.repr(self.tcx()));\n \n                 match *autoref {\n                     ty::AutoPtr(r, m) => {\n-                        let loan_mutability =\n-                            LoanMutability::from_ast_mutability(m);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt,\n-                                             loan_mutability,\n-                                             r)\n+                                             m,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n-                        let cmt_index = mcx.cat_index(expr, cmt, autoderefs+1);\n-                        let loan_mutability =\n-                            LoanMutability::from_ast_mutability(m);\n+                        let cmt_index = mc.cat_index(expr, cmt, autoderefs+1);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_index,\n-                                             loan_mutability,\n-                                             r)\n+                                             m,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoBorrowFn(r) => {\n-                        let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n+                        let cmt_deref = mc.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             ImmutableMutability,\n-                                             r)\n+                                             ast::MutImmutable,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoBorrowObj(r, m) => {\n-                        let cmt_deref = mcx.cat_deref_fn_or_obj(expr, cmt, 0);\n-                        let loan_mutability =\n-                            LoanMutability::from_ast_mutability(m);\n+                        let cmt_deref = mc.cat_deref_fn_or_obj(expr, cmt, 0);\n                         self.guarantee_valid(expr.id,\n                                              expr.span,\n                                              cmt_deref,\n-                                             loan_mutability,\n-                                             r)\n+                                             m,\n+                                             r,\n+                                             AutoRef)\n                     }\n                     ty::AutoUnsafe(_) => {}\n                 }\n@@ -421,22 +417,71 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    // Guarantees that addr_of(cmt) will be valid for the duration of\n-    // `static_scope_r`, or reports an error.  This may entail taking\n-    // out loans, which will be added to the `req_loan_map`.  This can\n-    // also entail \"rooting\" GC'd pointers, which means ensuring\n-    // dynamically that they are not freed.\n+    fn guarantee_captures(&mut self,\n+                          closure_expr: &ast::Expr) {\n+        let capture_map = self.bccx.capture_map.borrow();\n+        let captured_vars = capture_map.get().get(&closure_expr.id);\n+        for captured_var in captured_vars.borrow().iter() {\n+            match captured_var.mode {\n+                moves::CapCopy | moves::CapMove => { continue; }\n+                moves::CapRef => { }\n+            }\n+\n+            let var_id = ast_util::def_id_of_def(captured_var.def).node;\n+            let var_cmt = self.bccx.cat_captured_var(closure_expr.id,\n+                                                     closure_expr.span,\n+                                                     captured_var);\n+\n+            // Lookup the kind of borrow the callee requires\n+            let upvar_id = ty::UpvarId { var_id: var_id,\n+                                         closure_expr_id: closure_expr.id };\n+            let upvar_borrow_map = self.tcx().upvar_borrow_map.borrow();\n+            let upvar_borrow = upvar_borrow_map.get().get_copy(&upvar_id);\n+\n+            self.guarantee_valid_kind(closure_expr.id,\n+                                      closure_expr.span,\n+                                      var_cmt,\n+                                      upvar_borrow.kind,\n+                                      upvar_borrow.region,\n+                                      ClosureCapture(captured_var.span));\n+        }\n+    }\n+\n     pub fn guarantee_valid(&mut self,\n                            borrow_id: ast::NodeId,\n                            borrow_span: Span,\n                            cmt: mc::cmt,\n-                           req_mutbl: LoanMutability,\n-                           loan_region: ty::Region) {\n+                           req_mutbl: ast::Mutability,\n+                           loan_region: ty::Region,\n+                           cause: LoanCause) {\n+        self.guarantee_valid_kind(borrow_id,\n+                                  borrow_span,\n+                                  cmt,\n+                                  ty::BorrowKind::from_mutbl(req_mutbl),\n+                                  loan_region,\n+                                  cause);\n+    }\n+\n+    fn guarantee_valid_kind(&mut self,\n+                            borrow_id: ast::NodeId,\n+                            borrow_span: Span,\n+                            cmt: mc::cmt,\n+                            req_kind: ty::BorrowKind,\n+                            loan_region: ty::Region,\n+                            cause: LoanCause) {\n+        /*!\n+         * Guarantees that `addr_of(cmt)` will be valid for the duration of\n+         * `static_scope_r`, or reports an error.  This may entail taking\n+         * out loans, which will be added to the `req_loan_map`.  This can\n+         * also entail \"rooting\" GC'd pointers, which means ensuring\n+         * dynamically that they are not freed.\n+         */\n+\n         debug!(\"guarantee_valid(borrow_id={:?}, cmt={}, \\\n                 req_mutbl={:?}, loan_region={:?})\",\n                borrow_id,\n                cmt.repr(self.tcx()),\n-               req_mutbl,\n+               req_kind,\n                loan_region);\n \n         // a loan for the empty region can never be dereferenced, so\n@@ -450,26 +495,28 @@ impl<'a> GatherLoanCtxt<'a> {\n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n         if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n-                                        borrow_span, cmt, loan_region,\n-                                        req_mutbl).is_err() {\n+                                        borrow_span, cause, cmt, loan_region,\n+                                        req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        if check_mutability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+        if check_mutability(self.bccx, borrow_span, cause,\n+                            cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Check that we don't allow mutable borrows of aliasable data.\n-        if check_aliasability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+        if check_aliasability(self.bccx, borrow_span, cause,\n+                              cmt, req_kind).is_err() {\n             return; // reported an error, no sense in reporting more.\n         }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n-            self.bccx, borrow_span,\n-            cmt, loan_region, self.restriction_set(req_mutbl));\n+            self.bccx, borrow_span, cause,\n+            cmt, loan_region, self.restriction_set(req_kind));\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -512,7 +559,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                 let kill_scope = self.compute_kill_scope(loan_scope, loan_path);\n                 debug!(\"kill_scope = {:?}\", kill_scope);\n \n-                if req_mutbl == MutableMutability {\n+                if req_kind == ty::MutBorrow {\n                     self.mark_loan_path_as_mutated(loan_path);\n                 }\n \n@@ -521,11 +568,12 @@ impl<'a> GatherLoanCtxt<'a> {\n                     index: all_loans.get().len(),\n                     loan_path: loan_path,\n                     cmt: cmt,\n-                    mutbl: req_mutbl,\n+                    kind: req_kind,\n                     gen_scope: gen_scope,\n                     kill_scope: kill_scope,\n                     span: borrow_span,\n-                    restrictions: restrictions\n+                    restrictions: restrictions,\n+                    cause: cause,\n                 }\n             }\n         };\n@@ -568,23 +616,33 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         fn check_mutability(bccx: &BorrowckCtxt,\n                             borrow_span: Span,\n+                            cause: LoanCause,\n                             cmt: mc::cmt,\n-                            req_mutbl: LoanMutability) -> Result<(),()> {\n+                            req_kind: ty::BorrowKind)\n+                            -> Result<(),()> {\n             //! Implements the M-* rules in doc.rs.\n \n-            match req_mutbl {\n-                ImmutableMutability => {\n-                    // both imm and mut data can be lent as imm;\n-                    // for mutable data, this is a freeze\n-                    Ok(())\n+            match req_kind {\n+                ty::UniqueImmBorrow | ty::ImmBorrow => {\n+                    match cmt.mutbl {\n+                        // I am intentionally leaving this here to help\n+                        // refactoring if, in the future, we should add new\n+                        // kinds of mutability.\n+                        mc::McImmutable | mc::McDeclared | mc::McInherited => {\n+                            // both imm and mut data can be lent as imm;\n+                            // for mutable data, this is a freeze\n+                            Ok(())\n+                        }\n+                    }\n                 }\n \n-                MutableMutability => {\n+                ty::MutBorrow => {\n                     // Only mutable data can be lent as mutable.\n                     if !cmt.mutbl.is_mutable() {\n-                        Err(bccx.report(BckError {span: borrow_span,\n-                                                  cmt: cmt,\n-                                                  code: err_mutbl(req_mutbl)}))\n+                        Err(bccx.report(BckError { span: borrow_span,\n+                                                   cause: cause,\n+                                                   cmt: cmt,\n+                                                   code: err_mutbl }))\n                     } else {\n                         Ok(())\n                     }\n@@ -594,18 +652,18 @@ impl<'a> GatherLoanCtxt<'a> {\n \n         fn check_aliasability(bccx: &BorrowckCtxt,\n                               borrow_span: Span,\n+                              loan_cause: LoanCause,\n                               cmt: mc::cmt,\n-                              req_mutbl: LoanMutability) -> Result<(),()> {\n+                              req_kind: ty::BorrowKind)\n+                              -> Result<(),()> {\n             //! Implements the A-* rules in doc.rs.\n \n-            match req_mutbl {\n-                ImmutableMutability => {\n-                    // both imm and mut data can be lent as imm;\n-                    // for mutable data, this is a freeze\n+            match req_kind {\n+                ty::ImmBorrow => {\n                     Ok(())\n                 }\n \n-                MutableMutability => {\n+                ty::UniqueImmBorrow | ty::MutBorrow => {\n                     // Check for those cases where we cannot control\n                     // the aliasing and make sure that we are not\n                     // being asked to.\n@@ -620,11 +678,11 @@ impl<'a> GatherLoanCtxt<'a> {\n                             // unsafe. At your own peril and all that.\n                             Ok(())\n                         }\n-                        Some(cause) => {\n+                        Some(alias_cause) => {\n                             bccx.report_aliasability_violation(\n                                 borrow_span,\n-                                BorrowViolation,\n-                                cause);\n+                                BorrowViolation(loan_cause),\n+                                alias_cause);\n                             Err(())\n                         }\n                     }\n@@ -633,11 +691,18 @@ impl<'a> GatherLoanCtxt<'a> {\n         }\n     }\n \n-    pub fn restriction_set(&self, req_mutbl: LoanMutability)\n-                           -> RestrictionSet {\n-        match req_mutbl {\n-            ImmutableMutability => RESTR_MUTATE | RESTR_CLAIM,\n-            MutableMutability => RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE,\n+    fn restriction_set(&self, req_kind: ty::BorrowKind) -> RestrictionSet {\n+        match req_kind {\n+            // If borrowing data as immutable, no mutation allowed:\n+            ty::ImmBorrow => RESTR_MUTATE,\n+\n+            // If borrowing data as mutable, no mutation nor other\n+            // borrows allowed:\n+            ty::MutBorrow => RESTR_MUTATE | RESTR_FREEZE,\n+\n+            // If borrowing data as unique imm, no mutation nor other\n+            // borrows allowed:\n+            ty::UniqueImmBorrow => RESTR_MUTATE | RESTR_FREEZE,\n         }\n     }\n \n@@ -719,11 +784,11 @@ impl<'a> GatherLoanCtxt<'a> {\n          * `gather_pat()`.\n          */\n \n-        let mc_ctxt = self.bccx.mc_ctxt();\n+        let mut mc = self.bccx.mc();\n         for arg in decl.inputs.iter() {\n             let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n \n-            let arg_cmt = mc_ctxt.cat_rvalue(\n+            let arg_cmt = mc.cat_rvalue(\n                 arg.id,\n                 arg.pat.span,\n                 ty::ReScope(body.id), // Args live only as long as the fn body.\n@@ -735,7 +800,7 @@ impl<'a> GatherLoanCtxt<'a> {\n \n     fn gather_pat(&mut self,\n                   discr_cmt: mc::cmt,\n-                  root_pat: &ast::Pat,\n+                  root_pat: @ast::Pat,\n                   arm_match_ids: Option<(ast::NodeId, ast::NodeId)>) {\n         /*!\n          * Walks patterns, examining the bindings to determine if they\n@@ -774,13 +839,12 @@ impl<'a> GatherLoanCtxt<'a> {\n                             }\n                         }\n                     };\n-                    let loan_mutability =\n-                        LoanMutability::from_ast_mutability(mutbl);\n                     self.guarantee_valid(pat.id,\n                                          pat.span,\n                                          cmt_discr,\n-                                         loan_mutability,\n-                                         scope_r);\n+                                         mutbl,\n+                                         scope_r,\n+                                         RefBinding);\n                   }\n                   ast::BindByValue(_) => {\n                       // No borrows here, but there may be moves\n@@ -797,14 +861,15 @@ impl<'a> GatherLoanCtxt<'a> {\n                   // original vector.  This is effectively a borrow of\n                   // the elements of the vector being matched.\n \n-                  let slice_ty = ty::node_id_to_type(self.tcx(),\n-                                                     slice_pat.id);\n-                  let (slice_mutbl, slice_r) =\n-                      self.vec_slice_info(slice_pat, slice_ty);\n-                  let mcx = self.bccx.mc_ctxt();\n-                  let cmt_index = mcx.cat_index(slice_pat, cmt, 0);\n-                  let slice_loan_mutability =\n-                    LoanMutability::from_ast_mutability(slice_mutbl);\n+                  let (slice_cmt, slice_borrow_kind, slice_r) = {\n+                      match self.bccx.mc().cat_slice_pattern(cmt, slice_pat) {\n+                          Ok(v) => v,\n+                          Err(()) => {\n+                              self.tcx().sess.span_bug(slice_pat.span,\n+                                                       \"Err from mc\")\n+                          }\n+                      }\n+                  };\n \n                   // Note: We declare here that the borrow occurs upon\n                   // entering the `[...]` pattern. This implies that\n@@ -823,45 +888,16 @@ impl<'a> GatherLoanCtxt<'a> {\n                   // trans do the right thing, and it would only work\n                   // for `~` vectors. It seems simpler to just require\n                   // that people call `vec.pop()` or `vec.unshift()`.\n-                  self.guarantee_valid(pat.id,\n-                                       pat.span,\n-                                       cmt_index,\n-                                       slice_loan_mutability,\n-                                       slice_r);\n+                  self.guarantee_valid(pat.id, pat.span,\n+                                       slice_cmt, slice_borrow_kind, slice_r,\n+                                       RefBinding);\n               }\n \n               _ => {}\n             }\n         })\n     }\n \n-    pub fn vec_slice_info(&self, pat: &ast::Pat, slice_ty: ty::t)\n-                          -> (ast::Mutability, ty::Region) {\n-        /*!\n-         *\n-         * In a pattern like [a, b, ..c], normally `c` has slice type,\n-         * but if you have [a, b, ..ref c], then the type of `ref c`\n-         * will be `&&[]`, so to extract the slice details we have\n-         * to recurse through rptrs.\n-         */\n-\n-        match ty::get(slice_ty).sty {\n-            ty::ty_vec(slice_mt, ty::vstore_slice(slice_r)) => {\n-                (slice_mt.mutbl, slice_r)\n-            }\n-\n-            ty::ty_rptr(_, ref mt) => {\n-                self.vec_slice_info(pat, mt.ty)\n-            }\n-\n-            _ => {\n-                self.tcx().sess.span_bug(\n-                    pat.span,\n-                    format!(\"type of slice pattern is not a slice\"));\n-            }\n-        }\n-    }\n-\n     pub fn pat_is_binding(&self, pat: &ast::Pat) -> bool {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }"}, {"sha": "575119ba6904b34933032277c803acfcbc564ada", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -16,8 +16,8 @@ use std::vec;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{MutImmutable, MutMutable};\n use syntax::codemap::Span;\n+use util::ppaux::Repr;\n \n pub enum RestrictionResult {\n     Safe,\n@@ -26,12 +26,14 @@ pub enum RestrictionResult {\n \n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n+                            cause: LoanCause,\n                             cmt: mc::cmt,\n                             loan_region: ty::Region,\n                             restr: RestrictionSet) -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n+        cause: cause,\n         cmt_original: cmt,\n         loan_region: loan_region,\n     };\n@@ -47,12 +49,17 @@ struct RestrictionsContext<'a> {\n     span: Span,\n     cmt_original: mc::cmt,\n     loan_region: ty::Region,\n+    cause: LoanCause,\n }\n \n impl<'a> RestrictionsContext<'a> {\n     fn restrict(&self,\n                 cmt: mc::cmt,\n                 restrictions: RestrictionSet) -> RestrictionResult {\n+        debug!(\"restrict(cmt={}, restrictions={})\",\n+               cmt.repr(self.bccx.tcx),\n+               restrictions.repr(self.bccx.tcx));\n+\n         match cmt.cat {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n@@ -64,7 +71,8 @@ impl<'a> RestrictionsContext<'a> {\n             }\n \n             mc::cat_local(local_id) |\n-            mc::cat_arg(local_id) => {\n+            mc::cat_arg(local_id) |\n+            mc::cat_upvar(ty::UpvarId {var_id: local_id, ..}, _) => {\n                 // R-Variable\n                 let lp = @LpVar(local_id);\n                 SafeIf(lp, ~[Restriction {loan_path: lp,\n@@ -77,7 +85,7 @@ impl<'a> RestrictionsContext<'a> {\n                 // could cause the type of the memory to change.\n                 self.restrict(\n                     cmt_base,\n-                    restrictions | RESTR_MUTATE | RESTR_CLAIM)\n+                    restrictions | RESTR_MUTATE)\n             }\n \n             mc::cat_interior(cmt_base, i) => {\n@@ -90,15 +98,15 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpInterior(i), restrictions)\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::uniq_ptr) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::OwnedPtr) => {\n                 // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n                 // would cause the unique pointer to be freed.\n                 let result = self.restrict(\n                     cmt_base,\n-                    restrictions | RESTR_MUTATE | RESTR_CLAIM);\n+                    restrictions | RESTR_MUTATE);\n                 self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n@@ -107,12 +115,14 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, mc::region_ptr(MutImmutable, lt)) => {\n+            mc::cat_deref(cmt_base, _, mc::BorrowedPtr(ty::ImmBorrow, lt)) |\n+            mc::cat_deref(cmt_base, _, mc::BorrowedPtr(ty::UniqueImmBorrow, lt)) => {\n                 // R-Deref-Imm-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {\n                     self.bccx.report(\n                         BckError {\n                             span: self.span,\n+                            cause: self.cause,\n                             cmt: cmt_base,\n                             code: err_borrowed_pointer_too_short(\n                                 self.loan_region, lt, restrictions)});\n@@ -121,17 +131,18 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::gc_ptr) => {\n+            mc::cat_deref(_, _, mc::GcPtr) => {\n                 // R-Deref-Imm-Managed\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::BorrowedPtr(ty::MutBorrow, lt)) => {\n                 // R-Deref-Mut-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {\n                     self.bccx.report(\n                         BckError {\n                             span: self.span,\n+                            cause: self.cause,\n                             cmt: cmt_base,\n                             code: err_borrowed_pointer_too_short(\n                                 self.loan_region, lt, restrictions)});\n@@ -142,12 +153,11 @@ impl<'a> RestrictionsContext<'a> {\n                 self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n-            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n                 // We are very trusting when working with unsafe pointers.\n                 Safe\n             }\n \n-            mc::cat_stack_upvar(cmt_base) |\n             mc::cat_discr(cmt_base, _) => {\n                 self.restrict(cmt_base, restrictions)\n             }"}, {"sha": "acc8ece85f8d8cce8051dc8c0f9edaaf308ce385", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 207, "deletions": 153, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -120,41 +120,32 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                body: &ast::Block,\n                sp: Span,\n                id: ast::NodeId) {\n-    match fk {\n-        &visit::FkFnBlock(..) => {\n-            // Closures are checked as part of their containing fn item.\n-        }\n-\n-        &visit::FkItemFn(..) | &visit::FkMethod(..) => {\n-            debug!(\"borrowck_fn(id={:?})\", id);\n-\n-            // Check the body of fn items.\n-            let (id_range, all_loans, move_data) =\n-                gather_loans::gather_loans(this, decl, body);\n-\n-            let all_loans = all_loans.borrow();\n-            let mut loan_dfcx = DataFlowContext::new(this.tcx,\n-                                                     this.method_map,\n-                                                     LoanDataFlowOperator,\n-                                                     id_range,\n-                                                     all_loans.get().len());\n-            for (loan_idx, loan) in all_loans.get().iter().enumerate() {\n-                loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n-                loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n-            }\n-\n-            loan_dfcx.propagate(body);\n-\n-            let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                              this.tcx,\n-                                                              this.method_map,\n-                                                              id_range,\n-                                                              body);\n-\n-            check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                                     *all_loans.get(), body);\n-        }\n-    }\n+    debug!(\"borrowck_fn(id={})\", id);\n+\n+    // Check the body of fn items.\n+    let (id_range, all_loans, move_data) =\n+        gather_loans::gather_loans(this, decl, body);\n+    let all_loans = all_loans.borrow();\n+    let mut loan_dfcx =\n+        DataFlowContext::new(this.tcx,\n+                             this.method_map,\n+                             LoanDataFlowOperator,\n+                             id_range,\n+                             all_loans.get().len());\n+    for (loan_idx, loan) in all_loans.get().iter().enumerate() {\n+        loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n+        loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n+    }\n+    loan_dfcx.propagate(body);\n+\n+    let flowed_moves = move_data::FlowedMoveData::new(move_data,\n+                                                      this.tcx,\n+                                                      this.method_map,\n+                                                      id_range,\n+                                                      body);\n+\n+    check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n+                             *all_loans.get(), body);\n \n     visit::walk_fn(this, fk, decl, body, sp, id, ());\n }\n@@ -211,41 +202,25 @@ pub enum PartialTotal {\n ///////////////////////////////////////////////////////////////////////////\n // Loans and loan paths\n \n-#[deriving(Clone, Eq)]\n-pub enum LoanMutability {\n-    ImmutableMutability,\n-    MutableMutability,\n-}\n-\n-impl LoanMutability {\n-    pub fn from_ast_mutability(ast_mutability: ast::Mutability)\n-                               -> LoanMutability {\n-        match ast_mutability {\n-            ast::MutImmutable => ImmutableMutability,\n-            ast::MutMutable => MutableMutability,\n-        }\n-    }\n-}\n-\n-impl ToStr for LoanMutability {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ImmutableMutability => ~\"immutable\",\n-            MutableMutability => ~\"mutable\",\n-        }\n-    }\n-}\n-\n /// Record of a loan that was issued.\n pub struct Loan {\n     index: uint,\n     loan_path: @LoanPath,\n     cmt: mc::cmt,\n-    mutbl: LoanMutability,\n+    kind: ty::BorrowKind,\n     restrictions: ~[Restriction],\n     gen_scope: ast::NodeId,\n     kill_scope: ast::NodeId,\n     span: Span,\n+    cause: LoanCause,\n+}\n+\n+#[deriving(Eq)]\n+pub enum LoanCause {\n+    ClosureCapture(Span),\n+    AddrOf,\n+    AutoRef,\n+    RefBinding,\n }\n \n #[deriving(Eq, IterBytes)]\n@@ -283,7 +258,9 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n             None\n         }\n \n-        mc::cat_local(id) | mc::cat_arg(id) => {\n+        mc::cat_local(id) |\n+        mc::cat_arg(id) |\n+        mc::cat_upvar(ty::UpvarId {var_id: id, ..}, _) => {\n             Some(@LpVar(id))\n         }\n \n@@ -300,7 +277,6 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n         }\n \n         mc::cat_downcast(cmt_base) |\n-        mc::cat_stack_upvar(cmt_base) |\n         mc::cat_discr(cmt_base, _) => {\n             opt_loan_path(cmt_base)\n         }\n@@ -313,8 +289,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // Borrowing an lvalue often results in *restrictions* that limit what\n // can be done with this lvalue during the scope of the loan:\n //\n-// - `RESTR_MUTATE`: The lvalue may not be modified.\n-// - `RESTR_CLAIM`: `&mut` borrows of the lvalue are forbidden.\n+// - `RESTR_MUTATE`: The lvalue may not be modified or `&mut` borrowed.\n // - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n //\n // In addition, no value which is restricted may be moved. Therefore,\n@@ -333,8 +308,7 @@ pub struct RestrictionSet {\n \n pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n-pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n-pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n+pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0010};\n \n impl RestrictionSet {\n     pub fn intersects(&self, restr: RestrictionSet) -> bool {\n@@ -358,6 +332,12 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n     }\n }\n \n+impl Repr for RestrictionSet {\n+    fn repr(&self, _tcx: ty::ctxt) -> ~str {\n+        format!(\"RestrictionSet(0x{:x})\", self.bits as uint)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Rooting of managed boxes\n //\n@@ -393,10 +373,9 @@ pub fn root_map() -> root_map {\n // Errors that can occur\n #[deriving(Eq)]\n pub enum bckerr_code {\n-    err_mutbl(LoanMutability),\n+    err_mutbl,\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_freeze_aliasable_const,\n     err_borrowed_pointer_too_short(\n         ty::Region, ty::Region, RestrictionSet), // loan, ptr\n }\n@@ -406,13 +385,14 @@ pub enum bckerr_code {\n #[deriving(Eq)]\n pub struct BckError {\n     span: Span,\n+    cause: LoanCause,\n     cmt: mc::cmt,\n     code: bckerr_code\n }\n \n pub enum AliasableViolationKind {\n     MutabilityViolation,\n-    BorrowViolation\n+    BorrowViolation(LoanCause)\n }\n \n pub enum MovedValueUseKind {\n@@ -439,29 +419,55 @@ impl BorrowckCtxt {\n         moves_map.get().contains(&id)\n     }\n \n+    pub fn mc(&self) -> mc::MemCategorizationContext<TcxTyper> {\n+        mc::MemCategorizationContext {\n+            typer: TcxTyper {\n+                tcx: self.tcx,\n+                method_map: self.method_map\n+            }\n+        }\n+    }\n+\n     pub fn cat_expr(&self, expr: &ast::Expr) -> mc::cmt {\n-        mc::cat_expr(self.tcx, self.method_map, expr)\n+        match self.mc().cat_expr(expr) {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n+            }\n+        }\n     }\n \n     pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> mc::cmt {\n-        mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+        match self.mc().cat_expr_unadjusted(expr) {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(expr.span, \"error in mem categorization\");\n+            }\n+        }\n     }\n \n     pub fn cat_expr_autoderefd(&self,\n                                expr: &ast::Expr,\n                                adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n-        match *adj {\n+        let r = match *adj {\n             ty::AutoAddEnv(..) | ty::AutoObject(..) => {\n                 // no autoderefs\n-                mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n+                self.mc().cat_expr_unadjusted(expr)\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, ..}) => {\n-                mc::cat_expr_autoderefd(self.tcx, self.method_map, expr,\n-                                        autoderefs)\n+                self.mc().cat_expr_autoderefd(expr, autoderefs)\n+            }\n+        };\n+\n+        match r {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(expr.span,\n+                                       \"error in mem categorization\");\n             }\n         }\n     }\n@@ -472,7 +478,23 @@ impl BorrowckCtxt {\n                    ty: ty::t,\n                    def: ast::Def)\n                    -> mc::cmt {\n-        mc::cat_def(self.tcx, self.method_map, id, span, ty, def)\n+        match self.mc().cat_def(id, span, ty, def) {\n+            Ok(c) => c,\n+            Err(()) => {\n+                self.tcx.sess.span_bug(span, \"error in mem categorization\");\n+            }\n+        }\n+    }\n+\n+    pub fn cat_captured_var(&self,\n+                            id: ast::NodeId,\n+                            span: Span,\n+                            captured_var: &moves::CaptureVar) -> mc::cmt {\n+        // Create the cmt for the variable being borrowed, from the\n+        // caller's perspective\n+        let var_id = ast_util::def_id_of_def(captured_var.def).node;\n+        let var_ty = ty::node_id_to_type(self.tcx, var_id);\n+        self.cat_def(id, span, var_ty, captured_var.def)\n     }\n \n     pub fn cat_discr(&self, cmt: mc::cmt, match_id: ast::NodeId) -> mc::cmt {\n@@ -481,17 +503,12 @@ impl BorrowckCtxt {\n                    ..*cmt}\n     }\n \n-    pub fn mc_ctxt(&self) -> mc::mem_categorization_ctxt {\n-        mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                     method_map: self.method_map}\n-    }\n-\n     pub fn cat_pattern(&self,\n                        cmt: mc::cmt,\n-                       pat: &ast::Pat,\n+                       pat: @ast::Pat,\n                        op: |mc::cmt, &ast::Pat|) {\n-        let mc = self.mc_ctxt();\n-        mc.cat_pattern(cmt, pat, op);\n+        let r = self.mc().cat_pattern(cmt, pat, |_,x,y| op(x,y));\n+        assert!(r.is_ok());\n     }\n \n     pub fn report(&self, err: BckError) {\n@@ -622,24 +639,35 @@ impl BorrowckCtxt {\n \n     pub fn bckerr_to_str(&self, err: BckError) -> ~str {\n         match err.code {\n-            err_mutbl(lk) => {\n-                format!(\"cannot borrow {} {} as {}\",\n-                     err.cmt.mutbl.to_user_str(),\n-                     self.cmt_to_str(err.cmt),\n-                     self.mut_to_str(lk))\n+            err_mutbl => {\n+                let descr = match opt_loan_path(err.cmt) {\n+                    None => format!(\"{} {}\",\n+                                    err.cmt.mutbl.to_user_str(),\n+                                    self.cmt_to_str(err.cmt)),\n+                    Some(lp) => format!(\"{} {} `{}`\",\n+                                        err.cmt.mutbl.to_user_str(),\n+                                        self.cmt_to_str(err.cmt),\n+                                        self.loan_path_to_str(lp)),\n+                };\n+\n+                match err.cause {\n+                    ClosureCapture(_) => {\n+                        format!(\"closure cannot assign to {}\", descr)\n+                    }\n+                    AddrOf | RefBinding | AutoRef => {\n+                        format!(\"cannot borrow {} as mutable\", descr)\n+                    }\n+                }\n             }\n             err_out_of_root_scope(..) => {\n                 format!(\"cannot root managed value long enough\")\n             }\n             err_out_of_scope(..) => {\n-                format!(\"borrowed value does not live long enough\")\n-            }\n-            err_freeze_aliasable_const => {\n-                // Means that the user borrowed a ~T or enum value\n-                // residing in &const or @const pointer.  Terrible\n-                // error message, but then &const and @const are\n-                // supposed to be going away.\n-                format!(\"unsafe borrow of aliasable, const value\")\n+                let msg = match opt_loan_path(err.cmt) {\n+                    None => format!(\"borrowed value\"),\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                };\n+                format!(\"{} does not live long enough\", msg)\n             }\n             err_borrowed_pointer_too_short(..) => {\n                 let descr = match opt_loan_path(err.cmt) {\n@@ -659,8 +687,24 @@ impl BorrowckCtxt {\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason) {\n         let prefix = match kind {\n-            MutabilityViolation => \"cannot assign to data\",\n-            BorrowViolation => \"cannot borrow data mutably\"\n+            MutabilityViolation => {\n+                \"cannot assign to data\"\n+            }\n+            BorrowViolation(ClosureCapture(_)) => {\n+                // I don't think we can get aliasability violations\n+                // with closure captures, so no need to come up with a\n+                // good error message. The reason this cannot happen\n+                // is because we only capture local variables in\n+                // closures, and those are never aliasable.\n+                self.tcx.sess.span_bug(\n+                    span,\n+                    \"aliasability violation with closure\");\n+            }\n+            BorrowViolation(AddrOf) |\n+            BorrowViolation(AutoRef) |\n+            BorrowViolation(RefBinding) => {\n+                \"cannot borrow data mutably\"\n+            }\n         };\n \n         match cause {\n@@ -680,7 +724,7 @@ impl BorrowckCtxt {\n                     span,\n                     format!(\"{} in a `@` pointer\", prefix));\n             }\n-            mc::AliasableBorrowed(_) => {\n+            mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in a `&` reference\", prefix));\n@@ -691,7 +735,7 @@ impl BorrowckCtxt {\n     pub fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n-            err_mutbl(..) | err_freeze_aliasable_const(..) => {}\n+            err_mutbl(..) => { }\n \n             err_out_of_root_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n@@ -738,52 +782,16 @@ impl BorrowckCtxt {\n         }\n     }\n \n-    pub fn append_loan_path_to_str_from_interior(&self,\n-                                                 loan_path: &LoanPath,\n-                                                 out: &mut ~str) {\n-        match *loan_path {\n-            LpExtend(_, _, LpDeref(_)) => {\n-                out.push_char('(');\n-                self.append_loan_path_to_str(loan_path, out);\n-                out.push_char(')');\n-            }\n-            LpExtend(_, _, LpInterior(_)) |\n-            LpVar(_) => {\n-                self.append_loan_path_to_str(loan_path, out);\n-            }\n-        }\n-    }\n-\n     pub fn append_loan_path_to_str(&self,\n                                    loan_path: &LoanPath,\n                                    out: &mut ~str) {\n         match *loan_path {\n             LpVar(id) => {\n-                match self.tcx.items.find(id) {\n-                    Some(ast_map::NodeLocal(pat)) => {\n-                        match pat.node {\n-                            ast::PatIdent(_, ref path, _) => {\n-                                let ident = ast_util::path_to_ident(path);\n-                                let string = token::get_ident(ident.name);\n-                                out.push_str(string.get());\n-                            }\n-                            _ => {\n-                                self.tcx.sess.bug(\n-                                    format!(\"loan path LpVar({:?}) maps to {:?}, not local\",\n-                                        id, pat));\n-                            }\n-                        }\n-                    }\n-                    r => {\n-                        self.tcx.sess.bug(\n-                            format!(\"loan path LpVar({:?}) maps to {:?}, not local\",\n-                                 id, r));\n-                    }\n-                }\n+                out.push_str(ty::local_var_name_str(self.tcx, id).get());\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n-                self.append_loan_path_to_str_from_interior(lp_base, out);\n+                self.append_autoderefd_loan_path_to_str(lp_base, out);\n                 match fname {\n                     mc::NamedField(ref fname) => {\n                         let string = token::get_ident(*fname);\n@@ -798,8 +806,8 @@ impl BorrowckCtxt {\n             }\n \n             LpExtend(lp_base, _, LpInterior(mc::InteriorElement(_))) => {\n-                self.append_loan_path_to_str_from_interior(lp_base, out);\n-                out.push_str(\"[]\");\n+                self.append_autoderefd_loan_path_to_str(lp_base, out);\n+                out.push_str(\"[..]\");\n             }\n \n             LpExtend(lp_base, _, LpDeref(_)) => {\n@@ -809,20 +817,35 @@ impl BorrowckCtxt {\n         }\n     }\n \n+    pub fn append_autoderefd_loan_path_to_str(&self,\n+                                              loan_path: &LoanPath,\n+                                              out: &mut ~str) {\n+        match *loan_path {\n+            LpExtend(lp_base, _, LpDeref(_)) => {\n+                // For a path like `(*x).f` or `(*x)[3]`, autoderef\n+                // rules would normally allow users to omit the `*x`.\n+                // So just serialize such paths to `x.f` or x[3]` respectively.\n+                self.append_autoderefd_loan_path_to_str(lp_base, out)\n+            }\n+\n+            LpVar(..) | LpExtend(_, _, LpInterior(..)) => {\n+                self.append_loan_path_to_str(loan_path, out)\n+            }\n+        }\n+    }\n+\n     pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n         let mut result = ~\"\";\n         self.append_loan_path_to_str(loan_path, &mut result);\n         result\n     }\n \n     pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {\n-        let mc = &mc::mem_categorization_ctxt {tcx: self.tcx,\n-                                               method_map: self.method_map};\n-        mc.cmt_to_str(cmt)\n+        self.mc().cmt_to_str(cmt)\n     }\n \n-    pub fn mut_to_str(&self, mutbl: LoanMutability) -> ~str {\n-        mutbl.to_str()\n+    pub fn mut_to_str(&self, mutbl: ast::Mutability) -> ~str {\n+        self.mc().mut_to_str(mutbl)\n     }\n \n     pub fn mut_to_keyword(&self, mutbl: ast::Mutability) -> &'static str {\n@@ -843,19 +866,14 @@ impl DataFlowOperator for LoanDataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // loans from both preds are in scope\n     }\n-\n-    #[inline]\n-    fn walk_closures(&self) -> bool {\n-        true\n-    }\n }\n \n impl Repr for Loan {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         format!(\"Loan_{:?}({}, {:?}, {:?}-{:?}, {})\",\n              self.index,\n              self.loan_path.repr(tcx),\n-             self.mutbl,\n+             self.kind,\n              self.gen_scope,\n              self.kill_scope,\n              self.restrictions.repr(tcx))\n@@ -890,3 +908,39 @@ impl Repr for LoanPath {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+\n+struct TcxTyper {\n+    tcx: ty::ctxt,\n+    method_map: typeck::method_map,\n+}\n+\n+impl mc::Typer for TcxTyper {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.tcx\n+    }\n+\n+    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        Ok(ty::node_id_to_type(self.tcx, id))\n+    }\n+\n+    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n+        let adjustments = self.tcx.adjustments.borrow();\n+        adjustments.get().find_copy(&id)\n+    }\n+\n+    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+        let method_map = self.method_map.borrow();\n+        method_map.get().contains_key(&id)\n+    }\n+\n+    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.tcx.region_maps.temporary_scope(id)\n+    }\n+\n+    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+        let upvar_borrow_map = self.tcx.upvar_borrow_map.borrow();\n+        upvar_borrow_map.get().get_copy(&id)\n+    }\n+}"}, {"sha": "34efcacc44b0611fe3735283a05f66db2b142ae5", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -722,11 +722,6 @@ impl DataFlowOperator for MoveDataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n-\n-    #[inline]\n-    fn walk_closures(&self) -> bool {\n-        true\n-    }\n }\n \n impl DataFlowOperator for AssignDataFlowOperator {\n@@ -739,9 +734,4 @@ impl DataFlowOperator for AssignDataFlowOperator {\n     fn join(&self, succ: uint, pred: uint) -> uint {\n         succ | pred // moves from both preds are in scope\n     }\n-\n-    #[inline]\n-    fn walk_closures(&self) -> bool {\n-        true\n-    }\n }"}, {"sha": "5af5aa63e1de66f7e009447eddb829076e70e42a", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 23, "deletions": 120, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -17,7 +17,6 @@\n  */\n \n \n-use std::cast;\n use std::io;\n use std::uint;\n use std::vec;\n@@ -72,9 +71,6 @@ pub trait DataFlowOperator {\n \n     /// Joins two predecessor bits together, typically either `|` or `&`\n     fn join(&self, succ: uint, pred: uint) -> uint;\n-\n-    /// True if we should propagate through closures\n-    fn walk_closures(&self) -> bool;\n }\n \n struct PropagationContext<'a, O> {\n@@ -373,8 +369,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                   blk: &ast::Block,\n                   in_out: &mut [uint],\n                   loop_scopes: &mut ~[LoopScope]) {\n-        debug!(\"DataFlowContext::walk_block(blk.id={:?}, in_out={})\",\n-               blk.id, bits_to_str(reslice(in_out)));\n+        debug!(\"DataFlowContext::walk_block(blk.id={}, in_out={})\",\n+               blk.id, bits_to_str(in_out));\n \n         self.merge_with_entry_set(blk.id, in_out);\n \n@@ -425,99 +421,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                  in_out: &mut [uint],\n                  loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_expr(expr={}, in_out={})\",\n-               expr.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+               expr.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n         self.merge_with_entry_set(expr.id, in_out);\n \n         match expr.node {\n-            ast::ExprFnBlock(ref decl, body) |\n-            ast::ExprProc(ref decl, body) => {\n-                if self.dfcx.oper.walk_closures() {\n-                    // In the absence of once fns, we must assume that\n-                    // every function body will execute more than\n-                    // once. Thus we treat every function body like a\n-                    // loop.\n-                    //\n-                    // What is subtle and a bit tricky, also, is how\n-                    // to deal with the \"output\" bits---that is, what\n-                    // do we consider to be the successor of a\n-                    // function body, given that it could be called\n-                    // from any point within its lifetime? What we do\n-                    // is to add their effects immediately as of the\n-                    // point of creation. Of course we have to ensure\n-                    // that this is sound for the analyses which make\n-                    // use of dataflow.\n-                    //\n-                    // In the case of the initedness checker (which\n-                    // does not currently use dataflow, but I hope to\n-                    // convert at some point), we will simply not walk\n-                    // closures at all, so it's a moot point.\n-                    //\n-                    // In the case of the borrow checker, this means\n-                    // the loans which would be created by calling a\n-                    // function come into effect immediately when the\n-                    // function is created. This is guaranteed to be\n-                    // earlier than the point at which the loan\n-                    // actually comes into scope (which is the point\n-                    // at which the closure is *called*). Because\n-                    // loans persist until the scope of the loans is\n-                    // exited, it is always a safe approximation to\n-                    // have a loan begin earlier than it actually will\n-                    // at runtime, so this should be sound.\n-                    //\n-                    // We stil have to be careful in the region\n-                    // checker and borrow checker to treat function\n-                    // bodies like loops, which implies some\n-                    // limitations. For example, a closure cannot root\n-                    // a managed box for longer than its body.\n-                    //\n-                    // General control flow looks like this:\n-                    //\n-                    //  +- (expr) <----------+\n-                    //  |    |               |\n-                    //  |    v               |\n-                    //  |  (body) -----------+--> (exit)\n-                    //  |    |               |\n-                    //  |    + (break/loop) -+\n-                    //  |                    |\n-                    //  +--------------------+\n-                    //\n-                    // This is a bit more conservative than a loop.\n-                    // Note that we must assume that even after a\n-                    // `break` occurs (e.g., in a `for` loop) that the\n-                    // closure may be reinvoked.\n-                    //\n-                    // One difference from other loops is that `loop`\n-                    // and `break` statements which target a closure\n-                    // both simply add to the `break_bits`.\n-\n-                    // func_bits represents the state when the function\n-                    // returns\n-                    let mut func_bits = reslice(in_out).to_owned();\n-\n-                    loop_scopes.push(LoopScope {\n-                        loop_id: expr.id,\n-                        break_bits: reslice(in_out).to_owned()\n-                    });\n-                    for input in decl.inputs.iter() {\n-                        self.walk_pat(input.pat, func_bits, loop_scopes);\n-                    }\n-                    self.walk_block(body, func_bits, loop_scopes);\n-\n-                    // add the bits from any early return via `break`,\n-                    // `continue`, or `return` into `func_bits`\n-                    let loop_scope = loop_scopes.pop().unwrap();\n-                    join_bits(&self.dfcx.oper, loop_scope.break_bits, func_bits);\n-\n-                    // add `func_bits` to the entry bits for `expr`,\n-                    // since we must assume the function may be called\n-                    // more than once\n-                    self.add_to_entry_set(expr.id, reslice(func_bits));\n-\n-                    // the final exit bits include whatever was present\n-                    // in the original, joined with the bits from the function\n-                    join_bits(&self.dfcx.oper, func_bits, in_out);\n-                }\n+            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n             }\n \n             ast::ExprIf(cond, then, els) => {\n@@ -536,7 +445,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 //\n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut then_bits = reslice(in_out).to_owned();\n+                let mut then_bits = in_out.to_owned();\n                 self.walk_block(then, then_bits, loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n@@ -558,10 +467,10 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut body_bits = reslice(in_out).to_owned();\n+                let mut body_bits = in_out.to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: reslice(in_out).to_owned()\n+                    break_bits: in_out.to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -581,11 +490,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 //    <--+ (break)\n                 //\n \n-                let mut body_bits = reslice(in_out).to_owned();\n+                let mut body_bits = in_out.to_owned();\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: reslice(in_out).to_owned()\n+                    break_bits: in_out.to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -609,7 +518,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 //\n                 self.walk_expr(discr, in_out, loop_scopes);\n \n-                let mut guards = reslice(in_out).to_owned();\n+                let mut guards = in_out.to_owned();\n \n                 // We know that exactly one arm will be taken, so we\n                 // can start out with a blank slate and just union\n@@ -622,7 +531,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n-                    let mut body = reslice(guards).to_owned();\n+                    let mut body = guards.to_owned();\n                     self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n                     self.walk_block(arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n@@ -643,7 +552,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             ast::ExprAgain(label) => {\n                 let scope = self.find_scope(expr, label, loop_scopes);\n                 self.pop_scopes(expr, scope, in_out);\n-                self.add_to_entry_set(scope.loop_id, reslice(in_out));\n+                self.add_to_entry_set(scope.loop_id, in_out);\n                 self.reset(in_out);\n             }\n \n@@ -693,7 +602,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n             ast::ExprBinary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n-                let temp = reslice(in_out).to_owned();\n+                let temp = in_out.to_owned();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n@@ -756,7 +665,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n         debug!(\"pop_scopes(from_expr={}, to_scope={:?}, in_out={})\",\n                from_expr.repr(tcx), to_scope.loop_id,\n-               bits_to_str(reslice(in_out)));\n+               bits_to_str(in_out));\n \n         let mut id = from_expr.id;\n         while id != to_scope.loop_id {\n@@ -781,11 +690,11 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                      in_out: &mut [uint]) {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n-        join_bits(&self.dfcx.oper, reslice(in_out), to_scope.break_bits);\n-        debug!(\"break_from_to(from_expr={}, to_scope={:?}) final break_bits={}\",\n+        join_bits(&self.dfcx.oper, in_out, to_scope.break_bits);\n+        debug!(\"break_from_to(from_expr={}, to_scope={}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n-               bits_to_str(reslice(in_out)));\n+               bits_to_str(in_out));\n     }\n \n     fn walk_exprs(&mut self,\n@@ -830,10 +739,10 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 in_out: &mut [uint],\n                 _loop_scopes: &mut ~[LoopScope]) {\n         debug!(\"DataFlowContext::walk_pat(pat={}, in_out={})\",\n-               pat.repr(self.dfcx.tcx), bits_to_str(reslice(in_out)));\n+               pat.repr(self.dfcx.tcx), bits_to_str(in_out));\n \n         ast_util::walk_pat(pat, |p| {\n-            debug!(\"  p.id={:?} in_out={}\", p.id, bits_to_str(reslice(in_out)));\n+            debug!(\"  p.id={} in_out={}\", p.id, bits_to_str(in_out));\n             self.merge_with_entry_set(p.id, in_out);\n             self.dfcx.apply_gen_kill(p.id, in_out);\n             true\n@@ -852,7 +761,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         // In the general case, the patterns in `pats` are\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n-        let initial_state = reslice(in_out).to_owned();\n+        let initial_state = in_out.to_owned();\n         for &pat in pats.iter() {\n             let mut temp = initial_state.clone();\n             self.walk_pat(pat, temp, loop_scopes);\n@@ -929,8 +838,8 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         let (start, end) = self.dfcx.compute_id_range(id);\n         let changed = { // FIXME(#5074) awkward construction\n             let on_entry = self.dfcx.on_entry.mut_slice(start, end);\n-            let changed = join_bits(&self.dfcx.oper, reslice(pred_bits), on_entry);\n-            copy_bits(reslice(on_entry), pred_bits);\n+            let changed = join_bits(&self.dfcx.oper, pred_bits, on_entry);\n+            copy_bits(on_entry, pred_bits);\n             changed\n         };\n         if changed {\n@@ -942,7 +851,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n }\n \n fn mut_bits_to_str(words: &mut [uint]) -> ~str {\n-    bits_to_str(reslice(words))\n+    bits_to_str(words)\n }\n \n fn bits_to_str(words: &[uint]) -> ~str {\n@@ -1007,9 +916,3 @@ fn bit_str(bit: uint) -> ~str {\n     format!(\"[{}:{}-{:02x}]\", bit, byte, lobits)\n }\n \n-fn reslice<'a>(v: &'a mut [uint]) -> &'a [uint] {\n-    // bFIXME(#5074) this function should not be necessary at all\n-    unsafe {\n-        cast::transmute(v)\n-    }\n-}"}, {"sha": "efd19cf73c0abd555f1ef16317409d38279d03db", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 380, "deletions": 243, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -22,7 +22,7 @@\n  * forms):\n  *\n  *     E = rvalue    // some computed rvalue\n- *       | x         // address of a local variable, arg, or upvar\n+ *       | x         // address of a local variable or argument\n  *       | *E        // deref of a ptr\n  *       | E.comp    // access to an interior component\n  *\n@@ -44,13 +44,25 @@\n  * themselves.  For example, auto-derefs are explicit.  Also, an index a[b] is\n  * decomposed into two operations: a derefence to reach the array data and\n  * then an index to jump forward to the relevant item.\n+ *\n+ * ## By-reference upvars\n+ *\n+ * One part of the translation which may be non-obvious is that we translate\n+ * closure upvars into the dereference of a borrowed pointer; this more closely\n+ * resembles the runtime translation. So, for example, if we had:\n+ *\n+ *     let mut x = 3;\n+ *     let y = 5;\n+ *     let inc = || x += y;\n+ *\n+ * Then when we categorize `x` (*within* the closure) we would yield a\n+ * result of `*x'`, effectively, where `x'` is a `cat_upvar` reference\n+ * tied to `x`. The type of `x'` will be a borrowed pointer.\n  */\n \n \n use middle::ty;\n-use middle::typeck;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n-use util::common::indenter;\n \n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n@@ -63,15 +75,15 @@ pub enum categorization {\n     cat_rvalue(ty::Region),            // temporary val, argument is its scope\n     cat_static_item,\n     cat_copied_upvar(CopiedUpvar),     // upvar copied into @fn or ~fn env\n-    cat_stack_upvar(cmt),              // by ref upvar from ||\n+    cat_upvar(ty::UpvarId, ty::UpvarBorrow), // by ref upvar from stack closure\n     cat_local(ast::NodeId),            // local variable\n     cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n-    cat_downcast(cmt),                 // selects a particular enum variant (..)\n+    cat_downcast(cmt),                 // selects a particular enum variant (*1)\n     cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())\n \n-    // (..) downcast is only required if the enum has more than one variant\n+    // (*1) downcast is only required if the enum has more than one variant\n }\n \n #[deriving(Eq)]\n@@ -83,10 +95,10 @@ pub struct CopiedUpvar {\n // different kinds of pointers:\n #[deriving(Eq, IterBytes)]\n pub enum PointerKind {\n-    uniq_ptr,\n-    gc_ptr,\n-    region_ptr(ast::Mutability, ty::Region),\n-    unsafe_ptr(ast::Mutability)\n+    OwnedPtr,\n+    GcPtr,\n+    BorrowedPtr(ty::BorrowKind, ty::Region),\n+    UnsafePtr(ast::Mutability),\n }\n \n // We use the term \"interior\" to mean \"something reachable from the\n@@ -114,7 +126,7 @@ pub enum ElementKind {\n pub enum MutabilityCategory {\n     McImmutable, // Immutable.\n     McDeclared,  // Directly declared as mutable.\n-    McInherited  // Inherited from the fact that owner is mutable.\n+    McInherited, // Inherited from the fact that owner is mutable.\n }\n \n // `cmt`: \"Category, Mutability, and Type\".\n@@ -159,30 +171,32 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         ty::ty_vec(_, ty::vstore_uniq) |\n         ty::ty_str(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n-            Some(deref_ptr(uniq_ptr))\n+            Some(deref_ptr(OwnedPtr))\n         }\n \n         ty::ty_rptr(r, mt) |\n         ty::ty_vec(mt, ty::vstore_slice(r)) => {\n-            Some(deref_ptr(region_ptr(mt.mutbl, r)))\n+            let kind = ty::BorrowKind::from_mutbl(mt.mutbl);\n+            Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n         ty::ty_trait(_, _, ty::RegionTraitStore(r), m, _) => {\n-            Some(deref_ptr(region_ptr(m, r)))\n+            let kind = ty::BorrowKind::from_mutbl(m);\n+            Some(deref_ptr(BorrowedPtr(kind, r)))\n         }\n \n         ty::ty_str(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, ..}) => {\n-            Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n+            Some(deref_ptr(BorrowedPtr(ty::ImmBorrow, r)))\n         }\n \n-        ty::ty_box(_) => {\n-            Some(deref_ptr(gc_ptr))\n+        ty::ty_box(..) => {\n+            Some(deref_ptr(GcPtr))\n         }\n \n         ty::ty_ptr(ref mt) => {\n-            Some(deref_ptr(unsafe_ptr(mt.mutbl)))\n+            Some(deref_ptr(UnsafePtr(mt.mutbl)))\n         }\n \n         ty::ty_enum(..) |\n@@ -210,53 +224,7 @@ pub fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n     }\n }\n \n-pub fn cat_expr(tcx: ty::ctxt,\n-                method_map: typeck::method_map,\n-                expr: &ast::Expr)\n-             -> cmt {\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_expr(expr);\n-}\n-\n-pub fn cat_expr_unadjusted(tcx: ty::ctxt,\n-                           method_map: typeck::method_map,\n-                           expr: &ast::Expr)\n-                        -> cmt {\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_expr_unadjusted(expr);\n-}\n-\n-pub fn cat_expr_autoderefd(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr: &ast::Expr,\n-    autoderefs: uint) -> cmt\n-{\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_expr_autoderefd(expr, autoderefs);\n-}\n-\n-pub fn cat_def(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    expr_id: ast::NodeId,\n-    expr_span: Span,\n-    expr_ty: ty::t,\n-    def: ast::Def) -> cmt {\n-\n-    let mcx = &mem_categorization_ctxt {\n-        tcx: tcx, method_map: method_map\n-    };\n-    return mcx.cat_def(expr_id, expr_span, expr_ty, def);\n-}\n-\n-pub trait ast_node {\n+trait ast_node {\n     fn id(&self) -> ast::NodeId;\n     fn span(&self) -> Span;\n }\n@@ -271,9 +239,37 @@ impl ast_node for ast::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-pub struct mem_categorization_ctxt {\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n+pub struct MemCategorizationContext<TYPER> {\n+    typer: TYPER\n+}\n+\n+pub type McResult<T> = Result<T, ()>;\n+\n+/**\n+ * The `Typer` trait provides the interface for the mem-categorization\n+ * module to the results of the type check. It can be used to query\n+ * the type assigned to an expression node, to inquire after adjustments,\n+ * and so on.\n+ *\n+ * This interface is needed because mem-categorization is used from\n+ * two places: `regionck` and `borrowck`. `regionck` executes before\n+ * type inference is complete, and hence derives types and so on from\n+ * intermediate tables.  This also implies that type errors can occur,\n+ * and hence `node_ty()` and friends return a `Result` type -- any\n+ * error will propagate back up through the mem-categorization\n+ * routines.\n+ *\n+ * In the borrow checker, in contrast, type checking is complete and we\n+ * know that no errors have occurred, so we simply consult the tcx and we\n+ * can be sure that only `Ok` results will occur.\n+ */\n+pub trait Typer {\n+    fn tcx(&self) -> ty::ctxt;\n+    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n+    fn adjustment(&mut self, node_id: ast::NodeId) -> Option<@ty::AutoAdjustment>;\n+    fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n+    fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n+    fn upvar_borrow(&mut self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n }\n \n impl ToStr for MutabilityCategory {\n@@ -290,18 +286,45 @@ impl MutabilityCategory {\n         }\n     }\n \n+    pub fn from_borrow_kind(borrow_kind: ty::BorrowKind) -> MutabilityCategory {\n+        match borrow_kind {\n+            ty::ImmBorrow => McImmutable,\n+            ty::UniqueImmBorrow => McImmutable,\n+            ty::MutBorrow => McDeclared,\n+        }\n+    }\n+\n+    pub fn from_pointer_kind(base_mutbl: MutabilityCategory,\n+                             ptr: PointerKind) -> MutabilityCategory {\n+        match ptr {\n+            OwnedPtr => {\n+                base_mutbl.inherit()\n+            }\n+            BorrowedPtr(borrow_kind, _) => {\n+                MutabilityCategory::from_borrow_kind(borrow_kind)\n+            }\n+            GcPtr => {\n+                McImmutable\n+            }\n+            UnsafePtr(m) => {\n+                MutabilityCategory::from_mutbl(m)\n+            }\n+        }\n+    }\n+\n     pub fn inherit(&self) -> MutabilityCategory {\n         match *self {\n             McImmutable => McImmutable,\n             McDeclared => McInherited,\n-            McInherited => McInherited\n+            McInherited => McInherited,\n         }\n     }\n \n     pub fn is_mutable(&self) -> bool {\n         match *self {\n             McImmutable => false,\n-            McDeclared | McInherited => true\n+            McInherited => true,\n+            McDeclared => true,\n         }\n     }\n \n@@ -320,55 +343,78 @@ impl MutabilityCategory {\n     }\n }\n \n-impl mem_categorization_ctxt {\n-    pub fn expr_ty(&self, expr: &ast::Expr) -> ty::t {\n-        ty::expr_ty(self.tcx, expr)\n+macro_rules! if_ok(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => { v }\n+            Err(e) => { return Err(e); }\n+        }\n+    )\n+)\n+\n+impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.typer.tcx()\n+    }\n+\n+    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n+        self.typer.adjustment(id)\n+    }\n+\n+    fn expr_ty(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+        self.typer.node_ty(expr.id)\n     }\n \n-    pub fn pat_ty(&self, pat: &ast::Pat) -> ty::t {\n-        ty::node_id_to_type(self.tcx, pat.id)\n+    fn expr_ty_adjusted(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+        let unadjusted_ty = if_ok!(self.expr_ty(expr));\n+        let adjustment = self.adjustment(expr.id);\n+        Ok(ty::adjust_ty(self.tcx(), expr.span, unadjusted_ty, adjustment))\n     }\n \n-    pub fn cat_expr(&self, expr: &ast::Expr) -> cmt {\n-        let adjustments = self.tcx.adjustments.borrow();\n-        match adjustments.get().find(&expr.id) {\n+    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t> {\n+        self.typer.node_ty(id)\n+    }\n+\n+    fn pat_ty(&mut self, pat: @ast::Pat) -> McResult<ty::t> {\n+        self.typer.node_ty(pat.id)\n+    }\n+\n+    pub fn cat_expr(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n+        match self.adjustment(expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n             }\n \n             Some(adjustment) => {\n-                match **adjustment {\n+                match *adjustment {\n                     ty::AutoObject(..) => {\n                         // Implicity casts a concrete object to trait object\n                         // so just patch up the type\n-                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        @cmt_ {\n-                            ty: expr_ty,\n-                            ..*self.cat_expr_unadjusted(expr)\n-                        }\n+                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n+                        let expr_cmt = if_ok!(self.cat_expr_unadjusted(expr));\n+                        Ok(@cmt_ {ty: expr_ty, ..*expr_cmt})\n                     }\n \n                     ty::AutoAddEnv(..) => {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n-                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n-                        autoref: Some(_),\n-                    ..}) => {\n+                    ty::AutoDerefRef(\n+                        ty::AutoDerefRef {\n+                            autoref: Some(_), ..}) => {\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n-                        let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n+                        let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n+                        Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n-                            autoref: None,\n-                            autoderefs: autoderefs\n-                    }) => {\n+                    ty::AutoDerefRef(\n+                        ty::AutoDerefRef {\n+                            autoref: None, autoderefs: autoderefs}) => {\n                         // Equivalent to *expr or something similar.\n                         self.cat_expr_autoderefd(expr, autoderefs)\n                     }\n@@ -377,53 +423,51 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&self, expr: &ast::Expr, autoderefs: uint)\n-                               -> cmt {\n-        let mut cmt = self.cat_expr_unadjusted(expr);\n+    pub fn cat_expr_autoderefd(&mut self, expr: &ast::Expr, autoderefs: uint)\n+                               -> McResult<cmt> {\n+        let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         for deref in range(1u, autoderefs + 1) {\n             cmt = self.cat_deref(expr, cmt, deref);\n         }\n-        return cmt;\n+        return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> cmt {\n+    pub fn cat_expr_unadjusted(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n         debug!(\"cat_expr: id={} expr={}\",\n-               expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n+               expr.id,\n+               expr.repr(self.tcx()));\n \n-        let expr_ty = self.expr_ty(expr);\n+        let expr_ty = if_ok!(self.expr_ty(expr));\n         match expr.node {\n           ast::ExprUnary(_, ast::UnDeref, e_base) => {\n-            let method_map = self.method_map.borrow();\n-            if method_map.get().contains_key(&expr.id) {\n-                return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n+            if self.typer.is_method_call(expr.id) {\n+                return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n \n-            let base_cmt = self.cat_expr(e_base);\n-            self.cat_deref(expr, base_cmt, 0)\n+            let base_cmt = if_ok!(self.cat_expr(e_base));\n+            Ok(self.cat_deref(expr, base_cmt, 0))\n           }\n \n           ast::ExprField(base, f_name, _) => {\n             // Method calls are now a special syntactic form,\n             // so `a.b` should always be a field.\n-            let method_map = self.method_map.borrow();\n-            assert!(!method_map.get().contains_key(&expr.id));\n+            assert!(!self.typer.is_method_call(expr.id));\n \n-            let base_cmt = self.cat_expr(base);\n-            self.cat_field(expr, base_cmt, f_name, self.expr_ty(expr))\n+            let base_cmt = if_ok!(self.cat_expr(base));\n+            Ok(self.cat_field(expr, base_cmt, f_name, expr_ty))\n           }\n \n           ast::ExprIndex(_, base, _) => {\n-            let method_map = self.method_map.borrow();\n-            if method_map.get().contains_key(&expr.id) {\n-                return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n+            if self.typer.is_method_call(expr.id) {\n+                return Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty));\n             }\n \n-            let base_cmt = self.cat_expr(base);\n-            self.cat_index(expr, base_cmt, 0)\n+            let base_cmt = if_ok!(self.cat_expr(base));\n+            Ok(self.cat_index(expr, base_cmt, 0))\n           }\n \n           ast::ExprPath(_) => {\n-            let def_map = self.tcx.def_map.borrow();\n+            let def_map = self.tcx().def_map.borrow();\n             let def = def_map.get().get_copy(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n@@ -441,49 +485,48 @@ impl mem_categorization_ctxt {\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n-            return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n+            Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n \n           ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n-    pub fn cat_def(&self,\n+    pub fn cat_def(&mut self,\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n                    def: ast::Def)\n-                   -> cmt {\n+                   -> McResult<cmt> {\n         debug!(\"cat_def: id={} expr={}\",\n-               id, ty_to_str(self.tcx, expr_ty));\n-\n+               id, expr_ty.repr(self.tcx()));\n \n         match def {\n           ast::DefStruct(..) | ast::DefVariant(..) => {\n-                self.cat_rvalue_node(id, span, expr_ty)\n+                Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           ast::DefFn(..) | ast::DefStaticMethod(..) | ast::DefMod(_) |\n           ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n           ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n           ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n           ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n-              @cmt_ {\n+              Ok(@cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McImmutable,\n                   ty:expr_ty\n-              }\n+              })\n           }\n \n           ast::DefStatic(_, true) => {\n-              @cmt_ {\n+              Ok(@cmt_ {\n                   id:id,\n                   span:span,\n                   cat:cat_static_item,\n                   mutbl: McDeclared,\n                   ty:expr_ty\n-              }\n+              })\n           }\n \n           ast::DefArg(vid, binding_mode) => {\n@@ -495,17 +538,17 @@ impl mem_categorization_ctxt {\n                 ast::BindByValue(ast::MutMutable) => McDeclared,\n                 _ => McImmutable\n             };\n-            @cmt_ {\n+            Ok(@cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_arg(vid),\n                 mutbl: m,\n                 ty:expr_ty\n-            }\n+            })\n           }\n \n-          ast::DefUpvar(upvar_id, inner, fn_node_id, _) => {\n-              let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n+          ast::DefUpvar(var_id, _, fn_node_id, _) => {\n+              let ty = if_ok!(self.node_ty(fn_node_id));\n               match ty::get(ty).sty {\n                   ty::ty_closure(ref closure_ty) => {\n                       // Decide whether to use implicit reference or by copy/move\n@@ -523,33 +566,25 @@ impl mem_categorization_ctxt {\n \n                       };\n                       if var_is_refd {\n-                          let upvar_cmt =\n-                              self.cat_def(id, span, expr_ty, *inner);\n-                          @cmt_ {\n-                              id:id,\n-                              span:span,\n-                              cat:cat_stack_upvar(upvar_cmt),\n-                              mutbl:upvar_cmt.mutbl.inherit(),\n-                              ty:upvar_cmt.ty\n-                          }\n+                          self.cat_upvar(id, span, var_id, fn_node_id)\n                       } else {\n                           // FIXME #2152 allow mutation of moved upvars\n-                          @cmt_ {\n+                          Ok(@cmt_ {\n                               id:id,\n                               span:span,\n                               cat:cat_copied_upvar(CopiedUpvar {\n-                                  upvar_id: upvar_id,\n+                                  upvar_id: var_id,\n                                   onceness: closure_ty.onceness}),\n                               mutbl:McImmutable,\n                               ty:expr_ty\n-                          }\n+                          })\n                       }\n                   }\n                   _ => {\n-                      self.tcx.sess.span_bug(\n+                      self.tcx().sess.span_bug(\n                           span,\n-                          format!(\"upvar of non-closure {:?} - {}\",\n-                               fn_node_id, ty.repr(self.tcx)));\n+                          format!(\"Upvar of non-closure {} - {}\",\n+                                  fn_node_id, ty.repr(self.tcx())));\n                   }\n               }\n           }\n@@ -562,19 +597,73 @@ impl mem_categorization_ctxt {\n                 _ => McImmutable\n             };\n \n-            @cmt_ {\n+            Ok(@cmt_ {\n                 id: id,\n                 span: span,\n                 cat: cat_local(vid),\n                 mutbl: m,\n                 ty: expr_ty\n-            }\n+            })\n           }\n         }\n     }\n \n-    pub fn cat_rvalue_node(&self, id: ast::NodeId, span: Span, expr_ty: ty::t) -> cmt {\n-        match self.tcx.region_maps.temporary_scope(id) {\n+    fn cat_upvar(&mut self,\n+                 id: ast::NodeId,\n+                 span: Span,\n+                 var_id: ast::NodeId,\n+                 fn_node_id: ast::NodeId)\n+                 -> McResult<cmt> {\n+        /*!\n+         * Upvars through a closure are in fact indirect\n+         * references. That is, when a closure refers to a\n+         * variable from a parent stack frame like `x = 10`,\n+         * that is equivalent to `*x_ = 10` where `x_` is a\n+         * borrowed pointer (`&mut x`) created when the closure\n+         * was created and store in the environment. This\n+         * equivalence is expose in the mem-categorization.\n+         */\n+\n+        let upvar_id = ty::UpvarId { var_id: var_id,\n+                                     closure_expr_id: fn_node_id };\n+\n+        let upvar_borrow = self.typer.upvar_borrow(upvar_id);\n+\n+        let var_ty = if_ok!(self.node_ty(var_id));\n+\n+        // We can't actually represent the types of all upvars\n+        // as user-describable types, since upvars support const\n+        // and unique-imm borrows! Therefore, we cheat, and just\n+        // give err type. Nobody should be inspecting this type anyhow.\n+        let upvar_ty = ty::mk_err();\n+\n+        let base_cmt = @cmt_ {\n+            id:id,\n+            span:span,\n+            cat:cat_upvar(upvar_id, upvar_borrow),\n+            mutbl:McImmutable,\n+            ty:upvar_ty,\n+        };\n+\n+        let ptr = BorrowedPtr(upvar_borrow.kind, upvar_borrow.region);\n+\n+        let deref_cmt = @cmt_ {\n+            id:id,\n+            span:span,\n+            cat:cat_deref(base_cmt, 0, ptr),\n+            mutbl:MutabilityCategory::from_borrow_kind(upvar_borrow.kind),\n+            ty:var_ty,\n+        };\n+\n+        Ok(deref_cmt)\n+    }\n+\n+    pub fn cat_rvalue_node(&mut self,\n+                           id: ast::NodeId,\n+                           span: Span,\n+                           expr_ty: ty::t)\n+                           -> cmt {\n+        match self.typer.temporary_scope(id) {\n             Some(scope) => {\n                 self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n             }\n@@ -584,7 +673,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_rvalue(&self,\n+    pub fn cat_rvalue(&mut self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n@@ -602,7 +691,7 @@ impl mem_categorization_ctxt {\n     /// component is inherited from the base it is a part of. For\n     /// example, a record field is mutable if it is declared mutable\n     /// or if the container is mutable.\n-    pub fn inherited_mutability(&self,\n+    pub fn inherited_mutability(&mut self,\n                                 base_m: MutabilityCategory,\n                                 interior_m: ast::Mutability)\n                                 -> MutabilityCategory {\n@@ -612,7 +701,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_field<N:ast_node>(&self,\n+    pub fn cat_field<N:ast_node>(&mut self,\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  f_name: ast::Ident,\n@@ -627,7 +716,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_deref_fn_or_obj<N:ast_node>(&self,\n+    pub fn cat_deref_fn_or_obj<N:ast_node>(&mut self,\n                                            node: &N,\n                                            base_cmt: cmt,\n                                            deref_cnt: uint)\n@@ -638,49 +727,40 @@ impl mem_categorization_ctxt {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let opaque_ty = ty::mk_tup(self.tcx, ~[]);\n+        let opaque_ty = ty::mk_tup(self.tcx(), ~[]);\n         return self.cat_deref_common(node, base_cmt, deref_cnt, opaque_ty);\n     }\n \n-    pub fn cat_deref<N:ast_node>(&self,\n+    pub fn cat_deref<N:ast_node>(&mut self,\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  deref_cnt: uint)\n                                  -> cmt {\n         let mt = match ty::deref(base_cmt.ty, true) {\n             Some(mt) => mt,\n             None => {\n-                self.tcx.sess.span_bug(\n+                self.tcx().sess.span_bug(\n                     node.span(),\n-                    format!(\"explicit deref of non-derefable type: {}\",\n-                         ty_to_str(self.tcx, base_cmt.ty)));\n+                    format!(\"Explicit deref of non-derefable type: {}\",\n+                            base_cmt.ty.repr(self.tcx())));\n             }\n         };\n \n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt.ty);\n     }\n \n-    pub fn cat_deref_common<N:ast_node>(&self,\n+    pub fn cat_deref_common<N:ast_node>(&mut self,\n                                         node: &N,\n                                         base_cmt: cmt,\n                                         deref_cnt: uint,\n                                         deref_ty: ty::t)\n                                         -> cmt {\n-        match deref_kind(self.tcx, base_cmt.ty) {\n+        match deref_kind(self.tcx(), base_cmt.ty) {\n             deref_ptr(ptr) => {\n                 // for unique ptrs, we inherit mutability from the\n                 // owning reference.\n-                let m = match ptr {\n-                    uniq_ptr => {\n-                        base_cmt.mutbl.inherit()\n-                    }\n-                    gc_ptr => {\n-                        McImmutable\n-                    }\n-                    region_ptr(m, _) | unsafe_ptr(m) => {\n-                        MutabilityCategory::from_mutbl(m)\n-                    }\n-                };\n+                let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl,\n+                                                              ptr);\n \n                 @cmt_ {\n                     id:node.id(),\n@@ -704,7 +784,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_index<N:ast_node>(&self,\n+    pub fn cat_index<N:ast_node>(&mut self,\n                                  elt: &N,\n                                  base_cmt: cmt,\n                                  derefs: uint)\n@@ -743,28 +823,18 @@ impl mem_categorization_ctxt {\n         let element_ty = match ty::index(base_cmt.ty) {\n           Some(ref mt) => mt.ty,\n           None => {\n-            self.tcx.sess.span_bug(\n+            self.tcx().sess.span_bug(\n                 elt.span(),\n-                format!(\"explicit index of non-index type `{}`\",\n-                     ty_to_str(self.tcx, base_cmt.ty)));\n+                format!(\"Explicit index of non-index type `{}`\",\n+                     base_cmt.ty.repr(self.tcx())));\n           }\n         };\n \n-        return match deref_kind(self.tcx, base_cmt.ty) {\n+        return match deref_kind(self.tcx(), base_cmt.ty) {\n           deref_ptr(ptr) => {\n             // for unique ptrs, we inherit mutability from the\n             // owning reference.\n-            let m = match ptr {\n-                uniq_ptr => {\n-                    base_cmt.mutbl.inherit()\n-                }\n-                gc_ptr => {\n-                    McImmutable\n-                }\n-                region_ptr(m, _) | unsafe_ptr(m) => {\n-                    MutabilityCategory::from_mutbl(m)\n-                }\n-            };\n+            let m = MutabilityCategory::from_pointer_kind(base_cmt.mutbl, ptr);\n \n             // the deref is explicit in the resulting cmt\n             let deref_cmt = @cmt_ {\n@@ -775,7 +845,7 @@ impl mem_categorization_ctxt {\n                 ty:element_ty\n             };\n \n-            interior(elt, deref_cmt, base_cmt.ty, m, element_ty)\n+            interior(elt, deref_cmt, base_cmt.ty, m.inherit(), element_ty)\n           }\n \n           deref_interior(_) => {\n@@ -801,7 +871,57 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_imm_interior<N:ast_node>(&self,\n+    pub fn cat_slice_pattern(&mut self,\n+                             vec_cmt: cmt,\n+                             slice_pat: @ast::Pat)\n+                             -> McResult<(cmt, ast::Mutability, ty::Region)> {\n+        /*!\n+         * Given a pattern P like: `[_, ..Q, _]`, where `vec_cmt` is\n+         * the cmt for `P`, `slice_pat` is the pattern `Q`, returns:\n+         * - a cmt for `Q`\n+         * - the mutability and region of the slice `Q`\n+         *\n+         * These last two bits of info happen to be things that\n+         * borrowck needs.\n+         */\n+\n+        let slice_ty = if_ok!(self.node_ty(slice_pat.id));\n+        let (slice_mutbl, slice_r) = vec_slice_info(self.tcx(),\n+                                                    slice_pat,\n+                                                    slice_ty);\n+        let cmt_slice = self.cat_index(slice_pat, vec_cmt, 0);\n+        return Ok((cmt_slice, slice_mutbl, slice_r));\n+\n+        fn vec_slice_info(tcx: ty::ctxt,\n+                          pat: @ast::Pat,\n+                          slice_ty: ty::t)\n+                          -> (ast::Mutability, ty::Region) {\n+            /*!\n+             * In a pattern like [a, b, ..c], normally `c` has slice type,\n+             * but if you have [a, b, ..ref c], then the type of `ref c`\n+             * will be `&&[]`, so to extract the slice details we have\n+             * to recurse through rptrs.\n+             */\n+\n+            match ty::get(slice_ty).sty {\n+                ty::ty_vec(slice_mt, ty::vstore_slice(slice_r)) => {\n+                    (slice_mt.mutbl, slice_r)\n+                }\n+\n+                ty::ty_rptr(_, ref mt) => {\n+                    vec_slice_info(tcx, pat, mt.ty)\n+                }\n+\n+                _ => {\n+                    tcx.sess.span_bug(\n+                        pat.span,\n+                        format!(\"Type of slice pattern is not a slice\"));\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn cat_imm_interior<N:ast_node>(&mut self,\n                                         node: &N,\n                                         base_cmt: cmt,\n                                         interior_ty: ty::t,\n@@ -816,7 +936,7 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_downcast<N:ast_node>(&self,\n+    pub fn cat_downcast<N:ast_node>(&mut self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     downcast_ty: ty::t)\n@@ -830,10 +950,13 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_pattern(&self,\n+    pub fn cat_pattern(&mut self,\n                        cmt: cmt,\n-                       pat: &ast::Pat,\n-                       op: |cmt, &ast::Pat|) {\n+                       pat: @ast::Pat,\n+                       op: |&mut MemCategorizationContext<TYPER>,\n+                            cmt,\n+                            @ast::Pat|)\n+                       -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -846,7 +969,7 @@ impl mem_categorization_ctxt {\n         // we can be sure that the binding will remain valid for the\n         // duration of the arm.\n         //\n-        // (..) There is subtlety concerning the correspondence between\n+        // (*2) There is subtlety concerning the correspondence between\n         // pattern ids and types as compared to *expression* ids and\n         // types. This is explained briefly. on the definition of the\n         // type `cmt`, so go off and read what it says there, then\n@@ -856,7 +979,8 @@ impl mem_categorization_ctxt {\n         // In general, the id of the cmt should be the node that\n         // \"produces\" the value---patterns aren't executable code\n         // exactly, but I consider them to \"execute\" when they match a\n-        // value. So if you have something like:\n+        // value, and I consider them to produce the value that was\n+        // matched. So if you have something like:\n         //\n         //     let x = @@3;\n         //     match x {\n@@ -878,13 +1002,12 @@ impl mem_categorization_ctxt {\n         // step out of sync again. So you'll see below that we always\n         // get the type of the *subpattern* and use that.\n \n-        let tcx = self.tcx;\n+        let tcx = self.tcx();\n         debug!(\"cat_pattern: id={} pat={} cmt={}\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                cmt.repr(tcx));\n-        let _i = indenter();\n \n-        op(cmt, pat);\n+        op(self, cmt, pat);\n \n         match pat.node {\n           ast::PatWild | ast::PatWildMulti => {\n@@ -895,56 +1018,56 @@ impl mem_categorization_ctxt {\n             // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n-            let def_map = self.tcx.def_map.borrow();\n+            let def_map = self.tcx().def_map.borrow();\n             match def_map.get().find(&pat.id) {\n                 Some(&ast::DefVariant(enum_did, _, _)) => {\n                     // variant(x, y, z)\n \n                     let downcast_cmt = {\n-                        if ty::enum_is_univariant(tcx, enum_did) {\n+                        if ty::enum_is_univariant(self.tcx(), enum_did) {\n                             cmt // univariant, no downcast needed\n                         } else {\n                             self.cat_downcast(pat, cmt, cmt.ty)\n                         }\n                     };\n \n                     for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(subpat); // see (..)\n+                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n                                 pat, downcast_cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n+                        if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&ast::DefFn(..)) |\n                 Some(&ast::DefStruct(..)) => {\n                     for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(subpat); // see (..)\n+                        let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n+                        if_ok!(self.cat_pattern(cmt_field, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 Some(&ast::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n-                        self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n+                        if_ok!(self.cat_pattern(cmt, subpat, |x,y,z| op(x,y,z)));\n                     }\n                 }\n                 _ => {\n-                    self.tcx.sess.span_bug(\n+                    self.tcx().sess.span_bug(\n                         pat.span,\n                         \"enum pattern didn't resolve to enum or struct\");\n                 }\n             }\n           }\n \n           ast::PatIdent(_, _, Some(subpat)) => {\n-              self.cat_pattern(cmt, subpat, op);\n+              if_ok!(self.cat_pattern(cmt, subpat, op));\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -954,52 +1077,54 @@ impl mem_categorization_ctxt {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = self.pat_ty(fp.pat); // see (..)\n+                let field_ty = if_ok!(self.pat_ty(fp.pat)); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n-                self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n+                if_ok!(self.cat_pattern(cmt_field, fp.pat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, &subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = self.pat_ty(subpat); // see (..)\n+                let subpat_ty = if_ok!(self.pat_ty(subpat)); // see (*2)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt, subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n+                if_ok!(self.cat_pattern(subcmt, subpat, |x,y,z| op(x,y,z)));\n             }\n           }\n \n           ast::PatUniq(subpat) | ast::PatRegion(subpat) => {\n             // @p1, ~p1\n             let subcmt = self.cat_deref(pat, cmt, 0);\n-            self.cat_pattern(subcmt, subpat, op);\n+            if_ok!(self.cat_pattern(subcmt, subpat, op));\n           }\n \n           ast::PatVec(ref before, slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, cmt, 0);\n               for &before_pat in before.iter() {\n-                  self.cat_pattern(elt_cmt, before_pat, |x,y| op(x,y));\n+                  if_ok!(self.cat_pattern(elt_cmt, before_pat, |x,y,z| op(x,y,z)));\n               }\n               for &slice_pat in slice.iter() {\n-                  let slice_ty = self.pat_ty(slice_pat);\n+                  let slice_ty = if_ok!(self.pat_ty(slice_pat));\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n+                  if_ok!(self.cat_pattern(slice_cmt, slice_pat, |x,y,z| op(x,y,z)));\n               }\n               for &after_pat in after.iter() {\n-                  self.cat_pattern(elt_cmt, after_pat, |x,y| op(x,y));\n+                  if_ok!(self.cat_pattern(elt_cmt, after_pat, |x,y,z| op(x,y,z)));\n               }\n           }\n \n           ast::PatLit(_) | ast::PatRange(_, _) => {\n               /*always ok*/\n           }\n         }\n+\n+        Ok(())\n     }\n \n-    pub fn mut_to_str(&self, mutbl: ast::Mutability) -> ~str {\n+    pub fn mut_to_str(&mut self, mutbl: ast::Mutability) -> ~str {\n         match mutbl {\n           MutMutable => ~\"mutable\",\n           MutImmutable => ~\"immutable\"\n@@ -1023,8 +1148,15 @@ impl mem_categorization_ctxt {\n           cat_arg(..) => {\n               ~\"argument\"\n           }\n-          cat_deref(_, _, pk) => {\n-              format!(\"dereference of {} pointer\", ptr_sigil(pk))\n+          cat_deref(base, _, pk) => {\n+              match base.cat {\n+                  cat_upvar(..) => {\n+                      format!(\"captured outer variable\")\n+                  }\n+                  _ => {\n+                      format!(\"dereference of {} pointer\", ptr_sigil(pk))\n+                  }\n+              }\n           }\n           cat_interior(_, InteriorField(NamedField(_))) => {\n               ~\"field\"\n@@ -1041,7 +1173,7 @@ impl mem_categorization_ctxt {\n           cat_interior(_, InteriorElement(OtherElement)) => {\n               ~\"indexed content\"\n           }\n-          cat_stack_upvar(_) => {\n+          cat_upvar(..) => {\n               ~\"captured outer variable\"\n           }\n           cat_discr(cmt, _) => {\n@@ -1054,7 +1186,7 @@ impl mem_categorization_ctxt {\n     }\n \n     pub fn region_to_str(&self, r: ty::Region) -> ~str {\n-        region_ptr_to_str(self.tcx, r)\n+        region_ptr_to_str(self.tcx(), r)\n     }\n }\n \n@@ -1099,7 +1231,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n \n pub enum AliasableReason {\n     AliasableManaged,\n-    AliasableBorrowed(ast::Mutability),\n+    AliasableBorrowed,\n     AliasableOther,\n     AliasableStatic,\n     AliasableStaticMut,\n@@ -1117,16 +1249,16 @@ impl cmt_ {\n             cat_copied_upvar(..) |\n             cat_local(..) |\n             cat_arg(..) |\n-            cat_deref(_, _, unsafe_ptr(..)) |\n-            cat_deref(_, _, gc_ptr) |\n-            cat_deref(_, _, region_ptr(..)) => {\n+            cat_deref(_, _, UnsafePtr(..)) |\n+            cat_deref(_, _, GcPtr(..)) |\n+            cat_deref(_, _, BorrowedPtr(..)) |\n+            cat_upvar(..) => {\n                 @self\n             }\n             cat_downcast(b) |\n-            cat_stack_upvar(b) |\n             cat_discr(b, _) |\n             cat_interior(b, _) |\n-            cat_deref(b, _, uniq_ptr) => {\n+            cat_deref(b, _, OwnedPtr) => {\n                 b.guarantor()\n             }\n         }\n@@ -1143,10 +1275,10 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            cat_deref(b, _, region_ptr(MutMutable, _)) |\n+            cat_deref(b, _, BorrowedPtr(ty::MutBorrow, _)) |\n+            cat_deref(b, _, BorrowedPtr(ty::UniqueImmBorrow, _)) |\n             cat_downcast(b) |\n-            cat_stack_upvar(b) |\n-            cat_deref(b, _, uniq_ptr) |\n+            cat_deref(b, _, OwnedPtr) |\n             cat_interior(b, _) |\n             cat_discr(b, _) => {\n                 // Aliasability depends on base cmt\n@@ -1156,8 +1288,9 @@ impl cmt_ {\n             cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n             cat_rvalue(..) |\n             cat_local(..) |\n+            cat_upvar(..) |\n             cat_arg(_) |\n-            cat_deref(_, _, unsafe_ptr(..)) => { // yes, it's aliasable, but...\n+            cat_deref(_, _, UnsafePtr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n \n@@ -1173,12 +1306,12 @@ impl cmt_ {\n                 }\n             }\n \n-            cat_deref(_, _, gc_ptr) => {\n+            cat_deref(_, _, GcPtr) => {\n                 Some(AliasableManaged)\n             }\n \n-            cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n-                Some(AliasableBorrowed(m))\n+            cat_deref(_, _, BorrowedPtr(ty::ImmBorrow, _)) => {\n+                Some(AliasableBorrowed)\n             }\n         }\n     }\n@@ -1201,12 +1334,15 @@ impl Repr for categorization {\n             cat_rvalue(..) |\n             cat_copied_upvar(..) |\n             cat_local(..) |\n+            cat_upvar(..) |\n             cat_arg(..) => {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(cmt, derefs, ptr) => {\n-                format!(\"{}->({}, {})\", cmt.cat.repr(tcx),\n-                     ptr_sigil(ptr), derefs)\n+                format!(\"{}-{}{}->\",\n+                        cmt.cat.repr(tcx),\n+                        ptr_sigil(ptr),\n+                        derefs)\n             }\n             cat_interior(cmt, interior) => {\n                 format!(\"{}.{}\",\n@@ -1216,20 +1352,21 @@ impl Repr for categorization {\n             cat_downcast(cmt) => {\n                 format!(\"{}->(enum)\", cmt.cat.repr(tcx))\n             }\n-            cat_stack_upvar(cmt) |\n             cat_discr(cmt, _) => {\n                 cmt.cat.repr(tcx)\n             }\n         }\n     }\n }\n \n-pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n+pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n     match ptr {\n-        uniq_ptr => ~\"~\",\n-        gc_ptr => ~\"@\",\n-        region_ptr(_, _) => ~\"&\",\n-        unsafe_ptr(_) => ~\"*\"\n+        OwnedPtr => \"~\",\n+        GcPtr => \"@\",\n+        BorrowedPtr(ty::ImmBorrow, _) => \"&\",\n+        BorrowedPtr(ty::MutBorrow, _) => \"&mut\",\n+        BorrowedPtr(ty::UniqueImmBorrow, _) => \"&unique\",\n+        UnsafePtr(_) => \"*\"\n     }\n }\n "}, {"sha": "fcda7cd79e4219e9da4b3ecef466fecbc0f3f040", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -36,19 +36,42 @@ use syntax::ast_util::{stmt_id};\n /**\n The region maps encode information about region relationships.\n \n-- `scope_map` maps from:\n-  - an expression to the expression or block encoding the maximum\n-    (static) lifetime of a value produced by that expression.  This is\n-    generally the innermost call, statement, match, or block.\n-  - a variable or binding id to the block in which that variable is declared.\n-- `free_region_map` maps from:\n-  - a free region `a` to a list of free regions `bs` such that\n-    `a <= b for all b in bs`\n+- `scope_map` maps from a scope id to the enclosing scope id; this is\n+  usually corresponding to the lexical nesting, though in the case of\n+  closures the parent scope is the innermost conditinal expression or repeating\n+  block\n+\n+- `var_map` maps from a variable or binding id to the block in which\n+  that variable is declared.\n+\n+- `free_region_map` maps from a free region `a` to a list of free\n+  regions `bs` such that `a <= b for all b in bs`\n   - the free region map is populated during type check as we check\n     each function. See the function `relate_free_regions` for\n     more information.\n-- `temporary_scopes` includes scopes where cleanups for temporaries occur.\n-  These are statements and loop/fn bodies.\n+\n+- `rvalue_scopes` includes entries for those expressions whose cleanup\n+  scope is larger than the default. The map goes from the expression\n+  id to the cleanup scope id. For rvalues not present in this table,\n+  the appropriate cleanup scope is the innermost enclosing statement,\n+  conditional expression, or repeating block (see `terminating_scopes`).\n+\n+- `terminating_scopes` is a set containing the ids of each statement,\n+  or conditional/repeating expression. These scopes are calling \"terminating\n+  scopes\" because, when attempting to find the scope of a temporary, by\n+  default we search up the enclosing scopes until we encounter the\n+  terminating scope. A conditional/repeating\n+  expression is one which is not guaranteed to execute exactly once\n+  upon entering the parent scope. This could be because the expression\n+  only executes conditionally, such as the expression `b` in `a && b`,\n+  or because the expression may execute many times, such as a loop\n+  body. The reason that we distinguish such expressions is that, upon\n+  exiting the parent scope, we cannot statically know how many times\n+  the expression executed, and thus if the expression creates\n+  temporaries we cannot know statically how many such temporaries we\n+  would have to cleanup. Therefore we ensure that the temporaries never\n+  outlast the conditional/repeating expression, preventing the need\n+  for dynamic checks and/or arbitrary amounts of stack space.\n */\n pub struct RegionMaps {\n     priv scope_map: RefCell<HashMap<ast::NodeId, ast::NodeId>>,\n@@ -840,7 +863,16 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n             Context {parent: None, var_parent: None, ..cx}\n         }\n-        visit::FkFnBlock(..) => cx\n+        visit::FkFnBlock(..) => {\n+            // FIXME(#3696) -- at present we are place the closure body\n+            // within the region hierarchy exactly where it appears lexically.\n+            // This is wrong because the closure may live longer\n+            // than the enclosing expression. We should probably fix this,\n+            // but the correct fix is a bit subtle, and I am also not sure\n+            // that the present approach is unsound -- it may not permit\n+            // any illegal programs. See issue for more details.\n+            cx\n+        }\n     };\n     visitor.visit_block(body, body_cx);\n }"}, {"sha": "9623f6f0cbc851b7f3f19beb86a62421153c6dab", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -2567,52 +2567,15 @@ impl Resolver {\n             }\n         }\n \n-        let merge_import_resolution = |name, name_bindings: @NameBindings| {\n-            let dest_import_resolution;\n-            let mut import_resolutions = module_.import_resolutions\n-                                                .borrow_mut();\n-            match import_resolutions.get().find(&name) {\n-                None => {\n-                    // Create a new import resolution from this child.\n-                    dest_import_resolution =\n-                        @ImportResolution::new(id, is_public);\n-                    import_resolutions.get().insert(name,\n-                                                    dest_import_resolution);\n-                }\n-                Some(&existing_import_resolution) => {\n-                    dest_import_resolution = existing_import_resolution;\n-                }\n-            }\n-\n-            debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n-                    to `{}`\",\n-                   token::get_ident(name).get().to_str(),\n-                   self.module_to_str(containing_module),\n-                   self.module_to_str(module_));\n-\n-            // Merge the child item into the import resolution.\n-            if name_bindings.defined_in_public_namespace(ValueNS) {\n-                debug!(\"(resolving glob import) ... for value target\");\n-                dest_import_resolution.value_target.set(\n-                    Some(Target::new(containing_module, name_bindings)));\n-                dest_import_resolution.value_id.set(id);\n-            }\n-            if name_bindings.defined_in_public_namespace(TypeNS) {\n-                debug!(\"(resolving glob import) ... for type target\");\n-                dest_import_resolution.type_target.set(\n-                    Some(Target::new(containing_module, name_bindings)));\n-                dest_import_resolution.type_id.set(id);\n-            }\n-            dest_import_resolution.is_public.set(is_public);\n-        };\n-\n         // Add all children from the containing module.\n         self.populate_module_if_necessary(containing_module);\n \n         {\n             let children = containing_module.children.borrow();\n             for (&name, name_bindings) in children.get().iter() {\n-                merge_import_resolution(name, *name_bindings);\n+                self.merge_import_resolution(module_, containing_module,\n+                                             id, is_public,\n+                                             name, *name_bindings);\n             }\n         }\n \n@@ -2623,7 +2586,9 @@ impl Resolver {\n             for (&name, module) in external_module_children.get().iter() {\n                 let name_bindings =\n                     @Resolver::create_name_bindings_from_module(*module);\n-                merge_import_resolution(name, name_bindings);\n+                self.merge_import_resolution(module_, containing_module,\n+                                             id, is_public,\n+                                             name, name_bindings);\n             }\n         }\n \n@@ -2641,6 +2606,50 @@ impl Resolver {\n         return Success(());\n     }\n \n+    fn merge_import_resolution(&mut self,\n+                               module_: @Module,\n+                               containing_module: @Module,\n+                               id: NodeId,\n+                               is_public: bool,\n+                               name: Name,\n+                               name_bindings: @NameBindings) {\n+        let dest_import_resolution;\n+        let mut import_resolutions = module_.import_resolutions.borrow_mut();\n+        match import_resolutions.get().find(&name) {\n+            None => {\n+                // Create a new import resolution from this child.\n+                dest_import_resolution =\n+                    @ImportResolution::new(id, is_public);\n+                import_resolutions.get().insert(name,\n+                                                dest_import_resolution);\n+            }\n+            Some(&existing_import_resolution) => {\n+                dest_import_resolution = existing_import_resolution;\n+            }\n+        }\n+\n+        debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n+               to `{}`\",\n+               token::get_ident(name).get().to_str(),\n+               self.module_to_str(containing_module),\n+               self.module_to_str(module_));\n+\n+        // Merge the child item into the import resolution.\n+        if name_bindings.defined_in_public_namespace(ValueNS) {\n+            debug!(\"(resolving glob import) ... for value target\");\n+            dest_import_resolution.value_target.set(\n+                Some(Target::new(containing_module, name_bindings)));\n+            dest_import_resolution.value_id.set(id);\n+        }\n+        if name_bindings.defined_in_public_namespace(TypeNS) {\n+            debug!(\"(resolving glob import) ... for type target\");\n+            dest_import_resolution.type_target.set(\n+                Some(Target::new(containing_module, name_bindings)));\n+            dest_import_resolution.type_id.set(id);\n+        }\n+        dest_import_resolution.is_public.set(is_public);\n+    }\n+\n     /// Resolves the given module path from the given root `module_`.\n     fn resolve_module_path_from_root(&mut self,\n                                      module_: @Module,"}, {"sha": "329301efa5ebbfaf8f1891e0534c2f1c8c4c31e0", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -480,9 +480,9 @@ impl Datum<Expr> {\n          * no cleanup scheduled).\n          */\n \n-        let mut bcx = bcx;\n         self.match_kind(\n             |l| {\n+                let mut bcx = bcx;\n                 match l.appropriate_rvalue_mode(bcx.ccx()) {\n                     ByRef => {\n                         let scratch = rvalue_scratch_datum(bcx, l.ty, name);"}, {"sha": "7c4cb396b3e26176598173393a7bf274170af766", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 189, "deletions": 2, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -45,6 +45,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n@@ -350,6 +351,9 @@ pub struct ctxt_ {\n     // is used for lazy resolution of traits.\n     populated_external_traits: RefCell<HashSet<ast::DefId>>,\n \n+    // Borrows\n+    upvar_borrow_map: RefCell<UpvarBorrowMap>,\n+\n     // These two caches are used by const_eval when decoding external statics\n     // and variants that are found.\n     extern_const_statics: RefCell<HashMap<ast::DefId, Option<@ast::Expr>>>,\n@@ -493,6 +497,120 @@ pub enum Region {\n     ReEmpty,\n }\n \n+/**\n+ * Upvars do not get their own node-id. Instead, we use the pair of\n+ * the original var id (that is, the root variable that is referenced\n+ * by the upvar) and the id of the closure expression.\n+ */\n+#[deriving(Clone, Eq, IterBytes)]\n+pub struct UpvarId {\n+    var_id: ast::NodeId,\n+    closure_expr_id: ast::NodeId,\n+}\n+\n+#[deriving(Clone, Eq, IterBytes)]\n+pub enum BorrowKind {\n+    /// Data must be immutable and is aliasable.\n+    ImmBorrow,\n+\n+    /// Data must be immutable but not aliasable.  This kind of borrow\n+    /// cannot currently be expressed by the user and is used only in\n+    /// implicit closure bindings. It is needed when you the closure\n+    /// is borrowing or mutating a mutable referent, e.g.:\n+    ///\n+    ///    let x: &mut int = ...;\n+    ///    let y = || *x += 5;\n+    ///\n+    /// If we were to try to translate this closure into a more explicit\n+    /// form, we'd encounter an error with the code as written:\n+    ///\n+    ///    struct Env { x: & &mut int }\n+    ///    let x: &mut int = ...;\n+    ///    let y = (&mut Env { &x }, fn_ptr);  // Closure is pair of env and fn\n+    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    ///\n+    /// This is then illegal because you cannot mutate a `&mut` found\n+    /// in an aliasable location. To solve, you'd have to translate with\n+    /// an `&mut` borrow:\n+    ///\n+    ///    struct Env { x: & &mut int }\n+    ///    let x: &mut int = ...;\n+    ///    let y = (&mut Env { &mut x }, fn_ptr); // changed from &x to &mut x\n+    ///    fn fn_ptr(env: &mut Env) { **env.x += 5; }\n+    ///\n+    /// Now the assignment to `**env.x` is legal, but creating a\n+    /// mutable pointer to `x` is not because `x` is not mutable. We\n+    /// could fix this by declaring `x` as `let mut x`. This is ok in\n+    /// user code, if awkward, but extra weird for closures, since the\n+    /// borrow is hidden.\n+    ///\n+    /// So we introduce a \"unique imm\" borrow -- the referent is\n+    /// immutable, but not aliasable. This solves the problem. For\n+    /// simplicity, we don't give users the way to express this\n+    /// borrow, it's just used when translating closures.\n+    UniqueImmBorrow,\n+\n+    /// Data is mutable and not aliasable.\n+    MutBorrow\n+}\n+\n+/**\n+ * Information describing the borrowing of an upvar. This is computed\n+ * during `typeck`, specifically by `regionck`. The general idea is\n+ * that the compiler analyses treat closures like:\n+ *\n+ *     let closure: &'e fn() = || {\n+ *        x = 1;   // upvar x is assigned to\n+ *        use(y);  // upvar y is read\n+ *        foo(&z); // upvar z is borrowed immutably\n+ *     };\n+ *\n+ * as if they were \"desugared\" to something loosely like:\n+ *\n+ *     struct Vars<'x,'y,'z> { x: &'x mut int,\n+ *                             y: &'y const int,\n+ *                             z: &'z int }\n+ *     let closure: &'e fn() = {\n+ *         fn f(env: &Vars) {\n+ *             *env.x = 1;\n+ *             use(*env.y);\n+ *             foo(env.z);\n+ *         }\n+ *         let env: &'e mut Vars<'x,'y,'z> = &mut Vars { x: &'x mut x,\n+ *                                                       y: &'y const y,\n+ *                                                       z: &'z z };\n+ *         (env, f)\n+ *     };\n+ *\n+ * This is basically what happens at runtime. The closure is basically\n+ * an existentially quantified version of the `(env, f)` pair.\n+ *\n+ * This data structure indicates the region and mutability of a single\n+ * one of the `x...z` borrows.\n+ *\n+ * It may not be obvious why each borrowed variable gets its own\n+ * lifetime (in the desugared version of the example, these are indicated\n+ * by the lifetime parameters `'x`, `'y`, and `'z` in the `Vars` definition).\n+ * Each such lifetime must encompass the lifetime `'e` of the closure itself,\n+ * but need not be identical to it. The reason that this makes sense:\n+ *\n+ * - Callers are only permitted to invoke the closure, and hence to\n+ *   use the pointers, within the lifetime `'e`, so clearly `'e` must\n+ *   be a sublifetime of `'x...'z`.\n+ * - The closure creator knows which upvars were borrowed by the closure\n+ *   and thus `x...z` will be reserved for `'x...'z` respectively.\n+ * - Through mutation, the borrowed upvars can actually escape the\n+ *   the closure, so sometimes it is necessary for them to be larger\n+ *   than the closure lifetime itself.\n+ */\n+#[deriving(Eq, Clone)]\n+pub struct UpvarBorrow {\n+    kind: BorrowKind,\n+    region: ty::Region,\n+}\n+\n+pub type UpvarBorrowMap = HashMap<UpvarId, UpvarBorrow>;\n+\n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match self {\n@@ -998,7 +1116,7 @@ pub fn mk_ctxt(s: session::Session,\n         impl_vtables: RefCell::new(HashMap::new()),\n         populated_external_types: RefCell::new(HashSet::new()),\n         populated_external_traits: RefCell::new(HashSet::new()),\n-\n+        upvar_borrow_map: RefCell::new(HashMap::new()),\n         extern_const_statics: RefCell::new(HashMap::new()),\n         extern_const_variants: RefCell::new(HashMap::new()),\n      }\n@@ -2668,8 +2786,13 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::NodeId) -> @ty::TraitRef {\n     }\n }\n \n+pub fn try_node_id_to_type(cx: ctxt, id: ast::NodeId) -> Option<t> {\n+    let node_types = cx.node_types.borrow();\n+    node_types.get().find_copy(&(id as uint))\n+}\n+\n pub fn node_id_to_type(cx: ctxt, id: ast::NodeId) -> t {\n-    match node_id_to_type_opt(cx, id) {\n+    match try_node_id_to_type(cx, id) {\n        Some(t) => t,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n@@ -2883,6 +3006,45 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: &ast::Expr) -> t {\n     adjust_ty(cx, expr.span, unadjusted_ty, adjustment)\n }\n \n+pub fn expr_span(cx: ctxt, id: NodeId) -> Span {\n+    match cx.items.find(id) {\n+        Some(ast_map::NodeExpr(e)) => {\n+            e.span\n+        }\n+        Some(f) => {\n+            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n+                                id, f));\n+        }\n+        None => {\n+            cx.sess.bug(format!(\"Node id {} is not present \\\n+                                in the node map\", id));\n+        }\n+    }\n+}\n+\n+pub fn local_var_name_str(cx: ctxt, id: NodeId) -> InternedString {\n+    match cx.items.find(id) {\n+        Some(ast_map::NodeLocal(pat)) => {\n+            match pat.node {\n+                ast::PatIdent(_, ref path, _) => {\n+                    let ident = ast_util::path_to_ident(path);\n+                    token::get_ident(ident.name)\n+                }\n+                _ => {\n+                    cx.sess.bug(\n+                        format!(\"Variable id {} maps to {:?}, not local\",\n+                                id, pat));\n+                }\n+            }\n+        }\n+        r => {\n+            cx.sess.bug(\n+                format!(\"Variable id {} maps to {:?}, not local\",\n+                        id, r));\n+        }\n+    }\n+}\n+\n pub fn adjust_ty(cx: ctxt,\n                  span: Span,\n                  unadjusted_ty: ty::t,\n@@ -5055,3 +5217,28 @@ impl substs {\n         }\n     }\n }\n+\n+impl BorrowKind {\n+    pub fn from_mutbl(m: ast::Mutability) -> BorrowKind {\n+        match m {\n+            ast::MutMutable => MutBorrow,\n+            ast::MutImmutable => ImmBorrow,\n+        }\n+    }\n+\n+    pub fn to_user_str(&self) -> &'static str {\n+        match *self {\n+            MutBorrow => \"mutable\",\n+            ImmBorrow => \"immutable\",\n+            UniqueImmBorrow => \"uniquely immutable\",\n+        }\n+    }\n+\n+    pub fn to_short_str(&self) -> &'static str {\n+        match *self {\n+            MutBorrow => \"mut\",\n+            ImmBorrow => \"imm\",\n+            UniqueImmBorrow => \"own\",\n+        }\n+    }\n+}"}, {"sha": "9eec804dd2e11932e2a2b37d1d95a8823cf97f8b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -164,6 +164,7 @@ pub struct Inherited {\n     adjustments: RefCell<HashMap<ast::NodeId, @ty::AutoAdjustment>>,\n     method_map: method_map,\n     vtable_map: vtable_map,\n+    upvar_borrow_map: RefCell<ty::UpvarBorrowMap>,\n }\n \n #[deriving(Clone)]\n@@ -266,6 +267,7 @@ impl Inherited {\n             adjustments: RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(HashMap::new()),\n             vtable_map: @RefCell::new(HashMap::new()),\n+            upvar_borrow_map: RefCell::new(HashMap::new()),\n         }\n     }\n }"}, {"sha": "d3a0da4bbfd831d7993f6dd0e5fe169d7c70c175", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 682, "deletions": 578, "changes": 1260, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,23 +12,115 @@\n \n The region check is a final pass that runs over the AST after we have\n inferred the type constraints but before we have actually finalized\n-the types.  Its purpose is to embed some final region constraints.\n-The reason that this is not done earlier is that sometimes we don't\n-know whether a given type will be a region pointer or not until this\n-phase.\n-\n-In particular, we ensure that, if the type of an expression or\n-variable is `&'r T`, then the expression or variable must occur within\n-the region scope `r`.  Note that in some cases `r` may still be a\n-region variable, so this gives us a chance to influence the value for\n-`r` that we infer to ensure we choose a value large enough to enclose\n-all uses.  There is a lengthy comment in visit_node() that explains\n-this point a bit better.\n+the types.  Its purpose is to embed a variety of region constraints.\n+Inserting these constraints as a separate pass is good because (1) it\n+localizes the code that has to do with region inference and (2) often\n+we cannot know what constraints are needed until the basic types have\n+been inferred.\n+\n+### Interaction with the borrow checker\n+\n+In general, the job of the borrowck module (which runs later) is to\n+check that all soundness criteria are met, given a particular set of\n+regions. The job of *this* module is to anticipate the needs of the\n+borrow checker and infer regions that will satisfy its requirements.\n+It is generally true that the inference doesn't need to be sound,\n+meaning that if there is a bug and we inferred bad regions, the borrow\n+checker should catch it. This is not entirely true though; for\n+example, the borrow checker doesn't check subtyping, and it doesn't\n+check that region pointers are always live when they are used. It\n+might be worthwhile to fix this so that borrowck serves as a kind of\n+verification step -- that would add confidence in the overall\n+correctness of the compiler, at the cost of duplicating some type\n+checks and effort.\n+\n+### Inferring the duration of borrows, automatic and otherwise\n+\n+Whenever we introduce a borrowed pointer, for example as the result of\n+a borrow expression `let x = &data`, the lifetime of the pointer `x`\n+is always specified as a region inference variable. `regionck` has the\n+job of adding constraints such that this inference variable is as\n+narrow as possible while still accommodating all uses (that is, every\n+dereference of the resulting pointer must be within the lifetime).\n+\n+#### Reborrows\n+\n+Generally speaking, `regionck` does NOT try to ensure that the data\n+`data` will outlive the pointer `x`. That is the job of borrowck.  The\n+one exception is when \"re-borrowing\" the contents of another borrowed\n+pointer. For example, imagine you have a borrowed pointer `b` with\n+lifetime L1 and you have an expression `&*b`. The result of this\n+expression will be another borrowed pointer with lifetime L2 (which is\n+an inference variable). The borrow checker is going to enforce the\n+constraint that L2 < L1, because otherwise you are re-borrowing data\n+for a lifetime larger than the original loan.  However, without the\n+routines in this module, the region inferencer would not know of this\n+dependency and thus it might infer the lifetime of L2 to be greater\n+than L1 (issue #3148).\n+\n+There are a number of troublesome scenarios in the tests\n+`region-dependent-*.rs`, but here is one example:\n+\n+    struct Foo { i: int }\n+    struct Bar { foo: Foo  }\n+    fn get_i(x: &'a Bar) -> &'a int {\n+       let foo = &x.foo; // Lifetime L1\n+       &foo.i            // Lifetime L2\n+    }\n+\n+Note that this comes up either with `&` expressions, `ref`\n+bindings, and `autorefs`, which are the three ways to introduce\n+a borrow.\n+\n+The key point here is that when you are borrowing a value that\n+is \"guaranteed\" by a borrowed pointer, you must link the\n+lifetime of that borrowed pointer (L1, here) to the lifetime of\n+the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n+borrowed pointer? I mean any data that is reached by first\n+dereferencing a borrowed pointer and then either traversing\n+interior offsets or owned pointers.  We say that the guarantor\n+of such data it the region of the borrowed pointer that was\n+traversed.  This is essentially the same as the ownership\n+relation, except that a borrowed pointer never owns its\n+contents.\n+\n+### Inferring borrow kinds for upvars\n+\n+Whenever there is a closure expression, we need to determine how each\n+upvar is used. We do this by initially assigning each upvar an\n+immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n+\"escalating\" the kind as needed. The borrow kind proceeds according to\n+the following lattice:\n+\n+    ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n+\n+So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n+will promote its borrow kind to mutable borrow. If we see an `&mut x`\n+we'll do the same. Naturally, this applies not just to the upvar, but\n+to everything owned by `x`, so the result is the same for something\n+like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n+struct). These adjustments are performed in\n+`adjust_upvar_borrow_kind()` (you can trace backwards through the code\n+from there).\n+\n+The fact that we are inferring borrow kinds as we go results in a\n+semi-hacky interaction with mem-categorization. In particular,\n+mem-categorization will query the current borrow kind as it\n+categorizes, and we'll return the *current* value, but this may get\n+adjusted later. Therefore, in this module, we generally ignore the\n+borrow kind (and derived mutabilities) that are returned from\n+mem-categorization, since they may be inaccurate. (Another option\n+would be to use a unification scheme, where instead of returning a\n+concrete borrow kind like `ty::ImmBorrow`, we return a\n+`ty::InferBorrow(upvar_id)` or something like that, but this would\n+then mean that all later passes would have to check for these figments\n+and report an error, and it just seems like more mess in the end.)\n \n */\n \n \n-use middle::freevars::get_freevars;\n+use middle::freevars;\n+use mc = middle::mem_categorization;\n use middle::ty::{ReScope};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n@@ -43,6 +135,7 @@ use util::ppaux::{ty_to_str, region_to_str, Repr};\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -149,6 +242,36 @@ impl Rcx {\n     }\n }\n \n+impl<'a> mc::Typer for &'a mut Rcx {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.fcx.tcx()\n+    }\n+\n+    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        let t = self.resolve_node_type(id);\n+        if ty::type_is_error(t) {Err(())} else {Ok(t)}\n+    }\n+\n+    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n+        let adjustments = self.fcx.inh.adjustments.borrow();\n+        adjustments.get().find_copy(&id)\n+    }\n+\n+    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+        let method_map = self.fcx.inh.method_map.borrow();\n+        method_map.get().contains_key(&id)\n+    }\n+\n+    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.tcx().region_maps.temporary_scope(id)\n+    }\n+\n+    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+        let upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow();\n+        upvar_borrow_map.get().get_copy(&id)\n+    }\n+}\n+\n pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n@@ -213,7 +336,7 @@ fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n     // see above\n     constrain_bindings_in_pat(l.pat, rcx);\n-    guarantor::for_local(rcx, l);\n+    link_local(rcx, l);\n     visit::walk_local(rcx, l, ());\n }\n \n@@ -273,7 +396,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     let expr_ty = rcx.resolve_node_type(expr.id);\n                     constrain_derefs(rcx, expr, autoderefs, expr_ty);\n                     for autoref in opt_autoref.iter() {\n-                        guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+                        link_autoref(rcx, expr, autoderefs, autoref);\n \n                         // Require that the resulting region encompasses\n                         // the current node.\n@@ -323,8 +446,22 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n+        ast::ExprAssign(lhs, _) => {\n+            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+            visit::walk_expr(rcx, expr, ());\n+        }\n+\n+        ast::ExprAssignOp(callee_id, _, lhs, rhs) => {\n+            if has_method_map {\n+                constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n+            }\n+\n+            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+\n+            visit::walk_expr(rcx, expr, ());\n+        }\n+\n         ast::ExprIndex(callee_id, lhs, rhs) |\n-        ast::ExprAssignOp(callee_id, _, lhs, rhs) |\n         ast::ExprBinary(callee_id, _, lhs, rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n@@ -388,8 +525,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAddrOf(_, base) => {\n-            guarantor::for_addr_of(rcx, expr, base);\n+        ast::ExprAddrOf(m, base) => {\n+            link_addr_of(rcx, expr, m, base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -405,13 +542,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(discr, ref arms) => {\n-            guarantor::for_match(rcx, discr, *arms);\n+            link_match(rcx, discr, *arms);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-            check_expr_fn_block(rcx, expr);\n+        ast::ExprFnBlock(_, ref body) | ast::ExprProc(_, ref body) => {\n+            check_expr_fn_block(rcx, expr, &**body);\n         }\n \n         ast::ExprLoop(body, _) => {\n@@ -437,43 +574,136 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n }\n \n fn check_expr_fn_block(rcx: &mut Rcx,\n-                       expr: &ast::Expr) {\n+                       expr: &ast::Expr,\n+                       body: &ast::Block) {\n     let tcx = rcx.fcx.tcx();\n-    match expr.node {\n-        ast::ExprFnBlock(_, ref body) | ast::ExprProc(_, ref body) => {\n-            let function_type = rcx.resolve_node_type(expr.id);\n-            match ty::get(function_type).sty {\n-                ty::ty_closure(\n-                    ty::ClosureTy {\n-                        sigil: ast::BorrowedSigil, region: region, ..}) => {\n-                    if get_freevars(tcx, expr.id).is_empty() {\n-                        // No free variables means that the environment\n-                        // will be NULL at runtime and hence the closure\n-                        // has static lifetime.\n-                    } else {\n-                        // Otherwise, the closure must not outlive the\n-                        // variables it closes over, nor can it\n-                        // outlive the innermost repeating scope\n-                        // (since otherwise that would require\n-                        // infinite stack).\n-                        constrain_free_variables(rcx, region, expr);\n-                        let repeating_scope = ty::ReScope(rcx.repeating_scope);\n-                        rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n-                                        region, repeating_scope);\n-                    }\n-                }\n-                _ => ()\n+    let function_type = rcx.resolve_node_type(expr.id);\n+    match ty::get(function_type).sty {\n+        ty::ty_closure(ty::ClosureTy {\n+                sigil: ast::BorrowedSigil, region: region, ..}) => {\n+            let freevars = freevars::get_freevars(tcx, expr.id);\n+            if freevars.is_empty() {\n+                // No free variables means that the environment\n+                // will be NULL at runtime and hence the closure\n+                // has static lifetime.\n+            } else {\n+                // Closure must not outlive the variables it closes over.\n+                constrain_free_variables(rcx, region, expr, freevars);\n+\n+                // Closure cannot outlive the appropriate temporary scope.\n+                let s = rcx.repeating_scope;\n+                rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n+                                region, ty::ReScope(s));\n             }\n+        }\n+        _ => ()\n+    }\n \n-            let repeating_scope = rcx.set_repeating_scope(body.id);\n-            visit::walk_expr(rcx, expr, ());\n-            rcx.set_repeating_scope(repeating_scope);\n+    let repeating_scope = rcx.set_repeating_scope(body.id);\n+    visit::walk_expr(rcx, expr, ());\n+    rcx.set_repeating_scope(repeating_scope);\n+\n+    match ty::get(function_type).sty {\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n+            let freevars = freevars::get_freevars(tcx, expr.id);\n+            propagate_upupvar_borrow_kind(rcx, expr, freevars);\n         }\n+        _ => ()\n+    }\n \n-        _ => {\n-            tcx.sess.span_bug(\n-                expr.span,\n-                \"expected expr_fn_block\");\n+    fn constrain_free_variables(rcx: &mut Rcx,\n+                                region: ty::Region,\n+                                expr: &ast::Expr,\n+                                freevars: freevars::freevar_info) {\n+        /*!\n+         * Make sure that all free variables referenced inside the closure\n+         * outlive the closure itself. Also, create an entry in the\n+         * upvar_borrows map with a region.\n+         */\n+\n+        let tcx = rcx.fcx.ccx.tcx;\n+        let infcx = rcx.fcx.infcx();\n+        debug!(\"constrain_free_variables({}, {})\",\n+               region.repr(tcx), expr.repr(tcx));\n+        for freevar in freevars.iter() {\n+            debug!(\"freevar def is {:?}\", freevar.def);\n+\n+            // Identify the variable being closed over and its node-id.\n+            let def = freevar.def;\n+            let def_id = ast_util::def_id_of_def(def);\n+            assert!(def_id.crate == ast::LOCAL_CRATE);\n+            let upvar_id = ty::UpvarId { var_id: def_id.node,\n+                                         closure_expr_id: expr.id };\n+\n+            // Create a region variable to represent this borrow. This borrow\n+            // must outlive the region on the closure.\n+            let origin = infer::UpvarRegion(upvar_id, expr.span);\n+            let freevar_region = infcx.next_region_var(origin);\n+            rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span, def_id.node),\n+                            region, freevar_region);\n+\n+            // Create a UpvarBorrow entry. Note that we begin with a\n+            // const borrow_kind, but change it to either mut or\n+            // immutable as dictated by the uses.\n+            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n+                                                 region: freevar_region };\n+            let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+            upvar_borrow_map.get().insert(upvar_id, upvar_borrow);\n+\n+            // Guarantee that the closure does not outlive the variable itself.\n+            let en_region = region_of_def(rcx.fcx, def);\n+            debug!(\"en_region = {}\", en_region.repr(tcx));\n+            rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span, def_id.node),\n+                            region, en_region);\n+        }\n+    }\n+\n+    fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n+                                     expr: &ast::Expr,\n+                                     freevars: freevars::freevar_info) {\n+        let tcx = rcx.fcx.ccx.tcx;\n+        debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n+        for freevar in freevars.iter() {\n+            // Because of the semi-hokey way that we are doing\n+            // borrow_kind inference, we need to check for\n+            // indirect dependencies, like so:\n+            //\n+            //     let mut x = 0;\n+            //     outer_call(|| {\n+            //         inner_call(|| {\n+            //             x = 1;\n+            //         });\n+            //     });\n+            //\n+            // Here, the `inner_call` is basically \"reborrowing\" the\n+            // outer pointer. With no other changes, `inner_call`\n+            // would infer that it requires a mutable borrow, but\n+            // `outer_call` would infer that a const borrow is\n+            // sufficient. This is because we haven't linked the\n+            // borrow_kind of the borrow that occurs in the inner\n+            // closure to the borrow_kind of the borrow in the outer\n+            // closure. Note that regions *are* naturally linked\n+            // because we have a proper inference scheme there.\n+            //\n+            // Anyway, for borrow_kind, we basically go back over now\n+            // after checking the inner closure (and hence\n+            // determining the final borrow_kind) and propagate that as\n+            // a constraint on the outer closure.\n+            match freevar.def {\n+                ast::DefUpvar(var_id, _, outer_closure_id, _) => {\n+                    // thing being captured is itself an upvar:\n+                    let outer_upvar_id = ty::UpvarId {\n+                        var_id: var_id,\n+                        closure_expr_id: outer_closure_id };\n+                    let inner_upvar_id = ty::UpvarId {\n+                        var_id: var_id,\n+                        closure_expr_id: expr.id };\n+                    link_upvar_borrow_kind_for_nested_closures(rcx,\n+                                                               inner_upvar_id,\n+                                                               outer_upvar_id);\n+                }\n+                _ => {}\n+            }\n         }\n     }\n }\n@@ -554,7 +784,7 @@ fn constrain_call(rcx: &mut Rcx,\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            guarantor::for_by_ref(rcx, arg_expr, callee_scope);\n+            link_by_ref(rcx, arg_expr, callee_scope);\n         }\n     }\n \n@@ -564,7 +794,7 @@ fn constrain_call(rcx: &mut Rcx,\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n-            guarantor::for_by_ref(rcx, r, callee_scope);\n+            link_by_ref(rcx, r, callee_scope);\n         }\n     }\n \n@@ -644,27 +874,6 @@ fn constrain_index(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_free_variables(rcx: &mut Rcx,\n-                            region: ty::Region,\n-                            expr: &ast::Expr) {\n-    /*!\n-     * Make sure that all free variables referenced inside the closure\n-     * outlive the closure itself.\n-     */\n-\n-    let tcx = rcx.fcx.ccx.tcx;\n-    debug!(\"constrain_free_variables({}, {})\",\n-           region.repr(tcx), expr.repr(tcx));\n-    for freevar in get_freevars(tcx, expr.id).iter() {\n-        debug!(\"freevar def is {:?}\", freevar.def);\n-        let def = freevar.def;\n-        let def_region = region_of_def(rcx.fcx, def);\n-        debug!(\"def_region = {}\", def_region.repr(tcx));\n-        rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n-                        region, def_region);\n-    }\n-}\n-\n fn constrain_regions_in_type_of_node(\n     rcx: &mut Rcx,\n     id: ast::NodeId,\n@@ -744,576 +953,471 @@ fn constrain_regions_in_type(\n     return e == rcx.errors_reported;\n }\n \n-pub mod guarantor {\n+// If mem categorization results in an error, it's because the type\n+// check failed (or will fail, when the error is uncovered and\n+// reported during writeback). In this case, we just ignore this part\n+// of the code and don't try to add any more region constraints.\n+macro_rules! ignore_err(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => { v }\n+            Err(()) => { return; }\n+        }\n+    )\n+)\n+\n+fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n+               mutability: ast::Mutability, base: &ast::Expr) {\n     /*!\n-     * The routines in this module are aiming to deal with the case\n-     * where a the contents of a reference are re-borrowed.\n-     * Imagine you have a reference `b` with lifetime L1 and\n-     * you have an expression `&*b`.  The result of this borrow will\n-     * be another reference with lifetime L2 (which is an\n-     * inference variable).  The borrow checker is going to enforce\n-     * the constraint that L2 < L1, because otherwise you are\n-     * re-borrowing data for a lifetime larger than the original loan.\n-     * However, without the routines in this module, the region\n-     * inferencer would not know of this dependency and thus it might\n-     * infer the lifetime of L2 to be greater than L1 (issue #3148).\n-     *\n-     * There are a number of troublesome scenarios in the tests\n-     * `region-dependent-*.rs`, but here is one example:\n-     *\n-     *     struct Foo { i: int }\n-     *     struct Bar { foo: Foo  }\n-     *     fn get_i(x: &'a Bar) -> &'a int {\n-     *        let foo = &x.foo; // Lifetime L1\n-     *        &foo.i            // Lifetime L2\n-     *     }\n-     *\n-     * Note that this comes up either with `&` expressions, `ref`\n-     * bindings, and `autorefs`, which are the three ways to introduce\n-     * a borrow.\n-     *\n-     * The key point here is that when you are borrowing a value that\n-     * is \"guaranteed\" by a reference, you must link the\n-     * lifetime of that reference (L1, here) to the lifetime of\n-     * the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n-     * reference? I mean any data that is reached by first\n-     * dereferencing a reference and then either traversing\n-     * interior offsets or owned pointers.  We say that the guarantor\n-     * of such data it the region of the reference that was\n-     * traversed.  This is essentially the same as the ownership\n-     * relation, except that a reference never owns its\n-     * contents.\n-     *\n-     * NB: I really wanted to use the `mem_categorization` code here\n-     * but I cannot because final type resolution hasn't happened yet,\n-     * and `mem_categorization` requires that all types be known.\n-     * So this is very similar logic to what you would find there,\n-     * but more special purpose.\n+     * Computes the guarantor for an expression `&base` and then\n+     * ensures that the lifetime of the resulting pointer is linked\n+     * to the lifetime of its guarantor (if any).\n      */\n \n-    use middle::typeck::astconv::AstConv;\n-    use middle::typeck::check::regionck::Rcx;\n-    use middle::typeck::check::regionck::mk_subregion_due_to_derefence;\n-    use middle::typeck::infer;\n-    use middle::ty;\n-    use syntax::ast;\n-    use syntax::codemap::Span;\n-    use util::ppaux::{ty_to_str, Repr};\n+    debug!(\"link_addr_of(base=?)\");\n \n-    pub fn for_addr_of(rcx: &mut Rcx, expr: &ast::Expr, base: &ast::Expr) {\n-        /*!\n-         * Computes the guarantor for an expression `&base` and then\n-         * ensures that the lifetime of the resulting pointer is linked\n-         * to the lifetime of its guarantor (if any).\n-         */\n+    let cmt = {\n+        let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+        ignore_err!(mc.cat_expr(base))\n+    };\n+    link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n+}\n \n-        debug!(\"guarantor::for_addr_of(base=?)\");\n+fn link_local(rcx: &mut Rcx, local: &ast::Local) {\n+    /*!\n+     * Computes the guarantors for any ref bindings in a `let` and\n+     * then ensures that the lifetime of the resulting pointer is\n+     * linked to the lifetime of the initialization expression.\n+     */\n \n-        let guarantor = guarantor(rcx, base);\n-        link(rcx, expr.span, expr.id, guarantor);\n-    }\n+    debug!(\"regionck::for_local()\");\n+    let init_expr = match local.init {\n+        None => { return; }\n+        Some(expr) => expr,\n+    };\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n+    link_pattern(&mut mc, discr_cmt, local.pat);\n+}\n \n-    pub fn for_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n-        /*!\n-         * Computes the guarantors for any ref bindings in a match and\n-         * then ensures that the lifetime of the resulting pointer is\n-         * linked to the lifetime of its guarantor (if any).\n-         */\n+fn link_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n+    /*!\n+     * Computes the guarantors for any ref bindings in a match and\n+     * then ensures that the lifetime of the resulting pointer is\n+     * linked to the lifetime of its guarantor (if any).\n+     */\n \n-        debug!(\"regionck::for_match()\");\n-        let discr_guarantor = guarantor(rcx, discr);\n-        debug!(\"discr_guarantor={}\", discr_guarantor.repr(rcx.tcx()));\n-        for arm in arms.iter() {\n-            for pat in arm.pats.iter() {\n-                link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n-            }\n+    debug!(\"regionck::for_match()\");\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let discr_cmt = ignore_err!(mc.cat_expr(discr));\n+    debug!(\"discr_cmt={}\", discr_cmt.repr(mc.typer.tcx()));\n+    for arm in arms.iter() {\n+        for &root_pat in arm.pats.iter() {\n+            link_pattern(&mut mc, discr_cmt, root_pat);\n         }\n     }\n+}\n \n-    pub fn for_local(rcx: &mut Rcx, local: &ast::Local) {\n-        /*!\n-         * Link the lifetimes of any ref bindings in a let\n-         * pattern to the lifetimes in the initializer.\n-         *\n-         * For example, given something like this:\n-         *\n-         *    let &Foo(ref x) = ...;\n-         *\n-         * this would ensure that the lifetime 'a of the\n-         * region pointer being matched must be >= the lifetime\n-         * of the ref binding.\n-         */\n-\n-        debug!(\"regionck::for_match()\");\n-        let init_expr = match local.init {\n-            None => { return; }\n-            Some(e) => e\n-        };\n-        let init_guarantor = guarantor(rcx, init_expr);\n-        debug!(\"init_guarantor={}\", init_guarantor.repr(rcx.tcx()));\n-        link_ref_bindings_in_pat(rcx, local.pat, init_guarantor);\n-    }\n-\n-    pub fn for_autoref(rcx: &mut Rcx,\n-                       expr: &ast::Expr,\n-                       autoderefs: uint,\n-                       autoref: &ty::AutoRef) {\n-        /*!\n-         * Computes the guarantor for an expression that has an\n-         * autoref adjustment and links it to the lifetime of the\n-         * autoref.  This is only important when auto re-borrowing\n-         * region pointers.\n-         */\n-\n-        debug!(\"guarantor::for_autoref(autoref={:?})\", autoref);\n+fn link_pattern(mc: &mut mc::MemCategorizationContext<&mut Rcx>,\n+                discr_cmt: mc::cmt,\n+                root_pat: @ast::Pat) {\n+    /*!\n+     * Link lifetimes of any ref bindings in `root_pat` to\n+     * the pointers found in the discriminant, if needed.\n+     */\n \n-        let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"    unadjusted cat={:?}\", expr_ct.cat);\n-        expr_ct = apply_autoderefs(\n-            rcx, expr, autoderefs, expr_ct);\n+    let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n+            match sub_pat.node {\n+                // `ref x` pattern\n+                ast::PatIdent(ast::BindByRef(mutbl), _, _) => {\n+                    link_region_from_node_type(\n+                        mc.typer, sub_pat.span, sub_pat.id,\n+                        mutbl, sub_cmt);\n+                }\n \n-        match *autoref {\n-            ty::AutoPtr(r, _) => {\n-                // In this case, we are implicitly adding an `&`.\n-                maybe_make_subregion(rcx, expr, r, expr_ct.cat.guarantor);\n+                // `[_, ..slice, _]` pattern\n+                ast::PatVec(_, Some(slice_pat), _) => {\n+                    match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n+                        Ok((slice_cmt, slice_mutbl, slice_r)) => {\n+                            link_region(mc.typer, sub_pat.span, slice_r,\n+                                        slice_mutbl, slice_cmt);\n+                        }\n+                        Err(()) => {}\n+                    }\n+                }\n+                _ => {}\n             }\n+        });\n+}\n \n-            ty::AutoBorrowVec(r, _) |\n-            ty::AutoBorrowVecRef(r, _) |\n-            ty::AutoBorrowFn(r) |\n-            ty::AutoBorrowObj(r, _) => {\n-                // In each of these cases, what is being borrowed is\n-                // not the (autoderef'd) expr itself but rather the\n-                // contents of the autoderef'd expression (i.e., what\n-                // the pointer points at).\n-                maybe_make_subregion(rcx, expr, r,\n-                                     guarantor_of_deref(&expr_ct.cat));\n-            }\n+fn link_autoref(rcx: &mut Rcx,\n+                expr: &ast::Expr,\n+                autoderefs: uint,\n+                autoref: &ty::AutoRef) {\n+    /*!\n+     * Link lifetime of borrowed pointer resulting from autoref\n+     * to lifetimes in the value being autoref'd.\n+     */\n \n-            ty::AutoUnsafe(_) => {}\n+    debug!(\"link_autoref(autoref={:?})\", autoref);\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n+    debug!(\"expr_cmt={}\", expr_cmt.repr(mc.typer.tcx()));\n+\n+    match *autoref {\n+        ty::AutoPtr(r, m) => {\n+            link_region(mc.typer, expr.span, r, m, expr_cmt);\n         }\n \n-        fn maybe_make_subregion(\n-            rcx: &mut Rcx,\n-            expr: &ast::Expr,\n-            sub_region: ty::Region,\n-            sup_region: Option<ty::Region>)\n-        {\n-            for r in sup_region.iter() {\n-                rcx.fcx.mk_subr(true, infer::Reborrow(expr.span),\n-                                sub_region, *r);\n-            }\n+        ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n+            let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n+            link_region(mc.typer, expr.span, r, m, cmt_index);\n         }\n-    }\n \n-    pub fn for_by_ref(rcx: &mut Rcx,\n-                      expr: &ast::Expr,\n-                      callee_scope: ast::NodeId) {\n-        /*!\n-         * Computes the guarantor for cases where the `expr` is\n-         * being passed by implicit reference and must outlive\n-         * `callee_scope`.\n-         */\n+        ty::AutoBorrowFn(r) => {\n+            let cmt_deref = mc.cat_deref_fn_or_obj(expr, expr_cmt, 0);\n+            link_region(mc.typer, expr.span, r, ast::MutImmutable, cmt_deref);\n+        }\n \n-        let tcx = rcx.tcx();\n-        debug!(\"guarantor::for_by_ref(expr={}, callee_scope={:?})\",\n-               expr.repr(tcx), callee_scope);\n-        let expr_cat = categorize(rcx, expr);\n-        debug!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n-               expr.id, callee_scope, expr_cat);\n-        let minimum_lifetime = ty::ReScope(callee_scope);\n-        for guarantor in expr_cat.guarantor.iter() {\n-            mk_subregion_due_to_derefence(rcx, expr.span,\n-                                          minimum_lifetime, *guarantor);\n+        ty::AutoBorrowObj(r, m) => {\n+            let cmt_deref = mc.cat_deref_fn_or_obj(expr, expr_cmt, 0);\n+            link_region(mc.typer, expr.span, r, m, cmt_deref);\n         }\n+\n+        ty::AutoUnsafe(_) => {}\n     }\n+}\n \n-    fn link(\n-        rcx: &mut Rcx,\n-        span: Span,\n-        id: ast::NodeId,\n-        guarantor: Option<ty::Region>) {\n-        /*!\n-         *\n-         * Links the lifetime of the reference resulting from a borrow\n-         * to the lifetime of its guarantor (if any).\n-         */\n+fn link_by_ref(rcx: &mut Rcx,\n+               expr: &ast::Expr,\n+               callee_scope: ast::NodeId) {\n+    /*!\n+     * Computes the guarantor for cases where the `expr` is\n+     * being passed by implicit reference and must outlive\n+     * `callee_scope`.\n+     */\n \n-        debug!(\"link(id={:?}, guarantor={:?})\", id, guarantor);\n+    let tcx = rcx.tcx();\n+    debug!(\"link_by_ref(expr={}, callee_scope={})\",\n+           expr.repr(tcx), callee_scope);\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let expr_cmt = ignore_err!(mc.cat_expr(expr));\n+    let region_min = ty::ReScope(callee_scope);\n+    link_region(mc.typer, expr.span, region_min, ast::MutImmutable, expr_cmt);\n+}\n \n-        let bound = match guarantor {\n-            None => {\n-                // If guarantor is None, then the value being borrowed\n-                // is not guaranteed by a region pointer, so there are\n-                // no lifetimes to link.\n-                return;\n-            }\n-            Some(r) => { r }\n-        };\n-\n-        // this routine is used for the result of ref bindings and &\n-        // expressions, both of which always yield a region variable, so\n-        // mk_subr should never fail.\n-        let rptr_ty = rcx.resolve_node_type(id);\n-        if !ty::type_is_bot(rptr_ty) {\n-            let tcx = rcx.fcx.ccx.tcx;\n-            debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n-            let r = ty::ty_region(tcx, span, rptr_ty);\n-            rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n-        }\n-    }\n+fn link_region_from_node_type(rcx: &mut Rcx,\n+                              span: Span,\n+                              id: ast::NodeId,\n+                              mutbl: ast::Mutability,\n+                              cmt_borrowed: mc::cmt) {\n+    /*!\n+     * Like `link_region()`, except that the region is\n+     * extracted from the type of `id`, which must be some\n+     * reference (`&T`, `&str`, etc).\n+     */\n \n-    /// Categorizes types based on what kind of pointer they are.\n-    /// Note that we don't bother to distinguish between rptrs (&T)\n-    /// and slices (&[T], &str)---they are all just `BorrowedPointer`.\n-    enum PointerCategorization {\n-        NotPointer,\n-        OwnedPointer,\n-        BorrowedPointer(ty::Region),\n-        OtherPointer\n+    let rptr_ty = rcx.resolve_node_type(id);\n+    if !ty::type_is_bot(rptr_ty) && !ty::type_is_error(rptr_ty) {\n+        let tcx = rcx.fcx.ccx.tcx;\n+        debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n+        let r = ty::ty_region(tcx, span, rptr_ty);\n+        link_region(rcx, span, r, mutbl, cmt_borrowed);\n     }\n+}\n \n-    /// Guarantor of an expression paired with the\n-    /// PointerCategorization` of its type.\n-    struct ExprCategorization {\n-        guarantor: Option<ty::Region>,\n-        pointer: PointerCategorization\n-    }\n+fn link_region(rcx: &mut Rcx,\n+               span: Span,\n+               region_min: ty::Region,\n+               mutbl: ast::Mutability,\n+               cmt_borrowed: mc::cmt) {\n+    /*!\n+     * Informs the inference engine that a borrow of `cmt`\n+     * must have mutability `mutbl` and lifetime `region_min`.\n+     * If `cmt` is a deref of a region pointer with\n+     * lifetime `r_borrowed`, this will add the constraint that\n+     * `region_min <= r_borrowed`.\n+     */\n \n-    /// ExprCategorization paired with the full type of the expr\n-    struct ExprCategorizationType {\n-        cat: ExprCategorization,\n-        ty: ty::t\n-    }\n+    // Iterate through all the things that must be live at least\n+    // for the lifetime `region_min` for the borrow to be valid:\n+    let mut cmt_borrowed = cmt_borrowed;\n+    loop {\n+        debug!(\"link_region(region_min={}, mutbl={}, cmt_borrowed={})\",\n+               region_min.repr(rcx.tcx()),\n+               mutbl.repr(rcx.tcx()),\n+               cmt_borrowed.repr(rcx.tcx()));\n+        match cmt_borrowed.cat {\n+            mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) => {\n+                // References to an upvar `x` are translated to\n+                // `*x`, since that is what happens in the\n+                // underlying machine.  We detect such references\n+                // and treat them slightly differently, both to\n+                // offer better error messages and because we need\n+                // to infer the kind of borrow (mut, const, etc)\n+                // to use for each upvar.\n+                let cause = match base.cat {\n+                    mc::cat_upvar(ref upvar_id, _) => {\n+                        let mut upvar_borrow_map =\n+                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        match upvar_borrow_map.get().find_mut(upvar_id) {\n+                            Some(upvar_borrow) => {\n+                                debug!(\"link_region: {} <= {}\",\n+                                       region_min.repr(rcx.tcx()),\n+                                       upvar_borrow.region.repr(rcx.tcx()));\n+                                adjust_upvar_borrow_kind_for_loan(\n+                                    *upvar_id,\n+                                    upvar_borrow,\n+                                    mutbl);\n+                                infer::ReborrowUpvar(span, *upvar_id)\n+                            }\n+                            None => {\n+                                rcx.tcx().sess.span_bug(\n+                                    span,\n+                                    format!(\"Illegal upvar id: {}\",\n+                                            upvar_id.repr(rcx.tcx())));\n+                            }\n+                        }\n+                    }\n \n-    fn guarantor(rcx: &mut Rcx, expr: &ast::Expr) -> Option<ty::Region> {\n-        /*!\n-         *\n-         * Computes the guarantor of `expr`, or None if `expr` is\n-         * not guaranteed by any region.  Here `expr` is some expression\n-         * whose address is being taken (e.g., there is an expression\n-         * `&expr`).\n-         */\n+                    _ => {\n+                        infer::Reborrow(span)\n+                    }\n+                };\n \n-        debug!(\"guarantor()\");\n-        match expr.node {\n-            ast::ExprUnary(_, ast::UnDeref, b) => {\n-                let cat = categorize(rcx, b);\n-                guarantor_of_deref(&cat)\n-            }\n-            ast::ExprField(b, _, _) => {\n-                categorize(rcx, b).guarantor\n-            }\n-            ast::ExprIndex(_, b, _) => {\n-                let cat = categorize(rcx, b);\n-                guarantor_of_deref(&cat)\n-            }\n+                debug!(\"link_region: {} <= {}\",\n+                       region_min.repr(rcx.tcx()),\n+                       r_borrowed.repr(rcx.tcx()));\n+                rcx.fcx.mk_subr(true, cause, region_min, r_borrowed);\n+\n+                if mutbl == ast::MutMutable {\n+                    // If this is a mutable borrow, then the thing\n+                    // being borrowed will have to be unique.\n+                    // In user code, this means it must be an `&mut`\n+                    // borrow, but for an upvar, we might opt\n+                    // for an immutable-unique borrow.\n+                    adjust_upvar_borrow_kind_for_unique(rcx, base);\n+                }\n \n-            ast::ExprParen(e) => {\n-                guarantor(rcx, e)\n+                // Borrowing an `&mut` pointee for `region_min` is\n+                // only valid if the pointer resides in a unique\n+                // location which is itself valid for\n+                // `region_min`.  We don't care about the unique\n+                // part, but we may need to influence the\n+                // inference to ensure that the location remains\n+                // valid.\n+                //\n+                // FIXME(#8624) fixing borrowck will require this\n+                // if m == ast::m_mutbl {\n+                //    cmt_borrowed = cmt_base;\n+                // } else {\n+                //    return;\n+                // }\n+                return;\n             }\n-\n-            // Either a variable or constant and hence resides\n-            // in constant memory or on the stack frame.  Either way,\n-            // not guaranteed by a region pointer.\n-            ast::ExprPath(..) => None,\n-\n-            // All of these expressions are rvalues and hence their\n-            // value is not guaranteed by a region pointer.\n-            ast::ExprInlineAsm(..) |\n-            ast::ExprMac(..) |\n-            ast::ExprLit(_) |\n-            ast::ExprUnary(..) |\n-            ast::ExprAddrOf(..) |\n-            ast::ExprBinary(..) |\n-            ast::ExprVstore(..) |\n-            ast::ExprBox(..) |\n-            ast::ExprBreak(..) |\n-            ast::ExprAgain(..) |\n-            ast::ExprRet(..) |\n-            ast::ExprLogLevel |\n-            ast::ExprWhile(..) |\n-            ast::ExprLoop(..) |\n-            ast::ExprAssign(..) |\n-            ast::ExprAssignOp(..) |\n-            ast::ExprCast(..) |\n-            ast::ExprCall(..) |\n-            ast::ExprMethodCall(..) |\n-            ast::ExprStruct(..) |\n-            ast::ExprTup(..) |\n-            ast::ExprIf(..) |\n-            ast::ExprMatch(..) |\n-            ast::ExprFnBlock(..) |\n-            ast::ExprProc(..) |\n-            ast::ExprBlock(..) |\n-            ast::ExprRepeat(..) |\n-            ast::ExprVec(..) => {\n-                assert!(!ty::expr_is_lval(\n-                    rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n-                None\n+            mc::cat_discr(cmt_base, _) |\n+            mc::cat_downcast(cmt_base) |\n+            mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n+            mc::cat_interior(cmt_base, _) => {\n+                // Interior or owned data requires its base to be valid\n+                cmt_borrowed = cmt_base;\n+            }\n+            mc::cat_deref(_, _, mc::GcPtr(..)) |\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_static_item |\n+            mc::cat_copied_upvar(..) |\n+            mc::cat_local(..) |\n+            mc::cat_arg(..) |\n+            mc::cat_upvar(..) |\n+            mc::cat_rvalue(..) => {\n+                // These are all \"base cases\" with independent lifetimes\n+                // that are not subject to inference\n+                return;\n             }\n-            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n         }\n     }\n+}\n \n-    fn categorize(rcx: &mut Rcx, expr: &ast::Expr) -> ExprCategorization {\n-        debug!(\"categorize()\");\n-\n-        let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"before adjustments, cat={:?}\", expr_ct.cat);\n+fn adjust_borrow_kind_for_assignment_lhs(rcx: &mut Rcx,\n+                                         lhs: &ast::Expr) {\n+    /*!\n+     * Adjusts the inferred borrow_kind as needed to account\n+     * for upvars that are assigned to in an assignment\n+     * expression.\n+     */\n \n-        let adjustments = rcx.fcx.inh.adjustments.borrow();\n-        match adjustments.get().find(&expr.id) {\n-            Some(adjustment) => {\n-                match **adjustment {\n-                    ty::AutoAddEnv(..) => {\n-                        // This is basically an rvalue, not a pointer, no regions\n-                        // involved.\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: NotPointer\n-                        };\n-                    }\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let cmt = ignore_err!(mc.cat_expr(lhs));\n+    adjust_upvar_borrow_kind_for_mut(mc.typer, cmt);\n+}\n \n-                    ty::AutoObject(ast::BorrowedSigil,\n-                                   Some(region),\n-                                   _,\n-                                   _,\n-                                   _,\n-                                   _) => {\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: BorrowedPointer(region)\n-                        };\n-                    }\n+fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n+                                    cmt: mc::cmt) {\n+    let mut cmt = cmt;\n+    loop {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n+               cmt.repr(rcx.tcx()));\n+\n+        match cmt.cat {\n+            mc::cat_deref(base, _, mc::OwnedPtr) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base) |\n+            mc::cat_discr(base, _) => {\n+                // Interior or owned data is mutable if base is\n+                // mutable, so iterate to the base.\n+                cmt = base;\n+                continue;\n+            }\n \n-                    ty::AutoObject(ast::OwnedSigil, _, _, _, _, _) => {\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: OwnedPointer\n-                        };\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) => {\n+                match base.cat {\n+                    mc::cat_upvar(ref upvar_id, _) => {\n+                        // if this is an implicit deref of an\n+                        // upvar, then we need to modify the\n+                        // borrow_kind of the upvar to make sure it\n+                        // is inferred to mutable if necessary\n+                        let mut upvar_borrow_map =\n+                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        let ub = upvar_borrow_map.get().get_mut(upvar_id);\n+                        return adjust_upvar_borrow_kind(*upvar_id, ub, ty::MutBorrow);\n                     }\n \n-                    ty::AutoObject(ast::ManagedSigil, _, _, _, _, _) => {\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: OtherPointer\n-                        };\n+                    _ => {\n+                        // assignment to deref of an `&mut`\n+                        // borrowed pointer implies that the\n+                        // pointer itself must be unique, but not\n+                        // necessarily *mutable*\n+                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n                     }\n-                    ty::AutoDerefRef(ref adjustment) => {\n-                        debug!(\"adjustment={:?}\", adjustment);\n-\n-                        expr_ct = apply_autoderefs(\n-                            rcx, expr, adjustment.autoderefs, expr_ct);\n-\n-                        match adjustment.autoref {\n-                            None => {\n-                            }\n-                            Some(ty::AutoUnsafe(_)) => {\n-                                expr_ct.cat.guarantor = None;\n-                                expr_ct.cat.pointer = OtherPointer;\n-                                debug!(\"autoref, cat={:?}\", expr_ct.cat);\n-                            }\n-                            Some(ty::AutoPtr(r, _)) |\n-                            Some(ty::AutoBorrowVec(r, _)) |\n-                            Some(ty::AutoBorrowVecRef(r, _)) |\n-                            Some(ty::AutoBorrowFn(r)) |\n-                            Some(ty::AutoBorrowObj(r, _)) => {\n-                                // If there is an autoref, then the result of\n-                                // this expression will be some sort of\n-                                // reference.\n-                                expr_ct.cat.guarantor = None;\n-                                expr_ct.cat.pointer = BorrowedPointer(r);\n-                                debug!(\"autoref, cat={:?}\", expr_ct.cat);\n-                            }\n-                        }\n-                    }\n-\n-                    _ => fail!(\"invalid or unhandled adjustment\"),\n                 }\n             }\n \n-            None => {}\n-        }\n-\n-        debug!(\"result={:?}\", expr_ct.cat);\n-        return expr_ct.cat;\n-    }\n-\n-    fn categorize_unadjusted(rcx: &mut Rcx,\n-                             expr: &ast::Expr)\n-                          -> ExprCategorizationType {\n-        debug!(\"categorize_unadjusted()\");\n-\n-        let guarantor = {\n-            let method_map = rcx.fcx.inh.method_map.borrow();\n-            if method_map.get().contains_key(&expr.id) {\n-                None\n-            } else {\n-                guarantor(rcx, expr)\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_deref(_, _, mc::GcPtr) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_copied_upvar(_) |\n+            mc::cat_local(_) |\n+            mc::cat_arg(_) |\n+            mc::cat_upvar(..) => {\n+                return;\n             }\n-        };\n-\n-        let expr_ty = rcx.resolve_node_type(expr.id);\n-        ExprCategorizationType {\n-            cat: ExprCategorization {\n-                guarantor: guarantor,\n-                pointer: pointer_categorize(expr_ty)\n-            },\n-            ty: expr_ty\n         }\n     }\n+}\n \n-    fn apply_autoderefs(\n-        rcx: &mut Rcx,\n-        expr: &ast::Expr,\n-        autoderefs: uint,\n-        ct: ExprCategorizationType)\n-     -> ExprCategorizationType {\n-        let mut ct = ct;\n-        let tcx = rcx.fcx.ccx.tcx;\n-\n-        if ty::type_is_error(ct.ty) {\n-            ct.cat.pointer = NotPointer;\n-            return ct;\n-        }\n-\n-        for _ in range(0u, autoderefs) {\n-            ct.cat.guarantor = guarantor_of_deref(&ct.cat);\n-\n-            match ty::deref(ct.ty, true) {\n-                Some(mt) => {\n-                    ct.ty = mt.ty;\n-                    ct.cat.pointer = pointer_categorize(ct.ty);\n-                }\n-                None => {\n-                    tcx.sess.span_bug(\n-                        expr.span,\n-                        format!(\"autoderef but type not derefable: {}\",\n-                             ty_to_str(tcx, ct.ty)));\n-                }\n+fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n+                                       cmt: mc::cmt) {\n+    let mut cmt = cmt;\n+    loop {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n+               cmt.repr(rcx.tcx()));\n+\n+        match cmt.cat {\n+            mc::cat_deref(base, _, mc::OwnedPtr) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base) |\n+            mc::cat_discr(base, _) => {\n+                // Interior or owned data is unique if base is\n+                // unique.\n+                cmt = base;\n+                continue;\n             }\n \n-            debug!(\"autoderef, cat={:?}\", ct.cat);\n-        }\n-        return ct;\n-    }\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) => {\n+                match base.cat {\n+                    mc::cat_upvar(ref upvar_id, _) => {\n+                        // if this is an implicit deref of an\n+                        // upvar, then we need to modify the\n+                        // borrow_kind of the upvar to make sure it\n+                        // is inferred to unique if necessary\n+                        let mut upvar_borrow_map =\n+                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        let ub = upvar_borrow_map.get().get_mut(upvar_id);\n+                        return adjust_upvar_borrow_kind(*upvar_id, ub, ty::UniqueImmBorrow);\n+                    }\n \n-    fn pointer_categorize(ty: ty::t) -> PointerCategorization {\n-        match ty::get(ty).sty {\n-            ty::ty_rptr(r, _) |\n-            ty::ty_vec(_, ty::vstore_slice(r)) |\n-            ty::ty_trait(_, _, ty::RegionTraitStore(r), _, _) |\n-            ty::ty_str(ty::vstore_slice(r)) => {\n-                BorrowedPointer(r)\n-            }\n-            ty::ty_uniq(..) |\n-            ty::ty_str(ty::vstore_uniq) |\n-            ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-            ty::ty_vec(_, ty::vstore_uniq) => {\n-                OwnedPointer\n-            }\n-            ty::ty_box(..) | ty::ty_ptr(..) => {\n-                OtherPointer\n-            }\n-            ty::ty_closure(ref closure_ty) => {\n-                match closure_ty.sigil {\n-                    ast::BorrowedSigil => BorrowedPointer(closure_ty.region),\n-                    ast::OwnedSigil => OwnedPointer,\n-                    ast::ManagedSigil => OtherPointer,\n+                    _ => {\n+                        // for a borrowed pointer to be unique, its\n+                        // base must be unique\n+                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n+                    }\n                 }\n             }\n-            _ => {\n-                NotPointer\n+\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_deref(_, _, mc::GcPtr) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_copied_upvar(_) |\n+            mc::cat_local(_) |\n+            mc::cat_arg(_) |\n+            mc::cat_upvar(..) => {\n+                return;\n             }\n         }\n     }\n+}\n \n-    fn guarantor_of_deref(cat: &ExprCategorization) -> Option<ty::Region> {\n-        match cat.pointer {\n-            NotPointer => cat.guarantor,\n-            BorrowedPointer(r) => Some(r),\n-            OwnedPointer => cat.guarantor,\n-            OtherPointer => None\n+fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n+                                              inner_upvar_id: ty::UpvarId,\n+                                              outer_upvar_id: ty::UpvarId) {\n+    /*!\n+     * Indicates that the borrow_kind of `outer_upvar_id` must\n+     * permit a reborrowing with the borrow_kind of `inner_upvar_id`.\n+     * This occurs in nested closures, see comment above at the call to\n+     * this function.\n+     */\n+\n+    debug!(\"link_upvar_borrow_kind: inner_upvar_id={:?} outer_upvar_id={:?}\",\n+           inner_upvar_id, outer_upvar_id);\n+\n+    let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+    let inner_borrow = upvar_borrow_map.get().get_copy(&inner_upvar_id);\n+    match upvar_borrow_map.get().find_mut(&outer_upvar_id) {\n+        Some(outer_borrow) => {\n+            adjust_upvar_borrow_kind(outer_upvar_id, outer_borrow, inner_borrow.kind);\n         }\n+        None => { /* outer closure is not a stack closure */ }\n     }\n+}\n \n-    fn link_ref_bindings_in_pat(\n-        rcx: &mut Rcx,\n-        pat: &ast::Pat,\n-        guarantor: Option<ty::Region>) {\n-        /*!\n-         *\n-         * Descends through the pattern, tracking the guarantor\n-         * of the value being matched.  When a ref binding is encountered,\n-         * links the lifetime of that ref binding to the lifetime of\n-         * the guarantor.  We begin with the guarantor of the\n-         * discriminant but of course as we go we may pass through\n-         * other pointers.\n-         */\n+fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n+                                     upvar_borrow: &mut ty::UpvarBorrow,\n+                                     mutbl: ast::Mutability) {\n+    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={:?} kind={:?} -> {:?}\",\n+           upvar_id, upvar_borrow.kind, mutbl);\n \n-        debug!(\"link_ref_bindings_in_pat(pat={}, guarantor={:?})\",\n-               rcx.fcx.pat_to_str(pat), guarantor);\n+    adjust_upvar_borrow_kind(upvar_id, upvar_borrow,\n+                             ty::BorrowKind::from_mutbl(mutbl))\n+}\n \n-        match pat.node {\n-            ast::PatWild | ast::PatWildMulti => {}\n-            ast::PatIdent(ast::BindByRef(_), _, opt_p) => {\n-                link(rcx, pat.span, pat.id, guarantor);\n+fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n+                            upvar_borrow: &mut ty::UpvarBorrow,\n+                            kind: ty::BorrowKind) {\n+    /*!\n+     * We infer the borrow_kind with which to borrow upvars in a stack\n+     * closure. The borrow_kind basically follows a lattice of\n+     * `imm < unique-imm < mut`, moving from left to right as needed (but never\n+     * right to left). Here the argument `mutbl` is the borrow_kind that\n+     * is required by some particular use.\n+     */\n \n-                for p in opt_p.iter() {\n-                    link_ref_bindings_in_pat(rcx, *p, guarantor);\n-                }\n-            }\n-            ast::PatIdent(_, _, opt_p) => {\n-                for p in opt_p.iter() {\n-                    link_ref_bindings_in_pat(rcx, *p, guarantor);\n-                }\n-            }\n-            ast::PatEnum(_, None) => {}\n-            ast::PatEnum(_, Some(ref pats)) => {\n-                link_ref_bindings_in_pats(rcx, pats, guarantor);\n-            }\n-            ast::PatStruct(_, ref fpats, _) => {\n-                for fpat in fpats.iter() {\n-                    link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n-                }\n-            }\n-            ast::PatTup(ref ps) => {\n-                link_ref_bindings_in_pats(rcx, ps, guarantor)\n-            }\n-            ast::PatUniq(p) => {\n-                link_ref_bindings_in_pat(rcx, p, guarantor)\n-            }\n-            ast::PatRegion(p) => {\n-                let rptr_ty = rcx.resolve_node_type(pat.id);\n-                let r = ty::ty_region(rcx.fcx.tcx(), pat.span, rptr_ty);\n-                link_ref_bindings_in_pat(rcx, p, Some(r));\n-            }\n-            ast::PatLit(..) => {}\n-            ast::PatRange(..) => {}\n-            ast::PatVec(ref before, ref slice, ref after) => {\n-                let vec_ty = rcx.resolve_node_type(pat.id);\n-                let vstore = ty::ty_vstore(vec_ty);\n-                let guarantor1 = match vstore {\n-                    ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n-                    ty::vstore_slice(r) => Some(r),\n-                };\n+    debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n+           upvar_id, upvar_borrow.kind, kind);\n \n-                link_ref_bindings_in_pats(rcx, before, guarantor1);\n-                for &p in slice.iter() {\n-                    link_ref_bindings_in_pat(rcx, p, guarantor);\n-                }\n-                link_ref_bindings_in_pats(rcx, after, guarantor1);\n-            }\n+    match (upvar_borrow.kind, kind) {\n+        // Take RHS:\n+        (ty::ImmBorrow, ty::UniqueImmBorrow) |\n+        (ty::ImmBorrow, ty::MutBorrow) |\n+        (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+            upvar_borrow.kind = kind;\n         }\n-    }\n-\n-    fn link_ref_bindings_in_pats(rcx: &mut Rcx,\n-                                 pats: &~[@ast::Pat],\n-                                 guarantor: Option<ty::Region>) {\n-        for pat in pats.iter() {\n-            link_ref_bindings_in_pat(rcx, *pat, guarantor);\n+        // Take LHS:\n+        (ty::ImmBorrow, ty::ImmBorrow) |\n+        (ty::UniqueImmBorrow, ty::ImmBorrow) |\n+        (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n+        (ty::MutBorrow, _) => {\n         }\n     }\n-\n }"}, {"sha": "8480135599052bf1820bdcbb39017ac5243cce59", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -378,10 +378,45 @@ impl Visitor<()> for WbCtxt {\n     fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n }\n \n+fn resolve_upvar_borrow_map(wbcx: &mut WbCtxt) {\n+    if !wbcx.success {\n+        return;\n+    }\n+\n+    let fcx = wbcx.fcx;\n+    let tcx = fcx.tcx();\n+    let upvar_borrow_map = fcx.inh.upvar_borrow_map.borrow();\n+    for (upvar_id, upvar_borrow) in upvar_borrow_map.get().iter() {\n+        let r = upvar_borrow.region;\n+        match resolve_region(fcx.infcx(), r, resolve_all | force_all) {\n+            Ok(r) => {\n+                let new_upvar_borrow = ty::UpvarBorrow {\n+                    kind: upvar_borrow.kind,\n+                    region: r\n+                };\n+                debug!(\"Upvar borrow for {} resolved to {}\",\n+                       upvar_id.repr(tcx), new_upvar_borrow.repr(tcx));\n+                let mut tcx_upvar_borrow_map = tcx.upvar_borrow_map.borrow_mut();\n+                tcx_upvar_borrow_map.get().insert(*upvar_id, new_upvar_borrow);\n+            }\n+            Err(e) => {\n+                let span = ty::expr_span(tcx, upvar_id.closure_expr_id);\n+                fcx.ccx.tcx.sess.span_err(\n+                    span, format!(\"cannot resolve lifetime for \\\n+                                  captured variable `{}`: {}\",\n+                                  ty::local_var_name_str(tcx, upvar_id.var_id).get().to_str(),\n+                                  infer::fixup_err_to_str(e)));\n+                wbcx.success = false;\n+            }\n+        };\n+    }\n+}\n+\n pub fn resolve_type_vars_in_expr(fcx: @FnCtxt, e: &ast::Expr) -> bool {\n     let mut wbcx = WbCtxt { fcx: fcx, success: true };\n     let wbcx = &mut wbcx;\n     wbcx.visit_expr(e, ());\n+    resolve_upvar_borrow_map(wbcx);\n     return wbcx.success;\n }\n \n@@ -397,5 +432,6 @@ pub fn resolve_type_vars_in_fn(fcx: @FnCtxt, decl: &ast::FnDecl,\n             resolve_type_vars_for_node(wbcx, arg.pat.span, arg.pat.id);\n         }\n     }\n+    resolve_upvar_borrow_map(wbcx);\n     return wbcx.success;\n }"}, {"sha": "3a3f24a2e2d88d1163ab94c9c4571201e0e13adc", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -237,6 +237,24 @@ impl ErrorReporting for InferCtxt {\n                     sup,\n                     \"\");\n             }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"lifetime of borrowed pointer outlives \\\n+                            lifetime of captured variable `{}`...\",\n+                            ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str()));\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"...the borrowed pointer is valid for \",\n+                    sub,\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"...but `{}` is only valid for \",\n+                            ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str()),\n+                    sup,\n+                    \"\");\n+            }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -272,10 +290,12 @@ impl ErrorReporting for InferCtxt {\n                     sup,\n                     \"\");\n             }\n-            infer::FreeVariable(span) => {\n+            infer::FreeVariable(span, id) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    \"captured variable does not outlive the enclosing closure\");\n+                    format!(\"captured variable `{}` does not \\\n+                            outlive the enclosing closure\",\n+                            ty::local_var_name_str(self.tcx, id).get().to_str()));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -473,6 +493,10 @@ impl ErrorReportingHelpers for InferCtxt {\n             infer::BoundRegionInCoherence(..) => {\n                 format!(\" for coherence check\")\n             }\n+            infer::UpvarRegion(ref upvar_id, _) => {\n+                format!(\" for capture of `{}` by closure\",\n+                        ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str())\n+            }\n         };\n \n         self.tcx.sess.span_err(\n@@ -533,6 +557,12 @@ impl ErrorReportingHelpers for InferCtxt {\n                     \"...so that reference does not outlive \\\n                     borrowed content\");\n             }\n+            infer::ReborrowUpvar(span, ref upvar_id) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    format!(\"...so that closure can access `{}`\",\n+                            ty::local_var_name_str(self.tcx, upvar_id.var_id).get().to_str()))\n+            }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n@@ -549,11 +579,12 @@ impl ErrorReportingHelpers for InferCtxt {\n                     \"...so that pointer is not dereferenced \\\n                     outside its lifetime\");\n             }\n-            infer::FreeVariable(span) => {\n+            infer::FreeVariable(span, id) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    \"...so that captured variable does not outlive the \\\n-                    enclosing closure\");\n+                    format!(\"...so that captured variable `{}` \\\n+                            does not outlive the enclosing closure\",\n+                            ty::local_var_name_str(self.tcx, id).get().to_str()));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note("}, {"sha": "deec4100617412d6da3723ac6b68de4ab49bc6aa", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -160,7 +160,7 @@ pub enum SubregionOrigin {\n     DerefPointer(Span),\n \n     // Closure bound must not outlive captured free variables\n-    FreeVariable(Span),\n+    FreeVariable(Span, ast::NodeId),\n \n     // Index into slice must be within its lifetime\n     IndexSlice(Span),\n@@ -172,6 +172,9 @@ pub enum SubregionOrigin {\n     // Creating a pointer `b` to contents of another reference\n     Reborrow(Span),\n \n+    // Creating a pointer `b` to contents of an upvar\n+    ReborrowUpvar(Span, ty::UpvarId),\n+\n     // (&'a &'b T) where a >= b\n     ReferenceOutlivesReferent(ty::t, Span),\n \n@@ -225,6 +228,8 @@ pub enum RegionVariableOrigin {\n     // when doing subtyping/lub/glb computations\n     BoundRegionInFnType(Span, ty::BoundRegion),\n \n+    UpvarRegion(ty::UpvarId, Span),\n+\n     BoundRegionInTypeOrImpl(Span),\n \n     BoundRegionInCoherence,\n@@ -876,10 +881,11 @@ impl SubregionOrigin {\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n-            FreeVariable(a) => a,\n+            FreeVariable(a, _) => a,\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             Reborrow(a) => a,\n+            ReborrowUpvar(a, _) => a,\n             ReferenceOutlivesReferent(_, a) => a,\n             BindingTypeIsNotValidAtDecl(a) => a,\n             CallRcvr(a) => a,\n@@ -898,10 +904,11 @@ impl Repr for SubregionOrigin {\n             InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n             InvokeClosure(a) => format!(\"InvokeClosure({})\", a.repr(tcx)),\n             DerefPointer(a) => format!(\"DerefPointer({})\", a.repr(tcx)),\n-            FreeVariable(a) => format!(\"FreeVariable({})\", a.repr(tcx)),\n+            FreeVariable(a, b) => format!(\"FreeVariable({}, {})\", a.repr(tcx), b),\n             IndexSlice(a) => format!(\"IndexSlice({})\", a.repr(tcx)),\n             RelateObjectBound(a) => format!(\"RelateObjectBound({})\", a.repr(tcx)),\n             Reborrow(a) => format!(\"Reborrow({})\", a.repr(tcx)),\n+            ReborrowUpvar(a, b) => format!(\"ReborrowUpvar({},{:?})\", a.repr(tcx), b),\n             ReferenceOutlivesReferent(_, a) =>\n                 format!(\"ReferenceOutlivesReferent({})\", a.repr(tcx)),\n             BindingTypeIsNotValidAtDecl(a) =>\n@@ -928,6 +935,7 @@ impl RegionVariableOrigin {\n             BoundRegionInFnType(a, _) => a,\n             BoundRegionInTypeOrImpl(a) => a,\n             BoundRegionInCoherence => codemap::DUMMY_SP,\n+            UpvarRegion(_, a) => a\n         }\n     }\n }\n@@ -948,6 +956,9 @@ impl Repr for RegionVariableOrigin {\n             BoundRegionInTypeOrImpl(a) => format!(\"bound_regionInTypeOrImpl({})\",\n                                                a.repr(tcx)),\n             BoundRegionInCoherence => format!(\"bound_regionInCoherence\"),\n+            UpvarRegion(a, b) => format!(\"UpvarRegion({}, {})\",\n+                                         a.repr(tcx),\n+                                         b.repr(tcx)),\n         }\n     }\n }"}, {"sha": "bbd9d8e1c4dcc4dd19b4be9480fa2d420b81028f", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -270,7 +270,11 @@ impl RegionVarBindings {\n         // cannot add constraints once regions are resolved\n         assert!(self.values_are_none());\n \n-        debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n+        debug!(\"RegionVarBindings: make_subregion({}, {}) due to {}\",\n+               sub.repr(self.tcx),\n+               sup.repr(self.tcx),\n+               origin.repr(self.tcx));\n+\n         match (sub, sup) {\n           (ReEarlyBound(..), _) |\n           (ReLateBound(..), _) |"}, {"sha": "afac501835dc72bd170515e244888a16100f4f52", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -565,11 +565,26 @@ impl<T:Repr> Repr for Option<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n             &None => ~\"None\",\n-            &Some(ref t) => format!(\"Some({})\", t.repr(tcx))\n+            &Some(ref t) => t.repr(tcx),\n         }\n     }\n }\n \n+impl<T:Repr,U:Repr> Repr for Result<T,U> {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        match self {\n+            &Ok(ref t) => t.repr(tcx),\n+            &Err(ref u) => format!(\"Err({})\", u.repr(tcx))\n+        }\n+    }\n+}\n+\n+impl Repr for () {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        ~\"()\"\n+    }\n+}\n+\n impl<T:Repr> Repr for @T {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         (&**self).repr(tcx)\n@@ -1021,3 +1036,32 @@ impl UserString for AbiSet {\n         self.to_str()\n     }\n }\n+\n+impl Repr for ty::UpvarId {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"UpvarId({};`{}`;{})\",\n+             self.var_id,\n+             ty::local_var_name_str(tcx, self.var_id),\n+             self.closure_expr_id)\n+    }\n+}\n+\n+impl Repr for ast::Mutability {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl Repr for ty::BorrowKind {\n+    fn repr(&self, _tcx: ctxt) -> ~str {\n+        format!(\"{:?}\", *self)\n+    }\n+}\n+\n+impl Repr for ty::UpvarBorrow {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"UpvarBorrow({}, {})\",\n+             self.kind.repr(tcx),\n+             self.region.repr(tcx))\n+    }\n+}"}, {"sha": "116ec6bba290438c81192111018149e383b02ce0", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -453,18 +453,20 @@ impl Engine256 {\n         assert!(!self.finished)\n         // Assumes that input.len() can be converted to u64 without overflow\n         self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n-        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n+        let self_state = &mut self.state;\n+        self.buffer.input(input, |input: &[u8]| { self_state.process_block(input) });\n     }\n \n     fn finish(&mut self) {\n         if self.finished {\n             return;\n         }\n \n-        self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n+        let self_state = &mut self.state;\n+        self.buffer.standard_padding(8, |input: &[u8]| { self_state.process_block(input) });\n         write_u32_be(self.buffer.next(4), (self.length_bits >> 32) as u32 );\n         write_u32_be(self.buffer.next(4), self.length_bits as u32);\n-        self.state.process_block(self.buffer.full_buffer());\n+        self_state.process_block(self.buffer.full_buffer());\n \n         self.finished = true;\n     }"}, {"sha": "fee27bd5b317e59bf81cf950a8cc5919261c8a20", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -21,7 +21,6 @@ pub trait DocFolder {\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n         let Item { attrs, name, source, visibility, id, inner } = item;\n         let inner = inner;\n-        let c = |x| self.fold_item(x);\n         let inner = match inner {\n             StructItem(mut i) => {\n                 let mut foo = ~[]; swap(&mut foo, &mut i.fields);\n@@ -72,6 +71,7 @@ pub trait DocFolder {\n                     StructVariant(mut j) => {\n                         let mut foo = ~[]; swap(&mut foo, &mut j.fields);\n                         let num_fields = foo.len();\n+                        let c = |x| self.fold_item(x);\n                         j.fields.extend(&mut foo.move_iter().filter_map(c));\n                         j.fields_stripped |= num_fields != j.fields.len();\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})"}, {"sha": "551e2c9faf74f47ef980cc2fa8e8cd780d93aacf", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -510,8 +510,9 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n                     buf: Some(slice_to_uv_buf(buf)),\n                     result: None,\n                 };\n+                let handle = self.handle;\n                 wait_until_woken_after(&mut cx.task, || {\n-                    unsafe { uvll::set_data_for_uv_handle(self.handle, &cx) }\n+                    unsafe { uvll::set_data_for_uv_handle(handle, &cx) }\n                 });\n                 match cx.result.take_unwrap() {\n                     (n, _) if n < 0 =>"}, {"sha": "54c0d98c79897c1283fe7c195ac31a65b6f343c8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -277,7 +277,7 @@ use str::{StrSlice, OwnedStr};\n use str;\n use to_str::ToStr;\n use uint;\n-use unstable::finally::Finally;\n+use unstable::finally::try_finally;\n use vec::{OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n use vec;\n \n@@ -473,25 +473,33 @@ pub trait Reader {\n     /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n     /// read (an error was encountered), and the error is returned.\n     fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n+        struct State<'a> {\n+            buf: &'a mut ~[u8],\n+            total_read: uint\n+        }\n+\n         let start_len = buf.len();\n-        let mut total_read = 0;\n-\n-        buf.reserve_additional(len);\n-        unsafe { buf.set_len(start_len + len); }\n-\n-        (|| {\n-            while total_read < len {\n-                let len = buf.len();\n-                let slice = buf.mut_slice(start_len + total_read, len);\n-                match self.read(slice) {\n-                    Ok(nread) => {\n-                        total_read += nread;\n+        let mut s = State { buf: buf, total_read: 0 };\n+\n+        s.buf.reserve_additional(len);\n+        unsafe { s.buf.set_len(start_len + len); }\n+\n+        try_finally(\n+            &mut s, (),\n+            |s, _| {\n+                while s.total_read < len {\n+                    let len = s.buf.len();\n+                    let slice = s.buf.mut_slice(start_len + s.total_read, len);\n+                    match self.read(slice) {\n+                        Ok(nread) => {\n+                            s.total_read += nread;\n+                        }\n+                        Err(e) => return Err(e)\n                     }\n-                    Err(e) => return Err(e)\n                 }\n-            }\n-            Ok(())\n-        }).finally(|| unsafe { buf.set_len(start_len + total_read) })\n+                Ok(())\n+            },\n+            |s| unsafe { s.buf.set_len(start_len + s.total_read) })\n     }\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`"}, {"sha": "aeec36a932c464566e2ea68ab630f017a54e265c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -83,7 +83,8 @@ impl Reader for UdpStream {\n \n impl Writer for UdpStream {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.as_socket(|sock| sock.sendto(buf, self.connectedTo))\n+        let connectedTo = self.connectedTo;\n+        self.as_socket(|sock| sock.sendto(buf, connectedTo))\n     }\n }\n "}, {"sha": "bc5991c6eebd01b647cc3631ae1b373b9b25ef46", "filename": "src/libstd/str.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -625,15 +625,17 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n \n         if !self.sorted {\n             for ch in self.iter {\n+                let buffer = &mut self.buffer;\n+                let sorted = &mut self.sorted;\n                 decomposer(ch, |d| {\n                     let class = canonical_combining_class(d);\n-                    if class == 0 && !self.sorted {\n-                        canonical_sort(self.buffer);\n-                        self.sorted = true;\n+                    if class == 0 && !*sorted {\n+                        canonical_sort(*buffer);\n+                        *sorted = true;\n                     }\n-                    self.buffer.push((d, class));\n+                    buffer.push((d, class));\n                 });\n-                if self.sorted { break }\n+                if *sorted { break }\n             }\n         }\n "}, {"sha": "433accecdbcfdbff270ee337aa383265ee08403a", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 79, "deletions": 35, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,6 +12,11 @@\n The Finally trait provides a method, `finally` on\n stack closures that emulates Java-style try/finally blocks.\n \n+Using the `finally` method is sometimes convenient, but the type rules\n+prohibit any shared, mutable state between the \"try\" case and the\n+\"finally\" case. For advanced cases, the `try_finally` function can\n+also be used. See that function for more details.\n+\n # Example\n \n  ```\n@@ -31,67 +36,106 @@ pub trait Finally<T> {\n     fn finally(&self, dtor: ||) -> T;\n }\n \n-macro_rules! finally_fn {\n-    ($fnty:ty) => {\n-        impl<T> Finally<T> for $fnty {\n-            fn finally(&self, dtor: ||) -> T {\n-                let _d = Finallyalizer {\n-                    dtor: dtor\n-                };\n-                (*self)()\n-            }\n-        }\n+impl<'a,T> Finally<T> for 'a || -> T {\n+    fn finally(&self, dtor: ||) -> T {\n+        try_finally(&mut (), (),\n+                    |_, _| (*self)(),\n+                    |_| dtor())\n     }\n }\n \n-impl<'a,T> Finally<T> for 'a || -> T {\n+impl<T> Finally<T> for fn() -> T {\n     fn finally(&self, dtor: ||) -> T {\n-        let _d = Finallyalizer {\n-            dtor: dtor\n-        };\n-\n-        (*self)()\n+        try_finally(&mut (), (),\n+                    |_, _| (*self)(),\n+                    |_| dtor())\n     }\n }\n \n-finally_fn!(extern \"Rust\" fn() -> T)\n+/**\n+ * The most general form of the `finally` functions. The function\n+ * `try_fn` will be invoked first; whether or not it fails, the\n+ * function `finally_fn` will be invoked next. The two parameters\n+ * `mutate` and `drop` are used to thread state through the two\n+ * closures. `mutate` is used for any shared, mutable state that both\n+ * closures require access to; `drop` is used for any state that the\n+ * `try_fn` requires ownership of.\n+ *\n+ * **WARNING:** While shared, mutable state between the try and finally\n+ * function is often necessary, one must be very careful; the `try`\n+ * function could have failed at any point, so the values of the shared\n+ * state may be inconsistent.\n+ *\n+ * # Example\n+ *\n+ * ```\n+ * struct State<'a> { buffer: &'a mut [u8], len: uint }\n+ * let mut state = State { buffer: buf, len: 0 };\n+ * try_finally(\n+ *     &mut state, (),\n+ *     |state, ()| {\n+ *         // use state.buffer, state.len\n+ *     }\n+ *     |state| {\n+ *         // use state.buffer, state.len to cleanup\n+ *     })\n+ * ```\n+ */\n+pub fn try_finally<T,U,R>(mutate: &mut T,\n+                          drop: U,\n+                          try_fn: |&mut T, U| -> R,\n+                          finally_fn: |&mut T|)\n+                          -> R {\n+    let f = Finallyalizer {\n+        mutate: mutate,\n+        dtor: finally_fn,\n+    };\n+    try_fn(&mut *f.mutate, drop)\n+}\n \n-struct Finallyalizer<'a> {\n-    dtor: 'a ||\n+struct Finallyalizer<'a,A> {\n+    mutate: &'a mut A,\n+    dtor: 'a |&mut A|\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for Finallyalizer<'a> {\n+impl<'a,A> Drop for Finallyalizer<'a,A> {\n     #[inline]\n     fn drop(&mut self) {\n-        (self.dtor)();\n+        (self.dtor)(self.mutate);\n     }\n }\n \n #[test]\n fn test_success() {\n     let mut i = 0;\n-    (|| {\n-        i = 10;\n-    }).finally(|| {\n-        assert!(!failing());\n-        assert_eq!(i, 10);\n-        i = 20;\n-    });\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+        },\n+        |i| {\n+            assert!(!failing());\n+            assert_eq!(*i, 10);\n+            *i = 20;\n+        });\n     assert_eq!(i, 20);\n }\n \n #[test]\n #[should_fail]\n fn test_fail() {\n     let mut i = 0;\n-    (|| {\n-        i = 10;\n-        fail!();\n-    }).finally(|| {\n-        assert!(failing());\n-        assert_eq!(i, 10);\n-    })\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+            fail!();\n+        },\n+        |i| {\n+            assert!(failing());\n+            assert_eq!(*i, 10);\n+        })\n }\n \n #[test]"}, {"sha": "2acafecf9572044bdddf51806d6a73fc8c6141bd", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -119,7 +119,7 @@ use mem;\n use mem::size_of;\n use kinds::marker;\n use uint;\n-use unstable::finally::Finally;\n+use unstable::finally::try_finally;\n use unstable::raw::{Repr, Slice, Vec};\n \n /**\n@@ -132,15 +132,16 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         let p = v.as_mut_ptr();\n-        let mut i: uint = 0u;\n-        (|| {\n-            while i < n_elts {\n-                mem::move_val_init(&mut(*ptr::mut_offset(p, i as int)), op(i));\n-                i += 1u;\n-            }\n-        }).finally(|| {\n-            v.set_len(i);\n-        });\n+        let mut i = 0;\n+        try_finally(\n+            &mut i, (),\n+            |i, ()| while *i < n_elts {\n+                mem::move_val_init(\n+                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    op(*i));\n+                *i += 1u;\n+            },\n+            |i| v.set_len(*i));\n         v\n     }\n }\n@@ -160,14 +161,15 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n         let mut v = with_capacity(n_elts);\n         let p = v.as_mut_ptr();\n         let mut i = 0u;\n-        (|| {\n-            while i < n_elts {\n-                mem::move_val_init(&mut(*ptr::mut_offset(p, i as int)), t.clone());\n-                i += 1u;\n-            }\n-        }).finally(|| {\n-            v.set_len(i);\n-        });\n+        try_finally(\n+            &mut i, (),\n+            |i, ()| while *i < n_elts {\n+                mem::move_val_init(\n+                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    t.clone());\n+                *i += 1u;\n+            },\n+            |i| v.set_len(*i));\n         v\n     }\n }\n@@ -294,7 +296,8 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n             return Some(self.v);\n         }\n \n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n             None => {\n                 self.finished = true;\n                 Some(self.v)"}, {"sha": "9d290c93c6494f1edca3268fe0cb548d0101fdcf", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -580,10 +580,12 @@ impl<'a> MethodDef<'a> {\n             ast::SelfStatic => None,\n             _ => Some(ast::Arg::new_self(trait_.span, ast::MutImmutable))\n         };\n-        let args = arg_types.move_iter().map(|(name, ty)| {\n-            cx.arg(trait_.span, name, ty)\n-        });\n-        let args = self_arg.move_iter().chain(args).collect();\n+        let args = {\n+            let args = arg_types.move_iter().map(|(name, ty)| {\n+                    cx.arg(trait_.span, name, ty)\n+                });\n+            self_arg.move_iter().chain(args).collect()\n+        };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n "}, {"sha": "ef7bd7c2bcdec2ffae56a6dd9d544d3146e4afcc", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -60,7 +60,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n     ];\n-    let rand_call = |span| {\n+    let rand_call = |cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n                             ~[ rng[0] ])\n@@ -111,7 +111,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                 let i_expr = cx.expr_uint(v_span, i);\n                 let pat = cx.pat_lit(v_span, i_expr);\n \n-                let thing = rand_thing(cx, v_span, ident, summary, |sp| rand_call(sp));\n+                let thing = rand_thing(cx, v_span, ident, summary, |cx, sp| rand_call(cx, sp));\n                 cx.arm(v_span, ~[ pat ], thing)\n             }).collect::<~[ast::Arm]>();\n \n@@ -130,20 +130,21 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                   trait_span: Span,\n                   ctor_ident: Ident,\n                   summary: &StaticFields,\n-                  rand_call: |Span| -> @Expr)\n+                  rand_call: |&mut ExtCtxt, Span| -> @Expr)\n                   -> @Expr {\n         match *summary {\n             Unnamed(ref fields) => {\n                 if fields.is_empty() {\n                     cx.expr_ident(trait_span, ctor_ident)\n                 } else {\n-                    let exprs = fields.map(|span| rand_call(*span));\n+                    let exprs = fields.map(|span| rand_call(cx, *span));\n                     cx.expr_call_ident(trait_span, ctor_ident, exprs)\n                 }\n             }\n             Named(ref fields) => {\n                 let rand_fields = fields.map(|&(ident, span)| {\n-                    cx.field_imm(span, ident, rand_call(span))\n+                    let e = rand_call(cx, span);\n+                    cx.field_imm(span, ident, e)\n                 });\n                 cx.expr_struct_ident(trait_span, ctor_ident, rand_fields)\n             }"}, {"sha": "e5145fb15f7a1393568c228c38ac5cec833f5c16", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -67,31 +67,32 @@ fn to_str_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure)\n             let mut stmts = ~[cx.stmt_let(span, true, buf, init)];\n             let push_str = cx.ident_of(\"push_str\");\n \n-            let push = |s: @Expr| {\n-                let ebuf = cx.expr_ident(span, buf);\n-                let call = cx.expr_method_call(span, ebuf, push_str, ~[s]);\n-                stmts.push(cx.stmt_expr(call));\n-            };\n+            {\n+                let push = |s: @Expr| {\n+                    let ebuf = cx.expr_ident(span, buf);\n+                    let call = cx.expr_method_call(span, ebuf, push_str, ~[s]);\n+                    stmts.push(cx.stmt_expr(call));\n+                };\n \n-            for (i, &FieldInfo {name, span, self_, .. }) in fields.iter().enumerate() {\n-                if i > 0 {\n-                    push(cx.expr_str(span, InternedString::new(\", \")));\n-                }\n-                match name {\n-                    None => {}\n-                    Some(id) => {\n-                        let interned_id = token::get_ident(id.name);\n-                        let name = interned_id.get() + \": \";\n-                        push(cx.expr_str(span,\n-                                         token::intern_and_get_ident(name)));\n+                for (i, &FieldInfo {name, span, self_, .. }) in fields.iter().enumerate() {\n+                    if i > 0 {\n+                        push(cx.expr_str(span, InternedString::new(\", \")));\n+                    }\n+                    match name {\n+                        None => {}\n+                        Some(id) => {\n+                            let interned_id = token::get_ident(id.name);\n+                            let name = interned_id.get() + \": \";\n+                            push(cx.expr_str(span,\n+                                             token::intern_and_get_ident(name)));\n+                        }\n                     }\n+                    push(cx.expr_method_call(span, self_, to_str, ~[]));\n                 }\n-                push(cx.expr_method_call(span, self_, to_str, ~[]));\n+                push(cx.expr_str(span, end));\n             }\n-            push(cx.expr_str(span, end));\n \n-            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span,\n-                                                                   buf))))\n+            cx.expr_block(cx.block(span, stmts, Some(cx.expr_ident(span, buf))))\n         }\n     };\n "}, {"sha": "d146cd4dae392befa752a43fe95b97cab3e9a3ff", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -709,14 +709,15 @@ pub fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n // expand the elements of a block.\n pub fn expand_block_elts(b: &Block, fld: &mut MacroExpander) -> P<Block> {\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n-    let new_stmts = b.stmts.iter()\n-            .map(|x| {\n+    let new_stmts =\n+        b.stmts.iter().flat_map(|x| {\n+            let renamed_stmt = {\n                 let pending_renames = &mut fld.extsbox.info().pending_renames;\n                 let mut rename_fld = renames_to_fold(pending_renames);\n                 rename_fld.fold_stmt(*x).expect_one(\"rename_fold didn't return one value\")\n-             })\n-            .flat_map(|x| fld.fold_stmt(x).move_iter())\n-            .collect();\n+            };\n+            fld.fold_stmt(renamed_stmt).move_iter()\n+        }).collect();\n     let new_expr = b.expr.map(|x| {\n         let expr = {\n             let pending_renames = &mut fld.extsbox.info().pending_renames;"}, {"sha": "3eacce5eb1d774b7768a6824f4f0f478d0027cfc", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 126, "deletions": 116, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -367,169 +367,179 @@ impl<'a> Context<'a> {\n         return ~[unnamed, allow_dead_code];\n     }\n \n-    /// Translate a `parse::Piece` to a static `rt::Piece`\n-    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::Expr {\n-        let sp = self.fmtsp;\n-        let parsepath = |s: &str| {\n-            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-              self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n-        };\n-        let rtpath = |s: &str| {\n-            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-              self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n-        };\n-        let ctpath = |s: &str| {\n-            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n-              self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n-        };\n-        let none = self.ecx.path_global(sp, ~[\n+    fn parsepath(&self, s: &str) -> ~[ast::Ident] {\n+        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+    }\n+\n+    fn rtpath(&self, s: &str) -> ~[ast::Ident] {\n+        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n+    }\n+\n+    fn ctpath(&self, s: &str) -> ~[ast::Ident] {\n+        ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+          self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+    }\n+\n+    fn none(&self) -> @ast::Expr {\n+        let none = self.ecx.path_global(self.fmtsp, ~[\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n                 self.ecx.ident_of(\"None\")]);\n-        let none = self.ecx.expr_path(none);\n-        let some = |e: @ast::Expr| {\n-            let p = self.ecx.path_global(sp, ~[\n+        self.ecx.expr_path(none)\n+    }\n+\n+    fn some(&self, e: @ast::Expr) -> @ast::Expr {\n+        let p = self.ecx.path_global(self.fmtsp, ~[\n                 self.ecx.ident_of(\"std\"),\n                 self.ecx.ident_of(\"option\"),\n                 self.ecx.ident_of(\"Some\")]);\n-            let p = self.ecx.expr_path(p);\n-            self.ecx.expr_call(sp, p, ~[e])\n-        };\n-        let trans_count = |c: parse::Count| {\n-            match c {\n-                parse::CountIs(i) => {\n-                    self.ecx.expr_call_global(sp, rtpath(\"CountIs\"),\n-                                              ~[self.ecx.expr_uint(sp, i)])\n-                }\n-                parse::CountIsParam(i) => {\n-                    self.ecx.expr_call_global(sp, rtpath(\"CountIsParam\"),\n-                                              ~[self.ecx.expr_uint(sp, i)])\n-                }\n-                parse::CountImplied => {\n-                    let path = self.ecx.path_global(sp, rtpath(\"CountImplied\"));\n-                    self.ecx.expr_path(path)\n-                }\n-                parse::CountIsNextParam => {\n-                    let path = self.ecx.path_global(sp, rtpath(\"CountIsNextParam\"));\n-                    self.ecx.expr_path(path)\n-                }\n-                parse::CountIsName(n) => {\n-                    let i = match self.name_positions.find_equiv(&n) {\n-                        Some(&i) => i,\n-                        None => 0, // error already emitted elsewhere\n-                    };\n-                    let i = i + self.args.len();\n-                    self.ecx.expr_call_global(sp, rtpath(\"CountIsParam\"),\n-                                              ~[self.ecx.expr_uint(sp, i)])\n-                }\n+        let p = self.ecx.expr_path(p);\n+        self.ecx.expr_call(self.fmtsp, p, ~[e])\n+    }\n+\n+    fn trans_count(&self, c: parse::Count) -> @ast::Expr {\n+        let sp = self.fmtsp;\n+        match c {\n+            parse::CountIs(i) => {\n+                self.ecx.expr_call_global(sp, self.rtpath(\"CountIs\"),\n+                                          ~[self.ecx.expr_uint(sp, i)])\n             }\n-        };\n-        let trans_method = |method: &parse::Method| {\n-            let method = match *method {\n-                parse::Select(ref arms, ref default) => {\n-                    let arms = arms.iter().map(|arm| {\n-                        let p = self.ecx.path_global(sp, rtpath(\"SelectArm\"));\n+            parse::CountIsParam(i) => {\n+                self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n+                                          ~[self.ecx.expr_uint(sp, i)])\n+            }\n+            parse::CountImplied => {\n+                let path = self.ecx.path_global(sp, self.rtpath(\"CountImplied\"));\n+                self.ecx.expr_path(path)\n+            }\n+            parse::CountIsNextParam => {\n+                let path = self.ecx.path_global(sp, self.rtpath(\"CountIsNextParam\"));\n+                self.ecx.expr_path(path)\n+            }\n+            parse::CountIsName(n) => {\n+                let i = match self.name_positions.find_equiv(&n) {\n+                    Some(&i) => i,\n+                    None => 0, // error already emitted elsewhere\n+                };\n+                let i = i + self.args.len();\n+                self.ecx.expr_call_global(sp, self.rtpath(\"CountIsParam\"),\n+                                          ~[self.ecx.expr_uint(sp, i)])\n+            }\n+        }\n+    }\n+\n+    fn trans_method(&mut self, method: &parse::Method) -> @ast::Expr {\n+        let sp = self.fmtsp;\n+        let method = match *method {\n+            parse::Select(ref arms, ref default) => {\n+                let arms = arms.iter().map(|arm| {\n+                        let p = self.ecx.path_global(sp, self.rtpath(\"SelectArm\"));\n                         let result = arm.result.iter().map(|p| {\n                             self.trans_piece(p)\n                         }).collect();\n                         let s = token::intern_and_get_ident(arm.selector);\n                         let selector = self.ecx.expr_str(sp, s);\n                         self.ecx.expr_struct(sp, p, ~[\n-                            self.ecx.field_imm(sp,\n-                                               self.ecx.ident_of(\"selector\"),\n-                                               selector),\n-                            self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                               self.ecx.expr_vec_slice(sp, result)),\n-                        ])\n+                                self.ecx.field_imm(sp,\n+                                                   self.ecx.ident_of(\"selector\"),\n+                                                   selector),\n+                                self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n+                                                   self.ecx.expr_vec_slice(sp, result)),\n+                                ])\n                     }).collect();\n-                    let default = default.iter().map(|p| {\n+                let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n-                    self.ecx.expr_call_global(sp, rtpath(\"Select\"), ~[\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Select\"), ~[\n                         self.ecx.expr_vec_slice(sp, arms),\n                         self.ecx.expr_vec_slice(sp, default),\n-                    ])\n-                }\n-                parse::Plural(offset, ref arms, ref default) => {\n-                    let offset = match offset {\n-                        Some(i) => { some(self.ecx.expr_uint(sp, i)) }\n-                        None => { none.clone() }\n-                    };\n-                    let arms = arms.iter().map(|arm| {\n-                        let p = self.ecx.path_global(sp, rtpath(\"PluralArm\"));\n+                        ])\n+            }\n+            parse::Plural(offset, ref arms, ref default) => {\n+                let offset = match offset {\n+                    Some(i) => { self.some(self.ecx.expr_uint(sp, i)) }\n+                    None => { self.none() }\n+                };\n+                let arms = arms.iter().map(|arm| {\n+                        let p = self.ecx.path_global(sp, self.rtpath(\"PluralArm\"));\n                         let result = arm.result.iter().map(|p| {\n-                            self.trans_piece(p)\n-                        }).collect();\n+                                self.trans_piece(p)\n+                            }).collect();\n                         let (lr, selarg) = match arm.selector {\n                             parse::Keyword(t) => {\n-                                let p = ctpath(format!(\"{:?}\", t));\n+                                let p = self.ctpath(format!(\"{:?}\", t));\n                                 let p = self.ecx.path_global(sp, p);\n-                                (rtpath(\"Keyword\"), self.ecx.expr_path(p))\n+                                (self.rtpath(\"Keyword\"), self.ecx.expr_path(p))\n                             }\n                             parse::Literal(i) => {\n-                                (rtpath(\"Literal\"), self.ecx.expr_uint(sp, i))\n+                                (self.rtpath(\"Literal\"), self.ecx.expr_uint(sp, i))\n                             }\n                         };\n                         let selector = self.ecx.expr_call_global(sp,\n-                                lr, ~[selarg]);\n+                                                                 lr, ~[selarg]);\n                         self.ecx.expr_struct(sp, p, ~[\n-                            self.ecx.field_imm(sp,\n-                                               self.ecx.ident_of(\"selector\"),\n-                                               selector),\n-                            self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n-                                               self.ecx.expr_vec_slice(sp, result)),\n-                        ])\n+                                self.ecx.field_imm(sp,\n+                                                   self.ecx.ident_of(\"selector\"),\n+                                                   selector),\n+                                self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n+                                                   self.ecx.expr_vec_slice(sp, result)),\n+                                ])\n                     }).collect();\n-                    let default = default.iter().map(|p| {\n+                let default = default.iter().map(|p| {\n                         self.trans_piece(p)\n                     }).collect();\n-                    self.ecx.expr_call_global(sp, rtpath(\"Plural\"), ~[\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Plural\"), ~[\n                         offset,\n                         self.ecx.expr_vec_slice(sp, arms),\n                         self.ecx.expr_vec_slice(sp, default),\n-                    ])\n-                }\n-            };\n-            let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\"));\n-            let ty = self.ecx.ty_path(self.ecx.path_all(\n+                        ])\n+            }\n+        };\n+        let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\"));\n+        let ty = self.ecx.ty_path(self.ecx.path_all(\n                 sp,\n                 true,\n-                rtpath(\"Method\"),\n+                self.rtpath(\"Method\"),\n                 opt_vec::with(life),\n                 ~[]\n-            ), None);\n-            let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n-            let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n-                                                     self.method_statics.len()));\n-            let item = self.ecx.item(sp, static_name, self.static_attrs(), st);\n-            self.method_statics.push(item);\n-            self.ecx.expr_ident(sp, static_name)\n-        };\n+                    ), None);\n+        let st = ast::ItemStatic(ty, ast::MutImmutable, method);\n+        let static_name = self.ecx.ident_of(format!(\"__STATIC_METHOD_{}\",\n+                                                    self.method_statics.len()));\n+        let item = self.ecx.item(sp, static_name, self.static_attrs(), st);\n+        self.method_statics.push(item);\n+        self.ecx.expr_ident(sp, static_name)\n+    }\n \n+    /// Translate a `parse::Piece` to a static `rt::Piece`\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::Expr {\n+        let sp = self.fmtsp;\n         match *piece {\n             parse::String(s) => {\n                 let s = token::intern_and_get_ident(s);\n                 self.ecx.expr_call_global(sp,\n-                                          rtpath(\"String\"),\n+                                          self.rtpath(\"String\"),\n                                           ~[\n                     self.ecx.expr_str(sp, s)\n                 ])\n             }\n             parse::CurrentArgument => {\n                 let nil = self.ecx.expr_lit(sp, ast::LitNil);\n-                self.ecx.expr_call_global(sp, rtpath(\"CurrentArgument\"), ~[nil])\n+                self.ecx.expr_call_global(sp, self.rtpath(\"CurrentArgument\"), ~[nil])\n             }\n             parse::Argument(ref arg) => {\n                 // Translate the position\n                 let pos = match arg.position {\n                     // These two have a direct mapping\n                     parse::ArgumentNext => {\n                         let path = self.ecx.path_global(sp,\n-                                                        rtpath(\"ArgumentNext\"));\n+                                                        self.rtpath(\"ArgumentNext\"));\n                         self.ecx.expr_path(path)\n                     }\n                     parse::ArgumentIs(i) => {\n-                        self.ecx.expr_call_global(sp, rtpath(\"ArgumentIs\"),\n+                        self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n                                                   ~[self.ecx.expr_uint(sp, i)])\n                     }\n                     // Named arguments are converted to positional arguments at\n@@ -540,7 +550,7 @@ impl<'a> Context<'a> {\n                             None => 0, // error already emitted elsewhere\n                         };\n                         let i = i + self.args.len();\n-                        self.ecx.expr_call_global(sp, rtpath(\"ArgumentIs\"),\n+                        self.ecx.expr_call_global(sp, self.rtpath(\"ArgumentIs\"),\n                                                   ~[self.ecx.expr_uint(sp, i)])\n                     }\n                 };\n@@ -550,20 +560,20 @@ impl<'a> Context<'a> {\n                 let fill = self.ecx.expr_lit(sp, ast::LitChar(fill as u32));\n                 let align = match arg.format.align {\n                     parse::AlignLeft => {\n-                        self.ecx.path_global(sp, parsepath(\"AlignLeft\"))\n+                        self.ecx.path_global(sp, self.parsepath(\"AlignLeft\"))\n                     }\n                     parse::AlignRight => {\n-                        self.ecx.path_global(sp, parsepath(\"AlignRight\"))\n+                        self.ecx.path_global(sp, self.parsepath(\"AlignRight\"))\n                     }\n                     parse::AlignUnknown => {\n-                        self.ecx.path_global(sp, parsepath(\"AlignUnknown\"))\n+                        self.ecx.path_global(sp, self.parsepath(\"AlignUnknown\"))\n                     }\n                 };\n                 let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_uint(sp, arg.format.flags);\n-                let prec = trans_count(arg.format.precision);\n-                let width = trans_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, rtpath(\"FormatSpec\"));\n+                let prec = self.trans_count(arg.format.precision);\n+                let width = self.trans_count(arg.format.width);\n+                let path = self.ecx.path_global(sp, self.rtpath(\"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, ~[\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n@@ -574,19 +584,19 @@ impl<'a> Context<'a> {\n \n                 // Translate the method (if any)\n                 let method = match arg.method {\n-                    None => { none.clone() }\n+                    None => { self.none() }\n                     Some(ref m) => {\n-                        let m = trans_method(*m);\n-                        some(self.ecx.expr_addr_of(sp, m))\n+                        let m = self.trans_method(*m);\n+                        self.some(self.ecx.expr_addr_of(sp, m))\n                     }\n                 };\n-                let path = self.ecx.path_global(sp, rtpath(\"Argument\"));\n+                let path = self.ecx.path_global(sp, self.rtpath(\"Argument\"));\n                 let s = self.ecx.expr_struct(sp, path, ~[\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method),\n                 ]);\n-                self.ecx.expr_call_global(sp, rtpath(\"Argument\"), ~[s])\n+                self.ecx.expr_call_global(sp, self.rtpath(\"Argument\"), ~[s])\n             }\n         }\n     }"}, {"sha": "52ff3798f1b6baf098b89229a8ca9439afd93e66", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -75,14 +75,12 @@ pub trait Folder {\n     }\n \n     fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n-        let fold_attribute = |x| fold_attribute_(x, self);\n-\n         Spanned {\n             node: ast::StructField_ {\n                 kind: sf.node.kind,\n                 id: self.new_id(sf.node.id),\n                 ty: self.fold_ty(sf.node.ty),\n-                attrs: sf.node.attrs.map(|e| fold_attribute(*e))\n+                attrs: sf.node.attrs.map(|e| fold_attribute_(*e, self))\n             },\n             span: self.new_span(sf.span)\n         }\n@@ -225,8 +223,7 @@ pub trait Folder {\n             }\n         }\n \n-        let fold_attribute = |x| fold_attribute_(x, self);\n-        let attrs = v.node.attrs.map(|x| fold_attribute(*x));\n+        let attrs = v.node.attrs.map(|x| fold_attribute_(*x, self));\n \n         let de = match v.node.disr_expr {\n           Some(e) => Some(self.fold_expr(e)),\n@@ -323,8 +320,7 @@ fn fold_meta_item_<T: Folder>(mi: @MetaItem, fld: &mut T) -> @MetaItem {\n             match mi.node {\n                 MetaWord(ref id) => MetaWord((*id).clone()),\n                 MetaList(ref id, ref mis) => {\n-                    let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    MetaList((*id).clone(), mis.map(|e| fold_meta_item(*e)))\n+                    MetaList((*id).clone(), mis.map(|e| fold_meta_item_(*e, fld)))\n                 }\n                 MetaNameValue(ref id, ref s) => {\n                     MetaNameValue((*id).clone(), (*s).clone())\n@@ -604,23 +600,18 @@ pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n }\n \n pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n-    let fold_meta_item = |x| fold_meta_item_(x, folder);\n-    let fold_attribute = |x| fold_attribute_(x, folder);\n-\n     Crate {\n         module: folder.fold_mod(&c.module),\n-        attrs: c.attrs.map(|x| fold_attribute(*x)),\n-        config: c.config.map(|x| fold_meta_item(*x)),\n+        attrs: c.attrs.map(|x| fold_attribute_(*x, folder)),\n+        config: c.config.map(|x| fold_meta_item_(*x, folder)),\n         span: folder.new_span(c.span),\n     }\n }\n \n pub fn noop_fold_item<T: Folder>(i: &Item, folder: &mut T) -> SmallVector<@Item> {\n-    let fold_attribute = |x| fold_attribute_(x, folder);\n-\n     SmallVector::one(@Item {\n         ident: folder.fold_ident(i.ident),\n-        attrs: i.attrs.map(|e| fold_attribute(*e)),\n+        attrs: i.attrs.map(|e| fold_attribute_(*e, folder)),\n         id: folder.new_id(i.id),\n         node: folder.fold_item_underscore(&i.node),\n         vis: i.vis,\n@@ -711,8 +702,6 @@ pub fn noop_fold_pat<T: Folder>(p: @Pat, folder: &mut T) -> @Pat {\n }\n \n pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n-    let fold_field = |x| fold_field_(x, folder);\n-\n     let node = match e.node {\n         ExprVstore(e, v) => {\n             ExprVstore(folder.fold_expr(e), v)\n@@ -824,7 +813,7 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n         ExprStruct(ref path, ref fields, maybe_expr) => {\n             ExprStruct(folder.fold_path(path),\n-                       fields.map(|x| fold_field(*x)),\n+                       fields.map(|x| fold_field_(*x, folder)),\n                        maybe_expr.map(|x| folder.fold_expr(x)))\n         },\n         ExprParen(ex) => ExprParen(folder.fold_expr(ex))"}, {"sha": "653f37d96d473d8bb41cb12cfcc808d59c3e6ff3", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let mut y = None;\n     x.write_downgrade(|write_mode| {\n         y = Some(x.downgrade(write_mode));\n-        //~^ ERROR cannot infer an appropriate lifetime\n+        //~^ ERROR cannot infer\n     });\n     y.unwrap();\n     // Adding this line causes a method unification failure instead"}, {"sha": "dec248a3015d58f2cc175e22a90326e369c72bd4", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -32,9 +32,9 @@ fn b() {\n \n     let mut p = ~[1];\n \n-    borrow(p, || {\n-        p[0] = 5; //~ ERROR cannot assign to\n-    });\n+    borrow(\n+        p,\n+        || p[0] = 5); //~ ERROR cannot borrow `p` as mutable\n }\n \n fn c() {"}, {"sha": "29016a2f44f14921b9f94ab318ff6e7da54634b8", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -21,13 +21,14 @@ impl X {\n \n fn main() {\n     let mut x = X(Right(main));\n-    (&mut x).with(|opt| {\n-        match opt {\n-            &Right(ref f) => {\n-                x = X(Left((0,0))); //~ ERROR cannot assign to `x`\n-                (*f)()\n-            },\n-            _ => fail!()\n-        }\n-    })\n+    (&mut x).with(\n+        |opt| { //~ ERROR cannot borrow `x` as mutable more than once at a time\n+            match opt {\n+                &Right(ref f) => {\n+                    x = X(Left((0,0)));\n+                    (*f)()\n+                },\n+                _ => fail!()\n+            }\n+        })\n }"}, {"sha": "34b9c31fdd82fb8aeb101ce0f87347e68cb0d689", "filename": "src/test/compile-fail/borrowck-borrow-mut-object-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-object-twice.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -18,7 +18,7 @@ trait Foo {\n \n fn test(x: &mut Foo) {\n     let _y = x.f1();\n-    x.f2(); //~ ERROR cannot borrow `*x` because it is already borrowed as mutable\n+    x.f2(); //~ ERROR cannot borrow `*x` as mutable\n }\n \n fn main() {}"}, {"sha": "006f475b29d4ec87663a09888dfc50b0a284e9a0", "filename": "src/test/compile-fail/borrowck-closures-mut-and-imm.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-and-imm.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that two closures cannot simultaneously have mutable\n+// and immutable access to the variable. Issue #6801.\n+\n+fn get(x: &int) -> int {\n+    *x\n+}\n+\n+fn set(x: &mut int) {\n+    *x = 4;\n+}\n+\n+fn a() {\n+    let mut x = 3;\n+    let c1 = || x = 4;\n+    let c2 = || x * 5; //~ ERROR cannot borrow `x`\n+}\n+\n+fn b() {\n+    let mut x = 3;\n+    let c1 = || set(&mut x);\n+    let c2 = || get(&x); //~ ERROR cannot borrow `x`\n+}\n+\n+fn c() {\n+    let mut x = 3;\n+    let c1 = || set(&mut x);\n+    let c2 = || x * 5; //~ ERROR cannot borrow `x`\n+}\n+\n+fn d() {\n+    let mut x = 3;\n+    let c2 = || x * 5;\n+    x = 5; //~ ERROR cannot assign\n+}\n+\n+fn e() {\n+    let mut x = 3;\n+    let c1 = || get(&x);\n+    x = 5; //~ ERROR cannot assign\n+}\n+\n+fn f() {\n+    let mut x = ~3;\n+    let c1 = || get(&*x);\n+    *x = 5; //~ ERROR cannot assign\n+}\n+\n+fn g() {\n+    struct Foo {\n+        f: ~int\n+    }\n+\n+    let mut x = ~Foo { f: ~3 };\n+    let c1 = || get(&*x.f);\n+    *x.f = 5; //~ ERROR cannot assign to `*x.f`\n+}\n+\n+fn h() {\n+    struct Foo {\n+        f: ~int\n+    }\n+\n+    let mut x = ~Foo { f: ~3 };\n+    let c1 = || get(&*x.f);\n+    let c2 = || *x.f = 5; //~ ERROR cannot borrow `x` as mutable\n+}\n+\n+fn main() {\n+}"}, {"sha": "cdfb569762de35a68af839830fb700b0a3e37e23", "filename": "src/test/compile-fail/borrowck-closures-mut-of-imm.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-mut-of-imm.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that two closures cannot simultaneously have mutable\n+// and immutable access to the variable. Issue #6801.\n+\n+fn get(x: &int) -> int {\n+    *x\n+}\n+\n+fn set(x: &mut int) {\n+    *x = 4;\n+}\n+\n+fn a(x: &int) {\n+    let c1 = || set(&mut *x);\n+    //~^ ERROR cannot borrow\n+    let c2 = || set(&mut *x);\n+    //~^ ERROR closure requires unique access to `x`\n+    //~^^ ERROR cannot borrow\n+}\n+\n+fn main() {\n+}"}, {"sha": "570249aed443b5c7d5f2fdf5cd2679bec11ea801", "filename": "src/test/compile-fail/borrowck-closures-two-mut.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-two-mut.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that two closures cannot simultaneously have mutable\n+// access to the variable, whether that mutable access be used\n+// for direct assignment or for taking mutable ref. Issue #6801.\n+\n+fn a() {\n+    let mut x = 3;\n+    let c1 = || x = 4;\n+    let c2 = || x = 5; //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn set(x: &mut int) {\n+    *x = 4;\n+}\n+\n+fn b() {\n+    let mut x = 3;\n+    let c1 = || set(&mut x);\n+    let c2 = || set(&mut x); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn c() {\n+    let mut x = 3;\n+    let c1 = || x = 5;\n+    let c2 = || set(&mut x); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn d() {\n+    let mut x = 3;\n+    let c1 = || x = 5;\n+    let c2 = || { let _y = || set(&mut x); }; // (nested closure)\n+    //~^ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn g() {\n+    struct Foo {\n+        f: ~int\n+    }\n+\n+    let mut x = ~Foo { f: ~3 };\n+    let c1 = || set(&mut *x.f);\n+    let c2 = || set(&mut *x.f);\n+    //~^ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn main() {\n+}"}, {"sha": "80d942e58d15c7e36129d47ae6babed1bab99e03", "filename": "src/test/compile-fail/borrowck-closures-unique.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-unique.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that a closure which requires mutable access to the referent\n+// of an `&mut` requires a \"unique\" borrow -- that is, the variable to\n+// be borrowed (here, `x`) will not be borrowed *mutably*, but\n+//  may be *immutable*, but we cannot allow\n+// multiple borrows.\n+\n+fn get(x: &int) -> int {\n+    *x\n+}\n+\n+fn set(x: &mut int) -> int {\n+    *x\n+}\n+\n+fn a(x: &mut int) {\n+    let c1 = || get(x);\n+    let c2 = || get(x);\n+}\n+\n+fn b(x: &mut int) {\n+    let c1 = || get(x);\n+    let c2 = || set(x); //~ ERROR closure requires unique access to `x`\n+}\n+\n+fn c(x: &mut int) {\n+    let c1 = || get(x);\n+    let c2 = || { get(x); set(x); }; //~ ERROR closure requires unique access to `x`\n+}\n+\n+fn d(x: &mut int) {\n+    let c1 = || set(x);\n+    let c2 = || set(x); //~ ERROR closure requires unique access to `x`\n+}\n+\n+fn e(x: &mut int) {\n+    let c1: || = || x = fail!(); //~ ERROR closure cannot assign to immutable argument `x`\n+}\n+\n+fn main() {\n+}"}, {"sha": "38c13b1fce94f086947eac155299e33d06b7f5c8", "filename": "src/test/compile-fail/borrowck-closures-use-after-free.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-closures-use-after-free.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that a closure which mutates a local variable\n+// cannot also be supplied a borrowed version of that\n+// variable's contents. Issue #11192.\n+\n+struct Foo {\n+  x: int\n+}\n+\n+impl Drop for Foo {\n+  fn drop(&mut self) {\n+    println!(\"drop {}\", self.x);\n+  }\n+}\n+\n+fn main() {\n+  let mut ptr = ~Foo { x: 0 };\n+  let test = |foo: &Foo| {\n+    ptr = ~Foo { x: ptr.x + 1 };\n+  };\n+  test(ptr); //~ ERROR cannot borrow `*ptr`\n+}"}, {"sha": "38ff840ada4089ce71b530e42f3675f588b3e6ae", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -23,9 +23,10 @@ impl Foo {\n }\n \n fn bar(f: &mut Foo) {\n-  f.foo(|a| {\n-    f.n.insert(*a); //~ ERROR cannot borrow\n-  })\n+  f.foo(\n+        |a| { //~ ERROR closure requires unique access to `f`\n+            f.n.insert(*a);\n+        })\n }\n \n fn main() {"}, {"sha": "18fd411101834bb9598c3bd562850176289b32e0", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -21,7 +21,9 @@ fn box_imm() {\n         info!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n     });\n+}\n \n+fn box_imm_explicit() {\n     let v = ~3;\n     let _w = &v;\n     task::spawn(proc() {"}, {"sha": "6a0d3ef82fb21d40de474cf76e88d4c1ef584123", "filename": "src/test/compile-fail/borrowck-loan-blocks-mut-uniq.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-mut-uniq.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,11 +14,12 @@ fn borrow(v: &int, f: |x: &int|) {\n \n fn box_imm() {\n     let mut v = ~3;\n-    borrow(v, |w| {\n-        v = ~4; //~ ERROR cannot assign to `v` because it is borrowed\n-        assert_eq!(*v, 3);\n-        assert_eq!(*w, 4);\n-    })\n+    borrow(v,\n+           |w| { //~ ERROR cannot borrow `v` as mutable\n+            v = ~4;\n+            assert_eq!(*v, 3);\n+            assert_eq!(*w, 4);\n+        })\n }\n \n fn main() {"}, {"sha": "dbeeb5213069b2fa8de90f8a0565403282ac62bd", "filename": "src/test/compile-fail/borrowck-loan-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-rcvr.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -32,8 +32,8 @@ fn a() {\n     p.impurem();\n \n     // But in this case we do not honor the loan:\n-    p.blockm(|| {\n-        p.x = 10; //~ ERROR cannot assign\n+    p.blockm(|| { //~ ERROR cannot borrow `p` as mutable\n+        p.x = 10;\n     })\n }\n "}, {"sha": "0e721d7107f8ba6084816944e8f474a68f1e8f16", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -23,9 +23,11 @@ fn has_mut_vec_and_does_not_try_to_change_it() {\n \n fn has_mut_vec_but_tries_to_change_it() {\n     let mut v = ~[1, 2, 3];\n-    takes_imm_elt(&v[0], || {\n-        v[1] = 4; //~ ERROR cannot assign\n-    })\n+    takes_imm_elt(\n+        &v[0],\n+        || { //~ ERROR cannot borrow `v` as mutable\n+            v[1] = 4;\n+        })\n }\n \n fn main() {"}, {"sha": "f3869e5c9fdbaddb0b4a36482922aff5597a6806", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -9,10 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    // FIXME(#2202) - Due to the way that borrowck treats closures,\n-    // you get two error reports here.\n     let bar = ~3;\n-    let _g = || { //~ ERROR capture of moved value\n-        let _h: proc() -> int = proc() *bar; //~ ERROR capture of moved value\n+    let _g = || {\n+        let _h: proc() -> int = proc() *bar; //~ ERROR cannot move out of captured outer variable\n     };\n }"}, {"sha": "92b77d8243efc93182d96e878d94b7e63dbd6b32", "filename": "src/test/compile-fail/borrowck-object-lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-object-lifetime.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -17,7 +17,7 @@ fn borrowed_receiver<'a>(x: &'a Foo) -> &'a () {\n }\n \n fn owned_receiver(x: ~Foo) -> &() {\n-    x.borrowed() //~ ERROR borrowed value does not live long enough\n+    x.borrowed() //~ ERROR `*x` does not live long enough\n }\n \n fn mut_owned_receiver(mut x: ~Foo) {"}, {"sha": "cca8ed93388bc26fa4ca867bb354a30562c03ab1", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,6 +14,6 @@ fn main() {\n         [1, 2, ..tail] => tail,\n         _ => unreachable!()\n     };\n-    a[0] = 0; //~ ERROR cannot assign to `a[]` because it is borrowed\n+    a[0] = 0; //~ ERROR cannot assign to `a[..]` because it is borrowed\n     t[0];\n }"}, {"sha": "cb1a7d393a88fe34e52d0bb46a33ae90297c2ec4", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,7 +12,7 @@ fn a() {\n     let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [~ref _a] => {\n-            vec[0] = ~4; //~ ERROR cannot assign to `(*vec)[]` because it is borrowed\n+            vec[0] = ~4; //~ ERROR cannot assign\n         }\n         _ => fail!(\"foo\")\n     }\n@@ -22,7 +22,7 @@ fn b() {\n     let mut vec = ~[~1, ~2, ~3];\n     match vec {\n         [.._b] => {\n-            vec[0] = ~4; //~ ERROR cannot assign to `(*vec)[]` because it is borrowed\n+            vec[0] = ~4; //~ ERROR cannot assign\n         }\n     }\n }"}, {"sha": "b471d40a950f122d4dbff5b69c412b02bc3a2793", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -11,7 +11,7 @@\n fn a() -> &int {\n     let vec = ~[1, 2, 3, 4];\n     let tail = match vec {\n-        [_a, ..tail] => &tail[0], //~ ERROR borrowed value does not live long enough\n+        [_a, ..tail] => &tail[0], //~ ERROR `vec[..]` does not live long enough\n         _ => fail!(\"foo\")\n     };\n     tail"}, {"sha": "dcb705856d997b6ad2916298621c21a226b772a2", "filename": "src/test/compile-fail/issue-3154.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -13,7 +13,7 @@ struct thing<'a, Q> {\n }\n \n fn thing<Q>(x: &Q) -> thing<Q> {\n-    thing{ x: x } //~ ERROR cannot infer an appropriate lifetime\n+    thing{ x: x } //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "8e4aa799d1fb93f63e15fd47ee4ffd008577fab0", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -11,7 +11,7 @@\n fn id<T>(t: T) -> T { t }\n \n fn f<'r, T>(v: &'r T) -> 'r || -> T {\n-    id(|| *v) //~ ERROR cannot infer an appropriate lifetime\n+    id(|| *v) //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "ed1725f3240fa3326c8684d344893dfe913f00fe", "filename": "src/test/compile-fail/kindck-owned-trait-contains.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-contains.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -24,7 +24,7 @@ fn main() {\n \n     let y = {\n         let tmp0 = 3;\n-        let tmp1 = &tmp0; //~ ERROR borrowed value does not live long enough\n+        let tmp1 = &tmp0; //~ ERROR `tmp0` does not live long enough\n         repeater(tmp1)\n     };\n     assert!(3 == *(y.get()));"}, {"sha": "1557b290c2cb19e3fb3399b49a438a3becafd73c", "filename": "src/test/compile-fail/moves-based-on-type-access-to-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-access-to-field.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -17,13 +17,13 @@ fn touch<A>(_a: &A) {}\n \n fn f10() {\n     let x = Foo { f: ~\"hi\", y: 3 };\n-    consume(x.f); //~ NOTE `x.f` moved here\n+    consume(x.f);\n     touch(&x.y); //~ ERROR use of partially moved value: `x`\n }\n \n fn f20() {\n     let x = ~[~\"hi\"];\n-    consume(x[0]); //~ NOTE `(*x)[]` moved here\n+    consume(x[0]);\n     touch(&x[0]); //~ ERROR use of partially moved value: `x`\n }\n "}, {"sha": "e3e2ace71adc06c7204ea14e3e8dd1c2959dee16", "filename": "src/test/compile-fail/mut-cant-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-cant-alias.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,5 +14,5 @@ fn main() {\n     let m = RefCell::new(0);\n     let mut b = m.borrow_mut();\n     let b1 = b.get();\n-    let b2 = b.get(); //~ ERROR cannot borrow `b` because it is already borrowed as mutable\n+    let b2 = b.get(); //~ ERROR cannot borrow\n }"}, {"sha": "2e5cf1b504b65d0b3be19f8c1483bb0b2d2c0fb0", "filename": "src/test/compile-fail/mut-ptr-cant-outlive-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-ptr-cant-outlive-ref.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     let p;\n     {\n         let b = m.borrow();\n-        p = b.get(); //~ ERROR borrowed value does not live long enough\n+        p = b.get(); //~ ERROR `b` does not live long enough\n     }\n }"}, {"sha": "ec51f2dc2124434d7161a8975bce842e1b162796", "filename": "src/test/compile-fail/regionck-closure-lifetimes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-closure-lifetimes.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -18,7 +18,7 @@ fn env<'a>(_: &'a uint, blk: |p: 'a |||) {\n \n     let mut state = 0;\n     let statep = &mut state;\n-    blk(|| *statep = 1); //~ ERROR cannot infer an appropriate lifetime\n+    blk(|| *statep = 1); //~ ERROR cannot infer\n }\n \n fn no_env_no_for<'a>(_: &'a uint, blk: |p: 'a |||) {\n@@ -40,7 +40,7 @@ fn repeating_loop() {\n     let state = 0;\n \n     loop {\n-        closure = || state; //~ ERROR cannot infer an appropriate lifetime\n+        closure = || state; //~ ERROR cannot infer\n         break;\n     }\n \n@@ -56,7 +56,7 @@ fn repeating_while() {\n     let state = 0;\n \n     while true {\n-        closure = || state; //~ ERROR cannot infer an appropriate lifetime\n+        closure = || state; //~ ERROR cannot infer\n         break;\n     }\n "}, {"sha": "3e568180b53a4ba26d2a151a747337947e84e9dc", "filename": "src/test/compile-fail/regions-addr-of-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-arg.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,15 +12,15 @@\n // bounded by the current function call.\n \n fn foo(a: int) {\n-    let _p: &'static int = &a; //~ ERROR borrowed value does not live long enough\n+    let _p: &'static int = &a; //~ ERROR `a` does not live long enough\n }\n \n fn bar(a: int) {\n     let _q: &int = &a;\n }\n \n fn zed<'a>(a: int) -> &'a int {\n-    &a //~ ERROR borrowed value does not live long enough\n+    &a //~ ERROR `a` does not live long enough\n }\n \n fn main() {"}, {"sha": "ce89b66cd5b944b76a3021c8842b914adf28bbe8", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,8 +14,7 @@ struct dog {\n \n impl dog {\n     pub fn chase_cat(&mut self) {\n-        let p: &'static mut uint = &mut self.cats_chased;\n-        //~^ ERROR cannot infer an appropriate lifetime\n+        let p: &'static mut uint = &mut self.cats_chased; //~ ERROR cannot infer\n         *p += 1u;\n     }\n "}, {"sha": "7a146c043c8389cfb776c42dc104be176c666f5e", "filename": "src/test/compile-fail/regions-addr-of-upvar-self.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-upvar-self.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -17,8 +17,7 @@ struct dog {\n impl dog {\n     pub fn chase_cat(&mut self) {\n         let _f = || {\n-            let p: &'static mut uint = &mut self.food;\n-            //~^ ERROR cannot infer an appropriate lifetime\n+            let p: &'static mut uint = &mut self.food; //~ ERROR cannot infer\n             *p = 3u;\n         };\n     }"}, {"sha": "5ef043634fbe344f4252acf3ba3f4ca0fbe1d10f", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -17,12 +17,12 @@ struct a_class<'a> { x:&'a int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum<'b>` but found `an_enum<'a>`\n-    //~^ ERROR cannot infer an appropriate lifetime\n+    //~^ ERROR cannot infer\n }\n \n fn a_fn3<'a,'b>(e: a_class<'a>) -> a_class<'b> {\n     return e; //~ ERROR mismatched types: expected `a_class<'b>` but found `a_class<'a>`\n-    //~^ ERROR cannot infer an appropriate lifetime\n+    //~^ ERROR cannot infer\n }\n \n fn main() { }"}, {"sha": "2c3f39795a4f0008be718b2907740bb4c0c8d94c", "filename": "src/test/compile-fail/regions-creating-enums3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,7 +14,7 @@ enum ast<'a> {\n }\n \n fn mk_add_bad1<'a,'b>(x: &'a ast<'a>, y: &'b ast<'b>) -> ast<'a> {\n-    add(x, y) //~ ERROR cannot infer an appropriate lifetime\n+    add(x, y) //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "0cd5a97596045439c9be46acc8488bc1eb788da6", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,7 +14,7 @@ enum ast<'a> {\n }\n \n fn mk_add_bad2<'a>(x: &'a ast<'a>, y: &'a ast<'a>, z: &ast) -> ast {\n-    add(x, y) //~ ERROR cannot infer an appropriate lifetime\n+    add(x, y) //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "f588655d1afa85af5b19e7fc1af8c8a46594d233", "filename": "src/test/compile-fail/regions-escape-loop-via-variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-variable.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -18,6 +18,6 @@ fn main() {\n \n     loop {\n         let x = 1 + *p;\n-        p = &x; //~ ERROR borrowed value does not live long enough\n+        p = &x; //~ ERROR `x` does not live long enough\n     }\n }"}, {"sha": "ccfcc52945daf8121f6871ebb1599f131856cf85", "filename": "src/test/compile-fail/regions-escape-loop-via-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-loop-via-vec.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -14,7 +14,7 @@ fn broken() {\n     let mut _y = ~[&mut x];\n     while x < 10 {\n         let mut z = x;\n-        _y.push(&mut z); //~ ERROR borrowed value does not live long enough\n+        _y.push(&mut z); //~ ERROR `z` does not live long enough\n         x += 1; //~ ERROR cannot assign\n     }\n }"}, {"sha": "9762e5c4690ec82ebe14274cfe018d05b5ee6545", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -20,13 +20,13 @@ fn ordering1<'a, 'b>(x: &'a &'b uint) -> &'a uint {\n \n fn ordering2<'a, 'b>(x: &'a &'b uint, y: &'a uint) -> &'b uint {\n     // However, it is not safe to assume that 'b <= 'a\n-    &*y //~ ERROR cannot infer an appropriate lifetime\n+    &*y //~ ERROR cannot infer\n }\n \n fn ordering3<'a, 'b>(x: &'a uint, y: &'b uint) -> &'a &'b uint {\n     // Do not infer an ordering from the return value.\n     let z: &'b uint = &*x;\n-    //~^ ERROR cannot infer an appropriate lifetime\n+    //~^ ERROR cannot infer\n     fail!();\n }\n "}, {"sha": "b117a1a647643c994d62a726b8b3d906d7bdcb18", "filename": "src/test/compile-fail/regions-free-region-ordering-caller1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller1.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -18,7 +18,7 @@ fn call1<'a>(x: &'a uint) {\n     let y: uint = 3;\n     let z: &'a & uint = &(&y);\n     //~^ ERROR borrowed value does not live long enough\n-    //~^^ ERROR borrowed value does not live long enough\n+    //~^^ ERROR `y` does not live long enough\n }\n \n fn main() {}"}, {"sha": "6f6b6761735c25c318a5eef00ae5b12ea56546b0", "filename": "src/test/compile-fail/regions-free-region-ordering-incorrect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -24,7 +24,7 @@ impl<'b, T> Node<'b, T> {\n   fn get<'a>(&'a self) -> &'b T {\n     match self.next {\n       Some(ref next) => next.get(),\n-      None => &self.val //~ ERROR cannot infer an appropriate lifetime\n+      None => &self.val //~ ERROR cannot infer\n     }\n   }\n }"}, {"sha": "af460dbdd7868cab621b2a21b6a130e1e1d271fa", "filename": "src/test/compile-fail/regions-freevar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-freevar.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,8 +12,7 @@ fn wants_static_fn(_x: 'static ||) {}\n \n fn main() {\n     let i = 3;\n-    wants_static_fn(|| {\n-        //~^ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+    wants_static_fn(|| { //~ ERROR cannot infer\n         info!(\"i={}\", i);\n     })\n }"}, {"sha": "1aafd9057c266809770ea7c8e08dabaa8fc12f62", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -24,7 +24,7 @@ mod argparse {\n \n     impl<'a> Flag<'a> {\n         pub fn set_desc(self, s: &str) -> Flag<'a> {\n-            Flag { //~ ERROR cannot infer an appropriate lifetime\n+            Flag { //~ ERROR cannot infer\n                 name: self.name,\n                 desc: s,\n                 max_count: self.max_count,"}, {"sha": "ad6d1b2742d10c0a564b12e6cbeef1d71009c776", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -22,7 +22,7 @@ struct not_parameterized2 {\n \n fn take1(p: parameterized1) -> parameterized1 { p }\n //~^ ERROR mismatched types\n-//~^^ ERROR cannot infer an appropriate lifetime\n+//~^^ ERROR cannot infer\n \n fn take3(p: not_parameterized1) -> not_parameterized1 { p }\n fn take4(p: not_parameterized2) -> not_parameterized2 { p }"}, {"sha": "66f958c789336a1b778d7028d062e942379bb91d", "filename": "src/test/compile-fail/regions-infer-call-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-call-3.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -16,7 +16,7 @@ fn with<T>(f: |x: &int| -> T) -> T {\n \n fn manip<'a>(x: &'a int) -> int {\n     let z = with(|y| { select(x, y) });\n-    //~^ ERROR cannot infer an appropriate lifetime\n+    //~^ ERROR cannot infer\n     *z\n }\n "}, {"sha": "6596a1d8c2384032b0a8dd88f6db2b7e6b962847", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -23,11 +23,11 @@ struct indirect2<'a> {\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types\n-//~^ ERROR cannot infer an appropriate lifetime\n+//~^ ERROR cannot infer\n \n fn take_indirect1(p: indirect1) -> indirect1 { p }\n \n fn take_indirect2(p: indirect2) -> indirect2 { p } //~ ERROR mismatched types\n-//~^ ERROR cannot infer an appropriate lifetime\n+//~^ ERROR cannot infer\n \n fn main() {}"}, {"sha": "e2f4f791652a59d9966e5b06ac373301c3099db6", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -32,7 +32,7 @@ impl<'a> set_f<'a> for c<'a> {\n \n     fn set_f_bad(&self, b: @b) {\n         self.f = b; //~ ERROR mismatched types: expected `@@&'a int` but found `@@&int`\n-        //~^ ERROR cannot infer an appropriate lifetime\n+        //~^ ERROR cannot infer\n     }\n }\n "}, {"sha": "60eae9ce80af1ce41e32e8624a7e129e676893cc", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,9 +12,10 @@ fn ignore(_f: <'z>|&'z int| -> &'z int) {}\n \n fn nested() {\n     let y = 3;\n-    ignore(|z| {\n-        if false { &y } else { z } //~ ERROR borrowed value does not live long enough\n-    });\n+    ignore(\n+        |z| { //~ ERROR `y` does not live long enough\n+            if false { &y } else { z }\n+        });\n }\n \n fn main() {}"}, {"sha": "c66e5616b849ab395779d74e1ef66764e9741839", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,7 +12,7 @@ fn ignore<T>(t: T) {}\n \n fn nested<'x>(x: &'x int) {\n     let y = 3;\n-    let mut ay = &y; //~ ERROR cannot infer an appropriate lifetime\n+    let mut ay = &y; //~ ERROR cannot infer\n \n     ignore::< <'z>|&'z int|>(|z| {\n         ay = x;\n@@ -22,7 +22,7 @@ fn nested<'x>(x: &'x int) {\n \n     ignore::< <'z>|&'z int| -> &'z int>(|z| {\n         if false { return x; }  //~ ERROR mismatched types\n-        //~^ ERROR cannot infer an appropriate lifetime\n+        //~^ ERROR cannot infer\n         if false { return ay; }\n         return z;\n     });"}, {"sha": "0c335b9d5575fa5a6d0351c5bc8474c306d5abbc", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -19,7 +19,7 @@ fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n fn return_it<'a>() -> &'a int {\n     with(|o| o) //~ ERROR mismatched types\n         //~^ ERROR lifetime of return value does not outlive the function call\n-        //~^^ ERROR cannot infer an appropriate lifetime\n+        //~^^ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "469421751df2b69c4bca156b1725f7d735704c58", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -22,7 +22,7 @@ fn with<R>(f: |x: &int| -> R) -> R {\n fn return_it() -> &int {\n     with(|o| o) //~ ERROR mismatched types\n         //~^ ERROR lifetime of return value does not outlive the function call\n-        //~^^ ERROR cannot infer an appropriate lifetime\n+        //~^^ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "f80e5616bd5554f4fca5ab4749eb4fbad95116f9", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -19,7 +19,7 @@ fn box_it<'r>(x: 'r ||) -> closure_box<'r> {\n fn main() {\n     let cl_box = {\n         let mut i = 3;\n-        box_it(|| i += 1) //~ ERROR cannot infer an appropriate lifetime\n+        box_it(|| i += 1) //~ ERROR cannot infer\n     };\n     (cl_box.cl)();\n }"}, {"sha": "9222fde7789ee7bc6ac91034ffde997972046019", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -38,7 +38,7 @@ impl get_ctxt for Foo<'a> {\n }\n \n fn make_gc2<'a,'b>(foo: Foo<'a>) -> @get_ctxt<'b>  {\n-    return @foo as @get_ctxt; //~ ERROR cannot infer an appropriate lifetime\n+    return @foo as @get_ctxt; //~ ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "cb6c11537c60985e0fc74cc521481d6a924c7ce1", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: cannot infer an appropriate lifetime\n+// error-pattern: cannot infer\n extern mod sync;\n use sync::RWLock;\n fn main() {"}, {"sha": "76c877dcca821b14ad743382c491234e6c203b9f", "filename": "src/test/compile-fail/trait-coercion-generic-regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-coercion-generic-regions.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -24,7 +24,7 @@ impl Trait<&'static str> for Struct {\n \n fn main() {\n     let person = ~\"Fred\";\n-    let person: &str = person;  //~ ERROR borrowed value does not live long enough\n+    let person: &str = person;  //~ ERROR `person[..]` does not live long enough\n     let s: ~Trait<&'static str> = ~Struct { person: person };\n }\n "}, {"sha": "72dbd82e947f1701c64905708828b482bebe077d", "filename": "src/test/compile-fail/vec-mut-iter-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-mut-iter-borrow.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -12,6 +12,6 @@ fn main() {\n     let mut xs = ~[1, 2, 3, 4];\n \n     for x in xs.mut_iter() {\n-        xs.push(1) //~ ERROR cannot borrow `xs` because it is already borrowed as mutable\n+        xs.push(1) //~ ERROR cannot borrow `xs`\n     }\n }"}, {"sha": "3bd12b030411e17b3340f4e502b18bdf06633338", "filename": "src/test/run-pass/borrowck-closures-two-imm.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Frun-pass%2Fborrowck-closures-two-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Frun-pass%2Fborrowck-closures-two-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-closures-two-imm.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that two closures can simultaneously have immutable\n+// access to the variable, whether that immutable access be used\n+// for direct reads or for taking immutable ref. Also check\n+// that the main function can read the variable too while\n+// the closures are in scope. Issue #6801.\n+\n+fn a() -> int {\n+    let mut x = 3;\n+    x += 1;\n+    let c1 = || x * 4;\n+    let c2 = || x * 5;\n+    c1() * c2() * x\n+}\n+\n+fn get(x: &int) -> int {\n+    *x * 4\n+}\n+\n+fn b() -> int {\n+    let mut x = 3;\n+    x += 1;\n+    let c1 = || get(&x);\n+    let c2 = || get(&x);\n+    c1() * c2() * x\n+}\n+\n+fn c() -> int {\n+    let mut x = 3;\n+    x += 1;\n+    let c1 = || x * 5;\n+    let c2 = || get(&x);\n+    c1() * c2() * x\n+}\n+\n+pub fn main() {\n+    assert_eq!(a(), 1280);\n+    assert_eq!(b(), 1024);\n+    assert_eq!(c(), 1280);\n+}"}, {"sha": "59baf63d28400403a044653a80bf5b553a40562c", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -16,5 +16,6 @@ struct Refs { refs: ~[int], n: int }\n pub fn main() {\n     let mut e = Refs{refs: ~[], n: 0};\n     let _f: || = || error!(\"{}\", e.n);\n-    e.refs.push(1);\n+    let x: &[int] = e.refs;\n+    assert_eq!(x.len(), 0);\n }"}, {"sha": "bc491cc9b7f2ec4d9a9858b9811d3f3dea22615f", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "removed", "additions": 0, "deletions": 627, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/2ab248af38c982f42a0a1acf0769e71fa7e77db7/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ab248af38c982f42a0a1acf0769e71fa7e77db7/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=2ab248af38c982f42a0a1acf0769e71fa7e77db7", "patch": "@@ -1,627 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-fast\n-\n-#[feature(managed_boxes)];\n-\n-use std::cell::RefCell;\n-use std::libc::c_void;\n-use std::ptr;\n-use std::mem;\n-use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n-use std::unstable::raw::Vec;\n-\n-#[doc = \"High-level interfaces to `std::unstable::intrinsics::visit_ty` reflection system.\"]\n-\n-/// Trait for visitor that wishes to reflect on data.\n-trait movable_ptr {\n-    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void);\n-}\n-\n-/// Helper function for alignment calculation.\n-#[inline(always)]\n-fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n-\n-struct ptr_visit_adaptor<V>(Inner<V>);\n-\n-impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n-    fn inner<'a>(&'a mut self) -> &'a mut V {\n-        let ptr_visit_adaptor(ref mut i) = *self;\n-        &mut i.inner\n-    }\n-}\n-\n-impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n-\n-    #[inline(always)]\n-    pub fn bump(&mut self, sz: uint) {\n-      self.inner().move_ptr(|p| ((p as uint) + sz) as *c_void)\n-    }\n-\n-    #[inline(always)]\n-    pub fn align(&mut self, a: uint) {\n-      self.inner().move_ptr(|p| align(p as uint, a) as *c_void)\n-    }\n-\n-    #[inline(always)]\n-    pub fn align_to<T>(&mut self) {\n-        self.align(mem::min_align_of::<T>());\n-    }\n-\n-    #[inline(always)]\n-    pub fn bump_past<T>(&mut self) {\n-        self.bump(mem::size_of::<T>());\n-    }\n-\n-}\n-\n-impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n-\n-    fn visit_bot(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner().visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner().visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool(&mut self) -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner().visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int(&mut self) -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner().visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8(&mut self) -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner().visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16(&mut self) -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner().visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32(&mut self) -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner().visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64(&mut self) -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner().visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint(&mut self) -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner().visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8(&mut self) -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner().visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16(&mut self) -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner().visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32(&mut self) -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner().visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64(&mut self) -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner().visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_f32(&mut self) -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner().visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64(&mut self) -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner().visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner().visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_estr_box(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&mut self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner().visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.align_to::<&'static str>();\n-        if ! self.inner().visit_estr_slice() { return false; }\n-        self.bump_past::<&'static str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(&mut self, n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner().visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner().visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner().visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner().visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<Vec<()>>();\n-        // FIXME (#3732): Inner really has to move its own pointers on this one.\n-        // or else possibly we could have some weird interface wherein we\n-        // read-off a word from inner's pointers, but the read-word has to\n-        // always be the same in all sub-pointers? Dubious.\n-        if ! self.inner().visit_vec(mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner().visit_vec(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        true\n-    }\n-\n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner().visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static [u8]>();\n-        if ! self.inner().visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&'static [u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_rec_field(i, name, mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner().visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_class_field(i, name, named, mtbl, inner) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        if ! self.inner().visit_leave_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_tup_field(i, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner().visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner().visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_fn_output(retstyle, variadic, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner().visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_enum(n_variants, get_disr, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner().visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_enum_variant_field(i, offset, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner().visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        if ! self.inner().visit_leave_enum(n_variants, get_disr, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<~TyVisitor>();\n-        if ! self.inner().visit_trait(name) { return false; }\n-        self.bump_past::<~TyVisitor>();\n-        true\n-    }\n-\n-    fn visit_param(&mut self, i: uint) -> bool {\n-        if ! self.inner().visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self(&mut self) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner().visit_self() { return false; }\n-        self.align_to::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_type(&mut self) -> bool {\n-        if ! self.inner().visit_type() { return false; }\n-        true\n-    }\n-}\n-\n-struct my_visitor(@RefCell<Stuff>);\n-\n-#[deriving(Clone)]\n-struct Stuff {\n-    ptr1: *c_void,\n-    ptr2: *c_void,\n-    vals: ~[~str]\n-}\n-\n-impl my_visitor {\n-    pub fn get<T:Clone>(&mut self, f: |T|) {\n-        unsafe {\n-            let my_visitor(s) = *self;\n-            f((*((*s).get().ptr1 as *T)).clone());\n-        }\n-    }\n-\n-    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n-        unsafe {\n-            let my_visitor(s) = *self;\n-            let u = my_visitor(s);\n-            let mut v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n-            visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            true\n-        }\n-    }\n-}\n-\n-struct Inner<V> { inner: V }\n-\n-impl movable_ptr for my_visitor {\n-    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n-        let my_visitor(s) = *self;\n-        let mut this = s.borrow_mut();\n-        this.get().ptr1 = adjustment(this.get().ptr1);\n-        this.get().ptr2 = adjustment(this.get().ptr2);\n-    }\n-}\n-\n-impl TyVisitor for my_visitor {\n-\n-    fn visit_bot(&mut self) -> bool { true }\n-    fn visit_nil(&mut self) -> bool { true }\n-    fn visit_bool(&mut self) -> bool {\n-        self.get::<bool>(|b| {\n-            let my_visitor(s) = *self;\n-            let mut this = s.borrow_mut();\n-            this.get().vals.push(b.to_str());\n-        });\n-        true\n-    }\n-    fn visit_int(&mut self) -> bool {\n-        self.get::<int>(|i| {\n-            let my_visitor(s) = *self;\n-            let mut this = s.borrow_mut();\n-            this.get().vals.push(i.to_str());\n-        });\n-        true\n-    }\n-    fn visit_i8(&mut self) -> bool { true }\n-    fn visit_i16(&mut self) -> bool { true }\n-    fn visit_i32(&mut self) -> bool { true }\n-    fn visit_i64(&mut self) -> bool { true }\n-\n-    fn visit_uint(&mut self) -> bool { true }\n-    fn visit_u8(&mut self) -> bool { true }\n-    fn visit_u16(&mut self) -> bool { true }\n-    fn visit_u32(&mut self) -> bool { true }\n-    fn visit_u64(&mut self) -> bool { true }\n-\n-    fn visit_f32(&mut self) -> bool { true }\n-    fn visit_f64(&mut self) -> bool { true }\n-\n-    fn visit_char(&mut self) -> bool { true }\n-\n-    fn visit_estr_box(&mut self) -> bool { true }\n-    fn visit_estr_uniq(&mut self) -> bool { true }\n-    fn visit_estr_slice(&mut self) -> bool { true }\n-    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { true }\n-\n-    fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n-                        _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_enter_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(&mut self, _i: uint, _name: &str,\n-                       _mtbl: uint, inner: *TyDesc) -> bool {\n-        error!(\"rec field!\");\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(&mut self, _i: uint, _name: &str, _named: bool,\n-                         _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(&mut self, _i: uint, inner: *TyDesc) -> bool {\n-        error!(\"tup field!\");\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint, _align: uint) -> bool {\n-        // FIXME (#3732): this needs to rewind between enum variants, or something.\n-        true\n-    }\n-    fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                _n_fields: uint,\n-                                _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, inner: *TyDesc) -> bool {\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                _n_fields: uint,\n-                                _name: &str) -> bool { true }\n-    fn visit_leave_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&mut self, _name: &str) -> bool { true }\n-    fn visit_param(&mut self, _i: uint) -> bool { true }\n-    fn visit_self(&mut self) -> bool { true }\n-    fn visit_type(&mut self) -> bool { true }\n-}\n-\n-fn get_tydesc_for<T>(_t: T) -> *TyDesc {\n-    unsafe {\n-        get_tydesc::<T>()\n-    }\n-}\n-\n-struct Triple { x: int, y: int, z: int }\n-\n-pub fn main() {\n-    unsafe {\n-        let r = (1,2,3,true,false, Triple {x:5,y:4,z:3}, (12,));\n-        let p = ptr::to_unsafe_ptr(&r) as *c_void;\n-        let u = my_visitor(@RefCell::new(Stuff {ptr1: p,\n-                                                ptr2: p,\n-                                                vals: ~[]}));\n-        let mut v = ptr_visit_adaptor(Inner {inner: u});\n-        let td = get_tydesc_for(r);\n-        error!(\"tydesc sz: {}, align: {}\",\n-               (*td).size, (*td).align);\n-        visit_tydesc(td, &mut v as &mut TyVisitor);\n-\n-        let my_visitor(m) = u;\n-        let mut ub = m.borrow_mut();\n-        let r = ub.get().vals.clone();\n-        for s in r.iter() {\n-            println!(\"val: {}\", *s);\n-        }\n-        error!(\"{:?}\", ub.get().vals.clone());\n-        assert_eq!(ub.get().vals.clone(),\n-                   ~[ ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\", ~\"12\"]);\n-    }\n-}"}, {"sha": "55cb5c626846206b469de8d017242b9bf0332c04", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ac6e5afda2a9741d50d6b5c557ee16fee44878f/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=0ac6e5afda2a9741d50d6b5c557ee16fee44878f", "patch": "@@ -18,8 +18,11 @@ fn box_it<'r>(x: 'r ||) -> closure_box<'r> {\n \n pub fn main() {\n     let mut i = 3;\n-    let cl_box = box_it(|| i += 1);\n     assert_eq!(i, 3);\n-    (cl_box.cl)();\n+    {\n+        let cl = || i += 1;\n+        let cl_box = box_it(cl);\n+        (cl_box.cl)();\n+    }\n     assert_eq!(i, 4);\n }"}]}