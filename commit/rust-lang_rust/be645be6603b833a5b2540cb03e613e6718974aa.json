{"sha": "be645be6603b833a5b2540cb03e613e6718974aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNjQ1YmU2NjAzYjgzM2E1YjI1NDBjYjAzZTYxM2U2NzE4OTc0YWE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-06-07T15:05:58Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-06-19T17:38:37Z"}, "message": "Thread more argument info down from `Hir` into the `mir::LocalDecls`.\n\nNamely, we thread down the `HirId` of the explicit type of the\nargument.  In the case of the special `self` variable with an implicit\ntype, we also thread down a description of its structure (`self`/`mut\nself`/`&self`/`&mut self`).", "tree": {"sha": "0c385c35b34d46afa7036df37ae1e8a483fe5ee6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c385c35b34d46afa7036df37ae1e8a483fe5ee6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be645be6603b833a5b2540cb03e613e6718974aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be645be6603b833a5b2540cb03e613e6718974aa", "html_url": "https://github.com/rust-lang/rust/commit/be645be6603b833a5b2540cb03e613e6718974aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be645be6603b833a5b2540cb03e613e6718974aa/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5c4c5e93887b1e2355fe7fb86e622e6888eede7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c4c5e93887b1e2355fe7fb86e622e6888eede7", "html_url": "https://github.com/rust-lang/rust/commit/c5c4c5e93887b1e2355fe7fb86e622e6888eede7"}], "stats": {"total": 42, "additions": 36, "deletions": 6}, "files": [{"sha": "85671414618038781c9e4c2f81dcedf885e2112a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be645be6603b833a5b2540cb03e613e6718974aa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be645be6603b833a5b2540cb03e613e6718974aa/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=be645be6603b833a5b2540cb03e613e6718974aa", "patch": "@@ -70,11 +70,11 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n-                    Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None))\n+                    Some(ArgInfo(liberated_closure_env_ty(tcx, id, body_id), None, None, None))\n                 }\n                 ty::TyGenerator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n-                    Some(ArgInfo(gen_ty, None))\n+                    Some(ArgInfo(gen_ty, None, None, None))\n                 }\n                 _ => None,\n             };\n@@ -91,7 +91,23 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     .iter()\n                     .enumerate()\n                     .map(|(index, arg)| {\n-                        ArgInfo(fn_sig.inputs()[index], Some(&*arg.pat))\n+                        let owner_id = tcx.hir.body_owner(body_id);\n+                        let opt_ty_info;\n+                        let self_arg;\n+                        if let Some(ref fn_decl) = tcx.hir.fn_decl(owner_id) {\n+                            let ty_hir_id = fn_decl.inputs[index].hir_id;\n+                            let ty_span = tcx.hir.span(tcx.hir.hir_to_node_id(ty_hir_id));\n+                            opt_ty_info = Some(ty_span);\n+                            self_arg = if index == 0 && fn_decl.has_implicit_self {\n+                                Some(ImplicitSelfBinding)\n+                            } else {\n+                                None\n+                            };\n+                        } else {\n+                            opt_ty_info = None;\n+                            self_arg = None;\n+                        }\n+                        ArgInfo(fn_sig.inputs()[index], opt_ty_info, Some(&*arg.pat), self_arg)\n                     });\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n@@ -433,7 +449,12 @@ fn should_abort_on_panic<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n /// the main entry point for building MIR for a function\n \n-struct ArgInfo<'gcx>(Ty<'gcx>, Option<&'gcx hir::Pat>);\n+struct ImplicitSelfBinding;\n+\n+struct ArgInfo<'gcx>(Ty<'gcx>,\n+                     Option<Span>,\n+                     Option<&'gcx hir::Pat>,\n+                     Option<ImplicitSelfBinding>);\n \n fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    fn_id: ast::NodeId,\n@@ -650,7 +671,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      -> BlockAnd<()>\n     {\n         // Allocate locals for the function arguments\n-        for &ArgInfo(ty, pattern) in arguments.iter() {\n+        for &ArgInfo(ty, _, pattern, _) in arguments.iter() {\n             // If this is a simple binding pattern, give the local a nice name for debuginfo.\n             let mut name = None;\n             if let Some(pat) = pattern {\n@@ -676,10 +697,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         let mut scope = None;\n         // Bind the argument patterns\n-        for (index, &ArgInfo(ty, pattern)) in arguments.iter().enumerate() {\n+        for (index, arg_info) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n             let place = Place::Local(local);\n+            let &ArgInfo(ty, opt_ty_info, pattern, ref self_binding) = arg_info;\n \n             if let Some(pattern) = pattern {\n                 let pattern = self.hir.pattern_from_hir(pattern);\n@@ -688,6 +710,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // Don't introduce extra copies for simple bindings\n                     PatternKind::Binding { mutability, var, mode: BindingMode::ByValue, .. } => {\n                         self.local_decls[local].mutability = mutability;\n+                        self.local_decls[local].is_user_variable =\n+                            if let Some(ImplicitSelfBinding) = self_binding {\n+                                Some(ClearCrossCrate::Set(BindingForm::ImplicitSelf))\n+                            } else {\n+                                let binding_mode = ty::BindingMode::BindByValue(mutability.into());\n+                                Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                                    binding_mode, opt_ty_info })))\n+                            };\n                         self.var_indices.insert(var, LocalsForNode::One(local));\n                     }\n                     _ => {"}]}