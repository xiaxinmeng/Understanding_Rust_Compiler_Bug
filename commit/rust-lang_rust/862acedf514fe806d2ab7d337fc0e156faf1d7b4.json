{"sha": "862acedf514fe806d2ab7d337fc0e156faf1d7b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2MmFjZWRmNTE0ZmU4MDZkMmFiN2QzMzdmYzBlMTU2ZmFmMWQ3YjQ=", "commit": {"author": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-03-09T10:06:03Z"}, "committer": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-03-09T12:45:36Z"}, "message": "doc: remove node.js dependency\n\n`prep.js` outputs its own HTML directives, which `pandoc` cannot\nrecognize when converting the document into LaTeX (this is why the\nPDF docs have never been highlighted as of now).\n\nNote that if we were to add the `.rust` class to snippets, we could\nprobably use pandoc's native highlighting capatibilities i.e. Kate.", "tree": {"sha": "682d7d9b654524af6f818f35c8fecc054666ff84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/682d7d9b654524af6f818f35c8fecc054666ff84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/862acedf514fe806d2ab7d337fc0e156faf1d7b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/862acedf514fe806d2ab7d337fc0e156faf1d7b4", "html_url": "https://github.com/rust-lang/rust/commit/862acedf514fe806d2ab7d337fc0e156faf1d7b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/862acedf514fe806d2ab7d337fc0e156faf1d7b4/comments", "author": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62f1d68439dcfd509eaca29887afa97f22938373", "url": "https://api.github.com/repos/rust-lang/rust/commits/62f1d68439dcfd509eaca29887afa97f22938373", "html_url": "https://github.com/rust-lang/rust/commit/62f1d68439dcfd509eaca29887afa97f22938373"}], "stats": {"total": 710, "additions": 5, "deletions": 705}, "files": [{"sha": "873ff54722e33a7e4124033eb0ba39bfb042154a", "filename": "configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/862acedf514fe806d2ab7d337fc0e156faf1d7b4/configure", "raw_url": "https://github.com/rust-lang/rust/raw/862acedf514fe806d2ab7d337fc0e156faf1d7b4/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=862acedf514fe806d2ab7d337fc0e156faf1d7b4", "patch": "@@ -457,7 +457,6 @@ probe CFG_PANDOC           pandoc\n probe CFG_PDFLATEX         pdflatex\n probe CFG_XETEX            xetex\n probe CFG_LUATEX           luatex\n-probe CFG_NODE             nodejs node\n probe CFG_GDB              gdb\n if [ \"$CFG_OSTYPE\" = \"unknown-linux-gnu\" ]\n then"}, {"sha": "58a62b47aa09363b423e7daaad4ee154e2f3766e", "filename": "mk/docs.mk", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/862acedf514fe806d2ab7d337fc0e156faf1d7b4/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/862acedf514fe806d2ab7d337fc0e156faf1d7b4/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=862acedf514fe806d2ab7d337fc0e156faf1d7b4", "patch": "@@ -93,11 +93,6 @@ $(info cfg: no pandoc found, omitting PDF and EPUB docs)\n ONLY_HTML_DOCS = 1\n endif\n \n-ifeq ($(CFG_NODE),)\n-$(info cfg: no node found, omitting PDF and EPUB docs)\n-ONLY_HTML_DOCS = 1\n-endif\n-\n \n ######################################################################\n # Rust version\n@@ -118,7 +113,7 @@ doc/version_info.html: $(D)/version_info.html.template $(MKFILE_DEPS) \\\n GENERATED += doc/version.md doc/version_info.html\n \n ######################################################################\n-# Docs, from rustdoc and sometimes pandoc & node\n+# Docs, from rustdoc and sometimes pandoc\n ######################################################################\n \n doc/:\n@@ -168,15 +163,13 @@ ifneq ($(ONLY_HTML_DOCS),1)\n DOC_TARGETS += doc/$(1).epub\n doc/$(1).epub: $$(D)/$(1).md | doc/\n \t@$$(call E, pandoc: $$@)\n-\t$$(Q)$$(CFG_NODE) $$(D)/prep.js --highlight $$< | \\\n-\t$$(CFG_PANDOC) $$(PANDOC_EPUB_OPTS) --output=$$@\n+\t$$(CFG_PANDOC) $$(PANDOC_EPUB_OPTS) $$< --output=$$@\n \n # PDF (md =(pandoc)=> tex =(pdflatex)=> pdf)\n DOC_TARGETS += doc/$(1).tex\n doc/$(1).tex: $$(D)/$(1).md doc/footer.tex doc/version.md | doc/\n \t@$$(call E, pandoc: $$@)\n-\t$$(Q)$$(CFG_NODE) $$(D)/prep.js $$< | \\\n-\t$$(CFG_PANDOC) $$(PANDOC_TEX_OPTS) --output=$$@\n+\t$$(CFG_PANDOC) $$(PANDOC_TEX_OPTS) $$< --output=$$@\n \n ifneq ($(NO_PDF_DOCS),1)\n ifeq ($$(SHOULD_BUILD_PDF_DOC_$(1)),1)"}, {"sha": "be0938022d2cc28f22346332dcd9e15673334fc1", "filename": "src/doc/README.md", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/862acedf514fe806d2ab7d337fc0e156faf1d7b4/src%2Fdoc%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/862acedf514fe806d2ab7d337fc0e156faf1d7b4/src%2Fdoc%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2FREADME.md?ref=862acedf514fe806d2ab7d337fc0e156faf1d7b4", "patch": "@@ -4,10 +4,6 @@\n document converter, is required to generate docs as HTML from Rust's\n source code.\n \n-[Node.js](http://nodejs.org/) is also required for generating HTML from\n-the Markdown docs (reference manual, tutorials, etc.) distributed with\n-this git repository.\n-\n [po4a](http://po4a.alioth.debian.org/) is required for generating translated\n docs from the master (English) docs.\n \n@@ -30,8 +26,8 @@ rustdoc --output-dir html-doc/ --output-format html ../src/libstd/path.rs\n \n # Additional notes\n \n-To generate an HTML version of a doc from Markdown without having Node.js\n-installed, you can do something like:\n+To generate an HTML version of a doc from Markdown manually, you can do\n+something like:\n \n ~~~~\n pandoc --from=markdown --to=html5 --number-sections -o rust.html rust.md"}, {"sha": "6818ae8b12597e0bcea017a71a19935ee77974ae", "filename": "src/doc/lib/codemirror-node.js", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Flib%2Fcodemirror-node.js", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Flib%2Fcodemirror-node.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Flib%2Fcodemirror-node.js?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -1,146 +0,0 @@\n-// Copyright (C) 2013 by Marijn Haverbeke <marijnh@gmail.com> and others\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a copy\n-// of this software and associated documentation files (the \"Software\"), to deal\n-// in the Software without restriction, including without limitation the rights\n-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-// copies of the Software, and to permit persons to whom the Software is\n-// furnished to do so, subject to the following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included in\n-// all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-// THE SOFTWARE.\n-\n-exports.htmlEscape = function(text) {\n-  var replacements = {\"<\": \"&lt;\", \">\": \"&gt;\",\n-                      \"&\": \"&amp;\", \"\\\"\": \"&quot;\"};\n-  return text.replace(/[<>&\"]/g, function(character) {\n-    return replacements[character];\n-  });\n-};\n-\n-exports.splitLines = function(string){return string.split(/\\r?\\n/);};\n-\n-// Counts the column offset in a string, taking tabs into account.\n-// Used mostly to find indentation.\n-function countColumn(string, end) {\n-  tabSize = 4;\n-  if (end == null) {\n-    end = string.search(/[^\\s\\u00a0]/);\n-    if (end == -1) end = string.length;\n-  }\n-  for (var i = 0, n = 0; i < end; ++i) {\n-    if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n-    else ++n;\n-  }\n-  return n;\n-}\n-\n-function StringStream(string) {\n-  this.pos = this.start = 0;\n-  this.string = string;\n-}\n-StringStream.prototype = {\n-  eol: function() {return this.pos >= this.string.length;},\n-  sol: function() {return this.pos == 0;},\n-  peek: function() {return this.string.charAt(this.pos);},\n-  next: function() {\n-    if (this.pos < this.string.length)\n-      return this.string.charAt(this.pos++);\n-  },\n-  eat: function(match) {\n-    var ch = this.string.charAt(this.pos);\n-    if (typeof match == \"string\") var ok = ch == match;\n-    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n-    if (ok) {++this.pos; return ch;}\n-  },\n-  eatWhile: function(match) {\n-    var start = this.pos;\n-    while (this.eat(match)){}\n-    return this.pos > start;\n-  },\n-  eatSpace: function() {\n-    var start = this.pos;\n-    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n-    return this.pos > start;\n-  },\n-  skipToEnd: function() {this.pos = this.string.length;},\n-  skipTo: function(ch) {\n-    var found = this.string.indexOf(ch, this.pos);\n-    if (found > -1) {this.pos = found; return true;}\n-  },\n-  backUp: function(n) {this.pos -= n;},\n-  column: function() {return countColumn(this.string, this.start);},\n-  indentation: function() {return countColumn(this.string);},\n-  match: function(pattern, consume, caseInsensitive) {\n-    if (typeof pattern == \"string\") {\n-      function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}\n-      if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n-        if (consume !== false) this.pos += pattern.length;\n-        return true;\n-      }\n-    }\n-    else {\n-      var match = this.string.slice(this.pos).match(pattern);\n-      if (match && consume !== false) this.pos += match[0].length;\n-      return match;\n-    }\n-  },\n-  current: function(){return this.string.slice(this.start, this.pos);}\n-};\n-exports.StringStream = StringStream;\n-\n-exports.startState = function(mode, a1, a2) {\n-  return mode.startState ? mode.startState(a1, a2) : true;\n-};\n-\n-var modes = {}, mimeModes = {};\n-exports.defineMode = function(name, mode) { modes[name] = mode; };\n-exports.defineMIME = function(mime, spec) { mimeModes[mime] = spec; };\n-exports.getMode = function(options, spec) {\n-  if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n-    spec = mimeModes[spec];\n-  if (typeof spec == \"string\")\n-    var mname = spec, config = {};\n-  else if (spec != null)\n-    var mname = spec.name, config = spec;\n-  var mfactory = modes[mname];\n-  if (!mfactory) throw new Error(\"Unknown mode: \" + spec);\n-  return mfactory(options, config || {});\n-};\n-\n-exports.runMode = function(string, modespec, callback) {\n-  var mode = exports.getMode({indentUnit: 2}, modespec);\n-  var isNode = callback.nodeType == 1;\n-  if (isNode) {\n-    var node = callback, accum = [];\n-    callback = function(string, style) {\n-      if (string == \"\\n\")\n-        accum.push(\"<br>\");\n-      else if (style)\n-        accum.push(\"<span class=\\\"cm-\" + exports.htmlEscape(style) + \"\\\">\" +\n-                    exports.htmlEscape(string) + \"</span>\");\n-      else\n-        accum.push(exports.htmlEscape(string));\n-    }\n-  }\n-  var lines = exports.splitLines(string), state = exports.startState(mode);\n-  for (var i = 0, e = lines.length; i < e; ++i) {\n-    if (i) callback(\"\\n\");\n-    var stream = new exports.StringStream(lines[i]);\n-    while (!stream.eol()) {\n-      var style = mode.token(stream, state);\n-      callback(stream.current(), style, i, stream.start);\n-      stream.start = stream.pos;\n-    }\n-  }\n-  if (isNode)\n-    node.innerHTML = accum.join(\"\");\n-};"}, {"sha": "7f933d6b82ee71eafa0c8f2536e05dc29c69fe43", "filename": "src/doc/lib/codemirror-rust.js", "status": "removed", "additions": 0, "deletions": 453, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Flib%2Fcodemirror-rust.js", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Flib%2Fcodemirror-rust.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Flib%2Fcodemirror-rust.js?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -1,453 +0,0 @@\n-// Copyright (C) 2013 by Marijn Haverbeke <marijnh@gmail.com> and others\n-//\n-// Permission is hereby granted, free of charge, to any person obtaining a copy\n-// of this software and associated documentation files (the \"Software\"), to deal\n-// in the Software without restriction, including without limitation the rights\n-// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-// copies of the Software, and to permit persons to whom the Software is\n-// furnished to do so, subject to the following conditions:\n-//\n-// The above copyright notice and this permission notice shall be included in\n-// all copies or substantial portions of the Software.\n-//\n-// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-// THE SOFTWARE.\n-\n-CodeMirror.defineMode(\"rust\", function() {\n-  var indentUnit = 4, altIndentUnit = 2;\n-  var valKeywords = {\n-    \"if\": \"if-style\", \"while\": \"if-style\", \"loop\": \"if-style\", \"else\": \"else-style\",\n-    \"do\": \"else-style\", \"return\": \"else-style\",\n-    \"break\": \"atom\", \"cont\": \"atom\", \"const\": \"let\", \"resource\": \"fn\",\n-    \"let\": \"let\", \"fn\": \"fn\", \"for\": \"for\", \"match\": \"match\", \"trait\": \"trait\",\n-    \"impl\": \"impl\", \"type\": \"type\", \"enum\": \"enum\", \"struct\": \"atom\", \"mod\": \"mod\",\n-    \"as\": \"op\", \"true\": \"atom\", \"false\": \"atom\", \"assert\": \"op\", \"check\": \"op\",\n-    \"claim\": \"op\", \"extern\": \"ignore\", \"unsafe\": \"ignore\", \"import\": \"else-style\",\n-    \"export\": \"else-style\", \"copy\": \"op\", \"log\": \"op\",\n-    \"use\": \"op\", \"self\": \"atom\", \"pub\": \"atom\", \"priv\": \"atom\"\n-  };\n-  var typeKeywords = function() {\n-    var keywords = {\"fn\": \"fn\"};\n-    var atoms = \"bool uint int i8 i16 i32 i64 u8 u16 u32 u64 float f32 f64 str char\".split(\" \");\n-    for (var i = 0, e = atoms.length; i < e; ++i) keywords[atoms[i]] = \"atom\";\n-    return keywords;\n-  }();\n-  var operatorChar = /[+\\-*&%=<>!?|\\.@]/;\n-\n-  // Tokenizer\n-\n-  // Used as scratch variable to communicate multiple values without\n-  // consing up tons of objects.\n-  var tcat, content;\n-  function r(tc, style) {\n-    tcat = tc;\n-    return style;\n-  }\n-\n-  function tokenBase(stream, state) {\n-    var ch = stream.next();\n-    if (ch == '\"') {\n-      state.tokenize = tokenString;\n-      return state.tokenize(stream, state);\n-    }\n-    if (ch == \"'\") {\n-      tcat = \"atom\";\n-      if (stream.eat(\"\\\\\")) {\n-        if (stream.skipTo(\"'\")) { stream.next(); return \"string\"; }\n-        else { return \"error\"; }\n-      } else {\n-        stream.next();\n-        return stream.eat(\"'\") ? \"string\" : \"error\";\n-      }\n-    }\n-    if (ch == \"/\") {\n-      if (stream.eat(\"/\")) { stream.skipToEnd(); return \"comment\"; }\n-      if (stream.eat(\"*\")) {\n-        state.tokenize = tokenComment(1);\n-        return state.tokenize(stream, state);\n-      }\n-    }\n-    if (ch == \"#\") {\n-      if (stream.eat(\"[\")) { tcat = \"open-attr\"; return null; }\n-      stream.eatWhile(/\\w/);\n-      return r(\"macro\", \"meta\");\n-    }\n-    if (ch == \":\" && stream.match(\":<\")) {\n-      return r(\"op\", null);\n-    }\n-    if (ch.match(/\\d/) || (ch == \".\" && stream.eat(/\\d/))) {\n-      var flp = false;\n-      if (!stream.match(/^x[\\da-f]+/i) && !stream.match(/^b[01]+/)) {\n-        stream.eatWhile(/\\d/);\n-        if (stream.eat(\".\")) { flp = true; stream.eatWhile(/\\d/); }\n-        if (stream.match(/^e[+\\-]?\\d+/i)) { flp = true; }\n-      }\n-      if (flp) stream.match(/^f(?:32|64)/);\n-      else stream.match(/^[ui](?:8|16|32|64)/);\n-      return r(\"atom\", \"number\");\n-    }\n-    if (ch.match(/[()\\[\\]{}:;,]/)) return r(ch, null);\n-    if (ch == \"-\" && stream.eat(\">\")) return r(\"->\", null);\n-    if (ch.match(operatorChar)) {\n-      stream.eatWhile(operatorChar);\n-      return r(\"op\", null);\n-    }\n-    stream.eatWhile(/\\w/);\n-    content = stream.current();\n-    if (stream.match(/^::\\w/)) {\n-      stream.backUp(1);\n-      return r(\"prefix\", \"variable-2\");\n-    }\n-    if (state.keywords.propertyIsEnumerable(content))\n-      return r(state.keywords[content], content.match(/true|false/) ? \"atom\" : \"keyword\");\n-    return r(\"name\", \"variable\");\n-  }\n-\n-  function tokenString(stream, state) {\n-    var ch, escaped = false;\n-    while (ch = stream.next()) {\n-      if (ch == '\"' && !escaped) {\n-        state.tokenize = tokenBase;\n-        return r(\"atom\", \"string\");\n-      }\n-      escaped = !escaped && ch == \"\\\\\";\n-    }\n-    // Hack to not confuse the parser when a string is split in\n-    // pieces.\n-    return r(\"op\", \"string\");\n-  }\n-\n-  function tokenComment(depth) {\n-    return function(stream, state) {\n-      var lastCh = null, ch;\n-      while (ch = stream.next()) {\n-        if (ch == \"/\" && lastCh == \"*\") {\n-          if (depth == 1) {\n-            state.tokenize = tokenBase;\n-            break;\n-          } else {\n-            state.tokenize = tokenComment(depth - 1);\n-            return state.tokenize(stream, state);\n-          }\n-        }\n-        if (ch == \"*\" && lastCh == \"/\") {\n-          state.tokenize = tokenComment(depth + 1);\n-          return state.tokenize(stream, state);\n-        }\n-        lastCh = ch;\n-      }\n-      return \"comment\";\n-    };\n-  }\n-\n-  // Parser\n-\n-  var cx = {state: null, stream: null, marked: null, cc: null};\n-  function pass() {\n-    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n-  }\n-  function cont() {\n-    pass.apply(null, arguments);\n-    return true;\n-  }\n-\n-  function pushlex(type, info) {\n-    var result = function() {\n-      var state = cx.state;\n-      state.lexical = {indented: state.indented, column: cx.stream.column(),\n-                       type: type, prev: state.lexical, info: info};\n-    };\n-    result.lex = true;\n-    return result;\n-  }\n-  function poplex() {\n-    var state = cx.state;\n-    if (state.lexical.prev) {\n-      if (state.lexical.type == \")\")\n-        state.indented = state.lexical.indented;\n-      state.lexical = state.lexical.prev;\n-    }\n-  }\n-  function typecx() { cx.state.keywords = typeKeywords; }\n-  function valcx() { cx.state.keywords = valKeywords; }\n-  poplex.lex = typecx.lex = valcx.lex = true;\n-\n-  function commasep(comb, end) {\n-    function more(type) {\n-      if (type == \",\") return cont(comb, more);\n-      if (type == end) return cont();\n-      return cont(more);\n-    }\n-    return function(type) {\n-      if (type == end) return cont();\n-      return pass(comb, more);\n-    };\n-  }\n-\n-  function stat_of(comb, tag) {\n-    return cont(pushlex(\"stat\", tag), comb, poplex, block);\n-  }\n-  function block(type) {\n-    if (type == \"}\") return cont();\n-    if (type == \"let\") return stat_of(letdef1, \"let\");\n-    if (type == \"fn\") return stat_of(fndef);\n-    if (type == \"type\") return cont(pushlex(\"stat\"), tydef, endstatement, poplex, block);\n-    if (type == \"enum\") return stat_of(tagdef);\n-    if (type == \"mod\") return stat_of(mod);\n-    if (type == \"trait\") return stat_of(trait);\n-    if (type == \"impl\") return stat_of(impl);\n-    if (type == \"open-attr\") return cont(pushlex(\"]\"), commasep(expression, \"]\"), poplex);\n-    if (type == \"ignore\" || type.match(/[\\]\\);,]/)) return cont(block);\n-    return pass(pushlex(\"stat\"), expression, poplex, endstatement, block);\n-  }\n-  function endstatement(type) {\n-    if (type == \";\") return cont();\n-    return pass();\n-  }\n-  function expression(type) {\n-    if (type == \"atom\" || type == \"name\") return cont(maybeop);\n-    if (type == \"{\") return cont(pushlex(\"}\"), exprbrace, poplex);\n-    if (type.match(/[\\[\\(]/)) return matchBrackets(type, expression);\n-    if (type.match(/[\\]\\)\\};,]/)) return pass();\n-    if (type == \"if-style\") return cont(expression, expression);\n-    if (type == \"else-style\" || type == \"op\") return cont(expression);\n-    if (type == \"for\") return cont(pattern, maybetype, inop, expression, expression);\n-    if (type == \"match\") return cont(expression, altbody);\n-    if (type == \"fn\") return cont(fndef);\n-    if (type == \"macro\") return cont(macro);\n-    return cont();\n-  }\n-  function maybeop(type) {\n-    if (content == \".\") return cont(maybeprop);\n-    if (content == \"::<\"){return cont(typarams, maybeop);}\n-    if (type == \"op\" || content == \":\") return cont(expression);\n-    if (type == \"(\" || type == \"[\") return matchBrackets(type, expression);\n-    return pass();\n-  }\n-  function maybeprop(type) {\n-    if (content.match(/^\\w+$/)) {cx.marked = \"variable\"; return cont(maybeop);}\n-    return pass(expression);\n-  }\n-  function exprbrace(type) {\n-    if (type == \"op\") {\n-      if (content == \"|\") return cont(blockvars, poplex, pushlex(\"}\", \"block\"), block);\n-      if (content == \"||\") return cont(poplex, pushlex(\"}\", \"block\"), block);\n-    }\n-    if (content == \"mut\" || (content.match(/^\\w+$/) && cx.stream.peek() == \":\"\n-                                 && !cx.stream.match(\"::\", false)))\n-      return pass(record_of(expression));\n-    return pass(block);\n-  }\n-  function record_of(comb) {\n-    function ro(type) {\n-      if (content == \"mut\" || content == \"with\") {cx.marked = \"keyword\"; return cont(ro);}\n-      if (content.match(/^\\w*$/)) {cx.marked = \"variable\"; return cont(ro);}\n-      if (type == \":\") return cont(comb, ro);\n-      if (type == \"}\") return cont();\n-      return cont(ro);\n-    }\n-    return ro;\n-  }\n-  function blockvars(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(blockvars);}\n-    if (type == \"op\" && content == \"|\") return cont();\n-    return cont(blockvars);\n-  }\n-\n-  function letdef1(type) {\n-    if (type.match(/[\\]\\)\\};]/)) return cont();\n-    if (content == \"=\") return cont(expression, letdef2);\n-    if (type == \",\") return cont(letdef1);\n-    return pass(pattern, maybetype, letdef1);\n-  }\n-  function letdef2(type) {\n-    if (type.match(/[\\]\\)\\};,]/)) return pass(letdef1);\n-    else return pass(expression, letdef2);\n-  }\n-  function maybetype(type) {\n-    if (type == \":\") return cont(typecx, rtype, valcx);\n-    return pass();\n-  }\n-  function inop(type) {\n-    if (type == \"name\" && content == \"in\") {cx.marked = \"keyword\"; return cont();}\n-    return pass();\n-  }\n-  function fndef(type) {\n-    if (content == \"@\" || content == \"~\") {cx.marked = \"keyword\"; return cont(fndef);}\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(fndef);}\n-    if (content == \"<\") return cont(typarams, fndef);\n-    if (type == \"{\") return pass(expression);\n-    if (type == \"(\") return cont(pushlex(\")\"), commasep(argdef, \")\"), poplex, fndef);\n-    if (type == \"->\") return cont(typecx, rtype, valcx, fndef);\n-    if (type == \";\") return cont();\n-    return cont(fndef);\n-  }\n-  function tydef(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(tydef);}\n-    if (content == \"<\") return cont(typarams, tydef);\n-    if (content == \"=\") return cont(typecx, rtype, valcx);\n-    return cont(tydef);\n-  }\n-  function tagdef(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(tagdef);}\n-    if (content == \"<\") return cont(typarams, tagdef);\n-    if (content == \"=\") return cont(typecx, rtype, valcx, endstatement);\n-    if (type == \"{\") return cont(pushlex(\"}\"), typecx, tagblock, valcx, poplex);\n-    return cont(tagdef);\n-  }\n-  function tagblock(type) {\n-    if (type == \"}\") return cont();\n-    if (type == \"(\") return cont(pushlex(\")\"), commasep(rtype, \")\"), poplex, tagblock);\n-    if (content.match(/^\\w+$/)) cx.marked = \"def\";\n-    return cont(tagblock);\n-  }\n-  function mod(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(mod);}\n-    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n-    return pass();\n-  }\n-  function trait(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(trait);}\n-    if (content == \"<\") return cont(typarams, trait);\n-    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n-    return pass();\n-  }\n-  function impl(type) {\n-    if (content == \"<\") return cont(typarams, impl);\n-    if (content == \"of\" || content == \"for\") {cx.marked = \"keyword\"; return cont(rtype, impl);}\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(impl);}\n-    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n-    return pass();\n-  }\n-  function typarams(type) {\n-    if (content == \">\") return cont();\n-    if (content == \",\") return cont(typarams);\n-    if (content == \":\") return cont(rtype, typarams);\n-    return pass(rtype, typarams);\n-  }\n-  function argdef(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(argdef);}\n-    if (type == \":\") return cont(typecx, rtype, valcx);\n-    return pass();\n-  }\n-  function rtype(type) {\n-    if (type == \"name\") {cx.marked = \"variable-3\"; return cont(rtypemaybeparam); }\n-    if (content == \"mut\") {cx.marked = \"keyword\"; return cont(rtype);}\n-    if (type == \"atom\") return cont(rtypemaybeparam);\n-    if (type == \"op\" || type == \"obj\") return cont(rtype);\n-    if (type == \"fn\") return cont(fntype);\n-    if (type == \"{\") return cont(pushlex(\"{\"), record_of(rtype), poplex);\n-    return matchBrackets(type, rtype);\n-  }\n-  function rtypemaybeparam(type) {\n-    if (content == \"<\") return cont(typarams);\n-    return pass();\n-  }\n-  function fntype(type) {\n-    if (type == \"(\") return cont(pushlex(\"(\"), commasep(rtype, \")\"), poplex, fntype);\n-    if (type == \"->\") return cont(rtype);\n-    return pass();\n-  }\n-  function pattern(type) {\n-    if (type == \"name\") {cx.marked = \"def\"; return cont(patternmaybeop);}\n-    if (type == \"atom\") return cont(patternmaybeop);\n-    if (type == \"op\") return cont(pattern);\n-    if (type.match(/[\\]\\)\\};,]/)) return pass();\n-    return matchBrackets(type, pattern);\n-  }\n-  function patternmaybeop(type) {\n-    if (type == \"op\" && content == \".\") return cont();\n-    if (content == \"to\") {cx.marked = \"keyword\"; return cont(pattern);}\n-    else return pass();\n-  }\n-  function altbody(type) {\n-    if (type == \"{\") return cont(pushlex(\"}\", \"match\"), altblock1, poplex);\n-    return pass();\n-  }\n-  function altblock1(type) {\n-    if (type == \"}\") return cont();\n-    if (type == \"|\") return cont(altblock1);\n-    if (content == \"when\") {cx.marked = \"keyword\"; return cont(expression, altblock2);}\n-    if (type.match(/[\\]\\);,]/)) return cont(altblock1);\n-    return pass(pattern, altblock2);\n-  }\n-  function altblock2(type) {\n-    if (type == \"{\") return cont(pushlex(\"}\", \"match\"), block, poplex, altblock1);\n-    else return pass(altblock1);\n-  }\n-\n-  function macro(type) {\n-    if (type.match(/[\\[\\(\\{]/)) return matchBrackets(type, expression);\n-    return pass();\n-  }\n-  function matchBrackets(type, comb) {\n-    if (type == \"[\") return cont(pushlex(\"]\"), commasep(comb, \"]\"), poplex);\n-    if (type == \"(\") return cont(pushlex(\")\"), commasep(comb, \")\"), poplex);\n-    if (type == \"{\") return cont(pushlex(\"}\"), commasep(comb, \"}\"), poplex);\n-    return cont();\n-  }\n-\n-  function parse(state, stream, style) {\n-    var cc = state.cc;\n-    // Communicate our context to the combinators.\n-    // (Less wasteful than consing up a hundred closures on every call.)\n-    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n-\n-    while (true) {\n-      var combinator = cc.length ? cc.pop() : block;\n-      if (combinator(tcat)) {\n-        while(cc.length && cc[cc.length - 1].lex)\n-          cc.pop()();\n-        return cx.marked || style;\n-      }\n-    }\n-  }\n-\n-  return {\n-    startState: function() {\n-      return {\n-        tokenize: tokenBase,\n-        cc: [],\n-        lexical: {indented: -indentUnit, column: 0, type: \"top\", align: false},\n-        keywords: valKeywords,\n-        indented: 0\n-      };\n-    },\n-\n-    token: function(stream, state) {\n-      if (stream.sol()) {\n-        if (!state.lexical.hasOwnProperty(\"align\"))\n-          state.lexical.align = false;\n-        state.indented = stream.indentation();\n-      }\n-      if (stream.eatSpace()) return null;\n-      tcat = content = null;\n-      var style = state.tokenize(stream, state);\n-      if (style == \"comment\") return style;\n-      if (!state.lexical.hasOwnProperty(\"align\"))\n-        state.lexical.align = true;\n-      if (tcat == \"prefix\") return style;\n-      if (!content) content = stream.current();\n-      return parse(state, stream, style);\n-    },\n-\n-    indent: function(state, textAfter) {\n-      if (state.tokenize != tokenBase) return 0;\n-      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical,\n-          type = lexical.type, closing = firstChar == type;\n-      if (type == \"stat\") return lexical.indented + indentUnit;\n-      if (lexical.align) return lexical.column + (closing ? 0 : 1);\n-      return lexical.indented +\n-        (closing ? 0 : (lexical.info == \"match\" ? altIndentUnit : indentUnit));\n-    },\n-\n-    electricChars: \"{}\"\n-  };\n-});\n-\n-CodeMirror.defineMIME(\"text/x-rustsrc\", \"rust\");"}, {"sha": "850a0bc7db7ebe701e47ecea7c205ddd708ae6ae", "filename": "src/doc/prep.js", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fprep.js", "raw_url": "https://github.com/rust-lang/rust/raw/62f1d68439dcfd509eaca29887afa97f22938373/src%2Fdoc%2Fprep.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fprep.js?ref=62f1d68439dcfd509eaca29887afa97f22938373", "patch": "@@ -1,87 +0,0 @@\n-#!/usr/local/bin/node\n-\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/***\n- * Pandoc-style markdown preprocessor that drops extra directives\n- * included for running doc code, and that optionally, when\n- * --highlight is provided, replaces code blocks that are Rust code\n- * with highlighted HTML blocks. The directives recognized are:\n- *\n- * '## ignore' tells the test extractor (extract-tests.js) to ignore\n- *   the block completely.\n- * '## notrust' makes the test extractor ignore the block, makes\n- *   this script not highlight the block.\n- * '# [any text]' is a line that is stripped out by this script, and\n- *   converted to a normal line of code (without the leading #) by\n- *   the test extractor.\n- */\n-\n-var fs = require(\"fs\");\n-CodeMirror = require(\"./lib/codemirror-node\");\n-require(\"./lib/codemirror-rust\");\n-\n-function help() {\n-  console.log(\"usage: \" + process.argv[0] + \" [--highlight] [-o outfile] [infile]\");\n-  process.exit(1);\n-}\n-\n-var highlight = false, infile, outfile;\n-\n-for (var i = 2; i < process.argv.length; ++i) {\n-  var arg = process.argv[i];\n-  if (arg == \"--highlight\") highlight = true;\n-  else if (arg == \"-o\" && outfile == null && ++i < process.argv.length) outfile = process.argv[i];\n-  else if (arg[0] != \"-\") infile = arg;\n-  else help();\n-}\n-\n-var lines = fs.readFileSync(infile || \"/dev/stdin\").toString().split(/\\n\\r?/g), cur = 0, line;\n-var out = outfile ? fs.createWriteStream(outfile) : process.stdout;\n-\n-while ((line = lines[cur++]) != null) {\n-  if (/^~~~/.test(line)) {\n-    var block = \"\", bline;\n-    var notRust =\n-          /notrust/.test(line)\n-          // These are all used by the language ref to indicate things\n-          // that are not Rust source code\n-          || /ebnf/.test(line)\n-          || /abnf/.test(line)\n-          || /keyword/.test(line)\n-          || /field/.test(line)\n-          || /precedence/.test(line);\n-    var isRust = !notRust;\n-    while ((bline = lines[cur++]) != null) {\n-      if (/^~~~/.test(bline)) break;\n-      if (!/^\\s*##? /.test(bline)) block += bline + \"\\n\";\n-    }\n-    if (!highlight || !isRust)\n-      out.write(line + \"\\n\" + block + bline + \"\\n\");\n-    else {\n-      var html = '<pre class=\"cm-s-default\">', curstr = \"\", curstyle = null;\n-      function add(str, style) {\n-        if (style != curstyle) {\n-          if (curstyle) html +=\n-            '<span class=\"cm-' + CodeMirror.htmlEscape(curstyle) + '\">' +\n-            CodeMirror.htmlEscape(curstr) + \"</span>\";\n-          else if (curstr) html += CodeMirror.htmlEscape(curstr);\n-          curstr = str; curstyle = style;\n-        } else curstr += str;\n-      }\n-      CodeMirror.runMode(block, \"rust\", add);\n-      add(\"\", \"bogus\"); // Flush pending string.\n-      out.write(html + \"</pre>\\n\");\n-    }\n-  } else {\n-    out.write(line + \"\\n\");\n-  }\n-}"}, {"sha": "1e599125e89b7d60baa35c61cd70640cdf6f4b20", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/862acedf514fe806d2ab7d337fc0e156faf1d7b4/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/862acedf514fe806d2ab7d337fc0e156faf1d7b4/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=862acedf514fe806d2ab7d337fc0e156faf1d7b4", "patch": "@@ -33,8 +33,6 @@\n \"\"\"\n \n exceptions = [\n-    \"doc/lib/codemirror-node.js\", # MIT\n-    \"doc/lib/codemirror-rust.js\", # MIT\n     \"rt/rust_android_dummy.cpp\", # BSD, chromium\n     \"rt/rust_android_dummy.h\", # BSD, chromium\n     \"rt/isaac/randport.cpp\", # public domain"}]}