{"sha": "943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0M2NiOTRkY2U4ZmNhNmYzYTNmN2YwMTFhMmEyZjlmMGE2NjViOTc=", "commit": {"author": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-20T05:57:27Z"}, "committer": {"name": "JarredAllen", "email": "jarredallen73@gmail.com", "date": "2020-05-31T18:55:45Z"}, "message": "Passes all tests now!", "tree": {"sha": "6e1df1e3eb53ea2a7dc04992296534da17357859", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e1df1e3eb53ea2a7dc04992296534da17357859"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "html_url": "https://github.com/rust-lang/rust/commit/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/comments", "author": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JarredAllen", "id": 19656507, "node_id": "MDQ6VXNlcjE5NjU2NTA3", "avatar_url": "https://avatars.githubusercontent.com/u/19656507?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JarredAllen", "html_url": "https://github.com/JarredAllen", "followers_url": "https://api.github.com/users/JarredAllen/followers", "following_url": "https://api.github.com/users/JarredAllen/following{/other_user}", "gists_url": "https://api.github.com/users/JarredAllen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JarredAllen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JarredAllen/subscriptions", "organizations_url": "https://api.github.com/users/JarredAllen/orgs", "repos_url": "https://api.github.com/users/JarredAllen/repos", "events_url": "https://api.github.com/users/JarredAllen/events{/privacy}", "received_events_url": "https://api.github.com/users/JarredAllen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6", "html_url": "https://github.com/rust-lang/rust/commit/8590ab4d46de4eb43e7ebd42cb2f13b0064573e6"}], "stats": {"total": 106, "additions": 45, "deletions": 61}, "files": [{"sha": "31629a1dbc1b4754eb0bc5549c62f2cb1e866f2e", "filename": "clippy_lints/src/sort_by_key_reverse.rs", "status": "modified", "additions": 22, "deletions": 50, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsort_by_key_reverse.rs?ref=943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "patch": "@@ -53,8 +53,12 @@ fn mirrored_exprs(cx: &LateContext<'_, '_>, a_expr: &Expr<'_>, a_ident: &Ident,\n         // The two exprs are function calls.\n         // Check to see that the function itself and its arguments are mirrored\n         (ExprKind::Call(left_expr, left_args), ExprKind::Call(right_expr, right_args))\n-            => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n-                && left_args.iter().zip(right_args.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident)),\n+            => {\n+                // println!(\"{:?}\\n{:?}\\n\", left_expr, left_args);\n+                // println!(\"{:?}\\n{:?}\\n\", right_expr, right_args);\n+                mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident)\n+                && left_args.iter().zip(right_args.iter()).all(|(left, right)| mirrored_exprs(cx, left, a_ident, right, b_ident))\n+            },\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n@@ -74,65 +78,29 @@ fn mirrored_exprs(cx: &LateContext<'_, '_>, a_expr: &Expr<'_>, a_ident: &Ident,\n             => left_op == right_op && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n         // The two exprs are literals of some kind\n         (ExprKind::Lit(left_lit), ExprKind::Lit(right_lit)) => left_lit.node == right_lit.node,\n-        (ExprKind::Cast(left_expr, _), ExprKind::Cast(right_expr, _))\n+        (ExprKind::Cast(left_expr, left_ty), ExprKind::Cast(right_expr, right_ty))\n             => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n         (ExprKind::DropTemps(left), ExprKind::DropTemps(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n-        (ExprKind::Block(left, _), ExprKind::Block(right, _)) => mirrored_blocks(cx, left, a_ident, right, b_ident),\n         (ExprKind::Field(left_expr, left_ident), ExprKind::Field(right_expr, right_ident))\n             => left_ident.name == right_ident.name && mirrored_exprs(cx, left_expr, a_ident, right_expr, right_ident),\n-        // The two exprs are `a` and `b`, directly\n-        (ExprKind::Path(QPath::Resolved(_, Path { segments: &[PathSegment { ident: left_ident, .. }], ..  },)),\n-         ExprKind::Path(QPath::Resolved(_, Path { segments: &[PathSegment { ident: right_ident, .. }], ..  },)),\n-        ) => &left_ident == a_ident && &right_ident == b_ident,\n-        // The two exprs are Paths to the same name (which is neither a nor b)\n+        // Two paths: either one is a and the other is b, or they're identical to each other\n         (ExprKind::Path(QPath::Resolved(_, Path { segments: left_segments, .. })),\n          ExprKind::Path(QPath::Resolved(_, Path { segments: right_segments, .. })))\n-            => left_segments.iter().zip(right_segments.iter()).all(|(left, right)| left.ident == right.ident)\n-                && left_segments.iter().all(|seg| &seg.ident != a_ident && &seg.ident != b_ident),\n+            => (left_segments.iter().zip(right_segments.iter()).all(|(left, right)| left.ident == right.ident)\n+                 && left_segments.iter().all(|seg| &seg.ident != a_ident && &seg.ident != b_ident))\n+                || (left_segments.len() == 1 && &left_segments[0].ident == a_ident && right_segments.len() == 1 && &right_segments[0].ident == b_ident),\n         // Matching expressions, but one or both is borrowed\n         (ExprKind::AddrOf(left_kind, Mutability::Not, left_expr), ExprKind::AddrOf(right_kind, Mutability::Not, right_expr))\n             => left_kind == right_kind && mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n         (_, ExprKind::AddrOf(_, Mutability::Not, right_expr))\n             => mirrored_exprs(cx, a_expr, a_ident, right_expr, b_ident),\n         (ExprKind::AddrOf(_, Mutability::Not, left_expr), _)\n             => mirrored_exprs(cx, left_expr, a_ident, b_expr, b_ident),\n-        // _ => false,\n-        (left, right) => {\n-            println!(\"{:?}\\n{:?}\", left, right);\n-            false\n-        },\n-    }\n-}\n-\n-/// Detect if the two blocks are mirrored (identical, except one\n-/// contains a and the other replaces it with b)\n-fn mirrored_blocks(cx: &LateContext<'_, '_>, a_block: &Block<'_>, a_ident: &Ident, b_block: &Block<'_>, b_ident: &Ident) -> bool {\n-    match (a_block, b_block) {\n-        (Block { stmts: left_stmts, expr: left_expr, .. },\n-         Block { stmts: right_stmts, expr: right_expr, .. })\n-            => left_stmts.iter().zip(right_stmts.iter()).all(|(left, right)| match (&left.kind, &right.kind) {\n-                (StmtKind::Expr(left_expr), StmtKind::Expr(right_expr)) => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-                (StmtKind::Semi(left_expr), StmtKind::Semi(right_expr)) => mirrored_exprs(cx, left_expr, a_ident, right_expr, b_ident),\n-                (StmtKind::Item(left_item), StmtKind::Item(right_item)) => left_item.id == right_item.id,\n-                (StmtKind::Local(left), StmtKind::Local(right)) => mirrored_locals(cx, left, a_ident, right, b_ident),\n-                _ => false,\n-            }) && match (left_expr, right_expr) {\n-                (None, None) => true,\n-                (Some(left), Some(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n-                _ => false,\n-            },\n-    }\n-}\n-\n-/// Check that the two \"Local\"s (let statements) are equal\n-fn mirrored_locals(cx: &LateContext<'_, '_>, a_local: &Local<'_>, a_ident: &Ident, b_local: &Local<'_>, b_ident: &Ident) -> bool {\n-    match (a_local, b_local) {\n-        (Local { pat: left_pat, init: left_expr, .. }, Local { pat: right_pat, init: right_expr, .. })\n-            => match (left_expr, right_expr) {\n-                (None, None) => true,\n-                (Some(left), Some(right)) => mirrored_exprs(cx, left, a_ident, right, b_ident),\n-                _ => false,\n-            },\n+        _ => false,\n+        // (left, right) => {\n+            // println!(\"{:?}\\n{:?}\", left, right);\n+            // false\n+        // },\n     }\n }\n \n@@ -154,8 +122,12 @@ fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger>\n         then {\n             let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n             let unstable = name == \"sort_unstable_by\";\n-            let closure_arg = a_ident.name.to_ident_string();\n-            let closure_reverse_body = Sugg::hir(cx, &a_expr, \"..\").to_string();\n+            let closure_arg = format!(\"&{}\", b_ident.name.to_ident_string());\n+            let closure_reverse_body = Sugg::hir(cx, &b_expr, \"..\").to_string();\n+            // Get rid of parentheses, because they aren't needed anymore\n+            // while closure_reverse_body.chars().next() == Some('(') && closure_reverse_body.chars().last() == Some(')') {\n+                // closure_reverse_body = String::from(&closure_reverse_body[1..closure_reverse_body.len()-1]);\n+            // }\n             Some(LintTrigger { vec_name, unstable, closure_arg, closure_reverse_body })\n         } else {\n             None"}, {"sha": "d536dc385d5334474e8f3f443fecddc65088730e", "filename": "tests/ui/sort_by_key_reverse.fixed", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/tests%2Fui%2Fsort_by_key_reverse.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/tests%2Fui%2Fsort_by_key_reverse.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.fixed?ref=943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "patch": "@@ -1,9 +1,15 @@\n // run-rustfix\n #![warn(clippy::sort_by_key_reverse)]\n \n+use std::cmp::Reverse;\n+\n+fn id(x: isize) -> isize {\n+    x\n+}\n+\n fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n-    vec.sort_by_key(|a| Reverse(a));\n-    vec.sort_by_key(|a| Reverse(&(a+5).abs()));\n-    vec.sort_by_key(|a| Reverse(&-a));\n+    vec.sort_by_key(|&b| Reverse(b));\n+    vec.sort_by_key(|&b| Reverse((b + 5).abs()));\n+    vec.sort_by_key(|&b| Reverse(id(-b)));\n }"}, {"sha": "9c42d401755adcd6b46c9e16af04806cc9c17697", "filename": "tests/ui/sort_by_key_reverse.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/tests%2Fui%2Fsort_by_key_reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/tests%2Fui%2Fsort_by_key_reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.rs?ref=943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "patch": "@@ -1,9 +1,15 @@\n // run-rustfix\n #![warn(clippy::sort_by_key_reverse)]\n \n+use std::cmp::Reverse;\n+\n+fn id(x: isize) -> isize {\n+    x\n+}\n+\n fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     vec.sort_by(|a, b| b.cmp(a));\n     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a+5).abs()));\n-    vec.sort_by(|a, b| (-b).cmp(&-a));\n+    vec.sort_by(|a, b| id(-b).cmp(&id(-a)));\n }"}, {"sha": "3d26ddae78ad805f0fe5b3e6d27b043f3333d111", "filename": "tests/ui/sort_by_key_reverse.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/tests%2Fui%2Fsort_by_key_reverse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97/tests%2Fui%2Fsort_by_key_reverse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsort_by_key_reverse.stderr?ref=943cb94dce8fca6f3a3f7f011a2a2f9f0a665b97", "patch": "@@ -1,22 +1,22 @@\n error: use Vec::sort_by_key here instead\n-  --> $DIR/sort_by_key_reverse.rs:6:5\n+  --> $DIR/sort_by_key_reverse.rs:12:5\n    |\n LL |     vec.sort_by(|a, b| b.cmp(a));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| Reverse(a))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse(b))`\n    |\n    = note: `-D clippy::sort-by-key-reverse` implied by `-D warnings`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/sort_by_key_reverse.rs:7:5\n+  --> $DIR/sort_by_key_reverse.rs:13:5\n    |\n LL |     vec.sort_by(|a, b| (b + 5).abs().cmp(&(a+5).abs()));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| Reverse(&(a+5).abs()))`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse((b + 5).abs()))`\n \n error: use Vec::sort_by_key here instead\n-  --> $DIR/sort_by_key_reverse.rs:8:5\n+  --> $DIR/sort_by_key_reverse.rs:14:5\n    |\n-LL |     vec.sort_by(|a, b| (-b).cmp(&-a));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|a| Reverse(&-a))`\n+LL |     vec.sort_by(|a, b| id(-b).cmp(&id(-a)));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `vec.sort_by_key(|&b| Reverse(id(-b)))`\n \n error: aborting due to 3 previous errors\n "}]}