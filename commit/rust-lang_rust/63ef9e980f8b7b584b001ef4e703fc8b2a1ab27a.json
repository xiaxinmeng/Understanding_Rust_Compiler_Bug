{"sha": "63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZWY5ZTk4MGY4YjdiNTg0YjAwMWVmNGU3MDNmYzhiMmExYWIyN2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-09T17:24:47Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-12-09T17:24:47Z"}, "message": "rollup merge of #19589: huonw/unboxed-closure-elision\n\nThis means that `Fn(&A) -> (&B, &C)` is equivalent to `for<'a> Fn(&'a A)\n-> (&'a B, &'a C)` similar to the lifetime elision of lower-case `fn` in\ntypes and declarations.\n\nCloses #18992.", "tree": {"sha": "c62ea988d5cd6e19151fa5403697e38a71fcaa38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c62ea988d5cd6e19151fa5403697e38a71fcaa38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "html_url": "https://github.com/rust-lang/rust/commit/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "356193be0eb1bcccf15888054ade426c81aa42ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/356193be0eb1bcccf15888054ade426c81aa42ef", "html_url": "https://github.com/rust-lang/rust/commit/356193be0eb1bcccf15888054ade426c81aa42ef"}, {"sha": "b800ce160899b2c2350c45c25844640c46dd49cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b800ce160899b2c2350c45c25844640c46dd49cf", "html_url": "https://github.com/rust-lang/rust/commit/b800ce160899b2c2350c45c25844640c46dd49cf"}], "stats": {"total": 161, "additions": 117, "deletions": 44}, "files": [{"sha": "7f1aad8ca77c56f81fb7dae5d1e2113e1b7239e7", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 80, "deletions": 41, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "patch": "@@ -386,20 +386,81 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n     (regions, types)\n }\n \n+/// Returns the appropriate lifetime to use for any output lifetimes\n+/// (if one exists) and a vector of the (pattern, number of lifetimes)\n+/// corresponding to each input type/pattern.\n+fn find_implied_output_region(input_tys: &[Ty], input_pats: Vec<String>)\n+                              -> (Option<ty::Region>, Vec<(String, uint)>)\n+{\n+    let mut lifetimes_for_params: Vec<(String, uint)> = Vec::new();\n+    let mut possible_implied_output_region = None;\n+\n+    for (input_type, input_pat) in input_tys.iter().zip(input_pats.into_iter()) {\n+        let mut accumulator = Vec::new();\n+        ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n+\n+        if accumulator.len() == 1 {\n+            // there's a chance that the unique lifetime of this\n+            // iteration will be the appropriate lifetime for output\n+            // parameters, so lets store it.\n+            possible_implied_output_region = Some(accumulator[0])\n+        }\n+\n+        lifetimes_for_params.push((input_pat, accumulator.len()));\n+    }\n+\n+    let implied_output_region = if lifetimes_for_params.iter().map(|&(_, n)| n).sum() == 1 {\n+        assert!(possible_implied_output_region.is_some());\n+        possible_implied_output_region\n+    } else {\n+        None\n+    };\n+    (implied_output_region, lifetimes_for_params)\n+}\n+\n+fn convert_ty_with_lifetime_elision<'tcx,AC>(this: &AC,\n+                                             implied_output_region: Option<ty::Region>,\n+                                             param_lifetimes: Vec<(String, uint)>,\n+                                             ty: &ast::Ty)\n+                                             -> Ty<'tcx>\n+    where AC: AstConv<'tcx>\n+{\n+    match implied_output_region {\n+        Some(implied_output_region) => {\n+            let rb = SpecificRscope::new(implied_output_region);\n+            ast_ty_to_ty(this, &rb, ty)\n+        }\n+        None => {\n+            // All regions must be explicitly specified in the output\n+            // if the lifetime elision rules do not apply. This saves\n+            // the user from potentially-confusing errors.\n+            let rb = UnelidableRscope::new(param_lifetimes);\n+            ast_ty_to_ty(this, &rb, ty)\n+        }\n+    }\n+}\n+\n fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                                              data: &ast::ParenthesizedParameterData)\n                                              -> Vec<Ty<'tcx>>\n     where AC: AstConv<'tcx>\n {\n     let binding_rscope = BindingRscope::new();\n-\n     let inputs = data.inputs.iter()\n                             .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n-                            .collect();\n+                            .collect::<Vec<Ty<'tcx>>>();\n+\n+    let input_params = Vec::from_elem(inputs.len(), String::new());\n+    let (implied_output_region,\n+         params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n+\n     let input_ty = ty::mk_tup(this.tcx(), inputs);\n \n     let output = match data.output {\n-        Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n+        Some(ref output_ty) => convert_ty_with_lifetime_elision(this,\n+                                                                implied_output_region,\n+                                                                params_lifetimes,\n+                                                                &**output_ty),\n         None => ty::mk_nil(this.tcx()),\n     };\n \n@@ -1059,55 +1120,33 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let self_and_input_tys: Vec<Ty> =\n         self_ty.into_iter().chain(input_tys).collect();\n \n-    let mut lifetimes_for_params: Vec<(String, Vec<ty::Region>)> = Vec::new();\n \n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n-    if implied_output_region.is_none() {\n-        let mut self_and_input_tys_iter = self_and_input_tys.iter();\n-        if self_ty.is_some() {\n+    let lifetimes_for_params = if implied_output_region.is_none() {\n+        let input_tys = if self_ty.is_some() {\n             // Skip the first argument if `self` is present.\n-            drop(self_and_input_tys_iter.next())\n-        }\n-\n-        for (input_type, input_pat) in self_and_input_tys_iter.zip(input_pats.into_iter()) {\n-            let mut accumulator = Vec::new();\n-            ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n-            lifetimes_for_params.push((input_pat, accumulator));\n-        }\n-\n-        if lifetimes_for_params.iter().map(|&(_, ref x)| x.len()).sum() == 1 {\n-            implied_output_region =\n-                Some(lifetimes_for_params.iter()\n-                                         .filter_map(|&(_, ref x)|\n-                                            if x.len() == 1 { Some(x[0]) } else { None })\n-                                         .next().unwrap());\n-        }\n-    }\n+            self_and_input_tys.slice_from(1)\n+        } else {\n+            self_and_input_tys.slice_from(0)\n+        };\n \n-    let param_lifetimes: Vec<(String, uint)> = lifetimes_for_params.into_iter()\n-                                                                   .map(|(n, v)| (n, v.len()))\n-                                                                   .filter(|&(_, l)| l != 0)\n-                                                                   .collect();\n+        let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n+        implied_output_region = ior;\n+        lfp\n+    } else {\n+        vec![]\n+    };\n \n     let output_ty = match decl.output {\n         ast::Return(ref output) if output.node == ast::TyInfer =>\n             ty::FnConverging(this.ty_infer(output.span)),\n         ast::Return(ref output) =>\n-            ty::FnConverging(match implied_output_region {\n-                Some(implied_output_region) => {\n-                    let rb = SpecificRscope::new(implied_output_region);\n-                    ast_ty_to_ty(this, &rb, &**output)\n-                }\n-                None => {\n-                    // All regions must be explicitly specified in the output\n-                    // if the lifetime elision rules do not apply. This saves\n-                    // the user from potentially-confusing errors.\n-                    let rb = UnelidableRscope::new(param_lifetimes);\n-                    ast_ty_to_ty(this, &rb, &**output)\n-                }\n-            }),\n+            ty::FnConverging(convert_ty_with_lifetime_elision(this,\n+                                                              implied_output_region,\n+                                                              lifetimes_for_params,\n+                                                              &**output)),\n         ast::NoReturn(_) => ty::FnDiverging\n     };\n "}, {"sha": "308b33f9b4db195d381cff13eb8192cdd8793c83", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "patch": "@@ -44,9 +44,9 @@ fn test<'a,'b>() {\n     eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n           Foo(&int,&uint) -> uint                             >();\n \n-    // FIXME(#18992) Test lifetime elision in `()` form:\n-    // eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n-    //      Foo(&int) -> &int                                   >();\n+    // lifetime elision\n+    eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n+          Foo(&int) -> &int                                   >();\n \n     // Errors expected:\n     eq::< Foo<(),()>,                   Foo(char)                     >();"}, {"sha": "e08d84944c02a58beaa20727a81154ccb9897fe6", "filename": "src/test/compile-fail/unboxed-closure-sugar-lifetime-elision.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-lifetime-elision.rs?ref=63ef9e980f8b7b584b001ef4e703fc8b2a1ab27a", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the unboxed closure sugar can be used with an arbitrary\n+// struct type and that it is equivalent to the same syntax using\n+// angle brackets. This test covers only simple types and in\n+// particular doesn't test bound regions.\n+\n+#![feature(unboxed_closures)]\n+#![allow(dead_code)]\n+\n+trait Foo<T,U> {\n+    fn dummy(&self, t: T, u: U);\n+}\n+\n+trait Eq<Sized? X> for Sized? { }\n+impl<Sized? X> Eq<X> for X { }\n+fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+\n+fn main() {\n+    eq::< for<'a> Foo<(&'a int,), &'a int>,\n+          Foo(&int) -> &int                                   >();\n+    eq::< for<'a> Foo<(&'a int,), (&'a int, &'a int)>,\n+          Foo(&int) -> (&int, &int)                           >();\n+\n+    let _: Foo(&int, &uint) -> &uint; //~ ERROR missing lifetime specifier\n+}"}]}