{"sha": "dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNTYzZWZkOThlODNmYWI5M2UwZDlmZTE5OGY0NWEyZTk1YjFlN2U=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-01T19:04:09Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-01T23:17:28Z"}, "message": "rustc_mir: actually \"promote\" constants' MIR to 'static by removing StorageDead's.", "tree": {"sha": "e8496c97b8ba43838e5b4aeae5944babe97e7a01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8496c97b8ba43838e5b4aeae5944babe97e7a01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "html_url": "https://github.com/rust-lang/rust/commit/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f861b6ee46465097eec266c160ac53e230df7cf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f861b6ee46465097eec266c160ac53e230df7cf0", "html_url": "https://github.com/rust-lang/rust/commit/f861b6ee46465097eec266c160ac53e230df7cf0"}], "stats": {"total": 119, "additions": 89, "deletions": 30}, "files": [{"sha": "6c6fb976abe8df59df7007b5b1cd310eac45ece7", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "patch": "@@ -31,6 +31,7 @@ use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use std::cell::{RefCell, RefMut, Cell};\n@@ -1019,7 +1020,7 @@ define_maps! { <'tcx>\n     /// Maps DefId's that have an associated Mir to the result\n     /// of the MIR qualify_consts pass. The actual meaning of\n     /// the value isn't known except to the pass itself.\n-    [] fn mir_const_qualif: MirConstQualif(DefId) -> u8,\n+    [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Rc<IdxSetBuf<mir::Local>>),\n \n     /// Fetch the MIR for a given def-id up till the point where it is\n     /// ready for const evaluation."}, {"sha": "537e12086141c05466c5f6bb95b4ef474cbb9a0b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "patch": "@@ -38,6 +38,7 @@ use syntax::ext::base::SyntaxExtension;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION};\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc::hir::svh::Svh;\n use rustc::hir;\n \n@@ -106,7 +107,9 @@ provide! { <'tcx> tcx, def_id, cdata,\n         mir\n     }\n     generator_sig => { cdata.generator_sig(def_id.index, tcx) }\n-    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n+    mir_const_qualif => {\n+        (cdata.mir_const_qualif(def_id.index), Rc::new(IdxSetBuf::new_empty(0)))\n+    }\n     typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n     closure_kind => { cdata.closure_kind(def_id.index) }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }"}, {"sha": "d36aebe38eb0bcc0881666caf8feef3258b77f6b", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "patch": "@@ -793,7 +793,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let kind = match impl_item.kind {\n             ty::AssociatedKind::Const => {\n                 EntryKind::AssociatedConst(container,\n-                    self.tcx.at(ast_item.span).mir_const_qualif(def_id))\n+                    self.tcx.at(ast_item.span).mir_const_qualif(def_id).0)\n             }\n             ty::AssociatedKind::Method => {\n                 let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.node {\n@@ -912,7 +912,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n             hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n             hir::ItemConst(..) => {\n-                EntryKind::Const(tcx.at(item.span).mir_const_qualif(def_id))\n+                EntryKind::Const(tcx.at(item.span).mir_const_qualif(def_id).0)\n             }\n             hir::ItemFn(_, _, constness, .., body) => {\n                 let data = FnData {\n@@ -1256,7 +1256,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let body = tcx.hir.body_owned_by(id);\n \n         Entry {\n-            kind: EntryKind::Const(tcx.mir_const_qualif(def_id)),\n+            kind: EntryKind::Const(tcx.mir_const_qualif(def_id).0),\n             visibility: self.lazy(&ty::Visibility::Public),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),"}, {"sha": "9e64b0f9c77bebeb032807605baf86c2e60dbf1d", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 80, "deletions": 25, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc563efd98e83fab93e0d9fe198f45a2e95b1e7e/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=dc563efd98e83fab93e0d9fe198f45a2e95b1e7e", "patch": "@@ -15,6 +15,7 @@\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::hir;\n use rustc::hir::map as hir_map;\n@@ -33,6 +34,7 @@ use syntax::feature_gate::UnstableFeatures;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::fmt;\n+use std::rc::Rc;\n use std::usize;\n \n use super::promote_consts::{self, Candidate, TempState};\n@@ -127,7 +129,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-           param_env: ty::ParamEnv<'tcx>,\n            def_id: DefId,\n            mir: &'a Mir<'tcx>,\n            mode: Mode)\n@@ -142,7 +143,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             mir,\n             rpo,\n             tcx,\n-            param_env,\n+            param_env: tcx.param_env(def_id),\n             temp_qualif: IndexVec::from_elem(None, &mir.local_decls),\n             return_qualif: None,\n             qualif: Qualif::empty(),\n@@ -368,7 +369,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Qualify a whole const, static initializer or const fn.\n-    fn qualify_const(&mut self) -> Qualif {\n+    fn qualify_const(&mut self) -> (Qualif, Rc<IdxSetBuf<Local>>) {\n         debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n@@ -390,7 +391,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n                 // Non-terminating calls cannot produce any value.\n                 TerminatorKind::Call { destination: None, .. } => {\n-                    return Qualif::empty();\n+                    break;\n                 }\n \n                 TerminatorKind::SwitchInt {..} |\n@@ -472,7 +473,25 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n         }\n-        self.qualif\n+\n+        // Collect all the temps we need to promote.\n+        let mut promoted_temps = IdxSetBuf::new_empty(self.temp_promotion_state.len());\n+\n+        for candidate in &self.promotion_candidates {\n+            match *candidate {\n+                Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n+                    match self.mir[bb].statements[stmt_idx].kind {\n+                        StatementKind::Assign(_, Rvalue::Ref(_, _, Lvalue::Local(index))) => {\n+                            promoted_temps.add(&index);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                Candidate::ShuffleIndices(_) => {}\n+            }\n+        }\n+\n+        (self.qualif, Rc::new(promoted_temps))\n     }\n }\n \n@@ -516,6 +535,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                             span_err!(self.tcx.sess, self.span, E0625,\n                                       \"thread-local statics cannot be \\\n                                        accessed at compile-time\");\n+                            self.add(Qualif::NOT_CONST);\n                             return;\n                         }\n                     }\n@@ -598,7 +618,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     if self.tcx.trait_of_item(def_id).is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n-                        let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n                         self.add(qualif);\n@@ -702,13 +722,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n                 // We might have a candidate for promotion.\n                 let candidate = Candidate::Ref(location);\n-                if self.mode == Mode::Fn || self.mode == Mode::ConstFn {\n-                    if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n-                        // We can only promote direct borrows of temps.\n-                        if let Lvalue::Local(local) = *lvalue {\n-                            if self.mir.local_kind(local) == LocalKind::Temp {\n-                                self.promotion_candidates.push(candidate);\n-                            }\n+                if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n+                    // We can only promote direct borrows of temps.\n+                    if let Lvalue::Local(local) = *lvalue {\n+                        if self.mir.local_kind(local) == LocalKind::Temp {\n+                            self.promotion_candidates.push(candidate);\n                         }\n                     }\n                 }\n@@ -999,21 +1017,21 @@ pub fn provide(providers: &mut Providers) {\n \n fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n-                              -> u8 {\n+                              -> (u8, Rc<IdxSetBuf<Local>>) {\n     // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n     // performing the steal.\n     let mir = &tcx.mir_const(def_id).borrow();\n \n     if mir.return_ty.references_error() {\n-        return Qualif::NOT_CONST.bits();\n+        tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n+        return (Qualif::NOT_CONST.bits(), Rc::new(IdxSetBuf::new_empty(0)));\n     }\n \n-    let param_env = tcx.param_env(def_id);\n-\n-    let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, Mode::Const);\n-    qualifier.qualify_const().bits()\n+    let mut qualifier = Qualifier::new(tcx, def_id, mir, Mode::Const);\n+    let (qualif, promoted_temps) = qualifier.qualify_const();\n+    (qualif.bits(), promoted_temps)\n }\n \n pub struct QualifyAndPromoteConstants;\n@@ -1023,8 +1041,15 @@ impl MirPass for QualifyAndPromoteConstants {\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           src: MirSource,\n                           mir: &mut Mir<'tcx>) {\n+        // There's not really any point in promoting errorful MIR.\n+        if mir.return_ty.references_error() {\n+            tcx.sess.delay_span_bug(mir.span, \"QualifyAndPromoteConstants: Mir had errors\");\n+            return;\n+        }\n+\n         let id = src.item_id();\n         let def_id = tcx.hir.local_def_id(id);\n+        let mut const_promoted_temps = None;\n         let mode = match src {\n             MirSource::Fn(_) => {\n                 if tcx.is_const_fn(def_id) {\n@@ -1033,20 +1058,21 @@ impl MirPass for QualifyAndPromoteConstants {\n                     Mode::Fn\n                 }\n             }\n+            MirSource::Const(_) => {\n+                const_promoted_temps = Some(tcx.mir_const_qualif(def_id).1);\n+                Mode::Const\n+            }\n             MirSource::Static(_, hir::MutImmutable) => Mode::Static,\n             MirSource::Static(_, hir::MutMutable) => Mode::StaticMut,\n             MirSource::GeneratorDrop(_) |\n-            MirSource::Const(_) |\n             MirSource::Promoted(..) => return\n         };\n-        let param_env = tcx.param_env(def_id);\n \n         if mode == Mode::Fn || mode == Mode::ConstFn {\n             // This is ugly because Qualifier holds onto mir,\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {\n-                let mut qualifier = Qualifier::new(tcx, param_env,\n-                                                   def_id, mir, mode);\n+                let mut qualifier = Qualifier::new(tcx, def_id, mir, mode);\n                 if mode == Mode::ConstFn {\n                     // Enforce a constant-like CFG for `const fn`.\n                     qualifier.qualify_const();\n@@ -1062,8 +1088,37 @@ impl MirPass for QualifyAndPromoteConstants {\n             // Do the actual promotion, now that we know what's viable.\n             promote_consts::promote_candidates(mir, tcx, temps, candidates);\n         } else {\n-            let mut qualifier = Qualifier::new(tcx, param_env, def_id, mir, mode);\n-            qualifier.qualify_const();\n+            let promoted_temps = if mode == Mode::Const {\n+                // Already computed by `mir_const_qualif`.\n+                const_promoted_temps.unwrap()\n+            } else {\n+                Qualifier::new(tcx, def_id, mir, mode).qualify_const().1\n+            };\n+\n+            // In `const` and `static` everything without `StorageDead`\n+            // is `'static`, we don't have to create promoted MIR fragments,\n+            // just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+            for block in mir.basic_blocks_mut() {\n+                block.statements.retain(|statement| {\n+                    match statement.kind {\n+                        StatementKind::StorageDead(Lvalue::Local(index)) => {\n+                            !promoted_temps.contains(&index)\n+                        }\n+                        _ => true\n+                    }\n+                });\n+                let terminator = block.terminator_mut();\n+                match terminator.kind {\n+                    TerminatorKind::Drop { location: Lvalue::Local(index), target, .. } => {\n+                        if promoted_temps.contains(&index) {\n+                            terminator.kind = TerminatorKind::Goto {\n+                                target,\n+                            };\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n         }\n \n         // Statics must be Sync."}]}