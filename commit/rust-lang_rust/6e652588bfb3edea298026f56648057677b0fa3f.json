{"sha": "6e652588bfb3edea298026f56648057677b0fa3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNjUyNTg4YmZiM2VkZWEyOTgwMjZmNTY2NDgwNTc2NzdiMGZhM2Y=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-04T14:37:56Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-04T15:52:23Z"}, "message": "Get rid of 'overwrite' destination kind\n\nIt wasn't safe (computing the rval might invalidate the lval addr), and needlessly\ncomplicating things (code was already building up intermediary results to work\naround other unsafeties).\n\nIssue #667", "tree": {"sha": "01d11a346a9ee9e3a6e1350ce9b86e0a49395521", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01d11a346a9ee9e3a6e1350ce9b86e0a49395521"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e652588bfb3edea298026f56648057677b0fa3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e652588bfb3edea298026f56648057677b0fa3f", "html_url": "https://github.com/rust-lang/rust/commit/6e652588bfb3edea298026f56648057677b0fa3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e652588bfb3edea298026f56648057677b0fa3f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e56ec0066b3cc8d18365370f0b856670dc748bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e56ec0066b3cc8d18365370f0b856670dc748bd", "html_url": "https://github.com/rust-lang/rust/commit/6e56ec0066b3cc8d18365370f0b856670dc748bd"}], "stats": {"total": 164, "additions": 62, "deletions": 102}, "files": [{"sha": "6decfda3f8afcacce4dbc812ea53c2857bbc10a1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 56, "deletions": 82, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6e652588bfb3edea298026f56648057677b0fa3f", "patch": "@@ -2112,6 +2112,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                              ty_to_str(tcx, t));\n }\n \n+// FIXME[DPS] rename to store_temp_expr\n fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n                     src: lval_result, t: ty::t) -> @block_ctxt {\n     // Lvals in memory are not temporaries. Copy them.\n@@ -2213,7 +2214,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n             let llety = T_ptr(type_of(ccx, e_sp, e_ty));\n             body = PointerCast(bcx, body, llety);\n         }\n-        bcx = trans_expr_save_in(bcx, e, body, INIT);\n+        bcx = trans_expr_save_in(bcx, e, body);\n         revoke_clean(bcx, box);\n         ret store_in_dest(bcx, box, dest);\n       }\n@@ -2255,8 +2256,7 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|_fcx|});\n       }\n     };\n-    let {bcx, val: addr} = get_dest_addr(bcx, dest);\n-    fill_fn_pair(bcx, addr, llfn, env);\n+    fill_fn_pair(bcx, get_dest_addr(dest), llfn, env);\n     ret bcx;\n }\n \n@@ -2357,19 +2357,18 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n       }\n       _ { }\n     }\n-    let rhs_res = trans_expr(lhs_res.bcx, src);\n+    let {bcx, val: rhs_val} = trans_expr(lhs_res.bcx, src);\n     if ty::type_is_sequence(tcx, t) {\n         alt op {\n           ast::add. {\n-            ret tvec::trans_append(rhs_res.bcx, t, lhs_res.val,\n-                                   rhs_res.val);\n+            ret tvec::trans_append(bcx, t, lhs_res.val, rhs_val);\n           }\n           _ { }\n         }\n     }\n-    let lhs_val = load_if_immediate(rhs_res.bcx, lhs_res.val, t);\n-    ret trans_eager_binop(rhs_res.bcx, op, lhs_val, t, rhs_res.val, t,\n-                          overwrite(lhs_res.val, t));\n+    \n+    ret trans_eager_binop(bcx, op, Load(bcx, lhs_res.val), t, rhs_val, t,\n+                          save_in(lhs_res.val));\n }\n \n fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n@@ -2485,7 +2484,6 @@ tag dest {\n     by_val(@mutable ValueRef);\n     by_ref(@mutable ValueRef);\n     save_in(ValueRef);\n-    overwrite(ValueRef, ty::t);\n     ignore;\n }\n \n@@ -2538,19 +2536,12 @@ fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n       ignore. {}\n       by_val(cell) { *cell = val; }\n       save_in(addr) { Store(bcx, val, addr); }\n-      overwrite(addr, tp) {\n-        bcx = drop_ty(bcx, addr, tp);\n-        Store(bcx, val, addr);\n-      }\n     }\n     ret bcx;\n }\n \n-fn get_dest_addr(bcx: @block_ctxt, dest: dest) -> result {\n-    alt dest {\n-      save_in(a) { rslt(bcx, a) }\n-      overwrite(a, t) { rslt(drop_ty(bcx, a, t), a) }\n-    }\n+fn get_dest_addr(dest: dest) -> ValueRef {\n+    alt dest { save_in(a) { a } }\n }\n \n // Wrapper through which legacy non-DPS code can use DPS functions\n@@ -2733,7 +2724,7 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n         bcx = bound.bcx;\n         alt bv {\n           env_expr(e) {\n-            bcx = trans_expr_save_in(bcx, e, bound.val, INIT);\n+            bcx = trans_expr_save_in(bcx, e, bound.val);\n             add_clean_temp_mem(bcx, bound.val, bound_tys[i]);\n             temp_cleanups += [bound.val];\n           }\n@@ -3698,8 +3689,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         let lv = lval_maybe_callee_to_lval(f_res, pair_ty);\n         bcx = lv.bcx;\n         // FIXME[DPS] factor this out\n-        let {bcx, val: addr} = get_dest_addr(bcx, dest);\n-        ret memmove_ty(bcx, addr, lv.val, pair_ty);\n+        ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n     }\n     let closure = alt f_res.env {\n       null_env. { none }\n@@ -3736,8 +3726,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                          closure.ptrty, ty_param_count, target_res);\n \n     // Fill the function pair\n-    let {bcx, val: addr} = get_dest_addr(bcx, dest);\n-    fill_fn_pair(bcx, addr, llthunk.val, closure.ptr);\n+    fill_fn_pair(bcx, get_dest_addr(dest), llthunk.val, closure.ptr);\n     ret bcx;\n }\n \n@@ -3845,7 +3834,7 @@ fn trans_args(cx: @block_ctxt, outer_cx: @block_ctxt, llenv: ValueRef,\n         } else { alloca(cx, llretty) }\n       }\n       save_in(dst) { dst }\n-      overwrite(_, _) | by_val(_) { alloca(cx, llretty) }\n+      by_val(_) { alloca(cx, llretty) }\n       by_ref(_) { dest_ref = true; alloca(cx, T_ptr(llretty)) }\n     };\n     // FIXME[DSP] does this always hold?\n@@ -3970,10 +3959,6 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n         }\n       }\n       save_in(_) { } // Already saved by callee\n-      overwrite(a, t) {\n-        bcx = drop_ty(bcx, a, t);\n-        bcx = memmove_ty(bcx, a, llretslot, ret_ty);\n-      }\n       by_ref(cell) | by_val(cell) {\n         *cell = Load(bcx, llretslot);\n       }\n@@ -4167,55 +4152,38 @@ fn trans_landing_pad(bcx: @block_ctxt,\n fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n-    let (addr, overwrite) = alt dest {\n+    let addr = alt dest {\n       ignore. {\n         for ex in elts { bcx = trans_expr_dps(bcx, ex, ignore); }\n         ret bcx;\n       }\n-      save_in(pos) { (pos, none) }\n-      overwrite(pos, _) {\n-        let scratch = alloca(bcx, llvm::LLVMGetElementType(val_ty(pos)));\n-        (scratch, some(pos))\n-      }\n+      save_in(pos) { pos }\n     };\n     let temp_cleanups = [], i = 0;\n     for e in elts {\n         let dst = GEP_tup_like_1(bcx, t, addr, [0, i]);\n         let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n-        bcx = trans_expr_save_in(dst.bcx, e, dst.val, INIT);\n+        bcx = trans_expr_save_in(dst.bcx, e, dst.val);\n         add_clean_temp_mem(bcx, dst.val, e_ty);\n         temp_cleanups += [dst.val];\n         i += 1;\n     }\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n-    alt overwrite {\n-      some(pos) {\n-        bcx = drop_ty(bcx, pos, t);\n-        bcx = memmove_ty(bcx, pos, addr, t);\n-      }\n-      none. {}\n-    }\n     ret bcx;\n }\n \n fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n              base: option::t<@ast::expr>, id: ast::node_id,\n              dest: dest) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(bcx), id);\n-    let (addr, overwrite) = alt dest {\n+    let addr = alt dest {\n       ignore. {\n         for fld in fields {\n             bcx = trans_expr_dps(bcx, fld.node.expr, ignore);\n         }\n         ret bcx;\n       }\n-      save_in(pos) { (pos, none) }\n-      // The expressions that populate the fields might still use the old\n-      // record, so we build the new on in a scratch area\n-      overwrite(pos, _) {\n-        let scratch = alloca(bcx, llvm::LLVMGetElementType(val_ty(pos)));\n-        (scratch, some(pos))\n-      }\n+      save_in(pos) { pos }\n     };\n \n     let base_val = alt base {\n@@ -4234,7 +4202,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n         bcx = dst.bcx;\n         alt vec::find({|f| str::eq(f.node.ident, tf.ident)}, fields) {\n           some(f) {\n-            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val, INIT);\n+            bcx = trans_expr_save_in(bcx, f.node.expr, dst.val);\n           }\n           none. {\n             let base = GEP_tup_like_1(bcx, t, base_val, [0, i]);\n@@ -4249,13 +4217,6 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     // Now revoke the cleanups as we pass responsibility for the data\n     // structure on to the caller\n     for cleanup in temp_cleanups { revoke_clean(bcx, cleanup); }\n-    alt overwrite {\n-      some(pos) {\n-        bcx = drop_ty(bcx, pos, t);\n-        bcx = memmove_ty(bcx, pos, addr, t);\n-      }\n-      none. {}\n-    }\n     ret bcx;\n }\n \n@@ -4274,19 +4235,37 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n     }\n }\n \n-fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef,\n-                      kind: copy_action) -> @block_ctxt {\n+fn trans_expr_save_in(bcx: @block_ctxt, e: @ast::expr, dest: ValueRef)\n+    -> @block_ctxt {\n     let tcx = bcx_tcx(bcx), t = ty::expr_ty(tcx, e);\n     let dst = if ty::type_is_bot(tcx, t) || ty::type_is_nil(tcx, t) {\n         ignore\n-    } else if kind == INIT {\n-        save_in(dest)\n-    } else {\n-        overwrite(dest, t)\n-    };\n+    } else { save_in(dest) };\n     ret trans_expr_dps(bcx, e, dst);\n }\n \n+fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> lval_result {\n+    if expr_is_lval(bcx_tcx(bcx), e) {\n+        ret trans_lval(bcx, e);\n+    } else {\n+        let tcx = bcx_tcx(bcx);\n+        let ty = ty::expr_ty(tcx, e);\n+        if ty::type_is_nil(tcx, ty) || ty::type_is_bot(tcx, ty) {\n+            bcx = trans_expr_dps(bcx, e, ignore);\n+            ret {bcx: bcx, val: C_nil(), is_mem: false};\n+        } else if type_is_immediate(bcx_ccx(bcx), ty) {\n+            let cell = empty_dest_cell();\n+            bcx = trans_expr_dps(bcx, e, by_val(cell));\n+            ret {bcx: bcx, val: *cell, is_mem: false};\n+        } else {\n+            let {bcx, val: scratch} = alloc_ty(bcx, ty);\n+            bcx = trans_expr_dps(bcx, e, save_in(scratch));\n+            ret {bcx: bcx, val: scratch, is_mem: false};\n+        }\n+    }\n+}\n+\n+// FIXME[DPS] supersede by trans_temp_expr, get rid of by_ref dests\n fn trans_expr_by_ref(bcx: @block_ctxt, e: @ast::expr) -> result {\n     let cell = empty_dest_cell();\n     bcx = trans_expr_dps(bcx, e, by_ref(cell));\n@@ -4430,22 +4409,20 @@ fn trans_expr_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest)\n       }\n       ast::expr_assign(dst, src) {\n         assert dest == ignore;\n-        let {bcx, val: lhs_addr, is_mem} = trans_lval(bcx, dst);\n+        let src_r = trans_temp_expr(bcx, src);\n+        let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n         assert is_mem;\n-        ret trans_expr_save_in(bcx, src, lhs_addr, DROP_EXISTING);\n+        ret move_val_if_temp(bcx, DROP_EXISTING, addr, src_r,\n+                             ty::expr_ty(bcx_tcx(bcx), src));\n       }\n       ast::expr_move(dst, src) {\n+        // FIXME: calculate copy init-ness in typestate.\n         assert dest == ignore;\n-        let {bcx, val: addr, is_mem} = trans_lval(bcx, dst);\n+        let src_r = trans_temp_expr(bcx, src);\n+        let {bcx, val: addr, is_mem} = trans_lval(src_r.bcx, dst);\n         assert is_mem;\n-        // FIXME: calculate copy init-ness in typestate.\n-        if expr_is_lval(tcx, src) {\n-            ret trans_expr_save_in(bcx, src, addr, DROP_EXISTING);\n-        } else {\n-            let srclv = trans_lval(bcx, src);\n-            let t = ty::expr_ty(tcx, src);\n-            ret move_val(srclv.bcx, DROP_EXISTING, addr, srclv, t);\n-        }\n+        ret move_val(bcx, DROP_EXISTING, addr, src_r,\n+                     ty::expr_ty(bcx_tcx(bcx), src));\n       }\n       ast::expr_swap(dst, src) {\n         assert dest == ignore;\n@@ -4492,9 +4469,6 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         *cell = val;\n       }\n       save_in(loc) { bcx = move_val_if_temp(bcx, INIT, loc, lv, ty); }\n-      overwrite(loc, _) {\n-        bcx = move_val_if_temp(bcx, DROP_EXISTING, loc, lv, ty);\n-      }\n       ignore. {}\n     }\n     ret bcx;\n@@ -4746,7 +4720,7 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n             Store(cx, val, bcx.fcx.llretptr);\n             bcx = cx;\n         } else {\n-            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr, INIT);\n+            bcx = trans_expr_save_in(bcx, x, bcx.fcx.llretptr);\n         }\n       }\n       _ {}\n@@ -4784,7 +4758,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n       some(init) {\n         if init.op == ast::init_assign ||\n            !expr_is_lval(bcx_tcx(bcx), init.expr) {\n-            bcx = trans_expr_save_in(bcx, init.expr, llptr, INIT);\n+            bcx = trans_expr_save_in(bcx, init.expr, llptr);\n         } else { // This is a move from an lval, must perform an actual move\n             let sub = trans_lval(bcx, init.expr);\n             bcx = move_val(sub.bcx, INIT, llptr, sub, ty);"}, {"sha": "710c43d6bd5e6872b4f7867a71d62a368eab83a9", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=6e652588bfb3edea298026f56648057677b0fa3f", "patch": "@@ -378,7 +378,7 @@ fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n         revoke_clean(bcx, box);\n         box = PointerCast(bcx, box, llbox_ty);\n     }\n-    let {bcx, val: pair} = trans::get_dest_addr(bcx, dest);\n+    let pair = trans::get_dest_addr(dest);\n     let pair_vtbl = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     Store(bcx, vtbl, pair_vtbl);\n     let pair_box = GEP(bcx, pair, [C_int(0), C_int(abi::obj_field_box)]);"}, {"sha": "619ae9b78efd35360ec796f3855b63487945bc18", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=6e652588bfb3edea298026f56648057677b0fa3f", "patch": "@@ -29,7 +29,7 @@ fn trans_uniq(bcx: @block_ctxt, contents: @ast::expr,\n     check type_is_unique_box(bcx, uniq_ty);\n     let {bcx, val: llptr} = alloc_uniq(bcx, uniq_ty);\n     add_clean_free(bcx, llptr, true);\n-    bcx = trans::trans_expr_save_in(bcx, contents, llptr, INIT);\n+    bcx = trans::trans_expr_save_in(bcx, contents, llptr);\n     revoke_clean(bcx, llptr);\n     ret trans::store_in_dest(bcx, llptr, dest);\n }"}, {"sha": "8242a23489cdfe9d06aea3f98ff8ee7008db2d90", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e652588bfb3edea298026f56648057677b0fa3f/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=6e652588bfb3edea298026f56648057677b0fa3f", "patch": "@@ -124,17 +124,13 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n         } else { InBoundsGEP(bcx, dataptr, [C_uint(i)]) };\n-        bcx = trans::trans_expr_save_in(bcx, e, lleltptr, INIT);\n+        bcx = trans::trans_expr_save_in(bcx, e, lleltptr);\n         add_clean_temp_mem(bcx, lleltptr, unit_ty);\n         temp_cleanups += [lleltptr];\n         i += 1u;\n     }\n     for clean in temp_cleanups { revoke_clean(bcx, clean); }\n-    let vptrptr = alt dest {\n-      trans::save_in(a) { a }\n-      trans::overwrite(a, t) { bcx = trans::drop_ty(bcx, a, t); a }\n-    };\n-    Store(bcx, vptr, vptrptr);\n+    Store(bcx, vptr, trans::get_dest_addr(dest));\n     ret bcx;\n }\n \n@@ -147,11 +143,7 @@ fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n     let bcx =\n         call_memmove(bcx, get_dataptr_simple(bcx, sptr, T_i8()), llcstr,\n                      C_uint(veclen)).bcx;\n-    let sptrptr = alt dest {\n-      trans::save_in(a) { a }\n-      trans::overwrite(a, t) { bcx = trans::drop_ty(bcx, a, t); a }\n-    };\n-    Store(bcx, sptr, sptrptr);\n+    Store(bcx, sptr, trans::get_dest_addr(dest));\n     ret bcx;\n }\n \n@@ -266,13 +258,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n \n     let bcx = iter_vec_raw(bcx, lhsptr, vec_ty, lhs_fill, copy_fn);\n     bcx = iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n-    alt dest {\n-      trans::save_in(a) { Store(bcx, new_vec_ptr, a); }\n-      trans::overwrite(a, t) {\n-        bcx = trans::drop_ty(bcx, a, t);\n-        Store(bcx, new_vec_ptr, a);\n-      }\n-    }\n+    Store(bcx, new_vec_ptr, trans::get_dest_addr(dest));\n     ret bcx;\n }\n "}]}