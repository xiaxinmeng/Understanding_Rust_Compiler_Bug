{"sha": "293af417903b1a718795e60a1b6de0dea8fc4af0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5M2FmNDE3OTAzYjFhNzE4Nzk1ZTYwYTFiNmRlMGRlYThmYzRhZjA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-01T21:28:32Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-24T20:28:29Z"}, "message": "Split `Usefulness::NotUseful` into two", "tree": {"sha": "1fc6ba44814aef989dc825daff96e53943e7d2b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fc6ba44814aef989dc825daff96e53943e7d2b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/293af417903b1a718795e60a1b6de0dea8fc4af0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/293af417903b1a718795e60a1b6de0dea8fc4af0", "html_url": "https://github.com/rust-lang/rust/commit/293af417903b1a718795e60a1b6de0dea8fc4af0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/293af417903b1a718795e60a1b6de0dea8fc4af0/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4f20c0663b686f76c5722fde481c83acf2dd1e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f20c0663b686f76c5722fde481c83acf2dd1e9", "html_url": "https://github.com/rust-lang/rust/commit/f4f20c0663b686f76c5722fde481c83acf2dd1e9"}], "stats": {"total": 84, "additions": 52, "deletions": 32}, "files": [{"sha": "6f94edb9932b0411e028c54a6657378b57dc853e", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/293af417903b1a718795e60a1b6de0dea8fc4af0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/293af417903b1a718795e60a1b6de0dea8fc4af0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=293af417903b1a718795e60a1b6de0dea8fc4af0", "patch": "@@ -680,24 +680,32 @@ impl SpanSet {\n \n #[derive(Clone, Debug)]\n enum Usefulness<'tcx> {\n-    /// Pontentially carries a set of sub-branches that have been found to be unreachable. Used\n+    /// Potentially carries a set of sub-branches that have been found to be unreachable. Used\n     /// only in the presence of or-patterns, otherwise it stays empty.\n-    Useful(SpanSet),\n-    /// Carries a list of witnesses of non-exhaustiveness.\n-    UsefulWithWitness(Vec<Witness<'tcx>>),\n-    NotUseful,\n+    NoWitnesses(SpanSet),\n+    /// When not carrying witnesses, indicates that the whole pattern is unreachable.\n+    NoWitnessesFull,\n+    /// Carries a list of witnesses of non-exhaustiveness. Non-empty.\n+    WithWitnesses(Vec<Witness<'tcx>>),\n+    /// When carrying witnesses, indicates that the whole pattern is unreachable.\n+    WithWitnessesEmpty,\n }\n \n impl<'tcx> Usefulness<'tcx> {\n     fn new_useful(preference: WitnessPreference) -> Self {\n         match preference {\n-            ConstructWitness => UsefulWithWitness(vec![Witness(vec![])]),\n-            LeaveOutWitness => Useful(Default::default()),\n+            ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n+            LeaveOutWitness => NoWitnesses(Default::default()),\n+        }\n+    }\n+    fn new_not_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => WithWitnessesEmpty,\n+            LeaveOutWitness => NoWitnessesFull,\n         }\n     }\n \n-    /// Combine usefulnesses from two branches. This is an associative operation and `NotUseful` is\n-    /// a unit.\n+    /// Combine usefulnesses from two branches. This is an associative operation.\n     fn extend(&mut self, other: Self) {\n         // If we have detected some unreachable sub-branches, we only want to keep them when they\n         // were unreachable in _all_ branches. Eg. in the following, the last `true` is unreachable\n@@ -720,21 +728,29 @@ impl<'tcx> Usefulness<'tcx> {\n         // }\n         // ```\n         match (&mut *self, other) {\n-            (Useful(s), Useful(o)) => s.intersection_mut(&o),\n-            (UsefulWithWitness(s), UsefulWithWitness(o)) => s.extend(o),\n-            (_, NotUseful) => {}\n-            (NotUseful, other) => *self = other,\n-            (UsefulWithWitness(_), Useful(_)) | (Useful(_), UsefulWithWitness(_)) => unreachable!(),\n+            (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n+            (WithWitnessesEmpty, WithWitnesses(o)) => *self = WithWitnesses(o),\n+            (WithWitnesses(_), WithWitnessesEmpty) => {}\n+            (WithWitnessesEmpty, WithWitnessesEmpty) => {}\n+\n+            (NoWitnesses(s), NoWitnesses(o)) => s.intersection_mut(&o),\n+            (NoWitnessesFull, NoWitnesses(o)) => *self = NoWitnesses(o),\n+            (NoWitnesses(_), NoWitnessesFull) => {}\n+            (NoWitnessesFull, NoWitnessesFull) => {}\n+\n+            _ => {\n+                unreachable!()\n+            }\n         }\n     }\n \n     /// When trying several branches and each returns a `Usefulness`, we need to combine the\n     /// results together.\n-    fn merge(usefulnesses: impl Iterator<Item = Self>) -> Self {\n-        let mut ret = NotUseful;\n+    fn merge(pref: WitnessPreference, usefulnesses: impl Iterator<Item = Self>) -> Self {\n+        let mut ret = Self::new_not_useful(pref);\n         for u in usefulnesses {\n             ret.extend(u);\n-            if let Useful(spans) = &ret {\n+            if let NoWitnesses(spans) = &ret {\n                 if spans.is_empty() {\n                     // Once we reach the empty set, more intersections won't change the result.\n                     return ret;\n@@ -748,7 +764,7 @@ impl<'tcx> Usefulness<'tcx> {\n     /// usefulness mergeable with those from the other branches.\n     fn unsplit_or_pat(self, this_span: Span, or_pat_spans: &[Span]) -> Self {\n         match self {\n-            Useful(mut spans) => {\n+            NoWitnesses(mut spans) => {\n                 // We register the spans of the other branches of this or-pattern as being\n                 // unreachable from this one. This ensures that intersecting together the sets of\n                 // spans returns what we want.\n@@ -759,9 +775,10 @@ impl<'tcx> Usefulness<'tcx> {\n                         spans.push_nonintersecting(span);\n                     }\n                 }\n-                Useful(spans)\n+                NoWitnesses(spans)\n             }\n-            x => x,\n+            NoWitnessesFull => NoWitnessesFull,\n+            WithWitnesses(_) | WithWitnessesEmpty => bug!(),\n         }\n     }\n \n@@ -776,7 +793,7 @@ impl<'tcx> Usefulness<'tcx> {\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n-            UsefulWithWitness(witnesses) => {\n+            WithWitnesses(witnesses) => {\n                 let new_witnesses = if matches!(ctor, Constructor::Missing) {\n                     let mut split_wildcard = SplitWildcard::new(pcx);\n                     split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n@@ -806,7 +823,7 @@ impl<'tcx> Usefulness<'tcx> {\n                         .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n                         .collect()\n                 };\n-                UsefulWithWitness(new_witnesses)\n+                WithWitnesses(new_witnesses)\n             }\n             x => x,\n         }\n@@ -935,8 +952,11 @@ fn is_useful<'p, 'tcx>(\n     // first and then, if v is non-empty, the return value is based on whether\n     // the type of the tuple we're checking is inhabited or not.\n     if v.is_empty() {\n-        let ret =\n-            if rows.is_empty() { Usefulness::new_useful(witness_preference) } else { NotUseful };\n+        let ret = if rows.is_empty() {\n+            Usefulness::new_useful(witness_preference)\n+        } else {\n+            Usefulness::new_not_useful(witness_preference)\n+        };\n         debug!(?ret);\n         return ret;\n     }\n@@ -966,7 +986,7 @@ fn is_useful<'p, 'tcx>(\n             }\n             usefulness.unsplit_or_pat(v_span, &subspans)\n         });\n-        Usefulness::merge(usefulnesses)\n+        Usefulness::merge(witness_preference, usefulnesses)\n     } else {\n         let v_ctor = v.head_ctor(cx);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n@@ -994,7 +1014,7 @@ fn is_useful<'p, 'tcx>(\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n         });\n-        Usefulness::merge(usefulnesses)\n+        Usefulness::merge(witness_preference, usefulnesses)\n     };\n     debug!(?ret);\n     ret\n@@ -1049,9 +1069,9 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n                 matrix.push(v);\n             }\n             let reachability = match usefulness {\n-                Useful(spans) => Reachability::Reachable(spans),\n-                NotUseful => Reachability::Unreachable,\n-                UsefulWithWitness(..) => bug!(),\n+                NoWitnesses(spans) => Reachability::Reachable(spans),\n+                NoWitnessesFull => Reachability::Unreachable,\n+                WithWitnesses(..) | WithWitnessesEmpty => bug!(),\n             };\n             (arm, reachability)\n         })\n@@ -1061,15 +1081,15 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n-        NotUseful => vec![], // Wildcard pattern isn't useful, so the match is exhaustive.\n-        UsefulWithWitness(pats) => {\n+        WithWitnessesEmpty => vec![], // Wildcard pattern isn't useful, so the match is exhaustive.\n+        WithWitnesses(pats) => {\n             if pats.is_empty() {\n                 bug!(\"Exhaustiveness check returned no witnesses\")\n             } else {\n                 pats.into_iter().map(|w| w.single_pattern()).collect()\n             }\n         }\n-        Useful(_) => bug!(),\n+        NoWitnesses(_) | NoWitnessesFull => bug!(),\n     };\n     UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n }"}]}