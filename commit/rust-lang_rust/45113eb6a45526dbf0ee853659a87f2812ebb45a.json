{"sha": "45113eb6a45526dbf0ee853659a87f2812ebb45a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MTEzZWI2YTQ1NTI2ZGJmMGVlODUzNjU5YTg3ZjI4MTJlYmI0NWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-18T08:13:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-18T08:13:24Z"}, "message": "Auto merge of #1325 - RalfJung:float_to_int_unchecked, r=RalfJung\n\nimplement float_to_int_unchecked\n\n@hanna-kruppe would be great if you could have a look at this.\n\n`float.rs` tests legal casts. `test_cast` checks that both `as` casts and unchecked casts work (i.e., these are not saturating). The `compile-fail` tests should ensure that illegal casts via the intrinsic are detected as such.\n\nFixes https://github.com/rust-lang/miri/issues/1264", "tree": {"sha": "ce2dca21e2292b3007ee6735bab1e8f2c218ffd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce2dca21e2292b3007ee6735bab1e8f2c218ffd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45113eb6a45526dbf0ee853659a87f2812ebb45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45113eb6a45526dbf0ee853659a87f2812ebb45a", "html_url": "https://github.com/rust-lang/rust/commit/45113eb6a45526dbf0ee853659a87f2812ebb45a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45113eb6a45526dbf0ee853659a87f2812ebb45a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72667b58b8b262055c3f0a7146974c7a22d83b37", "url": "https://api.github.com/repos/rust-lang/rust/commits/72667b58b8b262055c3f0a7146974c7a22d83b37", "html_url": "https://github.com/rust-lang/rust/commit/72667b58b8b262055c3f0a7146974c7a22d83b37"}, {"sha": "bb38ab4340b944cb047ea0977d4198aaa9a36dec", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb38ab4340b944cb047ea0977d4198aaa9a36dec", "html_url": "https://github.com/rust-lang/rust/commit/bb38ab4340b944cb047ea0977d4198aaa9a36dec"}], "stats": {"total": 493, "additions": 425, "deletions": 68}, "files": [{"sha": "1f9004221920ff7f583ec4520e60cd51408b7a0b", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -1,9 +1,10 @@\n use std::iter;\n use std::convert::TryFrom;\n \n+use rustc_ast::ast::FloatTy;\n use rustc_middle::{mir, ty};\n-use rustc_apfloat::Float;\n-use rustc_target::abi::{Align, LayoutOf};\n+use rustc_apfloat::{Float, Round};\n+use rustc_target::abi::{Align, LayoutOf, Size};\n \n use crate::*;\n \n@@ -279,6 +280,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_u64(f.powi(i).to_bits()), dest)?;\n             }\n \n+            \"float_to_int_unchecked\" => {\n+                let val = this.read_immediate(args[0])?;\n+\n+                let res = match val.layout.ty.kind {\n+                    ty::Float(FloatTy::F32) => {\n+                        this.float_to_int_unchecked(val.to_scalar()?.to_f32()?, dest.layout.ty)?\n+                    }\n+                    ty::Float(FloatTy::F64) => {\n+                        this.float_to_int_unchecked(val.to_scalar()?.to_f64()?, dest.layout.ty)?\n+                    }\n+                    _ => bug!(\"`float_to_int_unchecked` called with non-float input type {:?}\", val.layout.ty),\n+                };\n+\n+                this.write_scalar(res, dest)?;\n+            }\n+\n             // Atomic operations\n             #[rustfmt::skip]\n             | \"atomic_load\"\n@@ -493,4 +510,55 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.go_to_block(ret);\n         Ok(())\n     }\n+\n+    fn float_to_int_unchecked<F>(\n+        &self,\n+        f: F,\n+        dest_ty: ty::Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Scalar<Tag>>\n+    where\n+        F: Float + Into<Scalar<Tag>>\n+    {\n+        let this = self.eval_context_ref();\n+\n+        // Step 1: cut off the fractional part of `f`. The result of this is\n+        // guaranteed to be precisely representable in IEEE floats.\n+        let f = f.round_to_integral(Round::TowardZero).value;\n+\n+        // Step 2: Cast the truncated float to the target integer type and see if we lose any information in this step.\n+        Ok(match dest_ty.kind {\n+            // Unsigned\n+            ty::Uint(t) => {\n+                let width = t.bit_width().unwrap_or_else(|| this.pointer_size().bits());\n+                let res = f.to_u128(usize::try_from(width).unwrap());\n+                if res.status.is_empty() {\n+                    // No status flags means there was no further rounding or other loss of precision.\n+                    Scalar::from_uint(res.value, Size::from_bits(width))\n+                } else {\n+                    // `f` was not representable in this integer type.\n+                    throw_ub_format!(\n+                        \"`float_to_int_unchecked` intrinsic called on {} which cannot be represented in target type `{:?}`\",\n+                        f, dest_ty,\n+                    );\n+                }\n+            }\n+            // Signed\n+            ty::Int(t) => {\n+                let width = t.bit_width().unwrap_or_else(|| this.pointer_size().bits());\n+                let res = f.to_i128(usize::try_from(width).unwrap());\n+                if res.status.is_empty() {\n+                    // No status flags means there was no further rounding or other loss of precision.\n+                    Scalar::from_int(res.value, Size::from_bits(width))\n+                } else {\n+                    // `f` was not representable in this integer type.\n+                    throw_ub_format!(\n+                        \"`float_to_int_unchecked` intrinsic called on {} which cannot be represented in target type `{:?}`\",\n+                        f, dest_ty,\n+                    );\n+                }\n+            }\n+            // Nothing else\n+            _ => bug!(\"`float_to_int_unchecked` called with non-int output type {:?}\", dest_ty),\n+        })\n+    }\n }"}, {"sha": "8d3c68139317e2ea50641ab29cca732c634e0262", "filename": "tests/compile-fail/intrinsics/copy_overlapping.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Fcopy_overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Fcopy_overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fcopy_overlapping.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -1,4 +1,3 @@\n-//error-pattern: copy_nonoverlapping called on overlapping ranges\n #![feature(intrinsics)]\n \n // Directly call intrinsic to avoid debug assertions in libstd\n@@ -11,6 +10,6 @@ fn main() {\n     unsafe {\n         let a = data.as_mut_ptr();\n         let b = a.wrapping_offset(1) as *mut _;\n-        copy_nonoverlapping(a, b, 2);\n+        copy_nonoverlapping(a, b, 2); //~ ERROR copy_nonoverlapping called on overlapping ranges\n     }\n }"}, {"sha": "84f4de93461e7aec452e0edb7f07e2be7313b3c4", "filename": "tests/compile-fail/intrinsics/copy_unaligned.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Fcopy_unaligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Fcopy_unaligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Fcopy_unaligned.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -1,4 +1,3 @@\n-//error-pattern: accessing memory with alignment 1, but alignment 2 is required\n #![feature(intrinsics)]\n \n // Directly call intrinsic to avoid debug assertions in libstd\n@@ -10,5 +9,5 @@ fn main() {\n     let mut data = [0u16; 8];\n     let ptr = (&mut data[0] as *mut u16 as *mut u8).wrapping_add(1) as *mut u16;\n     // Even copying 0 elements to something unaligned should error\n-    unsafe { copy_nonoverlapping(&data[5], ptr, 0); }\n+    unsafe { copy_nonoverlapping(&data[5], ptr, 0); } //~ ERROR accessing memory with alignment 1, but alignment 2 is required\n }"}, {"sha": "a56f4aefad3a7e5cdbbdfb2355c12b769874cc5a", "filename": "tests/compile-fail/intrinsics/float_to_int_32_inf1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_inf1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_inf1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_inf1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, i32>(f32::INFINITY); } //~ ERROR: cannot be represented in target type `i32`\n+}"}, {"sha": "d18f75fcca8abdbf6d4a677547f7832c669a84f1", "filename": "tests/compile-fail/intrinsics/float_to_int_32_infneg1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_infneg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_infneg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_infneg1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, i32>(f32::NEG_INFINITY); } //~ ERROR: cannot be represented in target type `i32`\n+}"}, {"sha": "e1fe8c7cf2f7422ecba8d03502ea0e4fa475f58d", "filename": "tests/compile-fail/intrinsics/float_to_int_32_nan.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_nan.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, u32>(f32::NAN); } //~ ERROR: cannot be represented in target type `u32`\n+}"}, {"sha": "38899045c92c0f9fe2d66932fc09958ae6113ad7", "filename": "tests/compile-fail/intrinsics/float_to_int_32_nanneg.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_nanneg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_nanneg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_nanneg.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, u32>(-f32::NAN); } //~ ERROR: cannot be represented in target type `u32`\n+}"}, {"sha": "f15cf9a9cd6433249e301cd45b935bf48d69328f", "filename": "tests/compile-fail/intrinsics/float_to_int_32_neg.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_neg.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, u32>(-1.000000001f32); } //~ ERROR: cannot be represented in target type `u32`\n+}"}, {"sha": "ccbf917c8e89f7ddc106121c710f2774e0c7a7b2", "filename": "tests/compile-fail/intrinsics/float_to_int_32_too_big1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_big1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_big1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_big1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, i32>(2147483648.0f32); } //~ ERROR: cannot be represented in target type `i32`\n+}"}, {"sha": "6598fd36e038a3716f6843457b0fdb1bdaa208c6", "filename": "tests/compile-fail/intrinsics/float_to_int_32_too_big2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_big2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_big2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_big2.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, u32>((u32::MAX-127) as f32); } //~ ERROR: cannot be represented in target type `u32`\n+}"}, {"sha": "89f09e1e3f18ab9ac082a88a387fb113a6cb2ad1", "filename": "tests/compile-fail/intrinsics/float_to_int_32_too_small1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_small1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_small1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_32_too_small1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f32, i32>(-2147483904.0f32); } //~ ERROR: cannot be represented in target type `i32`\n+}"}, {"sha": "e1a7b818d8539e14d36f42670a9d14bb312d09a6", "filename": "tests/compile-fail/intrinsics/float_to_int_64_inf1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_inf1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_inf1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_inf1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, u128>(f64::INFINITY); } //~ ERROR: cannot be represented in target type `u128`\n+}"}, {"sha": "a1d757b1511e61b0ed6fef09867256f959492f2c", "filename": "tests/compile-fail/intrinsics/float_to_int_64_infneg1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_infneg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_infneg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_infneg1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, u128>(f64::NEG_INFINITY); } //~ ERROR: cannot be represented in target type `u128`\n+}"}, {"sha": "e48d19f1a6a86b0dbf03ef6bd09ad4e34b528ea7", "filename": "tests/compile-fail/intrinsics/float_to_int_64_infneg2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_infneg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_infneg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_infneg2.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i128>(f64::NEG_INFINITY); } //~ ERROR: cannot be represented in target type `i128`\n+}"}, {"sha": "03f378f5bcb7280e57c87f3bcd13bce1095836b2", "filename": "tests/compile-fail/intrinsics/float_to_int_64_nan.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_nan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_nan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_nan.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, u32>(f64::NAN); } //~ ERROR: cannot be represented in target type `u32`\n+}"}, {"sha": "d0b5a3e21cf9eb7778be9c58fa78eb2f8ca1f0f0", "filename": "tests/compile-fail/intrinsics/float_to_int_64_neg.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_neg.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, u128>(-1.0000000000001f64); } //~ ERROR: cannot be represented in target type `u128`\n+}"}, {"sha": "f928f161872e2d46401e2841de24691a38ff3142", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_big1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i32>(2147483648.0f64); } //~ ERROR: cannot be represented in target type `i32`\n+}"}, {"sha": "feb24c362dda7275fab384d12336ef216383b8b9", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_big2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big2.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i64>(9223372036854775808.0f64); } //~ ERROR: cannot be represented in target type `i64`\n+}"}, {"sha": "cd491bfed7eb9d801c1ea15f66c22891878865b8", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_big3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big3.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, u64>(18446744073709551616.0f64); } //~ ERROR: cannot be represented in target type `u64`\n+}"}, {"sha": "e9623dba947f393b52063129c5b823bc525704ff", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_big4.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big4.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, u128>(u128::MAX as f64); } //~ ERROR: cannot be represented in target type `u128`\n+}"}, {"sha": "9c31c690b4e8a4f8d66643800ccb86342c0c1558", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_big5.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_big5.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i128>(240282366920938463463374607431768211455.0f64); } //~ ERROR: cannot be represented in target type `i128`\n+}"}, {"sha": "08f2f9e3fd26c1a462ec0a7b9d36ecaa318d21e3", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_small1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small1.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i32>(-2147483649.0f64); } //~ ERROR: cannot be represented in target type `i32`\n+}"}, {"sha": "f7b205de5346c91784e482c1b8b88c43092b7115", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_small2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small2.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i64>(-9223372036854777856.0f64); } //~ ERROR: cannot be represented in target type `i64`\n+}"}, {"sha": "779441f7448c8d844e028c9cd27375fae1a5c11f", "filename": "tests/compile-fail/intrinsics/float_to_int_64_too_small3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintrinsics%2Ffloat_to_int_64_too_small3.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -0,0 +1,10 @@\n+#![feature(intrinsics)]\n+\n+// Directly call intrinsic to avoid debug assertions in libstd\n+extern \"rust-intrinsic\" {\n+    fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n+}\n+\n+fn main() {\n+    unsafe { float_to_int_unchecked::<f64, i128>(-240282366920938463463374607431768211455.0f64); } //~ ERROR: cannot be represented in target type `i128`\n+}"}, {"sha": "364388571f44c22aee068a185ad4155c739c28a1", "filename": "tests/run-pass/float.rs", "status": "modified", "additions": 143, "deletions": 62, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45113eb6a45526dbf0ee853659a87f2812ebb45a/tests%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffloat.rs?ref=45113eb6a45526dbf0ee853659a87f2812ebb45a", "patch": "@@ -10,6 +10,71 @@ fn assert_eq<T: PartialEq + Debug>(x: T, y: T) {\n     assert_eq!(x, y);\n }\n \n+trait FloatToInt<Int>: Copy {\n+    fn cast(self) -> Int;\n+    unsafe fn cast_unchecked(self) -> Int;\n+}\n+\n+impl FloatToInt<i8> for f32 {\n+    fn cast(self) -> i8 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i8 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<i32> for f32 {\n+    fn cast(self) -> i32 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i32 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<u32> for f32 {\n+    fn cast(self) -> u32 { self as _ }\n+    unsafe fn cast_unchecked(self) -> u32 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<i64> for f32 {\n+    fn cast(self) -> i64 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i64 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<u64> for f32 {\n+    fn cast(self) -> u64 { self as _ }\n+    unsafe fn cast_unchecked(self) -> u64 { self.to_int_unchecked() }\n+}\n+\n+impl FloatToInt<i8> for f64 {\n+    fn cast(self) -> i8 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i8 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<i32> for f64 {\n+    fn cast(self) -> i32 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i32 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<u32> for f64 {\n+    fn cast(self) -> u32 { self as _ }\n+    unsafe fn cast_unchecked(self) -> u32 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<i64> for f64 {\n+    fn cast(self) -> i64 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i64 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<u64> for f64 {\n+    fn cast(self) -> u64 { self as _ }\n+    unsafe fn cast_unchecked(self) -> u64 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<i128> for f64 {\n+    fn cast(self) -> i128 { self as _ }\n+    unsafe fn cast_unchecked(self) -> i128 { self.to_int_unchecked() }\n+}\n+impl FloatToInt<u128> for f64 {\n+    fn cast(self) -> u128 { self as _ }\n+    unsafe fn cast_unchecked(self) -> u128 { self.to_int_unchecked() }\n+}\n+\n+/// Test this cast both via `as` and via `approx_unchecked` (i.e., it must not saturate).\n+#[track_caller]\n+#[inline(never)]\n+fn test_cast<F, I>(x: F, y: I)\n+    where F: FloatToInt<I>, I: PartialEq + Debug\n+{\n+    assert_eq!(x.cast(), y);\n+    assert_eq!(unsafe { x.cast_unchecked() }, y);\n+}\n+\n fn main() {\n     basic();\n     casts();\n@@ -50,19 +115,23 @@ fn basic() {\n }\n \n fn casts() {\n+    // f32 -> i8\n+    test_cast::<f32, i8>(127.99, 127);\n+    test_cast::<f32, i8>(-128.99, -128);\n+\n     // f32 -> i32\n-    assert_eq::<i32>(0.0f32 as i32, 0);\n-    assert_eq::<i32>(-0.0f32 as i32, 0);\n-    assert_eq::<i32>(/*0x1p-149*/ f32::from_bits(0x00000001) as i32, 0);\n-    assert_eq::<i32>(/*-0x1p-149*/ f32::from_bits(0x80000001) as i32, 0);\n-    assert_eq::<i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd) as i32, 1);\n-    assert_eq::<i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd) as i32, -1);\n-    assert_eq::<i32>(1.9f32 as i32, 1);\n-    assert_eq::<i32>(-1.9f32 as i32, -1);\n-    assert_eq::<i32>(5.0f32 as i32, 5);\n-    assert_eq::<i32>(-5.0f32 as i32, -5);\n-    assert_eq::<i32>(2147483520.0f32 as i32, 2147483520);\n-    assert_eq::<i32>(-2147483648.0f32 as i32, -2147483648);\n+    test_cast::<f32, i32>(0.0, 0);\n+    test_cast::<f32, i32>(-0.0, 0);\n+    test_cast::<f32, i32>(/*0x1p-149*/ f32::from_bits(0x00000001), 0);\n+    test_cast::<f32, i32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_cast::<f32, i32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_cast::<f32, i32>(/*-0x1.19999ap+0*/ f32::from_bits(0xbf8ccccd), -1);\n+    test_cast::<f32, i32>(1.9, 1);\n+    test_cast::<f32, i32>(-1.9, -1);\n+    test_cast::<f32, i32>(5.0, 5);\n+    test_cast::<f32, i32>(-5.0, -5);\n+    test_cast::<f32, i32>(2147483520.0, 2147483520);\n+    test_cast::<f32, i32>(-2147483648.0, -2147483648);\n     // unrepresentable casts\n     assert_eq::<i32>(2147483648.0f32 as i32, i32::MAX);\n     assert_eq::<i32>(-2147483904.0f32 as i32, i32::MIN);\n@@ -74,20 +143,21 @@ fn casts() {\n     assert_eq::<i32>((-f32::NAN) as i32, 0);\n \n     // f32 -> u32\n-    assert_eq::<u32>(0.0f32 as u32, 0);\n-    assert_eq::<u32>(-0.0f32 as u32, 0);\n-    assert_eq::<u32>(/*0x1p-149*/ f32::from_bits(0x1) as u32, 0);\n-    assert_eq::<u32>(/*-0x1p-149*/ f32::from_bits(0x80000001) as u32, 0);\n-    assert_eq::<u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd) as u32, 1);\n-    assert_eq::<u32>(1.9f32 as u32, 1);\n-    assert_eq::<u32>(5.0f32 as u32, 5);\n-    assert_eq::<u32>(2147483648.0f32 as u32, 0x8000_0000);\n-    assert_eq::<u32>(4294967040.0f32 as u32, 0u32.wrapping_sub(256));\n-    assert_eq::<u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666) as u32, 0);\n-    assert_eq::<u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff) as u32, 0);\n-    assert_eq::<u32>((u32::MAX-127) as f32 as u32, u32::MAX); // rounding loss\n-    assert_eq::<u32>((u32::MAX-128) as f32 as u32, u32::MAX-255); // rounding loss\n+    test_cast::<f32, u32>(0.0, 0);\n+    test_cast::<f32, u32>(-0.0, 0);\n+    test_cast::<f32, u32>(-0.9999999, 0);\n+    test_cast::<f32, u32>(/*0x1p-149*/ f32::from_bits(0x1), 0);\n+    test_cast::<f32, u32>(/*-0x1p-149*/ f32::from_bits(0x80000001), 0);\n+    test_cast::<f32, u32>(/*0x1.19999ap+0*/ f32::from_bits(0x3f8ccccd), 1);\n+    test_cast::<f32, u32>(1.9, 1);\n+    test_cast::<f32, u32>(5.0, 5);\n+    test_cast::<f32, u32>(2147483648.0, 0x8000_0000);\n+    test_cast::<f32, u32>(4294967040.0, 0u32.wrapping_sub(256));\n+    test_cast::<f32, u32>(/*-0x1.ccccccp-1*/ f32::from_bits(0xbf666666), 0);\n+    test_cast::<f32, u32>(/*-0x1.fffffep-1*/ f32::from_bits(0xbf7fffff), 0);\n+    test_cast::<f32, u32>((u32::MAX-128) as f32, u32::MAX-255); // rounding loss\n     // unrepresentable casts\n+    assert_eq::<u32>((u32::MAX-127) as f32 as u32, u32::MAX); // rounds up and then becomes unrepresentable\n     assert_eq::<u32>(4294967296.0f32 as u32, u32::MAX);\n     assert_eq::<u32>(-5.0f32 as u32, 0);\n     assert_eq::<u32>(f32::MAX as u32, u32::MAX);\n@@ -98,40 +168,44 @@ fn casts() {\n     assert_eq::<u32>((-f32::NAN) as u32, 0);\n \n     // f32 -> i64\n-    assert_eq::<i64>(4294967296.0f32 as i64, 4294967296);\n-    assert_eq::<i64>(-4294967296.0f32 as i64, -4294967296);\n-    assert_eq::<i64>(9223371487098961920.0f32 as i64, 9223371487098961920);\n-    assert_eq::<i64>(-9223372036854775808.0f32 as i64, -9223372036854775808);\n+    test_cast::<f32, i64>(4294967296.0, 4294967296);\n+    test_cast::<f32, i64>(-4294967296.0, -4294967296);\n+    test_cast::<f32, i64>(9223371487098961920.0, 9223371487098961920);\n+    test_cast::<f32, i64>(-9223372036854775808.0, -9223372036854775808);\n+\n+    // f64 -> i8\n+    test_cast::<f64, i8>(127.99, 127);\n+    test_cast::<f64, i8>(-128.99, -128);\n \n     // f64 -> i32\n-    assert_eq::<i32>(0.0f64 as i32, 0);\n-    assert_eq::<i32>(-0.0f64 as i32, 0);\n-    assert_eq::<i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a) as i32, 1);\n-    assert_eq::<i32>(/*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a) as i32, -1);\n-    assert_eq::<i32>(1.9f64 as i32, 1);\n-    assert_eq::<i32>(-1.9f64 as i32, -1);\n-    assert_eq::<i32>(1e8f64 as i32, 100_000_000);\n-    assert_eq::<i32>(2147483647.0f64 as i32, 2147483647);\n-    assert_eq::<i32>(-2147483648.0f64 as i32, -2147483648);\n+    test_cast::<f64, i32>(0.0, 0);\n+    test_cast::<f64, i32>(-0.0, 0);\n+    test_cast::<f64, i32>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_cast::<f64, i32>(/*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a), -1);\n+    test_cast::<f64, i32>(1.9, 1);\n+    test_cast::<f64, i32>(-1.9, -1);\n+    test_cast::<f64, i32>(1e8, 100_000_000);\n+    test_cast::<f64, i32>(2147483647.0, 2147483647);\n+    test_cast::<f64, i32>(-2147483648.0, -2147483648);\n     // unrepresentable casts\n     assert_eq::<i32>(2147483648.0f64 as i32, i32::MAX);\n     assert_eq::<i32>(-2147483649.0f64 as i32, i32::MIN);\n \n     // f64 -> i64\n-    assert_eq::<i64>(0.0f64 as i64, 0);\n-    assert_eq::<i64>(-0.0f64 as i64, 0);\n-    assert_eq::<i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as i64, 0);\n-    assert_eq::<i64>(/*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001) as i64, 0);\n-    assert_eq::<i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a) as i64, 1);\n-    assert_eq::<i64>(/*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a) as i64, -1);\n-    assert_eq::<i64>(5.0f64 as i64, 5);\n-    assert_eq::<i64>(5.9f64 as i64, 5);\n-    assert_eq::<i64>(-5.0f64 as i64, -5);\n-    assert_eq::<i64>(-5.9f64 as i64, -5);\n-    assert_eq::<i64>(4294967296.0f64 as i64, 4294967296);\n-    assert_eq::<i64>(-4294967296.0f64 as i64, -4294967296);\n-    assert_eq::<i64>(9223372036854774784.0f64 as i64, 9223372036854774784);\n-    assert_eq::<i64>(-9223372036854775808.0f64 as i64, -9223372036854775808);\n+    test_cast::<f64, i64>(0.0, 0);\n+    test_cast::<f64, i64>(-0.0, 0);\n+    test_cast::<f64, i64>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1), 0);\n+    test_cast::<f64, i64>(/*-0x0.0000000000001p-1022*/ f64::from_bits(0x8000000000000001), 0);\n+    test_cast::<f64, i64>(/*0x1.199999999999ap+0*/ f64::from_bits(0x3ff199999999999a), 1);\n+    test_cast::<f64, i64>(/*-0x1.199999999999ap+0*/ f64::from_bits(0xbff199999999999a), -1);\n+    test_cast::<f64, i64>(5.0, 5);\n+    test_cast::<f64, i64>(5.9, 5);\n+    test_cast::<f64, i64>(-5.0, -5);\n+    test_cast::<f64, i64>(-5.9, -5);\n+    test_cast::<f64, i64>(4294967296.0, 4294967296);\n+    test_cast::<f64, i64>(-4294967296.0, -4294967296);\n+    test_cast::<f64, i64>(9223372036854774784.0, 9223372036854774784);\n+    test_cast::<f64, i64>(-9223372036854775808.0, -9223372036854775808);\n     // unrepresentable casts\n     assert_eq::<i64>(9223372036854775808.0f64 as i64, i64::MAX);\n     assert_eq::<i64>(-9223372036854777856.0f64 as i64, i64::MIN);\n@@ -143,15 +217,16 @@ fn casts() {\n     assert_eq::<i64>((-f64::NAN) as i64, 0);\n \n     // f64 -> u64\n-    assert_eq::<u64>(0.0f64 as u64, 0);\n-    assert_eq::<u64>(-0.0f64 as u64, 0);\n-    assert_eq::<u64>(5.0f64 as u64, 5);\n-    assert_eq::<u64>(-5.0f64 as u64, 0);\n-    assert_eq::<u64>(1e16f64 as u64, 10000000000000000);\n-    assert_eq::<u64>((u64::MAX-1023) as f64 as u64, u64::MAX); // rounding loss\n-    assert_eq::<u64>((u64::MAX-1024) as f64 as u64, u64::MAX-2047); // rounding loss\n-    assert_eq::<u64>(9223372036854775808.0f64 as u64, 9223372036854775808);\n+    test_cast::<f64, u64>(0.0, 0);\n+    test_cast::<f64, u64>(-0.0, 0);\n+    test_cast::<f64, u64>(-0.99999999999, 0);\n+    test_cast::<f64, u64>(5.0, 5);\n+    test_cast::<f64, u64>(1e16, 10000000000000000);\n+    test_cast::<f64, u64>((u64::MAX-1024) as f64, u64::MAX-2047); // rounding loss\n+    test_cast::<f64, u64>(9223372036854775808.0, 9223372036854775808);\n     // unrepresentable casts\n+    assert_eq::<u64>(-5.0f64 as u64, 0);\n+    assert_eq::<u64>((u64::MAX-1023) as f64 as u64, u64::MAX); // rounds up and then becomes unrepresentable\n     assert_eq::<u64>(18446744073709551616.0f64 as u64, u64::MAX);\n     assert_eq::<u64>(f64::MAX as u64, u64::MAX);\n     assert_eq::<u64>(f64::MIN as u64, 0);\n@@ -160,6 +235,14 @@ fn casts() {\n     assert_eq::<u64>(f64::NAN as u64, 0);\n     assert_eq::<u64>((-f64::NAN) as u64, 0);\n \n+    // f64 -> i128\n+    assert_eq::<i128>(f64::MAX as i128, i128::MAX);\n+    assert_eq::<i128>(f64::MIN as i128, i128::MIN);\n+\n+    // f64 -> u128\n+    assert_eq::<u128>(f64::MAX as u128, u128::MAX);\n+    assert_eq::<u128>(f64::MIN as u128, 0);\n+\n     // int -> f32\n     assert_eq::<f32>(127i8 as f32, 127.0);\n     assert_eq::<f32>(2147483647i32 as f32, 2147483648.0);\n@@ -210,10 +293,8 @@ fn casts() {\n     assert_eq::<f32>(5.0f64 as f32, 5.0f32);\n     assert_eq::<f32>(/*0x0.0000000000001p-1022*/ f64::from_bits(0x1) as f32, 0.0);\n     assert_eq::<f32>(/*-0x0.0000000000001p-1022*/ (-f64::from_bits(0x1)) as f32, -0.0);\n-\n     assert_eq::<f32>(/*0x1.fffffe0000000p-127*/ f64::from_bits(0x380fffffe0000000) as f32, /*0x1p-149*/ f32::from_bits(0x800000));\n     assert_eq::<f32>(/*0x1.4eae4f7024c7p+108*/ f64::from_bits(0x46b4eae4f7024c70) as f32, /*0x1.4eae5p+108*/ f32::from_bits(0x75a75728));\n-\n     assert_eq::<f32>(f64::MAX as f32, f32::INFINITY);\n     assert_eq::<f32>(f64::MIN as f32, f32::NEG_INFINITY);\n     assert_eq::<f32>(f64::INFINITY as f32, f32::INFINITY);"}]}