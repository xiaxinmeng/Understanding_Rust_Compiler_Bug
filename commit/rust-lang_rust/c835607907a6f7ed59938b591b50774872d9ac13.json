{"sha": "c835607907a6f7ed59938b591b50774872d9ac13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MzU2MDc5MDdhNmY3ZWQ1OTkzOGI1OTFiNTA3NzQ4NzJkOWFjMTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-20T15:27:44Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-30T09:55:38Z"}, "message": "rustdoc: remove def_ctor hack.", "tree": {"sha": "df2976d683c0de839ee264af7bf7cffc541d4f47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2976d683c0de839ee264af7bf7cffc541d4f47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c835607907a6f7ed59938b591b50774872d9ac13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c835607907a6f7ed59938b591b50774872d9ac13", "html_url": "https://github.com/rust-lang/rust/commit/c835607907a6f7ed59938b591b50774872d9ac13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c835607907a6f7ed59938b591b50774872d9ac13/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f843ad60ef5a78d8b4da85c5007d3ecac229f1a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f843ad60ef5a78d8b4da85c5007d3ecac229f1a8", "html_url": "https://github.com/rust-lang/rust/commit/f843ad60ef5a78d8b4da85c5007d3ecac229f1a8"}], "stats": {"total": 664, "additions": 146, "deletions": 518}, "files": [{"sha": "dcbd48d6498cff35db469bda41cf4a9cc67cc0da", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -77,15 +77,15 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     /// in the future.\n     pub fn find_auto_trait_generics<A>(\n         &self,\n-        did: DefId,\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n         trait_did: DefId,\n         generics: &ty::Generics,\n         auto_trait_callback: impl for<'i> Fn(&InferCtxt<'_, 'tcx, 'i>, AutoTraitInfo<'i>) -> A,\n     ) -> AutoTraitResult<A> {\n         let tcx = self.tcx;\n-        let ty = self.tcx.type_of(did);\n \n-        let orig_params = tcx.param_env(did);\n+        let orig_params = tcx.param_env(param_env_def_id);\n \n         let trait_ref = ty::TraitRef {\n             def_id: trait_did,\n@@ -105,9 +105,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             match result {\n                 Ok(Some(Vtable::VtableImpl(_))) => {\n                     debug!(\n-                        \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n+                        \"find_auto_trait_generics(ty={:?}, trait_did={:?}, generics={:?}): \\\n                          manual impl found, bailing out\",\n-                        did, trait_did, generics\n+                        ty, trait_did, generics\n                     );\n                     true\n                 }\n@@ -158,7 +158,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             let (new_env, user_env) = match self.evaluate_predicates(\n                 &mut infcx,\n-                did,\n                 trait_did,\n                 ty,\n                 orig_params.clone(),\n@@ -172,7 +171,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n             let (full_env, full_user_env) = self.evaluate_predicates(\n                 &mut infcx,\n-                did,\n                 trait_did,\n                 ty,\n                 new_env.clone(),\n@@ -187,9 +185,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             });\n \n             debug!(\n-                \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n+                \"find_auto_trait_generics(ty={:?}, trait_did={:?}, generics={:?}): fulfilling \\\n                  with {:?}\",\n-                did, trait_did, generics, full_env\n+                ty, trait_did, generics, full_env\n             );\n             infcx.clear_caches();\n \n@@ -289,7 +287,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     pub fn evaluate_predicates<'b, 'gcx, 'c>(\n         &self,\n         infcx: &InferCtxt<'b, 'tcx, 'c>,\n-        ty_did: DefId,\n         trait_did: DefId,\n         ty: Ty<'c>,\n         param_env: ty::ParamEnv<'c>,\n@@ -401,9 +398,9 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             None\n         );\n         debug!(\n-            \"evaluate_nested_obligations(ty_did={:?}, trait_did={:?}): succeeded with '{:?}' \\\n+            \"evaluate_nested_obligations(ty={:?}, trait_did={:?}): succeeded with '{:?}' \\\n              '{:?}'\",\n-            ty_did, trait_did, new_env, final_user_env\n+            ty, trait_did, new_env, final_user_env\n         );\n \n         return Some((new_env, final_user_env));"}, {"sha": "46af92baa93f6ea096ef208684ece902e367e9b5", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 52, "deletions": 82, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -3,8 +3,6 @@ use rustc::traits::auto_trait as auto;\n use rustc::ty::{self, TypeFoldable};\n use std::fmt::Debug;\n \n-use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n-\n use super::*;\n \n pub struct AutoTraitFinder<'a, 'tcx> {\n@@ -19,103 +17,71 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         AutoTraitFinder { cx, f }\n     }\n \n-    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n-        get_def_from_def_id(&self.cx, def_id, &|def_ctor| {\n-            self.get_auto_trait_impls(def_id, &def_ctor, None)\n-        })\n-    }\n-\n-    pub fn get_with_hir_id(&self, id: hir::HirId, name: String) -> Vec<Item> {\n-        get_def_from_hir_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n-            self.get_auto_trait_impls(did, &def_ctor, Some(name))\n-        })\n-    }\n-\n-    pub fn get_auto_trait_impls<F>(\n+    // FIXME(eddyb) figure out a better way to pass information about\n+    // parametrization of `ty` than `param_env_def_id`.\n+    pub fn get_auto_trait_impls(\n         &self,\n-        def_id: DefId,\n-        def_ctor: &F,\n-        name: Option<String>,\n-    ) -> Vec<Item>\n-    where F: Fn(DefId) -> Def {\n-        if self.cx\n-            .tcx\n-            .get_attrs(def_id)\n-            .lists(\"doc\")\n-            .has_word(\"hidden\")\n-        {\n-            debug!(\n-                \"get_auto_trait_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n-                 aborting\",\n-                def_id\n-            );\n-            return Vec::new();\n-        }\n-\n-        let tcx = self.cx.tcx;\n-        let generics = self.cx.tcx.generics_of(def_id);\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n+    ) -> Vec<Item> {\n+        let generics = self.cx.tcx.generics_of(param_env_def_id);\n \n         debug!(\n-            \"get_auto_trait_impls(def_id={:?}, def_ctor=..., generics={:?}\",\n-            def_id, generics\n+            \"get_auto_trait_impls(param_env_def_id={:?}, generics={:?}\",\n+            param_env_def_id, generics\n         );\n         let auto_traits: Vec<_> = self.cx\n             .send_trait\n             .and_then(|send_trait| {\n                 self.get_auto_trait_impl_for(\n-                    def_id,\n-                    name.clone(),\n-                    generics.clone(),\n-                    def_ctor,\n+                    ty,\n+                    param_env_def_id,\n+                    generics,\n                     send_trait,\n                 )\n             })\n             .into_iter()\n             .chain(self.get_auto_trait_impl_for(\n-                def_id,\n-                name,\n-                generics.clone(),\n-                def_ctor,\n-                tcx.require_lang_item(lang_items::SyncTraitLangItem),\n+                ty,\n+                param_env_def_id,\n+                generics,\n+                self.cx.tcx.require_lang_item(lang_items::SyncTraitLangItem),\n             ).into_iter())\n             .collect();\n \n         debug!(\n             \"get_auto_traits: type {:?} auto_traits {:?}\",\n-            def_id, auto_traits\n+            param_env_def_id, auto_traits\n         );\n         auto_traits\n     }\n \n-    fn get_auto_trait_impl_for<F>(\n+    fn get_auto_trait_impl_for(\n         &self,\n-        def_id: DefId,\n-        name: Option<String>,\n-        generics: ty::Generics,\n-        def_ctor: &F,\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n+        generics: &ty::Generics,\n         trait_def_id: DefId,\n-    ) -> Option<Item>\n-    where F: Fn(DefId) -> Def {\n+    ) -> Option<Item> {\n         if !self.cx\n             .generated_synthetics\n             .borrow_mut()\n-            .insert((def_id, trait_def_id))\n+            .insert((param_env_def_id, trait_def_id))\n         {\n             debug!(\n-                \"get_auto_trait_impl_for(def_id={:?}, generics={:?}, def_ctor=..., \\\n+                \"get_auto_trait_impl_for(param_env_def_id={:?}, generics={:?}, \\\n                  trait_def_id={:?}): already generated, aborting\",\n-                def_id, generics, trait_def_id\n+                param_env_def_id, generics, trait_def_id\n             );\n             return None;\n         }\n \n-        let result = self.find_auto_trait_generics(def_id, trait_def_id, &generics);\n+        let result = self.find_auto_trait_generics(ty, param_env_def_id, trait_def_id, &generics);\n \n         if result.is_auto() {\n-            let trait_ = hir::TraitRef {\n-                path: get_path_for_type(self.cx.tcx, trait_def_id, hir::def::Def::Trait),\n-                hir_ref_id: hir::DUMMY_HIR_ID,\n+            let trait_ref = ty::TraitRef {\n+                def_id: trait_def_id,\n+                substs: self.cx.tcx.mk_substs_trait(ty, &[]),\n             };\n \n             let polarity;\n@@ -140,7 +106,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     // Instead, we generate `impl !Send for Foo<T>`, which better\n                     // expresses the fact that `Foo<T>` never implements `Send`,\n                     // regardless of the choice of `T`.\n-                    let real_generics = (&generics, &Default::default());\n+                    let real_generics = (generics, &Default::default());\n \n                     // Clean the generics, but ignore the '?Sized' bounds generated\n                     // by the `Clean` impl\n@@ -153,22 +119,20 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 }\n                 _ => unreachable!(),\n             };\n-            let real_name = name.map(|name| Ident::from_str(&name));\n-            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, &generics);\n \n             return Some(Item {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n                 visibility: None,\n-                def_id: self.cx.next_def_id(def_id.krate),\n+                def_id: self.cx.next_def_id(param_env_def_id.krate),\n                 stability: None,\n                 deprecation: None,\n                 inner: ImplItem(Impl {\n                     unsafety: hir::Unsafety::Normal,\n                     generics: new_generics,\n                     provided_trait_methods: Default::default(),\n-                    trait_: Some(trait_.clean(self.cx)),\n+                    trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n                     for_: ty.clean(self.cx),\n                     items: Vec::new(),\n                     polarity,\n@@ -182,11 +146,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n     fn find_auto_trait_generics(\n         &self,\n-        did: DefId,\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n         trait_did: DefId,\n         generics: &ty::Generics,\n     ) -> AutoTraitResult {\n-        match self.f.find_auto_trait_generics(did, trait_did, generics,\n+        match self.f.find_auto_trait_generics(ty, param_env_def_id, trait_did, generics,\n                 |infcx, mut info| {\n                     let region_data = info.region_data;\n                     let names_map =\n@@ -198,17 +163,17 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                         self.handle_lifetimes(&region_data, &names_map);\n                     let new_generics = self.param_env_to_generics(\n                         infcx.tcx,\n-                        did,\n+                        param_env_def_id,\n                         info.full_user_env,\n-                        generics.clone(),\n+                        generics,\n                         lifetime_predicates,\n                         info.vid_to_region,\n                     );\n \n                     debug!(\n-                        \"find_auto_trait_generics(did={:?}, trait_did={:?}, generics={:?}): \\\n+                        \"find_auto_trait_generics(ty={:?}, trait_did={:?}, generics={:?}): \\\n                          finished with {:?}\",\n-                        did, trait_did, generics, new_generics\n+                        ty, trait_did, generics, new_generics\n                     );\n \n                     new_generics\n@@ -530,16 +495,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     fn param_env_to_generics<'b, 'c, 'cx>(\n         &self,\n         tcx: TyCtxt<'b, 'c, 'cx>,\n-        did: DefId,\n+        param_env_def_id: DefId,\n         param_env: ty::ParamEnv<'cx>,\n-        type_generics: ty::Generics,\n+        type_generics: &ty::Generics,\n         mut existing_predicates: Vec<WherePredicate>,\n         vid_to_region: FxHashMap<ty::RegionVid, ty::Region<'cx>>,\n     ) -> Generics {\n         debug!(\n-            \"param_env_to_generics(did={:?}, param_env={:?}, type_generics={:?}, \\\n+            \"param_env_to_generics(param_env_def_id={:?}, param_env={:?}, type_generics={:?}, \\\n              existing_predicates={:?})\",\n-            did, param_env, type_generics, existing_predicates\n+            param_env_def_id, param_env, type_generics, existing_predicates\n         );\n \n         // The `Sized` trait must be handled specially, since we only display it when\n@@ -553,7 +518,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             tcx,\n         };\n \n-        let orig_bounds: FxHashSet<_> = self.cx.tcx.param_env(did).caller_bounds.iter().collect();\n+        let orig_bounds: FxHashSet<_> =\n+            self.cx.tcx.param_env(param_env_def_id).caller_bounds.iter().collect();\n         let clean_where_predicates = param_env\n             .caller_bounds\n             .iter()\n@@ -568,7 +534,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 (replaced.clone(), replaced.clean(self.cx))\n             });\n \n-        let full_generics = (&type_generics, &tcx.explicit_predicates_of(did));\n+        let full_generics = (type_generics, &tcx.explicit_predicates_of(param_env_def_id));\n         let Generics {\n             params: mut generic_params,\n             ..\n@@ -757,10 +723,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                         .or_default()\n                                         .insert(*trait_.clone());\n                                 }\n-                                _ => panic!(\"Unexpected trait {:?} for {:?}\", trait_, did),\n+                                _ => panic!(\n+                                    \"Unexpected trait {:?} for {:?}\",\n+                                    trait_,\n+                                    param_env_def_id,\n+                                ),\n                             }\n                         }\n-                        _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, did),\n+                        _ => panic!(\"Unexpected LHS {:?} for {:?}\", lhs, param_env_def_id),\n                     }\n                 }\n             };"}, {"sha": "423cbc66e1ce45aff88434f34042ac74ed417dff", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 57, "deletions": 95, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -9,8 +9,6 @@ use crate::core::DocAccessLevels;\n \n use super::*;\n \n-use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n-\n pub struct BlanketImplFinder<'a, 'tcx> {\n     pub cx: &'a core::DocContext<'tcx>,\n }\n@@ -20,67 +18,36 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n         BlanketImplFinder { cx }\n     }\n \n-    pub fn get_with_def_id(&self, def_id: DefId) -> Vec<Item> {\n-        get_def_from_def_id(&self.cx, def_id, &|def_ctor| {\n-            self.get_blanket_impls(def_id, &def_ctor, None)\n-        })\n-    }\n-\n-    pub fn get_with_hir_id(&self, id: hir::HirId, name: String) -> Vec<Item> {\n-        get_def_from_hir_id(&self.cx, id, name, &|def_ctor, name| {\n-            let did = self.cx.tcx.hir().local_def_id_from_hir_id(id);\n-            self.get_blanket_impls(did, &def_ctor, Some(name))\n-        })\n-    }\n-\n-    pub fn get_blanket_impls<F>(\n+    // FIXME(eddyb) figure out a better way to pass information about\n+    // parametrization of `ty` than `param_env_def_id`.\n+    pub fn get_blanket_impls(\n         &self,\n-        def_id: DefId,\n-        def_ctor: &F,\n-        name: Option<String>,\n-    ) -> Vec<Item>\n-    where F: Fn(DefId) -> Def {\n-        debug!(\"get_blanket_impls(def_id={:?}, ...)\", def_id);\n+        ty: Ty<'tcx>,\n+        param_env_def_id: DefId,\n+    ) -> Vec<Item> {\n+        debug!(\"get_blanket_impls(param_env_def_id={:?}, ...)\", param_env_def_id);\n         let mut impls = Vec::new();\n-        if self.cx\n-            .tcx\n-            .get_attrs(def_id)\n-            .lists(\"doc\")\n-            .has_word(\"hidden\")\n-        {\n-            debug!(\n-                \"get_blanket_impls(def_id={:?}, def_ctor=...): item has doc('hidden'), \\\n-                 aborting\",\n-                def_id\n-            );\n-            return impls;\n-        }\n-        let ty = self.cx.tcx.type_of(def_id);\n-        let generics = self.cx.tcx.generics_of(def_id);\n-        let real_name = name.map(|name| Ident::from_str(&name));\n-        let param_env = self.cx.tcx.param_env(def_id);\n+        let param_env = self.cx.tcx.param_env(param_env_def_id);\n         for &trait_def_id in self.cx.all_traits.iter() {\n             if !self.cx.renderinfo.borrow().access_levels.is_doc_reachable(trait_def_id) ||\n                self.cx.generated_synthetics\n                       .borrow_mut()\n-                      .get(&(def_id, trait_def_id))\n+                      .get(&(param_env_def_id, trait_def_id))\n                       .is_some() {\n                 continue\n             }\n             self.cx.tcx.for_each_relevant_impl(trait_def_id, ty, |impl_def_id| {\n-                self.cx.tcx.infer_ctxt().enter(|infcx| {\n-                    debug!(\"get_blanet_impls: Considering impl for trait '{:?}' {:?}\",\n+                let trait_ref = self.cx.tcx.impl_trait_ref(impl_def_id).unwrap();\n+                let may_apply = self.cx.tcx.infer_ctxt().enter(|infcx| {\n+                    debug!(\"get_blanket_impls: Considering impl for trait '{:?}' {:?}\",\n                            trait_def_id, impl_def_id);\n-                    let t_generics = infcx.tcx.generics_of(impl_def_id);\n-                    let trait_ref = infcx.tcx.impl_trait_ref(impl_def_id)\n-                                             .expect(\"Cannot get impl trait\");\n \n                     match trait_ref.self_ty().sty {\n                         ty::Param(_) => {},\n-                        _ => return,\n+                        _ => return false,\n                     }\n \n-                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, def_id);\n+                    let substs = infcx.fresh_substs_for_item(DUMMY_SP, param_env_def_id);\n                     let ty = ty.subst(infcx.tcx, substs);\n                     let param_env = param_env.subst(infcx.tcx, substs);\n \n@@ -100,7 +67,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             \"invoking predicate_may_hold: param_env={:?}, trait_ref={:?}, ty={:?}\",\n                              param_env, trait_ref, ty\n                         );\n-                        let may_apply = match infcx.evaluate_obligation(\n+                        match infcx.evaluate_obligation(\n                             &traits::Obligation::new(\n                                 cause,\n                                 param_env,\n@@ -109,56 +76,51 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                         ) {\n                             Ok(eval_result) => eval_result.may_apply(),\n                             Err(traits::OverflowError) => true, // overflow doesn't mean yes *or* no\n-                        };\n-                        debug!(\"get_blanket_impls: found applicable impl: {}\\\n-                               for trait_ref={:?}, ty={:?}\",\n-                               may_apply, trait_ref, ty);\n-\n-                        if !may_apply {\n-                            return\n                         }\n-                        self.cx.generated_synthetics.borrow_mut()\n-                                                    .insert((def_id, trait_def_id));\n-                        let trait_ = hir::TraitRef {\n-                            path: get_path_for_type(infcx.tcx,\n-                                                    trait_def_id,\n-                                                    hir::def::Def::Trait),\n-                            hir_ref_id: hir::DUMMY_HIR_ID,\n-                        };\n-                        let provided_trait_methods =\n-                            infcx.tcx.provided_trait_methods(trait_def_id)\n-                                     .into_iter()\n-                                     .map(|meth| meth.ident.to_string())\n-                                     .collect();\n-\n-                        let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n-                        let predicates = infcx.tcx.explicit_predicates_of(impl_def_id);\n-\n-                        impls.push(Item {\n-                            source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n-                            name: None,\n-                            attrs: Default::default(),\n-                            visibility: None,\n-                            def_id: self.cx.next_def_id(impl_def_id.krate),\n-                            stability: None,\n-                            deprecation: None,\n-                            inner: ImplItem(Impl {\n-                                unsafety: hir::Unsafety::Normal,\n-                                generics: (t_generics, &predicates).clean(self.cx),\n-                                provided_trait_methods,\n-                                trait_: Some(trait_.clean(self.cx)),\n-                                for_: ty.clean(self.cx),\n-                                items: infcx.tcx.associated_items(impl_def_id)\n-                                                .collect::<Vec<_>>()\n-                                                .clean(self.cx),\n-                                polarity: None,\n-                                synthetic: false,\n-                                blanket_impl: Some(infcx.tcx.type_of(impl_def_id)\n-                                                            .clean(self.cx)),\n-                            }),\n-                        });\n+                    } else {\n+                        false\n                     }\n                 });\n+                debug!(\"get_blanket_impls: found applicable impl: {}\\\n+                        for trait_ref={:?}, ty={:?}\",\n+                        may_apply, trait_ref, ty);\n+\n+                if !may_apply {\n+                    return\n+                }\n+                self.cx.generated_synthetics.borrow_mut()\n+                                            .insert((param_env_def_id, trait_def_id));\n+                let provided_trait_methods =\n+                    self.cx.tcx.provided_trait_methods(trait_def_id)\n+                                .into_iter()\n+                                .map(|meth| meth.ident.to_string())\n+                                .collect();\n+\n+                impls.push(Item {\n+                    source: self.cx.tcx.def_span(impl_def_id).clean(self.cx),\n+                    name: None,\n+                    attrs: Default::default(),\n+                    visibility: None,\n+                    def_id: self.cx.next_def_id(impl_def_id.krate),\n+                    stability: None,\n+                    deprecation: None,\n+                    inner: ImplItem(Impl {\n+                        unsafety: hir::Unsafety::Normal,\n+                        generics: (\n+                            self.cx.tcx.generics_of(impl_def_id),\n+                            &self.cx.tcx.explicit_predicates_of(impl_def_id),\n+                        ).clean(self.cx),\n+                        provided_trait_methods,\n+                        trait_: Some(trait_ref.clean(self.cx).get_trait_type().unwrap()),\n+                        for_: ty.clean(self.cx),\n+                        items: self.cx.tcx.associated_items(impl_def_id)\n+                                        .collect::<Vec<_>>()\n+                                        .clean(self.cx),\n+                        polarity: None,\n+                        synthetic: false,\n+                        blanket_impl: Some(trait_ref.self_ty().clean(self.cx)),\n+                    }),\n+                });\n             });\n         }\n         impls"}, {"sha": "405a2e66d6e5c21dbb4d48b212a0c4d17fe33f81", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f843ad60ef5a78d8b4da85c5007d3ecac229f1a8/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f843ad60ef5a78d8b4da85c5007d3ecac229f1a8/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=f843ad60ef5a78d8b4da85c5007d3ecac229f1a8", "patch": "@@ -1,55 +0,0 @@\n-use crate::core::DocContext;\n-\n-use super::*;\n-\n-pub fn get_def_from_def_id<F>(cx: &DocContext<'_>,\n-                              def_id: DefId,\n-                              callback: &F,\n-) -> Vec<Item>\n-where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n-    let ty = cx.tcx.type_of(def_id);\n-\n-    match ty.sty {\n-        ty::Adt(adt, _) => callback(&match adt.adt_kind() {\n-            AdtKind::Struct => Def::Struct,\n-            AdtKind::Enum => Def::Enum,\n-            AdtKind::Union => Def::Union,\n-        }),\n-        ty::Int(_) |\n-        ty::Uint(_) |\n-        ty::Float(_) |\n-        ty::Str |\n-        ty::Bool |\n-        ty::Char => callback(&move |_: DefId| {\n-            match ty.sty {\n-                ty::Int(x) => Def::PrimTy(hir::Int(x)),\n-                ty::Uint(x) => Def::PrimTy(hir::Uint(x)),\n-                ty::Float(x) => Def::PrimTy(hir::Float(x)),\n-                ty::Str => Def::PrimTy(hir::Str),\n-                ty::Bool => Def::PrimTy(hir::Bool),\n-                ty::Char => Def::PrimTy(hir::Char),\n-                _ => unreachable!(),\n-            }\n-        }),\n-        _ => {\n-            debug!(\"Unexpected type {:?}\", def_id);\n-            Vec::new()\n-        }\n-    }\n-}\n-\n-pub fn get_def_from_hir_id<F>(cx: &DocContext<'_>,\n-                              id: hir::HirId,\n-                              name: String,\n-                              callback: &F,\n-) -> Vec<Item>\n-where F: Fn(& dyn Fn(DefId) -> Def, String) -> Vec<Item> {\n-    let item = &cx.tcx.hir().expect_item_by_hir_id(id).node;\n-\n-    callback(&match *item {\n-        hir::ItemKind::Struct(_, _) => Def::Struct,\n-        hir::ItemKind::Union(_, _) => Def::Union,\n-        hir::ItemKind::Enum(_, _) => Def::Enum,\n-        _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n-    }, name)\n-}"}, {"sha": "8067bdf87963dedb697c505dfd8212cffafe3db3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 155, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -8,7 +8,6 @@ pub mod cfg;\n mod simplify;\n mod auto_trait;\n mod blanket_impl;\n-pub mod def_ctor;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::sync::Lrc;\n@@ -22,8 +21,7 @@ use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::hir::{self, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::map::DisambiguatedDefPathData;\n-use rustc::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n+use rustc::ty::subst::{InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n use rustc::ty::fold::TypeFolder;\n use rustc::ty::layout::VariantIdx;\n@@ -35,7 +33,7 @@ use syntax::source_map::{dummy_spanned, Spanned};\n use syntax::ptr::P;\n use syntax::symbol::keywords::{self, Keyword};\n use syntax::symbol::InternedString;\n-use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n+use syntax_pos::{self, Pos, FileName};\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n@@ -3776,40 +3774,13 @@ pub struct Impl {\n     pub blanket_impl: Option<Type>,\n }\n \n-pub fn get_auto_traits_with_hir_id(\n-    cx: &DocContext<'_>,\n-    id: hir::HirId,\n-    name: String\n-) -> Vec<Item> {\n-    let finder = AutoTraitFinder::new(cx);\n-    finder.get_with_hir_id(id, name)\n-}\n-\n-pub fn get_auto_traits_with_def_id(\n-    cx: &DocContext<'_>,\n-    id: DefId\n-) -> Vec<Item> {\n-    let finder = AutoTraitFinder::new(cx);\n-\n-    finder.get_with_def_id(id)\n-}\n-\n-pub fn get_blanket_impls_with_hir_id(\n-    cx: &DocContext<'_>,\n-    id: hir::HirId,\n-    name: String\n-) -> Vec<Item> {\n-    let finder = BlanketImplFinder::new(cx);\n-    finder.get_with_hir_id(id, name)\n-}\n-\n-pub fn get_blanket_impls_with_def_id(\n-    cx: &DocContext<'_>,\n-    id: DefId\n-) -> Vec<Item> {\n-    let finder = BlanketImplFinder::new(cx);\n-\n-    finder.get_with_def_id(id)\n+pub fn get_auto_trait_and_blanket_impls(\n+    cx: &DocContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    param_env_def_id: DefId,\n+) -> impl Iterator<Item = Item> {\n+    AutoTraitFinder::new(cx).get_auto_trait_impls(ty, param_env_def_id).into_iter()\n+        .chain(BlanketImplFinder::new(cx).get_blanket_impls(ty, param_env_def_id))\n }\n \n impl Clean<Vec<Item>> for doctree::Impl {\n@@ -4461,125 +4432,8 @@ pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-pub fn get_path_for_type(\n-    tcx: TyCtxt<'_, '_, '_>,\n-    def_id: DefId,\n-    def_ctor: impl Fn(DefId) -> Def,\n-) -> hir::Path {\n-    use rustc::ty::print::Printer;\n-\n-    struct AbsolutePathPrinter<'a, 'tcx> {\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    }\n-\n-    impl Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n-        type Error = !;\n-\n-        type Path = Vec<String>;\n-        type Region = ();\n-        type Type = ();\n-        type DynExistential = ();\n-\n-        fn tcx(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-            self.tcx\n-        }\n-\n-        fn print_region(\n-            self,\n-            _region: ty::Region<'_>,\n-        ) -> Result<Self::Region, Self::Error> {\n-            Ok(())\n-        }\n-\n-        fn print_type(\n-            self,\n-            _ty: Ty<'tcx>,\n-        ) -> Result<Self::Type, Self::Error> {\n-            Ok(())\n-        }\n-\n-        fn print_dyn_existential(\n-            self,\n-            _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-        ) -> Result<Self::DynExistential, Self::Error> {\n-            Ok(())\n-        }\n-\n-        fn path_crate(\n-            self,\n-            cnum: CrateNum,\n-        ) -> Result<Self::Path, Self::Error> {\n-            Ok(vec![self.tcx.original_crate_name(cnum).to_string()])\n-        }\n-        fn path_qualified(\n-            self,\n-            self_ty: Ty<'tcx>,\n-            trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ) -> Result<Self::Path, Self::Error> {\n-            // This shouldn't ever be needed, but just in case:\n-            Ok(vec![match trait_ref {\n-                Some(trait_ref) => format!(\"{:?}\", trait_ref),\n-                None => format!(\"<{}>\", self_ty),\n-            }])\n-        }\n-\n-        fn path_append_impl(\n-            self,\n-            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-            _disambiguated_data: &DisambiguatedDefPathData,\n-            self_ty: Ty<'tcx>,\n-            trait_ref: Option<ty::TraitRef<'tcx>>,\n-        ) -> Result<Self::Path, Self::Error> {\n-            let mut path = print_prefix(self)?;\n-\n-            // This shouldn't ever be needed, but just in case:\n-            path.push(match trait_ref {\n-                Some(trait_ref) => {\n-                    format!(\"<impl {} for {}>\", trait_ref, self_ty)\n-                }\n-                None => format!(\"<impl {}>\", self_ty),\n-            });\n-\n-            Ok(path)\n-        }\n-        fn path_append(\n-            self,\n-            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-            disambiguated_data: &DisambiguatedDefPathData,\n-        ) -> Result<Self::Path, Self::Error> {\n-            let mut path = print_prefix(self)?;\n-            path.push(disambiguated_data.data.as_interned_str().to_string());\n-            Ok(path)\n-        }\n-        fn path_generic_args(\n-            self,\n-            print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-            _args: &[Kind<'tcx>],\n-        ) -> Result<Self::Path, Self::Error> {\n-            print_prefix(self)\n-        }\n-    }\n-\n-    let names = AbsolutePathPrinter { tcx: tcx.global_tcx() }\n-        .print_def_path(def_id, &[])\n-        .unwrap();\n-\n-    hir::Path {\n-        span: DUMMY_SP,\n-        def: def_ctor(def_id),\n-        segments: hir::HirVec::from_vec(names.iter().map(|s| hir::PathSegment {\n-            ident: ast::Ident::from_str(&s),\n-            hir_id: None,\n-            def: None,\n-            args: None,\n-            infer_types: false,\n-        }).collect())\n-    }\n-}\n-\n // End of code copied from rust-clippy\n \n-\n #[derive(Eq, PartialEq, Hash, Copy, Clone, Debug)]\n enum RegionTarget<'tcx> {\n     Region(Region<'tcx>),"}, {"sha": "99550a3db65e01a68fd3a1d6c2c5660ceb58264d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 99, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -2,10 +2,10 @@ use rustc_lint;\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n-use rustc::hir::{self, HirId, HirVec};\n+use rustc::hir::HirId;\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc::lint::{self, LintPass};\n use rustc::session::config::ErrorOutputType;\n use rustc::session::DiagnosticOutput;\n@@ -16,13 +16,9 @@ use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{self, Ident};\n use syntax::source_map;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n-use syntax::ptr::P;\n-use syntax::symbol::keywords;\n-use syntax_pos::DUMMY_SP;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n@@ -36,7 +32,7 @@ use std::rc::Rc;\n use crate::visit_ast::RustdocVisitor;\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::clean;\n-use crate::clean::{get_path_for_type, Clean, MAX_DEF_ID, AttributesExt};\n+use crate::clean::{Clean, MAX_DEF_ID, AttributesExt};\n use crate::html::render::RenderInfo;\n \n use crate::passes;\n@@ -173,98 +169,6 @@ impl<'tcx> DocContext<'tcx> {\n             self.tcx.hir().as_local_hir_id(def_id)\n         }\n     }\n-\n-    pub fn get_real_ty<F>(&self,\n-                          def_id: DefId,\n-                          def_ctor: &F,\n-                          real_name: &Option<Ident>,\n-                          generics: &ty::Generics,\n-    ) -> hir::Ty\n-    where F: Fn(DefId) -> Def {\n-        let path = get_path_for_type(self.tcx, def_id, def_ctor);\n-        let mut segments = path.segments.into_vec();\n-        let last = segments.pop().expect(\"segments were empty\");\n-\n-        segments.push(hir::PathSegment::new(\n-            real_name.unwrap_or(last.ident),\n-            None,\n-            None,\n-            self.generics_to_path_params(generics.clone()),\n-            false,\n-        ));\n-\n-        let new_path = hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: HirVec::from_vec(segments),\n-        };\n-\n-        hir::Ty {\n-            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n-    pub fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n-        let mut args = vec![];\n-\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                ty::GenericParamDefKind::Lifetime => {\n-                    let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n-                    } else {\n-                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n-                    };\n-\n-                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        hir_id: hir::DUMMY_HIR_ID,\n-                        span: DUMMY_SP,\n-                        name: hir::LifetimeName::Param(name),\n-                    }));\n-                }\n-                ty::GenericParamDefKind::Type { .. } => {\n-                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n-                }\n-                ty::GenericParamDefKind::Const => {\n-                    args.push(hir::GenericArg::Const(hir::ConstArg {\n-                        value: hir::AnonConst {\n-                            hir_id: hir::DUMMY_HIR_ID,\n-                            body: hir::BodyId {\n-                                hir_id: hir::DUMMY_HIR_ID,\n-                            }\n-                        },\n-                        span: DUMMY_SP,\n-                    }))\n-                }\n-            }\n-        }\n-\n-        hir::GenericArgs {\n-            args: HirVec::from_vec(args),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        }\n-    }\n-\n-    pub fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n-        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n-        hir::Ty {\n-            node: hir::TyKind::Path(hir::QPath::Resolved(\n-                None,\n-                P(hir::Path {\n-                    span: DUMMY_SP,\n-                    def: Def::TyParam(param.def_id),\n-                    segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n-                    ]),\n-                }),\n-            )),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n }\n \n pub trait DocAccessLevels {"}, {"sha": "8d33cd72e29aad0eab1f3a1557271f160e36f62b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -67,16 +67,14 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         if !def_id.is_local() {\n             inline::build_impl(cx, def_id, &mut new_items);\n \n-            let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n-            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n-            let mut renderinfo = cx.renderinfo.borrow_mut();\n+            // FIXME(eddyb) is this `doc(hidden)` check needed?\n+            if !cx.tcx.get_attrs(def_id).lists(\"doc\").has_word(\"hidden\") {\n+                let self_ty = cx.tcx.type_of(def_id);\n+                let impls = get_auto_trait_and_blanket_impls(cx, self_ty, def_id);\n+                let mut renderinfo = cx.renderinfo.borrow_mut();\n \n-            let new_impls: Vec<Item> = auto_impls.into_iter()\n-                .chain(blanket_impls.into_iter())\n-                .filter(|i| renderinfo.inlined.insert(i.def_id))\n-                .collect();\n-\n-            new_items.extend(new_impls);\n+                new_items.extend(impls.filter(|i| renderinfo.inlined.insert(i.def_id)));\n+            }\n         }\n     }\n \n@@ -155,14 +153,13 @@ impl<'a, 'tcx> SyntheticImplCollector<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n-            if let (Some(hir_id), Some(name)) =\n-                (self.cx.tcx.hir().as_local_hir_id(i.def_id), i.name.clone())\n-            {\n-                self.impls.extend(get_auto_traits_with_hir_id(self.cx, hir_id, name.clone()));\n-                self.impls.extend(get_blanket_impls_with_hir_id(self.cx, hir_id, name));\n-            } else {\n-                self.impls.extend(get_auto_traits_with_def_id(self.cx, i.def_id));\n-                self.impls.extend(get_blanket_impls_with_def_id(self.cx, i.def_id));\n+            // FIXME(eddyb) is this `doc(hidden)` check needed?\n+            if !self.cx.tcx.get_attrs(i.def_id).lists(\"doc\").has_word(\"hidden\") {\n+                self.impls.extend(get_auto_trait_and_blanket_impls(\n+                    self.cx,\n+                    self.cx.tcx.type_of(i.def_id),\n+                    i.def_id,\n+                ));\n             }\n         }\n "}, {"sha": "f247ee637b97548e84e97c366ba47bd3e3c86528", "filename": "src/test/rustdoc/blanket-reexport-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fblanket-reexport-item.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -1,6 +1,6 @@\n #![crate_name = \"foo\"]\n \n-// @has foo/struct.S.html '//h3[@id=\"impl-Into\"]//code' 'impl<T, U> Into for T'\n+// @has foo/struct.S.html '//h3[@id=\"impl-Into%3CU%3E\"]//code' 'impl<T, U> Into<U> for T'\n pub struct S2 {}\n mod m {\n     pub struct S {}"}, {"sha": "d96301f3ae736f35eaf5e95001d834fd3cf8b829", "filename": "src/test/rustdoc/issue-34473.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Ftest%2Frustdoc%2Fissue-34473.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Ftest%2Frustdoc%2Fissue-34473.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-34473.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -7,6 +7,5 @@ mod second {\n // @has foo/index.html\n // @!has - SomeTypeWithLongName\n // @has foo/struct.SomeType.html\n-// @!has - SomeTypeWithLongName\n // @!has foo/struct.SomeTypeWithLongName.html\n pub use second::{SomeTypeWithLongName as SomeType};"}, {"sha": "80a717718c22b607a6dc920d72cad34aa5eb4339", "filename": "src/test/rustdoc/synthetic_auto/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c835607907a6f7ed59938b591b50774872d9ac13/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c835607907a6f7ed59938b591b50774872d9ac13/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fcomplex.rs?ref=c835607907a6f7ed59938b591b50774872d9ac13", "patch": "@@ -21,7 +21,7 @@ mod foo {\n \n // @has complex/struct.NotOuter.html\n // @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<'a, T, K: \\\n-// ?Sized> Send for NotOuter<'a, T, K> where K: for<'b> Fn((&'b bool, &'a u8)) \\\n+// ?Sized> Send for Outer<'a, T, K> where K: for<'b> Fn((&'b bool, &'a u8)) \\\n // -> &'b i8, T: MyTrait<'a>, <T as MyTrait<'a>>::MyItem: Copy, 'a: 'static\"\n \n pub use foo::{Foo, Inner as NotInner, MyTrait as NotMyTrait, Outer as NotOuter};"}]}