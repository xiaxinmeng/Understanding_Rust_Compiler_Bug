{"sha": "dd94930ee3d928c4029b4d118befdd620eaf0919", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkOTQ5MzBlZTNkOTI4YzQwMjliNGQxMThiZWZkZDYyMGVhZjA5MTk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-15T18:49:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-27T13:26:23Z"}, "message": "implement function barriers", "tree": {"sha": "da8f1d82eeb23057fbbc7cab7a999d0403cc85af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8f1d82eeb23057fbbc7cab7a999d0403cc85af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd94930ee3d928c4029b4d118befdd620eaf0919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd94930ee3d928c4029b4d118befdd620eaf0919", "html_url": "https://github.com/rust-lang/rust/commit/dd94930ee3d928c4029b4d118befdd620eaf0919", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd94930ee3d928c4029b4d118befdd620eaf0919/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215ec38624818c4df9889c702fecb10c33b646ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/215ec38624818c4df9889c702fecb10c33b646ee", "html_url": "https://github.com/rust-lang/rust/commit/215ec38624818c4df9889c702fecb10c33b646ee"}], "stats": {"total": 268, "additions": 174, "deletions": 94}, "files": [{"sha": "6b851cd65b5eef14e2f6636090167137c263e442", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 90, "deletions": 52, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -62,18 +62,7 @@ pub enum BorStackItem {\n     /// when there is no `UnsafeCell`.\n     Shr,\n     /// A barrier, tracking the function it belongs to by its index on the call stack\n-    #[allow(dead_code)] // for future use\n-    FnBarrier(usize)\n-}\n-\n-impl BorStackItem {\n-    #[inline(always)]\n-    pub fn is_fn_barrier(self) -> bool {\n-        match self {\n-            BorStackItem::FnBarrier(_) => true,\n-            _ => false,\n-        }\n-    }\n+    FnBarrier(CallId)\n }\n \n /// Extra per-location state\n@@ -130,6 +119,10 @@ impl BarrierTracking {\n     pub fn end_call(&mut self, id: CallId) {\n         assert!(self.active_calls.remove(&id));\n     }\n+\n+    fn is_active(&self, id: CallId) -> bool {\n+        self.active_calls.contains(&id)\n+    }\n }\n \n /// Extra global machine state\n@@ -178,7 +171,11 @@ impl<'tcx> Stack {\n     /// going to read or write.\n     /// Returns the index of the item we matched, `None` if it was the frozen one.\n     /// `kind` indicates which kind of reference is being dereferenced.\n-    fn deref(&self, bor: Borrow, kind: RefKind) -> Result<Option<usize>, String> {\n+    fn deref(\n+        &self,\n+        bor: Borrow,\n+        kind: RefKind,\n+    ) -> Result<Option<usize>, String> {\n         // Exclude unique ref with frozen tag.\n         if let (RefKind::Unique, Borrow::Shr(Some(_))) = (kind, bor) {\n             return Err(format!(\"Encountered mutable reference with frozen tag ({:?})\", bor));\n@@ -200,7 +197,6 @@ impl<'tcx> Stack {\n         // If we got here, we have to look for our item in the stack.\n         for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match (itm, bor) {\n-                (BorStackItem::FnBarrier(_), _) => break,\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n                     // Found matching unique item.  This satisfies U3.\n                     return Ok(Some(idx))\n@@ -209,21 +205,25 @@ impl<'tcx> Stack {\n                     // Found matching shared/raw item.\n                     return Ok(Some(idx))\n                 }\n-                // Go on looking.\n+                // Go on looking.  We ignore barriers!  When an `&mut` and an `&` alias,\n+                // dereferencing the `&` is still possible (to reborrow), but doing\n+                // an access is not.\n                 _ => {}\n             }\n         }\n         // If we got here, we did not find our item.  We have to error to satisfy U3.\n-        Err(format!(\n-            \"Borrow being dereferenced ({:?}) does not exist on the stack, or is guarded by a barrier\",\n-            bor\n-        ))\n+        Err(format!(\"Borrow being dereferenced ({:?}) does not exist on the stack\", bor))\n     }\n \n     /// Perform an actual memory access using `bor`.  We do not know any types here\n     /// or whether things should be frozen, but we *do* know if this is reading\n     /// or writing.\n-    fn access(&mut self, bor: Borrow, is_write: bool) -> EvalResult<'tcx> {\n+    fn access(\n+        &mut self,\n+        bor: Borrow,\n+        is_write: bool,\n+        barrier_tracking: &BarrierTracking,\n+    ) -> EvalResult<'tcx> {\n         // Check if we can match the frozen \"item\".\n         // Not possible on writes!\n         if self.is_frozen() {\n@@ -240,7 +240,12 @@ impl<'tcx> Stack {\n         // Pop the stack until we have something matching.\n         while let Some(&itm) = self.borrows.last() {\n             match (itm, bor) {\n-                (BorStackItem::FnBarrier(_), _) => break,\n+                (BorStackItem::FnBarrier(call), _) if barrier_tracking.is_active(call) => {\n+                    return err!(MachineError(format!(\n+                        \"Stopping looking for borrow being accessed ({:?}) because of barrier ({})\",\n+                        bor, call\n+                    )))\n+                }\n                 (BorStackItem::Uniq(itm_t), Borrow::Uniq(bor_t)) if itm_t == bor_t => {\n                     // Found matching unique item.\n                     return Ok(())\n@@ -265,7 +270,7 @@ impl<'tcx> Stack {\n         }\n         // If we got here, we did not find our item.\n         err!(MachineError(format!(\n-            \"Borrow being accessed ({:?}) does not exist on the stack, or is guarded by a barrier\",\n+            \"Borrow being accessed ({:?}) does not exist on the stack\",\n             bor\n         )))\n     }\n@@ -275,18 +280,21 @@ impl<'tcx> Stack {\n     /// is met: We cannot push `Uniq` onto frozen stacks.\n     /// `kind` indicates which kind of reference is being created.\n     fn create(&mut self, bor: Borrow, kind: RefKind) {\n-        // First, push the item.  We do this even if we will later freeze, because we\n-        // will allow mutation of shared data at the expense of unfreezing.\n         if self.frozen_since.is_some() {\n-            // A frozen location, this should be impossible!\n-            bug!(\"We should never try pushing to a frozen stack\");\n+            // A frozen location?  Possible if we create a barrier, then push again.\n+            assert!(bor.is_shared(), \"We should never try creating a unique borrow for a frozen stack\");\n+            trace!(\"create: Not doing anything on frozen location\");\n+            return;\n         }\n-        // First, push.\n+        // First, push.  We do this even if we will later freeze, because we\n+        // will allow mutation of shared data at the expense of unfreezing.\n         let itm = match bor {\n             Borrow::Uniq(t) => BorStackItem::Uniq(t),\n             Borrow::Shr(_) => BorStackItem::Shr,\n         };\n         if *self.borrows.last().unwrap() == itm {\n+            // This is just an optimization, no functional change: Avoid stacking\n+            // multiple `Shr` on top of each other.\n             assert!(bor.is_shared());\n             trace!(\"create: Sharing a shared location is a NOP\");\n         } else {\n@@ -304,6 +312,21 @@ impl<'tcx> Stack {\n             self.frozen_since = Some(bor_t);\n         }\n     }\n+\n+    /// Add a barrier\n+    fn barrier(&mut self, call: CallId) {\n+        let itm = BorStackItem::FnBarrier(call);\n+        if *self.borrows.last().unwrap() == itm {\n+            // This is just an optimization, no functional change: Avoid stacking\n+            // multiple identical barriers on top of each other.\n+            // This can happen when a function receives several shared references\n+            // that overlap.\n+            trace!(\"barrier: Avoiding redundant extra barrier\");\n+        } else {\n+            trace!(\"barrier: Pushing barrier for call {}\", call);\n+            self.borrows.push(itm);\n+        }\n+    }\n }\n \n /// Higher-level per-location operations: deref, access, reborrow.\n@@ -330,6 +353,7 @@ impl<'tcx> Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n         is_write: bool,\n+        barrier_tracking: &BarrierTracking,\n     ) -> EvalResult<'tcx> {\n         trace!(\"{} access of tag {:?}: {:?}, size {}\",\n             if is_write { \"read\" } else { \"write\" },\n@@ -339,7 +363,7 @@ impl<'tcx> Stacks {\n         // are no accesses through other references, not even reads.\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            stack.access(ptr.tag, is_write)?;\n+            stack.access(ptr.tag, is_write, barrier_tracking)?;\n         }\n         Ok(())\n     }\n@@ -350,12 +374,19 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Borrow>,\n         size: Size,\n+        mut barrier: Option<CallId>,\n         new_bor: Borrow,\n         new_kind: RefKind,\n+        barrier_tracking: &BarrierTracking,\n     ) -> EvalResult<'tcx> {\n         assert_eq!(new_bor.is_unique(), new_kind == RefKind::Unique);\n         trace!(\"reborrow for tag {:?} to {:?} as {:?}: {:?}, size {}\",\n             ptr.tag, new_bor, new_kind, ptr, size.bytes());\n+        if new_kind == RefKind::Raw {\n+            // No barrier for raw, including `&UnsafeCell`.  They can rightfully\n+            // alias with `&mut`.\n+            barrier = None;\n+        }\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n             // Access source `ptr`, create new ref.\n@@ -364,21 +395,25 @@ impl<'tcx> Stacks {\n             // the stack than the one we come from, just use that.\n             // IOW, we check if `new_bor` *already* is \"derived from\" `ptr.tag`.\n             // This also checks frozenness, if required.\n-            let bor_redundant = match (ptr_idx, stack.deref(new_bor, new_kind)) {\n-                // If the new borrow works with the frozen item, or else if it lives\n-                // above the old one in the stack, our job here is done.\n-                (_, Ok(None)) => true,\n-                (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => true,\n-                // Otherwise we need to create a new borrow.\n-                _ => false,\n-            };\n+            let bor_redundant = barrier.is_none() &&\n+                match (ptr_idx, stack.deref(new_bor, new_kind)) {\n+                    // If the new borrow works with the frozen item, or else if it lives\n+                    // above the old one in the stack, our job here is done.\n+                    (_, Ok(None)) => true,\n+                    (Some(ptr_idx), Ok(Some(new_idx))) if new_idx >= ptr_idx => true,\n+                    // Otherwise we need to create a new borrow.\n+                    _ => false,\n+                };\n             if bor_redundant {\n                 assert!(new_bor.is_shared(), \"A unique reborrow can never be redundant\");\n                 trace!(\"reborrow is redundant\");\n                 continue;\n             }\n             // We need to do some actual work.\n-            stack.access(ptr.tag, new_kind == RefKind::Unique)?;\n+            stack.access(ptr.tag, new_kind == RefKind::Unique, barrier_tracking)?;\n+            if let Some(call) = barrier {\n+                stack.barrier(call);\n+            }\n             stack.create(new_bor, new_kind);\n         }\n         Ok(())\n@@ -405,7 +440,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, /*is_write*/false)\n+        alloc.extra.access(ptr, size, /*is_write*/false, &*alloc.extra.barrier_tracking.borrow())\n     }\n \n     #[inline(always)]\n@@ -414,7 +449,7 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        alloc.extra.access(ptr, size, /*is_write*/true)\n+        alloc.extra.access(ptr, size, /*is_write*/true, &*alloc.extra.barrier_tracking.borrow())\n     }\n \n     #[inline(always)]\n@@ -424,19 +459,18 @@ impl AllocationExtra<Borrow, MemoryState> for Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         // This is like mutating\n-        alloc.extra.access(ptr, size, /*is_write*/true)\n+        alloc.extra.access(ptr, size, /*is_write*/true, &*alloc.extra.barrier_tracking.borrow())\n         // FIXME: Error out of there are any barriers?\n     }\n }\n \n impl<'tcx> Stacks {\n     /// Pushes the first item to the stacks.\n-    pub fn first_item(\n+    pub(crate) fn first_item(\n         &mut self,\n         itm: BorStackItem,\n         size: Size\n     ) {\n-        assert!(!itm.is_fn_barrier());\n         for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n             assert!(stack.borrows.len() == 1);\n             assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Shr);\n@@ -466,6 +500,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n+        fn_barrier: bool,\n         new_bor: Borrow\n     ) -> EvalResult<'tcx, Pointer<Borrow>>;\n \n@@ -474,6 +509,7 @@ pub trait EvalContextExt<'tcx> {\n         &mut self,\n         ptr: ImmTy<'tcx, Borrow>,\n         mutbl: Mutability,\n+        fn_barrier: bool,\n     ) -> EvalResult<'tcx, Immediate<Borrow>>;\n \n     fn retag(\n@@ -566,18 +602,20 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        self.reborrow(place, size, Borrow::default())?;\n+        self.reborrow(place, size, /*fn_barrier*/ false, Borrow::default())?;\n         Ok(())\n     }\n \n     fn reborrow(\n         &mut self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n+        fn_barrier: bool,\n         new_bor: Borrow\n     ) -> EvalResult<'tcx, Pointer<Borrow>> {\n         let ptr = place.ptr.to_ptr()?;\n         let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n+        let barrier = if fn_barrier { Some(self.frame().extra) } else { None };\n         trace!(\"reborrow: Creating new reference for {:?} (pointee {}): {:?}\",\n             ptr, place.layout.ty, new_bor);\n \n@@ -589,12 +627,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n             self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                 let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n-                alloc.extra.reborrow(cur_ptr, size, new_bor, kind)\n+                alloc.extra.reborrow(cur_ptr, size, barrier, new_bor, kind, &*self.memory().extra.borrow())\n             })?;\n         } else {\n             // Just treat this as one big chunk.\n             let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n-            alloc.extra.reborrow(ptr, size, new_bor, kind)?;\n+            alloc.extra.reborrow(ptr, size, barrier, new_bor, kind, &*self.memory().extra.borrow())?;\n         }\n         Ok(new_ptr)\n     }\n@@ -603,6 +641,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         &mut self,\n         val: ImmTy<'tcx, Borrow>,\n         mutbl: Mutability,\n+        fn_barrier: bool,\n     ) -> EvalResult<'tcx, Immediate<Borrow>> {\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = self.ref_to_mplace(val)?;\n@@ -622,7 +661,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         };\n \n         // Reborrow.\n-        let new_ptr = self.reborrow(place, size, new_bor)?;\n+        let new_ptr = self.reborrow(place, size, fn_barrier, new_bor)?;\n \n         // Return new ptr\n         let new_place = MemPlace { ptr: Scalar::Ptr(new_ptr), ..*place };\n@@ -631,11 +670,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n \n     fn retag(\n         &mut self,\n-        _fn_entry: bool,\n+        fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx> {\n-        // TODO: Honor `fn_entry`.\n-\n         // We need a visitor to visit all references.  However, that requires\n         // a `MemPlace`, so we have a fast path for reference types that\n         // avoids allocating.\n@@ -648,18 +685,19 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         } {\n             // fast path\n             let val = self.read_immediate(self.place_to_op(place)?)?;\n-            let val = self.retag_reference(val, mutbl)?;\n+            let val = self.retag_reference(val, mutbl, fn_entry)?;\n             self.write_immediate(val, place)?;\n             return Ok(());\n         }\n         let place = self.force_allocation(place)?;\n \n-        let mut visitor = RetagVisitor { ecx: self };\n+        let mut visitor = RetagVisitor { ecx: self, fn_entry };\n         visitor.visit_value(place)?;\n \n         // The actual visitor\n         struct RetagVisitor<'ecx, 'a, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'a, 'mir, 'tcx>,\n+            fn_entry: bool,\n         }\n         impl<'ecx, 'a, 'mir, 'tcx>\n             MutValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n@@ -684,7 +722,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n                     _ => return Ok(()), // nothing to do\n                 };\n                 let val = self.ecx.read_immediate(place.into())?;\n-                let val = self.ecx.retag_reference(val, mutbl)?;\n+                let val = self.ecx.retag_reference(val, mutbl, self.fn_entry)?;\n                 self.ecx.write_immediate(val, place.into())?;\n                 Ok(())\n             }"}, {"sha": "b82901985b781743b94b655e664c629cc781d734", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut1.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut1.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -1,12 +1,17 @@\n-// ignore-test validation_op is disabled\n-\n #![allow(unused_variables)]\n \n-mod safe {\n-    pub fn safe(x: &mut i32, y: &mut i32) {} //~ ERROR: in conflict with lock WriteLock\n-}\n+use std::mem;\n+\n+pub fn safe(x: &mut i32, y: &mut i32) {} //~ ERROR barrier\n \n fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&mut *x, &mut *x) };\n+    let mut x = 0;\n+    let xraw: *mut i32 = unsafe { mem::transmute(&mut x) };\n+    // We need to apply some tricky to be able to call `safe` with two mutable references\n+    // with the same tag: We transmute both the fn ptr (to take raw ptrs) and the argument\n+    // (to be raw, but still have the unique tag).\n+    let safe_raw: fn(x: *mut i32, y: *mut i32) = unsafe {\n+        mem::transmute::<fn(&mut i32, &mut i32), _>(safe)\n+    };\n+    safe_raw(xraw, xraw);\n }"}, {"sha": "69caddfa8c389055e65ebfede9bb8edfd4b09674", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut2.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut2.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -1,12 +1,17 @@\n-// ignore-test validation_op is disabled\n-\n #![allow(unused_variables)]\n \n-mod safe {\n-    pub fn safe(x: &i32, y: &mut i32) {} //~ ERROR: in conflict with lock ReadLock\n-}\n+use std::mem;\n+\n+pub fn safe(x: &i32, y: &mut i32) {} //~ ERROR barrier\n \n fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&*x, &mut *x) };\n+    let mut x = 0;\n+    let xref = &mut x;\n+    let xraw: *mut i32 = unsafe { mem::transmute_copy(&xref) };\n+    let xshr = &*xref;\n+    // transmute fn ptr around so that we can avoid retagging\n+    let safe_raw: fn(x: *const i32, y: *mut i32) = unsafe {\n+        mem::transmute::<fn(&i32, &mut i32), _>(safe)\n+    };\n+    safe_raw(xshr, xraw);\n }"}, {"sha": "d37f9e63f60d90a16bf719ba127edf65899990f3", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut3.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut3.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -1,12 +1,17 @@\n-// ignore-test validation_op is disabled\n-\n #![allow(unused_variables)]\n \n-mod safe {\n-    pub fn safe(x: &mut i32, y: &i32) {} //~ ERROR: in conflict with lock WriteLock\n-}\n+use std::mem;\n+\n+pub fn safe(x: &mut i32, y: &i32) {} //~ ERROR does not exist on the stack\n \n fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&mut *x, &*x) };\n+    let mut x = 0;\n+    let xref = &mut x;\n+    let xraw: *mut i32 = unsafe { mem::transmute_copy(&xref) };\n+    let xshr = &*xref;\n+    // transmute fn ptr around so that we can avoid retagging\n+    let safe_raw: fn(x: *mut i32, y: *const i32) = unsafe {\n+        mem::transmute::<fn(&mut i32, &i32), _>(safe)\n+    };\n+    safe_raw(xraw, xshr);\n }"}, {"sha": "bf65d6e230358c28b2ca48266b1e8174645c16c1", "filename": "tests/compile-fail-fullmir/stacked_borrows/aliasing_mut4.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Faliasing_mut4.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -1,15 +1,19 @@\n-// ignore-test validation_op is disabled\n-\n #![allow(unused_variables)]\n \n-mod safe {\n-    use std::cell::Cell;\n+use std::mem;\n+use std::cell::Cell;\n \n-    // Make sure &mut UnsafeCell also has a lock to it\n-    pub fn safe(x: &mut Cell<i32>, y: &i32) {} //~ ERROR: in conflict with lock WriteLock\n-}\n+// Make sure &mut UnsafeCell also is exclusive\n+pub fn safe(x: &i32, y: &mut Cell<i32>) {} //~ ERROR barrier\n \n fn main() {\n-    let x = &mut 0 as *mut _;\n-    unsafe { safe::safe(&mut *(x as *mut _), &*x) };\n+    let mut x = 0;\n+    let xref = &mut x;\n+    let xraw: *mut i32 = unsafe { mem::transmute_copy(&xref) };\n+    let xshr = &*xref;\n+    // transmute fn ptr around so that we can avoid retagging\n+    let safe_raw: fn(x: *const i32, y: *mut Cell<i32>) = unsafe {\n+        mem::transmute::<fn(&i32, &mut Cell<i32>), _>(safe)\n+    };\n+    safe_raw(xshr, xraw as *mut _);\n }"}, {"sha": "e8a182779adec2e9152e4cfef98211a93280511f", "filename": "tests/compile-fail-fullmir/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -8,7 +8,7 @@ fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n   unknown_code_2();\n \n   // We know this will return 5\n-  *our //~ ERROR does not exist on the stack\n+  *our\n }\n \n // Now comes the evil context\n@@ -21,7 +21,7 @@ fn unknown_code_1(x: &i32) { unsafe {\n } }\n \n fn unknown_code_2() { unsafe {\n-    *LEAK = 7;\n+    *LEAK = 7; //~ ERROR barrier\n } }\n \n fn main() {"}, {"sha": "d0a23cb44489ae8ec4511c5f709cdc49371dd791", "filename": "tests/compile-fail-fullmir/stacked_borrows/illegal_write1.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fillegal_write1.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -1,12 +1,9 @@\n-fn evil(x: &u32) {\n-    // mutating shared ref without `UnsafeCell`\n-    let x : *mut u32 = x as *const _ as *mut _;\n-    unsafe { *x = 42; }\n-}\n-\n fn main() {\n     let target = Box::new(42); // has an implicit raw\n-    let ref_ = &*target;\n-    evil(ref_); // invalidates shared ref, activates raw\n-    let _x = *ref_; //~ ERROR is not frozen\n+    let xref = &*target;\n+    {\n+        let x : *mut u32 = xref as *const _ as *mut _;\n+        unsafe { *x = 42; } // invalidates shared ref, activates raw\n+    }\n+    let _x = *xref; //~ ERROR is not frozen\n }"}, {"sha": "fc0dbb9e13133e8d299af04ae672d24e26ec2e96", "filename": "tests/compile-fail-fullmir/stacked_borrows/invalidate_against_barrier1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Finvalidate_against_barrier1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Finvalidate_against_barrier1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Finvalidate_against_barrier1.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -0,0 +1,13 @@\n+fn inner(x: *mut i32, _y: &mut i32) {\n+    // If `x` and `y` alias, retagging is fine with this... but we really\n+    // shouldn't be allowed to use `x` at all because `y` was assumed to be\n+    // unique for the duration of this call.\n+    let _val = unsafe { *x }; //~ ERROR barrier\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &mut *xraw };\n+    inner(xraw, xref);\n+}"}, {"sha": "a080c0958e4006dd382d9b47fdaab155ccb49ff0", "filename": "tests/compile-fail-fullmir/stacked_borrows/invalidate_against_barrier2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Finvalidate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Finvalidate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Finvalidate_against_barrier2.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -0,0 +1,13 @@\n+fn inner(x: *mut i32, _y: &i32) {\n+    // If `x` and `y` alias, retagging is fine with this... but we really\n+    // shouldn't be allowed to write to `x` at all because `y` was assumed to be\n+    // immutable for the duration of this call.\n+    unsafe { *x = 0 }; //~ ERROR barrier\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let xraw = &mut x as *mut _;\n+    let xref = unsafe { &*xraw };\n+    inner(xraw, xref);\n+}"}, {"sha": "3fe6b6567423c80f9fd706c11f4469660c67254f", "filename": "tests/compile-fail-fullmir/stacked_borrows/mut_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd94930ee3d928c4029b4d118befdd620eaf0919/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs?ref=dd94930ee3d928c4029b4d118befdd620eaf0919", "patch": "@@ -21,7 +21,7 @@ fn unknown_code_1(x: &i32) { unsafe {\n } }\n \n fn unknown_code_2() { unsafe {\n-    *LEAK = 7; //~ ERROR does not exist on the stack\n+    *LEAK = 7; //~ ERROR barrier\n } }\n \n fn main() {"}]}