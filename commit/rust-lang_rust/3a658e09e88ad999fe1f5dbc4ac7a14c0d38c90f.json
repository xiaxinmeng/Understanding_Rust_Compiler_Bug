{"sha": "3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNjU4ZTA5ZTg4YWQ5OTlmZTFmNWRiYzRhYzdhMTRjMGQzOGM5MGY=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-01-12T07:28:42Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-01-12T07:28:42Z"}, "message": "rustup (i128)", "tree": {"sha": "1dc6a5984ca7c19abb37190a5c5e41f0b43baa74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dc6a5984ca7c19abb37190a5c5e41f0b43baa74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYdzAqAAoJEFbW7qD8Z6xGLLkP/0KmtVqbF9BpAH3YzfVQc4TX\nfzOmzkAYiMdGaL/2xMQeqr9xngTrWy3eXTKUybYvgNKG9f0xvD8fbNVNvmmDcxC7\nx1G9rR2ao4LjEIAzvk5z67UAUomP+RTy+DO28hceNYIxo45SUlKaK0ixjvtAVRHZ\nVr7dIksub6TTHTrJMZgKN5SfrZi4N3McazSNt8DrjMSJORlfAwf7ZqGmJSGhzCGg\nLtf1ICwAWN2ZZEYCkvq1sEcuPmzDa15+Y7HDNj8yZxb7jJoA2NgGWXEK+CZg/ZJQ\nwsq9hTc/1HOX0jA6gXFXJ8IeVP5ZSyuEywqu4s1q3zy4geJJ1f0AZuiIlX+hc4o2\nPqgWOvmSvEAHcQ0O53s44FkrYolHV8Zgo83r1GdkDQG4OavC0pwgbNKER+jaT0Av\nxfKO7h3BniIbmfpIbqQ0GlrnVYZzFYwWag24rtqGsraf/K7wSV7e9cSstlYeFtx8\nh9jyeDe5xfRGQXsLdBTmtgczXQZJ7hrqcVpIeUPN+KxckSuC0K66t5JvBjIQ0Pn/\nNbeu0fQ97s2vW6giwKe7u4Eg8tYUMKACPToFsPC60oh3tNbGxzsKRU7DzanNqImn\n3fidjjaSjlWEMW+Ti3Qrt15qpQ3mcx9j4jM3bEpZQo+Fr56lARUmx6ZR9CL++wND\nYvOMzKLAavGNP1Z75I7W\n=cmAP\n-----END PGP SIGNATURE-----", "payload": "tree 1dc6a5984ca7c19abb37190a5c5e41f0b43baa74\nparent d6e35fe46fbb170c882277cff3532caec04e4940\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1484206122 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1484206122 +0100\n\nrustup (i128)"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "html_url": "https://github.com/rust-lang/rust/commit/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6e35fe46fbb170c882277cff3532caec04e4940", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6e35fe46fbb170c882277cff3532caec04e4940", "html_url": "https://github.com/rust-lang/rust/commit/d6e35fe46fbb170c882277cff3532caec04e4940"}], "stats": {"total": 347, "additions": 196, "deletions": 151}, "files": [{"sha": "a51553a8c5e2255673d3107c7698c0fd06845e42", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -3,3 +3,4 @@\n tex/*/out\n *.dot\n *.mir\n+*.rs.bk"}, {"sha": "94611529c5d139b168e82d2e9aef754ff5e8eabb", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -2,7 +2,7 @@\n name = \"miri\"\n version = \"0.1.0\"\n dependencies = [\n- \"byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"byteorder 1.0.0 (git+https://github.com/quininer/byteorder.git?branch=i128)\",\n  \"compiletest_rs 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -19,8 +19,8 @@ dependencies = [\n \n [[package]]\n name = \"byteorder\"\n-version = \"0.4.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+version = \"1.0.0\"\n+source = \"git+https://github.com/quininer/byteorder.git?branch=i128#ef51df297aa833d0b6639aae328a95597fc07d75\"\n \n [[package]]\n name = \"compiletest_rs\"\n@@ -136,7 +136,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n \"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n-\"checksum byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"96c8b41881888cc08af32d47ac4edd52bc7fa27fef774be47a92443756451304\"\n+\"checksum byteorder 1.0.0 (git+https://github.com/quininer/byteorder.git?branch=i128)\" = \"<none>\"\n \"checksum compiletest_rs 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f3f344389765ad7bec166f64c1b39ed6dd2b54d81c4c5dd8af789169351d380c\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\""}, {"sha": "ada46a794cb5967fafc3102967a70e80f1100d92", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -15,7 +15,8 @@ test = false\n test = false\n \n [dependencies]\n-byteorder = \"0.4.2\"\n+#byteorder = \"0.4.2\"\n+byteorder = { git = \"https://github.com/quininer/byteorder.git\", branch = \"i128\", features = [\"i128\"]}\n env_logger = \"0.3.3\"\n log = \"0.3.6\"\n log_settings = \"0.1.1\""}, {"sha": "379f25ef7576a1c327c030717a92ded072d7fb61", "filename": "src/bin/miri.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private)]\n+#![feature(rustc_private, i128_type)]\n \n extern crate getopts;\n extern crate miri;\n@@ -51,7 +51,7 @@ fn resource_limits_from_attributes(state: &CompileState) -> miri::ResourceLimits\n     let mut limits = miri::ResourceLimits::default();\n     let krate = state.hir_crate.as_ref().unwrap();\n     let err_msg = \"miri attributes need to be in the form `miri(key = value)`\";\n-    let extract_int = |lit: &syntax::ast::Lit| -> u64 {\n+    let extract_int = |lit: &syntax::ast::Lit| -> u128 {\n         match lit.node {\n             syntax::ast::LitKind::Int(i, _) => i,\n             _ => state.session.span_fatal(lit.span, \"expected an integer literal\"),\n@@ -64,8 +64,8 @@ fn resource_limits_from_attributes(state: &CompileState) -> miri::ResourceLimits\n                 if let NestedMetaItemKind::MetaItem(ref inner) = item.node {\n                     if let MetaItemKind::NameValue(ref value) = inner.node {\n                         match &inner.name().as_str()[..] {\n-                            \"memory_size\" => limits.memory_size = extract_int(value),\n-                            \"step_limit\" => limits.step_limit = extract_int(value),\n+                            \"memory_size\" => limits.memory_size = extract_int(value) as u64,\n+                            \"step_limit\" => limits.step_limit = extract_int(value) as u64,\n                             \"stack_limit\" => limits.stack_limit = extract_int(value) as usize,\n                             _ => state.session.span_err(item.span, \"unknown miri attribute\"),\n                         }"}, {"sha": "413c9b6ba827b54f4ab713636f0bddac606c4f8b", "filename": "src/cast.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -20,34 +20,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             F32 => self.cast_float(val.to_f32()? as f64, dest_ty),\n             F64 => self.cast_float(val.to_f64()?, dest_ty),\n \n-            I8 | I16 | I32 | I64 => self.cast_signed_int(val.to_i64()?, dest_ty),\n+            I8 | I16 | I32 | I64 | I128 => self.cast_signed_int(val.to_i128()?, dest_ty),\n \n-            Bool | Char | U8 | U16 | U32 | U64 => self.cast_int(val.to_u64()?, dest_ty, false),\n+            Bool | Char | U8 | U16 | U32 | U64 | U128 => self.cast_int(val.to_u128()?, dest_ty, false),\n \n             FnPtr | Ptr => self.cast_ptr(val.to_ptr()?, dest_ty),\n         }\n     }\n \n-    fn cast_signed_int(&self, val: i64, ty: ty::Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n-        self.cast_int(val as u64, ty, val < 0)\n+    fn cast_signed_int(&self, val: i128, ty: ty::Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+        self.cast_int(val as u128, ty, val < 0)\n     }\n \n-    fn cast_int(&self, v: u64, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n+    fn cast_int(&self, v: u128, ty: ty::Ty<'tcx>, negative: bool) -> EvalResult<'tcx, PrimVal> {\n         use rustc::ty::TypeVariants::*;\n         match ty.sty {\n             TyBool if v == 0 => Ok(PrimVal::from_bool(false)),\n             TyBool if v == 1 => Ok(PrimVal::from_bool(true)),\n             TyBool => Err(EvalError::InvalidBool),\n \n-            TyInt(IntTy::I8)  => Ok(PrimVal::Bytes(v as i64 as i8  as u64)),\n-            TyInt(IntTy::I16) => Ok(PrimVal::Bytes(v as i64 as i16 as u64)),\n-            TyInt(IntTy::I32) => Ok(PrimVal::Bytes(v as i64 as i32 as u64)),\n-            TyInt(IntTy::I64) => Ok(PrimVal::Bytes(v as i64 as i64 as u64)),\n+            TyInt(IntTy::I8)  => Ok(PrimVal::Bytes(v as i128 as i8  as u128)),\n+            TyInt(IntTy::I16) => Ok(PrimVal::Bytes(v as i128 as i16 as u128)),\n+            TyInt(IntTy::I32) => Ok(PrimVal::Bytes(v as i128 as i32 as u128)),\n+            TyInt(IntTy::I64) => Ok(PrimVal::Bytes(v as i128 as i64 as u128)),\n+            TyInt(IntTy::I128) => Ok(PrimVal::Bytes(v as u128)),\n \n-            TyUint(UintTy::U8)  => Ok(PrimVal::Bytes(v as u8  as u64)),\n-            TyUint(UintTy::U16) => Ok(PrimVal::Bytes(v as u16 as u64)),\n-            TyUint(UintTy::U32) => Ok(PrimVal::Bytes(v as u32 as u64)),\n-            TyUint(UintTy::U64) => Ok(PrimVal::Bytes(v)),\n+            TyUint(UintTy::U8)  => Ok(PrimVal::Bytes(v as u8  as u128)),\n+            TyUint(UintTy::U16) => Ok(PrimVal::Bytes(v as u16 as u128)),\n+            TyUint(UintTy::U32) => Ok(PrimVal::Bytes(v as u32 as u128)),\n+            TyUint(UintTy::U64) => Ok(PrimVal::Bytes(v as u64 as u128)),\n+            TyUint(UintTy::U128) => Ok(PrimVal::Bytes(v)),\n \n             TyInt(IntTy::Is) => {\n                 let int_ty = self.tcx.sess.target.int_type;\n@@ -61,15 +63,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.cast_int(v, ty, negative)\n             }\n \n-            TyFloat(FloatTy::F64) if negative => Ok(PrimVal::from_f64(v as i64 as f64)),\n+            TyFloat(FloatTy::F64) if negative => Ok(PrimVal::from_f64(v as i128 as f64)),\n             TyFloat(FloatTy::F64)             => Ok(PrimVal::from_f64(v as f64)),\n-            TyFloat(FloatTy::F32) if negative => Ok(PrimVal::from_f32(v as i64 as f32)),\n+            TyFloat(FloatTy::F32) if negative => Ok(PrimVal::from_f32(v as i128 as f32)),\n             TyFloat(FloatTy::F32)             => Ok(PrimVal::from_f32(v as f32)),\n \n-            TyChar if v as u8 as u64 == v => Ok(PrimVal::Bytes(v)),\n+            TyChar if v as u8 as u128 == v => Ok(PrimVal::Bytes(v)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n-            TyRawPtr(_) => Ok(PrimVal::Ptr(Pointer::from_int(v))),\n+            TyRawPtr(_) => Ok(PrimVal::Ptr(Pointer::from_int(v as u64))),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }\n@@ -80,9 +82,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match ty.sty {\n             // Casting negative floats to unsigned integers yields zero.\n             TyUint(_) if val < 0.0 => self.cast_int(0, ty, false),\n-            TyInt(_)  if val < 0.0 => self.cast_int(val as i64 as u64, ty, true),\n+            TyInt(_)  if val < 0.0 => self.cast_int(val as i128 as u128, ty, true),\n \n-            TyInt(_) | ty::TyUint(_) => self.cast_int(val as u64, ty, false),\n+            TyInt(_) | ty::TyUint(_) => self.cast_int(val as u128, ty, false),\n \n             TyFloat(FloatTy::F64) => Ok(PrimVal::from_f64(val)),\n             TyFloat(FloatTy::F32) => Ok(PrimVal::from_f32(val as f32)),"}, {"sha": "bf01ae27d2a280a2d3d57db6bb0ab0691feef622", "filename": "src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -31,7 +31,7 @@ pub enum EvalError<'tcx> {\n     ExecuteMemory,\n     ArrayIndexOutOfBounds(Span, u64, u64),\n     Math(Span, ConstMathErr),\n-    InvalidChar(u64),\n+    InvalidChar(u128),\n     OutOfMemory {\n         allocation_size: u64,\n         memory_size: u64,"}, {"sha": "7a0264665e52370f02fbaaf4abec7246a9d0d80a", "filename": "src/eval_context.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -169,15 +169,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u64(s.len() as u64)))\n+        Ok(Value::ByValPair(PrimVal::Ptr(ptr), PrimVal::from_u128(s.len() as u128)))\n     }\n \n     pub(super) fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::ConstFloat;\n \n         let primval = match *const_val {\n-            Integral(const_int) => PrimVal::Bytes(const_int.to_u64_unchecked()),\n+            Integral(const_int) => PrimVal::Bytes(const_int.to_u128_unchecked()),\n \n             Float(ConstFloat::F32(f)) => PrimVal::from_f32(f),\n             Float(ConstFloat::F64(f)) => PrimVal::from_f64(f),\n@@ -429,7 +429,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     General { discr, ref variants, .. } => {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n-                            let discr_val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n+                            let discr_val = adt_def.variants[variant].disr_val.to_u128_unchecked();\n                             let discr_size = discr.size().bytes();\n                             let discr_offset = variants[variant].offsets[0].bytes();\n \n@@ -497,7 +497,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     CEnum { .. } => {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n-                            let n = adt_def.variants[variant].disr_val.to_u64_unchecked();\n+                            let n = adt_def.variants[variant].disr_val.to_u128_unchecked();\n                             self.write_primval(dest, PrimVal::Bytes(n), dest_ty)?;\n                         } else {\n                             bug!(\"tried to assign {:?} to Layout::CEnum\", kind);\n@@ -556,7 +556,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n                 let (_, len) = src.elem_ty_and_len(ty);\n-                self.write_primval(dest, PrimVal::from_u64(len), dest_ty)?;\n+                self.write_primval(dest, PrimVal::from_u128(len as u128), dest_ty)?;\n             }\n \n             Ref(_, _, ref lvalue) => {\n@@ -566,7 +566,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let val = match extra {\n                     LvalueExtra::None => Value::ByVal(ptr),\n-                    LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_u64(len)),\n+                    LvalueExtra::Length(len) => Value::ByValPair(ptr, PrimVal::from_u128(len as u128)),\n                     LvalueExtra::Vtable(vtable) => Value::ByValPair(ptr, PrimVal::Ptr(vtable)),\n                     LvalueExtra::DowncastVariant(..) =>\n                         bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n@@ -1028,6 +1028,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     I16 => 2,\n                     I32 => 4,\n                     I64 => 8,\n+                    I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n                 PrimValKind::from_int_size(size)\n@@ -1040,6 +1041,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     U16 => 2,\n                     U32 => 4,\n                     U64 => 8,\n+                    U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n                 PrimValKind::from_uint_size(size)\n@@ -1092,7 +1094,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyBool if val.to_bytes()? > 1 => Err(EvalError::InvalidBool),\n \n             ty::TyChar if ::std::char::from_u32(val.to_bytes()? as u32).is_none()\n-                => Err(EvalError::InvalidChar(val.to_bytes()? as u32 as u64)),\n+                => Err(EvalError::InvalidChar(val.to_bytes()? as u32 as u128)),\n \n             _ => Ok(()),\n         }\n@@ -1115,7 +1117,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let c = self.memory.read_uint(ptr, 4)? as u32;\n                 match ::std::char::from_u32(c) {\n                     Some(ch) => PrimVal::from_char(ch),\n-                    None => return Err(EvalError::InvalidChar(c as u64)),\n+                    None => return Err(EvalError::InvalidChar(c as u128)),\n                 }\n             }\n \n@@ -1126,9 +1128,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     I16 => 2,\n                     I32 => 4,\n                     I64 => 8,\n+                    I128 => 16,\n                     Is => self.memory.pointer_size(),\n                 };\n-                PrimVal::from_i64(self.memory.read_int(ptr, size)?)\n+                PrimVal::from_i128(self.memory.read_int(ptr, size)?)\n             }\n \n             ty::TyUint(uint_ty) => {\n@@ -1138,9 +1141,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     U16 => 2,\n                     U32 => 4,\n                     U64 => 8,\n+                    U128 => 16,\n                     Us => self.memory.pointer_size(),\n                 };\n-                PrimVal::from_u64(self.memory.read_uint(ptr, size)?)\n+                PrimVal::from_u128(self.memory.read_uint(ptr, size)?)\n             }\n \n             ty::TyFloat(FloatTy::F32) => PrimVal::from_f32(self.memory.read_f32(ptr)?),\n@@ -1159,7 +1163,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let extra = match self.tcx.struct_tail(ty).sty {\n                         ty::TyDynamic(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n-                        ty::TyStr => PrimVal::from_u64(self.memory.read_usize(extra)?),\n+                        ty::TyStr => PrimVal::from_u128(self.memory.read_usize(extra)? as u128),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n                     };\n                     return Ok(Some(Value::ByValPair(PrimVal::Ptr(p), extra)));\n@@ -1171,9 +1175,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n                     let size = discr.size().bytes();\n                     if signed {\n-                        PrimVal::from_i64(self.memory.read_int(ptr, size)?)\n+                        PrimVal::from_i128(self.memory.read_int(ptr, size)?)\n                     } else {\n-                        PrimVal::from_u64(self.memory.read_uint(ptr, size)?)\n+                        PrimVal::from_u128(self.memory.read_uint(ptr, size)?)\n                     }\n                 } else {\n                     return Ok(None);\n@@ -1220,7 +1224,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                     (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                         let ptr = src.read_ptr(&self.memory)?;\n-                        let len = PrimVal::from_u64(length as u64);\n+                        let len = PrimVal::from_u128(length as u128);\n                         let ptr = PrimVal::Ptr(ptr);\n                         self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)?;\n                     }\n@@ -1454,6 +1458,7 @@ impl IntegerExt for layout::Integer {\n             I16 => Size::from_bits(16),\n             I32 => Size::from_bits(32),\n             I64 => Size::from_bits(64),\n+            I128 => Size::from_bits(128),\n         }\n     }\n }"}, {"sha": "418ccfa549fef65f572dc4c045223dc7f421041c", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -4,6 +4,7 @@\n     collections_bound,\n     pub_restricted,\n     rustc_private,\n+    i128_type,\n )]\n \n // From rustc."}, {"sha": "5be28f27712a4e7b2f4816f89863982cf5d90c8f", "filename": "src/memory.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -1,7 +1,7 @@\n-use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian, self};\n+use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::Bound::{Included, Excluded};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr, mem};\n+use std::{fmt, iter, ptr, mem, io};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, BareFnTy, ClosureTy, ClosureSubsts, TyCtxt};\n@@ -567,6 +567,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let endianess = self.endianess();\n         let bytes = self.get_bytes_unchecked(ptr, size)?;\n         let offset = read_target_uint(endianess, bytes).unwrap();\n+        assert_eq!(offset as u64 as u128, offset);\n+        let offset = offset as u64;\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n             Some(&alloc_id) => Ok(Pointer::new(alloc_id, offset)),\n@@ -596,10 +598,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 // We need to mask here, or the byteorder crate can die when given a u64 larger\n                 // than fits in an integer of the requested size.\n                 let mask = match size {\n-                    1 => 0xff,\n-                    2 => 0xffff,\n-                    4 => 0xffffffff,\n-                    8 => 0xffffffffffffffff,\n+                    1 => !0u8 as u128,\n+                    2 => !0u16 as u128,\n+                    4 => !0u32 as u128,\n+                    8 => !0u64 as u128,\n+                    16 => !0,\n                     _ => bug!(\"unexpected PrimVal::Bytes size\"),\n                 };\n                 self.write_uint(dest, bytes & mask, size)\n@@ -630,29 +633,30 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             2 => Ok(self.layout.i16_align.abi()),\n             4 => Ok(self.layout.i32_align.abi()),\n             8 => Ok(self.layout.i64_align.abi()),\n+            16 => Ok(self.layout.i128_align.abi()),\n             _ => bug!(\"bad integer size: {}\", size),\n         }\n     }\n \n-    pub fn read_int(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, i64> {\n+    pub fn read_int(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, i128> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: u64) -> EvalResult<'tcx, ()> {\n+    pub fn write_int(&mut self, ptr: Pointer, n: i128, size: u64) -> EvalResult<'tcx, ()> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_int(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_uint(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, u64> {\n+    pub fn read_uint(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, u128> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: u64) -> EvalResult<'tcx, ()> {\n+    pub fn write_uint(&mut self, ptr: Pointer, n: u128, size: u64) -> EvalResult<'tcx, ()> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n@@ -661,21 +665,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn read_isize(&self, ptr: Pointer) -> EvalResult<'tcx, i64> {\n-        self.read_int(ptr, self.pointer_size())\n+        self.read_int(ptr, self.pointer_size()).map(|i| i as i64)\n     }\n \n     pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx, ()> {\n         let size = self.pointer_size();\n-        self.write_int(ptr, n, size)\n+        self.write_int(ptr, n as i128, size)\n     }\n \n     pub fn read_usize(&self, ptr: Pointer) -> EvalResult<'tcx, u64> {\n-        self.read_uint(ptr, self.pointer_size())\n+        self.read_uint(ptr, self.pointer_size()).map(|i| i as u64)\n     }\n \n     pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx, ()> {\n         let size = self.pointer_size();\n-        self.write_uint(ptr, n, size)\n+        self.write_uint(ptr, n as u128, size)\n     }\n \n     pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx, ()> {\n@@ -801,58 +805,58 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n // Methods to access integers in the target endianess\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn write_target_uint(endianess: layout::Endian, mut target: &mut [u8], data: u64) -> Result<(), byteorder::Error> {\n+fn write_target_uint(endianess: layout::Endian, mut target: &mut [u8], data: u128) -> Result<(), io::Error> {\n     let len = target.len();\n     match endianess {\n-        layout::Endian::Little => target.write_uint::<LittleEndian>(data, len),\n-        layout::Endian::Big => target.write_uint::<BigEndian>(data, len),\n+        layout::Endian::Little => target.write_uint128::<LittleEndian>(data, len),\n+        layout::Endian::Big => target.write_uint128::<BigEndian>(data, len),\n     }\n }\n-fn write_target_int(endianess: layout::Endian, mut target: &mut [u8], data: i64) -> Result<(), byteorder::Error> {\n+fn write_target_int(endianess: layout::Endian, mut target: &mut [u8], data: i128) -> Result<(), io::Error> {\n     let len = target.len();\n     match endianess {\n-        layout::Endian::Little => target.write_int::<LittleEndian>(data, len),\n-        layout::Endian::Big => target.write_int::<BigEndian>(data, len),\n+        layout::Endian::Little => target.write_int128::<LittleEndian>(data, len),\n+        layout::Endian::Big => target.write_int128::<BigEndian>(data, len),\n     }\n }\n \n-fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u64, byteorder::Error> {\n+fn read_target_uint(endianess: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianess {\n-        layout::Endian::Little => source.read_uint::<LittleEndian>(source.len()),\n-        layout::Endian::Big => source.read_uint::<BigEndian>(source.len()),\n+        layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n+        layout::Endian::Big => source.read_uint128::<BigEndian>(source.len()),\n     }\n }\n-fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i64, byteorder::Error> {\n+fn read_target_int(endianess: layout::Endian, mut source: &[u8]) -> Result<i128, io::Error> {\n     match endianess {\n-        layout::Endian::Little => source.read_int::<LittleEndian>(source.len()),\n-        layout::Endian::Big => source.read_int::<BigEndian>(source.len()),\n+        layout::Endian::Little => source.read_int128::<LittleEndian>(source.len()),\n+        layout::Endian::Big => source.read_int128::<BigEndian>(source.len()),\n     }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n // Methods to access floats in the target endianess\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn write_target_f32(endianess: layout::Endian, mut target: &mut [u8], data: f32) -> Result<(), byteorder::Error> {\n+fn write_target_f32(endianess: layout::Endian, mut target: &mut [u8], data: f32) -> Result<(), io::Error> {\n     match endianess {\n         layout::Endian::Little => target.write_f32::<LittleEndian>(data),\n         layout::Endian::Big => target.write_f32::<BigEndian>(data),\n     }\n }\n-fn write_target_f64(endianess: layout::Endian, mut target: &mut [u8], data: f64) -> Result<(), byteorder::Error> {\n+fn write_target_f64(endianess: layout::Endian, mut target: &mut [u8], data: f64) -> Result<(), io::Error> {\n     match endianess {\n         layout::Endian::Little => target.write_f64::<LittleEndian>(data),\n         layout::Endian::Big => target.write_f64::<BigEndian>(data),\n     }\n }\n \n-fn read_target_f32(endianess: layout::Endian, mut source: &[u8]) -> Result<f32, byteorder::Error> {\n+fn read_target_f32(endianess: layout::Endian, mut source: &[u8]) -> Result<f32, io::Error> {\n     match endianess {\n         layout::Endian::Little => source.read_f32::<LittleEndian>(),\n         layout::Endian::Big => source.read_f32::<BigEndian>(),\n     }\n }\n-fn read_target_f64(endianess: layout::Endian, mut source: &[u8]) -> Result<f64, byteorder::Error> {\n+fn read_target_f64(endianess: layout::Endian, mut source: &[u8]) -> Result<f64, io::Error> {\n     match endianess {\n         layout::Endian::Little => source.read_f64::<LittleEndian>(),\n         layout::Endian::Big => source.read_f64::<BigEndian>(),"}, {"sha": "417e7047ec00ebf6499f2d48172217b352579eb3", "filename": "src/operator.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -66,7 +66,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n macro_rules! overflow {\n     ($op:ident, $l:expr, $r:expr) => ({\n         let (val, overflowed) = $l.$op($r);\n-        let primval = PrimVal::Bytes(val as u64);\n+        let primval = PrimVal::Bytes(val as u128);\n         Ok((primval, overflowed))\n     })\n }\n@@ -144,7 +144,7 @@ pub fn binary_op<'tcx>(\n     fn normalize(val: PrimVal) -> PrimVal {\n         if let PrimVal::Ptr(ptr) = val {\n             if let Ok(bytes) = ptr.to_int() {\n-                return PrimVal::Bytes(bytes);\n+                return PrimVal::Bytes(bytes as u128);\n             }\n         }\n         val\n@@ -158,15 +158,15 @@ pub fn binary_op<'tcx>(\n             if left_ptr.alloc_id == right_ptr.alloc_id {\n                 // If the pointers are into the same allocation, fall through to the more general\n                 // match later, which will do comparisons on the pointer offsets.\n-                (left_ptr.offset, right_ptr.offset)\n+                (left_ptr.offset as u128, right_ptr.offset as u128)\n             } else {\n                 return Ok((unrelated_ptr_ops(bin_op, left_ptr, right_ptr)?, false));\n             }\n         }\n \n         (PrimVal::Ptr(ptr), PrimVal::Bytes(bytes)) |\n         (PrimVal::Bytes(bytes), PrimVal::Ptr(ptr)) => {\n-            return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes))?, false));\n+            return Ok((unrelated_ptr_ops(bin_op, ptr, Pointer::from_int(bytes as u64))?, false));\n         }\n \n         (PrimVal::Undef, _) | (_, PrimVal::Undef) => return Err(EvalError::ReadUndefBytes),\n@@ -182,6 +182,7 @@ pub fn binary_op<'tcx>(\n             I16 | U16 => 16,\n             I32 | U32 => 32,\n             I64 | U64 => 64,\n+            I128 | U128 => 128,\n             _ => bug!(\"bad MIR: bitshift lhs is not integral\"),\n         };\n \n@@ -278,22 +279,25 @@ pub fn unary_op<'tcx>(\n     let bytes = val.to_bytes()?;\n \n     let result_bytes = match (un_op, val_kind) {\n-        (Not, Bool) => !bytes_to_bool(bytes) as u64,\n-\n-        (Not, U8)  => !(bytes as u8) as u64,\n-        (Not, U16) => !(bytes as u16) as u64,\n-        (Not, U32) => !(bytes as u32) as u64,\n-        (Not, U64) => !bytes,\n-\n-        (Not, I8)  => !(bytes as i8) as u64,\n-        (Not, I16) => !(bytes as i16) as u64,\n-        (Not, I32) => !(bytes as i32) as u64,\n-        (Not, I64) => !(bytes as i64) as u64,\n-\n-        (Neg, I8)  => -(bytes as i8) as u64,\n-        (Neg, I16) => -(bytes as i16) as u64,\n-        (Neg, I32) => -(bytes as i32) as u64,\n-        (Neg, I64) => -(bytes as i64) as u64,\n+        (Not, Bool) => !bytes_to_bool(bytes) as u128,\n+\n+        (Not, U8)  => !(bytes as u8) as u128,\n+        (Not, U16) => !(bytes as u16) as u128,\n+        (Not, U32) => !(bytes as u32) as u128,\n+        (Not, U64) => !(bytes as u64) as u128,\n+        (Not, U128) => !bytes,\n+\n+        (Not, I8)  => !(bytes as i8) as u128,\n+        (Not, I16) => !(bytes as i16) as u128,\n+        (Not, I32) => !(bytes as i32) as u128,\n+        (Not, I64) => !(bytes as i64) as u128,\n+        (Not, I128) => !(bytes as i128) as u128,\n+\n+        (Neg, I8)  => -(bytes as i8) as u128,\n+        (Neg, I16) => -(bytes as i16) as u128,\n+        (Neg, I32) => -(bytes as i32) as u128,\n+        (Neg, I64) => -(bytes as i64) as u128,\n+        (Neg, I128) => -(bytes as i128) as u128,\n \n         (Neg, F32) => f32_to_bytes(-bytes_to_f32(bytes)),\n         (Neg, F64) => f64_to_bytes(-bytes_to_f64(bytes)),"}, {"sha": "109631327b16ef2a0e78c7086b7e89e8b5c22a8f", "filename": "src/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let dest = self.force_allocation(dest)?;\n                         let discr_dest = (dest.to_ptr()).offset(discr_offset);\n \n-                        self.memory.write_uint(discr_dest, variant_index as u64, discr_size)?;\n+                        self.memory.write_uint(discr_dest, variant_index as u128, discr_size)?;\n                     }\n \n                     Layout::RawNullablePointer { nndiscr, .. } => {"}, {"sha": "a91a75454dd9399b6054cf1b1d290cfd1dfc3855", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -45,8 +45,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"arith_offset\" => {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64()?;\n-                let new_ptr = ptr.signed_offset(offset);\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()?;\n+                let new_ptr = ptr.signed_offset(offset as i64);\n                 self.write_primval(dest, PrimVal::Ptr(new_ptr), dest_ty)?;\n             }\n \n@@ -260,15 +260,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"min_align_of\" => {\n                 let elem_ty = substs.type_at(0);\n                 let elem_align = self.type_align(elem_ty)?;\n-                let align_val = PrimVal::from_u64(elem_align as u64);\n+                let align_val = PrimVal::from_u128(elem_align as u128);\n                 self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.type_layout(ty)?;\n                 let align = layout.align(&self.tcx.data_layout).pref();\n-                let align_val = PrimVal::from_u64(align);\n+                let align_val = PrimVal::from_u128(align as u128);\n                 self.write_primval(dest, align_val, dest_ty)?;\n             }\n \n@@ -289,7 +289,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let pointee_ty = substs.type_at(0);\n                 // FIXME: assuming here that type size is < i64::max_value()\n                 let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n-                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i64()?;\n+                let offset = self.value_to_primval(arg_vals[1], isize)?.to_i128()? as i64;\n \n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let result_ptr = ptr.signed_offset(offset * pointee_size);\n@@ -310,13 +310,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"powif32\" => {\n                 let f = self.value_to_primval(arg_vals[0], f32)?.to_f32()?;\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64()?;\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n                 self.write_primval(dest, PrimVal::from_f32(f.powi(i as i32)), dest_ty)?;\n             }\n \n             \"powif64\" => {\n                 let f = self.value_to_primval(arg_vals[0], f64)?.to_f64()?;\n-                let i = self.value_to_primval(arg_vals[1], i32)?.to_i64()?;\n+                let i = self.value_to_primval(arg_vals[1], i32)?.to_i128()?;\n                 self.write_primval(dest, PrimVal::from_f64(f.powi(i as i32)), dest_ty)?;\n             }\n \n@@ -336,21 +336,21 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 // `size_of_val` intrinsic, then change this back to\n                 // .expect(\"size_of intrinsic called on unsized value\")\n                 // see https://github.com/rust-lang/rust/pull/37708\n-                let size = self.type_size(ty)?.unwrap_or(!0) as u64;\n-                self.write_primval(dest, PrimVal::from_u64(size), dest_ty)?;\n+                let size = self.type_size(ty)?.unwrap_or(!0) as u128;\n+                self.write_primval(dest, PrimVal::from_u128(size), dest_ty)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (size, _) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n-                self.write_primval(dest, PrimVal::from_u64(size), dest_ty)?;\n+                self.write_primval(dest, PrimVal::from_u128(size as u128), dest_ty)?;\n             }\n \n             \"min_align_of_val\" |\n             \"align_of_val\" => {\n                 let ty = substs.type_at(0);\n                 let (_, align) = self.size_and_align_of_dst(ty, arg_vals[0])?;\n-                self.write_primval(dest, PrimVal::from_u64(align), dest_ty)?;\n+                self.write_primval(dest, PrimVal::from_u128(align as u128), dest_ty)?;\n             }\n \n             \"type_name\" => {\n@@ -362,7 +362,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let n = self.tcx.type_id_hash(ty);\n-                self.write_primval(dest, PrimVal::Bytes(n), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(n as u128), dest_ty)?;\n             }\n \n             \"transmute\" => {\n@@ -514,14 +514,16 @@ fn numeric_intrinsic<'tcx>(\n \n             use value::PrimValKind::*;\n             let result_bytes = match $kind {\n-                I8 => (bytes as i8).$method() as u64,\n-                U8 => (bytes as u8).$method() as u64,\n-                I16 => (bytes as i16).$method() as u64,\n-                U16 => (bytes as u16).$method() as u64,\n-                I32 => (bytes as i32).$method() as u64,\n-                U32 => (bytes as u32).$method() as u64,\n-                I64 => (bytes as i64).$method() as u64,\n-                U64 => bytes.$method() as u64,\n+                I8 => (bytes as i8).$method() as u128,\n+                U8 => (bytes as u8).$method() as u128,\n+                I16 => (bytes as i16).$method() as u128,\n+                U16 => (bytes as u16).$method() as u128,\n+                I32 => (bytes as i32).$method() as u128,\n+                U32 => (bytes as u32).$method() as u128,\n+                I64 => (bytes as i64).$method() as u128,\n+                U64 => (bytes as u64).$method() as u128,\n+                I128 => (bytes as i128).$method() as u128,\n+                U128 => bytes.$method() as u128,\n                 _ => bug!(\"invalid `{}` argument: {:?}\", $name, val),\n             };\n "}, {"sha": "6959da650b426bf3f4994ee4904b20536ac04a6c", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let adt_ty = self.lvalue_ty(discr);\n                 let discr_val = self.read_discriminant_value(adt_ptr, adt_ty)?;\n                 let matching = adt_def.variants.iter()\n-                    .position(|v| discr_val == v.disr_val.to_u64_unchecked());\n+                    .position(|v| discr_val == v.disr_val.to_u128_unchecked());\n \n                 match matching {\n                     Some(i) => self.goto_block(targets[i]),\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n+    fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n         trace!(\"read_discriminant_value {:?}\", adt_layout);\n@@ -275,13 +275,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             CEnum { discr, signed: true, .. } => {\n                 let discr_size = discr.size().bytes();\n-                self.memory.read_int(adt_ptr, discr_size)? as u64\n+                self.memory.read_int(adt_ptr, discr_size)? as u128\n             }\n \n             RawNullablePointer { nndiscr, value } => {\n                 let discr_size = value.size(&self.tcx.data_layout).bytes();\n                 trace!(\"rawnullablepointer with size {}\", discr_size);\n-                self.read_nonnull_discriminant_value(adt_ptr, nndiscr, discr_size)?\n+                self.read_nonnull_discriminant_value(adt_ptr, nndiscr as u128, discr_size)?\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n-                self.read_nonnull_discriminant_value(nonnull, nndiscr, discr_size)?\n+                self.read_nonnull_discriminant_value(nonnull, nndiscr as u128, discr_size)?\n             }\n \n             // The discriminant_value intrinsic returns 0 for non-sum types.\n@@ -301,7 +301,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64, discr_size: u64) -> EvalResult<'tcx, u64> {\n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n             Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n@@ -366,13 +366,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n-                        Less => -1,\n+                        Less => -1i8,\n                         Equal => 0,\n                         Greater => 1,\n                     }\n                 };\n \n-                self.write_primval(dest, PrimVal::Bytes(result as u64), dest_ty)?;\n+                self.write_primval(dest, PrimVal::Bytes(result as u128), dest_ty)?;\n             }\n \n             \"memchr\" => {\n@@ -641,17 +641,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n                     },\n                     Layout::General { ref variants, .. } => {\n-                        let discr_val = self.read_discriminant_value(adt_ptr, ty)?;\n-                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u64_unchecked()) {\n+                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n+                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n                             // start at offset 1, to skip over the discriminant\n                             Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n                             None => return Err(EvalError::InvalidDiscriminant),\n                         }\n                     },\n                     Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n                         let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        if discr == nndiscr {\n-                            assert_eq!(discr as usize as u64, discr);\n+                        if discr == nndiscr as u128 {\n+                            assert_eq!(discr as usize as u128, discr);\n                             adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n                         } else {\n                             // FIXME: the zst variant might contain zst types that impl Drop\n@@ -660,8 +660,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     },\n                     Layout::RawNullablePointer { nndiscr, .. } => {\n                         let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        if discr == nndiscr {\n-                            assert_eq!(discr as usize as u64, discr);\n+                        if discr == nndiscr as u128 {\n+                            assert_eq!(discr as usize as u128, discr);\n                             assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n                             let field_ty = &adt_def.variants[discr as usize].fields[0];\n                             let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);"}, {"sha": "8d153528d4f08d1fea215713c48532d8839170a6", "filename": "src/value.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=3a658e09e88ad999fe1f5dbc4ac7a14c0d38c90f", "patch": "@@ -6,23 +6,23 @@ use std::mem::transmute;\n use error::{EvalError, EvalResult};\n use memory::{Memory, Pointer};\n \n-pub(super) fn bytes_to_f32(bytes: u64) -> f32 {\n+pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     unsafe { transmute::<u32, f32>(bytes as u32) }\n }\n \n-pub(super) fn bytes_to_f64(bytes: u64) -> f64 {\n-    unsafe { transmute::<u64, f64>(bytes) }\n+pub(super) fn bytes_to_f64(bytes: u128) -> f64 {\n+    unsafe { transmute::<u64, f64>(bytes as u64) }\n }\n \n-pub(super) fn f32_to_bytes(f: f32) -> u64 {\n-    unsafe { transmute::<f32, u32>(f) as u64 }\n+pub(super) fn f32_to_bytes(f: f32) -> u128 {\n+    unsafe { transmute::<f32, u32>(f) as u128 }\n }\n \n-pub(super) fn f64_to_bytes(f: f64) -> u64 {\n-    unsafe { transmute::<f64, u64>(f) }\n+pub(super) fn f64_to_bytes(f: f64) -> u128 {\n+    unsafe { transmute::<f64, u64>(f) as u128 }\n }\n \n-pub(super) fn bytes_to_bool(n: u64) -> bool {\n+pub(super) fn bytes_to_bool(n: u128) -> bool {\n     // FIXME(solson): Can we reach here due to user error?\n     debug_assert!(n == 0 || n == 1, \"bytes interpreted as bool were {}\", n);\n     n & 1 == 1\n@@ -50,7 +50,7 @@ pub enum Value {\n #[derive(Clone, Copy, Debug)]\n pub enum PrimVal {\n     /// The raw bytes of a simple value.\n-    Bytes(u64),\n+    Bytes(u128),\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `PrimVal` is only large enough to contain one, so we just represent the\n@@ -64,8 +64,8 @@ pub enum PrimVal {\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n pub enum PrimValKind {\n-    I8, I16, I32, I64,\n-    U8, U16, U32, U64,\n+    I8, I16, I32, I64, I128,\n+    U8, U16, U32, U64, U128,\n     F32, F64,\n     Bool,\n     Char,\n@@ -109,20 +109,22 @@ impl<'a, 'tcx: 'a> Value {\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {\n-                Ok((ptr.to_ptr()?, val.to_u64()?))\n+                let len = val.to_u128()?;\n+                assert_eq!(len as u64 as u128, len);\n+                Ok((ptr.to_ptr()?, len as u64))\n             },\n             _ => unimplemented!(),\n         }\n     }\n }\n \n impl<'tcx> PrimVal {\n-    pub fn from_u64(n: u64) -> Self {\n+    pub fn from_u128(n: u128) -> Self {\n         PrimVal::Bytes(n)\n     }\n \n-    pub fn from_i64(n: i64) -> Self {\n-        PrimVal::Bytes(n as u64)\n+    pub fn from_i128(n: i128) -> Self {\n+        PrimVal::Bytes(n as u128)\n     }\n \n     pub fn from_f32(f: f32) -> Self {\n@@ -134,35 +136,56 @@ impl<'tcx> PrimVal {\n     }\n \n     pub fn from_bool(b: bool) -> Self {\n-        PrimVal::Bytes(b as u64)\n+        PrimVal::Bytes(b as u128)\n     }\n \n     pub fn from_char(c: char) -> Self {\n-        PrimVal::Bytes(c as u64)\n+        PrimVal::Bytes(c as u128)\n     }\n \n-    pub fn to_bytes(self) -> EvalResult<'tcx, u64> {\n+    pub fn to_bytes(self) -> EvalResult<'tcx, u128> {\n         match self {\n             PrimVal::Bytes(b) => Ok(b),\n-            PrimVal::Ptr(p) => p.to_int(),\n+            PrimVal::Ptr(p) => p.to_int().map(|b| b as u128),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         match self {\n-            PrimVal::Bytes(b) => Ok(Pointer::from_int(b)),\n+            PrimVal::Bytes(b) => Ok(Pointer::from_int(b as u64)),\n             PrimVal::Ptr(p) => Ok(p),\n             PrimVal::Undef => Err(EvalError::ReadUndefBytes),\n         }\n     }\n \n-    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n+    pub fn to_u128(self) -> EvalResult<'tcx, u128> {\n         self.to_bytes()\n     }\n \n+    pub fn to_u64(self) -> EvalResult<'tcx, u64> {\n+        self.to_bytes().map(|b| {\n+            assert_eq!(b as u64 as u128, b);\n+            b as u64\n+        })\n+    }\n+\n+    pub fn to_i32(self) -> EvalResult<'tcx, i32> {\n+        self.to_bytes().map(|b| {\n+            assert_eq!(b as i32 as u128, b);\n+            b as i32\n+        })\n+    }\n+\n+    pub fn to_i128(self) -> EvalResult<'tcx, i128> {\n+        self.to_bytes().map(|b| b as i128)\n+    }\n+\n     pub fn to_i64(self) -> EvalResult<'tcx, i64> {\n-        self.to_bytes().map(|b| b as i64)\n+        self.to_bytes().map(|b| {\n+            assert_eq!(b as i64 as u128, b);\n+            b as i64\n+        })\n     }\n \n     pub fn to_f32(self) -> EvalResult<'tcx, f32> {\n@@ -186,7 +209,7 @@ impl PrimValKind {\n     pub fn is_int(self) -> bool {\n         use self::PrimValKind::*;\n         match self {\n-            I8 | I16 | I32 | I64 | U8 | U16 | U32 | U64 => true,\n+            I8 | I16 | I32 | I64 | I128 | U8 | U16 | U32 | U64 | U128 => true,\n             _ => false,\n         }\n     }\n@@ -197,6 +220,7 @@ impl PrimValKind {\n             2 => PrimValKind::U16,\n             4 => PrimValKind::U32,\n             8 => PrimValKind::U64,\n+            16 => PrimValKind::U128,\n             _ => bug!(\"can't make uint with size {}\", size),\n         }\n     }\n@@ -207,6 +231,7 @@ impl PrimValKind {\n             2 => PrimValKind::I16,\n             4 => PrimValKind::I32,\n             8 => PrimValKind::I64,\n+            16 => PrimValKind::I128,\n             _ => bug!(\"can't make int with size {}\", size),\n         }\n     }"}]}