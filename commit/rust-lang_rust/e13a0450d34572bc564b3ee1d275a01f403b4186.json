{"sha": "e13a0450d34572bc564b3ee1d275a01f403b4186", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxM2EwNDUwZDM0NTcyYmM1NjRiM2VlMWQyNzVhMDFmNDAzYjQxODY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-22T03:00:29Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-01-29T21:18:14Z"}, "message": "Clean up resolve_single_import", "tree": {"sha": "8e2f3f1dd146c95055ba708e9bdff48c6a8fc087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e2f3f1dd146c95055ba708e9bdff48c6a8fc087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e13a0450d34572bc564b3ee1d275a01f403b4186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e13a0450d34572bc564b3ee1d275a01f403b4186", "html_url": "https://github.com/rust-lang/rust/commit/e13a0450d34572bc564b3ee1d275a01f403b4186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e13a0450d34572bc564b3ee1d275a01f403b4186/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "118c93ba5e3be48c91fff1840fdc7bbe942c5f00", "url": "https://api.github.com/repos/rust-lang/rust/commits/118c93ba5e3be48c91fff1840fdc7bbe942c5f00", "html_url": "https://github.com/rust-lang/rust/commit/118c93ba5e3be48c91fff1840fdc7bbe942c5f00"}], "stats": {"total": 172, "additions": 66, "deletions": 106}, "files": [{"sha": "4694f52188412eec7140f604f1fdb0340e40c0d6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 66, "deletions": 106, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e13a0450d34572bc564b3ee1d275a01f403b4186/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e13a0450d34572bc564b3ee1d275a01f403b4186/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=e13a0450d34572bc564b3ee1d275a01f403b4186", "patch": "@@ -375,22 +375,47 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         return resolution_result;\n     }\n \n-    fn resolve_imported_name_in_module(&mut self,\n-                                       module: Module<'b>, // Module containing the name\n-                                       name: Name,\n-                                       ns: Namespace,\n-                                       importing_module: Module<'b>) // Module importing the name\n-                                       -> ResolveResult<(Module<'b>, NameBinding<'b>)> {\n+    /// Resolves the name in the namespace of the module because it is being imported by\n+    /// importing_module. Returns the module in which the name was defined (as opposed to imported),\n+    /// the name bindings defining the name, and whether or not the name was imported into `module`.\n+    fn resolve_name_in_module(&mut self,\n+                              module: Module<'b>, // Module containing the name\n+                              name: Name,\n+                              ns: Namespace,\n+                              importing_module: Module<'b>) // Module importing the name\n+                              -> (ResolveResult<(Module<'b>, NameBinding<'b>)>, bool) {\n+        build_reduced_graph::populate_module_if_necessary(self.resolver, module);\n+        if let Some(name_binding) = module.get_child(name, ns) {\n+            return (Success((module, name_binding)), false);\n+        }\n+\n+        if let TypeNS = ns {\n+            if let Some(extern_crate) = module.external_module_children.borrow().get(&name) {\n+                // track the extern crate as used.\n+                if let Some(DefId{ krate: kid, .. }) = extern_crate.def_id() {\n+                    self.resolver.used_crates.insert(kid);\n+                }\n+                let name_binding = NameBinding::create_from_module(extern_crate, None);\n+                return (Success((module, name_binding)), false);\n+            }\n+        }\n+\n+        // If there is an unresolved glob at this point in the containing module, bail out.\n+        // We don't know enough to be able to resolve the name.\n+        if module.pub_glob_count.get() > 0 {\n+            return (Indeterminate, false);\n+        }\n+\n         match module.import_resolutions.borrow().get(&(name, ns)) {\n             // The containing module definitely doesn't have an exported import with the\n             // name in question. We can therefore accurately report that names are unbound.\n-            None => Failed(None),\n+            None => (Failed(None), false),\n \n             // The name is an import which has been fully resolved, so we just follow it.\n             Some(resolution) if resolution.outstanding_references == 0 => {\n                 // Import resolutions must be declared with \"pub\" in order to be exported.\n                 if !resolution.is_public {\n-                    return Failed(None);\n+                    return (Failed(None), false);\n                 }\n \n                 let target = resolution.target.clone();\n@@ -401,9 +426,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     if let Some(DefId { krate, .. }) = target_module.def_id() {\n                         self.resolver.used_crates.insert(krate);\n                     }\n-                    Success((target_module, binding))\n+                    (Success((target_module, binding)), true)\n                 } else {\n-                    Failed(None)\n+                    (Failed(None), false)\n                 }\n             }\n \n@@ -415,11 +440,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // use self::submodule;\n             // pub mod submodule;\n             //\n-            // In this case we continue as if we resolved the import and let the\n-            // check_for_conflicts_between_imports_and_items call below handle the conflict\n+            // In this case we continue as if we resolved the import and let\n+            // check_for_conflicts_between_imports_and_items handle the conflict\n             Some(_) => match (importing_module.def_id(), module.def_id()) {\n-                (Some(id1), Some(id2)) if id1 == id2 => Failed(None),\n-                _ => Indeterminate,\n+                (Some(id1), Some(id2)) if id1 == id2 => (Failed(None), false),\n+                _ => (Indeterminate, false)\n             },\n         }\n     }\n@@ -451,34 +476,25 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         };\n \n         // We need to resolve both namespaces for this to succeed.\n-        let mut value_result = Indeterminate;\n-        let mut type_result = Indeterminate;\n-        let mut lev_suggestion = \"\".to_owned();\n+        let (value_result, value_used_reexport) =\n+            self.resolve_name_in_module(&target_module, source, ValueNS, module_);\n+        let (type_result, type_used_reexport) =\n+            self.resolve_name_in_module(&target_module, source, TypeNS, module_);\n \n-        // Search for direct children of the containing module.\n-        build_reduced_graph::populate_module_if_necessary(self.resolver, &target_module);\n-\n-        // pub_err makes sure we don't give the same error twice.\n-        let mut pub_err = false;\n-\n-        if let Some(name_binding) = target_module.get_child(source, ValueNS) {\n-            debug!(\"(resolving single import) found value binding\");\n-            value_result = Success((target_module, name_binding.clone()));\n-            if directive.is_public && !name_binding.is_public() {\n+        match (&value_result, &type_result) {\n+            (&Success((_, ref name_binding)), _) if !value_used_reexport &&\n+                                                    directive.is_public &&\n+                                                    !name_binding.is_public() => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"Consider marking `{}` as `pub` in the imported module\",\n                                         source);\n                 struct_span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n-                pub_err = true;\n             }\n-        }\n \n-        if let Some(name_binding) = target_module.get_child(source, TypeNS) {\n-            debug!(\"(resolving single import) found type binding\");\n-            type_result = Success((target_module, name_binding.clone()));\n-            if !pub_err && directive.is_public {\n+            (_, &Success((_, ref name_binding))) if !type_used_reexport &&\n+                                                    directive.is_public => {\n                 if !name_binding.is_public() {\n                     let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                     let note_msg =\n@@ -496,50 +512,26 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                    msg);\n                 }\n             }\n-        }\n-\n-        if let (&Indeterminate, &Indeterminate) = (&value_result, &type_result) {\n-            let names = target_module.children.borrow();\n-            let names = names.keys().map(|&(ref name, _)| name);\n-            if let Some(name) = find_best_match_for_name(names, &source.as_str(), None) {\n-                lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n-            }\n-        }\n \n-        match (&value_result, &type_result) {\n-            // If there is an unresolved glob at this point in the containing module, bail out.\n-            // We don't know enough to be able to resolve this import.\n-            (&Indeterminate, _) | (_, &Indeterminate) if target_module.pub_glob_count.get() > 0 =>\n-                return Indeterminate,\n-            _ => ()\n-        }\n-\n-        let mut value_used_reexport = false;\n-        if let Indeterminate = value_result {\n-            value_result =\n-                self.resolve_imported_name_in_module(&target_module, source, ValueNS, module_);\n-            value_used_reexport = match value_result { Success(_) => true, _ => false };\n-        }\n-\n-        let mut type_used_reexport = false;\n-        if let Indeterminate = type_result {\n-            type_result =\n-                self.resolve_imported_name_in_module(&target_module, source, TypeNS, module_);\n-            type_used_reexport = match type_result { Success(_) => true, _ => false };\n+            _ => {}\n         }\n \n+        let mut lev_suggestion = \"\".to_owned();\n         match (&value_result, &type_result) {\n             (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n             (&Failed(_), &Failed(_)) => {\n-                if lev_suggestion.is_empty() {  // skip if we already have a suggestion\n-                    let names = target_module.import_resolutions.borrow();\n-                    let names = names.keys().map(|&(ref name, _)| name);\n+                let children = target_module.children.borrow();\n+                let names = children.keys().map(|&(ref name, _)| name);\n+                if let Some(name) = find_best_match_for_name(names, &source.as_str(), None) {\n+                    lev_suggestion = format!(\". Did you mean to use `{}`?\", name);\n+                } else {\n+                    let resolutions = target_module.import_resolutions.borrow();\n+                    let names = resolutions.keys().map(|&(ref name, _)| name);\n                     if let Some(name) = find_best_match_for_name(names,\n                                                                  &source.as_str(),\n                                                                  None) {\n                         lev_suggestion =\n-                            format!(\". Did you mean to use the re-exported import `{}`?\",\n-                                    name);\n+                            format!(\". Did you mean to use the re-exported import `{}`?\", name);\n                     }\n                 }\n             }\n@@ -549,30 +541,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         let mut value_used_public = false;\n         let mut type_used_public = false;\n \n-        // If we didn't find a result in the type namespace, search the\n-        // external modules.\n-        match type_result {\n-            Success(..) => {}\n-            _ => {\n-                match target_module.external_module_children.borrow_mut().get(&source).cloned() {\n-                    None => {} // Continue.\n-                    Some(module) => {\n-                        debug!(\"(resolving single import) found external module\");\n-                        // track the module as used.\n-                        match module.def_id() {\n-                            Some(DefId{krate: kid, ..}) => {\n-                                self.resolver.used_crates.insert(kid);\n-                            }\n-                            _ => {}\n-                        }\n-                        let name_binding = NameBinding::create_from_module(module, None);\n-                        type_result = Success((target_module, name_binding));\n-                        type_used_public = true;\n-                    }\n-                }\n-            }\n-        }\n-\n         // We've successfully resolved the import. Write the results in.\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n \n@@ -621,7 +589,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                                                    import_resolution,\n                                                                    directive.span,\n                                                                    (target, namespace));\n-\n             };\n             check_and_write_import(ValueNS, &value_result, &mut value_used_public);\n             check_and_write_import(TypeNS, &type_result, &mut type_used_public);\n@@ -631,8 +598,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             let msg = format!(\"There is no `{}` in `{}`{}\",\n                               source,\n                               module_to_string(&target_module), lev_suggestion);\n-            return ResolveResult::Failed(Some((directive.span, msg)));\n+            return Failed(Some((directive.span, msg)));\n         }\n+\n         let value_used_public = value_used_reexport || value_used_public;\n         let type_used_public = type_used_reexport || type_used_public;\n \n@@ -646,12 +614,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             // purposes it's good enough to just favor one over the other.\n             import_resolution_value.target.as_ref().map(|target| {\n                 let def = target.binding.def().unwrap();\n-                (def,\n-                 if value_used_public {\n-                    lp\n-                } else {\n-                    DependsOn(def.def_id())\n-                })\n+                let last_private = if value_used_public { lp } else { DependsOn(def.def_id()) };\n+                (def, last_private)\n             })\n         };\n \n@@ -662,12 +626,8 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n             import_resolution_type.target.as_ref().map(|target| {\n                 let def = target.binding.def().unwrap();\n-                (def,\n-                if type_used_public {\n-                    lp\n-                } else {\n-                    DependsOn(def.def_id())\n-                })\n+                let last_private = if type_used_public { lp } else { DependsOn(def.def_id()) };\n+                (def, last_private)\n             })\n         };\n \n@@ -696,7 +656,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n \n         debug!(\"(resolving single import) successfully resolved import\");\n-        return ResolveResult::Success(());\n+        return Success(());\n     }\n \n     // Resolves a glob import. Note that this function cannot fail; it either"}]}