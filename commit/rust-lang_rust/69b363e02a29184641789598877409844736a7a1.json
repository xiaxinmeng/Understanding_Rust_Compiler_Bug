{"sha": "69b363e02a29184641789598877409844736a7a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YjM2M2UwMmEyOTE4NDY0MTc4OTU5ODg3NzQwOTg0NDczNmE3YTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T18:03:36Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-05T18:07:06Z"}, "message": "doc: Split macros out into a separate tutorial", "tree": {"sha": "1d6fa6b636f70ae8b4f77bd8dbd3a21d8bff5b9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6fa6b636f70ae8b4f77bd8dbd3a21d8bff5b9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69b363e02a29184641789598877409844736a7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69b363e02a29184641789598877409844736a7a1", "html_url": "https://github.com/rust-lang/rust/commit/69b363e02a29184641789598877409844736a7a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69b363e02a29184641789598877409844736a7a1/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db44454541a9bcf1b1bed6cdda3c3213f355a25", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db44454541a9bcf1b1bed6cdda3c3213f355a25", "html_url": "https://github.com/rust-lang/rust/commit/9db44454541a9bcf1b1bed6cdda3c3213f355a25"}], "stats": {"total": 314, "additions": 163, "deletions": 151}, "files": [{"sha": "deb6252d0422bb73533703f1bfb47494e70c4414", "filename": "doc/tutorial-macros.md", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/69b363e02a29184641789598877409844736a7a1/doc%2Ftutorial-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/69b363e02a29184641789598877409844736a7a1/doc%2Ftutorial-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-macros.md?ref=69b363e02a29184641789598877409844736a7a1", "patch": "@@ -0,0 +1,152 @@\n+# Macros\n+\n+Functions are the programmer's primary tool of abstraction, but there are\n+cases in which they are insufficient, because the programmer wants to\n+abstract over concepts not represented as values. Consider the following\n+example:\n+\n+~~~~\n+# enum t { special_a(uint), special_b(uint) };\n+# fn f() -> uint {\n+# let input_1 = special_a(0), input_2 = special_a(0);\n+match input_1 {\n+    special_a(x) => { return x; }\n+    _ => {}\n+}\n+// ...\n+match input_2 {\n+    special_b(x) => { return x; }\n+    _ => {}\n+}\n+# return 0u;\n+# }\n+~~~~\n+\n+This code could become tiresome if repeated many times. However, there is\n+no reasonable function that could be written to solve this problem. In such a\n+case, it's possible to define a macro to solve the problem. Macros are\n+lightweight custom syntax extensions, themselves defined using the\n+`macro_rules!` syntax extension:\n+\n+~~~~\n+# enum t { special_a(uint), special_b(uint) };\n+# fn f() -> uint {\n+# let input_1 = special_a(0), input_2 = special_a(0);\n+macro_rules! early_return(\n+    ($inp:expr $sp:ident) => ( //invoke it like `(input_5 special_e)`\n+        match $inp {\n+            $sp(x) => { return x; }\n+            _ => {}\n+        }\n+    );\n+);\n+// ...\n+early_return!(input_1 special_a);\n+// ...\n+early_return!(input_2 special_b);\n+# return 0;\n+# }\n+~~~~\n+\n+Macros are defined in pattern-matching style:\n+\n+## Invocation syntax\n+\n+On the left-hand-side of the `=>` is the macro invocation syntax. It is\n+free-form, excepting the following rules:\n+\n+1. It must be surrounded in parentheses.\n+2. `$` has special meaning.\n+3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n+forbidden.\n+\n+To take as an argument a fragment of Rust code, write `$` followed by a name\n+ (for use on the right-hand side), followed by a `:`, followed by the sort of\n+fragment to match (the most common ones are `ident`, `expr`, `ty`, `pat`, and\n+`block`). Anything not preceeded by a `$` is taken literally. The standard\n+rules of tokenization apply,\n+\n+So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n+that could be invoked like `my_macro!(i=>(( 2+2 )))`.\n+\n+## Transcription syntax\n+\n+The right-hand side of the `=>` follows the same rules as the left-hand side,\n+except that `$` need only be followed by the name of the syntactic fragment\n+to transcribe.\n+\n+The right-hand side must be surrounded by delimiters of some kind, and must be\n+an expression; currently, user-defined macros can only be invoked in\n+expression position (even though `macro_rules!` itself can be in item\n+position).\n+\n+## Multiplicity\n+\n+### Invocation\n+\n+Going back to the motivating example, suppose that we wanted each invocation\n+of `early_return` to potentially accept multiple \"special\" identifiers. The\n+syntax `$(...)*` accepts zero or more occurences of its contents, much like\n+the Kleene star operator in regular expressions. It also supports a separator\n+token (a comma-separated list could be written `$(...),*`), and `+` instead of\n+`*` to mean \"at least one\".\n+\n+~~~~\n+# enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n+# fn f() -> uint {\n+# let input_1 = special_a(0), input_2 = special_a(0);\n+macro_rules! early_return(\n+    ($inp:expr, [ $($sp:ident)|+ ]) => (\n+        match $inp {\n+            $(\n+                $sp(x) => { return x; }\n+            )+\n+            _ => {}\n+        }\n+    );\n+);\n+// ...\n+early_return!(input_1, [special_a|special_c|special_d]);\n+// ...\n+early_return!(input_2, [special_b]);\n+# return 0;\n+# }\n+~~~~\n+\n+### Transcription\n+\n+As the above example demonstrates, `$(...)*` is also valid on the right-hand\n+side of a macro definition. The behavior of Kleene star in transcription,\n+especially in cases where multiple stars are nested, and multiple different\n+names are involved, can seem somewhat magical and intuitive at first. The\n+system that interprets them is called \"Macro By Example\". The two rules to\n+keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n+of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n+`$name` must be under at least as many `$(...)*`s as it was matched against.\n+If it is under more, it'll will be repeated, as appropriate.\n+\n+## Parsing limitations\n+\n+The parser used by the macro system is reasonably powerful, but the parsing of\n+Rust syntax is restricted in two ways:\n+\n+1. The parser will always parse as much as possible. For example, if the comma\n+were omitted from the syntax of `early_return!` above, `input_1 [` would've\n+been interpreted as the beginning of an array index. In fact, invoking the\n+macro would have been impossible.\n+2. The parser must have eliminated all ambiguity by the time it reaches a\n+`$name:fragment_specifier`. This most often affects them when they occur in\n+the beginning of, or immediately after, a `$(...)*`; requiring a distinctive\n+token in front can solve the problem.\n+\n+## A final note\n+\n+Macros, as currently implemented, are not for the faint of heart. Even\n+ordinary syntax errors can be more difficult to debug when they occur inside\n+a macro, and errors caused by parse problems in generated code can be very\n+tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n+states, using `trace_macros!(true)` will automatically print those\n+intermediate states out, and using `--pretty expanded` as an argument to the\n+compiler will show the result of expansion.\n+\n+"}, {"sha": "11a857cfd1b6b78f61589fb6fd7daa5b725601e0", "filename": "doc/tutorial.md", "status": "modified", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/69b363e02a29184641789598877409844736a7a1/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/69b363e02a29184641789598877409844736a7a1/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=69b363e02a29184641789598877409844736a7a1", "patch": "@@ -1897,157 +1897,6 @@ This makes it possible to rebind a variable without actually mutating\n it, which is mostly useful for destructuring (which can rebind, but\n not assign).\n \n-# Macros\n-\n-Functions are the programmer's primary tool of abstraction, but there are\n-cases in which they are insufficient, because the programmer wants to\n-abstract over concepts not represented as values. Consider the following\n-example:\n-\n-~~~~\n-# enum t { special_a(uint), special_b(uint) };\n-# fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n-match input_1 {\n-    special_a(x) => { return x; }\n-    _ => {}\n-}\n-// ...\n-match input_2 {\n-    special_b(x) => { return x; }\n-    _ => {}\n-}\n-# return 0u;\n-# }\n-~~~~\n-\n-This code could become tiresome if repeated many times. However, there is\n-no reasonable function that could be written to solve this problem. In such a\n-case, it's possible to define a macro to solve the problem. Macros are\n-lightweight custom syntax extensions, themselves defined using the\n-`macro_rules!` syntax extension:\n-\n-~~~~\n-# enum t { special_a(uint), special_b(uint) };\n-# fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n-macro_rules! early_return(\n-    ($inp:expr $sp:ident) => ( //invoke it like `(input_5 special_e)`\n-        match $inp {\n-            $sp(x) => { return x; }\n-            _ => {}\n-        }\n-    );\n-);\n-// ...\n-early_return!(input_1 special_a);\n-// ...\n-early_return!(input_2 special_b);\n-# return 0;\n-# }\n-~~~~\n-\n-Macros are defined in pattern-matching style:\n-\n-## Invocation syntax\n-\n-On the left-hand-side of the `=>` is the macro invocation syntax. It is\n-free-form, excepting the following rules:\n-\n-1. It must be surrounded in parentheses.\n-2. `$` has special meaning.\n-3. The `()`s, `[]`s, and `{}`s it contains must balance. For example, `([)` is\n-forbidden.\n-\n-To take as an argument a fragment of Rust code, write `$` followed by a name\n- (for use on the right-hand side), followed by a `:`, followed by the sort of\n-fragment to match (the most common ones are `ident`, `expr`, `ty`, `pat`, and\n-`block`). Anything not preceeded by a `$` is taken literally. The standard\n-rules of tokenization apply,\n-\n-So `($x:ident => (($e:expr)))`, though excessively fancy, would create a macro\n-that could be invoked like `my_macro!(i=>(( 2+2 )))`.\n-\n-## Transcription syntax\n-\n-The right-hand side of the `=>` follows the same rules as the left-hand side,\n-except that `$` need only be followed by the name of the syntactic fragment\n-to transcribe.\n-\n-The right-hand side must be surrounded by delimiters of some kind, and must be\n-an expression; currently, user-defined macros can only be invoked in\n-expression position (even though `macro_rules!` itself can be in item\n-position).\n-\n-## Multiplicity\n-\n-### Invocation\n-\n-Going back to the motivating example, suppose that we wanted each invocation\n-of `early_return` to potentially accept multiple \"special\" identifiers. The\n-syntax `$(...)*` accepts zero or more occurences of its contents, much like\n-the Kleene star operator in regular expressions. It also supports a separator\n-token (a comma-separated list could be written `$(...),*`), and `+` instead of\n-`*` to mean \"at least one\".\n-\n-~~~~\n-# enum t { special_a(uint),special_b(uint),special_c(uint),special_d(uint)};\n-# fn f() -> uint {\n-# let input_1 = special_a(0), input_2 = special_a(0);\n-macro_rules! early_return(\n-    ($inp:expr, [ $($sp:ident)|+ ]) => (\n-        match $inp {\n-            $(\n-                $sp(x) => { return x; }\n-            )+\n-            _ => {}\n-        }\n-    );\n-);\n-// ...\n-early_return!(input_1, [special_a|special_c|special_d]);\n-// ...\n-early_return!(input_2, [special_b]);\n-# return 0;\n-# }\n-~~~~\n-\n-### Transcription\n-\n-As the above example demonstrates, `$(...)*` is also valid on the right-hand\n-side of a macro definition. The behavior of Kleene star in transcription,\n-especially in cases where multiple stars are nested, and multiple different\n-names are involved, can seem somewhat magical and intuitive at first. The\n-system that interprets them is called \"Macro By Example\". The two rules to\n-keep in mind are (1) the behavior of `$(...)*` is to walk through one \"layer\"\n-of repetitions for all of the `$name`s it contains in lockstep, and (2) each\n-`$name` must be under at least as many `$(...)*`s as it was matched against.\n-If it is under more, it'll will be repeated, as appropriate.\n-\n-## Parsing limitations\n-\n-The parser used by the macro system is reasonably powerful, but the parsing of\n-Rust syntax is restricted in two ways:\n-\n-1. The parser will always parse as much as possible. For example, if the comma\n-were omitted from the syntax of `early_return!` above, `input_1 [` would've\n-been interpreted as the beginning of an array index. In fact, invoking the\n-macro would have been impossible.\n-2. The parser must have eliminated all ambiguity by the time it reaches a\n-`$name:fragment_specifier`. This most often affects them when they occur in\n-the beginning of, or immediately after, a `$(...)*`; requiring a distinctive\n-token in front can solve the problem.\n-\n-## A final note\n-\n-Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside\n-a macro, and errors caused by parse problems in generated code can be very\n-tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, using `trace_macros!(true)` will automatically print those\n-intermediate states out, and using `--pretty expanded` as an argument to the\n-compiler will show the result of expansion.\n-\n # Traits\n \n Traits are Rust's take on value polymorphism\u2014the thing that"}, {"sha": "0b278a86a8af18a57657ec8c9c1ec5fb7c228fe7", "filename": "mk/docs.mk", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69b363e02a29184641789598877409844736a7a1/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/69b363e02a29184641789598877409844736a7a1/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=69b363e02a29184641789598877409844736a7a1", "patch": "@@ -82,6 +82,17 @@ doc/tutorial.html: tutorial.md doc/version_info.html doc/rust.css\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-macros.html\n+doc/tutorial-macros.html: tutorial-macros.md doc/version_info.html \\\n+\t\t\t\t\t\t  doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n   endif\n endif\n "}]}