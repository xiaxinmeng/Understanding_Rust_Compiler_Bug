{"sha": "56ceebf86978a783d3607f40d9b993306254817b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2Y2VlYmY4Njk3OGE3ODNkMzYwN2Y0MGQ5Yjk5MzMwNjI1NDgxN2I=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-01-07T03:05:08Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-01-07T03:05:08Z"}, "message": "Update for changed in Rust master.", "tree": {"sha": "9d79e6c1800bf949f651acd85f461e6480760b19", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d79e6c1800bf949f651acd85f461e6480760b19"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56ceebf86978a783d3607f40d9b993306254817b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56ceebf86978a783d3607f40d9b993306254817b", "html_url": "https://github.com/rust-lang/rust/commit/56ceebf86978a783d3607f40d9b993306254817b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56ceebf86978a783d3607f40d9b993306254817b/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01c10e23a7491ee5121c1510cf53636ff1d5239a", "url": "https://api.github.com/repos/rust-lang/rust/commits/01c10e23a7491ee5121c1510cf53636ff1d5239a", "html_url": "https://github.com/rust-lang/rust/commit/01c10e23a7491ee5121c1510cf53636ff1d5239a"}], "stats": {"total": 60, "additions": 34, "deletions": 26}, "files": [{"sha": "10c9ef7dbd1cf7f0c77d993fb966324dd53cb79b", "filename": "src/interpreter.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/56ceebf86978a783d3607f40d9b993306254817b/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ceebf86978a783d3607f40d9b993306254817b/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=56ceebf86978a783d3607f40d9b993306254817b", "patch": "@@ -57,7 +57,10 @@ impl Pointer {\n /// ```\n #[derive(Debug)]\n struct Frame {\n-    return_ptr: Pointer,\n+    /// A pointer to a stack cell to write the return value of the current call, if it's not a\n+    /// divering call.\n+    return_ptr: Option<Pointer>,\n+\n     offset: usize,\n     num_args: usize,\n     num_vars: usize,\n@@ -100,7 +103,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn push_stack_frame(&mut self, mir: &Mir, args: &[Value], return_ptr: Pointer) {\n+    fn push_stack_frame(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n         let frame = Frame {\n             return_ptr: return_ptr,\n             offset: self.value_stack.len(),\n@@ -134,11 +137,12 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         ptr\n     }\n \n-    fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Pointer) {\n+    fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n         self.push_stack_frame(mir, args, return_ptr);\n         let mut block = mir::START_BLOCK;\n \n         loop {\n+            if TRACE_EXECUTION { println!(\"Entering block: {:?}\", block); }\n             let block_data = mir.basic_block_data(block);\n \n             for stmt in &block_data.statements {\n@@ -157,16 +161,14 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 }\n             }\n \n-            if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator); }\n+            if TRACE_EXECUTION { println!(\"{:?}\", block_data.terminator()); }\n \n-            match block_data.terminator {\n+            match *block_data.terminator() {\n                 mir::Terminator::Return => break,\n                 mir::Terminator::Goto { target } => block = target,\n \n-                mir::Terminator::Call { ref data, targets: (success_target, _panic_target) } => {\n-                    let mir::CallData { ref destination, ref func, ref args } = *data;\n-\n-                    let ptr = self.eval_lvalue(destination);\n+                mir::Terminator::Call { ref func, ref args, ref kind } => {\n+                    let ptr = kind.destination().map(|dest| self.eval_lvalue(&dest));\n                     let func_val = self.eval_operand(func);\n \n                     if let Value::Func(def_id) = func_val {\n@@ -184,7 +186,13 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                             args.iter().map(|arg| self.eval_operand(arg)).collect();\n \n                         self.call(mir, &arg_vals, ptr);\n-                        block = success_target\n+\n+                        match *kind {\n+                            mir::CallKind::Converging { target: success_target, .. } |\n+                            mir::CallKind::ConvergingCleanup { targets: (success_target, _), .. }\n+                            => { block = success_target; }\n+                            _ => {}\n+                        }\n                     } else {\n                         panic!(\"tried to call a non-function value: {:?}\", func_val);\n                     }\n@@ -217,8 +225,7 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                     }\n                 }\n \n-                // mir::Terminator::Diverge => unimplemented!(),\n-                // mir::Terminator::Panic { target } => unimplemented!(),\n+                // mir::Terminator::Resume => unimplemented!(),\n                 _ => unimplemented!(),\n             }\n         }\n@@ -230,7 +237,8 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         let frame = self.call_stack.last().expect(\"missing call frame\");\n \n         match *lvalue {\n-            mir::Lvalue::ReturnPointer => frame.return_ptr,\n+            mir::Lvalue::ReturnPointer =>\n+                frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n             mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i as usize)),\n             mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i as usize)),\n             mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i as usize)),\n@@ -405,7 +413,7 @@ pub fn interpret_start_points<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &MirMap<'tcx>\n \n                 let mut interpreter = Interpreter::new(tcx, mir_map);\n                 let return_ptr = Pointer::Stack(0);\n-                interpreter.call(mir, &[], return_ptr);\n+                interpreter.call(mir, &[], Some(return_ptr));\n \n                 let val_str = format!(\"{:?}\", interpreter.read_pointer(return_ptr));\n                 if !check_expected(&val_str, attr) {"}, {"sha": "301bbad3d8935767a1f463efc0632b218cbe61b9", "filename": "test/basic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/56ceebf86978a783d3607f40d9b993306254817b/test%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56ceebf86978a783d3607f40d9b993306254817b/test%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fbasic.rs?ref=56ceebf86978a783d3607f40d9b993306254817b", "patch": "@@ -122,18 +122,18 @@ fn basic_ref_mut_var() -> i32 {\n     a\n }\n \n-// #[miri_run(expected = \"Int(4)\")]\n-// fn match_int_range() -> i32 {\n-//     let n = 42;\n-//     match n {\n-//         0...9 => 0,\n-//         10...19 => 1,\n-//         20...29 => 2,\n-//         30...39 => 3,\n-//         40...49 => 4,\n-//         _ => 5,\n-//     }\n-// }\n+#[miri_run(expected = \"Int(4)\")]\n+fn match_int_range() -> i32 {\n+    let n = 42;\n+    match n {\n+        0...9 => 0,\n+        10...19 => 1,\n+        20...29 => 2,\n+        30...39 => 3,\n+        40...49 => 4,\n+        _ => 5,\n+    }\n+}\n \n enum MyOption<T> {\n     Some { data: T },"}]}