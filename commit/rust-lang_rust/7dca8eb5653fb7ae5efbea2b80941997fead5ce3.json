{"sha": "7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkY2E4ZWI1NjUzZmI3YWU1ZWZiZWEyYjgwOTQxOTk3ZmVhZDVjZTM=", "commit": {"author": {"name": "Kornel", "email": "kornel@geekhood.net", "date": "2021-08-07T11:51:58Z"}, "committer": {"name": "Kornel", "email": "kornel@geekhood.net", "date": "2021-08-07T13:48:27Z"}, "message": "Use assert_matches! instead of if let {} else", "tree": {"sha": "7fc0a868920125abcd93a120519a16f4909bf8a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fc0a868920125abcd93a120519a16f4909bf8a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "html_url": "https://github.com/rust-lang/rust/commit/7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/comments", "author": {"login": "kornelski", "id": 72159, "node_id": "MDQ6VXNlcjcyMTU5", "avatar_url": "https://avatars.githubusercontent.com/u/72159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kornelski", "html_url": "https://github.com/kornelski", "followers_url": "https://api.github.com/users/kornelski/followers", "following_url": "https://api.github.com/users/kornelski/following{/other_user}", "gists_url": "https://api.github.com/users/kornelski/gists{/gist_id}", "starred_url": "https://api.github.com/users/kornelski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kornelski/subscriptions", "organizations_url": "https://api.github.com/users/kornelski/orgs", "repos_url": "https://api.github.com/users/kornelski/repos", "events_url": "https://api.github.com/users/kornelski/events{/privacy}", "received_events_url": "https://api.github.com/users/kornelski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kornelski", "id": 72159, "node_id": "MDQ6VXNlcjcyMTU5", "avatar_url": "https://avatars.githubusercontent.com/u/72159?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kornelski", "html_url": "https://github.com/kornelski", "followers_url": "https://api.github.com/users/kornelski/followers", "following_url": "https://api.github.com/users/kornelski/following{/other_user}", "gists_url": "https://api.github.com/users/kornelski/gists{/gist_id}", "starred_url": "https://api.github.com/users/kornelski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kornelski/subscriptions", "organizations_url": "https://api.github.com/users/kornelski/orgs", "repos_url": "https://api.github.com/users/kornelski/repos", "events_url": "https://api.github.com/users/kornelski/events{/privacy}", "received_events_url": "https://api.github.com/users/kornelski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "215712283f044b902ef36f792e7360bb7690a65b", "url": "https://api.github.com/repos/rust-lang/rust/commits/215712283f044b902ef36f792e7360bb7690a65b", "html_url": "https://github.com/rust-lang/rust/commit/215712283f044b902ef36f792e7360bb7690a65b"}], "stats": {"total": 582, "additions": 281, "deletions": 301}, "files": [{"sha": "8fca2662fc3047d7c50d0e3a627122b15d2df322", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "patch": "@@ -1,4 +1,5 @@\n #![feature(allocator_api)]\n+#![feature(assert_matches)]\n #![feature(box_syntax)]\n #![feature(cow_is_borrowed)]\n #![feature(const_cow_is_borrowed)]"}, {"sha": "7be137131ff0100d4feac67e7203c6e8edd1a53d", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 73, "deletions": 80, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::collections::TryReserveErrorKind::*;\n@@ -713,35 +714,32 @@ fn test_try_reserve() {\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) =\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -756,23 +754,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n \n@@ -801,33 +800,29 @@ fn test_try_reserve_exact() {\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n-\n-            if let Err(CapacityOverflow) =\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n+\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n+\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -845,25 +840,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n "}, {"sha": "c2df50b48f55d9c2176d35890554875e77daa9a6", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 103, "deletions": 113, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::collections::TryReserveErrorKind::*;\n@@ -1488,34 +1489,32 @@ fn test_try_reserve() {\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1530,23 +1529,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1562,25 +1562,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\");\n-        }\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n \n@@ -1609,33 +1608,29 @@ fn test_try_reserve_exact() {\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n-\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n+\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n \n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1653,25 +1648,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1688,26 +1681,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) =\n-            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n-        {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n+        }\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n "}, {"sha": "ddfb4c00c2698fdc635219a2be033073264007a6", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 92, "deletions": 99, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n@@ -1181,28 +1182,28 @@ fn test_try_reserve() {\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1217,23 +1218,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1249,25 +1251,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\");\n-        }\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n \n@@ -1296,30 +1297,27 @@ fn test_try_reserve_exact() {\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n-\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n+\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1337,25 +1335,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1372,26 +1368,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) =\n-            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n "}, {"sha": "d9b20aee2d27f1e1b6fd7951976766db317ac6bc", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7dca8eb5653fb7ae5efbea2b80941997fead5ce3/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "patch": "@@ -1,6 +1,7 @@\n use super::Entry::{Occupied, Vacant};\n use super::HashMap;\n use super::RandomState;\n+use crate::assert_matches::assert_matches;\n use crate::cell::RefCell;\n use rand::{thread_rng, Rng};\n use realstd::collections::TryReserveErrorKind::*;\n@@ -821,15 +822,17 @@ fn test_try_reserve() {\n \n     const MAX_USIZE: usize = usize::MAX;\n \n-    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-    } else {\n-        panic!(\"usize::MAX should trigger an overflow!\");\n-    }\n-\n-    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8).map_err(|e| e.kind()) {\n-    } else {\n-        panic!(\"usize::MAX / 8 should trigger an OOM!\")\n-    }\n+    assert_matches!(\n+        empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+        Err(CapacityOverflow),\n+        \"usize::MAX should trigger an overflow!\"\n+    );\n+\n+    assert_matches!(\n+        empty_bytes.try_reserve(MAX_USIZE / 8).map_err(|e| e.kind()),\n+        Err(AllocError { .. }),\n+        \"usize::MAX / 8 should trigger an OOM!\"\n+    );\n }\n \n #[test]"}]}