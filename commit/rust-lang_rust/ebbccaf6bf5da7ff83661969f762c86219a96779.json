{"sha": "ebbccaf6bf5da7ff83661969f762c86219a96779", "node_id": "C_kwDOAAsO6NoAKGViYmNjYWY2YmY1ZGE3ZmY4MzY2MTk2OWY3NjJjODYyMTlhOTY3Nzk", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2022-02-01T03:07:08Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2022-02-05T19:15:18Z"}, "message": "Respond to review feedback, and improve implementation somewhat", "tree": {"sha": "45eee04636e32ed5c6f31bf2ee0dd46f84d52dd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45eee04636e32ed5c6f31bf2ee0dd46f84d52dd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebbccaf6bf5da7ff83661969f762c86219a96779", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0+qV0hta6XFe2D54u/UMJ4RyKgFAmH+zMYACgkQ4u/UMJ4R\nyKjIbw//eJZG7KP3M7qjiAX+uccrOlJPWdA7HFBbPtmm0r2MwSdHJJAXPbCpJM+R\nSWUVELQtVsc7khfIGk/fhp8rEJ6nXtYijSxcmT1eJakaK9ojQEt2YZWe09uvC7TR\nE66WxK+1luBSiGOFJb92YZIBcNFD/HOQTRBbnfNlAHVSTX+HkqFw3IVKEzONpkmK\npqF26O1oIgVL3yoNI8g+LpZLLpOo2tgFGEzbfsdlsyvm1qTcLJfPtJsTkSwuBHif\nrzjW0127or9hPxRD2G2EDcZR+zMYFFn2IS2Q/rIm85pO5xX1HkGx6fgZbbhnmfPt\nP1105c0cIFefol01u7ZNo+lb5ozdiCEvS+MfanJcanFqBeBNHLqfD8sgbeX4Xe1o\ncBGKj/wfrorsidMVig+FKNXBheFRDZIbD77/9G+5JG6oxp1tKkeltpdgSnTBJoV7\nq9UJ426m5FXZC2H7WqqU9PVSCf12h8vALzppDAKSxuAJg53fUiTq/VHOxcpKiWyE\nyxD59axvJcKmEexCNjCzkhaaU4ZGtTu6qmIvTdPJ4yt8TfivS+AYnvUeQmnCZ2CD\nP3tWjttPWy6sj7u1XywaAldnM1kFB6xri3tbnhZAG6N3mK8713YAzMxHaZk25Dz4\n/MtxNgWkYVJp9jpphfLUMZl2sZgMO7Vk0j1H8ug7vBpL6vv0QCU=\n=PcPw\n-----END PGP SIGNATURE-----", "payload": "tree 45eee04636e32ed5c6f31bf2ee0dd46f84d52dd3\nparent 002aaf2c65765408c8fddb7e3384d224f35fd1f1\nauthor Thom Chiovoloni <chiovolonit@gmail.com> 1643684828 -0800\ncommitter Thom Chiovoloni <chiovolonit@gmail.com> 1644088518 -0800\n\nRespond to review feedback, and improve implementation somewhat\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebbccaf6bf5da7ff83661969f762c86219a96779", "html_url": "https://github.com/rust-lang/rust/commit/ebbccaf6bf5da7ff83661969f762c86219a96779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebbccaf6bf5da7ff83661969f762c86219a96779/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "002aaf2c65765408c8fddb7e3384d224f35fd1f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/002aaf2c65765408c8fddb7e3384d224f35fd1f1", "html_url": "https://github.com/rust-lang/rust/commit/002aaf2c65765408c8fddb7e3384d224f35fd1f1"}], "stats": {"total": 87, "additions": 59, "deletions": 28}, "files": [{"sha": "25d9b2e299223dc6f8ec681ff699af1128178867", "filename": "library/core/benches/str/char_count.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebbccaf6bf5da7ff83661969f762c86219a96779/library%2Fcore%2Fbenches%2Fstr%2Fchar_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebbccaf6bf5da7ff83661969f762c86219a96779/library%2Fcore%2Fbenches%2Fstr%2Fchar_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fstr%2Fchar_count.rs?ref=ebbccaf6bf5da7ff83661969f762c86219a96779", "patch": "@@ -3,21 +3,25 @@ use test::{black_box, Bencher};\n \n macro_rules! define_benches {\n     ($( fn $name: ident($arg: ident: &str) $body: block )+) => {\n+        define_benches!(mod en_tiny, en::TINY, $($name $arg $body)+);\n         define_benches!(mod en_small, en::SMALL, $($name $arg $body)+);\n         define_benches!(mod en_medium, en::MEDIUM, $($name $arg $body)+);\n         define_benches!(mod en_large, en::LARGE, $($name $arg $body)+);\n         define_benches!(mod en_huge, en::HUGE, $($name $arg $body)+);\n \n+        define_benches!(mod zh_tiny, zh::TINY, $($name $arg $body)+);\n         define_benches!(mod zh_small, zh::SMALL, $($name $arg $body)+);\n         define_benches!(mod zh_medium, zh::MEDIUM, $($name $arg $body)+);\n         define_benches!(mod zh_large, zh::LARGE, $($name $arg $body)+);\n         define_benches!(mod zh_huge, zh::HUGE, $($name $arg $body)+);\n \n+        define_benches!(mod ru_tiny, ru::TINY, $($name $arg $body)+);\n         define_benches!(mod ru_small, ru::SMALL, $($name $arg $body)+);\n         define_benches!(mod ru_medium, ru::MEDIUM, $($name $arg $body)+);\n         define_benches!(mod ru_large, ru::LARGE, $($name $arg $body)+);\n         define_benches!(mod ru_huge, ru::HUGE, $($name $arg $body)+);\n \n+        define_benches!(mod emoji_tiny, emoji::TINY, $($name $arg $body)+);\n         define_benches!(mod emoji_small, emoji::SMALL, $($name $arg $body)+);\n         define_benches!(mod emoji_medium, emoji::MEDIUM, $($name $arg $body)+);\n         define_benches!(mod emoji_large, emoji::LARGE, $($name $arg $body)+);\n@@ -43,12 +47,12 @@ macro_rules! define_benches {\n }\n \n define_benches! {\n-    fn case00_cur_libcore(s: &str) {\n-        cur_libcore(s)\n+    fn case00_libcore(s: &str) {\n+        libcore(s)\n     }\n \n-    fn case01_old_libcore(s: &str) {\n-        old_libcore(s)\n+    fn case01_filter_count_cont_bytes(s: &str) {\n+        filter_count_cont_bytes(s)\n     }\n \n     fn case02_iter_increment(s: &str) {\n@@ -60,14 +64,16 @@ define_benches! {\n     }\n }\n \n-fn cur_libcore(s: &str) -> usize {\n+fn libcore(s: &str) -> usize {\n     s.chars().count()\n }\n+\n #[inline]\n fn utf8_is_cont_byte(byte: u8) -> bool {\n     (byte as i8) < -64\n }\n-fn old_libcore(s: &str) -> usize {\n+\n+fn filter_count_cont_bytes(s: &str) -> usize {\n     s.as_bytes().iter().filter(|&&byte| !utf8_is_cont_byte(byte)).count()\n }\n "}, {"sha": "b4ac625061dfa524bbe7522985fae02032316365", "filename": "library/core/benches/str/corpora.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebbccaf6bf5da7ff83661969f762c86219a96779/library%2Fcore%2Fbenches%2Fstr%2Fcorpora.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebbccaf6bf5da7ff83661969f762c86219a96779/library%2Fcore%2Fbenches%2Fstr%2Fcorpora.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fstr%2Fcorpora.rs?ref=ebbccaf6bf5da7ff83661969f762c86219a96779", "patch": "@@ -1,8 +1,9 @@\n //! Exposes a number of modules with different kinds of strings.\n //!\n-//! Each module contains `&str` constants named `SMALL`, `MEDIUM`, `LARGE`, and\n-//! `HUGE`.\n+//! Each module contains `&str` constants named `TINY`, `SMALL`, `MEDIUM`,\n+//! `LARGE`, and `HUGE`.\n //!\n+//! - The `TINY` string is generally around 8 bytes.\n //! - The `SMALL` string is generally around 30-40 bytes.\n //! - The `MEDIUM` string is generally around 600-700 bytes.\n //! - The `LARGE` string is the `MEDIUM` string repeated 8x, and is\u00a0around 5kb.\n@@ -27,6 +28,7 @@ macro_rules! define_consts {\n }\n \n pub mod en {\n+    pub const TINY: &str = \"Mary had\";\n     pub const SMALL: &str = \"Mary had a little lamb, Little lamb\";\n     define_consts! {\n         \"Rust is blazingly fast and memory-efficient: with no runtime or garbage\n@@ -42,6 +44,7 @@ pub mod en {\n }\n \n pub mod zh {\n+    pub const TINY: &str = \"\u901f\u5ea6\u60ca\";\n     pub const SMALL: &str = \"\u901f\u5ea6\u60ca\u4eba\u4e14\u5185\u5b58\u5229\u7528\u7387\u6781\u9ad8\";\n     define_consts! {\n         \"Rust   \u901f\u5ea6\u60ca\u4eba\u4e14\u5185\u5b58\u5229\u7528\u7387\u6781\u9ad8\u3002\u7531\u4e8e\\\n@@ -59,6 +62,7 @@ pub mod zh {\n }\n \n pub mod ru {\n+    pub const TINY: &str = \"\u0421\u043e\u0442\u043d\u0438\";\n     pub const SMALL: &str = \"\u0421\u043e\u0442\u043d\u0438 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0439 \u043f\u043e\";\n     define_consts! {\n         \"\u0421\u043e\u0442\u043d\u0438 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0439 \u043f\u043e \u0432\u0441\u0435\u043c\u0443 \u043c\u0438\u0440\u0443 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u044e\u0442 Rust \u0432 \u0440\u0435\u0430\u043b\u044c\u043d\u044b\u0445\\\n@@ -72,6 +76,7 @@ pub mod ru {\n }\n \n pub mod emoji {\n+    pub const TINY: &str = \"\ud83d\ude00\ud83d\ude03\";\n     pub const SMALL: &str = \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\ud83d\ude06\ud83d\ude05\ud83e\udd23\ud83d\ude02\ud83d\ude42\ud83d\ude43\ud83d\ude09\ud83d\ude0a\ud83d\ude07\ud83e\udd70\ud83d\ude0d\ud83e\udd29\ud83d\ude18\";\n     define_consts! {\n         \"\ud83d\ude00\ud83d\ude03\ud83d\ude04\ud83d\ude01\ud83d\ude06\ud83d\ude05\ud83e\udd23\ud83d\ude02\ud83d\ude42\ud83d\ude43\ud83d\ude09\ud83d\ude0a\ud83d\ude07\ud83e\udd70\ud83d\ude0d\ud83e\udd29\ud83d\ude18\ud83d\ude17\u263a\ud83d\ude1a\ud83d\ude19\ud83e\udd72\ud83d\ude0b\ud83d\ude1b\ud83d\ude1c\ud83e\udd2a\ud83d\ude1d\ud83e\udd11\ud83e\udd17\ud83e\udd2d\ud83e\udd2b\ud83e\udd14\ud83e\udd10\ud83e\udd28\ud83d\ude10\ud83d\ude11\ud83d\ude36\ud83d\ude36\u200d\ud83c\udf2b\ufe0f\ud83d\ude0f\ud83d\ude12\\"}, {"sha": "a80ebac734d78a9b8caaf46d75c8a48ac7e9cb55", "filename": "library/core/src/str/count.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ebbccaf6bf5da7ff83661969f762c86219a96779/library%2Fcore%2Fsrc%2Fstr%2Fcount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebbccaf6bf5da7ff83661969f762c86219a96779/library%2Fcore%2Fsrc%2Fstr%2Fcount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fcount.rs?ref=ebbccaf6bf5da7ff83661969f762c86219a96779", "patch": "@@ -17,39 +17,66 @@\n //! Note: Because the term \"leading byte\" can sometimes be ambiguous (for\n //! example, it could also refer to the first byte of a slice), we'll often use\n //! the term \"non-continuation byte\" to refer to these bytes in the code.\n+use core::intrinsics::unlikely;\n \n+const USIZE_SIZE: usize = core::mem::size_of::<usize>();\n+const UNROLL_INNER: usize = 4;\n+\n+#[inline]\n pub(super) fn count_chars(s: &str) -> usize {\n+    if s.len() < USIZE_SIZE * UNROLL_INNER {\n+        // Avoid entering the optimized implementation for strings where the\n+        // difference is not likely to matter, or where it might even be slower.\n+        // That said, a ton of thought was not spent on the particular threshold\n+        // here, beyond \"this value seems to make sense\".\n+        char_count_general_case(s.as_bytes())\n+    } else {\n+        do_count_chars(s)\n+    }\n+}\n+\n+fn do_count_chars(s: &str) -> usize {\n     // For correctness, `CHUNK_SIZE` must be:\n+    //\n     // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n     // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n     //   `body.chunks(CHUNK_SIZE)` loop.\n     //\n     // For performance, `CHUNK_SIZE` should be:\n-    // - Relatively cheap to `%` against.\n+    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n     // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n     //   too often.\n     const CHUNK_SIZE: usize = 192;\n-    const UNROLL_INNER: usize = 4;\n \n-    // Check the properties of `CHUNK_SIZE` / `UNROLL_INNER` that are required\n+    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n     // for correctness.\n-    const _: [(); 1] = [(); (CHUNK_SIZE < 256 && (CHUNK_SIZE % UNROLL_INNER) == 0) as usize];\n+    const _: () = assert!(CHUNK_SIZE < 256);\n+    const _: () = assert!(CHUNK_SIZE % UNROLL_INNER == 0);\n+\n     // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n     // differences which are handled by `align_to`.\n     let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n \n+    // This should be quite rare, and basically exists to handle the degenerate\n+    // cases where align_to fails (as well as miri under symbolic alignment\n+    // mode).\n+    //\n+    // The `unlikely` helps discourage LLVM from inlining the body, which is\n+    // nice, as we would rather not mark the `char_count_general_case` function\n+    // as cold.\n+    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n+        return char_count_general_case(s.as_bytes());\n+    }\n+\n     let mut total = char_count_general_case(head) + char_count_general_case(tail);\n     // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n     // we call `sum_bytes_in_usize`.\n     for chunk in body.chunks(CHUNK_SIZE) {\n         // We accumulate intermediate sums in `counts`, where each byte contains\n         // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n         let mut counts = 0;\n-        let unrolled_chunks = chunk.array_chunks::<UNROLL_INNER>();\n-        // If there's a remainder (know can only happen for the last item in\n-        // `chunks`, because `CHUNK_SIZE % UNROLL == 0`), then we need to\n-        // account for that (although we don't use it to later).\n-        let remainder = unrolled_chunks.remainder();\n+\n+        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n         for unrolled in unrolled_chunks {\n             for &word in unrolled {\n                 // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n@@ -85,8 +112,8 @@ pub(super) fn count_chars(s: &str) -> usize {\n // true)\n #[inline]\n fn contains_non_continuation_byte(w: usize) -> usize {\n-    let lsb = 0x0101_0101_0101_0101u64 as usize;\n-    ((!w >> 7) | (w >> 6)) & lsb\n+    const LSB: usize = 0x0101_0101_0101_0101u64 as usize;\n+    ((!w >> 7) | (w >> 6)) & LSB\n }\n \n // Morally equivalent to `values.to_ne_bytes().into_iter().sum::<usize>()`, but\n@@ -97,20 +124,13 @@ fn sum_bytes_in_usize(values: usize) -> usize {\n     const SKIP_BYTES: usize = 0x00ff_00ff_00ff_00ff_u64 as usize;\n \n     let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n-    pair_sum.wrapping_mul(LSB_SHORTS) >> ((core::mem::size_of::<usize>() - 2) * 8)\n+    pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)\n }\n \n // This is the most direct implementation of the concept of \"count the number of\n // bytes in the string which are not continuation bytes\", and is used for the\n // head and tail of the input string (the first and last item in the tuple\n // returned by `slice::align_to`).\n fn char_count_general_case(s: &[u8]) -> usize {\n-    const CONT_MASK_U8: u8 = 0b0011_1111;\n-    const TAG_CONT_U8: u8 = 0b1000_0000;\n-    let mut leads = 0;\n-    for &byte in s {\n-        let is_lead = (byte & !CONT_MASK_U8) != TAG_CONT_U8;\n-        leads += is_lead as usize;\n-    }\n-    leads\n+    s.iter().filter(|&&byte| !super::validations::utf8_is_cont_byte(byte)).count()\n }"}]}