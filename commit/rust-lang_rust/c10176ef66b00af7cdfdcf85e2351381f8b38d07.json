{"sha": "c10176ef66b00af7cdfdcf85e2351381f8b38d07", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMDE3NmVmNjZiMDBhZjdjZGZkY2Y4NWUyMzUxMzgxZjhiMzhkMDc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-15T15:40:16Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-15T15:40:16Z"}, "message": "trans: Only translate #[inline] functions if they are used somewhere.", "tree": {"sha": "2fcd00f8411f47d4c9ea17bb058349188ef135ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2fcd00f8411f47d4c9ea17bb058349188ef135ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c10176ef66b00af7cdfdcf85e2351381f8b38d07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c10176ef66b00af7cdfdcf85e2351381f8b38d07", "html_url": "https://github.com/rust-lang/rust/commit/c10176ef66b00af7cdfdcf85e2351381f8b38d07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c10176ef66b00af7cdfdcf85e2351381f8b38d07/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97b561a0944141a02a0cebe577c3c69e436abcf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/97b561a0944141a02a0cebe577c3c69e436abcf4", "html_url": "https://github.com/rust-lang/rust/commit/97b561a0944141a02a0cebe577c3c69e436abcf4"}], "stats": {"total": 112, "additions": 25, "deletions": 87}, "files": [{"sha": "fcfe53d0c8512789fbdcfa51c65eeef527b2d15e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c10176ef66b00af7cdfdcf85e2351381f8b38d07", "patch": "@@ -1591,7 +1591,11 @@ pub fn filter_reachable_ids(tcx: TyCtxt, reachable: NodeSet) -> NodeSet {\n                 node: hir::ImplItemKind::Method(..), .. }) => {\n                 let def_id = tcx.map.local_def_id(id);\n                 let generics = tcx.lookup_generics(def_id);\n-                generics.parent_types == 0 && generics.types.is_empty()\n+                let attributes = tcx.get_attrs(def_id);\n+                (generics.parent_types == 0 && generics.types.is_empty()) &&\n+                // Functions marked with #[inline] are only ever translated\n+                // with \"internal\" linkage and are never exported.\n+                !attr::requests_inline(&attributes[..])\n             }\n \n             _ => false"}, {"sha": "f193c0482f70943c5414b913579794f77423f39f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c10176ef66b00af7cdfdcf85e2351381f8b38d07", "patch": "@@ -401,7 +401,7 @@ fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n-        trans_item.is_from_extern_crate() || trans_item.requests_inline(tcx)\n+        trans_item.needs_local_copy(tcx)\n     };\n \n     let inlining_candidates = callees.into_iter()"}, {"sha": "798e883c9557c452ca56d06ac8555b02a679a0f1", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 1, "deletions": 70, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c10176ef66b00af7cdfdcf85e2351381f8b38d07", "patch": "@@ -261,12 +261,6 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n {\n     let tcx = scx.tcx();\n \n-    if let PartitioningStrategy::FixedUnitCount(1) = strategy {\n-        // If there is only a single codegen-unit, we can use a very simple\n-        // scheme and don't have to bother with doing much analysis.\n-        return vec![single_codegen_unit(tcx, trans_items, reachable)];\n-    }\n-\n     // In the first step, we place all regular translation items into their\n     // respective 'home' codegen unit. Regular translation items are all\n     // functions and statics defined in the local crate.\n@@ -320,7 +314,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut codegen_units = FnvHashMap();\n \n     for trans_item in trans_items {\n-        let is_root = !trans_item.is_instantiated_only_on_demand();\n+        let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n \n         if is_root {\n             let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n@@ -454,7 +448,6 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n                 // reliably in that case.\n                 new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             } else {\n-                assert!(trans_item.is_instantiated_only_on_demand());\n                 // We can't be sure if this will also be instantiated\n                 // somewhere else, so we add an instance here with\n                 // InternalLinkage so we don't get any conflicts.\n@@ -550,68 +543,6 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return token::intern_and_get_ident(&mod_path[..]);\n }\n \n-fn single_codegen_unit<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    trans_items: I,\n-                                    reachable: &NodeSet)\n-                                    -> CodegenUnit<'tcx>\n-    where I: Iterator<Item = TransItem<'tcx>>\n-{\n-    let mut items = FnvHashMap();\n-\n-    for trans_item in trans_items {\n-        let linkage = trans_item.explicit_linkage(tcx).unwrap_or_else(|| {\n-            match trans_item {\n-                TransItem::Static(node_id) => {\n-                    if reachable.contains(&node_id) {\n-                        llvm::ExternalLinkage\n-                    } else {\n-                        llvm::PrivateLinkage\n-                    }\n-                }\n-                TransItem::DropGlue(_) => {\n-                    llvm::InternalLinkage\n-                }\n-                TransItem::Fn(instance) => {\n-                    if trans_item.is_generic_fn() {\n-                        // FIXME(mw): Assigning internal linkage to all\n-                        // monomorphizations is potentially a waste of space\n-                        // since monomorphizations could be shared between\n-                        // crates. The main reason for making them internal is\n-                        // a limitation in MingW's binutils that cannot deal\n-                        // with COFF object that have more than 2^15 sections,\n-                        // which is something that can happen for large programs\n-                        // when every function gets put into its own COMDAT\n-                        // section.\n-                        llvm::InternalLinkage\n-                    } else if trans_item.is_from_extern_crate() {\n-                        // FIXME(mw): It would be nice if we could mark these as\n-                        // `AvailableExternallyLinkage`, since they should have\n-                        // been instantiated in the extern crate. But this\n-                        // sometimes leads to crashes on Windows because LLVM\n-                        // does not handle exception handling table instantiation\n-                        // reliably in that case.\n-                        llvm::InternalLinkage\n-                    } else if reachable.contains(&tcx.map\n-                                                     .as_local_node_id(instance.def)\n-                                                     .unwrap()) {\n-                        llvm::ExternalLinkage\n-                    } else {\n-                        // Functions that are not visible outside this crate can\n-                        // be marked as internal.\n-                        llvm::InternalLinkage\n-                    }\n-                }\n-            }\n-        });\n-\n-        items.insert(trans_item, linkage);\n-    }\n-\n-    CodegenUnit::new(\n-        numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n-        items)\n-}\n-\n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n     token::intern_and_get_ident(&format!(\"{}{}{}\",\n         crate_name,"}, {"sha": "bde393b77e167fc4ffa12e0cd2bbaddca659b879", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c10176ef66b00af7cdfdcf85e2351381f8b38d07/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=c10176ef66b00af7cdfdcf85e2351381f8b38d07", "patch": "@@ -241,19 +241,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                instance.substs.types().next().is_some() || {\n-                    let attributes = tcx.get_attrs(instance.def);\n-                    attr::requests_inline(&attributes[..])\n-                }\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n     pub fn is_from_extern_crate(&self) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => !instance.def.is_local(),\n@@ -262,10 +249,14 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    pub fn is_instantiated_only_on_demand(&self) -> bool {\n+    /// True if the translation item should only be translated to LLVM IR if\n+    /// it is referenced somewhere (like inline functions, for example).\n+    pub fn is_instantiated_only_on_demand(&self, tcx: TyCtxt) -> bool {\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.def.is_local() || instance.substs.types().next().is_some()\n+                !instance.def.is_local() ||\n+                instance.substs.types().next().is_some() ||\n+                attr::requests_inline(&tcx.get_attrs(instance.def)[..])\n             }\n             TransItem::DropGlue(..) => true,\n             TransItem::Static(..)   => false,\n@@ -282,6 +273,18 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n+    /// Returns true if there has to be a local copy of this TransItem in every\n+    /// codegen unit that references it (as with inlined functions, for example)\n+    pub fn needs_local_copy(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        // Currently everything that is instantiated only on demand is done so\n+        // with \"internal\" linkage, so we need a copy to be present in every\n+        // codegen unit.\n+        // This is coincidental: We could also instantiate something only if it\n+        // is referenced (e.g. a regular, private function) but place it in its\n+        // own codegen unit with \"external\" linkage.\n+        self.is_instantiated_only_on_demand(tcx)\n+    }\n+\n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,"}]}