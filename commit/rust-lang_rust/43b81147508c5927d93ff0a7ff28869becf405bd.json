{"sha": "43b81147508c5927d93ff0a7ff28869becf405bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYjgxMTQ3NTA4YzU5MjdkOTNmZjBhN2ZmMjg4NjliZWNmNDA1YmQ=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-31T20:27:08Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-02T03:08:01Z"}, "message": "Linked failure: Rewrite to use ancestor_list and send_map for proper-propagation. (tag #3068, #2190, #1868)", "tree": {"sha": "5226d93d3bc746c30bbb42f0df4d69c5abe0b1b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5226d93d3bc746c30bbb42f0df4d69c5abe0b1b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43b81147508c5927d93ff0a7ff28869becf405bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43b81147508c5927d93ff0a7ff28869becf405bd", "html_url": "https://github.com/rust-lang/rust/commit/43b81147508c5927d93ff0a7ff28869becf405bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43b81147508c5927d93ff0a7ff28869becf405bd/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d8c7fd096c4b1551945e22b00266586a929b39c", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d8c7fd096c4b1551945e22b00266586a929b39c", "html_url": "https://github.com/rust-lang/rust/commit/2d8c7fd096c4b1551945e22b00266586a929b39c"}], "stats": {"total": 582, "additions": 396, "deletions": 186}, "files": [{"sha": "60ea14cf63743b72d72538bfdbfc226fd119e692", "filename": "src/libcore/task.rs", "status": "modified", "additions": 396, "deletions": 186, "changes": 582, "blob_url": "https://github.com/rust-lang/rust/blob/43b81147508c5927d93ff0a7ff28869becf405bd/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43b81147508c5927d93ff0a7ff28869becf405bd/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=43b81147508c5927d93ff0a7ff28869becf405bd", "patch": "@@ -598,30 +598,222 @@ type rust_closure = libc::c_void;\n \n /* linked failure */\n \n-type taskgroup_arc =\n-    arc::exclusive<option<(dvec::dvec<option<*rust_task>>,dvec::dvec<uint>)>>;\n+type taskset = send_map::linear::linear_map<*rust_task,()>;\n \n+fn new_taskset() -> taskset {\n+    pure fn task_hash(t: &*rust_task) -> uint {\n+        let task: *rust_task = *t;\n+        hash::hash_uint(task as uint) as uint\n+    }\n+    pure fn task_eq(t1: &*rust_task, t2: &*rust_task) -> bool {\n+        let task1: *rust_task = *t1;\n+        let task2: *rust_task = *t2;\n+        task1 == task2\n+    }\n+\n+    send_map::linear::linear_map(task_hash, task_eq)\n+}\n+fn taskset_insert(tasks: &mut taskset, task: *rust_task) {\n+    let didnt_overwrite = tasks.insert(task, ());\n+    assert didnt_overwrite;\n+}\n+fn taskset_remove(tasks: &mut taskset, task: *rust_task) {\n+    let was_present = tasks.remove(&task);\n+    assert was_present;\n+}\n+fn taskset_each(tasks: &taskset, blk: fn(+*rust_task) -> bool) {\n+    tasks.each_key(blk)\n+}\n+\n+// One of these per group of linked-failure tasks.\n+type taskgroup_data = {\n+    // All tasks which might kill this group. When this is empty, the group\n+    // can be \"GC\"ed (i.e., its link in the ancestor list can be removed).\n+    mut members:     taskset,\n+    // All tasks unidirectionally supervised by (directly or transitively)\n+    // tasks in this group.\n+    mut descendants: taskset,\n+};\n+type taskgroup_arc = arc::exclusive<option<taskgroup_data>>;\n+\n+type taskgroup_inner = &mut option<taskgroup_data>;\n+\n+fn taskgroup_is_dead(tg: taskgroup_data) -> bool {\n+    (&mut tg.members).is_empty()\n+}\n+\n+// A list-like structure by which taskgroups keep track of all ancestor groups\n+// which may kill them. Needed for tasks to be able to remove themselves from\n+// ancestor groups upon exit. The list has a node for each \"generation\", and\n+// ends either at the root taskgroup (which has no ancestors) or at a\n+// taskgroup which was spawned-unlinked. Tasks from intermediate generations\n+// have references to the middle of the list; when intermediate generations\n+// die, their node in the list will be collected at a descendant's spawn-time.\n+enum ancestor_list = option<arc::exclusive<{\n+    // Since the ancestor list is recursive, we end up with references to\n+    // exclusives within other exclusives. This is dangerous business (if\n+    // circular references arise, deadlock and memory leaks are imminent).\n+    // Hence we assert that this counter monotonically decreases as we\n+    // approach the tail of the list.\n+    // FIXME(#3068): Make the generation counter togglable with #[cfg(debug)].\n+    generation:       uint,\n+    // Should really be an immutable non-option. This way appeases borrowck.\n+    mut parent_group: option<taskgroup_arc>,\n+    // Recursive rest of the list.\n+    mut ancestors:    ancestor_list,\n+}>>;\n+\n+// Iterates over an ancestor list.\n+// (1) Runs forward_blk on each ancestral taskgroup in the list\n+// (2) If forward_blk \"break\"s, runs optional bail_blk on all ancestral\n+//     taskgroups that forward_blk already ran on successfully (Note: bail_blk\n+//     is NOT called on the block that forward_blk broke on!).\n+// (3) As a bonus, coalesces away all 'dead' taskgroup nodes in the list.\n+// FIXME(#2190): Change option<fn@(...)> to option<fn&(...)>, to save on\n+// allocations. Once that bug is fixed, changing the sigil should suffice.\n+fn each_ancestor(list:        &mut ancestor_list,\n+                 bail_opt:    option<fn@(taskgroup_inner)>,\n+                 forward_blk: fn(taskgroup_inner) -> bool)\n+        -> bool {\n+    // \"Kickoff\" call - there was no last generation.\n+    return !coalesce(list, bail_opt, forward_blk, uint::max_value);\n+\n+    // Recursively iterates, and coalesces afterwards if needed. Returns\n+    // whether or not unwinding is needed (i.e., !successful iteration).\n+    fn coalesce(list:            &mut ancestor_list,\n+                bail_opt:        option<fn@(taskgroup_inner)>,\n+                forward_blk:     fn(taskgroup_inner) -> bool,\n+                last_generation: uint) -> bool {\n+        // Need to swap the list out to use it, to appease borrowck.\n+        let mut tmp_list = ancestor_list(none);\n+        *list <-> tmp_list;\n+        let (coalesce_this, early_break) =\n+            iterate(tmp_list, bail_opt, forward_blk, last_generation);\n+        // What should our next ancestor end up being?\n+        if coalesce_this.is_some() {\n+            // Needed coalesce. Our next ancestor becomes our old\n+            // ancestor's next ancestor. (\"next = old_next->next;\")\n+            *list <- option::unwrap(coalesce_this);\n+        } else {\n+            // No coalesce; restore from tmp. (\"next = old_next;\")\n+            *list <- tmp_list;\n+        }\n+        return early_break;\n+    }\n+\n+    // Returns an optional list-to-coalesce and whether unwinding is needed.\n+    // option<ancestor_list>:\n+    //     Whether or not the ancestor taskgroup being iterated over is\n+    //     dead or not; i.e., it has no more tasks left in it, whether or not\n+    //     it has descendants. If dead, the caller shall coalesce it away.\n+    // bool:\n+    //     True if the supplied block did 'break', here or in any recursive\n+    //     calls. If so, must call the unwinder on all previous nodes.\n+    fn iterate(ancestors:       ancestor_list,\n+               bail_opt:        option<fn@(taskgroup_inner)>,\n+               forward_blk:     fn(taskgroup_inner) -> bool,\n+               last_generation: uint) -> (option<ancestor_list>, bool) {\n+        // At each step of iteration, three booleans are at play which govern\n+        // how the iteration should behave.\n+        // 'nobe_is_dead' - Should the list should be coalesced at this point?\n+        //                  Largely unrelated to the other two.\n+        // 'need_unwind'  - Should we run the bail_blk at this point? (i.e.,\n+        //                  do_continue was false not here, but down the line)\n+        // 'do_continue'  - Did the forward_blk succeed at this point? (i.e.,\n+        //                  should we recurse? or should our callers unwind?)\n+\n+        // The map defaults to none, because if ancestors is none, we're at\n+        // the end of the list, which doesn't make sense to coalesce.\n+        return do (*ancestors).map_default((none,false)) |ancestor_arc| {\n+            // NB: Takes a lock! (this ancestor node)\n+            do ancestor_arc.with |_c, nobe| {\n+                // Check monotonicity\n+                assert last_generation > nobe.generation;\n+                /*##########################################################*\n+                 * Step 1: Look at this ancestor group (call iterator block).\n+                 *##########################################################*/\n+                let mut nobe_is_dead = false;\n+                let do_continue =\n+                    // NB: Takes a lock! (this ancestor node's parent group)\n+                    do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n+                        // Decide whether this group is dead. Note that the\n+                        // group being *dead* is disjoint from it *failing*.\n+                        do tg_opt.iter |tg| {\n+                            nobe_is_dead = taskgroup_is_dead(tg);\n+                        }\n+                        // Call iterator block. (If the group is dead, it's\n+                        // safe to skip it. This will leave our *rust_task\n+                        // hanging around in the group even after it's freed,\n+                        // but that's ok because, by virtue of the group being\n+                        // dead, nobody will ever kill-all (foreach) over it.)\n+                        if nobe_is_dead { true } else { forward_blk(tg_opt) }\n+                    };\n+                /*##########################################################*\n+                 * Step 2: Recurse on the rest of the list; maybe coalescing.\n+                 *##########################################################*/\n+                // 'need_unwind' is only set if blk returned true above, *and*\n+                // the recursive call early-broke.\n+                let mut need_unwind = false;\n+                if do_continue {\n+                    // NB: Takes many locks! (ancestor nodes & parent groups)\n+                    need_unwind = coalesce(&mut nobe.ancestors, bail_opt,\n+                                           forward_blk, nobe.generation);\n+                }\n+                /*##########################################################*\n+                 * Step 3: Maybe unwind; compute return info for our caller.\n+                 *##########################################################*/\n+                if need_unwind && !nobe_is_dead {\n+                    do bail_opt.iter |bail_blk| {\n+                        do with_parent_tg(&mut nobe.parent_group) |tg_opt| {\n+                            bail_blk(tg_opt)\n+                        }\n+                    }\n+                }\n+                // Decide whether our caller should unwind.\n+                need_unwind = need_unwind || !do_continue;\n+                // Tell caller whether or not to coalesce and/or unwind\n+                if nobe_is_dead {\n+                    let mut rest = ancestor_list(none);\n+                    // Swap the list out here; the caller replaces us with it.\n+                    nobe.ancestors <-> rest;\n+                    (some(rest), need_unwind)\n+                } else {\n+                    (none, need_unwind)\n+                }\n+            }\n+        };\n+\n+        // Wrapper around exclusive::with that appeases borrowck.\n+        fn with_parent_tg<U>(parent_group: &mut option<taskgroup_arc>,\n+                             blk: fn(taskgroup_inner) -> U) -> U {\n+            let mut tmp = none;\n+            *parent_group <-> tmp;\n+            // If this trips, more likely the problem is 'blk' failed inside.\n+            assert tmp.is_some();\n+            let tmp_arc = option::unwrap(tmp);\n+            let result = do tmp_arc.with |_c, tg_opt| { blk(tg_opt) };\n+            *parent_group <- some(tmp_arc);\n+            result\n+        }\n+    }\n+}\n+\n+// One of these per task.\n class taskgroup {\n-    // FIXME (#2816): Change dvec to an O(1) data structure (and change 'me'\n-    // to a node-handle or somesuch when so done (or remove the field entirely\n-    // if keyed by *rust_task)).\n-    let me:         *rust_task;\n+    let me:            *rust_task;\n     // List of tasks with whose fates this one's is intertwined.\n-    let tasks:      taskgroup_arc; // 'none' means the group already failed.\n-    let my_pos:     uint;          // Index into above for this task's slot.\n+    let tasks:         taskgroup_arc; // 'none' means the group has failed.\n     // Lists of tasks who will kill us if they fail, but whom we won't kill.\n-    let parents:    option<(taskgroup_arc,uint)>;\n-    let is_main:    bool;\n-    let notifier:   option<auto_notify>;\n-    new(me: *rust_task, -tasks: taskgroup_arc, my_pos: uint,\n-        -parents: option<(taskgroup_arc,uint)>, is_main: bool,\n-        -notifier: option<auto_notify>) {\n-        self.me       = me;\n-        self.tasks    = tasks;\n-        self.my_pos   = my_pos;\n-        self.parents  = parents;\n-        self.is_main  = is_main;\n-        self.notifier = notifier;\n+    let mut ancestors: ancestor_list;\n+    let is_main:       bool;\n+    let notifier:      option<auto_notify>;\n+    new(me: *rust_task, -tasks: taskgroup_arc, -ancestors: ancestor_list,\n+        is_main: bool, -notifier: option<auto_notify>) {\n+        self.me        = me;\n+        self.tasks     = tasks;\n+        self.ancestors = ancestors;\n+        self.is_main   = is_main;\n+        self.notifier  = notifier;\n         self.notifier.iter(|x| { x.failed = false; });\n     }\n     // Runs on task exit.\n@@ -630,19 +822,21 @@ class taskgroup {\n         if rustrt::rust_task_is_unwinding(self.me) {\n             self.notifier.iter(|x| { x.failed = true; });\n             // Take everybody down with us.\n-            kill_taskgroup(self.tasks, self.me, self.my_pos, self.is_main);\n+            do self.tasks.with |_c, tg| {\n+                kill_taskgroup(tg, self.me, self.is_main);\n+            }\n         } else {\n             // Remove ourselves from the group(s).\n-            leave_taskgroup(self.tasks, self.me, self.my_pos);\n-        }\n-        // It doesn't matter whether this happens before or after dealing with\n-        // our own taskgroup, so long as both happen before we die.\n-        alt self.parents {\n-            some((parent_group,pos_in_group)) {\n-                leave_taskgroup(parent_group, self.me, pos_in_group);\n+            do self.tasks.with |_c, tg| {\n+                leave_taskgroup(tg, self.me, true);\n             }\n-            none { }\n         }\n+        // It doesn't matter whether this happens before or after dealing with\n+        // our own taskgroup, so long as both happen before we die. We need to\n+        // remove ourself from every ancestor we can, so no cleanup; no break.\n+        for each_ancestor(&mut self.ancestors, none) |ancestor_group| {\n+            leave_taskgroup(ancestor_group, self.me, false);\n+        };\n     }\n }\n \n@@ -659,85 +853,70 @@ class auto_notify {\n     }\n }\n \n-fn enlist_in_taskgroup(group_arc: taskgroup_arc,\n-                       me: *rust_task) -> option<uint> {\n-    do group_arc.with |_c, state| {\n-        // If 'none', the group was failing. Can't enlist.\n-        let mut newstate = none;\n-        *state <-> newstate;\n-        if newstate.is_some() {\n-            let (tasks,empty_slots) = option::unwrap(newstate);\n-            // Try to find an empty slot.\n-            let slotno = if empty_slots.len() > 0 {\n-                let empty_index = empty_slots.pop();\n-                assert tasks[empty_index] == none;\n-                tasks.set_elt(empty_index, some(me));\n-                empty_index\n-            } else {\n-                tasks.push(some(me));\n-                tasks.len() - 1\n-            };\n-            *state = some((tasks,empty_slots));\n-            some(slotno)\n-        } else {\n-            none\n-        }\n+fn enlist_in_taskgroup(state: taskgroup_inner, me: *rust_task,\n+                       is_member: bool) -> bool {\n+    let mut newstate = none;\n+    *state <-> newstate;\n+    // If 'none', the group was failing. Can't enlist.\n+    if newstate.is_some() {\n+        let group = option::unwrap(newstate);\n+        taskset_insert(if is_member { &mut group.members }\n+                       else         { &mut group.descendants }, me);\n+        *state = some(group);\n+        true\n+    } else {\n+        false\n     }\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn leave_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n-    do group_arc.with |_c, state| {\n-        let mut newstate = none;\n-        *state <-> newstate;\n-        // If 'none', already failing and we've already gotten a kill signal.\n-        if newstate.is_some() {\n-            let (tasks,empty_slots) = option::unwrap(newstate);\n-            assert tasks[index] == some(me);\n-            tasks.set_elt(index, none);\n-            empty_slots.push(index);\n-            *state = some((tasks,empty_slots));\n-        };\n-    };\n+fn leave_taskgroup(state: taskgroup_inner, me: *rust_task, is_member: bool) {\n+    let mut newstate = none;\n+    *state <-> newstate;\n+    // If 'none', already failing and we've already gotten a kill signal.\n+    if newstate.is_some() {\n+        let group = option::unwrap(newstate);\n+        taskset_remove(if is_member { &mut group.members }\n+                       else         { &mut group.descendants }, me);\n+        *state = some(group);\n+    }\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n-fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n-                  is_main: bool) {\n+fn kill_taskgroup(state: taskgroup_inner, me: *rust_task, is_main: bool) {\n     // NB: We could do the killing iteration outside of the group arc, by\n     // having \"let mut newstate\" here, swapping inside, and iterating after.\n     // But that would let other exiting tasks fall-through and exit while we\n     // were trying to kill them, causing potential use-after-free. A task's\n     // presence in the arc guarantees it's alive only while we hold the lock,\n     // so if we're failing, all concurrently exiting tasks must wait for us.\n-    // To do it differently, we'd have to use the runtime's task refcounting.\n-    do group_arc.with |_c, state| {\n-        let mut newstate = none;\n-        *state <-> newstate;\n-        // Might already be none, if somebody is failing simultaneously.\n-        // That's ok; only one task needs to do the dirty work. (Might also\n-        // see 'none' if somebody already failed and we got a kill signal.)\n-        if newstate.is_some() {\n-            let (tasks,_empty_slots) = option::unwrap(newstate);\n-            // First remove ourself (killing ourself won't do much good). This\n-            // is duplicated here to avoid having to lock twice.\n-            assert tasks[index] == some(me);\n-            tasks.set_elt(index, none);\n-            // Now send takedown signal.\n-            for tasks.each |entry| {\n-                do entry.map |task| {\n-                    rustrt::rust_task_kill_other(task);\n-                };\n-            }\n-            // Only one task should ever do this.\n-            if is_main {\n-                rustrt::rust_task_kill_all(me);\n+    // To do it differently, we'd have to use the runtime's task refcounting,\n+    // but that could leave task structs around long after their task exited.\n+    let mut newstate = none;\n+    *state <-> newstate;\n+    // Might already be none, if somebody is failing simultaneously.\n+    // That's ok; only one task needs to do the dirty work. (Might also\n+    // see 'none' if somebody already failed and we got a kill signal.)\n+    if newstate.is_some() {\n+        let group = option::unwrap(newstate);\n+        for taskset_each(&group.members) |+sibling| {\n+            // Skip self - killing ourself won't do much good.\n+            if sibling != me {\n+                rustrt::rust_task_kill_other(sibling);\n             }\n-            // Do NOT restore state to some(..)! It stays none to indicate\n-            // that the whole taskgroup is failing, to forbid new spawns.\n         }\n-        // (note: multiple tasks may reach this point)\n-    };\n+        for taskset_each(&group.descendants) |+child| {\n+            assert child != me;\n+            rustrt::rust_task_kill_other(child);\n+        }\n+        // Only one task should ever do this.\n+        if is_main {\n+            rustrt::rust_task_kill_all(me);\n+        }\n+        // Do NOT restore state to some(..)! It stays none to indicate\n+        // that the whole taskgroup is failing, to forbid new spawns.\n+    }\n+    // (note: multiple tasks may reach this point)\n }\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n@@ -747,64 +926,97 @@ unsafe fn taskgroup_key() -> local_data_key<taskgroup> {\n     unsafe::transmute((-2 as uint, 0u))\n }\n \n-// The 'linked' arg tells whether or not to also ref the unidirectionally-\n-// linked supervisors' group. False when the spawn is supervised, not linked.\n-fn share_spawner_taskgroup(linked: bool)\n-        -> (taskgroup_arc, option<taskgroup_arc>, bool) {\n-    let me = rustrt::rust_get_task();\n-    alt unsafe { local_get(me, taskgroup_key()) } {\n-        some(group) {\n-            // If they are linked to us, they share our parent group.\n-            let parent_arc_opt = if linked {\n-                group.parents.map(|x| alt x { (pg,_) { pg.clone() } })\n-            } else {\n-                none\n-            };\n-            // Clone the shared state for the child; propagate main-ness.\n-            (group.tasks.clone(), parent_arc_opt, group.is_main)\n-        }\n+fn gen_child_taskgroup(linked: bool, supervised: bool)\n+        -> (taskgroup_arc, ancestor_list, bool) {\n+    let spawner = rustrt::rust_get_task();\n+    /*######################################################################*\n+     * Step 1. Get spawner's taskgroup info.\n+     *######################################################################*/\n+    let spawner_group = alt unsafe { local_get(spawner, taskgroup_key()) } {\n         none {\n-            // Main task, doing first spawn ever.\n-            let tasks = arc::exclusive(some((dvec::from_elem(some(me)),\n-                                             dvec::dvec())));\n-            // Main group has no parent group.\n-            let group = @taskgroup(me, tasks.clone(), 0, none, true, none);\n-            unsafe { local_set(me, taskgroup_key(), group); }\n-            // Tell child task it's also in the main group.\n-            // Whether or not it wanted our parent group, we haven't got one.\n-            (tasks, none, true)\n+            // Main task, doing first spawn ever. Lazily initialise here.\n+            let mut members = new_taskset();\n+            taskset_insert(&mut members, spawner);\n+            let tasks =\n+                arc::exclusive(some({ mut members:     members,\n+                                      mut descendants: new_taskset() }));\n+            // Main task/group has no ancestors, no notifier, etc.\n+            let group =\n+                @taskgroup(spawner, tasks, ancestor_list(none), true, none);\n+            unsafe { local_set(spawner, taskgroup_key(), group); }\n+            group\n+        }\n+        some(group) { group }\n+    };\n+    //for each_ancestor(&mut spawner_group.ancestors, none) |_a| { };\n+    /*######################################################################*\n+     * Step 2. Process spawn options for child.\n+     *######################################################################*/\n+    return if linked {\n+        // Child is in the same group as spawner.\n+        let g = spawner_group.tasks.clone();\n+        // Child's ancestors are spawner's ancestors.\n+        let a = share_ancestors(&mut spawner_group.ancestors);\n+        // Propagate main-ness.\n+        (g, a, spawner_group.is_main)\n+    } else {\n+        // Child is in a separate group from spawner.\n+        let g = arc::exclusive(some({ mut members:     new_taskset(),\n+                                      mut descendants: new_taskset() }));\n+        let a = if supervised {\n+            // Child's ancestors start with the spawner.\n+            let old_ancestors = share_ancestors(&mut spawner_group.ancestors);\n+            // FIXME(#3068) - The generation counter is only used for a debug\n+            // assertion, but initialising it requires locking a mutex. Hence\n+            // it should be enabled only in debug builds.\n+            let new_generation =\n+                alt *old_ancestors {\n+                    some(arc) { do arc.with |_c,nobe| { nobe.generation+1 } }\n+                    none      { 0 } // the actual value doesn't really matter.\n+                };\n+            assert new_generation < uint::max_value;\n+            // Build a new node in the ancestor list.\n+            ancestor_list(some(arc::exclusive(\n+                { generation:       new_generation,\n+                  mut parent_group: some(spawner_group.tasks.clone()),\n+                  mut ancestors:    old_ancestors })))\n+        } else {\n+            // Child has no ancestors.\n+            ancestor_list(none)\n+        };\n+        (g,a, false)\n+    };\n+\n+    fn share_ancestors(ancestors: &mut ancestor_list) -> ancestor_list {\n+        // Appease the borrow-checker. Really this wants to be written as:\n+        // alt ancestors\n+        //    some(ancestor_arc) { ancestor_list(some(ancestor_arc.clone())) }\n+        //    none               { ancestor_list(none) }\n+        let mut tmp = none;\n+        **ancestors <-> tmp;\n+        if tmp.is_some() {\n+            let ancestor_arc = option::unwrap(tmp);\n+            let result = ancestor_arc.clone();\n+            **ancestors <- some(ancestor_arc);\n+            ancestor_list(some(result))\n+        } else {\n+            ancestor_list(none)\n         }\n     }\n }\n \n fn spawn_raw(opts: task_opts, +f: fn~()) {\n-    // Decide whether the child needs to be in a new linked failure group.\n-    // This whole conditional should be consolidated with share_spawner above.\n-    let (child_tg, parent_tg, is_main) = if opts.linked {\n-        // It doesn't mean anything for a linked-spawned-task to have a parent\n-        // group. The spawning task is already bidirectionally linked to it.\n-        share_spawner_taskgroup(true)\n-    } else {\n-        // Detached from the parent group; create a new (non-main) one.\n-        (arc::exclusive(some((dvec::dvec(),dvec::dvec()))),\n-         // Allow the parent to unidirectionally fail the child?\n-         if opts.parented {\n-             // Use the spawner's own group as the child's parent group.\n-             let (pg,_,_) = share_spawner_taskgroup(false); some(pg)\n-         } else {\n-             none\n-         },\n-         false)\n-    };\n+    let (child_tg, ancestors, is_main) =\n+        gen_child_taskgroup(opts.linked, opts.parented);\n \n     unsafe {\n-        let child_data_ptr = ~mut some((child_tg, parent_tg, f));\n+        let child_data_ptr = ~mut some((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut child_data = none;\n             *child_data_ptr <-> child_data;\n-            let (child_tg, parent_tg, f) = option::unwrap(child_data);\n+            let (child_tg, ancestors, f) = option::unwrap(child_data);\n             // Create child task.\n             let new_task = alt opts.sched {\n               none             { rustrt::new_task() }\n@@ -814,7 +1026,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             // Getting killed after here would leak the task.\n \n             let child_wrapper =\n-                make_child_wrapper(new_task, child_tg, parent_tg, is_main,\n+                make_child_wrapper(new_task, child_tg, ancestors, is_main,\n                                    opts.notify_chan, f);\n             let fptr = ptr::addr_of(child_wrapper);\n             let closure: *rust_closure = unsafe::reinterpret_cast(fptr);\n@@ -828,69 +1040,67 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n     }\n \n     // This function returns a closure-wrapper that we pass to the child task.\n-    // In brief, it does the following:\n-    //     if enlist_in_group(child_group) {\n-    //         if parent_group {\n-    //             if !enlist_in_group(parent_group) {\n-    //                 leave_group(child_group); // Roll back\n-    //                 return; // Parent group failed. Don't run child's f().\n-    //             }\n-    //         }\n-    //         stash_taskgroup_data_in_TLS(child_group, parent_group);\n-    //         f();\n-    //     } else {\n-    //         // My group failed. Don't run chid's f().\n-    //     }\n-    fn make_child_wrapper(child: *rust_task, -child_tg: taskgroup_arc,\n-                          -parent_tg: option<taskgroup_arc>, is_main: bool,\n+    // (1) It sets up the notification channel.\n+    // (2) It attempts to enlist in the child's group and all ancestor groups.\n+    // (3a) If any of those fails, it leaves all groups, and does nothing.\n+    // (3b) Otherwise it builds a task control structure and puts it in TLS,\n+    // (4) ...and runs the provided body function.\n+    fn make_child_wrapper(child: *rust_task, -child_arc: taskgroup_arc,\n+                          -ancestors: ancestor_list, is_main: bool,\n                           notify_chan: option<comm::chan<notification>>,\n                           -f: fn~()) -> fn~() {\n-        let child_tg_ptr = ~mut some((child_tg, parent_tg));\n-        fn~() {\n+        let child_tg_ptr = ~mut some((child_arc, ancestors));\n+        return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n             let mut tg_data_opt = none;\n             *child_tg_ptr <-> tg_data_opt;\n-            let (child_tg, parent_tg) = option::unwrap(tg_data_opt);\n+            let mut (child_arc, ancestors) = option::unwrap(tg_data_opt);\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must\n             // send something on the notify channel.\n             let notifier = notify_chan.map(|c| auto_notify(c));\n \n-            // Set up membership in taskgroup. If this returns none, some\n-            // task was already failing, so don't bother doing anything.\n-            alt enlist_in_taskgroup(child_tg, child) {\n-                some(my_pos) {\n-                    // Enlist in parent group too. If enlist returns none, a\n-                    // parent was failing: don't spawn; leave this group too.\n-                    let (pg, enlist_ok) = if parent_tg.is_some() {\n-                        let parent_group = option::unwrap(parent_tg);\n-                        alt enlist_in_taskgroup(parent_group, child) {\n-                            some(my_p_index) {\n-                                // Successful enlist.\n-                                (some((parent_group, my_p_index)), true)\n-                            }\n-                            none {\n-                                // Couldn't enlist. Have to quit here too.\n-                                leave_taskgroup(child_tg, child, my_pos);\n-                                (none, false)\n-                            }\n+            if enlist_many(child, child_arc, &mut ancestors) {\n+                let group = @taskgroup(child, child_arc, ancestors,\n+                                       is_main, notifier);\n+                unsafe { local_set(child, taskgroup_key(), group); }\n+                // Run the child's body.\n+                f();\n+                // TLS cleanup code will exit the taskgroup.\n+            }\n+        };\n+\n+        // Set up membership in taskgroup and descendantship in all ancestor\n+        // groups. If any enlistment fails, some task was already failing, so\n+        // don't let the child task run, and undo every successful enlistment.\n+        fn enlist_many(child: *rust_task, child_arc: taskgroup_arc,\n+                       ancestors: &mut ancestor_list) -> bool {\n+            // Join this taskgroup.\n+            let mut result =\n+                do child_arc.with |_c, child_tg| {\n+                    enlist_in_taskgroup(child_tg, child, true) // member\n+                };\n+            if result {\n+                // Unwinding function in case any ancestral enlisting fails\n+                let bail = |tg| { leave_taskgroup(tg, child, false) };\n+                // Attempt to join every ancestor group.\n+                result =\n+                    for each_ancestor(ancestors, some(bail)) |ancestor_tg| {\n+                        // Enlist as a descendant, not as an actual member.\n+                        // Descendants don't kill ancestor groups on failure.\n+                        if !enlist_in_taskgroup(ancestor_tg, child, false) {\n+                            break;\n                         }\n-                    } else {\n-                        // No parent group to enlist in. No worry.\n-                        (none, true)\n                     };\n-                    if enlist_ok {\n-                        let group = @taskgroup(child, child_tg, my_pos,\n-                                               pg, is_main, notifier);\n-                        unsafe { local_set(child, taskgroup_key(), group); }\n-                        // Run the child's body.\n-                        f();\n-                        // TLS cleanup code will exit the taskgroup.\n+                // If any ancestor group fails, need to exit this group too.\n+                if !result {\n+                    do child_arc.with |_c, child_tg| {\n+                        leave_taskgroup(child_tg, child, true); // member\n                     }\n                 }\n-                none { }\n             }\n+            result\n         }\n     }\n "}]}