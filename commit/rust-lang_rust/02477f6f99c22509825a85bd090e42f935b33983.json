{"sha": "02477f6f99c22509825a85bd090e42f935b33983", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNDc3ZjZmOTljMjI1MDk4MjVhODViZDA5MGU0MmY5MzViMzM5ODM=", "commit": {"author": {"name": "Kevin Leimkuhler", "email": "kevin@kleimkuhler.com", "date": "2018-10-11T22:59:54Z"}, "committer": {"name": "Kevin Leimkuhler", "email": "kevin@kleimkuhler.com", "date": "2019-01-18T06:34:43Z"}, "message": "Add is_sorted impl for [T]", "tree": {"sha": "7aeca0eade74c1122439e2efe69c5589289512dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aeca0eade74c1122439e2efe69c5589289512dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02477f6f99c22509825a85bd090e42f935b33983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02477f6f99c22509825a85bd090e42f935b33983", "html_url": "https://github.com/rust-lang/rust/commit/02477f6f99c22509825a85bd090e42f935b33983", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02477f6f99c22509825a85bd090e42f935b33983/comments", "author": {"login": "kleimkuhler", "id": 4572153, "node_id": "MDQ6VXNlcjQ1NzIxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/4572153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kleimkuhler", "html_url": "https://github.com/kleimkuhler", "followers_url": "https://api.github.com/users/kleimkuhler/followers", "following_url": "https://api.github.com/users/kleimkuhler/following{/other_user}", "gists_url": "https://api.github.com/users/kleimkuhler/gists{/gist_id}", "starred_url": "https://api.github.com/users/kleimkuhler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kleimkuhler/subscriptions", "organizations_url": "https://api.github.com/users/kleimkuhler/orgs", "repos_url": "https://api.github.com/users/kleimkuhler/repos", "events_url": "https://api.github.com/users/kleimkuhler/events{/privacy}", "received_events_url": "https://api.github.com/users/kleimkuhler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kleimkuhler", "id": 4572153, "node_id": "MDQ6VXNlcjQ1NzIxNTM=", "avatar_url": "https://avatars.githubusercontent.com/u/4572153?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kleimkuhler", "html_url": "https://github.com/kleimkuhler", "followers_url": "https://api.github.com/users/kleimkuhler/followers", "following_url": "https://api.github.com/users/kleimkuhler/following{/other_user}", "gists_url": "https://api.github.com/users/kleimkuhler/gists{/gist_id}", "starred_url": "https://api.github.com/users/kleimkuhler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kleimkuhler/subscriptions", "organizations_url": "https://api.github.com/users/kleimkuhler/orgs", "repos_url": "https://api.github.com/users/kleimkuhler/repos", "events_url": "https://api.github.com/users/kleimkuhler/events{/privacy}", "received_events_url": "https://api.github.com/users/kleimkuhler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dea0d0172d5a50b75dbde8ece24201f0d5b2125", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dea0d0172d5a50b75dbde8ece24201f0d5b2125", "html_url": "https://github.com/rust-lang/rust/commit/8dea0d0172d5a50b75dbde8ece24201f0d5b2125"}], "stats": {"total": 132, "additions": 110, "deletions": 22}, "files": [{"sha": "879cc8357cd2462e45d071285857b92988a052af", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/02477f6f99c22509825a85bd090e42f935b33983/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02477f6f99c22509825a85bd090e42f935b33983/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=02477f6f99c22509825a85bd090e42f935b33983", "patch": "@@ -2608,19 +2608,18 @@ pub trait Iterator {\n \n     /// Checks if the elements of this iterator are sorted.\n     ///\n-    /// That is, for each element `a` and its following element `b`, `a <= b`\n-    /// must hold. If the iterator yields exactly zero or one element, `true`\n-    /// is returned.\n+    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n+    /// iterator yields exactly zero or one element, `true` is returned.\n     ///\n-    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above\n-    /// definition implies that this function returns `false` if any two\n-    /// consecutive items are not comparable.\n+    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n+    /// implies that this function returns `false` if any two consecutive items are not\n+    /// comparable.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(is_sorted)]\n-    /// \n+    ///\n     /// assert!([1, 2, 2, 9].iter().is_sorted());\n     /// assert!(![1, 3, 2, 4].iter().is_sorted());\n     /// assert!([0].iter().is_sorted());\n@@ -2636,13 +2635,11 @@ pub trait Iterator {\n         self.is_sorted_by(|a, b| a.partial_cmp(b))\n     }\n \n-    /// Checks if the elements of this iterator are sorted using the given\n-    /// comparator function.\n+    /// Checks if the elements of this iterator are sorted using the given comparator function.\n     ///\n-    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given\n-    /// `compare` function to determine the ordering of two elements. Apart from\n-    /// that, it's equivalent to `is_sorted`; see its documentation for more\n-    /// information.\n+    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`\n+    /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n+    /// `is_sorted`; see its documentation for more information.\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool\n     where\n@@ -2664,19 +2661,18 @@ pub trait Iterator {\n         true\n     }\n \n-    /// Checks if the elements of this iterator are sorted using the given\n-    /// key extraction function.\n+    /// Checks if the elements of this iterator are sorted using the given key extraction\n+    /// function.\n     ///\n-    /// Instead of comparing the iterator's elements directly, this function\n-    /// compares the keys of the elements, as determined by `f`. Apart from\n-    /// that, it's equivalent to `is_sorted`; see its documentation for more\n-    /// information.\n+    /// Instead of comparing the iterator's elements directly, this function compares the keys of\n+    /// the elements, as determined by `f`. Apart from that, it's equivalent to `is_sorted`; see\n+    /// its documentation for more information.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(is_sorted)]\n-    /// \n+    ///\n     /// assert!([\"c\", \"bb\", \"aaa\"].iter().is_sorted_by_key(|s| s.len()));\n     /// assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n     /// ```"}, {"sha": "d4cac3e4f4b8f5c3309183827e4ead6e083035b8", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/02477f6f99c22509825a85bd090e42f935b33983/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02477f6f99c22509825a85bd090e42f935b33983/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=02477f6f99c22509825a85bd090e42f935b33983", "patch": "@@ -1783,7 +1783,7 @@ impl<T> [T] {\n     /// let mut a = ['a', 'b', 'c', 'd', 'e', 'f'];\n     /// a[1..5].rotate_left(1);\n     /// assert_eq!(a, ['a', 'c', 'd', 'e', 'b', 'f']);\n-   /// ```\n+    /// ```\n     #[stable(feature = \"slice_rotate\", since = \"1.26.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n@@ -2250,6 +2250,83 @@ impl<T> [T] {\n              from_raw_parts_mut(mut_ptr.add(rest.len() - ts_len), ts_len))\n         }\n     }\n+\n+    /// Checks if the elements of this slice are sorted.\n+    ///\n+    /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the\n+    /// slice yields exactly zero or one element, `true` is returned.\n+    ///\n+    /// Note that if `Self::Item` is only `PartialOrd`, but not `Ord`, the above definition\n+    /// implies that this function returns `false` if any two consecutive items are not\n+    /// comparable.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    /// let empty: [i32; 0] = [];\n+    ///\n+    /// assert!([1, 2, 2, 9].is_sorted());\n+    /// assert!(![1, 3, 2, 4].is_sorted());\n+    /// assert!([0].is_sorted());\n+    /// assert!(empty.is_sorted());\n+    /// assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    /// ```\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    pub fn is_sorted(&self) -> bool\n+    where\n+        T: PartialOrd,\n+    {\n+        self.is_sorted_by(|a, b| a.partial_cmp(b))\n+    }\n+\n+    /// Checks if the elements of this slice are sorted using the given comparator function.\n+    ///\n+    /// Instead of using `PartialOrd::partial_cmp`, this function uses the given `compare`\n+    /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n+    /// `is_sorted`; see its documentation for more information.\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    pub fn is_sorted_by<F>(&self, mut compare: F) -> bool\n+    where\n+        F: FnMut(&T, &T) -> Option<Ordering>\n+    {\n+        let mut last = match self.first() {\n+            Some(e) => e,\n+            None => return true,\n+        };\n+\n+        for curr in &self[1..] {\n+            if compare(&last, &curr).map(|o| o == Ordering::Greater).unwrap_or(true) {\n+                return false;\n+            }\n+            last = &curr;\n+        }\n+\n+        true\n+    }\n+\n+    /// Checks if the elements of this slice are sorted using the given key extraction function.\n+    ///\n+    /// Instead of comparing the slice's elements directly, this function compares the keys of the\n+    /// elements, as determined by `f`. Apart from that, it's equivalent to `is_sorted`; see its\n+    /// documentation for more information.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n+    /// assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n+    /// ```\n+    #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n+    pub fn is_sorted_by_key<F, K>(&self, mut f: F) -> bool\n+    where\n+        F: FnMut(&T) -> K,\n+        K: PartialOrd\n+    {\n+        self.is_sorted_by(|a, b| f(a).partial_cmp(&f(b)))\n+    }\n }\n \n #[lang = \"slice_u8\"]"}, {"sha": "e210e83122c47537e6a09e9459bc14526e1ebbed", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/02477f6f99c22509825a85bd090e42f935b33983/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02477f6f99c22509825a85bd090e42f935b33983/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=02477f6f99c22509825a85bd090e42f935b33983", "patch": "@@ -1317,3 +1317,18 @@ fn test_copy_within_panics_src_inverted() {\n     // 2 is greater than 1, so this range is invalid.\n     bytes.copy_within(2..1, 0);\n }\n+\n+#[test]\n+fn test_is_sorted() {\n+    let empty: [i32; 0] = [];\n+\n+    assert!([1, 2, 2, 9].is_sorted());\n+    assert!(![1, 3, 2].is_sorted());\n+    assert!([0].is_sorted());\n+    assert!(empty.is_sorted());\n+    assert!(![0.0, 1.0, std::f32::NAN].is_sorted());\n+    assert!([-2, -1, 0, 3].is_sorted());\n+    assert!(![-2i32, -1, 0, 3].is_sorted_by_key(|n| n.abs()));\n+    assert!(![\"c\", \"bb\", \"aaa\"].is_sorted());\n+    assert!([\"c\", \"bb\", \"aaa\"].is_sorted_by_key(|s| s.len()));\n+}"}, {"sha": "82fee379a4fa7246d721aaf5c29f3fa342eaa4fd", "filename": "src/test/ui/feature-gates/feature-gate-is_sorted.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02477f6f99c22509825a85bd090e42f935b33983/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02477f6f99c22509825a85bd090e42f935b33983/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-is_sorted.rs?ref=02477f6f99c22509825a85bd090e42f935b33983", "patch": "@@ -13,4 +13,4 @@ fn main() {\n     //^ ERROR: use of unstable library feature 'is_sorted'\n     assert!(![-2i32, -1, 0, 3].iter().is_sorted_by_key(|n| n.abs()));\n     //^ ERROR: use of unstable library feature 'is_sorted'\n-}\n\\ No newline at end of file\n+}"}]}