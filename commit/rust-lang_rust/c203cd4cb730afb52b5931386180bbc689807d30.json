{"sha": "c203cd4cb730afb52b5931386180bbc689807d30", "node_id": "C_kwDOAAsO6NoAKGMyMDNjZDRjYjczMGFmYjUyYjU5MzEzODYxODBiYmM2ODk4MDdkMzA", "commit": {"author": {"name": "Jonas Goronczy", "email": "goronczy.jonas@gmail.com", "date": "2022-02-12T22:21:41Z"}, "committer": {"name": "Jonas Goronczy", "email": "goronczy.jonas@gmail.com", "date": "2022-02-12T22:21:41Z"}, "message": "Extract struct from enum variant filters generics\n\nExtracting a struct from an enum variant now filters out only the\ngeneric parameters necessary for the new struct.\nBounds will be copied to the new struct, but unneeded ones are not\nfiltered out.\nExtracting bounds in a where clause are still not implemented.", "tree": {"sha": "2e150acab81bc0f9b80a5e7d0d140136dbfab056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e150acab81bc0f9b80a5e7d0d140136dbfab056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c203cd4cb730afb52b5931386180bbc689807d30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c203cd4cb730afb52b5931386180bbc689807d30", "html_url": "https://github.com/rust-lang/rust/commit/c203cd4cb730afb52b5931386180bbc689807d30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c203cd4cb730afb52b5931386180bbc689807d30/comments", "author": {"login": "jo-goro", "id": 13321616, "node_id": "MDQ6VXNlcjEzMzIxNjE2", "avatar_url": "https://avatars.githubusercontent.com/u/13321616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jo-goro", "html_url": "https://github.com/jo-goro", "followers_url": "https://api.github.com/users/jo-goro/followers", "following_url": "https://api.github.com/users/jo-goro/following{/other_user}", "gists_url": "https://api.github.com/users/jo-goro/gists{/gist_id}", "starred_url": "https://api.github.com/users/jo-goro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jo-goro/subscriptions", "organizations_url": "https://api.github.com/users/jo-goro/orgs", "repos_url": "https://api.github.com/users/jo-goro/repos", "events_url": "https://api.github.com/users/jo-goro/events{/privacy}", "received_events_url": "https://api.github.com/users/jo-goro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jo-goro", "id": 13321616, "node_id": "MDQ6VXNlcjEzMzIxNjE2", "avatar_url": "https://avatars.githubusercontent.com/u/13321616?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jo-goro", "html_url": "https://github.com/jo-goro", "followers_url": "https://api.github.com/users/jo-goro/followers", "following_url": "https://api.github.com/users/jo-goro/following{/other_user}", "gists_url": "https://api.github.com/users/jo-goro/gists{/gist_id}", "starred_url": "https://api.github.com/users/jo-goro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jo-goro/subscriptions", "organizations_url": "https://api.github.com/users/jo-goro/orgs", "repos_url": "https://api.github.com/users/jo-goro/repos", "events_url": "https://api.github.com/users/jo-goro/events{/privacy}", "received_events_url": "https://api.github.com/users/jo-goro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08348d79fa3ccb2aeeea87e758dcd5f1614c7ad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/08348d79fa3ccb2aeeea87e758dcd5f1614c7ad8", "html_url": "https://github.com/rust-lang/rust/commit/08348d79fa3ccb2aeeea87e758dcd5f1614c7ad8"}], "stats": {"total": 238, "additions": 213, "deletions": 25}, "files": [{"sha": "aeecac3c74fe1de7f6a04cd55f5df45e7a59a56b", "filename": "crates/ide_assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 213, "deletions": 25, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/c203cd4cb730afb52b5931386180bbc689807d30/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c203cd4cb730afb52b5931386180bbc689807d30/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=c203cd4cb730afb52b5931386180bbc689807d30", "patch": "@@ -16,7 +16,7 @@ use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{\n         self, edit::IndentLevel, edit_in_place::Indent, make, AstNode, HasAttrs, HasGenericParams,\n-        HasName, HasTypeBounds, HasVisibility,\n+        HasName, HasVisibility,\n     },\n     match_ast,\n     ted::{self, Position},\n@@ -106,7 +106,26 @@ pub(crate) fn extract_struct_from_enum_variant(\n             }\n \n             let indent = enum_ast.indent_level();\n-            let def = create_struct_def(variant_name.clone(), &variant, &field_list, &enum_ast);\n+            let generic_params = enum_ast\n+                .generic_param_list()\n+                .map(|known_generics| extract_generic_params(&known_generics, &field_list));\n+            let generics =\n+                generic_params.as_ref().filter(|generics| !generics.all_empty()).map(|generics| {\n+                    make::generic_param_list(\n+                        generics\n+                            .lifetimes\n+                            .iter()\n+                            .cloned()\n+                            .map(ast::GenericParam::LifetimeParam)\n+                            .chain(generics.types.iter().cloned().map(ast::GenericParam::TypeParam))\n+                            .chain(\n+                                generics.consts.iter().cloned().map(ast::GenericParam::ConstParam),\n+                            ),\n+                    )\n+                    .clone_for_update()\n+                });\n+            let def =\n+                create_struct_def(variant_name.clone(), &variant, &field_list, generics, &enum_ast);\n             def.reindent_to(indent);\n \n             let start_offset = &variant.parent_enum().syntax().clone();\n@@ -118,7 +137,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 ],\n             );\n \n-            update_variant(&variant, enum_ast.generic_param_list());\n+            update_variant(&variant, generic_params);\n         },\n     )\n }\n@@ -159,10 +178,95 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n         .any(|(name, _)| name.to_string() == variant_name.to_string())\n }\n \n+struct ExtractedGenerics {\n+    lifetimes: Vec<ast::LifetimeParam>,\n+    types: Vec<ast::TypeParam>,\n+    consts: Vec<ast::ConstParam>,\n+}\n+\n+impl ExtractedGenerics {\n+    fn all_empty(&self) -> bool {\n+        self.lifetimes.is_empty() && self.types.is_empty() && self.consts.is_empty()\n+    }\n+}\n+\n+fn extract_generic_params(\n+    known_generics: &ast::GenericParamList,\n+    field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n+) -> ExtractedGenerics {\n+    let mut lifetimes = known_generics.lifetime_params().map(|x| (x, false)).collect_vec();\n+    let mut types = known_generics.type_params().map(|x| (x, false)).collect_vec();\n+    let mut consts = known_generics.const_params().map(|x| (x, false)).collect_vec();\n+\n+    match field_list {\n+        Either::Left(field_list) => field_list\n+            .fields()\n+            .filter_map(|f| f.ty())\n+            .for_each(|ty| tag_generics_in_variant(&ty, &mut lifetimes, &mut types, &mut consts)),\n+        Either::Right(field_list) => field_list\n+            .fields()\n+            .filter_map(|f| f.ty())\n+            .for_each(|ty| tag_generics_in_variant(&ty, &mut lifetimes, &mut types, &mut consts)),\n+    }\n+\n+    let lifetimes = lifetimes.into_iter().filter_map(|(x, present)| present.then(|| x)).collect();\n+    let types = types.into_iter().filter_map(|(x, present)| present.then(|| x)).collect();\n+    let consts = consts.into_iter().filter_map(|(x, present)| present.then(|| x)).collect();\n+\n+    ExtractedGenerics { lifetimes, types, consts }\n+}\n+\n+fn tag_generics_in_variant(\n+    ty: &ast::Type,\n+    lifetimes: &mut [(ast::LifetimeParam, bool)],\n+    types: &mut [(ast::TypeParam, bool)],\n+    consts: &mut [(ast::ConstParam, bool)],\n+) {\n+    for token in\n+        ty.syntax().preorder_with_tokens().filter_map(|node_or_token| match node_or_token {\n+            syntax::WalkEvent::Enter(syntax::NodeOrToken::Token(token)) => Some(token),\n+            _ => None,\n+        })\n+    {\n+        match token.kind() {\n+            T![lifetime_ident] => {\n+                for (lt, present) in lifetimes.iter_mut() {\n+                    if let Some(lt) = lt.lifetime() {\n+                        if lt.text().as_str() == token.text() {\n+                            *present = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            T![ident] => {\n+                for (ty, present) in types.iter_mut() {\n+                    if let Some(name) = ty.name() {\n+                        if name.text().as_str() == token.text() {\n+                            *present = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                for (cnst, present) in consts.iter_mut() {\n+                    if let Some(name) = cnst.name() {\n+                        if name.text().as_str() == token.text() {\n+                            *present = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n fn create_struct_def(\n     variant_name: ast::Name,\n     variant: &ast::Variant,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n+    generics: Option<ast::GenericParamList>,\n     enum_: &ast::Enum,\n ) -> ast::Struct {\n     let enum_vis = enum_.visibility();\n@@ -204,9 +308,7 @@ fn create_struct_def(\n \n     field_list.reindent_to(IndentLevel::single());\n \n-    // FIXME: This uses all the generic params of the enum, but the variant might not use all of them.\n-    let strukt = make::struct_(enum_vis, variant_name, enum_.generic_param_list(), field_list)\n-        .clone_for_update();\n+    let strukt = make::struct_(enum_vis, variant_name, generics, field_list).clone_for_update();\n \n     // FIXME: Consider making this an actual function somewhere (like in `AttrsOwnerEdit`) after some deliberation\n     let attrs_and_docs = |node: &SyntaxNode| {\n@@ -243,26 +345,24 @@ fn create_struct_def(\n     strukt\n }\n \n-fn update_variant(variant: &ast::Variant, generic: Option<ast::GenericParamList>) -> Option<()> {\n+fn update_variant(variant: &ast::Variant, generics: Option<ExtractedGenerics>) -> Option<()> {\n     let name = variant.name()?;\n-    let ty = match generic {\n-        // FIXME: This uses all the generic params of the enum, but the variant might not use all of them.\n-        Some(gpl) => {\n-            let gpl = gpl.clone_for_update();\n-            gpl.generic_params().for_each(|gp| {\n-                let tbl = match gp {\n-                    ast::GenericParam::LifetimeParam(it) => it.type_bound_list(),\n-                    ast::GenericParam::TypeParam(it) => it.type_bound_list(),\n-                    ast::GenericParam::ConstParam(_) => return,\n-                };\n-                if let Some(tbl) = tbl {\n-                    tbl.remove();\n-                }\n-            });\n-            make::ty(&format!(\"{}<{}>\", name.text(), gpl.generic_params().join(\", \")))\n-        }\n-        None => make::ty(&name.text()),\n-    };\n+    let ty = generics\n+        .filter(|generics| !generics.all_empty())\n+        .map(|generics| {\n+            let generics_str = [\n+                generics.lifetimes.iter().filter_map(|lt| lt.lifetime()).join(\", \"),\n+                generics.types.iter().filter_map(|ty| ty.name()).join(\", \"),\n+                generics.consts.iter().filter_map(|cnst| cnst.name()).join(\", \"),\n+            ]\n+            .iter()\n+            .filter(|s| !s.is_empty())\n+            .join(\", \");\n+\n+            make::ty(&format!(\"{}<{}>\", &name.text(), &generics_str))\n+        })\n+        .unwrap_or_else(|| make::ty(&name.text()));\n+\n     let tuple_field = make::tuple_field(None, ty);\n     let replacement = make::variant(\n         name,\n@@ -902,4 +1002,92 @@ enum A { $0One(u8, u32) }\n     fn test_extract_not_applicable_no_field_named() {\n         check_assist_not_applicable(extract_struct_from_enum_variant, r\"enum A { $0None {} }\");\n     }\n+\n+    #[test]\n+    fn test_extract_struct_only_copies_needed_generics() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum X<'a, 'b, 'x> {\n+    $0A { a: &'a &'x mut () },\n+    B { b: &'b () },\n+    C { c: () },\n+}\n+\"#,\n+            r#\"\n+struct A<'a, 'x>{ a: &'a &'x mut () }\n+\n+enum X<'a, 'b, 'x> {\n+    A(A<'a, 'x>),\n+    B { b: &'b () },\n+    C { c: () },\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_with_liftime_type_const() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum X<'b, T, V, const C: usize> {\n+    $0A { a: T, b: X<'b>, c: [u8; C] },\n+    D { d: V },\n+}\n+\"#,\n+            r#\"\n+struct A<'b, T, const C: usize>{ a: T, b: X<'b>, c: [u8; C] }\n+\n+enum X<'b, T, V, const C: usize> {\n+    A(A<'b, T, C>),\n+    D { d: V },\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_without_generics() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum X<'a, 'b> {\n+    A { a: &'a () },\n+    B { b: &'b () },\n+    $0C { c: () },\n+}\n+\"#,\n+            r#\"\n+struct C{ c: () }\n+\n+enum X<'a, 'b> {\n+    A { a: &'a () },\n+    B { b: &'b () },\n+    C(C),\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_struct_keeps_trait_bounds() {\n+        check_assist(\n+            extract_struct_from_enum_variant,\n+            r#\"\n+enum En<T: TraitT, V: TraitV> {\n+    $0A { a: T },\n+    B { b: V },\n+}\n+\"#,\n+            r#\"\n+struct A<T: TraitT>{ a: T }\n+\n+enum En<T: TraitT, V: TraitV> {\n+    A(A<T>),\n+    B { b: V },\n+}\n+\"#,\n+        );\n+    }\n }"}]}