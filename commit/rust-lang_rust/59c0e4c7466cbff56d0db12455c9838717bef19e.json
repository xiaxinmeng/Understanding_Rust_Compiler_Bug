{"sha": "59c0e4c7466cbff56d0db12455c9838717bef19e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5YzBlNGM3NDY2Y2JmZjU2ZDBkYjEyNDU1Yzk4Mzg3MTdiZWYxOWU=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-06-17T07:25:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-17T07:25:10Z"}, "message": "Merge pull request #1701 from topecongiro/issue-1697\n\nForbid overflowing closure if its header goes multi lines", "tree": {"sha": "98d409a29b7294a3309cde90ed1181b96c16b1f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98d409a29b7294a3309cde90ed1181b96c16b1f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59c0e4c7466cbff56d0db12455c9838717bef19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59c0e4c7466cbff56d0db12455c9838717bef19e", "html_url": "https://github.com/rust-lang/rust/commit/59c0e4c7466cbff56d0db12455c9838717bef19e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59c0e4c7466cbff56d0db12455c9838717bef19e/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06f351664b4230b8b6b3a624b71629da60d9d44c", "url": "https://api.github.com/repos/rust-lang/rust/commits/06f351664b4230b8b6b3a624b71629da60d9d44c", "html_url": "https://github.com/rust-lang/rust/commit/06f351664b4230b8b6b3a624b71629da60d9d44c"}, {"sha": "e31f5eceac47f66779f95324c58abde73cb06a0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e31f5eceac47f66779f95324c58abde73cb06a0d", "html_url": "https://github.com/rust-lang/rust/commit/e31f5eceac47f66779f95324c58abde73cb06a0d"}], "stats": {"total": 313, "additions": 170, "deletions": 143}, "files": [{"sha": "5a4a404bfdb3e0d942dbefb913d606a721cde032", "filename": "src/chains.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -165,9 +165,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     );\n \n     let child_shape_iter = Some(first_child_shape).into_iter().chain(\n-        ::std::iter::repeat(\n-            other_child_shape,\n-        ).take(subexpr_list.len() - 1),\n+        ::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1),\n     );\n     let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n     let mut rewrites = try_opt!(\n@@ -178,9 +176,10 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n \n     // Total of all items excluding the last.\n     let last_non_try_index = rewrites.len() - (1 + trailing_try_num);\n-    let almost_total = rewrites[..last_non_try_index]\n-        .iter()\n-        .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n+    let almost_total = rewrites[..last_non_try_index].iter().fold(\n+        0,\n+        |a, b| a + first_line_width(b),\n+    ) + parent_rewrite.len();\n     let one_line_len = rewrites.iter().fold(0, |a, r| a + first_line_width(r)) +\n         parent_rewrite.len();\n "}, {"sha": "ce4b45009a2a5805e50520ade4009617cbf4058f", "filename": "src/comment.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -45,9 +45,10 @@ pub enum CommentStyle<'a> {\n \n fn custom_opener(s: &str) -> &str {\n     s.lines().next().map_or(\"\", |first_line| {\n-        first_line\n-            .find(' ')\n-            .map_or(first_line, |space_index| &first_line[0..space_index + 1])\n+        first_line.find(' ').map_or(\n+            first_line,\n+            |space_index| &first_line[0..space_index + 1],\n+        )\n     })\n }\n "}, {"sha": "8e2fe782ce987fc5102c07708c6f4038c44fe2bb", "filename": "src/expr.rs", "status": "modified", "additions": 79, "deletions": 68, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -298,9 +298,7 @@ fn format_expr(\n             Some(format!(\n                 \"{}{}\",\n                 \"do catch \",\n-                try_opt!(\n-                    block.rewrite(&context, Shape::legacy(budget, shape.indent))\n-                )\n+                try_opt!(block.rewrite(&context, Shape::legacy(budget, shape.indent)))\n             ))\n         }\n     };\n@@ -563,7 +561,7 @@ fn rewrite_closure_fn_decl(\n         fn_decl.inputs.iter(),\n         \"|\",\n         |arg| span_lo_for_arg(arg),\n-        |arg| span_hi_for_arg(arg),\n+        |arg| span_hi_for_arg(context, arg),\n         |arg| arg.rewrite(context, arg_shape),\n         context.codemap.span_after(span, \"|\"),\n         body.span.lo,\n@@ -941,13 +939,9 @@ fn to_control_flow<'a>(expr: &'a ast::Expr, expr_type: ExprType) -> Option<Contr\n         ast::ExprKind::Loop(ref block, label) => Some(\n             ControlFlow::new_loop(block, label, expr.span),\n         ),\n-        ast::ExprKind::While(ref cond, ref block, label) => Some(ControlFlow::new_while(\n-            None,\n-            cond,\n-            block,\n-            label,\n-            expr.span,\n-        )),\n+        ast::ExprKind::While(ref cond, ref block, label) => Some(\n+            ControlFlow::new_while(None, cond, block, label, expr.span),\n+        ),\n         ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n             Some(ControlFlow::new_while(\n                 Some(pat),\n@@ -1302,14 +1296,13 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                 }\n             };\n \n-            let between_kwd_else_block =\n-                mk_sp(\n-                    self.block.span.hi,\n-                    context.codemap.span_before(\n-                        mk_sp(self.block.span.hi, else_block.span.lo),\n-                        \"else\",\n-                    ),\n-                );\n+            let between_kwd_else_block = mk_sp(\n+                self.block.span.hi,\n+                context.codemap.span_before(\n+                    mk_sp(self.block.span.hi, else_block.span.lo),\n+                    \"else\",\n+                ),\n+            );\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n@@ -1434,10 +1427,9 @@ fn rewrite_match_arm_comment(\n     result.push_str(&missed_str[..first_brk]);\n     let missed_str = &missed_str[first_brk..]; // If missed_str had one newline, it starts with it\n \n-    let first = missed_str.find(|c: char| !c.is_whitespace()).unwrap_or(\n-        missed_str\n-            .len(),\n-    );\n+    let first = missed_str\n+        .find(|c: char| !c.is_whitespace())\n+        .unwrap_or(missed_str.len());\n     if missed_str[..first].chars().filter(|c| c == &'\\n').count() >= 2 {\n         // Excessive vertical whitespace before comment should be preserved\n         // FIXME handle vertical whitespace better\n@@ -2053,20 +2045,16 @@ where\n     Ok(format!(\n         \"{}{}\",\n         callee_str,\n-        wrap_args_with_parens(\n-            context,\n-            &list_str,\n-            extendable,\n-            args_shape,\n-            nested_shape,\n-        )\n+        wrap_args_with_parens(context, &list_str, extendable, args_shape, nested_shape)\n     ))\n }\n \n fn need_block_indent(s: &str, shape: Shape) -> bool {\n     s.lines().skip(1).any(|s| {\n-        s.find(|c| !char::is_whitespace(c))\n-            .map_or(false, |w| w + 1 < shape.indent.width())\n+        s.find(|c| !char::is_whitespace(c)).map_or(\n+            false,\n+            |w| w + 1 < shape.indent.width(),\n+        )\n     })\n }\n \n@@ -2207,6 +2195,48 @@ fn last_arg_shape(\n     })\n }\n \n+// Rewriting closure which is placed at the end of the function call's arg.\n+// Returns `None` if the reformatted closure 'looks bad'.\n+fn rewrite_last_closure(\n+    context: &RewriteContext,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n+    if let ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) = expr.node {\n+        let body = match body.node {\n+            ast::ExprKind::Block(ref block) if block.stmts.len() == 1 => {\n+                stmt_expr(&block.stmts[0]).unwrap_or(body)\n+            }\n+            _ => body,\n+        };\n+        let (prefix, extra_offset) = try_opt!(rewrite_closure_fn_decl(\n+            capture,\n+            fn_decl,\n+            body,\n+            expr.span,\n+            context,\n+            shape,\n+        ));\n+        // If the closure goes multi line before its body, do not overflow the closure.\n+        if prefix.contains('\\n') {\n+            return None;\n+        }\n+        let body_shape = try_opt!(shape.offset_left(extra_offset));\n+        // When overflowing the closure which consists of a single control flow expression,\n+        // force to use block if its condition uses multi line.\n+        if rewrite_cond(context, body, body_shape)\n+            .map(|cond| cond.contains('\\n'))\n+            .unwrap_or(false)\n+        {\n+            return rewrite_closure_with_block(context, body_shape, &prefix, body);\n+        }\n+\n+        // Seems fine, just format the closure in usual manner.\n+        return expr.rewrite(context, shape);\n+    }\n+    None\n+}\n+\n fn rewrite_last_arg_with_overflow<'a, T>(\n     context: &RewriteContext,\n     last_arg: &T,\n@@ -2220,31 +2250,7 @@ where\n         match expr.node {\n             // When overflowing the closure which consists of a single control flow expression,\n             // force to use block if its condition uses multi line.\n-            ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n-                let try_closure_with_block = || {\n-                    let body = match body.node {\n-                        ast::ExprKind::Block(ref block) if block.stmts.len() == 1 => {\n-                            try_opt!(stmt_expr(&block.stmts[0]))\n-                        }\n-                        _ => body,\n-                    };\n-                    let (prefix, extra_offset) = try_opt!(rewrite_closure_fn_decl(\n-                        capture,\n-                        fn_decl,\n-                        body,\n-                        expr.span,\n-                        context,\n-                        shape,\n-                    ));\n-                    let shape = try_opt!(shape.offset_left(extra_offset));\n-                    rewrite_cond(context, body, shape).map_or(None, |cond| if cond.contains('\\n') {\n-                        rewrite_closure_with_block(context, shape, &prefix, body)\n-                    } else {\n-                        None\n-                    })\n-                };\n-                try_closure_with_block().or_else(|| expr.rewrite(context, shape))\n-            }\n+            ast::ExprKind::Closure(..) => rewrite_last_closure(context, expr, shape),\n             _ => expr.rewrite(context, shape),\n         }\n     } else {\n@@ -2390,10 +2396,12 @@ fn rewrite_index(\n     let indent = indent.to_string(&context.config);\n     // FIXME this is not right, since we don't take into account that shape.width\n     // might be reduced from max_width by something on the right.\n-    let budget = try_opt!(context.config.max_width().checked_sub(\n-        indent.len() + lbr.len() +\n-            rbr.len(),\n-    ));\n+    let budget = try_opt!(\n+        context\n+            .config\n+            .max_width()\n+            .checked_sub(indent.len() + lbr.len() + rbr.len())\n+    );\n     let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n     Some(format!(\n         \"{}\\n{}{}{}{}\",\n@@ -2558,7 +2566,12 @@ fn shape_from_fn_call_style(\n     offset: usize,\n ) -> Option<Shape> {\n     if context.use_block_indent() {\n-        Some(shape.block().block_indent(context.config.tab_spaces()))\n+        // 1 = \",\"\n+        shape\n+            .block()\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config)\n+            .sub_width(1)\n     } else {\n         shape.visual_indent(offset).sub_width(overhead)\n     }\n@@ -2580,12 +2593,10 @@ where\n         // 3 = \"(\" + \",)\"\n         let nested_shape = try_opt!(shape.sub_width(3)).visual_indent(1);\n         return items.next().unwrap().rewrite(context, nested_shape).map(\n-            |s| {\n-                if context.config.spaces_within_parens() {\n-                    format!(\"( {}, )\", s)\n-                } else {\n-                    format!(\"({},)\", s)\n-                }\n+            |s| if context.config.spaces_within_parens() {\n+                format!(\"( {}, )\", s)\n+            } else {\n+                format!(\"({},)\", s)\n             },\n         );\n     }"}, {"sha": "9a6bb08d3b6d1cad4d0999c7099c0da7225cb7f1", "filename": "src/items.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -803,10 +803,9 @@ fn format_impl_ref_and_type(\n             Style::Legacy => new_line_offset + trait_ref_overhead,\n             Style::Rfc => new_line_offset,\n         };\n-        result.push_str(&*try_opt!(self_ty.rewrite(\n-            context,\n-            Shape::legacy(budget, type_offset),\n-        )));\n+        result.push_str(&*try_opt!(\n+            self_ty.rewrite(context, Shape::legacy(budget, type_offset))\n+        ));\n         Some(result)\n     } else {\n         unreachable!();\n@@ -967,8 +966,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             where_density,\n             \"{\",\n             !has_body,\n-            trait_bound_str.is_empty() &&\n-                last_line_width(&generics_str) == 1,\n+            trait_bound_str.is_empty() && last_line_width(&generics_str) == 1,\n             None,\n         ));\n         // If the where clause cannot fit on the same line,\n@@ -1260,10 +1258,12 @@ fn format_tuple_struct(\n             context.codemap.span_after(span, \"(\"),\n             span.hi,\n         );\n-        let body_budget = try_opt!(context.config.max_width().checked_sub(\n-            offset.block_only().width() +\n-                result.len() + 3,\n-        ));\n+        let body_budget = try_opt!(\n+            context\n+                .config\n+                .max_width()\n+                .checked_sub(offset.block_only().width() + result.len() + 3)\n+        );\n         let body = try_opt!(list_helper(\n             items,\n             // TODO budget is wrong in block case\n@@ -1548,8 +1548,7 @@ pub fn rewrite_static(\n     let ty_str = try_opt!(ty.rewrite(\n         context,\n         Shape::legacy(\n-            context.config.max_width() - offset.block_indent -\n-                prefix.len() - 2,\n+            context.config.max_width() - offset.block_indent - prefix.len() - 2,\n             offset.block_only(),\n         ),\n     ));\n@@ -1613,8 +1612,7 @@ pub fn rewrite_associated_type(\n         let ty_str = try_opt!(ty.rewrite(\n             context,\n             Shape::legacy(\n-                context.config.max_width() - indent.block_indent -\n-                    prefix.len() - 2,\n+                context.config.max_width() - indent.block_indent - prefix.len() - 2,\n                 indent.block_only(),\n             ),\n         ));\n@@ -1659,6 +1657,16 @@ impl Rewrite for ast::FunctionRetTy {\n     }\n }\n \n+fn is_empty_infer(context: &RewriteContext, ty: &ast::Ty) -> bool {\n+    match ty.node {\n+        ast::TyKind::Infer => {\n+            let original = context.snippet(ty.span);\n+            original != \"_\"\n+        }\n+        _ => false,\n+    }\n+}\n+\n impl Rewrite for ast::Arg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if is_named_arg(self) {\n@@ -1667,7 +1675,7 @@ impl Rewrite for ast::Arg {\n                 Shape::legacy(shape.width, shape.indent),\n             ));\n \n-            if self.ty.node != ast::TyKind::Infer {\n+            if !is_empty_infer(context, &*self.ty) {\n                 if context.config.space_before_type_annotation() {\n                     result.push_str(\" \");\n                 }\n@@ -1752,8 +1760,9 @@ pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n     }\n }\n \n-pub fn span_hi_for_arg(arg: &ast::Arg) -> BytePos {\n+pub fn span_hi_for_arg(context: &RewriteContext, arg: &ast::Arg) -> BytePos {\n     match arg.ty.node {\n+        ast::TyKind::Infer if context.snippet(arg.ty.span) == \"_\" => arg.ty.span.hi,\n         ast::TyKind::Infer if is_named_arg(arg) => arg.pat.span.hi,\n         _ => arg.ty.span.hi,\n     }\n@@ -1857,8 +1866,7 @@ fn rewrite_fn_base(\n         2\n     };\n     let shape = try_opt!(\n-        Shape::indented(indent + last_line_width(&result), context.config)\n-            .sub_width(overhead)\n+        Shape::indented(indent + last_line_width(&result), context.config).sub_width(overhead)\n     );\n     let g_span = mk_sp(span.lo, span_for_return(&fd.output).lo);\n     let generics_str = try_opt!(rewrite_generics(context, generics, shape, g_span));\n@@ -1979,10 +1987,10 @@ fn rewrite_fn_base(\n         }\n         // If the last line of args contains comment, we cannot put the closing paren\n         // on the same line.\n-        if arg_str\n-            .lines()\n-            .last()\n-            .map_or(false, |last_line| last_line.contains(\"//\"))\n+        if arg_str.lines().last().map_or(\n+            false,\n+            |last_line| last_line.contains(\"//\"),\n+        )\n         {\n             args_last_line_contains_comment = true;\n             result.push('\\n');\n@@ -2055,13 +2063,14 @@ fn rewrite_fn_base(\n             let snippet_hi = span.hi;\n             let snippet = context.snippet(mk_sp(snippet_lo, snippet_hi));\n             // Try to preserve the layout of the original snippet.\n-            let original_starts_with_newline =\n-                snippet\n-                    .find(|c| c != ' ')\n-                    .map_or(false, |i| snippet[i..].starts_with('\\n'));\n-            let original_ends_with_newline = snippet\n-                .rfind(|c| c != ' ')\n-                .map_or(false, |i| snippet[i..].ends_with('\\n'));\n+            let original_starts_with_newline = snippet.find(|c| c != ' ').map_or(\n+                false,\n+                |i| snippet[i..].starts_with('\\n'),\n+            );\n+            let original_ends_with_newline = snippet.rfind(|c| c != ' ').map_or(\n+                false,\n+                |i| snippet[i..].ends_with('\\n'),\n+            );\n             let snippet = snippet.trim();\n             if !snippet.is_empty() {\n                 result.push(if original_starts_with_newline {"}, {"sha": "da412211233772a91589be54ea85075a38336331", "filename": "src/lists.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -132,9 +132,10 @@ impl ListItem {\n     }\n \n     pub fn has_line_pre_comment(&self) -> bool {\n-        self.pre_comment\n-            .as_ref()\n-            .map_or(false, |comment| comment.starts_with(\"//\"))\n+        self.pre_comment.as_ref().map_or(\n+            false,\n+            |comment| comment.starts_with(\"//\"),\n+        )\n     }\n \n     pub fn from_str<S: Into<String>>(s: S) -> ListItem {\n@@ -419,10 +420,9 @@ where\n                     }\n                 }\n                 None => {\n-                    post_snippet.find_uncommented(self.terminator).unwrap_or(\n-                        post_snippet\n-                            .len(),\n-                    )\n+                    post_snippet\n+                        .find_uncommented(self.terminator)\n+                        .unwrap_or(post_snippet.len())\n                 }\n             };\n \n@@ -435,10 +435,9 @@ where\n                 let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments.\n                 let test_snippet = &test_snippet[first_newline..];\n-                let first = test_snippet.find(|c: char| !c.is_whitespace()).unwrap_or(\n-                    test_snippet\n-                        .len(),\n-                );\n+                let first = test_snippet\n+                    .find(|c: char| !c.is_whitespace())\n+                    .unwrap_or(test_snippet.len());\n                 // From the end of the first line of comments to the next non-whitespace char.\n                 let test_snippet = &test_snippet[..first];\n "}, {"sha": "723317a1040317e94270be838d0ecda2b5c6b462", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -590,10 +590,7 @@ impl Rewrite for ast::PolyTraitRef {\n             let max_path_width = try_opt!(shape.width.checked_sub(extra_offset));\n             let path_str = try_opt!(self.trait_ref.rewrite(\n                 context,\n-                Shape::legacy(\n-                    max_path_width,\n-                    shape.indent + extra_offset,\n-                ),\n+                Shape::legacy(max_path_width, shape.indent + extra_offset),\n             ));\n \n             Some(if context.config.spaces_within_angle_brackets() &&\n@@ -645,10 +642,7 @@ impl Rewrite for ast::Ty {\n                             mut_str,\n                             try_opt!(mt.ty.rewrite(\n                                 context,\n-                                Shape::legacy(\n-                                    budget,\n-                                    shape.indent + 2 + mut_len + lt_len,\n-                                ),\n+                                Shape::legacy(budget, shape.indent + 2 + mut_len + lt_len),\n                             ))\n                         )\n                     }"}, {"sha": "b8225aaed1c12407474c34f6de6dece4fe13e9e8", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -782,8 +782,8 @@ impl Rewrite for ast::MetaItem {\n \n impl Rewrite for ast::Attribute {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        try_opt!(self.meta()).rewrite(context, shape).map(|rw| {\n-            if rw.starts_with(\"///\") {\n+        try_opt!(self.meta()).rewrite(context, shape).map(\n+            |rw| if rw.starts_with(\"///\") {\n                 rw\n             } else {\n                 let original = context.snippet(self.span);\n@@ -792,8 +792,8 @@ impl Rewrite for ast::Attribute {\n                 } else {\n                     format!(\"#[{}]\", rw)\n                 }\n-            }\n-        })\n+            },\n+        )\n     }\n }\n "}, {"sha": "b52643f2fb8c6a0a3dbd561799405044d8f5ac72", "filename": "tests/source/closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -143,3 +143,11 @@ fn issue1329() {\n fn issue325() {\n     let f = || unsafe { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx };\n }\n+\n+fn issue1697() {\n+    Test.func_a(A_VERY_LONG_CONST_VARIABLE_NAME, move |arg1, arg2, arg3, arg4| arg1 + arg2 + arg3 + arg4)\n+}\n+\n+fn issue1694() {\n+    foooooo(|_referencefffffffff: _, _target_reference: _, _oid: _, _target_oid: _| format!(\"refs/pull/{}/merge\", pr_id))\n+}"}, {"sha": "3d6d322a1039b24667fad3e3ae011bb2dd644b84", "filename": "tests/target/closure.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -128,11 +128,8 @@ fn issue470() {\n     {\n         {\n             {\n-                let explicit_arg_decls =\n-                    explicit_arguments.into_iter().enumerate().map(|(\n-                        index,\n-                        (ty, pattern),\n-                    )| {\n+                let explicit_arg_decls = explicit_arguments.into_iter().enumerate().map(\n+                    |(index, (ty, pattern))| {\n                         let lvalue = Lvalue::Arg(index as u32);\n                         block = this.pattern(\n                             block,\n@@ -141,7 +138,8 @@ fn issue470() {\n                             &lvalue,\n                         );\n                         ArgDecl { ty: ty }\n-                    });\n+                    },\n+                );\n             }\n         }\n     }\n@@ -169,3 +167,18 @@ fn issue325() {\n     let f =\n         || unsafe { xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx };\n }\n+\n+fn issue1697() {\n+    Test.func_a(\n+        A_VERY_LONG_CONST_VARIABLE_NAME,\n+        move |arg1, arg2, arg3, arg4| arg1 + arg2 + arg3 + arg4,\n+    )\n+}\n+\n+fn issue1694() {\n+    foooooo(\n+        |_referencefffffffff: _, _target_reference: _, _oid: _, _target_oid: _| {\n+            format!(\"refs/pull/{}/merge\", pr_id)\n+        },\n+    )\n+}"}, {"sha": "65c556fed06369ec84c8e6a7d642e185356bd7b1", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59c0e4c7466cbff56d0db12455c9838717bef19e/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59c0e4c7466cbff56d0db12455c9838717bef19e/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=59c0e4c7466cbff56d0db12455c9838717bef19e", "patch": "@@ -79,14 +79,7 @@ fn main() {\n         ),\n         Variantttttttttttttttttttttttt => (\n             \"variant\",\n-            vec![\n-                \"id\",\n-                \"name\",\n-                \"qualname\",\n-                \"type\",\n-                \"value\",\n-                \"scopeid\",\n-            ],\n+            vec![\"id\", \"name\", \"qualname\", \"type\", \"value\", \"scopeid\"],\n             true,\n             true,\n         ),"}]}