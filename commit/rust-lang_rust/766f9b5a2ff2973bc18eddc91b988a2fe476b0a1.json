{"sha": "766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2NmY5YjVhMmZmMjk3M2JjMThlZGRjOTFiOTg4YTJmZTQ3NmIwYTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-08T18:19:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-14T10:26:40Z"}, "message": "Remove ExplicitSelf from HIR", "tree": {"sha": "f3febe6c0e985f4dae073e08b257eb6d511c09a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3febe6c0e985f4dae073e08b257eb6d511c09a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "html_url": "https://github.com/rust-lang/rust/commit/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "212d5d43524123a45c6a88174fd3c771057faf47", "url": "https://api.github.com/repos/rust-lang/rust/commits/212d5d43524123a45c6a88174fd3c771057faf47", "html_url": "https://github.com/rust-lang/rust/commit/212d5d43524123a45c6a88174fd3c771057faf47"}], "stats": {"total": 627, "additions": 196, "deletions": 431}, "files": [{"sha": "740d72f4c3e3cfd777337eb9827039f6cac4ed6a", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -158,14 +158,6 @@ pub trait Folder : Sized {\n         noop_fold_local(l, self)\n     }\n \n-    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n-        noop_fold_explicit_self(es, self)\n-    }\n-\n-    fn fold_explicit_self_underscore(&mut self, es: ExplicitSelf_) -> ExplicitSelf_ {\n-        noop_fold_explicit_self_underscore(es, self)\n-    }\n-\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -495,29 +487,6 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n-pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_,\n-                                                     fld: &mut T)\n-                                                     -> ExplicitSelf_ {\n-    match es {\n-        SelfStatic | SelfValue(_) => es,\n-        SelfRegion(lifetime, m, name) => {\n-            SelfRegion(fld.fold_opt_lifetime(lifetime), m, name)\n-        }\n-        SelfExplicit(typ, name) => {\n-            SelfExplicit(fld.fold_ty(typ), name)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_explicit_self<T: Folder>(Spanned { span, node }: ExplicitSelf,\n-                                          fld: &mut T)\n-                                          -> ExplicitSelf {\n-    Spanned {\n-        node: fld.fold_explicit_self_underscore(node),\n-        span: fld.new_span(span),\n-    }\n-}\n-\n pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n     mi.map(|Spanned { node, span }| {\n         Spanned {\n@@ -941,7 +910,6 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n     MethodSig {\n         generics: folder.fold_generics(sig.generics),\n         abi: sig.abi,\n-        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: folder.fold_fn_decl(sig.decl),"}, {"sha": "b387ced48228ca3784b890d7cf77e5c58989f05a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -180,9 +180,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n-        walk_explicit_self(self, es)\n-    }\n     fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n@@ -258,23 +255,6 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V, lifetime_def: &'v\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V, explicit_self: &'v ExplicitSelf) {\n-    match explicit_self.node {\n-        SelfStatic => {}\n-        SelfValue(name) => {\n-            visitor.visit_name(explicit_self.span, name)\n-        }\n-        SelfRegion(ref opt_lifetime, _, name) => {\n-            visitor.visit_name(explicit_self.span, name);\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n-        }\n-        SelfExplicit(ref typ, name) => {\n-            visitor.visit_name(explicit_self.span, name);\n-            visitor.visit_ty(typ)\n-        }\n-    }\n-}\n-\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: &'v TraitBoundModifier)\n@@ -620,7 +600,6 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n         }\n         FnKind::Method(_, sig, _, _) => {\n             visitor.visit_generics(&sig.generics);\n-            visitor.visit_explicit_self(&sig.explicit_self);\n         }\n         FnKind::Closure(_) => {}\n     }\n@@ -645,7 +624,6 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_list!(visitor, visit_expr, default);\n         }\n         MethodTraitItem(ref sig, None) => {\n-            visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }"}, {"sha": "d6a29b0376428fa217e82c516a02e20624501356", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -388,35 +388,13 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_explicit_self_underscore(&mut self, es: &SelfKind) -> hir::ExplicitSelf_ {\n-        match *es {\n-            SelfKind::Static => hir::SelfStatic,\n-            SelfKind::Value(v) => hir::SelfValue(v.name),\n-            SelfKind::Region(ref lifetime, m, ident) => {\n-                hir::SelfRegion(self.lower_opt_lifetime(lifetime),\n-                                self.lower_mutability(m),\n-                                ident.name)\n-            }\n-            SelfKind::Explicit(ref typ, ident) => {\n-                hir::SelfExplicit(self.lower_ty(typ), ident.name)\n-            }\n-        }\n-    }\n-\n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n         match m {\n             Mutability::Mutable => hir::MutMutable,\n             Mutability::Immutable => hir::MutImmutable,\n         }\n     }\n \n-    fn lower_explicit_self(&mut self, s: &ExplicitSelf) -> hir::ExplicitSelf {\n-        Spanned {\n-            node: self.lower_explicit_self_underscore(&s.node),\n-            span: s.span,\n-        }\n-    }\n-\n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         hir::Arg {\n             id: arg.id,\n@@ -800,7 +778,6 @@ impl<'a> LoweringContext<'a> {\n         hir::MethodSig {\n             generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n-            explicit_self: self.lower_explicit_self(&sig.explicit_self),\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n             decl: self.lower_fn_decl(&sig.decl),"}, {"sha": "eb38458a3acfa78435f02bcee803213f28782c02", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -15,7 +15,6 @@ pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n-pub use self::ExplicitSelf_::*;\n pub use self::Expr_::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n@@ -37,12 +36,12 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n+use syntax::codemap::{self, mk_sp, respan, Span, Spanned, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::attr::{ThinAttributes, ThinAttributesExt};\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n \n use std::collections::BTreeMap;\n@@ -1055,7 +1054,6 @@ pub struct MethodSig {\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n-    pub explicit_self: ExplicitSelf,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1196,25 +1194,41 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n+/// Alternative representation for `Arg`s describing `self` parameter of methods.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum SelfKind {\n+    /// `self`, `mut self`\n+    Value(Mutability),\n+    /// `&'lt self`, `&'lt mut self`\n+    Region(Option<Lifetime>, Mutability),\n+    /// `self: TYPE`, `mut self: TYPE`\n+    Explicit(P<Ty>, Mutability),\n+}\n+\n+pub type ExplicitSelf = Spanned<SelfKind>;\n+\n impl Arg {\n-    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n-        let path = Spanned {\n-            span: span,\n-            node: self_ident,\n-        };\n-        Arg {\n-            // HACK(eddyb) fake type for the self argument.\n-            ty: P(Ty {\n-                id: DUMMY_NODE_ID,\n-                node: TyInfer,\n-                span: DUMMY_SP,\n-            }),\n-            pat: P(Pat {\n-                id: DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindByValue(mutability), path, None),\n-                span: span,\n-            }),\n-            id: DUMMY_NODE_ID,\n+    pub fn to_self(&self) -> Option<ExplicitSelf> {\n+        if let PatKind::Ident(BindByValue(mutbl), ident, _) = self.pat.node {\n+            if ident.node.unhygienic_name == keywords::SelfValue.name() {\n+                return match self.ty.node {\n+                    TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n+                    TyRptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyInfer => {\n+                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n+                    }\n+                    _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n+                                     SelfKind::Explicit(self.ty.clone(), mutbl)))\n+                }\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn is_self(&self) -> bool {\n+        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+            ident.node.unhygienic_name == keywords::SelfValue.name()\n+        } else {\n+            false\n         }\n     }\n }\n@@ -1227,6 +1241,12 @@ pub struct FnDecl {\n     pub variadic: bool,\n }\n \n+impl FnDecl {\n+    pub fn has_self(&self) -> bool {\n+        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,\n@@ -1308,21 +1328,6 @@ impl FunctionRetTy {\n     }\n }\n \n-/// Represents the kind of 'self' associated with a method\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ExplicitSelf_ {\n-    /// No self\n-    SelfStatic,\n-    /// `self`\n-    SelfValue(Name),\n-    /// `&'lt self`, `&'lt mut self`\n-    SelfRegion(Option<Lifetime>, Mutability, Name),\n-    /// `self: TYPE`\n-    SelfExplicit(P<Ty>, Name),\n-}\n-\n-pub type ExplicitSelf = Spanned<ExplicitSelf_>;\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`."}, {"sha": "c3617cb768d56334060c94ffc5e35e7ed59044c8", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 27, "deletions": 85, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -23,7 +23,7 @@ use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n \n use hir;\n-use hir::{Crate, PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use hir::{Crate, PatKind, RegionTyParamBound, SelfKind, TraitTyParamBound, TraitBoundModifier};\n \n use std::io::{self, Write, Read};\n \n@@ -281,7 +281,6 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                      unsafety: hir::Unsafety,\n                      constness: hir::Constness,\n                      name: ast::Name,\n-                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                      generics: &hir::Generics)\n                      -> String {\n     to_string(|s| {\n@@ -292,7 +291,6 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                    Abi::Rust,\n                    Some(name),\n                    generics,\n-                   opt_explicit_self,\n                    &hir::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n@@ -309,10 +307,6 @@ pub fn block_to_string(blk: &hir::Block) -> String {\n     })\n }\n \n-pub fn explicit_self_to_string(explicit_self: &hir::ExplicitSelf_) -> String {\n-    to_string(|s| s.print_explicit_self(explicit_self, hir::MutImmutable).map(|_| {}))\n-}\n-\n pub fn variant_to_string(var: &hir::Variant) -> String {\n     to_string(|s| s.print_variant(var))\n }\n@@ -526,7 +520,7 @@ impl<'a> State<'a> {\n                         predicates: hir::HirVec::new(),\n                     },\n                 };\n-                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics, None)?;\n+                self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n             }\n             hir::TyPath(None, ref path) => {\n                 self.print_path(path, false, 0)?;\n@@ -573,7 +567,6 @@ impl<'a> State<'a> {\n                               Abi::Rust,\n                               Some(item.name),\n                               generics,\n-                              None,\n                               &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n@@ -710,7 +703,6 @@ impl<'a> State<'a> {\n                               abi,\n                               Some(item.name),\n                               typarams,\n-                              None,\n                               &item.vis)?;\n                 word(&mut self.s, \" \")?;\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n@@ -976,7 +968,6 @@ impl<'a> State<'a> {\n                       m.abi,\n                       Some(name),\n                       &m.generics,\n-                      Some(&m.explicit_self.node),\n                       vis)\n     }\n \n@@ -1881,32 +1872,25 @@ impl<'a> State<'a> {\n         self.end() // close enclosing cbox\n     }\n \n-    // Returns whether it printed anything\n-    fn print_explicit_self(&mut self,\n-                           explicit_self: &hir::ExplicitSelf_,\n-                           mutbl: hir::Mutability)\n-                           -> io::Result<bool> {\n-        self.print_mutability(mutbl)?;\n-        match *explicit_self {\n-            hir::SelfStatic => {\n-                return Ok(false);\n-            }\n-            hir::SelfValue(_) => {\n-                word(&mut self.s, \"self\")?;\n+    fn print_explicit_self(&mut self, explicit_self: &hir::ExplicitSelf) -> io::Result<()> {\n+        match explicit_self.node {\n+            SelfKind::Value(m) => {\n+                self.print_mutability(m)?;\n+                word(&mut self.s, \"self\")\n             }\n-            hir::SelfRegion(ref lt, m, _) => {\n+            SelfKind::Region(ref lt, m) => {\n                 word(&mut self.s, \"&\")?;\n                 self.print_opt_lifetime(lt)?;\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n+                word(&mut self.s, \"self\")\n             }\n-            hir::SelfExplicit(ref typ, _) => {\n+            SelfKind::Explicit(ref typ, m) => {\n+                self.print_mutability(m)?;\n                 word(&mut self.s, \"self\")?;\n                 self.word_space(\":\")?;\n-                self.print_type(&typ)?;\n+                self.print_type(&typ)\n             }\n         }\n-        return Ok(true);\n     }\n \n     pub fn print_fn(&mut self,\n@@ -1916,7 +1900,6 @@ impl<'a> State<'a> {\n                     abi: Abi,\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n-                    opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                     vis: &hir::Visibility)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n@@ -1926,55 +1909,13 @@ impl<'a> State<'a> {\n             self.print_name(name)?;\n         }\n         self.print_generics(generics)?;\n-        self.print_fn_args_and_ret(decl, opt_explicit_self)?;\n+        self.print_fn_args_and_ret(decl)?;\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_args(&mut self,\n-                         decl: &hir::FnDecl,\n-                         opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                         is_closure: bool)\n-                         -> io::Result<()> {\n-        // It is unfortunate to duplicate the commasep logic, but we want the\n-        // self type and the args all in the same box.\n-        self.rbox(0, Inconsistent)?;\n-        let mut first = true;\n-        if let Some(explicit_self) = opt_explicit_self {\n-            let m = match explicit_self {\n-                &hir::SelfStatic => hir::MutImmutable,\n-                _ => match decl.inputs[0].pat.node {\n-                    PatKind::Ident(hir::BindByValue(m), _, _) => m,\n-                    _ => hir::MutImmutable,\n-                },\n-            };\n-            first = !self.print_explicit_self(explicit_self, m)?;\n-        }\n-\n-        // HACK(eddyb) ignore the separately printed self argument.\n-        let args = if first {\n-            &decl.inputs[..]\n-        } else {\n-            &decl.inputs[1..]\n-        };\n-\n-        for arg in args {\n-            if first {\n-                first = false;\n-            } else {\n-                self.word_space(\",\")?;\n-            }\n-            self.print_arg(arg, is_closure)?;\n-        }\n-\n-        self.end()\n-    }\n-\n-    pub fn print_fn_args_and_ret(&mut self,\n-                                 decl: &hir::FnDecl,\n-                                 opt_explicit_self: Option<&hir::ExplicitSelf_>)\n-                                 -> io::Result<()> {\n+    pub fn print_fn_args_and_ret(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         self.popen()?;\n-        self.print_fn_args(decl, opt_explicit_self, false)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n         if decl.variadic {\n             word(&mut self.s, \", ...\")?;\n         }\n@@ -1985,7 +1926,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_block_args(&mut self, decl: &hir::FnDecl) -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n-        self.print_fn_args(decl, None, true)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n         word(&mut self.s, \"|\")?;\n \n         if let hir::DefaultReturn(..) = decl.output {\n@@ -2207,18 +2148,21 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             hir::TyInfer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                match input.pat.node {\n-                    PatKind::Ident(_, ref path1, _)\n-                            if path1.node.name == keywords::Invalid.name() => {\n-                        // Do nothing.\n-                    }\n-                    _ => {\n+                if let Some(eself) = input.to_self() {\n+                    self.print_explicit_self(&eself)?;\n+                } else {\n+                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n+                        ident.node.name == keywords::Invalid.name()\n+                    } else {\n+                        false\n+                    };\n+                    if !invalid {\n                         self.print_pat(&input.pat)?;\n                         word(&mut self.s, \":\")?;\n                         space(&mut self.s)?;\n                     }\n+                    self.print_type(&input.ty)?;\n                 }\n-                self.print_type(&input.ty)?;\n             }\n         }\n         self.end()\n@@ -2250,8 +2194,7 @@ impl<'a> State<'a> {\n                        unsafety: hir::Unsafety,\n                        decl: &hir::FnDecl,\n                        name: Option<ast::Name>,\n-                       generics: &hir::Generics,\n-                       opt_explicit_self: Option<&hir::ExplicitSelf_>)\n+                       generics: &hir::Generics)\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n@@ -2272,7 +2215,6 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      opt_explicit_self,\n                       &hir::Inherited)?;\n         self.end()\n     }"}, {"sha": "cabc004a65d7d3a957c7a2a1c0fdfea5b4c420b2", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 50, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -976,8 +976,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n                         hir::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n-                            Some((fn_decl, gen, unsafety, constness,\n-                                  item.name, None, item.span))\n+                            Some((fn_decl, gen, unsafety, constness, item.name, item.span))\n                         },\n                         _ => None\n                     }\n@@ -990,7 +989,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   sig.unsafety,\n                                   sig.constness,\n                                   item.name,\n-                                  Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n                         _ => None,\n@@ -1004,7 +1002,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                   sig.unsafety,\n                                   sig.constness,\n                                   item.name,\n-                                  Some(&sig.explicit_self.node),\n                                   item.span))\n                         }\n                         _ => None\n@@ -1014,13 +1011,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             },\n             None => None\n         };\n-        let (fn_decl, generics, unsafety, constness, name, expl_self, span)\n+        let (fn_decl, generics, unsafety, constness, name, span)\n                                     = node_inner.expect(\"expect item fn\");\n-        let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n-                                       generics, same_regions, &life_giver);\n-        let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name,\n-                                      expl_self.as_ref(), &generics, span);\n+        let rebuilder = Rebuilder::new(self.tcx, fn_decl, generics, same_regions, &life_giver);\n+        let (fn_decl, generics) = rebuilder.rebuild();\n+        self.give_expl_lifetime_param(err, &fn_decl, unsafety, constness, name, &generics, span);\n     }\n }\n \n@@ -1038,7 +1033,6 @@ struct RebuildPathInfo<'a> {\n struct Rebuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     fn_decl: &'a hir::FnDecl,\n-    expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n     generics: &'a hir::Generics,\n     same_regions: &'a [SameRegions],\n     life_giver: &'a LifeGiver,\n@@ -1054,15 +1048,13 @@ enum FreshOrKept {\n impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            fn_decl: &'a hir::FnDecl,\n-           expl_self_opt: Option<&'a hir::ExplicitSelf_>,\n            generics: &'a hir::Generics,\n            same_regions: &'a [SameRegions],\n            life_giver: &'a LifeGiver)\n            -> Rebuilder<'a, 'gcx, 'tcx> {\n         Rebuilder {\n             tcx: tcx,\n             fn_decl: fn_decl,\n-            expl_self_opt: expl_self_opt,\n             generics: generics,\n             same_regions: same_regions,\n             life_giver: life_giver,\n@@ -1071,9 +1063,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn rebuild(&self)\n-               -> (hir::FnDecl, Option<hir::ExplicitSelf_>, hir::Generics) {\n-        let mut expl_self_opt = self.expl_self_opt.cloned();\n+    fn rebuild(&self) -> (hir::FnDecl, hir::Generics) {\n         let mut inputs = self.fn_decl.inputs.clone();\n         let mut output = self.fn_decl.output.clone();\n         let mut ty_params = self.generics.ty_params.clone();\n@@ -1089,8 +1079,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 Kept => { kept_lifetimes.insert(lifetime.name); }\n                 _ => ()\n             }\n-            expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n-                                                   &anon_nums, &region_names);\n             inputs = self.rebuild_args_ty(&inputs[..], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n@@ -1110,7 +1098,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n             output: output,\n             variadic: self.fn_decl.variadic\n         };\n-        (new_fn_decl, expl_self_opt, generics)\n+        (new_fn_decl, generics)\n     }\n \n     fn pick_lifetime(&self,\n@@ -1250,34 +1238,6 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         }).collect()\n     }\n \n-    fn rebuild_expl_self(&self,\n-                         expl_self_opt: Option<hir::ExplicitSelf_>,\n-                         lifetime: hir::Lifetime,\n-                         anon_nums: &HashSet<u32>,\n-                         region_names: &HashSet<ast::Name>)\n-                         -> Option<hir::ExplicitSelf_> {\n-        match expl_self_opt {\n-            Some(ref expl_self) => match *expl_self {\n-                hir::SelfRegion(lt_opt, muta, id) => match lt_opt {\n-                    Some(lt) => if region_names.contains(&lt.name) {\n-                        return Some(hir::SelfRegion(Some(lifetime), muta, id));\n-                    },\n-                    None => {\n-                        let anon = self.cur_anon.get();\n-                        self.inc_and_offset_cur_anon(1);\n-                        if anon_nums.contains(&anon) {\n-                            self.track_anon(anon);\n-                            return Some(hir::SelfRegion(Some(lifetime), muta, id));\n-                        }\n-                    }\n-                },\n-                _ => ()\n-            },\n-            None => ()\n-        }\n-        expl_self_opt\n-    }\n-\n     fn rebuild_generics(&self,\n                         generics: &hir::Generics,\n                         add: &Vec<hir::Lifetime>,\n@@ -1575,11 +1535,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n                                 name: ast::Name,\n-                                opt_explicit_self: Option<&hir::ExplicitSelf_>,\n                                 generics: &hir::Generics,\n                                 span: Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name,\n-                                                 opt_explicit_self, generics);\n+        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, name, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n         err.span_help(span, &msg[..]);"}, {"sha": "0801f8f4ac7ef8bc63e5d18325b6fc2fb89c3210", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -889,11 +889,6 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n         run_lints!(self, check_lifetime_def, late_passes, lt);\n     }\n \n-    fn visit_explicit_self(&mut self, es: &hir::ExplicitSelf) {\n-        run_lints!(self, check_explicit_self, late_passes, es);\n-        hir_visit::walk_explicit_self(self, es);\n-    }\n-\n     fn visit_path(&mut self, p: &hir::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, late_passes, p, id);\n         hir_visit::walk_path(self, p);"}, {"sha": "932f2882b496335a8deb23d0c1a0675991779ea3", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -483,7 +483,6 @@ impl<'a> LifetimeContext<'a> {\n             FnKind::Method(_, sig, _, _) => {\n                 intravisit::walk_fn_decl(self, fd);\n                 self.visit_generics(&sig.generics);\n-                self.visit_explicit_self(&sig.explicit_self);\n             }\n             FnKind::Closure(_) => {\n                 intravisit::walk_fn_decl(self, fd);"}, {"sha": "e914c38963cab872d9c298f389678c9aaa395b52", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -172,7 +172,6 @@ mod svh_visitor {\n         SawImplItem,\n         SawStructField,\n         SawVariant,\n-        SawExplicitSelf,\n         SawPath,\n         SawBlock,\n         SawPat,\n@@ -391,10 +390,6 @@ mod svh_visitor {\n             SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n-        fn visit_explicit_self(&mut self, es: &'a ExplicitSelf) {\n-            SawExplicitSelf.hash(self.st); visit::walk_explicit_self(self, es)\n-        }\n-\n         fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }"}, {"sha": "f1e744098b960bd0d1068a040620ce321cb8ad1c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -831,8 +831,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n-                                if sig.explicit_self.node == hir::SelfStatic &&\n-                                      self.item_is_public(&impl_item.id, &impl_item.vis) {\n+                                if !sig.decl.has_self() &&\n+                                        self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }"}, {"sha": "60c8724b8db6e90e279774a7e7ecdb038c9564f3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -582,7 +582,6 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n             }\n             FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n-                self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind\n             }\n             FnKind::Closure => ClosureRibKind(node_id),"}, {"sha": "4faefb610562df32e0dfdebda5b327ca830a4229", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 36, "deletions": 41, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -75,7 +75,7 @@ use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::parse::token::{self, keywords};\n \n use rustc::hir::print as pprust;\n-use rustc::hir;\n+use rustc::hir::{self, SelfKind};\n use rustc_back::slice;\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -166,11 +166,6 @@ struct ConvertedBinding<'tcx> {\n     span: Span,\n }\n \n-struct SelfInfo<'a, 'tcx> {\n-    untransformed_self_ty: Ty<'tcx>,\n-    explicit_self: &'a hir::ExplicitSelf,\n-}\n-\n type TraitAndProjections<'tcx> = (ty::PolyTraitRef<'tcx>, Vec<ty::PolyProjectionPredicate<'tcx>>);\n \n pub fn ast_region_to_region(tcx: TyCtxt, lifetime: &hir::Lifetime)\n@@ -1719,33 +1714,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                         sig: &hir::MethodSig,\n                         untransformed_self_ty: Ty<'tcx>)\n                         -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n-        let self_info = Some(SelfInfo {\n-            untransformed_self_ty: untransformed_self_ty,\n-            explicit_self: &sig.explicit_self,\n-        });\n         let (bare_fn_ty, optional_explicit_self_category) =\n             self.ty_of_method_or_bare_fn(sig.unsafety,\n                                          sig.abi,\n-                                         self_info,\n+                                         Some(untransformed_self_ty),\n                                          &sig.decl);\n-        (bare_fn_ty, optional_explicit_self_category.unwrap())\n+        (bare_fn_ty, optional_explicit_self_category)\n     }\n \n     pub fn ty_of_bare_fn(&self,\n-                         unsafety: hir::Unsafety, abi: abi::Abi,\n+                         unsafety: hir::Unsafety,\n+                         abi: abi::Abi,\n                          decl: &hir::FnDecl)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        let (bare_fn_ty, _) = self.ty_of_method_or_bare_fn(unsafety, abi, None, decl);\n-        bare_fn_ty\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl).0\n     }\n \n     fn ty_of_method_or_bare_fn<'a>(&self,\n                                    unsafety: hir::Unsafety,\n                                    abi: abi::Abi,\n-                                   opt_self_info: Option<SelfInfo<'a, 'tcx>>,\n+                                   opt_untransformed_self_ty: Option<Ty<'tcx>>,\n                                    decl: &hir::FnDecl)\n-                                   -> (&'tcx ty::BareFnTy<'tcx>,\n-                                       Option<ty::ExplicitSelfCategory>)\n+                                   -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n@@ -1758,9 +1748,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // lifetime elision, we can determine it in two ways. First (determined\n         // here), if self is by-reference, then the implied output region is the\n         // region of the self parameter.\n-        let (self_ty, explicit_self_category) = match opt_self_info {\n-            None => (None, None),\n-            Some(self_info) => self.determine_self_type(&rb, self_info)\n+        let explicit_self = decl.inputs.get(0).and_then(hir::Arg::to_self);\n+        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, explicit_self) {\n+            (Some(untransformed_self_ty), Some(explicit_self)) => {\n+                let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n+                                                         &explicit_self);\n+                (Some(self_type.0), self_type.1)\n+            }\n+            _ => (None, ty::ExplicitSelfCategory::Static),\n         };\n \n         // HACK(eddyb) replace the fake self type in the AST with the actual type.\n@@ -1778,7 +1773,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // reference) in the arguments, then any anonymous regions in the output\n         // have that lifetime.\n         let implied_output_region = match explicit_self_category {\n-            Some(ty::ExplicitSelfCategory::ByReference(region, _)) => Ok(region),\n+            ty::ExplicitSelfCategory::ByReference(region, _) => Ok(region),\n             _ => self.find_implied_output_region(&arg_tys, arg_pats)\n         };\n \n@@ -1803,29 +1798,29 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn determine_self_type<'a>(&self,\n                                rscope: &RegionScope,\n-                               self_info: SelfInfo<'a, 'tcx>)\n-                               -> (Option<Ty<'tcx>>, Option<ty::ExplicitSelfCategory>)\n+                               untransformed_self_ty: Ty<'tcx>,\n+                               explicit_self: &hir::ExplicitSelf)\n+                               -> (Ty<'tcx>, ty::ExplicitSelfCategory)\n     {\n-        let self_ty = self_info.untransformed_self_ty;\n-        return match self_info.explicit_self.node {\n-            hir::SelfStatic => (None, Some(ty::ExplicitSelfCategory::Static)),\n-            hir::SelfValue(_) => {\n-                (Some(self_ty), Some(ty::ExplicitSelfCategory::ByValue))\n+        return match explicit_self.node {\n+            SelfKind::Value(..) => {\n+                (untransformed_self_ty, ty::ExplicitSelfCategory::ByValue)\n             }\n-            hir::SelfRegion(ref lifetime, mutability, _) => {\n+            SelfKind::Region(ref lifetime, mutability) => {\n                 let region =\n-                    self.opt_ast_region_to_region(rscope,\n-                                                  self_info.explicit_self.span,\n-                                                  lifetime);\n-                (Some(self.tcx().mk_ref(\n+                    self.opt_ast_region_to_region(\n+                                             rscope,\n+                                             explicit_self.span,\n+                                             lifetime);\n+                (self.tcx().mk_ref(\n                     self.tcx().mk_region(region),\n                     ty::TypeAndMut {\n-                        ty: self_ty,\n+                        ty: untransformed_self_ty,\n                         mutbl: mutability\n-                    })),\n-                 Some(ty::ExplicitSelfCategory::ByReference(region, mutability)))\n+                    }),\n+                 ty::ExplicitSelfCategory::ByReference(region, mutability))\n             }\n-            hir::SelfExplicit(ref ast_type, _) => {\n+            SelfKind::Explicit(ref ast_type, _) => {\n                 let explicit_type = self.ast_ty_to_ty(rscope, &ast_type);\n \n                 // We wish to (for now) categorize an explicit self\n@@ -1857,13 +1852,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // type has two, so we end up with\n                 // ExplicitSelfCategory::ByReference.\n \n-                let impl_modifiers = count_modifiers(self_info.untransformed_self_ty);\n+                let impl_modifiers = count_modifiers(untransformed_self_ty);\n                 let method_modifiers = count_modifiers(explicit_type);\n \n                 debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={:?} \\\n                        explicit_type={:?} \\\n                        modifiers=({},{})\",\n-                       self_info.untransformed_self_ty,\n+                       untransformed_self_ty,\n                        explicit_type,\n                        impl_modifiers,\n                        method_modifiers);\n@@ -1878,7 +1873,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     }\n                 };\n \n-                (Some(explicit_type), Some(category))\n+                (explicit_type, category)\n             }\n         };\n "}, {"sha": "f5d54123f37b52a018bee19ad27259ba87b8fba6", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -361,7 +361,7 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                 let mut item = method.clean(cx);\n                 item.inner = match item.inner.clone() {\n                     clean::TyMethodItem(clean::TyMethod {\n-                        unsafety, decl, self_, generics, abi\n+                        unsafety, decl, generics, abi\n                     }) => {\n                         let constness = if tcx.sess.cstore.is_const_fn(did) {\n                             hir::Constness::Const\n@@ -373,7 +373,6 @@ pub fn build_impl<'a, 'tcx>(cx: &DocContext,\n                             unsafety: unsafety,\n                             constness: constness,\n                             decl: decl,\n-                            self_: self_,\n                             generics: generics,\n                             abi: abi\n                         })"}, {"sha": "7c7a2cfc21cc9804568d5d7ae57d64b03e4f2d1d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 44, "deletions": 69, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -1025,7 +1025,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n-    pub self_: SelfTy,\n     pub unsafety: hir::Unsafety,\n     pub constness: hir::Constness,\n     pub decl: FnDecl,\n@@ -1034,22 +1033,16 @@ pub struct Method {\n \n impl Clean<Method> for hir::MethodSig {\n     fn clean(&self, cx: &DocContext) -> Method {\n-        let all_inputs = &self.decl.inputs;\n-        let inputs = match self.explicit_self.node {\n-            hir::SelfStatic => &**all_inputs,\n-            _ => &all_inputs[1..]\n-        };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.clean(cx),\n+                values: self.decl.inputs.clean(cx),\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n             attrs: Vec::new()\n         };\n         Method {\n             generics: self.generics.clean(cx),\n-            self_: self.explicit_self.node.clean(cx),\n             unsafety: self.unsafety,\n             constness: self.constness,\n             decl: decl,\n@@ -1063,19 +1056,14 @@ pub struct TyMethod {\n     pub unsafety: hir::Unsafety,\n     pub decl: FnDecl,\n     pub generics: Generics,\n-    pub self_: SelfTy,\n     pub abi: Abi,\n }\n \n impl Clean<TyMethod> for hir::MethodSig {\n     fn clean(&self, cx: &DocContext) -> TyMethod {\n-        let inputs = match self.explicit_self.node {\n-            hir::SelfStatic => &*self.decl.inputs,\n-            _ => &self.decl.inputs[1..]\n-        };\n         let decl = FnDecl {\n             inputs: Arguments {\n-                values: inputs.clean(cx),\n+                values: self.decl.inputs.clean(cx),\n             },\n             output: self.decl.output.clean(cx),\n             variadic: false,\n@@ -1084,34 +1072,12 @@ impl Clean<TyMethod> for hir::MethodSig {\n         TyMethod {\n             unsafety: self.unsafety.clone(),\n             decl: decl,\n-            self_: self.explicit_self.node.clean(cx),\n             generics: self.generics.clean(cx),\n             abi: self.abi\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n-pub enum SelfTy {\n-    SelfStatic,\n-    SelfValue,\n-    SelfBorrowed(Option<Lifetime>, Mutability),\n-    SelfExplicit(Type),\n-}\n-\n-impl Clean<SelfTy> for hir::ExplicitSelf_ {\n-    fn clean(&self, cx: &DocContext) -> SelfTy {\n-        match *self {\n-            hir::SelfStatic => SelfStatic,\n-            hir::SelfValue(_) => SelfValue,\n-            hir::SelfRegion(ref lt, ref mt, _) => {\n-                SelfBorrowed(lt.clean(cx), mt.clean(cx))\n-            }\n-            hir::SelfExplicit(ref typ, _) => SelfExplicit(typ.clean(cx)),\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n@@ -1150,6 +1116,12 @@ pub struct FnDecl {\n     pub attrs: Vec<Attribute>,\n }\n \n+impl FnDecl {\n+    pub fn has_self(&self) -> bool {\n+        return self.inputs.values.len() > 0 && self.inputs.values[0].name == \"self\";\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Arguments {\n     pub values: Vec<Argument>,\n@@ -1185,9 +1157,6 @@ impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n         } else {\n             cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n         }.peekable();\n-        if let Some(\"self\") = names.peek().map(|s| &s[..]) {\n-            let _ = names.next();\n-        }\n         FnDecl {\n             output: Return(sig.0.output.clean(cx)),\n             attrs: Vec::new(),\n@@ -1212,6 +1181,29 @@ pub struct Argument {\n     pub id: ast::NodeId,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n+pub enum SelfTy {\n+    SelfValue,\n+    SelfBorrowed(Option<Lifetime>, Mutability),\n+    SelfExplicit(Type),\n+}\n+\n+impl Argument {\n+    pub fn to_self(&self) -> Option<SelfTy> {\n+        if self.name == \"self\" {\n+            match self.type_ {\n+                Infer => Some(SelfValue),\n+                BorrowedRef{ref lifetime, mutability, ref type_} if **type_ == Infer => {\n+                    Some(SelfBorrowed(lifetime.clone(), mutability))\n+                }\n+                _ => Some(SelfExplicit(self.type_.clone()))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl Clean<Argument> for hir::Arg {\n     fn clean(&self, cx: &DocContext) -> Argument {\n         Argument {\n@@ -1346,36 +1338,21 @@ impl Clean<Item> for hir::ImplItem {\n \n impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n-        let (self_, sig) = match self.explicit_self {\n-            ty::ExplicitSelfCategory::Static => (hir::SelfStatic.clean(cx),\n-                                                 self.fty.sig.clone()),\n-            s => {\n-                let sig = ty::Binder(ty::FnSig {\n-                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n-                    ..self.fty.sig.0.clone()\n-                });\n-                let s = match s {\n-                    ty::ExplicitSelfCategory::ByValue => SelfValue,\n-                    ty::ExplicitSelfCategory::ByReference(..) => {\n-                        match self.fty.sig.0.inputs[0].sty {\n-                            ty::TyRef(r, mt) => {\n-                                SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n-                            }\n-                            _ => unreachable!(),\n-                        }\n-                    }\n-                    ty::ExplicitSelfCategory::ByBox => {\n-                        SelfExplicit(self.fty.sig.0.inputs[0].clean(cx))\n-                    }\n-                    ty::ExplicitSelfCategory::Static => unreachable!(),\n-                };\n-                (s, sig)\n-            }\n-        };\n-\n         let generics = (&self.generics, &self.predicates,\n                         subst::FnSpace).clean(cx);\n-        let decl = (self.def_id, &sig).clean(cx);\n+        let mut decl = (self.def_id, &self.fty.sig).clean(cx);\n+        match self.explicit_self {\n+            ty::ExplicitSelfCategory::ByValue => {\n+                decl.inputs.values[0].type_ = Infer;\n+            }\n+            ty::ExplicitSelfCategory::ByReference(..) => {\n+                match decl.inputs.values[0].type_ {\n+                    BorrowedRef{ref mut type_, ..} => **type_ = Infer,\n+                    _ => unreachable!(),\n+                }\n+            }\n+            _ => {}\n+        }\n         let provided = match self.container {\n             ty::ImplContainer(..) => false,\n             ty::TraitContainer(did) => {\n@@ -1388,7 +1365,6 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             MethodItem(Method {\n                 unsafety: self.fty.unsafety,\n                 generics: generics,\n-                self_: self_,\n                 decl: decl,\n                 abi: self.fty.abi,\n \n@@ -1399,7 +1375,6 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             TyMethodItem(TyMethod {\n                 unsafety: self.fty.unsafety,\n                 generics: generics,\n-                self_: self_,\n                 decl: decl,\n                 abi: self.fty.abi,\n             })"}, {"sha": "95bf66ed30db2735bcf6a1354ed50ec351b0b3e7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -43,7 +43,7 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n+pub struct Method<'a>(pub &'a clean::FnDecl);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n@@ -642,29 +642,31 @@ impl fmt::Display for clean::FnDecl {\n \n impl<'a> fmt::Display for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Method(selfty, d) = *self;\n+        let decl = self.0;\n         let mut args = String::new();\n-        match *selfty {\n-            clean::SelfStatic => {},\n-            clean::SelfValue => args.push_str(\"self\"),\n-            clean::SelfBorrowed(Some(ref lt), mtbl) => {\n-                args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n-            }\n-            clean::SelfBorrowed(None, mtbl) => {\n-                args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n-            }\n-            clean::SelfExplicit(ref typ) => {\n-                args.push_str(&format!(\"self: {}\", *typ));\n-            }\n-        }\n-        for (i, input) in d.inputs.values.iter().enumerate() {\n+        for (i, input) in decl.inputs.values.iter().enumerate() {\n             if i > 0 || !args.is_empty() { args.push_str(\", \"); }\n-            if !input.name.is_empty() {\n-                args.push_str(&format!(\"{}: \", input.name));\n+            if let Some(selfty) = input.to_self() {\n+                match selfty {\n+                    clean::SelfValue => args.push_str(\"self\"),\n+                    clean::SelfBorrowed(Some(ref lt), mtbl) => {\n+                        args.push_str(&format!(\"&amp;{} {}self\", *lt, MutableSpace(mtbl)));\n+                    }\n+                    clean::SelfBorrowed(None, mtbl) => {\n+                        args.push_str(&format!(\"&amp;{}self\", MutableSpace(mtbl)));\n+                    }\n+                    clean::SelfExplicit(ref typ) => {\n+                        args.push_str(&format!(\"self: {}\", *typ));\n+                    }\n+                }\n+            } else {\n+                if !input.name.is_empty() {\n+                    args.push_str(&format!(\"{}: \", input.name));\n+                }\n+                args.push_str(&format!(\"{}\", input.type_));\n             }\n-            args.push_str(&format!(\"{}\", input.type_));\n         }\n-        write!(f, \"({args}){arrow}\", args = args, arrow = d.output)\n+        write!(f, \"({args}){arrow}\", args = args, arrow = decl.output)\n     }\n }\n "}, {"sha": "005e25b07d42d35c7fe603ffc47549f00330f69d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/766f9b5a2ff2973bc18eddc91b988a2fe476b0a1/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=766f9b5a2ff2973bc18eddc91b988a2fe476b0a1", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc::hir;\n \n-use clean::{self, SelfTy, Attributes, GetDefId};\n+use clean::{self, Attributes, GetDefId};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -592,16 +592,14 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for &(did, ref item) in orphan_methods {\n         match paths.get(&did) {\n             Some(&(ref fqp, _)) => {\n-                // Needed to determine `self` type.\n-                let parent_basename = Some(fqp[fqp.len() - 1].clone());\n                 search_index.push(IndexItem {\n                     ty: shortty(item),\n                     name: item.name.clone().unwrap(),\n                     path: fqp[..fqp.len() - 1].join(\"::\"),\n                     desc: Escape(&shorter(item.doc_value())).to_string(),\n                     parent: Some(did),\n                     parent_idx: None,\n-                    search_type: get_index_search_type(&item, parent_basename),\n+                    search_type: get_index_search_type(&item),\n                 });\n             },\n             None => {}\n@@ -1081,13 +1079,6 @@ impl DocFolder for Cache {\n \n             match parent {\n                 (parent, Some(path)) if is_method || (!self.stripped_mod) => {\n-                    // Needed to determine `self` type.\n-                    let parent_basename = self.parent_stack.first().and_then(|parent| {\n-                        match self.paths.get(parent) {\n-                            Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n-                            _ => None\n-                        }\n-                    });\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n@@ -1101,7 +1092,7 @@ impl DocFolder for Cache {\n                             desc: Escape(&shorter(item.doc_value())).to_string(),\n                             parent: parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, parent_basename),\n+                            search_type: get_index_search_type(&item),\n                         });\n                     }\n                 }\n@@ -2167,7 +2158,6 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n               constness: hir::Constness,\n               abi: abi::Abi,\n               g: &clean::Generics,\n-              selfty: &clean::SelfTy,\n               d: &clean::FnDecl,\n               link: AssocItemLink)\n               -> fmt::Result {\n@@ -2201,18 +2191,18 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(selfty, d),\n+               decl = Method(d),\n                where_clause = WhereClause(g))\n     }\n     match item.inner {\n         clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n-                   m.abi, &m.generics, &m.self_, &m.decl, link)\n+                   m.abi, &m.generics, &m.decl, link)\n         }\n         clean::MethodItem(ref m) => {\n             method(w, item, m.unsafety, m.constness,\n-                   m.abi, &m.generics, &m.self_, &m.decl,\n+                   m.abi, &m.generics, &m.decl,\n                    link)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n@@ -2570,8 +2560,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         let name = item.name.as_ref().unwrap();\n \n         let is_static = match item.inner {\n-            clean::MethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n-            clean::TyMethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n+            clean::MethodItem(ref method) => !method.decl.has_self(),\n+            clean::TyMethodItem(ref method) => !method.decl.has_self(),\n             _ => false\n         };\n \n@@ -2760,27 +2750,15 @@ fn make_item_keywords(it: &clean::Item) -> String {\n     format!(\"{}, {}\", BASIC_KEYWORDS, it.name.as_ref().unwrap())\n }\n \n-fn get_index_search_type(item: &clean::Item,\n-                         parent: Option<String>) -> Option<IndexItemFunctionType> {\n-    let (decl, selfty) = match item.inner {\n-        clean::FunctionItem(ref f) => (&f.decl, None),\n-        clean::MethodItem(ref m) => (&m.decl, Some(&m.self_)),\n-        clean::TyMethodItem(ref m) => (&m.decl, Some(&m.self_)),\n+fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+    let decl = match item.inner {\n+        clean::FunctionItem(ref f) => &f.decl,\n+        clean::MethodItem(ref m) => &m.decl,\n+        clean::TyMethodItem(ref m) => &m.decl,\n         _ => return None\n     };\n \n-    let mut inputs = Vec::new();\n-\n-    // Consider `self` an argument as well.\n-    match parent.and_then(|p| selfty.map(|s| (p, s)) ) {\n-        Some((_, &clean::SelfStatic)) | None => (),\n-        Some((name, _)) => inputs.push(Type { name: Some(name.to_ascii_lowercase()) }),\n-    }\n-\n-    inputs.extend(&mut decl.inputs.values.iter().map(|arg| {\n-        get_index_type(&arg.type_)\n-    }));\n-\n+    let inputs = decl.inputs.values.iter().map(|arg| get_index_type(&arg.type_)).collect();\n     let output = match decl.output {\n         clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n         _ => None"}]}