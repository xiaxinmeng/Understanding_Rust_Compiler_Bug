{"sha": "6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNDcwYTljNGE0MWU5N2NmN2I5ZDlhYjJjYzAwNDVkNzg4OWQwMWY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-11T15:27:54Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-28T17:38:55Z"}, "message": "Add a macro to improve code", "tree": {"sha": "9999890c41ba1958b0bb87615d4249c84948a7a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9999890c41ba1958b0bb87615d4249c84948a7a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f", "html_url": "https://github.com/rust-lang/rust/commit/6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5b6c046de79bf357683d9db191ed6a97c24187c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b6c046de79bf357683d9db191ed6a97c24187c", "html_url": "https://github.com/rust-lang/rust/commit/d5b6c046de79bf357683d9db191ed6a97c24187c"}], "stats": {"total": 156, "additions": 39, "deletions": 117}, "files": [{"sha": "3cc95260e3bd6e1ef569f33e42d85641e984d6bf", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 39, "deletions": 117, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=6d470a9c4a41e97cf7b9d9ab2cc0045d7889d01f", "patch": "@@ -104,6 +104,25 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n+macro_rules! event_loop_break {\n+    ($parser:expr, $toc_builder:expr, $shorter:expr, $buf:expr, $($end_event:pat)|*) => {{\n+        while let Some(event) = $parser.next() {\n+            match event {\n+                $($end_event)|* => break,\n+                Event::Text(ref s) => {\n+                    $buf.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak if !$buf.is_empty() => {\n+                    $buf.push(' ');\n+                }\n+                x => {\n+                    looper($parser, &mut $buf, Some(x), $toc_builder, $shorter);\n+                }\n+            }\n+        }\n+    }}\n+}\n+\n pub fn render(w: &mut fmt::Formatter,\n               s: &str,\n               print_toc: bool,\n@@ -186,21 +205,10 @@ pub fn render(w: &mut fmt::Formatter,\n         });\n     }\n \n-    fn header(parser: &mut Parser, level: i32, toc_builder: &mut Option<TocBuilder>,\n-              buffer: &mut String) {\n+    fn header(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+              shorter: MarkdownOutputStyle, level: i32) {\n         let mut ret = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Header(_)) => break,\n-                Event::Text(ref s) => {\n-                    ret.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !ret.is_empty() => {\n-                    ret.push(' ');\n-                }\n-                _ => {}\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, ret, Event::End(Tag::Header(_)));\n         ret = ret.trim_right().to_owned();\n \n         let id = ret.clone();\n@@ -236,82 +244,35 @@ pub fn render(w: &mut fmt::Formatter,\n                                  ret, lvl = level, id = id, sec = sec));\n     }\n \n-    fn codespan(parser: &mut Parser, buffer: &mut String) {\n+    fn codespan(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Code) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n-                    content.push(' ');\n-                }\n-                _ => {}\n-            }\n-        }\n-        buffer.push_str(&format!(\"<code>{}</code>\", Escape(&collapse_whitespace(content.trim_right()))));\n+        event_loop_break!(parser, toc_builder, shorter, content, Event::End(Tag::Code));\n+        buffer.push_str(&format!(\"<code>{}</code>\",\n+                                 Escape(&collapse_whitespace(content.trim_right()))));\n     }\n \n     fn link(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n             shorter: MarkdownOutputStyle, url: &str, mut title: String) {\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Link(_, _)) => break,\n-                Event::Text(ref s) => {\n-                    title.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !title.is_empty() => {\n-                    title.push(' ');\n-                }\n-                x => {\n-                    looper(parser, &mut title, Some(x), toc_builder, shorter);\n-                }\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, title, Event::End(Tag::Link(_, _)));\n         buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, title));\n     }\n \n     fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n                  shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Paragraph) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n-                    content.push(' ');\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                }\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, content, Event::End(Tag::Paragraph));\n         buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n     }\n \n     fn cell(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n             shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::TableHead) |\n-                    Event::End(Tag::Table(_)) |\n-                    Event::End(Tag::TableRow) |\n-                    Event::End(Tag::TableCell) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak => {\n-                    content.push(' ');\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                }\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, content,\n+                          Event::End(Tag::TableHead) |\n+                              Event::End(Tag::Table(_)) |\n+                              Event::End(Tag::TableRow) |\n+                              Event::End(Tag::TableCell));\n         buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n     }\n \n@@ -381,20 +342,7 @@ pub fn render(w: &mut fmt::Formatter,\n     fn blockquote(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n                   shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::BlockQuote) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n-                    content.push(' ');\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                }\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, content, Event::End(Tag::BlockQuote));\n         buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n     }\n \n@@ -435,40 +383,14 @@ pub fn render(w: &mut fmt::Formatter,\n     fn emphasis(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n                 shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Emphasis) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n-                    content.push(' ');\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                }\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, content, Event::End(Tag::Emphasis));\n         buffer.push_str(&format!(\"<em>{}</em>\", content));\n     }\n \n     fn strong(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n               shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        while let Some(event) = parser.next() {\n-            match event {\n-                Event::End(Tag::Strong) => break,\n-                Event::Text(ref s) => {\n-                    content.push_str(s);\n-                }\n-                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n-                    content.push(' ');\n-                }\n-                x => {\n-                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                }\n-            }\n-        }\n+        event_loop_break!(parser, toc_builder, shorter, content, Event::End(Tag::Strong));\n         buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n     }\n \n@@ -480,10 +402,10 @@ pub fn render(w: &mut fmt::Formatter,\n                     block(parser, buffer, &*lang);\n                 }\n                 Event::Start(Tag::Header(level)) => {\n-                    header(parser, level, toc_builder, buffer);\n+                    header(parser, buffer, toc_builder, shorter, level);\n                 }\n                 Event::Start(Tag::Code) => {\n-                    codespan(parser, buffer);\n+                    codespan(parser, buffer, toc_builder, shorter);\n                 }\n                 Event::Start(Tag::Paragraph) => {\n                     paragraph(parser, buffer, toc_builder, shorter);"}]}