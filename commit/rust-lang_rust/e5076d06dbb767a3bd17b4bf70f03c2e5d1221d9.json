{"sha": "e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1MDc2ZDA2ZGJiNzY3YTNiZDE3YjRiZjcwZjAzYzJlNWQxMjIxZDk=", "commit": {"author": {"name": "HMPerson1", "email": "hmperson1@gmail.com", "date": "2017-10-16T21:06:31Z"}, "committer": {"name": "HMPerson1", "email": "hmperson1@gmail.com", "date": "2017-10-21T00:47:30Z"}, "message": "Add lint for `From<String>`", "tree": {"sha": "6cf043c60c6b12e307745cb43624c6e87cdee735", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf043c60c6b12e307745cb43624c6e87cdee735"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "html_url": "https://github.com/rust-lang/rust/commit/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/comments", "author": {"login": "HMPerson1", "id": 2219904, "node_id": "MDQ6VXNlcjIyMTk5MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2219904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HMPerson1", "html_url": "https://github.com/HMPerson1", "followers_url": "https://api.github.com/users/HMPerson1/followers", "following_url": "https://api.github.com/users/HMPerson1/following{/other_user}", "gists_url": "https://api.github.com/users/HMPerson1/gists{/gist_id}", "starred_url": "https://api.github.com/users/HMPerson1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HMPerson1/subscriptions", "organizations_url": "https://api.github.com/users/HMPerson1/orgs", "repos_url": "https://api.github.com/users/HMPerson1/repos", "events_url": "https://api.github.com/users/HMPerson1/events{/privacy}", "received_events_url": "https://api.github.com/users/HMPerson1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HMPerson1", "id": 2219904, "node_id": "MDQ6VXNlcjIyMTk5MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2219904?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HMPerson1", "html_url": "https://github.com/HMPerson1", "followers_url": "https://api.github.com/users/HMPerson1/followers", "following_url": "https://api.github.com/users/HMPerson1/following{/other_user}", "gists_url": "https://api.github.com/users/HMPerson1/gists{/gist_id}", "starred_url": "https://api.github.com/users/HMPerson1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HMPerson1/subscriptions", "organizations_url": "https://api.github.com/users/HMPerson1/orgs", "repos_url": "https://api.github.com/users/HMPerson1/repos", "events_url": "https://api.github.com/users/HMPerson1/events{/privacy}", "received_events_url": "https://api.github.com/users/HMPerson1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e489f322155113fe911352895a8fee68a9751d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e489f322155113fe911352895a8fee68a9751d7", "html_url": "https://github.com/rust-lang/rust/commit/0e489f322155113fe911352895a8fee68a9751d7"}], "stats": {"total": 290, "additions": 290, "deletions": 0}, "files": [{"sha": "5d9b3226e11b3f1b0e55ba4ed1295ea92302e8e5", "filename": "clippy_lints/src/impl_from_str.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/clippy_lints%2Fsrc%2Fimpl_from_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/clippy_lints%2Fsrc%2Fimpl_from_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimpl_from_str.rs?ref=e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "patch": "@@ -0,0 +1,136 @@\n+use rustc::lint::*;\n+use rustc::hir;\n+use rustc::ty;\n+use syntax_pos::Span;\n+use utils::{method_chain_args, match_def_path, span_lint_and_then, walk_ptrs_ty};\n+use utils::paths::{BEGIN_PANIC, BEGIN_PANIC_FMT, FROM_TRAIT, OPTION, RESULT, STRING};\n+\n+/// **What it does:** Checks for impls of `From<&str>` and `From<String>` that contain `panic!()` or\n+/// `unwrap()`\n+///\n+/// **Why is this bad?** `FromStr` should be used if there's a possibility of failure.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// struct Foo(i32);\n+/// impl From<String> for Foo {\n+///     fn from(s: String) -> Self {\n+///         Foo(s.parse().unwrap())\n+///     }\n+/// }\n+/// ```\n+declare_lint! {\n+    pub IMPL_FROM_STR, Warn,\n+    \"Warn on impls of `From<&str>` and `From<String>` that contain `panic!()` or `unwrap()`\"\n+}\n+\n+pub struct ImplFromStr;\n+\n+impl LintPass for ImplFromStr {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(IMPL_FROM_STR)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplFromStr {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n+        // check for `impl From<???> for ..`\n+        let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n+        if_let_chain!{[\n+            let hir::ItemImpl(.., ref impl_items) = item.node,\n+            let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id),\n+            match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT),\n+        ], {\n+            // check if the type parameter is `str` or `String`\n+            let from_ty_param = impl_trait_ref.substs.type_at(1);\n+            let base_from_ty_param =\n+                walk_ptrs_ty(cx.tcx.normalize_associated_type(&from_ty_param));\n+            if base_from_ty_param.sty == ty::TyStr ||\n+                match_type(cx.tcx, base_from_ty_param, &STRING)\n+            {\n+                lint_impl_body(cx, item.span, impl_items);\n+            }\n+        }}\n+    }\n+}\n+\n+fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_items: &hir::HirVec<hir::ImplItemRef>) {\n+    use rustc::hir::*;\n+    use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n+\n+    struct FindPanicUnwrap<'a, 'tcx: 'a> {\n+        tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+        tables: &'tcx ty::TypeckTables<'tcx>,\n+        result: Vec<Span>,\n+    }\n+\n+    impl<'a, 'tcx: 'a> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx Expr) {\n+            // check for `begin_panic`\n+            if_let_chain!{[\n+                let ExprCall(ref func_expr, _) = expr.node,\n+                let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node,\n+                match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC) ||\n+                    match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC_FMT),\n+            ], {\n+                self.result.push(expr.span);\n+            }}\n+\n+            // check for `unwrap`\n+            if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n+                let reciever_ty = walk_ptrs_ty(self.tables.expr_ty(&arglists[0][0]));\n+                if match_type(self.tcx, reciever_ty, &OPTION) ||\n+                    match_type(self.tcx, reciever_ty, &RESULT)\n+                {\n+                    self.result.push(expr.span);\n+                }\n+            }\n+\n+            // and check sub-expressions\n+            intravisit::walk_expr(self, expr);\n+        }\n+\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+\n+    for impl_item in impl_items {\n+        if_let_chain!{[\n+            impl_item.name == \"from\",\n+            let ImplItemKind::Method(_, body_id) =\n+                cx.tcx.hir.impl_item(impl_item.id).node,\n+        ], {\n+            // check the body for `begin_panic` or `unwrap`\n+            let body = cx.tcx.hir.body(body_id);\n+            let impl_item_def_id = cx.tcx.hir.local_def_id(impl_item.id.node_id);\n+            let mut fpu = FindPanicUnwrap {\n+                tcx: cx.tcx,\n+                tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n+                result: Vec::new(),\n+            };\n+            fpu.visit_expr(&body.value);\n+\n+            // if we've found one, lint\n+            if !fpu.result.is_empty() {\n+                span_lint_and_then(\n+                    cx,\n+                    IMPL_FROM_STR,\n+                    impl_span,\n+                    \"consider implementing `FromStr` instead\",\n+                    move |db| {\n+                        db.span_note(fpu.result, \"potential failure(s)\");\n+                    });\n+            }\n+        }}\n+    }\n+}\n+\n+fn match_type(tcx: ty::TyCtxt, ty: ty::Ty, path: &[&str]) -> bool {\n+    match ty.sty {\n+        ty::TyAdt(adt, _) => match_def_path(tcx, adt.did, path),\n+        _ => false,\n+    }\n+}"}, {"sha": "96bc4fe729c042ed8fc043f108ea9ccfd9b001ef", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "patch": "@@ -100,6 +100,7 @@ pub mod identity_conversion;\n pub mod identity_op;\n pub mod if_let_redundant_pattern_matching;\n pub mod if_not_else;\n+pub mod impl_from_str;\n pub mod infinite_iter;\n pub mod int_plus_one;\n pub mod invalid_ref;\n@@ -341,6 +342,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box identity_conversion::IdentityConversion::default());\n     reg.register_late_lint_pass(box types::ImplicitHasher);\n     reg.register_early_lint_pass(box const_static_lifetime::StaticConst);\n+    reg.register_late_lint_pass(box impl_from_str::ImplFromStr);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -446,6 +448,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         identity_conversion::IDENTITY_CONVERSION,\n         identity_op::IDENTITY_OP,\n         if_let_redundant_pattern_matching::IF_LET_REDUNDANT_PATTERN_MATCHING,\n+        impl_from_str::IMPL_FROM_STR,\n         infinite_iter::INFINITE_ITER,\n         invalid_ref::INVALID_REF,\n         is_unit_expr::UNIT_EXPR,"}, {"sha": "96ccddaf2d04c1ea3b04a41d8907b785ec574f73", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "patch": "@@ -6,6 +6,7 @@ pub const ARC: [&str; 3] = [\"alloc\", \"arc\", \"Arc\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BEGIN_PANIC: [&str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n+pub const BEGIN_PANIC_FMT: [&str; 3] = [\"std\", \"panicking\", \"begin_panic_fmt\"];\n pub const BINARY_HEAP: [&str; 3] = [\"alloc\", \"binary_heap\", \"BinaryHeap\"];\n pub const BORROW_TRAIT: [&str; 3] = [\"core\", \"borrow\", \"Borrow\"];\n pub const BOX: [&str; 3] = [\"std\", \"boxed\", \"Box\"];\n@@ -27,6 +28,7 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n+pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];\n pub const HASHMAP: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];"}, {"sha": "d0ebe5d988a52f3e331be356ec1107a888b41217", "filename": "tests/ui/impl_from_str.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/tests%2Fui%2Fimpl_from_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/tests%2Fui%2Fimpl_from_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl_from_str.rs?ref=e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "patch": "@@ -0,0 +1,69 @@\n+// docs example\n+struct Foo(i32);\n+impl From<String> for Foo {\n+    fn from(s: String) -> Self {\n+        Foo(s.parse().unwrap())\n+    }\n+}\n+\n+\n+struct Valid(Vec<u8>);\n+\n+impl<'a> From<&'a str> for Valid {\n+    fn from(s: &'a str) -> Valid {\n+        Valid(s.to_owned().into_bytes())\n+    }\n+}\n+impl From<String> for Valid {\n+    fn from(s: String) -> Valid {\n+        Valid(s.into_bytes())\n+    }\n+}\n+impl From<usize> for Valid {\n+    fn from(i: usize) -> Valid {\n+        if i == 0 {\n+            panic!();\n+        }\n+        Valid(Vec::with_capacity(i))\n+    }\n+}\n+\n+\n+struct Invalid;\n+\n+impl<'a> From<&'a str> for Invalid {\n+    fn from(s: &'a str) -> Invalid {\n+        if !s.is_empty() {\n+            panic!();\n+        }\n+        Invalid\n+    }\n+}\n+\n+impl From<String> for Invalid {\n+    fn from(s: String) -> Invalid {\n+        if !s.is_empty() {\n+            panic!(42);\n+        } else if s.parse::<u32>().unwrap() != 42 {\n+            panic!(\"{:?}\", s);\n+        }\n+        Invalid\n+    }\n+}\n+\n+trait ProjStrTrait {\n+    type ProjString;\n+}\n+impl<T> ProjStrTrait for Box<T> {\n+    type ProjString = String;\n+}\n+impl<'a> From<&'a mut <Box<u32> as ProjStrTrait>::ProjString> for Invalid {\n+    fn from(s: &'a mut <Box<u32> as ProjStrTrait>::ProjString) -> Invalid {\n+        if s.parse::<u32>().ok().unwrap() != 42 {\n+            panic!(\"{:?}\", s);\n+        }\n+        Invalid\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "b394df153e2860865829aebf7d7b77ece5799789", "filename": "tests/ui/impl_from_str.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/tests%2Fui%2Fimpl_from_str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9/tests%2Fui%2Fimpl_from_str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl_from_str.stderr?ref=e5076d06dbb767a3bd17b4bf70f03c2e5d1221d9", "patch": "@@ -0,0 +1,80 @@\n+error: consider implementing `FromStr` instead\n+ --> $DIR/impl_from_str.rs:3:1\n+  |\n+3 | / impl From<String> for Foo {\n+4 | |     fn from(s: String) -> Self {\n+5 | |         Foo(s.parse().unwrap())\n+6 | |     }\n+7 | | }\n+  | |_^\n+  |\n+  = note: `-D impl-from-str` implied by `-D warnings`\n+note: potential failure(s)\n+ --> $DIR/impl_from_str.rs:5:13\n+  |\n+5 |         Foo(s.parse().unwrap())\n+  |             ^^^^^^^^^^^^^^^^^^\n+\n+error: consider implementing `FromStr` instead\n+  --> $DIR/impl_from_str.rs:34:1\n+   |\n+34 | / impl<'a> From<&'a str> for Invalid {\n+35 | |     fn from(s: &'a str) -> Invalid {\n+36 | |         if !s.is_empty() {\n+37 | |             panic!();\n+...  |\n+40 | |     }\n+41 | | }\n+   | |_^\n+   |\n+note: potential failure(s)\n+  --> $DIR/impl_from_str.rs:37:13\n+   |\n+37 |             panic!();\n+   |             ^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: consider implementing `FromStr` instead\n+  --> $DIR/impl_from_str.rs:43:1\n+   |\n+43 | / impl From<String> for Invalid {\n+44 | |     fn from(s: String) -> Invalid {\n+45 | |         if !s.is_empty() {\n+46 | |             panic!(42);\n+...  |\n+51 | |     }\n+52 | | }\n+   | |_^\n+   |\n+note: potential failure(s)\n+  --> $DIR/impl_from_str.rs:46:13\n+   |\n+46 |             panic!(42);\n+   |             ^^^^^^^^^^^\n+47 |         } else if s.parse::<u32>().unwrap() != 42 {\n+   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n+48 |             panic!(\"{:?}\", s);\n+   |             ^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+\n+error: consider implementing `FromStr` instead\n+  --> $DIR/impl_from_str.rs:60:1\n+   |\n+60 | / impl<'a> From<&'a mut <Box<u32> as ProjStrTrait>::ProjString> for Invalid {\n+61 | |     fn from(s: &'a mut <Box<u32> as ProjStrTrait>::ProjString) -> Invalid {\n+62 | |         if s.parse::<u32>().ok().unwrap() != 42 {\n+63 | |             panic!(\"{:?}\", s);\n+...  |\n+66 | |     }\n+67 | | }\n+   | |_^\n+   |\n+note: potential failure(s)\n+  --> $DIR/impl_from_str.rs:62:12\n+   |\n+62 |         if s.parse::<u32>().ok().unwrap() != 42 {\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+63 |             panic!(\"{:?}\", s);\n+   |             ^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in a macro outside of the current crate\n+"}]}