{"sha": "87e729f58a440c2b384f4871fb68f07afdbd3ba6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3ZTcyOWY1OGE0NDBjMmIzODRmNDg3MWZiNjhmMDdhZmRiZDNiYTY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-18T20:34:01Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-07-23T12:20:20Z"}, "message": "thread the `errors_buffer` down into `nll::type_check`.\n\nRight now its solely used for `check_local`, which ... I guess is not surprising?", "tree": {"sha": "d6ca82de1e6a4bb25699c3df1f7b2bc38da11798", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6ca82de1e6a4bb25699c3df1f7b2bc38da11798"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87e729f58a440c2b384f4871fb68f07afdbd3ba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87e729f58a440c2b384f4871fb68f07afdbd3ba6", "html_url": "https://github.com/rust-lang/rust/commit/87e729f58a440c2b384f4871fb68f07afdbd3ba6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87e729f58a440c2b384f4871fb68f07afdbd3ba6/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d3e0aa57190db4519d4e59ab606f685c21bfc7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d3e0aa57190db4519d4e59ab606f685c21bfc7f", "html_url": "https://github.com/rust-lang/rust/commit/3d3e0aa57190db4519d4e59ab606f685c21bfc7f"}], "stats": {"total": 49, "additions": 34, "deletions": 15}, "files": [{"sha": "edc701bad1eb3a28bc88350cf7f915a118ffd6e0", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87e729f58a440c2b384f4871fb68f07afdbd3ba6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e729f58a440c2b384f4871fb68f07afdbd3ba6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=87e729f58a440c2b384f4871fb68f07afdbd3ba6", "patch": "@@ -122,6 +122,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         flow_inits,\n         move_data,\n         elements,\n+        errors_buffer,\n     );\n \n     if let Some(all_facts) = &mut all_facts {"}, {"sha": "a80cd9ff1a4be9aed233df69eaadd24649186b00", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/87e729f58a440c2b384f4871fb68f07afdbd3ba6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87e729f58a440c2b384f4871fb68f07afdbd3ba6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=87e729f58a440c2b384f4871fb68f07afdbd3ba6", "patch": "@@ -41,6 +41,7 @@ use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n use util::liveness::LivenessResults;\n+use rustc_errors::Diagnostic;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -102,6 +103,7 @@ mod liveness;\n ///   constraints for the regions in the types of variables\n /// - `flow_inits` -- results of a maybe-init dataflow analysis\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n+/// - `errors_buffer` -- errors are sent here for future reporting\n pub(crate) fn type_check<'gcx, 'tcx>(\n     infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n@@ -115,6 +117,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n+    errors_buffer: &mut Vec<Diagnostic>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -140,14 +143,13 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             &universal_regions.region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n+            Some(errors_buffer),\n             |cx| {\n                 liveness::generate(cx, mir, liveness, flow_inits, move_data);\n-\n                 cx.equate_inputs_and_outputs(mir, mir_def_id, universal_regions);\n             },\n         );\n     }\n-\n     constraints\n }\n \n@@ -159,6 +161,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    errors_buffer: Option<&mut Vec<Diagnostic>>,\n     mut extra: F,\n )\n     where F: FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>)\n@@ -180,7 +183,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, F>(\n \n     if !errors_reported {\n         // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(mir);\n+        checker.typeck_mir(mir, errors_buffer);\n     }\n \n     extra(&mut checker);\n@@ -1227,7 +1230,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn check_local(&mut self, mir: &Mir<'tcx>, local: Local, local_decl: &LocalDecl<'tcx>) {\n+    fn check_local(&mut self,\n+                   mir: &Mir<'tcx>,\n+                   local: Local,\n+                   local_decl: &LocalDecl<'tcx>,\n+                   errors_buffer: &mut Option<&mut Vec<Diagnostic>>)\n+    {\n         match mir.local_kind(local) {\n             LocalKind::ReturnPointer | LocalKind::Arg => {\n                 // return values of normal functions are required to be\n@@ -1255,14 +1263,21 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // slot or local, so to find all unsized rvalues it is enough\n             // to check all temps, return slots and locals.\n             if let None = self.reported_errors.replace((ty, span)) {\n-                span_err!(\n-                    self.tcx().sess,\n-                    span,\n-                    E0161,\n-                    \"cannot move a value of type {0}: the size of {0} \\\n-                     cannot be statically determined\",\n-                    ty\n-                );\n+                let mut diag = struct_span_err!(self.tcx().sess,\n+                                                span,\n+                                                E0161,\n+                                                \"cannot move a value of type {0}: the size of {0} \\\n+                                                 cannot be statically determined\",\n+                                                ty);\n+                if let Some(ref mut errors_buffer) = *errors_buffer {\n+                    diag.buffer(errors_buffer);\n+                } else {\n+                    // we're allowed to use emit() here because the\n+                    // NLL migration will be turned on (and thus\n+                    // errors will need to be buffered) *only if*\n+                    // errors_buffer is Some.\n+                    diag.emit();\n+                }\n             }\n         }\n     }\n@@ -1742,12 +1757,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n+    fn typeck_mir(&mut self,\n+                  mir: &Mir<'tcx>,\n+                  mut errors_buffer: Option<&mut Vec<Diagnostic>>)\n+    {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);\n \n         for (local, local_decl) in mir.local_decls.iter_enumerated() {\n-            self.check_local(mir, local, local_decl);\n+            self.check_local(mir, local, local_decl, &mut errors_buffer);\n         }\n \n         for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n@@ -1812,7 +1830,7 @@ impl MirPass for TypeckMir {\n \n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, |_| ());\n+            type_check_internal(&infcx, def_id, param_env, mir, &[], None, None, None, |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}]}