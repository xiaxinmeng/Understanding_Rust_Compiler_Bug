{"sha": "9ba3d5e9212bb67166d137efd58fcf5d06906c2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTNkNWU5MjEyYmI2NzE2NmQxMzdlZmQ1OGZjZjVkMDY5MDZjMmE=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-04-05T15:38:48Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-04-05T16:07:14Z"}, "message": "Reinstate fast_reject for overlap checking\n\nThe initial implementation of specialization did not use the\n`fast_reject` mechanism when checking for overlap, which caused a\nserious performance regression in some cases.\n\nThis commit modifies the specialization graph to use simplified types\nfor fast rejection when possible, and along the way refactors the logic\nfor building the specialization graph.\n\nCloses #32499", "tree": {"sha": "cc061a8f6aff8f27a60ff4483cf4d340f7e9aa39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc061a8f6aff8f27a60ff4483cf4d340f7e9aa39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba3d5e9212bb67166d137efd58fcf5d06906c2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba3d5e9212bb67166d137efd58fcf5d06906c2a", "html_url": "https://github.com/rust-lang/rust/commit/9ba3d5e9212bb67166d137efd58fcf5d06906c2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba3d5e9212bb67166d137efd58fcf5d06906c2a/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0d31707cc849bd385ae8677823d1f2bcc8aba41", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0d31707cc849bd385ae8677823d1f2bcc8aba41", "html_url": "https://github.com/rust-lang/rust/commit/b0d31707cc849bd385ae8677823d1f2bcc8aba41"}], "stats": {"total": 232, "additions": 162, "deletions": 70}, "files": [{"sha": "9584c5ea193c602ed8d2dc41928bd51c39772868", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 149, "deletions": 56, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/9ba3d5e9212bb67166d137efd58fcf5d06906c2a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba3d5e9212bb67166d137efd58fcf5d06906c2a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9ba3d5e9212bb67166d137efd58fcf5d06906c2a", "patch": "@@ -18,8 +18,9 @@ use middle::def_id::DefId;\n use infer;\n use traits::{self, ProjectionMode};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n+use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, FnvHashMap};\n \n /// A per-trait graph of impls in specialization order. At the moment, this\n /// graph forms a tree rooted with the trait itself, with all other nodes\n@@ -42,7 +43,124 @@ pub struct Graph {\n     parent: DefIdMap<DefId>,\n \n     // the \"root\" impls are found by looking up the trait's def_id.\n-    children: DefIdMap<Vec<DefId>>,\n+    children: DefIdMap<Children>,\n+}\n+\n+/// Children of a given impl, grouped into blanket/non-blanket varieties as is\n+/// done in `TraitDef`.\n+struct Children {\n+    // Impls of a trait (or specializations of a given impl). To allow for\n+    // quicker lookup, the impls are indexed by a simplified version of their\n+    // `Self` type: impls with a simplifiable `Self` are stored in\n+    // `nonblanket_impls` keyed by it, while all other impls are stored in\n+    // `blanket_impls`.\n+    //\n+    // A similar division is used within `TraitDef`, but the lists there collect\n+    // together *all* the impls for a trait, and are populated prior to building\n+    // the specialization graph.\n+\n+    /// Impls of the trait.\n+    nonblanket_impls: FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n+\n+    /// Blanket impls associated with the trait.\n+    blanket_impls: Vec<DefId>,\n+}\n+\n+/// The result of attempting to insert an impl into a group of children.\n+enum InsertResult<'a, 'tcx: 'a> {\n+    /// The impl was inserted as a new child in this group of children.\n+    BecameNewSibling,\n+\n+    /// The impl replaced an existing impl that specializes it.\n+    Replaced(DefId),\n+\n+    /// The impl is a specialization of an existing child.\n+    ShouldRecurseOn(DefId),\n+\n+    /// The impl has an unresolvable overlap with an existing child (neither\n+    /// specializes the other).\n+    Overlapped(Overlap<'a, 'tcx>),\n+}\n+\n+impl Children {\n+    fn new() -> Children {\n+        Children {\n+            nonblanket_impls: FnvHashMap(),\n+            blanket_impls: vec![],\n+        }\n+    }\n+\n+    /// Insert an impl into this set of children without comparing to any existing impls\n+    fn insert_blindly(&mut self, tcx: &TyCtxt, impl_def_id: DefId) {\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        if let Some(sty) = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false) {\n+            self.nonblanket_impls.entry(sty).or_insert(vec![]).push(impl_def_id)\n+        } else {\n+            self.blanket_impls.push(impl_def_id)\n+        }\n+    }\n+\n+    /// Attempt to insert an impl into this set of children, while comparing for\n+    /// specialiation relationships.\n+    fn insert<'a, 'tcx>(&mut self,\n+                        tcx: &'a TyCtxt<'tcx>,\n+                        impl_def_id: DefId,\n+                        simplified_self: Option<SimplifiedType>)\n+                        -> InsertResult<'a, 'tcx>\n+    {\n+        for slot in match simplified_self {\n+            Some(sty) => self.filtered_mut(sty),\n+            None => self.iter_mut(),\n+        } {\n+            let possible_sibling = *slot;\n+\n+            let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n+            let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n+\n+            if let Some(impl_header) = overlap {\n+                let le = specializes(tcx, impl_def_id, possible_sibling);\n+                let ge = specializes(tcx, possible_sibling, impl_def_id);\n+\n+                if le && !ge {\n+                    debug!(\"descending as child of TraitRef {:?}\",\n+                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+\n+                    // the impl specializes possible_sibling\n+                    return InsertResult::ShouldRecurseOn(possible_sibling);\n+                } else if ge && !le {\n+                    debug!(\"placing as parent of TraitRef {:?}\",\n+                           tcx.impl_trait_ref(possible_sibling).unwrap());\n+\n+                    // possible_sibling specializes the impl\n+                    *slot = impl_def_id;\n+                    return InsertResult::Replaced(possible_sibling);\n+                } else {\n+                    // overlap, but no specialization; error out\n+                    return InsertResult::Overlapped(Overlap {\n+                        with_impl: possible_sibling,\n+                        on_trait_ref: impl_header.trait_ref.unwrap(),\n+                        in_context: infcx,\n+                    });\n+                }\n+            }\n+        }\n+\n+        // no overlap with any potential siblings, so add as a new sibling\n+        debug!(\"placing as new sibling\");\n+        self.insert_blindly(tcx, impl_def_id);\n+        InsertResult::BecameNewSibling\n+    }\n+\n+    fn iter_mut<'a>(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+        let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter_mut());\n+        Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n+    }\n+\n+    fn filtered_mut<'a>(&'a mut self, sty: SimplifiedType)\n+                        -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n+        let nonblanket = self.nonblanket_impls.entry(sty).or_insert(vec![]).iter_mut();\n+        Box::new(self.blanket_impls.iter_mut().chain(nonblanket))\n+    }\n }\n \n impl Graph {\n@@ -78,78 +196,53 @@ impl Graph {\n                    trait_ref, impl_def_id, trait_def_id);\n \n             self.parent.insert(impl_def_id, trait_def_id);\n-            self.children.entry(trait_def_id).or_insert(vec![]).push(impl_def_id);\n+            self.children.entry(trait_def_id).or_insert(Children::new())\n+                .insert_blindly(tcx, impl_def_id);\n             return Ok(());\n         }\n \n         let mut parent = trait_def_id;\n+        let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n-        // Ugly hack around borrowck limitations. Assigned only in the case\n-        // where we bump downward an existing node in the graph.\n-        let child_to_insert;\n-\n-        'descend: loop {\n-            let mut possible_siblings = self.children.entry(parent).or_insert(vec![]);\n-\n-            for slot in possible_siblings.iter_mut() {\n-                let possible_sibling = *slot;\n-\n-                let infcx = infer::new_infer_ctxt(tcx, &tcx.tables, None, ProjectionMode::Topmost);\n-                let overlap = traits::overlapping_impls(&infcx, possible_sibling, impl_def_id);\n-\n-                if let Some(impl_header) = overlap {\n-                    let le = specializes(tcx, impl_def_id, possible_sibling);\n-                    let ge = specializes(tcx, possible_sibling, impl_def_id);\n-\n-                    if le && !ge {\n-                        debug!(\"descending as child of TraitRef {:?}\",\n-                               tcx.impl_trait_ref(possible_sibling).unwrap());\n-\n-                        // the impl specializes possible_sibling\n-                        parent = possible_sibling;\n-                        continue 'descend;\n-                    } else if ge && !le {\n-                        debug!(\"placing as parent of TraitRef {:?}\",\n-                               tcx.impl_trait_ref(possible_sibling).unwrap());\n-\n-                        // possible_sibling specializes the impl\n-                        *slot = impl_def_id;\n-                        self.parent.insert(impl_def_id, parent);\n-                        self.parent.insert(possible_sibling, impl_def_id);\n-                        // we have to defer the insertion, because we can't\n-                        // relinquish the borrow of `self.children`\n-                        child_to_insert = possible_sibling;\n-                        break 'descend;\n-                    } else {\n-                        // overlap, but no specialization; error out\n-                        return Err(Overlap {\n-                            with_impl: possible_sibling,\n-                            on_trait_ref: impl_header.trait_ref.unwrap(),\n-                            in_context: infcx,\n-                        });\n-                    }\n+        // Descend the specialization tree, where `parent` is the current parent node\n+        loop {\n+            use self::InsertResult::*;\n+\n+            let insert_result = self.children.entry(parent).or_insert(Children::new())\n+                .insert(tcx, impl_def_id, simplified);\n+\n+            match insert_result {\n+                BecameNewSibling => {\n+                    break;\n+                }\n+                Replaced(new_child) => {\n+                    self.parent.insert(new_child, impl_def_id);\n+                    let mut new_children = Children::new();\n+                    new_children.insert_blindly(tcx, new_child);\n+                    self.children.insert(impl_def_id, new_children);\n+                    break;\n+                }\n+                ShouldRecurseOn(new_parent) => {\n+                    parent = new_parent;\n+                }\n+                Overlapped(error) => {\n+                    return Err(error);\n                 }\n             }\n-\n-            // no overlap with any potential siblings, so add as a new sibling\n-            debug!(\"placing as new sibling\");\n-            self.parent.insert(impl_def_id, parent);\n-            possible_siblings.push(impl_def_id);\n-            return Ok(());\n         }\n \n-        self.children.insert(impl_def_id, vec![child_to_insert]);\n+        self.parent.insert(impl_def_id, parent);\n         Ok(())\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, parent: DefId, child: DefId) {\n+    pub fn record_impl_from_cstore(&mut self, tcx: &TyCtxt, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             panic!(\"When recording an impl from the crate store, information about its parent \\\n                     was already present.\");\n         }\n \n-        self.children.entry(parent).or_insert(vec![]).push(child);\n+        self.children.entry(parent).or_insert(Children::new()).insert_blindly(tcx, child);\n     }\n \n     /// The parent of a given impl, which is the def id of the trait when the"}, {"sha": "51f330686db6eb3c11bd4b5b6e9a7caa79300cea", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9ba3d5e9212bb67166d137efd58fcf5d06906c2a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba3d5e9212bb67166d137efd58fcf5d06906c2a/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=9ba3d5e9212bb67166d137efd58fcf5d06906c2a", "patch": "@@ -15,7 +15,7 @@ use ty;\n use ty::fast_reject;\n use ty::{Ty, TyCtxt, TraitRef};\n use std::borrow::{Borrow};\n-use std::cell::{Cell, Ref, RefCell};\n+use std::cell::{Cell, RefCell};\n use syntax::ast::Name;\n use rustc_front::hir;\n use util::nodemap::FnvHashMap;\n@@ -43,10 +43,17 @@ pub struct TraitDef<'tcx> {\n     /// for resolving `X::Foo` type markers.\n     pub associated_type_names: Vec<Name>,\n \n-    // Impls of this trait. To allow for quicker lookup, the impls are indexed\n-    // by a simplified version of their Self type: impls with a simplifiable\n-    // Self are stored in nonblanket_impls keyed by it, while all other impls\n-    // are stored in blanket_impls.\n+    // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n+    // simplified version of their `Self` type: impls with a simplifiable `Self`\n+    // are stored in `nonblanket_impls` keyed by it, while all other impls are\n+    // stored in `blanket_impls`.\n+    //\n+    // A similar division is used within `specialization_graph`, but the ones\n+    // here are (1) stored as a flat list for the trait and (2) populated prior\n+    // to -- and used while -- determining specialization order.\n+    //\n+    // FIXME: solve the reentrancy issues and remove these lists in favor of the\n+    // ones in `specialization_graph`.\n     //\n     // These lists are tracked by `DepNode::TraitImpls`; we don't use\n     // a DepTrackingMap but instead have the `TraitDef` insert the\n@@ -184,7 +191,7 @@ impl<'tcx> TraitDef<'tcx> {\n             // if the impl is non-local, it's placed directly into the\n             // specialization graph using parent information drawn from metadata.\n             self.specialization_graph.borrow_mut()\n-                .record_impl_from_cstore(parent_impl, impl_def_id)\n+                .record_impl_from_cstore(tcx, parent_impl, impl_def_id)\n         }\n     }\n \n@@ -261,14 +268,6 @@ impl<'tcx> TraitDef<'tcx> {\n             }\n         }\n     }\n-\n-    pub fn borrow_impl_lists<'s>(&'s self, tcx: &TyCtxt<'tcx>)\n-                                 -> (Ref<'s, Vec<DefId>>,\n-                                     Ref<'s, FnvHashMap<fast_reject::SimplifiedType, Vec<DefId>>>) {\n-        self.read_trait_impls(tcx);\n-        (self.blanket_impls.borrow(), self.nonblanket_impls.borrow())\n-    }\n-\n }\n \n bitflags! {"}]}