{"sha": "ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae", "node_id": "C_kwDOAAsO6NoAKGVmNWUzMWFjMDY3MTZlMmZkNWM1ZjBkYzA5OTFiMzc2MGRjMGMzYWU", "commit": {"author": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-11-01T03:04:42Z"}, "committer": {"name": "jackh726", "email": "jack.huey@umassmed.edu", "date": "2021-11-01T03:04:42Z"}, "message": "Move outlives checking to separate functions", "tree": {"sha": "85d3e4ef9938eb6f388dadde60b88eabbe06a093", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85d3e4ef9938eb6f388dadde60b88eabbe06a093"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae", "html_url": "https://github.com/rust-lang/rust/commit/ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18421b1f08420869181d8bf08114bef6547215f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/18421b1f08420869181d8bf08114bef6547215f8", "html_url": "https://github.com/rust-lang/rust/commit/18421b1f08420869181d8bf08114bef6547215f8"}], "stats": {"total": 271, "additions": 146, "deletions": 125}, "files": [{"sha": "3f5d4383838a884ad5292804e9b225519905f4d0", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 146, "deletions": 125, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=ef5e31ac06716e2fd5c5f0dc0991b3760dc0c3ae", "patch": "@@ -339,76 +339,36 @@ fn check_gat_where_clauses(\n         // reflected in a where clause on the GAT itself.\n         for (region, region_idx) in &visitor.regions {\n             for (ty, ty_idx) in &visitor.types {\n-                // Unfortunately, we have to use a new `InferCtxt` for each\n-                // pair, because region constraints get added and solved there,\n-                // and we need to test each pair individually.\n-                tcx.infer_ctxt().enter(|infcx| {\n-                    let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-                    outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n-                    outlives_environment.save_implied_bounds(id);\n-                    let region_bound_pairs =\n-                        outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n-\n-                    let cause =\n-                        ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-                    let sup_type = *ty;\n-                    let sub_region = region;\n-\n-                    let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-                        infer::RelateParamBound(cause.span, sup_type, None)\n-                    });\n-\n-                    let outlives = &mut TypeOutlives::new(\n-                        &infcx,\n-                        tcx,\n-                        &region_bound_pairs,\n-                        Some(tcx.lifetimes.re_root_empty),\n-                        param_env,\n-                    );\n-                    // In our example, requires that Self: 'a\n-                    outlives.type_must_outlive(origin, sup_type, sub_region);\n-\n-                    let errors = infcx.resolve_regions(\n-                        trait_item.def_id.to_def_id(),\n-                        &outlives_environment,\n-                        RegionckMode::default(),\n-                    );\n-\n-                    debug!(?errors, \"errors\");\n-\n-                    // If we were able to prove that Self: 'a without an error,\n-                    // it must be because of the implied or explicit bounds...\n-                    if errors.is_empty() {\n-                        debug!(?ty_idx, ?region_idx);\n-                        debug!(\"required clause: {} must outlive {}\", ty, region);\n-                        // Translate into the generic parameters of the GAT. In\n-                        // our example, the type was Self, which will also be\n-                        // Self in the GAT.\n-                        let ty_param = generics.param_at(*ty_idx, tcx);\n-                        let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n-                            index: ty_param.index,\n-                            name: ty_param.name,\n+                // In our example, requires that Self: 'a\n+                if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n+                    debug!(?ty_idx, ?region_idx);\n+                    debug!(\"required clause: {} must outlive {}\", ty, region);\n+                    // Translate into the generic parameters of the GAT. In\n+                    // our example, the type was Self, which will also be\n+                    // Self in the GAT.\n+                    let ty_param = generics.param_at(*ty_idx, tcx);\n+                    let ty_param = tcx.mk_ty(ty::Param(ty::ParamTy {\n+                        index: ty_param.index,\n+                        name: ty_param.name,\n+                    }));\n+                    // Same for the region. In our example, 'a corresponds\n+                    // to the 'me parameter.\n+                    let region_param = generics.param_at(*region_idx, tcx);\n+                    let region_param =\n+                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                            def_id: region_param.def_id,\n+                            index: region_param.index,\n+                            name: region_param.name,\n                         }));\n-                        // Same for the region. In our example, 'a corresponds\n-                        // to the 'me parameter.\n-                        let region_param = generics.param_at(*region_idx, tcx);\n-                        let region_param =\n-                            tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                                def_id: region_param.def_id,\n-                                index: region_param.index,\n-                                name: region_param.name,\n-                            }));\n-                        // The predicate we expect to see. (In our example,\n-                        // `Self: 'me`.)\n-                        let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n-                            ty_param,\n-                            region_param,\n-                        ));\n-                        let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                        function_clauses.insert(clause);\n-                    }\n-                });\n+                    // The predicate we expect to see. (In our example,\n+                    // `Self: 'me`.)\n+                    let clause = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                        ty_param,\n+                        region_param,\n+                    ));\n+                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                    function_clauses.insert(clause);\n+                }\n             }\n         }\n \n@@ -422,62 +382,33 @@ fn check_gat_where_clauses(\n                     continue;\n                 }\n \n-                // Unfortunately, we have to use a new `InferCtxt` for each\n-                // pair, because region constraints get added and solved there,\n-                // and we need to test each pair individually.\n-                tcx.infer_ctxt().enter(|infcx| {\n-                    let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-                    outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n-                    outlives_environment.save_implied_bounds(id);\n-\n-                    let cause =\n-                        ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-                    let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-                        infer::RelateRegionParamBound(cause.span)\n-                    });\n-\n-                    use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n-                    (&infcx).push_sub_region_constraint(origin, region_a, region_b);\n-\n-                    let errors = infcx.resolve_regions(\n-                        trait_item.def_id.to_def_id(),\n-                        &outlives_environment,\n-                        RegionckMode::default(),\n-                    );\n-\n-                    debug!(?errors, \"errors\");\n-\n-                    // If we were able to prove that Self: 'a without an error,\n-                    // it must be because of the implied or explicit bounds...\n-                    if errors.is_empty() {\n-                        debug!(?region_a_idx, ?region_b_idx);\n-                        debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n-                        // Translate into the generic parameters of the GAT.\n-                        let region_a_param = generics.param_at(*region_a_idx, tcx);\n-                        let region_a_param =\n-                            tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                                def_id: region_a_param.def_id,\n-                                index: region_a_param.index,\n-                                name: region_a_param.name,\n-                            }));\n-                        // Same for the region.\n-                        let region_b_param = generics.param_at(*region_b_idx, tcx);\n-                        let region_b_param =\n-                            tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n-                                def_id: region_b_param.def_id,\n-                                index: region_b_param.index,\n-                                name: region_b_param.name,\n-                            }));\n-                        // The predicate we expect to see.\n-                        let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n-                            region_a_param,\n-                            region_b_param,\n-                        ));\n-                        let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n-                        function_clauses.insert(clause);\n-                    }\n-                });\n+                if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n+                    debug!(?region_a_idx, ?region_b_idx);\n+                    debug!(\"required clause: {} must outlive {}\", region_a, region_b);\n+                    // Translate into the generic parameters of the GAT.\n+                    let region_a_param = generics.param_at(*region_a_idx, tcx);\n+                    let region_a_param =\n+                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                            def_id: region_a_param.def_id,\n+                            index: region_a_param.index,\n+                            name: region_a_param.name,\n+                        }));\n+                    // Same for the region.\n+                    let region_b_param = generics.param_at(*region_b_idx, tcx);\n+                    let region_b_param =\n+                        tcx.mk_region(ty::RegionKind::ReEarlyBound(ty::EarlyBoundRegion {\n+                            def_id: region_b_param.def_id,\n+                            index: region_b_param.index,\n+                            name: region_b_param.name,\n+                        }));\n+                    // The predicate we expect to see.\n+                    let clause = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                        region_a_param,\n+                        region_b_param,\n+                    ));\n+                    let clause = tcx.mk_predicate(ty::Binder::dummy(clause));\n+                    function_clauses.insert(clause);\n+                }\n             }\n         }\n \n@@ -530,6 +461,96 @@ fn check_gat_where_clauses(\n     }\n }\n \n+/// Given a known `param_env` and a set of well formed types, can we prove that\n+/// `ty` outlives `region`.\n+fn ty_known_to_outlive<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    ty: Ty<'tcx>,\n+    region: ty::Region<'tcx>,\n+) -> bool {\n+    // Unfortunately, we have to use a new `InferCtxt` each call, because\n+    // region constraints get added and solved there and we need to test each\n+    // call individually.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n+        outlives_environment.save_implied_bounds(id);\n+        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n+\n+        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n+\n+        let sup_type = ty;\n+        let sub_region = region;\n+\n+        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n+            infer::RelateParamBound(cause.span, sup_type, None)\n+        });\n+\n+        let outlives = &mut TypeOutlives::new(\n+            &infcx,\n+            tcx,\n+            &region_bound_pairs,\n+            Some(infcx.tcx.lifetimes.re_root_empty),\n+            param_env,\n+        );\n+        outlives.type_must_outlive(origin, sup_type, sub_region);\n+\n+        let errors = infcx.resolve_regions(\n+            id.expect_owner().to_def_id(),\n+            &outlives_environment,\n+            RegionckMode::default(),\n+        );\n+\n+        debug!(?errors, \"errors\");\n+\n+        // If we were able to prove that the type outlives the region without\n+        // an error, it must be because of the implied or explicit bounds...\n+        errors.is_empty()\n+    })\n+}\n+\n+fn region_known_to_outlive<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    region_a: ty::Region<'tcx>,\n+    region_b: ty::Region<'tcx>,\n+) -> bool {\n+    // Unfortunately, we have to use a new `InferCtxt` each call, because\n+    // region constraints get added and solved there and we need to test each\n+    // call individually.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n+        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n+        outlives_environment.save_implied_bounds(id);\n+\n+        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n+\n+        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n+            infer::RelateRegionParamBound(cause.span)\n+        });\n+\n+        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n+        (&infcx).push_sub_region_constraint(origin, region_a, region_b);\n+\n+        let errors = infcx.resolve_regions(\n+            id.expect_owner().to_def_id(),\n+            &outlives_environment,\n+            RegionckMode::default(),\n+        );\n+\n+        debug!(?errors, \"errors\");\n+\n+        // If we were able to prove that the type outlives the region without\n+        // an error, it must be because of the implied or explicit bounds...\n+        errors.is_empty()\n+    })\n+}\n+\n /// TypeVisitor that looks for uses of GATs like\n /// `<P0 as Trait<P1..Pn>>::GAT<Pn..Pm>` and adds the arguments `P0..Pm` into\n /// the two vectors, `regions` and `types` (depending on their kind). For each"}]}