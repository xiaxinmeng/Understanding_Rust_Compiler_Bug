{"sha": "994cdd918589535d705177545bf503cd0c3c5148", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NGNkZDkxODU4OTUzNWQ3MDUxNzc1NDViZjUwM2NkMGMzYzUxNDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-13T03:36:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-13T03:36:15Z"}, "message": "Auto merge of #54086 - petrochenkov:derhelp, r=alexcrichton\n\nresolve: Future proof derive helper attributes\n\nDerive helpers no longer require going through recovery mode (fixes https://github.com/rust-lang/rust/issues/53481).\nThey also report an error if they are ambiguous with any other macro in scope, so we can resolve the question about their exact priority sometime later (cc https://github.com/rust-lang/rust/issues/52226).", "tree": {"sha": "a8421aa3c41628ddb964d1ff2785241d7f64c4cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8421aa3c41628ddb964d1ff2785241d7f64c4cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/994cdd918589535d705177545bf503cd0c3c5148", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/994cdd918589535d705177545bf503cd0c3c5148", "html_url": "https://github.com/rust-lang/rust/commit/994cdd918589535d705177545bf503cd0c3c5148", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/994cdd918589535d705177545bf503cd0c3c5148/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2302daef3608c09e2b50193a64611b18ced86f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2302daef3608c09e2b50193a64611b18ced86f3", "html_url": "https://github.com/rust-lang/rust/commit/f2302daef3608c09e2b50193a64611b18ced86f3"}, {"sha": "2b3e98f4e389ddec4f4ebea4b500cffd73f4928a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b3e98f4e389ddec4f4ebea4b500cffd73f4928a", "html_url": "https://github.com/rust-lang/rust/commit/2b3e98f4e389ddec4f4ebea4b500cffd73f4928a"}], "stats": {"total": 327, "additions": 221, "deletions": 106}, "files": [{"sha": "7d9139df415013434d21d331213d450dde6ae096", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -13,7 +13,7 @@\n //! Here we build the \"reduced graph\": the graph of the module tree without\n //! any imports resolved.\n \n-use macros::{InvocationData, LegacyScope};\n+use macros::{InvocationData, ParentScope, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n@@ -1061,8 +1061,15 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n     fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         if !attr.is_sugared_doc && is_builtin_attr(attr) {\n-            self.resolver.current_module.builtin_attrs.borrow_mut().push((\n-                attr.path.segments[0].ident, self.expansion, self.current_legacy_scope\n+            let parent_scope = ParentScope {\n+                module: self.resolver.current_module.nearest_item_scope(),\n+                expansion: self.expansion,\n+                legacy: self.current_legacy_scope,\n+                // Let's hope discerning built-in attributes from derive helpers is not necessary\n+                derives: Vec::new(),\n+            };\n+            parent_scope.module.builtin_attrs.borrow_mut().push((\n+                attr.path.segments[0].ident, parent_scope\n             ));\n         }\n         visit::walk_attribute(self, attr);"}, {"sha": "93f1c20661ba620170b69d1025e05be7fd62014f", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -80,7 +80,7 @@ use std::mem::replace;\n use rustc_data_structures::sync::Lrc;\n \n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n-use macros::{InvocationData, LegacyBinding, LegacyScope};\n+use macros::{InvocationData, LegacyBinding, ParentScope};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n@@ -1009,9 +1009,9 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, Mark, LegacyScope<'a>, Option<Def>)>>,\n+    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>, Option<Def>)>>,\n     macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n-    builtin_attrs: RefCell<Vec<(Ident, Mark, LegacyScope<'a>)>>,\n+    builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n     unresolved_invocations: RefCell<FxHashSet<Mark>>,\n@@ -3494,23 +3494,25 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_parent_expansion(base_module, path, opt_ns, Mark::root(),\n-                                                record_used, path_span, crate_lint)\n+        let parent_scope = ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n+        self.resolve_path_with_parent_scope(base_module, path, opt_ns, &parent_scope,\n+                                            record_used, path_span, crate_lint)\n     }\n \n-    fn resolve_path_with_parent_expansion(\n+    fn resolve_path_with_parent_scope(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Ident],\n         opt_ns: Option<Namespace>, // `None` indicates a module path\n-        parent_expansion: Mark,\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         let mut module = base_module;\n         let mut allow_super = true;\n         let mut second_binding = None;\n+        self.current_module = parent_scope.module;\n \n         debug!(\n             \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, \\\n@@ -3596,9 +3598,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 self.resolve_ident_in_module(module, ident, ns, record_used, path_span)\n             } else if opt_ns == Some(MacroNS) {\n                 assert!(ns == TypeNS);\n-                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_expansion,\n-                                                        record_used, record_used, path_span)\n-                                                        .map(|(binding, _)| binding)\n+                self.resolve_lexical_macro_path_segment(ident, ns, None, parent_scope, record_used,\n+                                                        record_used, path_span).map(|(b, _)| b)\n             } else {\n                 let record_used_id =\n                     if record_used { crate_lint.node_id().or(Some(CRATE_NODE_ID)) } else { None };"}, {"sha": "f687e022a412cf646215307bf1c0dda60705c971", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 113, "deletions": 87, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -101,6 +101,15 @@ pub enum LegacyScope<'a> {\n     Invocation(&'a InvocationData<'a>),\n }\n \n+/// Everything you need to resolve a macro path.\n+#[derive(Clone)]\n+pub struct ParentScope<'a> {\n+    crate module: Module<'a>,\n+    crate expansion: Mark,\n+    crate legacy: LegacyScope<'a>,\n+    crate derives: Vec<ast::Path>,\n+}\n+\n pub struct ProcMacError {\n     crate_name: Symbol,\n     name: Symbol,\n@@ -326,14 +335,15 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             InvocationKind::Attr { attr: None, .. } =>\n                 return Ok(None),\n             InvocationKind::Attr { attr: Some(ref attr), ref traits, .. } =>\n-                (&attr.path, MacroKind::Attr, &traits[..]),\n+                (&attr.path, MacroKind::Attr, traits.clone()),\n             InvocationKind::Bang { ref mac, .. } =>\n-                (&mac.node.path, MacroKind::Bang, &[][..]),\n+                (&mac.node.path, MacroKind::Bang, Vec::new()),\n             InvocationKind::Derive { ref path, .. } =>\n-                (path, MacroKind::Derive, &[][..]),\n+                (path, MacroKind::Derive, Vec::new()),\n         };\n \n-        let (def, ext) = self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?;\n+        let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        let (def, ext) = self.resolve_macro_to_def(path, kind, &parent_scope, force)?;\n \n         if let Def::Macro(def_id, _) = def {\n             self.macro_defs.insert(invoc.expansion_data.mark, def_id);\n@@ -349,9 +359,10 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n     }\n \n     fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n-                          derives_in_scope: &[ast::Path], force: bool)\n+                          derives_in_scope: Vec<ast::Path>, force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Ok(self.resolve_macro_to_def(path, kind, invoc_id, derives_in_scope, force)?.1)\n+        let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n+        Ok(self.resolve_macro_to_def(path, kind, &parent_scope, force)?.1)\n     }\n \n     fn check_unused_macros(&self) {\n@@ -373,10 +384,28 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n }\n \n impl<'a, 'cl> Resolver<'a, 'cl> {\n-    fn resolve_macro_to_def(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n-                            derives_in_scope: &[ast::Path], force: bool)\n-                            -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n-        let def = self.resolve_macro_to_def_inner(path, kind, invoc_id, derives_in_scope, force);\n+    pub fn dummy_parent_scope(&mut self) -> ParentScope<'a> {\n+        self.invoc_parent_scope(Mark::root(), Vec::new())\n+    }\n+\n+    fn invoc_parent_scope(&mut self, invoc_id: Mark, derives: Vec<ast::Path>) -> ParentScope<'a> {\n+        let invoc = self.invocations[&invoc_id];\n+        ParentScope {\n+            module: invoc.module.get().nearest_item_scope(),\n+            expansion: invoc_id.parent(),\n+            legacy: invoc.parent_legacy_scope.get(),\n+            derives,\n+        }\n+    }\n+\n+    fn resolve_macro_to_def(\n+        &mut self,\n+        path: &ast::Path,\n+        kind: MacroKind,\n+        parent_scope: &ParentScope<'a>,\n+        force: bool,\n+    ) -> Result<(Def, Lrc<SyntaxExtension>), Determinacy> {\n+        let def = self.resolve_macro_to_def_inner(path, kind, parent_scope, force);\n \n         // Report errors and enforce feature gates for the resolved macro.\n         if def != Err(Determinacy::Undetermined) {\n@@ -440,15 +469,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         Ok((def, self.get_macro(def)))\n     }\n \n-    pub fn resolve_macro_to_def_inner(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n-                                      derives_in_scope: &[ast::Path], force: bool)\n-                                      -> Result<Def, Determinacy> {\n+    pub fn resolve_macro_to_def_inner(\n+        &mut self,\n+        path: &ast::Path,\n+        kind: MacroKind,\n+        parent_scope: &ParentScope<'a>,\n+        force: bool,\n+    ) -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         let mut path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n-        let invocation = self.invocations[&invoc_id];\n-        let parent_expansion = invoc_id.parent();\n-        let parent_legacy_scope = invocation.parent_legacy_scope.get();\n-        self.current_module = invocation.module.get().nearest_item_scope();\n \n         // Possibly apply the macro helper hack\n         if kind == MacroKind::Bang && path.len() == 1 &&\n@@ -458,9 +487,9 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path_with_parent_expansion(None, &path, Some(MacroNS),\n-                                                                    parent_expansion, false, span,\n-                                                                    CrateLint::No) {\n+            let def = match self.resolve_path_with_parent_scope(None, &path, Some(MacroNS),\n+                                                                parent_scope, false, span,\n+                                                                CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n@@ -480,19 +509,17 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     Err(Determinacy::Determined)\n                 },\n             };\n-            self.current_module.macro_resolutions.borrow_mut()\n+            parent_scope.module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n             return def;\n         }\n \n-        let legacy_resolution = self.resolve_legacy_scope(\n-            path[0], Some(kind), parent_expansion, parent_legacy_scope, false\n-        );\n-        let result = if let Some(legacy_binding) = legacy_resolution {\n+        let result = if let Some(legacy_binding) = self.resolve_legacy_scope(path[0], Some(kind),\n+                                                                             parent_scope, false) {\n             Ok(legacy_binding.def())\n         } else {\n             match self.resolve_lexical_macro_path_segment(path[0], MacroNS, Some(kind),\n-                                                          parent_expansion, false, force, span) {\n+                                                          parent_scope, false, force, span) {\n                 Ok((binding, _)) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n                 Err(Determinacy::Determined) => {\n@@ -502,44 +529,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         };\n \n-        self.current_module.legacy_macro_resolutions.borrow_mut()\n-            .push((path[0], kind, parent_expansion, parent_legacy_scope, result.ok()));\n-\n-        if let Ok(Def::NonMacroAttr(NonMacroAttrKind::Custom)) = result {} else {\n-            return result;\n-        }\n+        parent_scope.module.legacy_macro_resolutions.borrow_mut()\n+            .push((path[0], kind, parent_scope.clone(), result.ok()));\n \n-        // At this point we've found that the `attr` is determinately unresolved and thus can be\n-        // interpreted as a custom attribute. Normally custom attributes are feature gated, but\n-        // it may be a custom attribute whitelisted by a derive macro and they do not require\n-        // a feature gate.\n-        //\n-        // So here we look through all of the derive annotations in scope and try to resolve them.\n-        // If they themselves successfully resolve *and* one of the resolved derive macros\n-        // whitelists this attribute's name, then this is a registered attribute and we can convert\n-        // it from a \"generic custom attrite\" into a \"known derive helper attribute\".\n-        assert!(kind == MacroKind::Attr);\n-        enum ConvertToDeriveHelper { Yes, No, DontKnow }\n-        let mut convert_to_derive_helper = ConvertToDeriveHelper::No;\n-        for derive in derives_in_scope {\n-            match self.resolve_macro_path(derive, MacroKind::Derive, invoc_id, &[], force) {\n-                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs, _) = *ext {\n-                    if inert_attrs.contains(&path[0].name) {\n-                        convert_to_derive_helper = ConvertToDeriveHelper::Yes;\n-                        break\n-                    }\n-                },\n-                Err(Determinacy::Undetermined) =>\n-                    convert_to_derive_helper = ConvertToDeriveHelper::DontKnow,\n-                Err(Determinacy::Determined) => {}\n-            }\n-        }\n-\n-        match convert_to_derive_helper {\n-            ConvertToDeriveHelper::Yes => Ok(Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)),\n-            ConvertToDeriveHelper::No => result,\n-            ConvertToDeriveHelper::DontKnow => Err(Determinacy::determined(force)),\n-        }\n+        result\n     }\n \n     // Resolve the initial segment of a non-global macro path\n@@ -551,7 +544,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         mut ident: Ident,\n         ns: Namespace,\n         kind: Option<MacroKind>,\n-        parent_expansion: Mark,\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         force: bool,\n         path_span: Span,\n@@ -580,6 +573,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n         // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n         // 4. Language prelude: builtin attributes (closed, controlled).\n+        // N (unordered). Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and maybe even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n \n         assert!(ns == TypeNS  || ns == MacroNS);\n         assert!(force || !record_used); // `record_used` implies `force`\n@@ -603,15 +603,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             MacroUsePrelude,\n             BuiltinMacros,\n             BuiltinAttrs,\n+            DeriveHelpers,\n             ExternPrelude,\n             ToolPrelude,\n             StdLibPrelude,\n             BuiltinTypes,\n         }\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = WhereToResolve::Module(self.current_module);\n-        let mut use_prelude = !self.current_module.no_implicit_prelude;\n+        let mut where_to_resolve = WhereToResolve::Module(parent_scope.module);\n+        let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         loop {\n             let result = match where_to_resolve {\n                 WhereToResolve::Module(module) => {\n@@ -652,6 +653,26 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         Err(Determinacy::Determined)\n                     }\n                 }\n+                WhereToResolve::DeriveHelpers => {\n+                    let mut result = Err(Determinacy::Determined);\n+                    for derive in &parent_scope.derives {\n+                        let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n+                        if let Ok((_, ext)) = self.resolve_macro_to_def(derive, MacroKind::Derive,\n+                                                                        &parent_scope, force) {\n+                            if let SyntaxExtension::ProcMacroDerive(_, helper_attrs, _) = &*ext {\n+                                if helper_attrs.contains(&ident.name) {\n+                                    let binding =\n+                                        (Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                        ty::Visibility::Public, derive.span, Mark::root())\n+                                        .to_name_binding(self.arenas);\n+                                    result = Ok((binding, FromPrelude(false)));\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    result\n+                }\n                 WhereToResolve::ExternPrelude => {\n                     if use_prelude && self.extern_prelude.contains(&ident.name) {\n                         if !self.session.features_untracked().extern_prelude &&\n@@ -731,7 +752,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                     WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n                     WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                    WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n+                    WhereToResolve::BuiltinAttrs => WhereToResolve::DeriveHelpers,\n+                    WhereToResolve::DeriveHelpers => break, // nowhere else to search\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n                     WhereToResolve::StdLibPrelude => WhereToResolve::BuiltinTypes,\n@@ -753,9 +775,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                     if let Some(innermost_result) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n-                        if result.0.def() != innermost_result.0.def() &&\n+                        let (def, innermost_def) = (result.0.def(), innermost_result.0.def());\n+                        if def != innermost_def &&\n                            (innermost_result.0.is_glob_import() ||\n-                            innermost_result.0.may_appear_after(parent_expansion, result.0)) {\n+                            innermost_result.0.may_appear_after(parent_scope.expansion, result.0) ||\n+                            innermost_def == Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper) ||\n+                            def == Def::NonMacroAttr(NonMacroAttrKind::DeriveHelper)) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result.0,\n@@ -797,13 +822,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n     }\n \n-    fn resolve_legacy_scope(&mut self,\n-                            ident: Ident,\n-                            kind: Option<MacroKind>,\n-                            parent_expansion: Mark,\n-                            parent_legacy_scope: LegacyScope<'a>,\n-                            record_used: bool)\n-                            -> Option<&'a NameBinding<'a>> {\n+    fn resolve_legacy_scope(\n+        &mut self,\n+        ident: Ident,\n+        kind: Option<MacroKind>,\n+        parent_scope: &ParentScope<'a>,\n+        record_used: bool,\n+    ) -> Option<&'a NameBinding<'a>> {\n         if macro_kind_mismatch(ident.name, kind, Some(MacroKind::Bang)) {\n             return None;\n         }\n@@ -824,7 +849,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let mut innermost_result: Option<&NameBinding> = None;\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = parent_legacy_scope;\n+        let mut where_to_resolve = parent_scope.legacy;\n         loop {\n             let result = match where_to_resolve {\n                 LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident =>\n@@ -852,7 +877,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if let Some(innermost_result) = innermost_result {\n                         // Found another solution, if the first one was \"weak\", report an error.\n                         if result.def() != innermost_result.def() &&\n-                           innermost_result.may_appear_after(parent_expansion, result) {\n+                           innermost_result.may_appear_after(parent_scope.expansion, result) {\n                             self.ambiguity_errors.push(AmbiguityError {\n                                 ident,\n                                 b1: innermost_result,\n@@ -889,14 +914,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             }\n         }\n \n-        for &(ident, kind, parent_expansion, parent_legacy_scope, def)\n-                in module.legacy_macro_resolutions.borrow().iter() {\n+        let legacy_macro_resolutions =\n+            mem::replace(&mut *module.legacy_macro_resolutions.borrow_mut(), Vec::new());\n+        for (ident, kind, parent_scope, def) in legacy_macro_resolutions {\n             let span = ident.span;\n             let legacy_resolution = self.resolve_legacy_scope(\n-                ident, Some(kind), parent_expansion, parent_legacy_scope, true\n+                ident, Some(kind), &parent_scope, true\n             );\n             let resolution = self.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, Some(kind), parent_expansion, true, true, span\n+                ident, MacroNS, Some(kind), &parent_scope, true, true, span\n             );\n \n             let check_consistency = |this: &Self, new_def: Def| {\n@@ -932,7 +958,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 (Some(legacy_binding), Ok((binding, FromPrelude(from_prelude))))\n                         if legacy_binding.def() != binding.def_ignoring_ambiguity() &&\n                            (!from_prelude ||\n-                            legacy_binding.may_appear_after(parent_expansion, binding)) => {\n+                            legacy_binding.may_appear_after(parent_scope.expansion, binding)) => {\n                     self.report_ambiguity_error(ident, legacy_binding, binding);\n                 },\n                 // OK, non-macro-expanded legacy wins over prelude even if defs are different\n@@ -953,13 +979,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n         }\n \n-        for &(ident, parent_expansion, parent_legacy_scope)\n-                in module.builtin_attrs.borrow().iter() {\n+        let builtin_attrs = mem::replace(&mut *module.builtin_attrs.borrow_mut(), Vec::new());\n+        for (ident, parent_scope) in builtin_attrs {\n             let resolve_legacy = |this: &mut Self| this.resolve_legacy_scope(\n-                ident, Some(MacroKind::Attr), parent_expansion, parent_legacy_scope, true\n+                ident, Some(MacroKind::Attr), &parent_scope, true\n             );\n             let resolve_modern = |this: &mut Self| this.resolve_lexical_macro_path_segment(\n-                ident, MacroNS, Some(MacroKind::Attr), parent_expansion, true, true, ident.span\n+                ident, MacroNS, Some(MacroKind::Attr), &parent_scope, true, true, ident.span\n             ).map(|(binding, _)| binding).ok();\n \n             if let Some(binding) = resolve_legacy(self).or_else(|| resolve_modern(self)) {"}, {"sha": "181fe379248ce52422ae06f30639f5c3a01d83fa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -398,12 +398,12 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for LinkCollector<'a, 'tcx, 'rcx, 'cstor\n /// Resolve a string as a macro\n fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n-    use syntax::ext::hygiene::Mark;\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     let mut resolver = cx.resolver.borrow_mut();\n-    let mark = Mark::root();\n-    if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang, mark, &[], false) {\n+    let parent_scope = resolver.dummy_parent_scope();\n+    if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n+                                                         &parent_scope, false) {\n         if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n             return Some(def);\n         }"}, {"sha": "e42624bf41f0ad7ffacfc969d8f40a587254e0a0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -730,7 +730,7 @@ pub trait Resolver {\n     fn resolve_macro_invocation(&mut self, invoc: &Invocation, invoc_id: Mark, force: bool)\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Determinacy>;\n     fn resolve_macro_path(&mut self, path: &ast::Path, kind: MacroKind, invoc_id: Mark,\n-                          derives_in_scope: &[ast::Path], force: bool)\n+                          derives_in_scope: Vec<ast::Path>, force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy>;\n \n     fn check_unused_macros(&self);\n@@ -768,7 +768,7 @@ impl Resolver for DummyResolver {\n         Err(Determinacy::Determined)\n     }\n     fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n-                          _derives_in_scope: &[ast::Path], _force: bool)\n+                          _derives_in_scope: Vec<ast::Path>, _force: bool)\n                           -> Result<Lrc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)\n     }"}, {"sha": "40903e8ad6cb7e06e2c32bba3da006aea4e7b3ac", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -384,7 +384,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         let mark = Mark::fresh(self.cx.current_expansion.mark);\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro_path(\n-                                path, MacroKind::Derive, Mark::root(), &[], false) {\n+                                path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n                             Ok(ext) => match *ext {\n                                 BuiltinDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),"}, {"sha": "0fd8aa5638a50c76cde1ded5fc51c49f9039df9a", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/derive-helper-shadowing.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-helper-shadowing.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -0,0 +1,16 @@\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro_attribute]\n+pub fn my_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}\n+\n+#[proc_macro_derive(MyTrait, attributes(my_attr))]\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "9554cdde4907eb7fcd932347a5790e7d80f03caf", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/issue-53481.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-53481.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-53481.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-53481.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -0,0 +1,12 @@\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::*;\n+\n+#[proc_macro_derive(MyTrait, attributes(my_attr))]\n+pub fn foo(_: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}"}, {"sha": "c2357d501ee447045c53b84776518f67419c6204", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:derive-helper-shadowing.rs\n+\n+extern crate derive_helper_shadowing;\n+use derive_helper_shadowing::*;\n+\n+#[derive(MyTrait)]\n+#[my_attr] //~ ERROR `my_attr` is ambiguous\n+struct S;\n+\n+fn main() {}"}, {"sha": "d597b577bb790b82b2af5fff0c365cd31608b15e", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -0,0 +1,21 @@\n+error[E0659]: `my_attr` is ambiguous\n+  --> $DIR/derive-helper-shadowing.rs:7:3\n+   |\n+LL | #[my_attr] //~ ERROR `my_attr` is ambiguous\n+   |   ^^^^^^^ ambiguous name\n+   |\n+note: `my_attr` could refer to the name imported here\n+  --> $DIR/derive-helper-shadowing.rs:4:5\n+   |\n+LL | use derive_helper_shadowing::*;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: `my_attr` could also refer to the name defined here\n+  --> $DIR/derive-helper-shadowing.rs:6:10\n+   |\n+LL | #[derive(MyTrait)]\n+   |          ^^^^^^^\n+   = note: consider adding an explicit import of `my_attr` to disambiguate\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "479fd1db630a392b2350f637279650e954e43573", "filename": "src/test/ui-fulldeps/proc-macro/issue-53481.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fissue-53481.rs", "raw_url": "https://github.com/rust-lang/rust/raw/994cdd918589535d705177545bf503cd0c3c5148/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fissue-53481.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fissue-53481.rs?ref=994cdd918589535d705177545bf503cd0c3c5148", "patch": "@@ -0,0 +1,22 @@\n+// compile-pass\n+// aux-build:issue-53481.rs\n+\n+#[macro_use]\n+extern crate issue_53481;\n+\n+mod m1 {\n+    use m2::MyTrait;\n+\n+    #[derive(MyTrait)]\n+    struct A {}\n+}\n+\n+mod m2 {\n+    pub type MyTrait = u8;\n+\n+    #[derive(MyTrait)]\n+    #[my_attr]\n+    struct B {}\n+}\n+\n+fn main() {}"}]}