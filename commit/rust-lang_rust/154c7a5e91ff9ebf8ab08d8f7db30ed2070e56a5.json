{"sha": "154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "node_id": "C_kwDOAAsO6NoAKDE1NGM3YTVlOTFmZjllYmY4YWIwOGQ4ZjdkYjMwZWQyMDcwZTU2YTU", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-05-12T08:02:12Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2023-05-12T08:02:12Z"}, "message": "Merge from rustc", "tree": {"sha": "d3d8993e7fca57a6930649c863d6f6b37c86a3bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3d8993e7fca57a6930649c863d6f6b37c86a3bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "html_url": "https://github.com/rust-lang/rust/commit/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01937562505363962cf7a5c45a81d82cfe79dd4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/01937562505363962cf7a5c45a81d82cfe79dd4f", "html_url": "https://github.com/rust-lang/rust/commit/01937562505363962cf7a5c45a81d82cfe79dd4f"}, {"sha": "0b795044c6f0854445f1f2bb6443e87848e150d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b795044c6f0854445f1f2bb6443e87848e150d1", "html_url": "https://github.com/rust-lang/rust/commit/0b795044c6f0854445f1f2bb6443e87848e150d1"}], "stats": {"total": 6369, "additions": 4781, "deletions": 1588}, "files": [{"sha": "bb37fee98e4f8222d979294ef67fe94c8f7dfb90", "filename": "Cargo.lock", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -741,7 +741,7 @@ dependencies = [\n  \"tracing-subscriber\",\n  \"unified-diff\",\n  \"walkdir\",\n- \"windows 0.46.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -1647,7 +1647,7 @@ dependencies = [\n  \"iana-time-zone-haiku\",\n  \"js-sys\",\n  \"wasm-bindgen\",\n- \"windows 0.48.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -3259,7 +3259,7 @@ dependencies = [\n  \"tempfile\",\n  \"thorin-dwp\",\n  \"tracing\",\n- \"windows 0.46.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -3315,7 +3315,7 @@ dependencies = [\n  \"tempfile\",\n  \"thin-vec\",\n  \"tracing\",\n- \"windows 0.46.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -3376,7 +3376,7 @@ dependencies = [\n  \"rustc_ty_utils\",\n  \"serde_json\",\n  \"tracing\",\n- \"windows 0.46.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -3426,7 +3426,7 @@ dependencies = [\n  \"termize\",\n  \"tracing\",\n  \"unicode-width\",\n- \"windows 0.46.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -4096,7 +4096,7 @@ dependencies = [\n  \"smallvec\",\n  \"termize\",\n  \"tracing\",\n- \"windows 0.46.0\",\n+ \"windows\",\n ]\n \n [[package]]\n@@ -5498,15 +5498,6 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"windows\"\n-version = \"0.46.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cdacb41e6a96a052c6cb63a144f24900236121c6f63f4f8219fef5977ecb0c25\"\n-dependencies = [\n- \"windows-targets 0.42.2\",\n-]\n-\n [[package]]\n name = \"windows\"\n version = \"0.48.0\""}, {"sha": "b775739fed2ae689a8027ddf02581d294fd9cf0a", "filename": "compiler/rustc_borrowck/src/def_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdef_use.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -55,7 +55,7 @@ pub fn categorize(context: PlaceContext) -> Option<DefUse> {\n         // `PlaceMention` and `AscribeUserType` both evaluate the place, which must not\n         // contain dangling references.\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::PlaceMention) |\n-        PlaceContext::NonUse(NonUseContext::AscribeUserTy) |\n+        PlaceContext::NonUse(NonUseContext::AscribeUserTy(_)) |\n \n         PlaceContext::MutatingUse(MutatingUseContext::AddressOf) |\n         PlaceContext::NonMutatingUse(NonMutatingUseContext::AddressOf) |"}, {"sha": "33b24b68f7cfc5d59bed289afaf8cac199277ac6", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -777,7 +777,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 Inspect | Copy | Move | PlaceMention | SharedBorrow | ShallowBorrow | UniqueBorrow\n                 | AddressOf | Projection,\n             ) => ty::Covariant,\n-            PlaceContext::NonUse(AscribeUserTy) => ty::Covariant,\n+            PlaceContext::NonUse(AscribeUserTy(variance)) => variance,\n         }\n     }\n "}, {"sha": "ee56d45c9c826eb85c79865d34ba3710ece3685f", "filename": "compiler/rustc_builtin_macros/src/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_idents.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -19,7 +19,7 @@ pub fn expand_concat_idents<'cx>(\n     }\n \n     let mut res_str = String::new();\n-    for (i, e) in tts.into_trees().enumerate() {\n+    for (i, e) in tts.trees().enumerate() {\n         if i & 1 == 1 {\n             match e {\n                 TokenTree::Token(Token { kind: token::Comma, .. }, _) => {}"}, {"sha": "9c98723e1f43f96ccedc581d6603987c760cc938", "filename": "compiler/rustc_builtin_macros/src/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftrace_macros.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -8,7 +8,7 @@ pub fn expand_trace_macros(\n     sp: Span,\n     tt: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let mut cursor = tt.into_trees();\n+    let mut cursor = tt.trees();\n     let mut err = false;\n     let value = match &cursor.next() {\n         Some(TokenTree::Token(token, _)) if token.is_keyword(kw::True) => true,"}, {"sha": "4b9ca2e7d19c3f9fb2cc9cbd3f040ddd31944bfc", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -94,11 +94,11 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n             // LLVM will prefix the name with `__imp_`. Ideally, we'd like the\n             // existing logic below to set the Storage Class, but it has an\n             // exemption for MinGW for backwards compatability.\n-            let llfn = cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi);\n+            let llfn = cx.declare_fn(&common::i686_decorated_name(&dllimport, common::is_mingw_gnu_toolchain(&tcx.sess.target), true), fn_abi, Some(instance));\n             unsafe { llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport); }\n             llfn\n         } else {\n-            cx.declare_fn(sym, fn_abi)\n+            cx.declare_fn(sym, fn_abi, Some(instance))\n         };\n         debug!(\"get_fn: not casting pointer!\");\n "}, {"sha": "cd261293e9b2dd2262a19056fd75cc1635347e8b", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -207,6 +207,7 @@ fn declare_unused_fn<'tcx>(cx: &CodegenCx<'_, 'tcx>, def_id: DefId) -> Instance<\n             )),\n             ty::List::empty(),\n         ),\n+        None,\n     );\n \n     llvm::set_linkage(llfn, llvm::Linkage::PrivateLinkage);"}, {"sha": "164b12cf8d4118686fed81eeef0a50bc35d41664", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -19,8 +19,11 @@ use crate::llvm::AttributePlace::Function;\n use crate::type_::Type;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::TypeMembershipMethods;\n-use rustc_middle::ty::Ty;\n-use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi, TypeIdOptions};\n+use rustc_middle::ty::{Instance, Ty};\n+use rustc_symbol_mangling::typeid::{\n+    kcfi_typeid_for_fnabi, kcfi_typeid_for_instance, typeid_for_fnabi, typeid_for_instance,\n+    TypeIdOptions,\n+};\n use smallvec::SmallVec;\n \n /// Declare a function.\n@@ -116,7 +119,12 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n+    pub fn declare_fn(\n+        &self,\n+        name: &str,\n+        fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+        instance: Option<Instance<'tcx>>,\n+    ) -> &'ll Value {\n         debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n         // Function addresses in Rust are never significant, allowing functions to\n@@ -132,18 +140,35 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         fn_abi.apply_attrs_llfn(self, llfn);\n \n         if self.tcx.sess.is_sanitizer_cfi_enabled() {\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::empty());\n-            self.set_type_metadata(llfn, typeid);\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::GENERALIZE_POINTERS);\n-            self.add_type_metadata(llfn, typeid);\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::NORMALIZE_INTEGERS);\n-            self.add_type_metadata(llfn, typeid);\n-            let typeid = typeid_for_fnabi(\n-                self.tcx,\n-                fn_abi,\n-                TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n-            );\n-            self.add_type_metadata(llfn, typeid);\n+            if let Some(instance) = instance {\n+                let typeid = typeid_for_instance(self.tcx, &instance, TypeIdOptions::empty());\n+                self.set_type_metadata(llfn, typeid);\n+                let typeid =\n+                    typeid_for_instance(self.tcx, &instance, TypeIdOptions::GENERALIZE_POINTERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid =\n+                    typeid_for_instance(self.tcx, &instance, TypeIdOptions::NORMALIZE_INTEGERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_instance(\n+                    self.tcx,\n+                    &instance,\n+                    TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n+                );\n+                self.add_type_metadata(llfn, typeid);\n+            } else {\n+                let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::empty());\n+                self.set_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::GENERALIZE_POINTERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::NORMALIZE_INTEGERS);\n+                self.add_type_metadata(llfn, typeid);\n+                let typeid = typeid_for_fnabi(\n+                    self.tcx,\n+                    fn_abi,\n+                    TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n+                );\n+                self.add_type_metadata(llfn, typeid);\n+            }\n         }\n \n         if self.tcx.sess.is_sanitizer_kcfi_enabled() {\n@@ -156,8 +181,13 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n                 options.insert(TypeIdOptions::NORMALIZE_INTEGERS);\n             }\n \n-            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi, options);\n-            self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+            if let Some(instance) = instance {\n+                let kcfi_typeid = kcfi_typeid_for_instance(self.tcx, &instance, options);\n+                self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+            } else {\n+                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi, options);\n+                self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n+            }\n         }\n \n         llfn"}, {"sha": "4e28034a8507b1df9ab5525c1949cf777821019b", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -772,7 +772,7 @@ fn gen_fn<'ll, 'tcx>(\n ) -> (&'ll Type, &'ll Value) {\n     let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n     let llty = fn_abi.llvm_type(cx);\n-    let llfn = cx.declare_fn(name, fn_abi);\n+    let llfn = cx.declare_fn(name, fn_abi, None);\n     cx.set_frame_pointer_type(llfn);\n     cx.apply_target_cpu_attr(llfn);\n     // FIXME(eddyb) find a nicer way to do this."}, {"sha": "aefd5b2a13c92ad1cfe5034d1c7b7e6ff2d10ada", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -680,7 +680,9 @@ pub type InlineAsmDiagHandlerTy = unsafe extern \"C\" fn(&SMDiagnostic, *const c_v\n pub mod coverageinfo {\n     use super::coverage_map;\n \n-    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L209-L230)\n+    /// Corresponds to enum `llvm::coverage::CounterMappingRegion::RegionKind`.\n+    ///\n+    /// Must match the layout of `LLVMRustCounterMappingRegionKind`.\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub enum RegionKind {\n@@ -714,7 +716,9 @@ pub mod coverageinfo {\n     /// array\", encoded separately), and source location (start and end positions of the represented\n     /// code region).\n     ///\n-    /// Matches LLVMRustCounterMappingRegion.\n+    /// Corresponds to struct `llvm::coverage::CounterMappingRegion`.\n+    ///\n+    /// Must match the layout of `LLVMRustCounterMappingRegion`.\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub struct CounterMappingRegion {"}, {"sha": "e8f8c321510a269d98f227bc2d208c8385b5d112", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> PreDefineMethods<'tcx> for CodegenCx<'_, 'tcx> {\n         assert!(!instance.substs.has_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n-        let lldecl = self.declare_fn(symbol_name, fn_abi);\n+        let lldecl = self.declare_fn(symbol_name, fn_abi, Some(instance));\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n         let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n         base::set_link_section(lldecl, attrs);"}, {"sha": "02be88df103a52405369c32f515dc0c6f9caf7de", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -51,5 +51,5 @@ default-features = false\n features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]\n \n [target.'cfg(windows)'.dependencies.windows]\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n features = [\"Win32_Globalization\"]"}, {"sha": "ea06cb02d8bafd42353e398a281e00028e67cc39", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -546,12 +546,38 @@ fn link_staticlib<'a>(\n \n     ab.build(out_filename);\n \n-    if !all_native_libs.is_empty() {\n-        if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n-            print_native_static_libs(sess, &all_native_libs);\n+    let crates = codegen_results.crate_info.used_crates.iter();\n+\n+    let fmts = codegen_results\n+        .crate_info\n+        .dependency_formats\n+        .iter()\n+        .find_map(|&(ty, ref list)| if ty == CrateType::Staticlib { Some(list) } else { None })\n+        .expect(\"no dependency formats for staticlib\");\n+\n+    let mut all_rust_dylibs = vec![];\n+    for &cnum in crates {\n+        match fmts.get(cnum.as_usize() - 1) {\n+            Some(&Linkage::Dynamic) => {}\n+            _ => continue,\n+        }\n+        let crate_name = codegen_results.crate_info.crate_name[&cnum];\n+        let used_crate_source = &codegen_results.crate_info.used_crate_source[&cnum];\n+        if let Some((path, _)) = &used_crate_source.dylib {\n+            all_rust_dylibs.push(&**path);\n+        } else {\n+            if used_crate_source.rmeta.is_some() {\n+                sess.emit_fatal(errors::LinkRlibError::OnlyRmetaFound { crate_name });\n+            } else {\n+                sess.emit_fatal(errors::LinkRlibError::NotFound { crate_name });\n+            }\n         }\n     }\n \n+    if sess.opts.prints.contains(&PrintRequest::NativeStaticLibs) {\n+        print_native_static_libs(sess, &all_native_libs, &all_rust_dylibs);\n+    }\n+\n     Ok(())\n }\n \n@@ -1370,8 +1396,12 @@ enum RlibFlavor {\n     StaticlibBase,\n }\n \n-fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n-    let lib_args: Vec<_> = all_native_libs\n+fn print_native_static_libs(\n+    sess: &Session,\n+    all_native_libs: &[NativeLib],\n+    all_rust_dylibs: &[&Path],\n+) {\n+    let mut lib_args: Vec<_> = all_native_libs\n         .iter()\n         .filter(|l| relevant_lib(sess, l))\n         .filter_map(|lib| {\n@@ -1401,6 +1431,41 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n             }\n         })\n         .collect();\n+    for path in all_rust_dylibs {\n+        // FIXME deduplicate with add_dynamic_crate\n+\n+        // Just need to tell the linker about where the library lives and\n+        // what its name is\n+        let parent = path.parent();\n+        if let Some(dir) = parent {\n+            let dir = fix_windows_verbatim_for_gcc(dir);\n+            if sess.target.is_like_msvc {\n+                let mut arg = String::from(\"/LIBPATH:\");\n+                arg.push_str(&dir.display().to_string());\n+                lib_args.push(arg);\n+            } else {\n+                lib_args.push(\"-L\".to_owned());\n+                lib_args.push(dir.display().to_string());\n+            }\n+        }\n+        let stem = path.file_stem().unwrap().to_str().unwrap();\n+        // Convert library file-stem into a cc -l argument.\n+        let prefix = if stem.starts_with(\"lib\") && !sess.target.is_like_windows { 3 } else { 0 };\n+        let lib = &stem[prefix..];\n+        let path = parent.unwrap_or_else(|| Path::new(\"\"));\n+        if sess.target.is_like_msvc {\n+            // When producing a dll, the MSVC linker may not actually emit a\n+            // `foo.lib` file if the dll doesn't actually export any symbols, so we\n+            // check to see if the file is there and just omit linking to it if it's\n+            // not present.\n+            let name = format!(\"{}.dll.lib\", lib);\n+            if path.join(&name).exists() {\n+                lib_args.push(name);\n+            }\n+        } else {\n+            lib_args.push(format!(\"-l{}\", lib));\n+        }\n+    }\n     if !lib_args.is_empty() {\n         sess.emit_note(errors::StaticLibraryNativeArtifacts);\n         // Prefix for greppability"}, {"sha": "1791ce4b31559bcba88bba2c4cae5fa8c3f290f1", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L95)\n+/// Must match the layout of `LLVMRustCounterKind`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum CounterKind {\n@@ -17,8 +17,10 @@ pub enum CounterKind {\n ///     `instrprof.increment()`)\n ///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n ///     counter expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L102-L103)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n+///\n+/// Corresponds to struct `llvm::coverage::Counter`.\n+///\n+/// Must match the layout of `LLVMRustCounter`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct Counter {\n@@ -59,17 +61,19 @@ impl Counter {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L150)\n+/// Corresponds to enum `llvm::coverage::CounterExpression::ExprKind`.\n+///\n+/// Must match the layout of `LLVMRustCounterExprKind`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n     Subtract = 0,\n     Add = 1,\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L151-L152)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++\n-/// counterpart.\n+/// Corresponds to struct `llvm::coverage::CounterExpression`.\n+///\n+/// Must match the layout of `LLVMRustCounterExpression`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct CounterExpression {"}, {"sha": "c815bb2d1974920dcb4c124c087f57405da07254", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -37,7 +37,7 @@ itertools = \"0.10.1\"\n version = \"0.11\"\n \n [target.'cfg(windows)'.dependencies.windows]\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n features = [\n     \"Win32_Foundation\",\n     \"Win32_Storage_FileSystem\","}, {"sha": "3c76c2b79911a05dc209a4564179eff0bb4454b4", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -865,14 +865,16 @@ cfg_if! {\n             use std::mem;\n \n             use windows::{\n-                Win32::System::ProcessStatus::{K32GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS},\n+                // FIXME: change back to K32GetProcessMemoryInfo when windows crate\n+                // updated to 0.49.0+ to drop dependency on psapi.dll\n+                Win32::System::ProcessStatus::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS},\n                 Win32::System::Threading::GetCurrentProcess,\n             };\n \n             let mut pmc = PROCESS_MEMORY_COUNTERS::default();\n             let pmc_size = mem::size_of_val(&pmc);\n             unsafe {\n-                K32GetProcessMemoryInfo(\n+                GetProcessMemoryInfo(\n                     GetCurrentProcess(),\n                     &mut pmc,\n                     pmc_size as u32,"}, {"sha": "67352c55c9019713723d89508145c7ea8b48469c", "filename": "compiler/rustc_driver_impl/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_driver_impl%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_driver_impl%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -57,7 +57,7 @@ rustc_mir_transform = { path = \"../rustc_mir_transform\" }\n libc = \"0.2\"\n \n [target.'cfg(windows)'.dependencies.windows]\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n features = [\n     \"Win32_System_Diagnostics_Debug\",\n ]"}, {"sha": "bd3033fcb3e868412c5016a5eef7ede3d134772d", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -27,12 +27,11 @@ serde = { version = \"1.0.125\", features = [ \"derive\" ] }\n serde_json = \"1.0.59\"\n \n [target.'cfg(windows)'.dependencies.windows]\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n features = [\n     \"Win32_Foundation\",\n     \"Win32_Security\",\n     \"Win32_System_Threading\",\n-    \"Win32_System_WindowsProgramming\",\n ]\n \n [features]"}, {"sha": "bd5cf49b56bd7dc0d9f7dba5bbc3dfd1bad2ab69", "filename": "compiler/rustc_errors/src/lock.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_errors%2Fsrc%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_errors%2Fsrc%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flock.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -19,8 +19,7 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n     use windows::{\n         core::PCSTR,\n         Win32::Foundation::{CloseHandle, HANDLE, WAIT_ABANDONED, WAIT_OBJECT_0},\n-        Win32::System::Threading::{CreateMutexA, ReleaseMutex, WaitForSingleObject},\n-        Win32::System::WindowsProgramming::INFINITE,\n+        Win32::System::Threading::{CreateMutexA, ReleaseMutex, WaitForSingleObject, INFINITE},\n     };\n \n     struct Handle(HANDLE);"}, {"sha": "5187e63f8e3a144f51703be89e22b7f09c56c2d3", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -31,6 +31,7 @@ use rustc_target::abi::FieldIdx;\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n+use rustc_trait_selection::traits::outlives_bounds::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt, TraitEngine, TraitEngineExt as _};\n \n use std::ops::ControlFlow;\n@@ -222,7 +223,7 @@ fn check_opaque(tcx: TyCtxt<'_>, id: hir::ItemId) {\n     if check_opaque_for_cycles(tcx, item.owner_id.def_id, substs, span, &origin).is_err() {\n         return;\n     }\n-    check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n+    check_opaque_meets_bounds(tcx, item.owner_id.def_id, span, &origin);\n }\n \n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n@@ -391,7 +392,6 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n fn check_opaque_meets_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n-    substs: SubstsRef<'tcx>,\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n@@ -406,6 +406,8 @@ fn check_opaque_meets_bounds<'tcx>(\n         .with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor))\n         .build();\n     let ocx = ObligationCtxt::new(&infcx);\n+\n+    let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n     let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n     // `ReErased` regions appear in the \"parent_substs\" of closures/generators.\n@@ -448,9 +450,18 @@ fn check_opaque_meets_bounds<'tcx>(\n     match origin {\n         // Checked when type checking the function containing them.\n         hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+        // Nested opaque types occur only in associated types:\n+        // ` type Opaque<T> = impl Trait<&'static T, AssocTy = impl Nested>; `\n+        // They can only be referenced as `<Opaque<T> as Trait<&'static T>>::AssocTy`.\n+        // We don't have to check them here because their well-formedness follows from the WF of\n+        // the projection input types in the defining- and use-sites.\n+        hir::OpaqueTyOrigin::TyAlias\n+            if tcx.def_kind(tcx.parent(def_id.to_def_id())) == DefKind::OpaqueTy => {}\n         // Can have different predicates to their defining use\n         hir::OpaqueTyOrigin::TyAlias => {\n-            let outlives_env = OutlivesEnvironment::new(param_env);\n+            let wf_tys = ocx.assumed_wf_types(param_env, span, def_id);\n+            let implied_bounds = infcx.implied_bounds_tys(param_env, def_id, wf_tys);\n+            let outlives_env = OutlivesEnvironment::with_bounds(param_env, implied_bounds);\n             let _ = ocx.resolve_regions_and_report_errors(defining_use_anchor, &outlives_env);\n         }\n     }"}, {"sha": "3efdab534384b8065d4b48dfee66526461213817", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -278,9 +278,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) -> bool {\n         if let traits::FulfillmentErrorCode::CodeSelectionError(\n-            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n+            traits::SelectionError::OutputTypeParameterMismatch(box traits::SelectionOutputTypeParameterMismatch{\n+                expected_trait_ref, ..\n+            }),\n         ) = error.code\n-            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n+            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected_trait_ref.skip_binder().self_ty().kind()\n             && span.overlaps(self.tcx.def_span(*def_id))\n         {\n             true"}, {"sha": "dcc323493f4795a2d13d6860bd32e2e441a814c7", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -2,6 +2,7 @@\n #![feature(let_chains)]\n #![feature(try_blocks)]\n #![feature(never_type)]\n+#![feature(box_patterns)]\n #![feature(min_specialization)]\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]"}, {"sha": "9a95a9c8375e00a2483d8d8b239ace66246aa2b0", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1530,7 +1530,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         // variables\n         let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            if let Some(ct) = tcx.bound_abstract_const(unevaluated.def)? {\n+            if let Some(ct) = tcx.thir_abstract_const(unevaluated.def)? {\n                 let ct = tcx.expand_abstract_consts(ct.subst(tcx, substs));\n                 if let Err(e) = ct.error_reported() {\n                     return Err(ErrorHandled::Reported(e));"}, {"sha": "51354c2b127990f8329aa21a20d1712b5c843fe6", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -173,12 +173,21 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                         let expected_values = check_cfg\n                                             .expecteds\n                                             .entry(ident.name.to_string())\n+                                            .and_modify(|expected_values| match expected_values {\n+                                                ExpectedValues::Some(_) => {}\n+                                                ExpectedValues::Any => {\n+                                                    // handle the case where names(...) was done\n+                                                    // before values by changing to a list\n+                                                    *expected_values =\n+                                                        ExpectedValues::Some(FxHashSet::default());\n+                                                }\n+                                            })\n                                             .or_insert_with(|| {\n                                                 ExpectedValues::Some(FxHashSet::default())\n                                             });\n \n                                         let ExpectedValues::Some(expected_values) = expected_values else {\n-                                            bug!(\"shoudn't be possible\")\n+                                            bug!(\"`expected_values` should be a list a values\")\n                                         };\n \n                                         for val in values {"}, {"sha": "b1c45eaf601e501f22f90485a48fa455bc14a51e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1882,8 +1882,8 @@ declare_lint_pass!(\n struct UnderMacro(bool);\n \n impl KeywordIdents {\n-    fn check_tokens(&mut self, cx: &EarlyContext<'_>, tokens: TokenStream) {\n-        for tt in tokens.into_trees() {\n+    fn check_tokens(&mut self, cx: &EarlyContext<'_>, tokens: &TokenStream) {\n+        for tt in tokens.trees() {\n             match tt {\n                 // Only report non-raw idents.\n                 TokenTree::Token(token, _) => {\n@@ -1944,10 +1944,10 @@ impl KeywordIdents {\n \n impl EarlyLintPass for KeywordIdents {\n     fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef) {\n-        self.check_tokens(cx, mac_def.body.tokens.clone());\n+        self.check_tokens(cx, &mac_def.body.tokens);\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n-        self.check_tokens(cx, mac.args.tokens.clone());\n+        self.check_tokens(cx, &mac.args.tokens);\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);"}, {"sha": "87906dee4d3481d4f59d3966d9e0a7e7ab0561c4", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -8,18 +8,100 @@\n \n using namespace llvm;\n \n+// FFI equivalent of enum `llvm::coverage::Counter::CounterKind`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L97-L99\n+enum class LLVMRustCounterKind {\n+  Zero = 0,\n+  CounterValueReference = 1,\n+  Expression = 2,\n+};\n+\n+// FFI equivalent of struct `llvm::coverage::Counter`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L94-L149\n+struct LLVMRustCounter {\n+  LLVMRustCounterKind CounterKind;\n+  uint32_t ID;\n+};\n+\n+static coverage::Counter fromRust(LLVMRustCounter Counter) {\n+  switch (Counter.CounterKind) {\n+  case LLVMRustCounterKind::Zero:\n+    return coverage::Counter::getZero();\n+  case LLVMRustCounterKind::CounterValueReference:\n+    return coverage::Counter::getCounter(Counter.ID);\n+  case LLVMRustCounterKind::Expression:\n+    return coverage::Counter::getExpression(Counter.ID);\n+  }\n+  report_fatal_error(\"Bad LLVMRustCounterKind!\");\n+}\n+\n+// FFI equivalent of enum `llvm::coverage::CounterMappingRegion::RegionKind`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L213-L234\n+enum class LLVMRustCounterMappingRegionKind {\n+  CodeRegion = 0,\n+  ExpansionRegion = 1,\n+  SkippedRegion = 2,\n+  GapRegion = 3,\n+  BranchRegion = 4,\n+};\n+\n+static coverage::CounterMappingRegion::RegionKind\n+fromRust(LLVMRustCounterMappingRegionKind Kind) {\n+  switch (Kind) {\n+  case LLVMRustCounterMappingRegionKind::CodeRegion:\n+    return coverage::CounterMappingRegion::CodeRegion;\n+  case LLVMRustCounterMappingRegionKind::ExpansionRegion:\n+    return coverage::CounterMappingRegion::ExpansionRegion;\n+  case LLVMRustCounterMappingRegionKind::SkippedRegion:\n+    return coverage::CounterMappingRegion::SkippedRegion;\n+  case LLVMRustCounterMappingRegionKind::GapRegion:\n+    return coverage::CounterMappingRegion::GapRegion;\n+  case LLVMRustCounterMappingRegionKind::BranchRegion:\n+    return coverage::CounterMappingRegion::BranchRegion;\n+  }\n+  report_fatal_error(\"Bad LLVMRustCounterMappingRegionKind!\");\n+}\n+\n+// FFI equivalent of struct `llvm::coverage::CounterMappingRegion`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L211-L304\n struct LLVMRustCounterMappingRegion {\n-  coverage::Counter Count;\n-  coverage::Counter FalseCount;\n+  LLVMRustCounter Count;\n+  LLVMRustCounter FalseCount;\n   uint32_t FileID;\n   uint32_t ExpandedFileID;\n   uint32_t LineStart;\n   uint32_t ColumnStart;\n   uint32_t LineEnd;\n   uint32_t ColumnEnd;\n-  coverage::CounterMappingRegion::RegionKind Kind;\n+  LLVMRustCounterMappingRegionKind Kind;\n+};\n+\n+// FFI equivalent of enum `llvm::coverage::CounterExpression::ExprKind`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L154\n+enum class LLVMRustCounterExprKind {\n+  Subtract = 0,\n+  Add = 1,\n };\n \n+// FFI equivalent of struct `llvm::coverage::CounterExpression`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L151-L160\n+struct LLVMRustCounterExpression {\n+  LLVMRustCounterExprKind Kind;\n+  LLVMRustCounter LHS;\n+  LLVMRustCounter RHS;\n+};\n+\n+static coverage::CounterExpression::ExprKind\n+fromRust(LLVMRustCounterExprKind Kind) {\n+  switch (Kind) {\n+  case LLVMRustCounterExprKind::Subtract:\n+    return coverage::CounterExpression::Subtract;\n+  case LLVMRustCounterExprKind::Add:\n+    return coverage::CounterExpression::Add;\n+  }\n+  report_fatal_error(\"Bad LLVMRustCounterExprKind!\");\n+}\n+\n extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n@@ -37,9 +119,9 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n     const unsigned *VirtualFileMappingIDs,\n     unsigned NumVirtualFileMappingIDs,\n-    const coverage::CounterExpression *Expressions,\n+    const LLVMRustCounterExpression *RustExpressions,\n     unsigned NumExpressions,\n-    LLVMRustCounterMappingRegion *RustMappingRegions,\n+    const LLVMRustCounterMappingRegion *RustMappingRegions,\n     unsigned NumMappingRegions,\n     RustStringRef BufferOut) {\n   // Convert from FFI representation to LLVM representation.\n@@ -48,13 +130,24 @@ extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n   for (const auto &Region : ArrayRef<LLVMRustCounterMappingRegion>(\n            RustMappingRegions, NumMappingRegions)) {\n     MappingRegions.emplace_back(\n-        Region.Count, Region.FalseCount, Region.FileID, Region.ExpandedFileID,\n+        fromRust(Region.Count), fromRust(Region.FalseCount),\n+        Region.FileID, Region.ExpandedFileID,\n         Region.LineStart, Region.ColumnStart, Region.LineEnd, Region.ColumnEnd,\n-        Region.Kind);\n+        fromRust(Region.Kind));\n   }\n+\n+  std::vector<coverage::CounterExpression> Expressions;\n+  Expressions.reserve(NumExpressions);\n+  for (const auto &Expression :\n+       ArrayRef<LLVMRustCounterExpression>(RustExpressions, NumExpressions)) {\n+    Expressions.emplace_back(fromRust(Expression.Kind),\n+                             fromRust(Expression.LHS),\n+                             fromRust(Expression.RHS));\n+  }\n+\n   auto CoverageMappingWriter = coverage::CoverageMappingWriter(\n       ArrayRef<unsigned>(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n-      ArrayRef<coverage::CounterExpression>(Expressions, NumExpressions),\n+      Expressions,\n       MappingRegions);\n   RawRustStringOstream OS(BufferOut);\n   CoverageMappingWriter.write(OS);"}, {"sha": "72b208a7132768ff7f37c1c9b02c6fc394f28ca8", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -89,11 +89,25 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         // to try to eagerly statically link all dependencies. This is normally\n         // done for end-product dylibs, not intermediate products.\n         //\n-        // Treat cdylibs similarly. If `-C prefer-dynamic` is set, the caller may\n-        // be code-size conscious, but without it, it makes sense to statically\n-        // link a cdylib.\n-        CrateType::Dylib | CrateType::Cdylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n-        CrateType::Dylib | CrateType::Cdylib => Linkage::Dynamic,\n+        // Treat cdylibs and staticlibs similarly. If `-C prefer-dynamic` is set,\n+        // the caller may be code-size conscious, but without it, it makes sense\n+        // to statically link a cdylib or staticlib. For staticlibs we use\n+        // `-Z staticlib-prefer-dynamic` for now. This may be merged into\n+        // `-C prefer-dynamic` in the future.\n+        CrateType::Dylib | CrateType::Cdylib => {\n+            if sess.opts.cg.prefer_dynamic {\n+                Linkage::Dynamic\n+            } else {\n+                Linkage::Static\n+            }\n+        }\n+        CrateType::Staticlib => {\n+            if sess.opts.unstable_opts.staticlib_prefer_dynamic {\n+                Linkage::Dynamic\n+            } else {\n+                Linkage::Static\n+            }\n+        }\n \n         // If the global prefer_dynamic switch is turned off, or the final\n         // executable will be statically linked, prefer static crate linkage.\n@@ -108,9 +122,6 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n         CrateType::Rlib => Linkage::NotLinked,\n-\n-        // staticlibs must have all static dependencies.\n-        CrateType::Staticlib => Linkage::Static,\n     };\n \n     match preferred_linkage {\n@@ -123,9 +134,9 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n                 return v;\n             }\n \n-            // Staticlibs and static executables must have all static dependencies.\n+            // Static executables must have all static dependencies.\n             // If any are not found, generate some nice pretty errors.\n-            if ty == CrateType::Staticlib\n+            if (ty == CrateType::Staticlib && !sess.opts.unstable_opts.staticlib_allow_rdylib_deps)\n                 || (ty == CrateType::Executable\n                     && sess.crt_static(Some(ty))\n                     && !sess.target.crt_static_allows_dylibs)"}, {"sha": "29cf432b8f9186030725272371c737d0033db6e2", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -862,6 +862,11 @@ fn should_encode_attrs(def_kind: DefKind) -> bool {\n         | DefKind::Macro(_)\n         | DefKind::Field\n         | DefKind::Impl { .. } => true,\n+        // Tools may want to be able to detect their tool lints on\n+        // closures from upstream crates, too. This is used by\n+        // https://github.com/model-checking/kani and is not a performance\n+        // or maintenance issue for us.\n+        DefKind::Closure => true,\n         DefKind::TyParam\n         | DefKind::ConstParam\n         | DefKind::Ctor(..)\n@@ -874,7 +879,6 @@ fn should_encode_attrs(def_kind: DefKind) -> bool {\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::LifetimeParam\n         | DefKind::GlobalAsm\n-        | DefKind::Closure\n         | DefKind::Generator => false,\n     }\n }"}, {"sha": "e2f6acb186b7234204f536ce424d644f17fc412e", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -394,7 +394,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     mir_generator_witnesses: Table<DefIndex, LazyValue<mir::GeneratorLayout<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n-    thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<ty::EarlyBinder<ty::Const<'static>>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,"}, {"sha": "4b7014e31090b4c59946b8898446bf5067958177", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -64,7 +64,7 @@\n \n use crate::mir::*;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{CanonicalUserTypeAnnotation, Ty};\n+use crate::ty::{self, CanonicalUserTypeAnnotation, Ty};\n use rustc_span::Span;\n \n macro_rules! make_mir_visitor {\n@@ -782,12 +782,12 @@ macro_rules! make_mir_visitor {\n \n             fn super_ascribe_user_ty(&mut self,\n                                      place: & $($mutability)? Place<'tcx>,\n-                                     _variance: $(& $mutability)? ty::Variance,\n+                                     variance: $(& $mutability)? ty::Variance,\n                                      user_ty: & $($mutability)? UserTypeProjection,\n                                      location: Location) {\n                 self.visit_place(\n                     place,\n-                    PlaceContext::NonUse(NonUseContext::AscribeUserTy),\n+                    PlaceContext::NonUse(NonUseContext::AscribeUserTy($(* &$mutability *)? variance)),\n                     location\n                 );\n                 self.visit_user_type_projection(user_ty);\n@@ -1320,7 +1320,7 @@ pub enum NonUseContext {\n     /// Ending a storage live range.\n     StorageDead,\n     /// User type annotation assertions for NLL.\n-    AscribeUserTy,\n+    AscribeUserTy(ty::Variance),\n     /// The data of a user variable, for debug info.\n     VarDebugInfo,\n }"}, {"sha": "28a9c1eef1a6d30c1daff18fd066af628d064e21", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -82,9 +82,10 @@ impl EraseType for Result<Option<ty::Instance<'_>>, rustc_errors::ErrorGuarantee\n         [u8; size_of::<Result<Option<ty::Instance<'static>>, rustc_errors::ErrorGuaranteed>>()];\n }\n \n-impl EraseType for Result<Option<ty::Const<'_>>, rustc_errors::ErrorGuaranteed> {\n-    type Result =\n-        [u8; size_of::<Result<Option<ty::Const<'static>>, rustc_errors::ErrorGuaranteed>>()];\n+impl EraseType for Result<Option<ty::EarlyBinder<ty::Const<'_>>>, rustc_errors::ErrorGuaranteed> {\n+    type Result = [u8; size_of::<\n+        Result<Option<ty::EarlyBinder<ty::Const<'static>>>, rustc_errors::ErrorGuaranteed>,\n+    >()];\n }\n \n impl EraseType for Result<ty::GenericArg<'_>, traits::query::NoSolution> {"}, {"sha": "9fad2816b0d842ed5c7160dd71d64502285fd1d6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -402,7 +402,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }\n@@ -1016,7 +1016,7 @@ rustc_queries! {\n         desc { \"converting literal to mir constant\" }\n     }\n \n-    query check_match(key: LocalDefId) {\n+    query check_match(key: LocalDefId) -> Result<(), rustc_errors::ErrorGuaranteed> {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { true }\n     }"}, {"sha": "449c453555e9e4c978d94d0b7f7ceb9fb28f81ce", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -580,11 +580,7 @@ pub enum SelectionError<'tcx> {\n     /// After a closure impl has selected, its \"outputs\" were evaluated\n     /// (which for closures includes the \"input\" type params) and they\n     /// didn't resolve. See `confirm_poly_trait_refs` for more.\n-    OutputTypeParameterMismatch(\n-        ty::PolyTraitRef<'tcx>,\n-        ty::PolyTraitRef<'tcx>,\n-        ty::error::TypeError<'tcx>,\n-    ),\n+    OutputTypeParameterMismatch(Box<SelectionOutputTypeParameterMismatch<'tcx>>),\n     /// The trait pointed by `DefId` is not object safe.\n     TraitNotObjectSafe(DefId),\n     /// A given constant couldn't be evaluated.\n@@ -596,6 +592,13 @@ pub enum SelectionError<'tcx> {\n     ErrorReporting,\n }\n \n+#[derive(Clone, Debug, TypeVisitable, Lift)]\n+pub struct SelectionOutputTypeParameterMismatch<'tcx> {\n+    pub found_trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub expected_trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub terr: ty::error::TypeError<'tcx>,\n+}\n+\n /// When performing resolution, it is typically the case that there\n /// can be one of three outcomes:\n ///"}, {"sha": "972c417cbbabd907ef53a0a204a51920dad7a510", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -4,7 +4,6 @@ use crate::ty::{\n     TypeVisitableExt,\n };\n use rustc_errors::ErrorGuaranteed;\n-use rustc_hir::def_id::DefId;\n \n #[derive(Hash, Debug, Clone, Copy, Ord, PartialOrd, PartialEq, Eq)]\n #[derive(TyDecodable, TyEncodable, HashStable, TypeVisitable, TypeFoldable)]\n@@ -35,12 +34,6 @@ TrivialTypeTraversalAndLiftImpls! {\n pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed>;\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Returns a const without substs applied\n-    pub fn bound_abstract_const(self, uv: DefId) -> BoundAbstractConst<'tcx> {\n-        let ac = self.thir_abstract_const(uv);\n-        Ok(ac?.map(|ac| EarlyBinder(ac)))\n-    }\n-\n     pub fn expand_abstract_consts<T: TypeFoldable<TyCtxt<'tcx>>>(self, ac: T) -> T {\n         struct Expander<'tcx> {\n             tcx: TyCtxt<'tcx>,\n@@ -59,7 +52,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             }\n             fn fold_const(&mut self, c: Const<'tcx>) -> Const<'tcx> {\n                 let ct = match c.kind() {\n-                    ty::ConstKind::Unevaluated(uv) => match self.tcx.bound_abstract_const(uv.def) {\n+                    ty::ConstKind::Unevaluated(uv) => match self.tcx.thir_abstract_const(uv.def) {\n                         Err(e) => self.tcx.const_error_with_guaranteed(c.ty(), e),\n                         Ok(Some(bac)) => {\n                             let substs = self.tcx.erase_regions(uv.substs);"}, {"sha": "488d83b5f671b6e083ede5ece2e1985ca20a9cdc", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -2366,13 +2366,11 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Adt(def, _substs) => def.sized_constraint(tcx).0.is_empty(),\n \n-            ty::Alias(..) | ty::Param(_) => false,\n+            ty::Alias(..) | ty::Param(_) | ty::Placeholder(..) => false,\n \n             ty::Infer(ty::TyVar(_)) => false,\n \n-            ty::Bound(..)\n-            | ty::Placeholder(..)\n-            | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+            ty::Bound(..) | ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"`is_trivially_sized` applied to unexpected type: {:?}\", self)\n             }\n         }"}, {"sha": "bcb51db9bcf90091de39e10ea0d1430c8f2db9d6", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1253,7 +1253,7 @@ pub enum ExplicitSelf<'tcx> {\n \n impl<'tcx> ExplicitSelf<'tcx> {\n     /// Categorizes an explicit self declaration like `self: SomeType`\n-    /// into either `self`, `&self`, `&mut self`, `Box<self>`, or\n+    /// into either `self`, `&self`, `&mut self`, `Box<Self>`, or\n     /// `Other`.\n     /// This is mainly used to require the arbitrary_self_types feature\n     /// in the case of `Other`, to improve error messages in the common cases,"}, {"sha": "20d381eddb1fc0b8fa6f6f4dd0ba7ba864422d48", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -42,7 +42,9 @@ fn mir_build(tcx: TyCtxt<'_>, def: LocalDefId) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     tcx.ensure_with_value().thir_check_unsafety(def);\n     tcx.ensure_with_value().thir_abstract_const(def);\n-    tcx.ensure_with_value().check_match(def);\n+    if let Err(e) = tcx.check_match(def) {\n+        return construct_error(tcx, def, e);\n+    }\n \n     let body = match tcx.thir_body(def) {\n         Err(error_reported) => construct_error(tcx, def, error_reported),"}, {"sha": "ca25f83e6437eb35fcad769824734c899e8b45d9", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -26,8 +26,8 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let Ok((thir, expr)) = tcx.thir_body(def_id) else { return };\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGuaranteed> {\n+    let (thir, expr) = tcx.thir_body(def_id)?;\n     let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n@@ -37,13 +37,16 @@ pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         lint_level: tcx.hir().local_def_id_to_hir_id(def_id),\n         let_source: LetSource::None,\n         pattern_arena: &pattern_arena,\n+        error: Ok(()),\n     };\n     visitor.visit_expr(&thir[expr]);\n+\n     for param in thir.params.iter() {\n         if let Some(box ref pattern) = param.pat {\n             visitor.check_irrefutable(pattern, \"function argument\", None);\n         }\n     }\n+    visitor.error\n }\n \n fn create_e0004(\n@@ -77,6 +80,7 @@ struct MatchVisitor<'a, 'p, 'tcx> {\n     lint_level: HirId,\n     let_source: LetSource,\n     pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    error: Result<(), ErrorGuaranteed>,\n }\n \n impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n@@ -276,9 +280,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 let [pat_field] = &subpatterns[..] else { bug!() };\n                 self.check_irrefutable(&pat_field.pattern, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(\n+                self.error = Err(non_exhaustive_match(\n                     &cx, self.thir, scrut_ty, scrut.span, witnesses, arms, expr_span,\n-                );\n+                ));\n             }\n         }\n     }\n@@ -406,7 +410,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n+    fn check_irrefutable(&mut self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(self.lint_level, false);\n \n         let pattern = self.lower_pattern(&mut cx, pat);\n@@ -475,7 +479,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n-        self.tcx.sess.emit_err(PatternNotCovered {\n+        self.error = Err(self.tcx.sess.emit_err(PatternNotCovered {\n             span: pat.span,\n             origin,\n             uncovered: Uncovered::new(pat.span, &cx, witnesses),\n@@ -486,7 +490,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             let_suggestion,\n             misc_suggestion,\n             adt_defined_here,\n-        });\n+        }));\n     }\n }\n \n@@ -628,7 +632,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n     arms: &[ArmId],\n     expr_span: Span,\n-) {\n+) -> ErrorGuaranteed {\n     let is_empty_match = arms.is_empty();\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants().is_empty(),\n@@ -640,13 +644,12 @@ fn non_exhaustive_match<'p, 'tcx>(\n     let pattern;\n     let patterns_len;\n     if is_empty_match && !non_empty_enum {\n-        cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n+        return cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n             cx,\n             expr_span,\n             span: sp,\n             ty: scrut_ty,\n         });\n-        return;\n     } else {\n         // FIXME: migration of this diagnostic will require list support\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n@@ -797,7 +800,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     } else {\n         err.help(msg);\n     }\n-    err.emit();\n+    err.emit()\n }\n \n pub(crate) fn joined_uncovered_patterns<'p, 'tcx>("}, {"sha": "3952f44ad489dfb0f4bd01158ad218de56b5fec4", "filename": "compiler/rustc_mir_dataflow/src/framework/lattice.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Flattice.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -75,12 +75,12 @@ pub trait MeetSemiLattice: Eq {\n \n /// A set that has a \"bottom\" element, which is less than or equal to any other element.\n pub trait HasBottom {\n-    fn bottom() -> Self;\n+    const BOTTOM: Self;\n }\n \n /// A set that has a \"top\" element, which is greater than or equal to any other element.\n pub trait HasTop {\n-    fn top() -> Self;\n+    const TOP: Self;\n }\n \n /// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom:\n@@ -113,15 +113,11 @@ impl MeetSemiLattice for bool {\n }\n \n impl HasBottom for bool {\n-    fn bottom() -> Self {\n-        false\n-    }\n+    const BOTTOM: Self = false;\n }\n \n impl HasTop for bool {\n-    fn top() -> Self {\n-        true\n-    }\n+    const TOP: Self = true;\n }\n \n /// A tuple (or list) of lattices is itself a lattice whose least upper bound is the concatenation\n@@ -274,13 +270,9 @@ impl<T: Clone + Eq> MeetSemiLattice for FlatSet<T> {\n }\n \n impl<T> HasBottom for FlatSet<T> {\n-    fn bottom() -> Self {\n-        Self::Bottom\n-    }\n+    const BOTTOM: Self = Self::Bottom;\n }\n \n impl<T> HasTop for FlatSet<T> {\n-    fn top() -> Self {\n-        Self::Top\n-    }\n+    const TOP: Self = Self::Top;\n }"}, {"sha": "b74d06e5ae8dd0b02635bcae5f775db179e9e3e1", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 160, "deletions": 110, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -32,9 +32,12 @@\n //! Because of that, we can assume that the only way to change the value behind a tracked place is\n //! by direct assignment.\n \n+use std::collections::VecDeque;\n use std::fmt::{Debug, Formatter};\n+use std::ops::Range;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_index::bit_set::BitSet;\n use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n@@ -65,20 +68,20 @@ pub trait ValueAnalysis<'tcx> {\n             StatementKind::Assign(box (place, rvalue)) => {\n                 self.handle_assign(*place, rvalue, state);\n             }\n-            StatementKind::SetDiscriminant { box ref place, .. } => {\n-                state.flood_discr(place.as_ref(), self.map());\n+            StatementKind::SetDiscriminant { box place, variant_index } => {\n+                self.handle_set_discriminant(*place, *variant_index, state);\n             }\n             StatementKind::Intrinsic(box intrinsic) => {\n                 self.handle_intrinsic(intrinsic, state);\n             }\n             StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n                 // StorageLive leaves the local in an uninitialized state.\n                 // StorageDead makes it UB to access the local afterwards.\n-                state.flood_with(Place::from(*local).as_ref(), self.map(), Self::Value::bottom());\n+                state.flood_with(Place::from(*local).as_ref(), self.map(), Self::Value::BOTTOM);\n             }\n             StatementKind::Deinit(box place) => {\n                 // Deinit makes the place uninitialized.\n-                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::BOTTOM);\n             }\n             StatementKind::Retag(..) => {\n                 // We don't track references.\n@@ -92,6 +95,24 @@ pub trait ValueAnalysis<'tcx> {\n         }\n     }\n \n+    fn handle_set_discriminant(\n+        &self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        self.super_set_discriminant(place, variant_index, state)\n+    }\n+\n+    fn super_set_discriminant(\n+        &self,\n+        place: Place<'tcx>,\n+        _variant_index: VariantIdx,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        state.flood_discr(place.as_ref(), self.map());\n+    }\n+\n     fn handle_intrinsic(\n         &self,\n         intrinsic: &NonDivergingIntrinsic<'tcx>,\n@@ -103,16 +124,18 @@ pub trait ValueAnalysis<'tcx> {\n     fn super_intrinsic(\n         &self,\n         intrinsic: &NonDivergingIntrinsic<'tcx>,\n-        state: &mut State<Self::Value>,\n+        _state: &mut State<Self::Value>,\n     ) {\n         match intrinsic {\n             NonDivergingIntrinsic::Assume(..) => {\n                 // Could use this, but ignoring it is sound.\n             }\n-            NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping { dst, .. }) => {\n-                if let Some(place) = dst.place() {\n-                    state.flood(place.as_ref(), self.map());\n-                }\n+            NonDivergingIntrinsic::CopyNonOverlapping(CopyNonOverlapping {\n+                dst: _,\n+                src: _,\n+                count: _,\n+            }) => {\n+                // This statement represents `*dst = *src`, `count` times.\n             }\n         }\n     }\n@@ -154,7 +177,7 @@ pub trait ValueAnalysis<'tcx> {\n             Rvalue::CopyForDeref(place) => self.handle_operand(&Operand::Copy(*place), state),\n             Rvalue::Ref(..) | Rvalue::AddressOf(..) => {\n                 // We don't track such places.\n-                ValueOrPlace::top()\n+                ValueOrPlace::TOP\n             }\n             Rvalue::Repeat(..)\n             | Rvalue::ThreadLocalRef(..)\n@@ -168,7 +191,7 @@ pub trait ValueAnalysis<'tcx> {\n             | Rvalue::Aggregate(..)\n             | Rvalue::ShallowInitBox(..) => {\n                 // No modification is possible through these r-values.\n-                ValueOrPlace::top()\n+                ValueOrPlace::TOP\n             }\n         }\n     }\n@@ -196,7 +219,7 @@ pub trait ValueAnalysis<'tcx> {\n                 self.map()\n                     .find(place.as_ref())\n                     .map(ValueOrPlace::Place)\n-                    .unwrap_or(ValueOrPlace::top())\n+                    .unwrap_or(ValueOrPlace::TOP)\n             }\n         }\n     }\n@@ -214,7 +237,7 @@ pub trait ValueAnalysis<'tcx> {\n         _constant: &Constant<'tcx>,\n         _state: &mut State<Self::Value>,\n     ) -> Self::Value {\n-        Self::Value::top()\n+        Self::Value::TOP\n     }\n \n     /// The effect of a successful function call return should not be\n@@ -229,7 +252,7 @@ pub trait ValueAnalysis<'tcx> {\n                 // Effect is applied by `handle_call_return`.\n             }\n             TerminatorKind::Drop { place, .. } => {\n-                state.flood_with(place.as_ref(), self.map(), Self::Value::bottom());\n+                state.flood_with(place.as_ref(), self.map(), Self::Value::BOTTOM);\n             }\n             TerminatorKind::Yield { .. } => {\n                 // They would have an effect, but are not allowed in this phase.\n@@ -307,7 +330,7 @@ impl<'tcx, T: ValueAnalysis<'tcx>> AnalysisDomain<'tcx> for ValueAnalysisWrapper\n     fn initialize_start_block(&self, body: &Body<'tcx>, state: &mut Self::Domain) {\n         // The initial state maps all tracked places of argument projections to \u22a4 and the rest to \u22a5.\n         assert!(matches!(state.0, StateData::Unreachable));\n-        let values = IndexVec::from_elem_n(T::Value::bottom(), self.0.map().value_count);\n+        let values = IndexVec::from_elem_n(T::Value::BOTTOM, self.0.map().value_count);\n         *state = State(StateData::Reachable(values));\n         for arg in body.args_iter() {\n             state.flood(PlaceRef { local: arg, projection: &[] }, self.0.map());\n@@ -437,7 +460,7 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n     }\n \n     pub fn flood_all(&mut self) {\n-        self.flood_all_with(V::top())\n+        self.flood_all_with(V::TOP)\n     }\n \n     pub fn flood_all_with(&mut self, value: V) {\n@@ -447,28 +470,24 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n \n     pub fn flood_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.for_each_aliasing_place(place, None, &mut |place| {\n-            if let Some(vi) = map.places[place].value_index {\n-                values[vi] = value.clone();\n-            }\n+        map.for_each_aliasing_place(place, None, &mut |vi| {\n+            values[vi] = value.clone();\n         });\n     }\n \n     pub fn flood(&mut self, place: PlaceRef<'_>, map: &Map) {\n-        self.flood_with(place, map, V::top())\n+        self.flood_with(place, map, V::TOP)\n     }\n \n     pub fn flood_discr_with(&mut self, place: PlaceRef<'_>, map: &Map, value: V) {\n         let StateData::Reachable(values) = &mut self.0 else { return };\n-        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |place| {\n-            if let Some(vi) = map.places[place].value_index {\n-                values[vi] = value.clone();\n-            }\n+        map.for_each_aliasing_place(place, Some(TrackElem::Discriminant), &mut |vi| {\n+            values[vi] = value.clone();\n         });\n     }\n \n     pub fn flood_discr(&mut self, place: PlaceRef<'_>, map: &Map) {\n-        self.flood_discr_with(place, map, V::top())\n+        self.flood_discr_with(place, map, V::TOP)\n     }\n \n     /// Low-level method that assigns to a place.\n@@ -538,26 +557,26 @@ impl<V: Clone + HasTop + HasBottom> State<V> {\n \n     /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n     pub fn get(&self, place: PlaceRef<'_>, map: &Map) -> V {\n-        map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::top())\n+        map.find(place).map(|place| self.get_idx(place, map)).unwrap_or(V::TOP)\n     }\n \n     /// Retrieve the value stored for a place, or \u22a4 if it is not tracked.\n     pub fn get_discr(&self, place: PlaceRef<'_>, map: &Map) -> V {\n         match map.find_discr(place) {\n             Some(place) => self.get_idx(place, map),\n-            None => V::top(),\n+            None => V::TOP,\n         }\n     }\n \n     /// Retrieve the value stored for a place index, or \u22a4 if it is not tracked.\n     pub fn get_idx(&self, place: PlaceIndex, map: &Map) -> V {\n         match &self.0 {\n             StateData::Reachable(values) => {\n-                map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::top())\n+                map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::TOP)\n             }\n             StateData::Unreachable => {\n                 // Because this is unreachable, we can return any value we want.\n-                V::bottom()\n+                V::BOTTOM\n             }\n         }\n     }\n@@ -588,6 +607,9 @@ pub struct Map {\n     projections: FxHashMap<(PlaceIndex, TrackElem), PlaceIndex>,\n     places: IndexVec<PlaceIndex, PlaceInfo>,\n     value_count: usize,\n+    // The Range corresponds to a slice into `inner_values_buffer`.\n+    inner_values: IndexVec<PlaceIndex, Range<usize>>,\n+    inner_values_buffer: Vec<ValueIndex>,\n }\n \n impl Map {\n@@ -597,6 +619,8 @@ impl Map {\n             projections: FxHashMap::default(),\n             places: IndexVec::new(),\n             value_count: 0,\n+            inner_values: IndexVec::new(),\n+            inner_values_buffer: Vec::new(),\n         }\n     }\n \n@@ -608,12 +632,12 @@ impl Map {\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        filter: impl FnMut(Ty<'tcx>) -> bool,\n-        place_limit: Option<usize>,\n+        filter: impl Fn(Ty<'tcx>) -> bool,\n+        value_limit: Option<usize>,\n     ) -> Self {\n         let mut map = Self::new();\n         let exclude = excluded_locals(body);\n-        map.register_with_filter(tcx, body, filter, exclude, place_limit);\n+        map.register_with_filter(tcx, body, filter, exclude, value_limit);\n         debug!(\"registered {} places ({} nodes in total)\", map.value_count, map.places.len());\n         map\n     }\n@@ -623,51 +647,90 @@ impl Map {\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n-        mut filter: impl FnMut(Ty<'tcx>) -> bool,\n+        filter: impl Fn(Ty<'tcx>) -> bool,\n         exclude: BitSet<Local>,\n-        place_limit: Option<usize>,\n+        value_limit: Option<usize>,\n     ) {\n-        // We use this vector as stack, pushing and popping projections.\n-        let mut projection = Vec::new();\n+        let mut worklist = VecDeque::with_capacity(value_limit.unwrap_or(body.local_decls.len()));\n+\n+        // Start by constructing the places for each bare local.\n+        self.locals = IndexVec::from_elem(None, &body.local_decls);\n         for (local, decl) in body.local_decls.iter_enumerated() {\n-            if !exclude.contains(local) {\n-                self.register_with_filter_rec(\n-                    tcx,\n-                    local,\n-                    &mut projection,\n-                    decl.ty,\n-                    &mut filter,\n-                    place_limit,\n-                );\n+            if exclude.contains(local) {\n+                continue;\n             }\n+\n+            // Create a place for the local.\n+            debug_assert!(self.locals[local].is_none());\n+            let place = self.places.push(PlaceInfo::new(None));\n+            self.locals[local] = Some(place);\n+\n+            // And push the eventual children places to the worklist.\n+            self.register_children(tcx, place, decl.ty, &filter, &mut worklist);\n         }\n+\n+        // `place.elem1.elem2` with type `ty`.\n+        // `elem1` is either `Some(Variant(i))` or `None`.\n+        while let Some((mut place, elem1, elem2, ty)) = worklist.pop_front() {\n+            // The user requires a bound on the number of created values.\n+            if let Some(value_limit) = value_limit && self.value_count >= value_limit {\n+                break\n+            }\n+\n+            // Create a place for this projection.\n+            for elem in [elem1, Some(elem2)].into_iter().flatten() {\n+                place = *self.projections.entry((place, elem)).or_insert_with(|| {\n+                    // Prepend new child to the linked list.\n+                    let next = self.places.push(PlaceInfo::new(Some(elem)));\n+                    self.places[next].next_sibling = self.places[place].first_child;\n+                    self.places[place].first_child = Some(next);\n+                    next\n+                });\n+            }\n+\n+            // And push the eventual children places to the worklist.\n+            self.register_children(tcx, place, ty, &filter, &mut worklist);\n+        }\n+\n+        // Pre-compute the tree of ValueIndex nested in each PlaceIndex.\n+        // `inner_values_buffer[inner_values[place]]` is the set of all the values\n+        // reachable by projecting `place`.\n+        self.inner_values_buffer = Vec::with_capacity(self.value_count);\n+        self.inner_values = IndexVec::from_elem(0..0, &self.places);\n+        for local in body.local_decls.indices() {\n+            if let Some(place) = self.locals[local] {\n+                self.cache_preorder_invoke(place);\n+            }\n+        }\n+\n+        // Trim useless places.\n+        for opt_place in self.locals.iter_mut() {\n+            if let Some(place) = *opt_place && self.inner_values[place].is_empty() {\n+                *opt_place = None;\n+            }\n+        }\n+        #[allow(rustc::potential_query_instability)]\n+        self.projections.retain(|_, child| !self.inner_values[*child].is_empty());\n     }\n \n     /// Potentially register the (local, projection) place and its fields, recursively.\n     ///\n     /// Invariant: The projection must only contain trackable elements.\n-    fn register_with_filter_rec<'tcx>(\n+    fn register_children<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        local: Local,\n-        projection: &mut Vec<PlaceElem<'tcx>>,\n+        place: PlaceIndex,\n         ty: Ty<'tcx>,\n-        filter: &mut impl FnMut(Ty<'tcx>) -> bool,\n-        place_limit: Option<usize>,\n+        filter: &impl Fn(Ty<'tcx>) -> bool,\n+        worklist: &mut VecDeque<(PlaceIndex, Option<TrackElem>, TrackElem, Ty<'tcx>)>,\n     ) {\n-        if let Some(place_limit) = place_limit && self.value_count >= place_limit {\n-            return\n-        }\n-\n-        // We know that the projection only contains trackable elements.\n-        let place = self.make_place(local, projection).unwrap();\n-\n         // Allocate a value slot if it doesn't have one, and the user requested one.\n         if self.places[place].value_index.is_none() && filter(ty) {\n             self.places[place].value_index = Some(self.value_count.into());\n             self.value_count += 1;\n         }\n \n+        // For enums, directly create the `Discriminant`, as that's their main use.\n         if ty.is_enum() {\n             let discr_ty = ty.discriminant_ty(tcx);\n             if filter(discr_ty) {\n@@ -692,46 +755,32 @@ impl Map {\n \n         // Recurse with all fields of this place.\n         iter_fields(ty, tcx, ty::ParamEnv::reveal_all(), |variant, field, ty| {\n-            if let Some(variant) = variant {\n-                projection.push(PlaceElem::Downcast(None, variant));\n-                let _ = self.make_place(local, projection);\n-                projection.push(PlaceElem::Field(field, ty));\n-                self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n-                projection.pop();\n-                projection.pop();\n-                return;\n-            }\n-            projection.push(PlaceElem::Field(field, ty));\n-            self.register_with_filter_rec(tcx, local, projection, ty, filter, place_limit);\n-            projection.pop();\n+            worklist.push_back((\n+                place,\n+                variant.map(TrackElem::Variant),\n+                TrackElem::Field(field),\n+                ty,\n+            ))\n         });\n     }\n \n-    /// Tries to add the place to the map, without allocating a value slot.\n-    ///\n-    /// Can fail if the projection contains non-trackable elements.\n-    fn make_place<'tcx>(\n-        &mut self,\n-        local: Local,\n-        projection: &[PlaceElem<'tcx>],\n-    ) -> Result<PlaceIndex, ()> {\n-        // Get the base index of the local.\n-        let mut index =\n-            *self.locals.get_or_insert_with(local, || self.places.push(PlaceInfo::new(None)));\n-\n-        // Apply the projection.\n-        for &elem in projection {\n-            let elem = elem.try_into()?;\n-            index = *self.projections.entry((index, elem)).or_insert_with(|| {\n-                // Prepend new child to the linked list.\n-                let next = self.places.push(PlaceInfo::new(Some(elem)));\n-                self.places[next].next_sibling = self.places[index].first_child;\n-                self.places[index].first_child = Some(next);\n-                next\n-            });\n+    /// Precompute the list of values inside `root` and store it inside\n+    /// as a slice within `inner_values_buffer`.\n+    fn cache_preorder_invoke(&mut self, root: PlaceIndex) {\n+        let start = self.inner_values_buffer.len();\n+        if let Some(vi) = self.places[root].value_index {\n+            self.inner_values_buffer.push(vi);\n+        }\n+\n+        // We manually iterate instead of using `children` as we need to mutate `self`.\n+        let mut next_child = self.places[root].first_child;\n+        while let Some(child) = next_child {\n+            ensure_sufficient_stack(|| self.cache_preorder_invoke(child));\n+            next_child = self.places[child].next_sibling;\n         }\n \n-        Ok(index)\n+        let end = self.inner_values_buffer.len();\n+        self.inner_values[root] = start..end;\n     }\n \n     /// Returns the number of tracked places, i.e., those for which a value can be stored.\n@@ -750,7 +799,7 @@ impl Map {\n         place: PlaceRef<'_>,\n         extra: impl IntoIterator<Item = TrackElem>,\n     ) -> Option<PlaceIndex> {\n-        let mut index = *self.locals.get(place.local)?.as_ref()?;\n+        let mut index = *self.locals[place.local].as_ref()?;\n \n         for &elem in place.projection {\n             index = self.apply(index, elem.try_into().ok()?)?;\n@@ -784,17 +833,17 @@ impl Map {\n     ///\n     /// `tail_elem` allows to support discriminants that are not a place in MIR, but that we track\n     /// as such.\n-    pub fn for_each_aliasing_place(\n+    fn for_each_aliasing_place(\n         &self,\n         place: PlaceRef<'_>,\n         tail_elem: Option<TrackElem>,\n-        f: &mut impl FnMut(PlaceIndex),\n+        f: &mut impl FnMut(ValueIndex),\n     ) {\n-        if place.is_indirect() {\n+        if place.has_deref() {\n             // We do not track indirect places.\n             return;\n         }\n-        let Some(&Some(mut index)) = self.locals.get(place.local) else {\n+        let Some(mut index) = self.locals[place.local] else {\n             // The local is not tracked at all, so it does not alias anything.\n             return;\n         };\n@@ -805,7 +854,9 @@ impl Map {\n             .chain(tail_elem.map(Ok).into_iter());\n         for elem in elems {\n             // A field aliases the parent place.\n-            f(index);\n+            if let Some(vi) = self.places[index].value_index {\n+                f(vi);\n+            }\n \n             let Ok(elem) = elem else { return };\n             let sub = self.apply(index, elem);\n@@ -819,15 +870,15 @@ impl Map {\n                 return;\n             }\n         }\n-        self.preorder_invoke(index, f);\n+        self.for_each_value_inside(index, f);\n     }\n \n     /// Invoke the given function on all the descendants of the given place, except one branch.\n     fn for_each_variant_sibling(\n         &self,\n         parent: PlaceIndex,\n         preserved_child: Option<PlaceIndex>,\n-        f: &mut impl FnMut(PlaceIndex),\n+        f: &mut impl FnMut(ValueIndex),\n     ) {\n         for sibling in self.children(parent) {\n             let elem = self.places[sibling].proj_elem;\n@@ -837,16 +888,17 @@ impl Map {\n                 // Only invalidate the other variants, the current one is fine.\n                 && Some(sibling) != preserved_child\n             {\n-                self.preorder_invoke(sibling, f);\n+                self.for_each_value_inside(sibling, f);\n             }\n         }\n     }\n \n-    /// Invoke a function on the given place and all descendants.\n-    fn preorder_invoke(&self, root: PlaceIndex, f: &mut impl FnMut(PlaceIndex)) {\n-        f(root);\n-        for child in self.children(root) {\n-            self.preorder_invoke(child, f);\n+    /// Invoke a function on each value in the given place and all descendants.\n+    fn for_each_value_inside(&self, root: PlaceIndex, f: &mut impl FnMut(ValueIndex)) {\n+        let range = self.inner_values[root].clone();\n+        let values = &self.inner_values_buffer[range];\n+        for &v in values {\n+            f(v)\n         }\n     }\n }\n@@ -909,9 +961,7 @@ pub enum ValueOrPlace<V> {\n }\n \n impl<V: HasTop> ValueOrPlace<V> {\n-    pub fn top() -> Self {\n-        ValueOrPlace::Value(V::top())\n-    }\n+    pub const TOP: Self = ValueOrPlace::Value(V::TOP);\n }\n \n /// The set of projection elements that can be used by a tracked place."}, {"sha": "7adfc9dff2ae9f5bb93474d6e28cfe5b53cedc86", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -79,22 +79,22 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n         &self.map\n     }\n \n-    fn handle_statement(&self, statement: &Statement<'tcx>, state: &mut State<Self::Value>) {\n-        match statement.kind {\n-            StatementKind::SetDiscriminant { box ref place, variant_index } => {\n-                state.flood_discr(place.as_ref(), &self.map);\n-                if self.map.find_discr(place.as_ref()).is_some() {\n-                    let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n-                    if let Some(discr) = self.eval_discriminant(enum_ty, variant_index) {\n-                        state.assign_discr(\n-                            place.as_ref(),\n-                            ValueOrPlace::Value(FlatSet::Elem(discr)),\n-                            &self.map,\n-                        );\n-                    }\n-                }\n+    fn handle_set_discriminant(\n+        &self,\n+        place: Place<'tcx>,\n+        variant_index: VariantIdx,\n+        state: &mut State<Self::Value>,\n+    ) {\n+        state.flood_discr(place.as_ref(), &self.map);\n+        if self.map.find_discr(place.as_ref()).is_some() {\n+            let enum_ty = place.ty(self.local_decls, self.tcx).ty;\n+            if let Some(discr) = self.eval_discriminant(enum_ty, variant_index) {\n+                state.assign_discr(\n+                    place.as_ref(),\n+                    ValueOrPlace::Value(FlatSet::Elem(discr)),\n+                    &self.map,\n+                );\n             }\n-            _ => self.super_statement(statement, state),\n         }\n     }\n \n@@ -208,8 +208,8 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'_, 'tcx> {\n                     _ => unreachable!(),\n                 }\n                 .map(|result| ValueOrPlace::Value(self.wrap_immediate(result, *ty)))\n-                .unwrap_or(ValueOrPlace::top()),\n-                _ => ValueOrPlace::top(),\n+                .unwrap_or(ValueOrPlace::TOP),\n+                _ => ValueOrPlace::TOP,\n             },\n             Rvalue::BinaryOp(op, box (left, right)) => {\n                 // Overflows must be ignored here."}, {"sha": "d1bc9ee91538e6ef58953f8f43b14ac21d4881f7", "filename": "compiler/rustc_mir_transform/src/ref_prop.rs", "status": "modified", "additions": 60, "deletions": 30, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fref_prop.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -85,7 +85,9 @@ fn propagate_ssa<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     let ssa = SsaLocals::new(body);\n \n     let mut replacer = compute_replacement(tcx, body, &ssa);\n-    debug!(?replacer.targets, ?replacer.allowed_replacements, ?replacer.storage_to_remove);\n+    debug!(?replacer.targets);\n+    debug!(?replacer.allowed_replacements);\n+    debug!(?replacer.storage_to_remove);\n \n     replacer.visit_body_preserves_cfg(body);\n \n@@ -190,8 +192,11 @@ fn compute_replacement<'tcx>(\n             continue;\n         }\n \n+        // Whether the current local is subject to the uniqueness rule.\n+        let needs_unique = ty.is_mutable_ptr();\n+\n         // If this a mutable reference that we cannot fully replace, mark it as unknown.\n-        if ty.is_mutable_ptr() && !fully_replacable_locals.contains(local) {\n+        if needs_unique && !fully_replacable_locals.contains(local) {\n             debug!(\"not fully replaceable\");\n             continue;\n         }\n@@ -203,32 +208,33 @@ fn compute_replacement<'tcx>(\n             // have been visited before.\n             Rvalue::Use(Operand::Copy(place) | Operand::Move(place))\n             | Rvalue::CopyForDeref(place) => {\n-                if let Some(rhs) = place.as_local() {\n+                if let Some(rhs) = place.as_local() && ssa.is_ssa(rhs) {\n                     let target = targets[rhs];\n-                    if matches!(target, Value::Pointer(..)) {\n+                    // Only see through immutable reference and pointers, as we do not know yet if\n+                    // mutable references are fully replaced.\n+                    if !needs_unique && matches!(target, Value::Pointer(..)) {\n                         targets[local] = target;\n-                    } else if ssa.is_ssa(rhs) {\n-                        let refmut = body.local_decls[rhs].ty.is_mutable_ptr();\n-                        targets[local] = Value::Pointer(tcx.mk_place_deref(rhs.into()), refmut);\n+                    } else {\n+                        targets[local] = Value::Pointer(tcx.mk_place_deref(rhs.into()), needs_unique);\n                     }\n                 }\n             }\n             Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n                 let mut place = *place;\n                 // Try to see through `place` in order to collapse reborrow chains.\n                 if place.projection.first() == Some(&PlaceElem::Deref)\n-                    && let Value::Pointer(target, refmut) = targets[place.local]\n+                    && let Value::Pointer(target, inner_needs_unique) = targets[place.local]\n                     // Only see through immutable reference and pointers, as we do not know yet if\n                     // mutable references are fully replaced.\n-                    && !refmut\n+                    && !inner_needs_unique\n                     // Only collapse chain if the pointee is definitely live.\n                     && can_perform_opt(target, location)\n                 {\n                     place = target.project_deeper(&place.projection[1..], tcx);\n                 }\n                 assert_ne!(place.local, local);\n                 if is_constant_place(place) {\n-                    targets[local] = Value::Pointer(place, ty.is_mutable_ptr());\n+                    targets[local] = Value::Pointer(place, needs_unique);\n                 }\n             }\n             // We do not know what to do, so keep as not-a-pointer.\n@@ -276,16 +282,35 @@ fn compute_replacement<'tcx>(\n                 return;\n             }\n \n-            if let Value::Pointer(target, refmut) = self.targets[place.local]\n-                && place.projection.first() == Some(&PlaceElem::Deref)\n-            {\n-                let perform_opt = (self.can_perform_opt)(target, loc);\n-                if perform_opt {\n-                    self.allowed_replacements.insert((target.local, loc));\n-                } else if refmut {\n-                    // This mutable reference is not fully replacable, so drop it.\n-                    self.targets[place.local] = Value::Unknown;\n+            if place.projection.first() != Some(&PlaceElem::Deref) {\n+                // This is not a dereference, nothing to do.\n+                return;\n+            }\n+\n+            let mut place = place.as_ref();\n+            loop {\n+                if let Value::Pointer(target, needs_unique) = self.targets[place.local] {\n+                    let perform_opt = (self.can_perform_opt)(target, loc);\n+                    debug!(?place, ?target, ?needs_unique, ?perform_opt);\n+\n+                    // This a reborrow chain, recursively allow the replacement.\n+                    //\n+                    // This also allows to detect cases where `target.local` is not replacable,\n+                    // and mark it as such.\n+                    if let &[PlaceElem::Deref] = &target.projection[..] {\n+                        assert!(perform_opt);\n+                        self.allowed_replacements.insert((target.local, loc));\n+                        place.local = target.local;\n+                        continue;\n+                    } else if perform_opt {\n+                        self.allowed_replacements.insert((target.local, loc));\n+                    } else if needs_unique {\n+                        // This mutable reference is not fully replacable, so drop it.\n+                        self.targets[place.local] = Value::Unknown;\n+                    }\n                 }\n+\n+                break;\n             }\n         }\n     }\n@@ -326,18 +351,23 @@ impl<'tcx> MutVisitor<'tcx> for Replacer<'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, ctxt: PlaceContext, loc: Location) {\n-        if let Value::Pointer(target, _) = self.targets[place.local]\n-            && place.projection.first() == Some(&PlaceElem::Deref)\n-        {\n-            let perform_opt = matches!(ctxt, PlaceContext::NonUse(_))\n-                || self.allowed_replacements.contains(&(target.local, loc));\n-\n-            if perform_opt {\n-                *place = target.project_deeper(&place.projection[1..], self.tcx);\n-                self.any_replacement = true;\n+        if place.projection.first() != Some(&PlaceElem::Deref) {\n+            return;\n+        }\n+\n+        loop {\n+            if let Value::Pointer(target, _) = self.targets[place.local] {\n+                let perform_opt = matches!(ctxt, PlaceContext::NonUse(_))\n+                    || self.allowed_replacements.contains(&(target.local, loc));\n+\n+                if perform_opt {\n+                    *place = target.project_deeper(&place.projection[1..], self.tcx);\n+                    self.any_replacement = true;\n+                    continue;\n+                }\n             }\n-        } else {\n-            self.super_place(place, ctxt, loc);\n+\n+            break;\n         }\n     }\n "}, {"sha": "a7b453666622a24ded2f9289fd49118b3d25f835", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -209,13 +209,6 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n         match ctxt {\n             PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             | PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) => bug!(),\n-            PlaceContext::MutatingUse(MutatingUseContext::Store) => {\n-                self.assignments[local].insert(LocationExtended::Plain(loc));\n-                if let Set1::One(_) = self.assignments[local] {\n-                    // Only record if SSA-like, to avoid growing the vector needlessly.\n-                    self.assignment_order.push(local);\n-                }\n-            }\n             // Anything can happen with raw pointers, so remove them.\n             // We do not verify that all uses of the borrow dominate the assignment to `local`,\n             // so we have to remove them too.\n@@ -252,6 +245,19 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n             self.visit_local(place.local, ctxt, loc);\n         }\n     }\n+\n+    fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, loc: Location) {\n+        if let Some(local) = place.as_local() {\n+            self.assignments[local].insert(LocationExtended::Plain(loc));\n+            if let Set1::One(_) = self.assignments[local] {\n+                // Only record if SSA-like, to avoid growing the vector needlessly.\n+                self.assignment_order.push(local);\n+            }\n+        } else {\n+            self.visit_place(place, PlaceContext::MutatingUse(MutatingUseContext::Store), loc);\n+        }\n+        self.visit_rvalue(rvalue, loc);\n+    }\n }\n \n #[instrument(level = \"trace\", skip(ssa, body))]"}, {"sha": "345255c4c693531cddb90e5472475c5f323444bb", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -199,6 +199,10 @@ resolve_invalid_asm_sym =\n     .label = is a local variable\n     .help = `sym` operands must refer to either a function or a static\n \n+resolve_lowercase_self =\n+    attempt to use a non-constant value in a constant\n+    .suggestion = try using `Self`\n+\n resolve_trait_impl_duplicate =\n     duplicate definitions with name `{$name}`:\n     .label = duplicate definition"}, {"sha": "6675b8ed59b268cafac42a813ba3a57e757119c8", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -948,6 +948,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ResolutionError::InvalidAsmSym => {\n                 self.tcx.sess.create_err(errs::InvalidAsmSym { span })\n             }\n+            ResolutionError::LowercaseSelf => {\n+                self.tcx.sess.create_err(errs::LowercaseSelf { span })\n+            }\n         }\n     }\n "}, {"sha": "2ab55f12637c84dfa0e2be7f203bbe5012aef751", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -442,6 +442,14 @@ pub(crate) struct InvalidAsmSym {\n     pub(crate) span: Span,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(resolve_lowercase_self)]\n+pub(crate) struct LowercaseSelf {\n+    #[primary_span]\n+    #[suggestion(code = \"Self\", applicability = \"maybe-incorrect\", style = \"short\")]\n+    pub(crate) span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(resolve_trait_impl_duplicate, code = \"E0201\")]\n pub(crate) struct TraitImplDuplicate {"}, {"sha": "755acdd81fe5cb725b1ecd1d964e1318f6162239", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -15,8 +15,7 @@ use std::ptr;\n \n use crate::errors::{ParamKindInEnumDiscriminant, ParamKindInNonTrivialAnonConst};\n use crate::late::{\n-    ConstantHasGenerics, ConstantItemKind, HasGenericParams, NoConstantGenericsReason, PathSource,\n-    Rib, RibKind,\n+    ConstantHasGenerics, HasGenericParams, NoConstantGenericsReason, PathSource, Rib, RibKind,\n };\n use crate::macros::{sub_namespace_match, MacroRulesScope};\n use crate::{errors, AmbiguityError, AmbiguityErrorMisc, AmbiguityKind, Determinacy, Finalize};\n@@ -1127,28 +1126,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         RibKind::ConstantItem(_, item) => {\n                             // Still doesn't deal with upvars\n                             if let Some(span) = finalize {\n-                                let (span, resolution_error) =\n-                                    if let Some((ident, constant_item_kind)) = item {\n-                                        let kind_str = match constant_item_kind {\n-                                            ConstantItemKind::Const => \"const\",\n-                                            ConstantItemKind::Static => \"static\",\n-                                        };\n-                                        (\n-                                            span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                ident, \"let\", kind_str,\n-                                            ),\n-                                        )\n-                                    } else {\n-                                        (\n-                                            rib_ident.span,\n-                                            AttemptToUseNonConstantValueInConstant(\n-                                                original_rib_ident_def,\n-                                                \"const\",\n-                                                \"let\",\n-                                            ),\n-                                        )\n-                                    };\n+                                let (span, resolution_error) = match item {\n+                                    None if rib_ident.as_str() == \"self\" => (span, LowercaseSelf),\n+                                    None => (\n+                                        rib_ident.span,\n+                                        AttemptToUseNonConstantValueInConstant(\n+                                            original_rib_ident_def,\n+                                            \"const\",\n+                                            \"let\",\n+                                        ),\n+                                    ),\n+                                    Some((ident, kind)) => (\n+                                        span,\n+                                        AttemptToUseNonConstantValueInConstant(\n+                                            ident,\n+                                            \"let\",\n+                                            kind.as_str(),\n+                                        ),\n+                                    ),\n+                                };\n                                 self.report_error(span, resolution_error);\n                             }\n                             return Res::Err;"}, {"sha": "44e277c99b96fbefcd342ab16bf8c436a3029215", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -150,6 +150,15 @@ pub(crate) enum ConstantItemKind {\n     Static,\n }\n \n+impl ConstantItemKind {\n+    pub(crate) fn as_str(&self) -> &'static str {\n+        match self {\n+            Self::Const => \"const\",\n+            Self::Static => \"static\",\n+        }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n enum RecordPartialRes {\n     Yes,\n@@ -1482,7 +1491,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             if let Some(&(_, res)) = rib.bindings.get(&normalized_ident) {\n                 self.record_lifetime_res(lifetime.id, res, LifetimeElisionCandidate::Named);\n \n-                if let LifetimeRes::Param { param, .. } = res {\n+                if let LifetimeRes::Param { param, binder } = res {\n                     match self.lifetime_uses.entry(param) {\n                         Entry::Vacant(v) => {\n                             debug!(\"First use of {:?} at {:?}\", res, ident.span);\n@@ -1496,10 +1505,16 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                                     LifetimeRibKind::Item\n                                     | LifetimeRibKind::AnonymousReportError\n                                     | LifetimeRibKind::ElisionFailure => Some(LifetimeUseSet::Many),\n-                                    // An anonymous lifetime is legal here, go ahead.\n-                                    LifetimeRibKind::AnonymousCreateParameter { .. } => {\n-                                        Some(LifetimeUseSet::One { use_span: ident.span, use_ctxt })\n-                                    }\n+                                    // An anonymous lifetime is legal here, and bound to the right\n+                                    // place, go ahead.\n+                                    LifetimeRibKind::AnonymousCreateParameter {\n+                                        binder: anon_binder,\n+                                        ..\n+                                    } => Some(if binder == anon_binder {\n+                                        LifetimeUseSet::One { use_span: ident.span, use_ctxt }\n+                                    } else {\n+                                        LifetimeUseSet::Many\n+                                    }),\n                                     // Only report if eliding the lifetime would have the same\n                                     // semantics.\n                                     LifetimeRibKind::Elided(r) => Some(if res == r {"}, {"sha": "c12dc2f5d92a545bfe95c0c895659c4fa726611b", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -251,6 +251,8 @@ enum ResolutionError<'a> {\n     TraitImplDuplicate { name: Symbol, trait_item_span: Span, old_span: Span },\n     /// Inline asm `sym` operand must refer to a `fn` or `static`.\n     InvalidAsmSym,\n+    /// `self` used instead of `Self` in a generic parameter\n+    LowercaseSelf,\n }\n \n enum VisResolutionError<'a> {"}, {"sha": "3af83aaaaa8a22a9947f66d334b9e492fa07c1ed", "filename": "compiler/rustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -25,7 +25,7 @@ termize = \"0.1.1\"\n libc = \"0.2\"\n \n [target.'cfg(windows)'.dependencies.windows]\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n features = [\n     \"Win32_Foundation\",\n     \"Win32_System_LibraryLoader\","}, {"sha": "3988416d0c795c24a3bc0ca0445cd68fc9c61459", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -135,13 +135,13 @@ fn current_dll_path() -> Result<PathBuf, String> {\n \n     use windows::{\n         core::PCWSTR,\n-        Win32::Foundation::HINSTANCE,\n+        Win32::Foundation::HMODULE,\n         Win32::System::LibraryLoader::{\n             GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n         },\n     };\n \n-    let mut module = HINSTANCE::default();\n+    let mut module = HMODULE::default();\n     unsafe {\n         GetModuleHandleExW(\n             GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,"}, {"sha": "5976b9aa3e74a168b8f8629e069dd7733a4735dd", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1720,6 +1720,10 @@ options! {\n     #[rustc_lint_opt_deny_field_access(\"use `Session::stack_protector` instead of this field\")]\n     stack_protector: StackProtector = (StackProtector::None, parse_stack_protector, [TRACKED],\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n+    staticlib_allow_rdylib_deps: bool = (false, parse_bool, [TRACKED],\n+        \"allow staticlibs to have rust dylib dependencies\"),\n+    staticlib_prefer_dynamic: bool = (false, parse_bool, [TRACKED],\n+        \"prefer dynamic linking to static linking for staticlibs (default: no)\"),\n     strict_init_checks: bool = (false, parse_bool, [TRACKED],\n         \"control if mem::uninitialized and mem::zeroed panic on more UB\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],"}, {"sha": "b00f0a1c1531236a409c8bfe4eff24ab4f64a7cd", "filename": "compiler/rustc_smir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Flib.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -11,6 +11,8 @@\n     test(attr(allow(unused_variables), deny(warnings)))\n )]\n #![cfg_attr(not(feature = \"default\"), feature(rustc_private))]\n+#![feature(local_key_cell_methods)]\n+#![feature(ptr_metadata)]\n \n pub mod rustc_internal;\n pub mod stable_mir;"}, {"sha": "609a04d263c961eabe7092aba59bd1b66544668a", "filename": "compiler/rustc_smir/src/rustc_internal/mod.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_internal%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -3,30 +3,49 @@\n //! For that, we define APIs that will temporarily be public to 3P that exposes rustc internal APIs\n //! until stable MIR is complete.\n \n-use std::sync::RwLock;\n-\n-use crate::stable_mir;\n+use crate::{\n+    rustc_smir::Tables,\n+    stable_mir::{self, with},\n+};\n+use rustc_middle::ty::TyCtxt;\n pub use rustc_span::def_id::{CrateNum, DefId};\n \n-static DEF_ID_MAP: RwLock<Vec<DefId>> = RwLock::new(Vec::new());\n+fn with_tables<R>(mut f: impl FnMut(&mut Tables<'_>) -> R) -> R {\n+    let mut ret = None;\n+    with(|tables| tables.rustc_tables(&mut |t| ret = Some(f(t))));\n+    ret.unwrap()\n+}\n \n pub fn item_def_id(item: &stable_mir::CrateItem) -> DefId {\n-    DEF_ID_MAP.read().unwrap()[item.0]\n+    with_tables(|t| t.item_def_id(item))\n }\n \n pub fn crate_item(did: DefId) -> stable_mir::CrateItem {\n-    // FIXME: this becomes inefficient when we have too many ids\n-    let mut map = DEF_ID_MAP.write().unwrap();\n-    for (i, &d) in map.iter().enumerate() {\n-        if d == did {\n-            return stable_mir::CrateItem(i);\n+    with_tables(|t| t.crate_item(did))\n+}\n+\n+impl<'tcx> Tables<'tcx> {\n+    pub fn item_def_id(&self, item: &stable_mir::CrateItem) -> DefId {\n+        self.def_ids[item.0]\n+    }\n+\n+    pub fn crate_item(&mut self, did: DefId) -> stable_mir::CrateItem {\n+        // FIXME: this becomes inefficient when we have too many ids\n+        for (i, &d) in self.def_ids.iter().enumerate() {\n+            if d == did {\n+                return stable_mir::CrateItem(i);\n+            }\n         }\n+        let id = self.def_ids.len();\n+        self.def_ids.push(did);\n+        stable_mir::CrateItem(id)\n     }\n-    let id = map.len();\n-    map.push(did);\n-    stable_mir::CrateItem(id)\n }\n \n pub fn crate_num(item: &stable_mir::Crate) -> CrateNum {\n     item.id.into()\n }\n+\n+pub fn run(tcx: TyCtxt<'_>, f: impl FnOnce()) {\n+    crate::stable_mir::run(Tables { tcx, def_ids: vec![], types: vec![] }, f);\n+}"}, {"sha": "6af43f5d3f358fe73aed0a4fa5cf913c1d20b30f", "filename": "compiler/rustc_smir/src/rustc_smir/mod.rs", "status": "modified", "additions": 92, "deletions": 43, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Frustc_smir%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -7,41 +7,107 @@\n //!\n //! For now, we are developing everything inside `rustc`, thus, we keep this module private.\n \n-use crate::{\n-    rustc_internal::{crate_item, item_def_id},\n-    stable_mir::{self},\n-};\n-use rustc_middle::ty::{tls::with, TyCtxt};\n-use rustc_span::def_id::{CrateNum, LOCAL_CRATE};\n+use crate::stable_mir::{self, ty::TyKind, Context};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use tracing::debug;\n \n-/// Get information about the local crate.\n-pub fn local_crate() -> stable_mir::Crate {\n-    with(|tcx| smir_crate(tcx, LOCAL_CRATE))\n-}\n+impl<'tcx> Context for Tables<'tcx> {\n+    fn local_crate(&self) -> stable_mir::Crate {\n+        smir_crate(self.tcx, LOCAL_CRATE)\n+    }\n \n-/// Retrieve a list of all external crates.\n-pub fn external_crates() -> Vec<stable_mir::Crate> {\n-    with(|tcx| tcx.crates(()).iter().map(|crate_num| smir_crate(tcx, *crate_num)).collect())\n-}\n+    fn external_crates(&self) -> Vec<stable_mir::Crate> {\n+        self.tcx.crates(()).iter().map(|crate_num| smir_crate(self.tcx, *crate_num)).collect()\n+    }\n \n-/// Find a crate with the given name.\n-pub fn find_crate(name: &str) -> Option<stable_mir::Crate> {\n-    with(|tcx| {\n-        [LOCAL_CRATE].iter().chain(tcx.crates(()).iter()).find_map(|crate_num| {\n-            let crate_name = tcx.crate_name(*crate_num).to_string();\n-            (name == crate_name).then(|| smir_crate(tcx, *crate_num))\n+    fn find_crate(&self, name: &str) -> Option<stable_mir::Crate> {\n+        [LOCAL_CRATE].iter().chain(self.tcx.crates(()).iter()).find_map(|crate_num| {\n+            let crate_name = self.tcx.crate_name(*crate_num).to_string();\n+            (name == crate_name).then(|| smir_crate(self.tcx, *crate_num))\n         })\n-    })\n+    }\n+\n+    fn all_local_items(&mut self) -> stable_mir::CrateItems {\n+        self.tcx.mir_keys(()).iter().map(|item| self.crate_item(item.to_def_id())).collect()\n+    }\n+    fn entry_fn(&mut self) -> Option<stable_mir::CrateItem> {\n+        Some(self.crate_item(self.tcx.entry_fn(())?.0))\n+    }\n+    fn mir_body(&mut self, item: &stable_mir::CrateItem) -> stable_mir::mir::Body {\n+        let def_id = self.item_def_id(item);\n+        let mir = self.tcx.optimized_mir(def_id);\n+        stable_mir::mir::Body {\n+            blocks: mir\n+                .basic_blocks\n+                .iter()\n+                .map(|block| stable_mir::mir::BasicBlock {\n+                    terminator: rustc_terminator_to_terminator(block.terminator()),\n+                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n+                })\n+                .collect(),\n+            locals: mir.local_decls.iter().map(|decl| self.intern_ty(decl.ty)).collect(),\n+        }\n+    }\n+\n+    fn rustc_tables(&mut self, f: &mut dyn FnMut(&mut Tables<'_>)) {\n+        f(self)\n+    }\n+\n+    fn ty_kind(&mut self, ty: crate::stable_mir::ty::Ty) -> TyKind {\n+        self.rustc_ty_to_ty(self.types[ty.0])\n+    }\n }\n \n-/// Retrieve all items of the local crate that have a MIR associated with them.\n-pub fn all_local_items() -> stable_mir::CrateItems {\n-    with(|tcx| tcx.mir_keys(()).iter().map(|item| crate_item(item.to_def_id())).collect())\n+pub struct Tables<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub def_ids: Vec<DefId>,\n+    pub types: Vec<Ty<'tcx>>,\n }\n \n-pub fn entry_fn() -> Option<stable_mir::CrateItem> {\n-    with(|tcx| Some(crate_item(tcx.entry_fn(())?.0)))\n+impl<'tcx> Tables<'tcx> {\n+    fn rustc_ty_to_ty(&mut self, ty: Ty<'tcx>) -> TyKind {\n+        match ty.kind() {\n+            ty::Bool => TyKind::Bool,\n+            ty::Char => todo!(),\n+            ty::Int(_) => todo!(),\n+            ty::Uint(_) => todo!(),\n+            ty::Float(_) => todo!(),\n+            ty::Adt(_, _) => todo!(),\n+            ty::Foreign(_) => todo!(),\n+            ty::Str => todo!(),\n+            ty::Array(_, _) => todo!(),\n+            ty::Slice(_) => todo!(),\n+            ty::RawPtr(_) => todo!(),\n+            ty::Ref(_, _, _) => todo!(),\n+            ty::FnDef(_, _) => todo!(),\n+            ty::FnPtr(_) => todo!(),\n+            ty::Placeholder(..) => todo!(),\n+            ty::Dynamic(_, _, _) => todo!(),\n+            ty::Closure(_, _) => todo!(),\n+            ty::Generator(_, _, _) => todo!(),\n+            ty::GeneratorWitness(_) => todo!(),\n+            ty::GeneratorWitnessMIR(_, _) => todo!(),\n+            ty::Never => todo!(),\n+            ty::Tuple(fields) => {\n+                TyKind::Tuple(fields.iter().map(|ty| self.intern_ty(ty)).collect())\n+            }\n+            ty::Alias(_, _) => todo!(),\n+            ty::Param(_) => todo!(),\n+            ty::Bound(_, _) => todo!(),\n+            ty::Infer(_) => todo!(),\n+            ty::Error(_) => todo!(),\n+        }\n+    }\n+\n+    fn intern_ty(&mut self, ty: Ty<'tcx>) -> stable_mir::ty::Ty {\n+        if let Some(id) = self.types.iter().position(|&t| t == ty) {\n+            return stable_mir::ty::Ty(id);\n+        }\n+        let id = self.types.len();\n+        self.types.push(ty);\n+        stable_mir::ty::Ty(id)\n+    }\n }\n \n /// Build a stable mir crate from a given crate number.\n@@ -52,23 +118,6 @@ fn smir_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> stable_mir::Crate {\n     stable_mir::Crate { id: crate_num.into(), name: crate_name, is_local }\n }\n \n-pub fn mir_body(item: &stable_mir::CrateItem) -> stable_mir::mir::Body {\n-    with(|tcx| {\n-        let def_id = item_def_id(item);\n-        let mir = tcx.optimized_mir(def_id);\n-        stable_mir::mir::Body {\n-            blocks: mir\n-                .basic_blocks\n-                .iter()\n-                .map(|block| stable_mir::mir::BasicBlock {\n-                    terminator: rustc_terminator_to_terminator(block.terminator()),\n-                    statements: block.statements.iter().map(rustc_statement_to_statement).collect(),\n-                })\n-                .collect(),\n-        }\n-    })\n-}\n-\n fn rustc_statement_to_statement(\n     s: &rustc_middle::mir::Statement<'_>,\n ) -> stable_mir::mir::Statement {"}, {"sha": "6328c35aa5982f563e4c4e127a20ddd35f214228", "filename": "compiler/rustc_smir/src/stable_mir/mir/body.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmir%2Fbody.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,6 +1,9 @@\n+use crate::stable_mir::ty::Ty;\n+\n #[derive(Clone, Debug)]\n pub struct Body {\n     pub blocks: Vec<BasicBlock>,\n+    pub locals: Vec<Ty>,\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "612777b9c75395d279f91d9e278ff652d548e599", "filename": "compiler/rustc_smir/src/stable_mir/mod.rs", "status": "modified", "additions": 60, "deletions": 6, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -11,7 +11,14 @@\n //! There shouldn't be any direct references to internal compiler constructs in this module.\n //! If you need an internal construct, consider using `rustc_internal` or `rustc_smir`.\n \n+use std::cell::Cell;\n+\n+use crate::rustc_smir::Tables;\n+\n+use self::ty::{Ty, TyKind};\n+\n pub mod mir;\n+pub mod ty;\n \n /// Use String for now but we should replace it.\n pub type Symbol = String;\n@@ -41,33 +48,80 @@ pub struct CrateItem(pub(crate) DefId);\n \n impl CrateItem {\n     pub fn body(&self) -> mir::Body {\n-        crate::rustc_smir::mir_body(self)\n+        with(|cx| cx.mir_body(self))\n     }\n }\n \n /// Return the function where execution starts if the current\n /// crate defines that. This is usually `main`, but could be\n /// `start` if the crate is a no-std crate.\n pub fn entry_fn() -> Option<CrateItem> {\n-    crate::rustc_smir::entry_fn()\n+    with(|cx| cx.entry_fn())\n }\n \n /// Access to the local crate.\n pub fn local_crate() -> Crate {\n-    crate::rustc_smir::local_crate()\n+    with(|cx| cx.local_crate())\n }\n \n /// Try to find a crate with the given name.\n pub fn find_crate(name: &str) -> Option<Crate> {\n-    crate::rustc_smir::find_crate(name)\n+    with(|cx| cx.find_crate(name))\n }\n \n /// Try to find a crate with the given name.\n pub fn external_crates() -> Vec<Crate> {\n-    crate::rustc_smir::external_crates()\n+    with(|cx| cx.external_crates())\n }\n \n /// Retrieve all items in the local crate that have a MIR associated with them.\n pub fn all_local_items() -> CrateItems {\n-    crate::rustc_smir::all_local_items()\n+    with(|cx| cx.all_local_items())\n+}\n+\n+pub trait Context {\n+    fn entry_fn(&mut self) -> Option<CrateItem>;\n+    /// Retrieve all items of the local crate that have a MIR associated with them.\n+    fn all_local_items(&mut self) -> CrateItems;\n+    fn mir_body(&mut self, item: &CrateItem) -> mir::Body;\n+    /// Get information about the local crate.\n+    fn local_crate(&self) -> Crate;\n+    /// Retrieve a list of all external crates.\n+    fn external_crates(&self) -> Vec<Crate>;\n+\n+    /// Find a crate with the given name.\n+    fn find_crate(&self, name: &str) -> Option<Crate>;\n+\n+    /// Obtain the representation of a type.\n+    fn ty_kind(&mut self, ty: Ty) -> TyKind;\n+\n+    /// HACK: Until we have fully stable consumers, we need an escape hatch\n+    /// to get `DefId`s out of `CrateItem`s.\n+    fn rustc_tables(&mut self, f: &mut dyn FnMut(&mut Tables<'_>));\n+}\n+\n+thread_local! {\n+    /// A thread local variable that stores a pointer to the tables mapping between TyCtxt\n+    /// datastructures and stable MIR datastructures.\n+    static TLV: Cell<*mut ()> = const { Cell::new(std::ptr::null_mut()) };\n+}\n+\n+pub fn run(mut context: impl Context, f: impl FnOnce()) {\n+    assert!(TLV.get().is_null());\n+    fn g<'a>(mut context: &mut (dyn Context + 'a), f: impl FnOnce()) {\n+        TLV.set(&mut context as *mut &mut _ as _);\n+        f();\n+        TLV.replace(std::ptr::null_mut());\n+    }\n+    g(&mut context, f);\n+}\n+\n+/// Loads the current context and calls a function with it.\n+/// Do not nest these, as that will ICE.\n+pub(crate) fn with<R>(f: impl FnOnce(&mut dyn Context) -> R) -> R {\n+    let ptr = TLV.replace(std::ptr::null_mut()) as *mut &mut dyn Context;\n+    assert!(!ptr.is_null());\n+    let ret = f(unsafe { *ptr });\n+    TLV.set(ptr as _);\n+    ret\n }"}, {"sha": "f27801b0f6caec31947c984b6ca4f3575057b736", "filename": "compiler/rustc_smir/src/stable_mir/ty.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_smir%2Fsrc%2Fstable_mir%2Fty.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,15 @@\n+use super::with;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct Ty(pub usize);\n+\n+impl Ty {\n+    pub fn kind(&self) -> TyKind {\n+        with(|context| context.ty_kind(*self))\n+    }\n+}\n+\n+pub enum TyKind {\n+    Bool,\n+    Tuple(Vec<Ty>),\n+}"}, {"sha": "cda16e3a3f5661879b8edafa4490873c28c4e344", "filename": "compiler/rustc_symbol_mangling/src/typeid.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -4,7 +4,7 @@\n /// For more information about LLVM CFI and cross-language LLVM CFI support for the Rust compiler,\n /// see design document in the tracking issue #89653.\n use bitflags::bitflags;\n-use rustc_middle::ty::{FnSig, Ty, TyCtxt};\n+use rustc_middle::ty::{FnSig, Instance, Ty, TyCtxt};\n use rustc_target::abi::call::FnAbi;\n use std::hash::Hasher;\n use twox_hash::XxHash64;\n@@ -38,6 +38,15 @@ pub fn typeid_for_fnsig<'tcx>(\n     typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, options)\n }\n \n+/// Returns a type metadata identifier for the specified Instance.\n+pub fn typeid_for_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: &Instance<'tcx>,\n+    options: TypeIdOptions,\n+) -> String {\n+    typeid_itanium_cxx_abi::typeid_for_instance(tcx, instance, options)\n+}\n+\n /// Returns a KCFI type metadata identifier for the specified FnAbi.\n pub fn kcfi_typeid_for_fnabi<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -63,3 +72,16 @@ pub fn kcfi_typeid_for_fnsig<'tcx>(\n     hash.write(typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, options).as_bytes());\n     hash.finish() as u32\n }\n+\n+/// Returns a KCFI type metadata identifier for the specified Instance.\n+pub fn kcfi_typeid_for_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: &Instance<'tcx>,\n+    options: TypeIdOptions,\n+) -> u32 {\n+    // A KCFI type metadata identifier is a 32-bit constant produced by taking the lower half of the\n+    // xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+    let mut hash: XxHash64 = Default::default();\n+    hash.write(typeid_itanium_cxx_abi::typeid_for_instance(tcx, instance, options).as_bytes());\n+    hash.finish() as u32\n+}"}, {"sha": "c281aa7e83a85d80140cf79e57df2ff70565a3ee", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -14,8 +14,8 @@ use rustc_errors::DiagnosticMessage;\n use rustc_hir as hir;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    self, Const, ExistentialPredicate, FloatTy, FnSig, IntTy, List, Region, RegionKind, TermKind,\n-    Ty, TyCtxt, UintTy,\n+    self, Const, ExistentialPredicate, FloatTy, FnSig, Instance, IntTy, List, Region, RegionKind,\n+    TermKind, Ty, TyCtxt, UintTy,\n };\n use rustc_span::def_id::DefId;\n use rustc_span::sym;\n@@ -1010,3 +1010,56 @@ pub fn typeid_for_fnsig<'tcx>(\n \n     typeid\n }\n+\n+/// Returns a type metadata identifier for the specified Instance using the Itanium C++ ABI with\n+/// vendor extended type qualifiers and types for Rust types that are not used at the FFI boundary.\n+pub fn typeid_for_instance<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance: &Instance<'tcx>,\n+    options: TypeIdOptions,\n+) -> String {\n+    let fn_abi = tcx\n+        .fn_abi_of_instance(tcx.param_env(instance.def_id()).and((*instance, ty::List::empty())))\n+        .unwrap_or_else(|instance| {\n+            bug!(\"typeid_for_instance: couldn't get fn_abi of instance {:?}\", instance)\n+        });\n+\n+    // If this instance is a method and self is a reference, get the impl it belongs to\n+    let impl_def_id = tcx.impl_of_method(instance.def_id());\n+    if impl_def_id.is_some() && !fn_abi.args.is_empty() && fn_abi.args[0].layout.ty.is_ref() {\n+        // If this impl is not an inherent impl, get the trait it implements\n+        if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id.unwrap()) {\n+            // Transform the concrete self into a reference to a trait object\n+            let existential_predicate = trait_ref.map_bound(|trait_ref| {\n+                ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n+                    tcx, trait_ref,\n+                ))\n+            });\n+            let existential_predicates = tcx.mk_poly_existential_predicates(&[ty::Binder::dummy(\n+                existential_predicate.skip_binder(),\n+            )]);\n+            // Is the concrete self mutable?\n+            let self_ty = if fn_abi.args[0].layout.ty.is_mutable_ptr() {\n+                tcx.mk_mut_ref(\n+                    tcx.lifetimes.re_erased,\n+                    tcx.mk_dynamic(existential_predicates, tcx.lifetimes.re_erased, ty::Dyn),\n+                )\n+            } else {\n+                tcx.mk_imm_ref(\n+                    tcx.lifetimes.re_erased,\n+                    tcx.mk_dynamic(existential_predicates, tcx.lifetimes.re_erased, ty::Dyn),\n+                )\n+            };\n+\n+            // Replace the concrete self in an fn_abi clone by the reference to a trait object\n+            let mut fn_abi = fn_abi.clone();\n+            // HACK(rcvalle): It is okay to not replace or update the entire ArgAbi here because the\n+            //   other fields are never used.\n+            fn_abi.args[0].layout.ty = self_ty;\n+\n+            return typeid_for_fnabi(tcx, &fn_abi, options);\n+        }\n+    }\n+\n+    typeid_for_fnabi(tcx, &fn_abi, options)\n+}"}, {"sha": "1ae11f5671cd99c02961707b73cf8442a91686ce", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -28,7 +28,7 @@ mod x86;\n mod x86_64;\n mod x86_win64;\n \n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub enum PassMode {\n     /// Ignore the argument.\n     ///\n@@ -211,7 +211,7 @@ impl Uniform {\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct CastTarget {\n     pub prefix: [Option<Reg>; 8],\n     pub rest: Uniform,\n@@ -458,7 +458,7 @@ impl<'a, Ty> TyAndLayout<'a, Ty> {\n \n /// Information about how to pass an argument to,\n /// or return a value from, a function, under some ABI.\n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct ArgAbi<'a, Ty> {\n     pub layout: TyAndLayout<'a, Ty>,\n     pub mode: PassMode,\n@@ -605,7 +605,7 @@ pub enum Conv {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, HashStable_Generic)]\n pub struct FnAbi<'a, Ty> {\n     /// The LLVM types of each argument.\n     pub args: Box<[ArgAbi<'a, Ty>]>,"}, {"sha": "25cc82f01d5535822fc09611e7add79ab26c4a08", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 154, "deletions": 4, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -8,6 +8,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate;\n+use rustc_infer::traits::Reveal;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n@@ -87,7 +88,9 @@ pub(super) enum CandidateSource {\n }\n \n /// Methods used to assemble candidates for either trait or projection goals.\n-pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n+pub(super) trait GoalKind<'tcx>:\n+    TypeFoldable<TyCtxt<'tcx>> + Copy + Eq + std::fmt::Display\n+{\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n@@ -96,6 +99,17 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n+    // Try equating an assumption predicate against a goal's predicate. If it\n+    // holds, then execute the `then` callback, which should do any additional\n+    // work, then produce a response (typically by executing\n+    // [`EvalCtxt::evaluate_added_goals_and_make_canonical_response`]).\n+    fn probe_and_match_goal_against_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n     // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n     // goal by equating it with the assumption.\n@@ -104,7 +118,26 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.add_goals(requirements);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    /// Consider a bound originating from the item bounds of an alias. For this we\n+    /// require that the well-formed requirements of the self type of the goal\n+    /// are \"satisfied from the param-env\".\n+    /// See [`EvalCtxt::validate_alias_bound_self_from_param_env`].\n+    fn consider_alias_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.validate_alias_bound_self_from_param_env(goal)\n+        })\n+    }\n \n     // Consider a clause specifically for a `dyn Trait` self type. This requires\n     // additionally checking all of the supertraits and object bounds to hold,\n@@ -113,7 +146,25 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            let tcx = ecx.tcx();\n+            let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+            ecx.add_goals(\n+                structural_traits::predicates_for_object_candidate(\n+                    &ecx,\n+                    goal.param_env,\n+                    goal.predicate.trait_ref(tcx),\n+                    bounds,\n+                )\n+                .into_iter()\n+                .map(|pred| goal.with(tcx, pred)),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n \n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n@@ -463,7 +514,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_implied_clause(self, goal, assumption, []) {\n+            match G::consider_alias_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -472,6 +523,105 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// Check that we are allowed to use an alias bound originating from the self\n+    /// type of this goal. This means something different depending on the self type's\n+    /// alias kind.\n+    ///\n+    /// * Projection: Given a goal with a self type such as `<Ty as Trait>::Assoc`,\n+    /// we require that the bound `Ty: Trait` can be proven using either a nested alias\n+    /// bound candidate, or a param-env candidate.\n+    ///\n+    /// * Opaque: The param-env must be in `Reveal::UserFacing` mode. Otherwise,\n+    /// the goal should be proven by using the hidden type instead.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn validate_alias_bound_self_from_param_env<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+    ) -> QueryResult<'tcx> {\n+        match *goal.predicate.self_ty().kind() {\n+            ty::Alias(ty::Projection, projection_ty) => {\n+                let mut param_env_candidates = vec![];\n+                let self_trait_ref = projection_ty.trait_ref(self.tcx());\n+\n+                if self_trait_ref.self_ty().is_ty_var() {\n+                    return self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+\n+                let trait_goal: Goal<'_, ty::TraitPredicate<'tcx>> = goal.with(\n+                    self.tcx(),\n+                    ty::TraitPredicate {\n+                        trait_ref: self_trait_ref,\n+                        constness: ty::BoundConstness::NotConst,\n+                        polarity: ty::ImplPolarity::Positive,\n+                    },\n+                );\n+\n+                self.assemble_param_env_candidates(trait_goal, &mut param_env_candidates);\n+                // FIXME: We probably need some sort of recursion depth check here.\n+                // Can't come up with an example yet, though, and the worst case\n+                // we can have is a compiler stack overflow...\n+                self.assemble_alias_bound_candidates(trait_goal, &mut param_env_candidates);\n+\n+                // FIXME: We must also consider alias-bound candidates for a peculiar\n+                // class of built-in candidates that I'll call \"defaulted\" built-ins.\n+                //\n+                // For example, we always know that `T: Pointee` is implemented, but\n+                // we do not always know what `<T as Pointee>::Metadata` actually is,\n+                // similar to if we had a user-defined impl with a `default type ...`.\n+                // For these traits, since we're not able to always normalize their\n+                // associated types to a concrete type, we must consider their alias bounds\n+                // instead, so we can prove bounds such as `<T as Pointee>::Metadata: Copy`.\n+                self.assemble_alias_bound_candidates_for_builtin_impl_default_items(\n+                    trait_goal,\n+                    &mut param_env_candidates,\n+                );\n+\n+                self.merge_candidates(param_env_candidates)\n+            }\n+            ty::Alias(ty::Opaque, _opaque_ty) => match goal.param_env.reveal() {\n+                Reveal::UserFacing => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                Reveal::All => return Err(NoSolution),\n+            },\n+            _ => bug!(\"only expected to be called on alias tys\"),\n+        }\n+    }\n+\n+    /// Assemble a subset of builtin impl candidates for a class of candidates called\n+    /// \"defaulted\" built-in traits.\n+    ///\n+    /// For example, we always know that `T: Pointee` is implemented, but we do not\n+    /// always know what `<T as Pointee>::Metadata` actually is! See the comment in\n+    /// [`EvalCtxt::validate_alias_bound_self_from_param_env`] for more detail.\n+    #[instrument(level = \"debug\", skip_all)]\n+    fn assemble_alias_bound_candidates_for_builtin_impl_default_items<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+\n+        // You probably shouldn't add anything to this list unless you\n+        // know what you're doing.\n+        let result = if lang_items.pointee_trait() == Some(trait_def_id) {\n+            G::consider_builtin_pointee_candidate(self, goal)\n+        } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+            G::consider_builtin_discriminant_kind_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip_all)]\n     fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n         &mut self,"}, {"sha": "20ce2d9416e73eeeb3c30676a74dfc1735d05bcb", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -56,11 +56,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n@@ -75,49 +75,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n                     .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.probe(|ecx| {\n-                let tcx = ecx.tcx();\n-\n-                let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.projection_ty.trait_ref(tcx),\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "dcfa33ae842e9b5f02d14dd9265055cb802bc02b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -78,11 +78,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -97,48 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-            && poly_trait_pred.polarity() == goal.predicate.polarity\n-        {\n-            // FIXME: Constness and polarity\n-            ecx.probe(|ecx| {\n-                let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.trait_ref,\n-                    assumption_trait_pred.trait_ref,\n-                )?;\n-\n-                let tcx = ecx.tcx();\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.trait_ref,\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "9836522392373772620296ecfde82aeb33523220", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -28,6 +28,7 @@ use rustc_hir::{GenericParam, Item, Node};\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n+use rustc_middle::traits::SelectionOutputTypeParameterMismatch;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n@@ -1087,17 +1088,21 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n \n-            OutputTypeParameterMismatch(\n+            OutputTypeParameterMismatch(box SelectionOutputTypeParameterMismatch {\n                 found_trait_ref,\n                 expected_trait_ref,\n-                terr @ TypeError::CyclicTy(_),\n-            ) => self.report_type_parameter_mismatch_cyclic_type_error(\n+                terr: terr @ TypeError::CyclicTy(_),\n+            }) => self.report_type_parameter_mismatch_cyclic_type_error(\n                 &obligation,\n                 found_trait_ref,\n                 expected_trait_ref,\n                 terr,\n             ),\n-            OutputTypeParameterMismatch(found_trait_ref, expected_trait_ref, _) => {\n+            OutputTypeParameterMismatch(box SelectionOutputTypeParameterMismatch {\n+                found_trait_ref,\n+                expected_trait_ref,\n+                terr: _,\n+            }) => {\n                 match self.report_type_parameter_mismatch_error(\n                     &obligation,\n                     span,"}, {"sha": "4dc84e0ad10b1a3b7b9cd645781186088d7d3c1c", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -10,6 +10,7 @@ use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::LateBoundRegionConversionTime::HigherRankedType;\n use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n+use rustc_middle::traits::SelectionOutputTypeParameterMismatch;\n use rustc_middle::ty::{\n     self, Binder, GenericParamDefKind, InternalSubsts, SubstsRef, ToPolyTraitRef, ToPredicate,\n     TraitRef, Ty, TyCtxt, TypeVisitableExt,\n@@ -811,7 +812,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_poly_trait_refs(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-        expected_trait_ref: ty::PolyTraitRef<'tcx>,\n+        self_ty_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let obligation_trait_ref = obligation.predicate.to_poly_trait_ref();\n         // Normalize the obligation and expected trait refs together, because why not\n@@ -822,7 +823,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     obligation.param_env,\n                     obligation.cause.clone(),\n                     obligation.recursion_depth + 1,\n-                    (obligation_trait_ref, expected_trait_ref),\n+                    (obligation_trait_ref, self_ty_trait_ref),\n                 )\n             });\n \n@@ -834,7 +835,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 obligations.extend(nested);\n                 obligations\n             })\n-            .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n+            .map_err(|terr| {\n+                OutputTypeParameterMismatch(Box::new(SelectionOutputTypeParameterMismatch {\n+                    expected_trait_ref: obligation_trait_ref,\n+                    found_trait_ref: expected_trait_ref,\n+                    terr,\n+                }))\n+            })\n     }\n \n     fn confirm_trait_upcasting_unsize_candidate("}, {"sha": "3dd1d056be24f603e272e5e68486547d709a2882", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -394,7 +394,7 @@ impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n pub fn thir_abstract_const(\n     tcx: TyCtxt<'_>,\n     def: LocalDefId,\n-) -> Result<Option<ty::Const<'_>>, ErrorGuaranteed> {\n+) -> Result<Option<ty::EarlyBinder<ty::Const<'_>>>, ErrorGuaranteed> {\n     if !tcx.features().generic_const_exprs {\n         return Ok(None);\n     }\n@@ -420,7 +420,7 @@ pub fn thir_abstract_const(\n \n     let root_span = body.exprs[body_id].span;\n \n-    Some(recurse_build(tcx, body, body_id, root_span)).transpose()\n+    Ok(Some(ty::EarlyBinder(recurse_build(tcx, body, body_id, root_span)?)))\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "5ca5d14337cf08b0d2f7b08e52ec5034389948ac", "filename": "compiler/rustc_ty_utils/src/implied_bounds.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fimplied_bounds.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -31,6 +31,18 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n             }\n         }\n         DefKind::AssocConst | DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n+        DefKind::OpaqueTy => match tcx.def_kind(tcx.parent(def_id)) {\n+            DefKind::TyAlias => ty::List::empty(),\n+            DefKind::AssocTy => tcx.assumed_wf_types(tcx.parent(def_id)),\n+            // Nested opaque types only occur in associated types:\n+            // ` type Opaque<T> = impl Trait<&'static T, AssocTy = impl Nested>; `\n+            // assumed_wf_types should include those of `Opaque<T>`, `Opaque<T>` itself\n+            // and `&'static T`.\n+            DefKind::OpaqueTy => bug!(\"unimplemented implied bounds for neseted opaque types\"),\n+            def_kind @ _ => {\n+                bug!(\"unimplemented implied bounds for opaque types with parent {def_kind:?}\")\n+            }\n+        },\n         DefKind::Mod\n         | DefKind::Struct\n         | DefKind::Union\n@@ -51,7 +63,6 @@ fn assumed_wf_types(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::List<Ty<'_>> {\n         | DefKind::ForeignMod\n         | DefKind::AnonConst\n         | DefKind::InlineConst\n-        | DefKind::OpaqueTy\n         | DefKind::ImplTraitPlaceholder\n         | DefKind::Field\n         | DefKind::LifetimeParam"}, {"sha": "f6b44bdf27ef9fff28569bfc91d66da1c4b3cf47", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -643,7 +643,7 @@ impl UnifyKey for FloatVid {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Decodable, Encodable, Hash, HashStable_Generic)]\n+#[derive(Copy, Clone, PartialEq, Eq, Decodable, Encodable, Hash, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub enum Variance {\n     Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type"}, {"sha": "23ded42fa6679c53f19c489ad2fa5ffff75c1609", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1187,7 +1187,7 @@ extern \"rust-intrinsic\" {\n     /// Below are common applications of `transmute` which can be replaced with safer\n     /// constructs.\n     ///\n-    /// Turning raw bytes (`&[u8]`) into `u32`, `f64`, etc.:\n+    /// Turning raw bytes (`[u8; SZ]`) into `u32`, `f64`, etc.:\n     ///\n     /// ```\n     /// let raw_bytes = [0x78, 0x56, 0x34, 0x12];"}, {"sha": "b492d2f07bc13d91f22f3195fea3c01e9f16fa1b", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -449,6 +449,19 @@ impl<T: ?Sized> NonNull<T> {\n         // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n         unsafe { NonNull::new_unchecked(self.as_ptr() as *mut U) }\n     }\n+\n+    /// See [`pointer::add`] for semantics and safety requirements.\n+    #[inline]\n+    pub(crate) const unsafe fn add(self, delta: usize) -> Self\n+    where\n+        T: Sized,\n+    {\n+        // SAFETY: We require that the delta stays in-bounds of the object, and\n+        // thus it cannot become null, as that would require wrapping the\n+        // address space, which no legal objects are allowed to do.\n+        // And the caller promised the `delta` is sound to add.\n+        unsafe { NonNull { pointer: self.pointer.add(delta) } }\n+    }\n }\n \n impl<T> NonNull<[T]> {"}, {"sha": "67fcef0f4663c609df6892f18f05ce03b165f239", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -13,7 +13,7 @@ use crate::iter::{\n use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem::{self, SizedTypeProperties};\n use crate::num::NonZeroUsize;\n-use crate::ptr::NonNull;\n+use crate::ptr::{invalid, invalid_mut, NonNull};\n \n use super::{from_raw_parts, from_raw_parts_mut};\n \n@@ -67,9 +67,7 @@ pub struct Iter<'a, T: 'a> {\n     ptr: NonNull<T>,\n     /// For non-ZSTs, the non-null pointer to the past-the-end element.\n     ///\n-    /// For ZSTs, this is `ptr.wrapping_byte_add(len)`.\n-    ///\n-    /// For all types, `ptr == end` tests whether the iterator is empty.\n+    /// For ZSTs, this is `ptr::invalid(len)`.\n     end: *const T,\n     _marker: PhantomData<&'a T>,\n }\n@@ -94,8 +92,7 @@ impl<'a, T> Iter<'a, T> {\n         unsafe {\n             assume(!ptr.is_null());\n \n-            let end =\n-                if T::IS_ZST { ptr.wrapping_byte_add(slice.len()) } else { ptr.add(slice.len()) };\n+            let end = if T::IS_ZST { invalid(slice.len()) } else { ptr.add(slice.len()) };\n \n             Self { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: PhantomData }\n         }\n@@ -193,9 +190,7 @@ pub struct IterMut<'a, T: 'a> {\n     ptr: NonNull<T>,\n     /// For non-ZSTs, the non-null pointer to the past-the-end element.\n     ///\n-    /// For ZSTs, this is `ptr.wrapping_byte_add(len)`.\n-    ///\n-    /// For all types, `ptr == end` tests whether the iterator is empty.\n+    /// For ZSTs, this is `ptr::invalid_mut(len)`.\n     end: *mut T,\n     _marker: PhantomData<&'a mut T>,\n }\n@@ -235,8 +230,7 @@ impl<'a, T> IterMut<'a, T> {\n         unsafe {\n             assume(!ptr.is_null());\n \n-            let end =\n-                if T::IS_ZST { ptr.wrapping_byte_add(slice.len()) } else { ptr.add(slice.len()) };\n+            let end = if T::IS_ZST { invalid_mut(slice.len()) } else { ptr.add(slice.len()) };\n \n             Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }\n         }"}, {"sha": "3462c0e020a3d96938d59a7a1f3edea88b6f2f12", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,28 +1,44 @@\n //! Macros used by iterators of slice.\n \n+// Shrinks the iterator when T is a ZST, setting the length to `new_len`.\n+// `new_len` must not exceed `self.len()`.\n+macro_rules! zst_set_len {\n+    ($self: ident, $new_len: expr) => {{\n+        #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n+\n+        // SAFETY: same as `invalid(_mut)`, but the macro doesn't know\n+        // which versions of that function to call, so open-code it.\n+        $self.end = unsafe { mem::transmute::<usize, _>($new_len) };\n+    }};\n+}\n+\n+// Shrinks the iterator when T is a ZST, reducing the length by `n`.\n+// `n` must not exceed `self.len()`.\n+macro_rules! zst_shrink {\n+    ($self: ident, $n: ident) => {\n+        let new_len = $self.end.addr() - $n;\n+        zst_set_len!($self, new_len);\n+    };\n+}\n+\n // Inlining is_empty and len makes a huge performance difference\n macro_rules! is_empty {\n-    // The way we encode the length of a ZST iterator, this works both for ZST\n-    // and non-ZST.\n     ($self: ident) => {\n-        $self.ptr.as_ptr() as *const T == $self.end\n+        if T::IS_ZST { $self.end.addr() == 0 } else { $self.ptr.as_ptr() as *const _ == $self.end }\n     };\n }\n \n macro_rules! len {\n     ($self: ident) => {{\n         #![allow(unused_unsafe)] // we're sometimes used within an unsafe block\n \n-        let start = $self.ptr;\n         if T::IS_ZST {\n-            // This _cannot_ use `ptr_sub` because we depend on wrapping\n-            // to represent the length of long ZST slice iterators.\n-            $self.end.addr().wrapping_sub(start.as_ptr().addr())\n+            $self.end.addr()\n         } else {\n             // To get rid of some bounds checks (see `position`), we use ptr_sub instead of\n             // offset_from (Tested by `codegen/slice-position-bounds-check`.)\n             // SAFETY: by the type invariant pointers are aligned and `start <= end`\n-            unsafe { $self.end.sub_ptr(start.as_ptr()) }\n+            unsafe { $self.end.sub_ptr($self.ptr.as_ptr()) }\n         }\n     }};\n }\n@@ -50,14 +66,6 @@ macro_rules! iterator {\n             ($self: ident) => {& $( $mut_ )? *$self.pre_dec_end(1)}\n         }\n \n-        // Shrinks the iterator when T is a ZST, by moving the end of the iterator\n-        // backwards by `n`. `n` must not exceed `self.len()`.\n-        macro_rules! zst_shrink {\n-            ($self: ident, $n: ident) => {\n-                $self.end = $self.end.wrapping_byte_sub($n);\n-            }\n-        }\n-\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n@@ -73,16 +81,15 @@ macro_rules! iterator {\n             // Unsafe because the offset must not exceed `self.len()`.\n             #[inline(always)]\n             unsafe fn post_inc_start(&mut self, offset: usize) -> * $raw_mut T {\n+                let old = self.ptr;\n                 if T::IS_ZST {\n                     zst_shrink!(self, offset);\n-                    self.ptr.as_ptr()\n                 } else {\n-                    let old = self.ptr.as_ptr();\n                     // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                     // so this new pointer is inside `self` and thus guaranteed to be non-null.\n-                    self.ptr = unsafe { NonNull::new_unchecked(self.ptr.as_ptr().add(offset)) };\n-                    old\n+                    self.ptr = unsafe { self.ptr.add(offset) };\n                 }\n+                old.as_ptr()\n             }\n \n             // Helper function for moving the end of the iterator backwards by `offset` elements,\n@@ -155,9 +162,7 @@ macro_rules! iterator {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n                     if T::IS_ZST {\n-                        // We have to do it this way as `ptr` may never be 0, but `end`\n-                        // could be (due to wrapping).\n-                        self.end = self.ptr.as_ptr();\n+                        zst_set_len!(self, 0);\n                     } else {\n                         // SAFETY: end can't be 0 if T isn't ZST because ptr isn't 0 and end >= ptr\n                         unsafe {\n@@ -356,7 +361,11 @@ macro_rules! iterator {\n             fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                 if n >= len!(self) {\n                     // This iterator is now empty.\n-                    self.end = self.ptr.as_ptr();\n+                    if T::IS_ZST {\n+                        zst_set_len!(self, 0);\n+                    } else {\n+                        self.end = self.ptr.as_ptr();\n+                    }\n                     return None;\n                 }\n                 // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs."}, {"sha": "acd47a3da72b2cc0f910755b2b0573dbbb09e662", "filename": "library/portable-simd/.github/workflows/ci.yml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2F.github%2Fworkflows%2Fci.yml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -241,6 +241,10 @@ jobs:\n           - \"--features std\"\n           - \"--features generic_const_exprs\"\n           - \"--features std --features generic_const_exprs\"\n+          - \"--features all_lane_counts\"\n+          - \"--features all_lane_counts --features std\"\n+          - \"--features all_lane_counts --features generic_const_exprs\"\n+          - \"--features all_lane_counts --features std --features generic_const_exprs\"\n \n     steps:\n       - uses: actions/checkout@v2"}, {"sha": "e8ac600debe67881c33b1301aceb4945eb56206f", "filename": "library/portable-simd/README.md", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FREADME.md?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -24,44 +24,34 @@ or by setting up `rustup default nightly` or else with `cargo +nightly {build,te\n ```bash\n cargo new hellosimd\n ```\n-to create a new crate. Edit `hellosimd/Cargo.toml` to be \n-```toml\n-[package]\n-name = \"hellosimd\"\n-version = \"0.1.0\"\n-edition = \"2018\"\n-[dependencies]\n-core_simd = { git = \"https://github.com/rust-lang/portable-simd\" }\n-```\n-\n-and finally write this in `src/main.rs`:\n+to create a new crate. Finally write this in `src/main.rs`:\n ```rust\n-use core_simd::*;\n+#![feature(portable_simd)]\n+use std::simd::f32x4;\n fn main() {\n     let a = f32x4::splat(10.0);\n     let b = f32x4::from_array([1.0, 2.0, 3.0, 4.0]);\n     println!(\"{:?}\", a + b);\n }\n ```\n \n-Explanation: We import all the bindings from the crate with the first line. Then, we construct our SIMD vectors with methods like `splat` or `from_array`. Finally, we can use operators on them like `+` and the appropriate SIMD instructions will be carried out. When we run `cargo run` you should get `[11.0, 12.0, 13.0, 14.0]`.\n-\n-## Code Organization\n+Explanation: We construct our SIMD vectors with methods like `splat` or `from_array`. Next, we can use operators like `+` on them, and the appropriate SIMD instructions will be carried out. When we run `cargo run` you should get `[11.0, 12.0, 13.0, 14.0]`.\n \n-Currently the crate is organized so that each element type is a file, and then the 64-bit, 128-bit, 256-bit, and 512-bit vectors using those types are contained in said file.\n+## Supported vectors\n \n-All types are then exported as a single, flat module.\n+Currently, vectors may have up to 64 elements, but aliases are provided only up to 512-bit vectors.\n \n Depending on the size of the primitive type, the number of lanes the vector will have varies. For example, 128-bit vectors have four `f32` lanes and two `f64` lanes.\n \n The supported element types are as follows:\n * **Floating Point:** `f32`, `f64`\n-* **Signed Integers:** `i8`, `i16`, `i32`, `i64`, `i128`, `isize`\n-* **Unsigned Integers:** `u8`, `u16`, `u32`, `u64`, `u128`, `usize`\n-* **Masks:** `mask8`, `mask16`, `mask32`, `mask64`, `mask128`, `masksize`\n+* **Signed Integers:** `i8`, `i16`, `i32`, `i64`, `isize` (`i128` excluded)\n+* **Unsigned Integers:** `u8`, `u16`, `u32`, `u64`, `usize` (`u128` excluded)\n+* **Pointers:** `*const T` and `*mut T` (zero-sized metadata only)\n+* **Masks:** 8-bit, 16-bit, 32-bit, 64-bit, and `usize`-sized masks\n \n-Floating point, signed integers, and unsigned integers are the [primitive types](https://doc.rust-lang.org/core/primitive/index.html) you're already used to.\n-The `mask` types are \"truthy\" values, but they use the number of bits in their name instead of just 1 bit like a normal `bool` uses.\n+Floating point, signed integers, unsigned integers, and pointers are the [primitive types](https://doc.rust-lang.org/core/primitive/index.html) you're already used to.\n+The mask types have elements that are \"truthy\" values, like `bool`, but have an unspecified layout because different architectures prefer different layouts for mask types.\n \n [simd-guide]: ./beginners-guide.md\n [zulip-project-portable-simd]: https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd"}, {"sha": "d1a3a515a7e81ff25c2750863d92f2cfc06b60e2", "filename": "library/portable-simd/crates/core_simd/Cargo.toml", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -13,12 +13,11 @@ default = [\"as_crate\"]\n as_crate = []\n std = []\n generic_const_exprs = []\n+all_lane_counts = []\n \n-[target.'cfg(target_arch = \"wasm32\")'.dev-dependencies.wasm-bindgen]\n-version = \"0.2\"\n-\n-[dev-dependencies.wasm-bindgen-test]\n-version = \"0.3\"\n+[target.'cfg(target_arch = \"wasm32\")'.dev-dependencies]\n+wasm-bindgen = \"0.2\"\n+wasm-bindgen-test = \"0.3\"\n \n [dev-dependencies.proptest]\n version = \"0.10\""}, {"sha": "82747f1b5a6f9c7091f7d3e1ad13d357d9619efb", "filename": "library/portable-simd/crates/core_simd/examples/README.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2FREADME.md?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,13 @@\n+### `stdsimd` examples\n+\n+This crate is a port of example uses of `stdsimd`, mostly taken from the `packed_simd` crate.\n+\n+The examples contain, as in the case of `dot_product.rs`, multiple ways of solving the problem, in order to show idiomatic uses of SIMD and iteration of performance designs.\n+\n+Run the tests with the command \n+\n+```\n+cargo run --example dot_product\n+```\n+\n+and verify the code for `dot_product.rs` on your machine."}, {"sha": "391f08f55a07a37d54c33414cc7c0ea0449781b3", "filename": "library/portable-simd/crates/core_simd/examples/dot_product.rs", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fdot_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fdot_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fdot_product.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,169 @@\n+// Code taken from the `packed_simd` crate\n+// Run this code with `cargo test --example dot_product`\n+//use std::iter::zip;\n+\n+#![feature(array_chunks)]\n+#![feature(slice_as_chunks)]\n+// Add these imports to use the stdsimd library\n+#![feature(portable_simd)]\n+use core_simd::simd::*;\n+\n+// This is your barebones dot product implementation:\n+// Take 2 vectors, multiply them element wise and *then*\n+// go along the resulting array and add up the result.\n+// In the next example we will see if there\n+//  is any difference to adding and multiplying in tandem.\n+pub fn dot_prod_scalar_0(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+\n+    a.iter().zip(b.iter()).map(|(a, b)| a * b).sum()\n+}\n+\n+// When dealing with SIMD, it is very important to think about the amount\n+// of data movement and when it happens. We're going over simple computation examples here, and yet\n+// it is not trivial to understand what may or may not contribute to performance\n+// changes. Eventually, you will need tools to inspect the generated assembly and confirm your\n+// hypothesis and benchmarks - we will mention them later on.\n+// With the use of `fold`, we're doing a multiplication,\n+// and then adding it to the sum, one element from both vectors at a time.\n+pub fn dot_prod_scalar_1(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    a.iter()\n+        .zip(b.iter())\n+        .fold(0.0, |a, zipped| a + zipped.0 * zipped.1)\n+}\n+\n+// We now move on to the SIMD implementations: notice the following constructs:\n+// `array_chunks::<4>`: mapping this over the vector will let use construct SIMD vectors\n+// `f32x4::from_array`: construct the SIMD vector from a slice\n+// `(a * b).reduce_sum()`: Multiply both f32x4 vectors together, and then reduce them.\n+// This approach essentially uses SIMD to produce a vector of length N/4 of all the products,\n+// and then add those with `sum()`. This is suboptimal.\n+// TODO: ASCII diagrams\n+pub fn dot_prod_simd_0(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .map(|(a, b)| (a * b).reduce_sum())\n+        .sum()\n+}\n+\n+// There's some simple ways to improve the previous code:\n+// 1. Make a `zero` `f32x4` SIMD vector that we will be accumulating into\n+// So that there is only one `sum()` reduction when the last `f32x4` has been processed\n+// 2. Exploit Fused Multiply Add so that the multiplication, addition and sinking into the reduciton\n+// happen in the same step.\n+// If the arrays are large, minimizing the data shuffling will lead to great perf.\n+// If the arrays are small, handling the remainder elements when the length isn't a multiple of 4\n+// Can become a problem.\n+pub fn dot_prod_simd_1(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .fold(f32x4::splat(0.0), |acc, zipped| acc + zipped.0 * zipped.1)\n+        .reduce_sum()\n+}\n+\n+// A lot of knowledgeable use of SIMD comes from knowing specific instructions that are\n+// available - let's try to use the `mul_add` instruction, which is the fused-multiply-add we were looking for.\n+use std_float::StdFloat;\n+pub fn dot_prod_simd_2(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    let mut res = f32x4::splat(0.0);\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .for_each(|(a, b)| {\n+            res = a.mul_add(b, res);\n+        });\n+    res.reduce_sum()\n+}\n+\n+// Finally, we will write the same operation but handling the loop remainder.\n+const LANES: usize = 4;\n+pub fn dot_prod_simd_3(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+\n+    let (a_extra, a_chunks) = a.as_rchunks();\n+    let (b_extra, b_chunks) = b.as_rchunks();\n+\n+    // These are always true, but for emphasis:\n+    assert_eq!(a_chunks.len(), b_chunks.len());\n+    assert_eq!(a_extra.len(), b_extra.len());\n+\n+    let mut sums = [0.0; LANES];\n+    for ((x, y), d) in std::iter::zip(a_extra, b_extra).zip(&mut sums) {\n+        *d = x * y;\n+    }\n+\n+    let mut sums = f32x4::from_array(sums);\n+    std::iter::zip(a_chunks, b_chunks).for_each(|(x, y)| {\n+        sums += f32x4::from_array(*x) * f32x4::from_array(*y);\n+    });\n+\n+    sums.reduce_sum()\n+}\n+\n+// Finally, we present an iterator version for handling remainders in a scalar fashion at the end of the loop.\n+// Unfortunately, this is allocating 1 `XMM` register on the order of `~len(a)` - we'll see how we can get around it in the\n+// next example.\n+pub fn dot_prod_simd_4(a: &[f32], b: &[f32]) -> f32 {\n+    let mut sum = a\n+        .array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .map(|(a, b)| a * b)\n+        .fold(f32x4::splat(0.0), std::ops::Add::add)\n+        .reduce_sum();\n+    let remain = a.len() - (a.len() % 4);\n+    sum += a[remain..]\n+        .iter()\n+        .zip(&b[remain..])\n+        .map(|(a, b)| a * b)\n+        .sum::<f32>();\n+    sum\n+}\n+\n+// This version allocates a single `XMM` register for accumulation, and the folds don't allocate on top of that.\n+// Notice the the use of `mul_add`, which can do a multiply and an add operation ber iteration.\n+pub fn dot_prod_simd_5(a: &[f32], b: &[f32]) -> f32 {\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .fold(f32x4::splat(0.), |acc, (a, b)| a.mul_add(b, acc))\n+        .reduce_sum()\n+}\n+\n+fn main() {\n+    // Empty main to make cargo happy\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn smoke_test() {\n+        use super::*;\n+        let a: Vec<f32> = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];\n+        let b: Vec<f32> = vec![-8.0, -7.0, -6.0, -5.0, 4.0, 3.0, 2.0, 1.0];\n+        let x: Vec<f32> = [0.5; 1003].to_vec();\n+        let y: Vec<f32> = [2.0; 1003].to_vec();\n+\n+        // Basic check\n+        assert_eq!(0.0, dot_prod_scalar_0(&a, &b));\n+        assert_eq!(0.0, dot_prod_scalar_1(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_0(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_1(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_2(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_3(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_4(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_5(&a, &b));\n+\n+        // We can handle vectors that are non-multiples of 4\n+        assert_eq!(1003.0, dot_prod_simd_3(&x, &y));\n+    }\n+}"}, {"sha": "23f121c46197c58d39b851015256112469943253", "filename": "library/portable-simd/crates/core_simd/src/alias.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Falias.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,227 @@\n+macro_rules! number {\n+    { 1 } => { \"one\" };\n+    { 2 } => { \"two\" };\n+    { 4 } => { \"four\" };\n+    { 8 } => { \"eight\" };\n+    { $x:literal } => { stringify!($x) };\n+}\n+\n+macro_rules! plural {\n+    { 1 } => { \"\" };\n+    { $x:literal } => { \"s\" };\n+}\n+\n+macro_rules! alias {\n+    {\n+        $(\n+            $element_ty:ty = {\n+                $($alias:ident $num_elements:tt)*\n+            }\n+        )*\n+    } => {\n+        $(\n+            $(\n+            #[doc = concat!(\"A SIMD vector with \", number!($num_elements), \" element\", plural!($num_elements), \" of type [`\", stringify!($element_ty), \"`].\")]\n+            #[allow(non_camel_case_types)]\n+            pub type $alias = $crate::simd::Simd<$element_ty, $num_elements>;\n+            )*\n+        )*\n+    }\n+}\n+\n+macro_rules! mask_alias {\n+    {\n+        $(\n+            $element_ty:ty : $size:literal = {\n+                $($alias:ident $num_elements:tt)*\n+            }\n+        )*\n+    } => {\n+        $(\n+            $(\n+            #[doc = concat!(\"A SIMD mask with \", number!($num_elements), \" element\", plural!($num_elements), \" for vectors with \", $size, \" element types.\")]\n+            ///\n+            #[doc = concat!(\n+                \"The layout of this type is unspecified, and may change between platforms and/or Rust versions, and code should not assume that it is equivalent to `[\",\n+                stringify!($element_ty), \"; \", $num_elements, \"]`.\"\n+            )]\n+            #[allow(non_camel_case_types)]\n+            pub type $alias = $crate::simd::Mask<$element_ty, $num_elements>;\n+            )*\n+        )*\n+    }\n+}\n+\n+alias! {\n+    i8 = {\n+        i8x1 1\n+        i8x2 2\n+        i8x4 4\n+        i8x8 8\n+        i8x16 16\n+        i8x32 32\n+        i8x64 64\n+    }\n+\n+    i16 = {\n+        i16x1 1\n+        i16x2 2\n+        i16x4 4\n+        i16x8 8\n+        i16x16 16\n+        i16x32 32\n+        i16x64 64\n+    }\n+\n+    i32 = {\n+        i32x1 1\n+        i32x2 2\n+        i32x4 4\n+        i32x8 8\n+        i32x16 16\n+        i32x32 32\n+        i32x64 64\n+    }\n+\n+    i64 = {\n+        i64x1 1\n+        i64x2 2\n+        i64x4 4\n+        i64x8 8\n+        i64x16 16\n+        i64x32 32\n+        i64x64 64\n+    }\n+\n+    isize = {\n+        isizex1 1\n+        isizex2 2\n+        isizex4 4\n+        isizex8 8\n+        isizex16 16\n+        isizex32 32\n+        isizex64 64\n+    }\n+\n+    u8 = {\n+        u8x1 1\n+        u8x2 2\n+        u8x4 4\n+        u8x8 8\n+        u8x16 16\n+        u8x32 32\n+        u8x64 64\n+    }\n+\n+    u16 = {\n+        u16x1 1\n+        u16x2 2\n+        u16x4 4\n+        u16x8 8\n+        u16x16 16\n+        u16x32 32\n+        u16x64 64\n+    }\n+\n+    u32 = {\n+        u32x1 1\n+        u32x2 2\n+        u32x4 4\n+        u32x8 8\n+        u32x16 16\n+        u32x32 32\n+        u32x64 64\n+    }\n+\n+    u64 = {\n+        u64x1 1\n+        u64x2 2\n+        u64x4 4\n+        u64x8 8\n+        u64x16 16\n+        u64x32 32\n+        u64x64 64\n+    }\n+\n+    usize = {\n+        usizex1 1\n+        usizex2 2\n+        usizex4 4\n+        usizex8 8\n+        usizex16 16\n+        usizex32 32\n+        usizex64 64\n+    }\n+\n+    f32 = {\n+        f32x1 1\n+        f32x2 2\n+        f32x4 4\n+        f32x8 8\n+        f32x16 16\n+        f32x32 32\n+        f32x64 64\n+    }\n+\n+    f64 = {\n+        f64x1 1\n+        f64x2 2\n+        f64x4 4\n+        f64x8 8\n+        f64x16 16\n+        f64x32 32\n+        f64x64 64\n+    }\n+}\n+\n+mask_alias! {\n+    i8 : \"8-bit\" = {\n+        mask8x1 1\n+        mask8x2 2\n+        mask8x4 4\n+        mask8x8 8\n+        mask8x16 16\n+        mask8x32 32\n+        mask8x64 64\n+    }\n+\n+    i16 : \"16-bit\" = {\n+        mask16x1 1\n+        mask16x2 2\n+        mask16x4 4\n+        mask16x8 8\n+        mask16x16 16\n+        mask16x32 32\n+        mask16x64 64\n+    }\n+\n+    i32 : \"32-bit\" = {\n+        mask32x1 1\n+        mask32x2 2\n+        mask32x4 4\n+        mask32x8 8\n+        mask32x16 16\n+        mask32x32 32\n+        mask32x64 64\n+    }\n+\n+    i64 : \"64-bit\" = {\n+        mask64x1 1\n+        mask64x2 2\n+        mask64x4 4\n+        mask64x8 8\n+        mask64x16 16\n+        mask64x32 32\n+        mask64x64 64\n+    }\n+\n+    isize : \"pointer-sized\" = {\n+        masksizex1 1\n+        masksizex2 2\n+        masksizex4 4\n+        masksizex8 8\n+        masksizex16 16\n+        masksizex32 32\n+        masksizex64 64\n+    }\n+}"}, {"sha": "65a3f845ffca74022127bf319ffccf5c77bacf38", "filename": "library/portable-simd/crates/core_simd/src/cast.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fcast.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,55 @@\n+use crate::simd::SimdElement;\n+\n+/// Supporting trait for `Simd::cast`.  Typically doesn't need to be used directly.\n+///\n+/// # Safety\n+/// Implementing this trait asserts that the type is a valid vector element for the `simd_cast` or\n+/// `simd_as` intrinsics.\n+pub unsafe trait SimdCast: SimdElement {}\n+\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i8 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i16 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for i64 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for isize {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u8 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u16 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for u64 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for usize {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for f32 {}\n+// Safety: primitive number types can be cast to other primitive number types\n+unsafe impl SimdCast for f64 {}\n+\n+/// Supporting trait for `Simd::cast_ptr`.  Typically doesn't need to be used directly.\n+///\n+/// # Safety\n+/// Implementing this trait asserts that the type is a valid vector element for the `simd_cast_ptr`\n+/// intrinsic.\n+pub unsafe trait SimdCastPtr<T> {}\n+\n+// Safety: pointers can be cast to other pointer types\n+unsafe impl<T, U> SimdCastPtr<T> for *const U\n+where\n+    U: core::ptr::Pointee,\n+    T: core::ptr::Pointee<Metadata = U::Metadata>,\n+{\n+}\n+// Safety: pointers can be cast to other pointer types\n+unsafe impl<T, U> SimdCastPtr<T> for *mut U\n+where\n+    U: core::ptr::Pointee,\n+    T: core::ptr::Pointee<Metadata = U::Metadata>,\n+{\n+}"}, {"sha": "dc7f52a4d576cf1d31f4841c60c974791cf1bff8", "filename": "library/portable-simd/crates/core_simd/src/elements.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,11 +1,15 @@\n+mod const_ptr;\n mod float;\n mod int;\n+mod mut_ptr;\n mod uint;\n \n mod sealed {\n     pub trait Sealed {}\n }\n \n+pub use const_ptr::*;\n pub use float::*;\n pub use int::*;\n+pub use mut_ptr::*;\n pub use uint::*;"}, {"sha": "0ef9802b5e219c43294157dee2752adb29279e94", "filename": "library/portable-simd/crates/core_simd/src/elements/const_ptr.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fconst_ptr.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,141 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of constant pointers.\n+pub trait SimdConstPtr: Copy + Sealed {\n+    /// Vector of `usize` with the same number of lanes.\n+    type Usize;\n+\n+    /// Vector of `isize` with the same number of lanes.\n+    type Isize;\n+\n+    /// Vector of mutable pointers to the same type.\n+    type MutPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    ///\n+    /// Equivalent to calling [`pointer::cast_mut`] on each lane.\n+    fn cast_mut(self) -> Self::MutPtr;\n+\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// This method semantically discards *provenance* and\n+    /// *address-space* information. To properly restore that information, use [`Self::with_addr`].\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n+    /// Gets the \"address\" portion of the pointer, and \"exposes\" the provenance part for future use\n+    /// in [`Self::from_exposed_addr`].\n+    fn expose_addr(self) -> Self::Usize;\n+\n+    /// Convert an address back to a pointer, picking up a previously \"exposed\" provenance.\n+    ///\n+    /// Equivalent to calling [`core::ptr::from_exposed_addr`] on each lane.\n+    fn from_exposed_addr(addr: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n+    fn wrapping_offset(self, offset: Self::Isize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_sub`] on each lane.\n+    fn wrapping_sub(self, count: Self::Usize) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*const T, LANES> where\n+    LaneCount<LANES>: SupportedLaneCount\n+{\n+}\n+\n+impl<T, const LANES: usize> SimdConstPtr for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Usize = Simd<usize, LANES>;\n+    type Isize = Simd<isize, LANES>;\n+    type MutPtr = Simd<*mut T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null()).simd_eq(self)\n+    }\n+\n+    #[inline]\n+    fn cast_mut(self) -> Self::MutPtr {\n+        self.cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n+        // provenance).\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        self.cast_ptr::<*const u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn expose_addr(self) -> Self::Usize {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_expose_addr(self) }\n+    }\n+\n+    #[inline]\n+    fn from_exposed_addr(addr: Self::Usize) -> Self {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_from_exposed_addr(addr) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_offset(self, count: Self::Isize) -> Self {\n+        // Safety: simd_arith_offset takes a vector of pointers and a vector of offsets\n+        unsafe { intrinsics::simd_arith_offset(self, count) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(count.cast())\n+    }\n+\n+    #[inline]\n+    fn wrapping_sub(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(-count.cast::<isize>())\n+    }\n+}"}, {"sha": "d87986b4a091cea9be41e186582725fc98465500", "filename": "library/portable-simd/crates/core_simd/src/elements/mut_ptr.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Felements%2Fmut_ptr.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,136 @@\n+use super::sealed::Sealed;\n+use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+\n+/// Operations on SIMD vectors of mutable pointers.\n+pub trait SimdMutPtr: Copy + Sealed {\n+    /// Vector of `usize` with the same number of lanes.\n+    type Usize;\n+\n+    /// Vector of `isize` with the same number of lanes.\n+    type Isize;\n+\n+    /// Vector of constant pointers to the same type.\n+    type ConstPtr;\n+\n+    /// Mask type used for manipulating this SIMD vector type.\n+    type Mask;\n+\n+    /// Returns `true` for each lane that is null.\n+    fn is_null(self) -> Self::Mask;\n+\n+    /// Changes constness without changing the type.\n+    ///\n+    /// Equivalent to calling [`pointer::cast_const`] on each lane.\n+    fn cast_const(self) -> Self::ConstPtr;\n+\n+    /// Gets the \"address\" portion of the pointer.\n+    ///\n+    /// This method discards pointer semantic metadata, so the result cannot be\n+    /// directly cast into a valid pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::addr`] on each lane.\n+    fn addr(self) -> Self::Usize;\n+\n+    /// Creates a new pointer with the given address.\n+    ///\n+    /// This performs the same operation as a cast, but copies the *address-space* and\n+    /// *provenance* of `self` to the new pointer.\n+    ///\n+    /// Equivalent to calling [`pointer::with_addr`] on each lane.\n+    fn with_addr(self, addr: Self::Usize) -> Self;\n+\n+    /// Gets the \"address\" portion of the pointer, and \"exposes\" the provenance part for future use\n+    /// in [`Self::from_exposed_addr`].\n+    fn expose_addr(self) -> Self::Usize;\n+\n+    /// Convert an address back to a pointer, picking up a previously \"exposed\" provenance.\n+    ///\n+    /// Equivalent to calling [`core::ptr::from_exposed_addr_mut`] on each lane.\n+    fn from_exposed_addr(addr: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_offset`] on each lane.\n+    fn wrapping_offset(self, offset: Self::Isize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_add`] on each lane.\n+    fn wrapping_add(self, count: Self::Usize) -> Self;\n+\n+    /// Calculates the offset from a pointer using wrapping arithmetic.\n+    ///\n+    /// Equivalent to calling [`pointer::wrapping_sub`] on each lane.\n+    fn wrapping_sub(self, count: Self::Usize) -> Self;\n+}\n+\n+impl<T, const LANES: usize> Sealed for Simd<*mut T, LANES> where LaneCount<LANES>: SupportedLaneCount\n+{}\n+\n+impl<T, const LANES: usize> SimdMutPtr for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Usize = Simd<usize, LANES>;\n+    type Isize = Simd<isize, LANES>;\n+    type ConstPtr = Simd<*const T, LANES>;\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn is_null(self) -> Self::Mask {\n+        Simd::splat(core::ptr::null_mut()).simd_eq(self)\n+    }\n+\n+    #[inline]\n+    fn cast_const(self) -> Self::ConstPtr {\n+        self.cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn addr(self) -> Self::Usize {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n+        // provenance).\n+        unsafe { core::mem::transmute_copy(&self) }\n+    }\n+\n+    #[inline]\n+    fn with_addr(self, addr: Self::Usize) -> Self {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        //\n+        // In the mean-time, this operation is defined to be \"as if\" it was\n+        // a wrapping_offset, so we can emulate it as such. This should properly\n+        // restore pointer provenance even under today's compiler.\n+        self.cast_ptr::<*mut u8>()\n+            .wrapping_offset(addr.cast::<isize>() - self.addr().cast::<isize>())\n+            .cast_ptr()\n+    }\n+\n+    #[inline]\n+    fn expose_addr(self) -> Self::Usize {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_expose_addr(self) }\n+    }\n+\n+    #[inline]\n+    fn from_exposed_addr(addr: Self::Usize) -> Self {\n+        // Safety: `self` is a pointer vector\n+        unsafe { intrinsics::simd_from_exposed_addr(addr) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_offset(self, count: Self::Isize) -> Self {\n+        // Safety: simd_arith_offset takes a vector of pointers and a vector of offsets\n+        unsafe { intrinsics::simd_arith_offset(self, count) }\n+    }\n+\n+    #[inline]\n+    fn wrapping_add(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(count.cast())\n+    }\n+\n+    #[inline]\n+    fn wrapping_sub(self, count: Self::Usize) -> Self {\n+        self.wrapping_offset(-count.cast::<isize>())\n+    }\n+}"}, {"sha": "80763c07272781d7e370fa788249e0b26382dded", "filename": "library/portable-simd/crates/core_simd/src/eq.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Feq.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdElement, SimdMutPtr, SupportedLaneCount,\n+};\n \n /// Parallel `PartialEq`.\n pub trait SimdPartialEq {\n@@ -71,3 +73,37 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        self.addr().simd_eq(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ne(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialEq for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    type Mask = Mask<isize, LANES>;\n+\n+    #[inline]\n+    fn simd_eq(self, other: Self) -> Self::Mask {\n+        self.addr().simd_eq(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ne(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ne(other.addr())\n+    }\n+}"}, {"sha": "b7317969cbb49ad994408227a5d8cdeadda3618e", "filename": "library/portable-simd/crates/core_simd/src/fmt.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,39 +1,21 @@\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::fmt;\n \n-macro_rules! impl_fmt_trait {\n-    { $($trait:ident,)* } => {\n-        $(\n-            impl<T, const LANES: usize> fmt::$trait for Simd<T, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-                T: SimdElement + fmt::$trait,\n-            {\n-                fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                    #[repr(transparent)]\n-                    struct Wrapper<'a, T: fmt::$trait>(&'a T);\n-\n-                    impl<T: fmt::$trait> fmt::Debug for Wrapper<'_, T> {\n-                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                            self.0.fmt(f)\n-                        }\n-                    }\n-\n-                    f.debug_list()\n-                        .entries(self.as_array().iter().map(|x| Wrapper(x)))\n-                        .finish()\n-                }\n-            }\n-        )*\n+impl<T, const LANES: usize> fmt::Debug for Simd<T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+    T: SimdElement + fmt::Debug,\n+{\n+    /// A `Simd<T, N>` has a debug format like the one for `[T]`:\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd::Simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd::Simd;\n+    /// let floats = Simd::<f32, 4>::splat(-1.0);\n+    /// assert_eq!(format!(\"{:?}\", [-1.0; 4]), format!(\"{:?}\", floats));\n+    /// ```\n+    #[inline]\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        <[T] as fmt::Debug>::fmt(self.as_array(), f)\n     }\n }\n-\n-impl_fmt_trait! {\n-    Debug,\n-    Binary,\n-    LowerExp,\n-    UpperExp,\n-    Octal,\n-    LowerHex,\n-    UpperHex,\n-}"}, {"sha": "dd6698e2ba56cac6796ebf8d9598aaf453e34bfb", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -61,9 +61,6 @@ extern \"platform-intrinsic\" {\n     /// xor\n     pub(crate) fn simd_xor<T>(x: T, y: T) -> T;\n \n-    /// getelementptr (without inbounds)\n-    pub(crate) fn simd_arith_offset<T, U>(ptrs: T, offsets: U) -> T;\n-\n     /// fptoui/fptosi/uitofp/sitofp\n     /// casting floats to integers is truncating, so it is safe to convert values like e.g. 1.5\n     /// but the truncated value must fit in the target type or the result is poison.\n@@ -150,4 +147,17 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_select<M, T>(m: M, yes: T, no: T) -> T;\n     #[allow(unused)]\n     pub(crate) fn simd_select_bitmask<M, T>(m: M, yes: T, no: T) -> T;\n+\n+    /// getelementptr (without inbounds)\n+    /// equivalent to wrapping_offset\n+    pub(crate) fn simd_arith_offset<T, U>(ptr: T, offset: U) -> T;\n+\n+    /// equivalent to `T as U` semantics, specifically for pointers\n+    pub(crate) fn simd_cast_ptr<T, U>(ptr: T) -> U;\n+\n+    /// expose a pointer as an address\n+    pub(crate) fn simd_expose_addr<T, U>(ptr: T) -> U;\n+\n+    /// convert an exposed address back to a pointer\n+    pub(crate) fn simd_from_exposed_addr<T, U>(addr: T) -> U;\n }"}, {"sha": "2b91eb9e80047d313421dd79c7b8908ddebc6e37", "filename": "library/portable-simd/crates/core_simd/src/lane_count.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flane_count.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -23,24 +23,20 @@ pub trait SupportedLaneCount: Sealed {\n \n impl<const LANES: usize> Sealed for LaneCount<LANES> {}\n \n-impl SupportedLaneCount for LaneCount<1> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<2> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<4> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<8> {\n-    type BitMask = [u8; 1];\n-}\n-impl SupportedLaneCount for LaneCount<16> {\n-    type BitMask = [u8; 2];\n-}\n-impl SupportedLaneCount for LaneCount<32> {\n-    type BitMask = [u8; 4];\n-}\n-impl SupportedLaneCount for LaneCount<64> {\n-    type BitMask = [u8; 8];\n+macro_rules! supported_lane_count {\n+    ($($lanes:literal),+) => {\n+        $(\n+            impl SupportedLaneCount for LaneCount<$lanes> {\n+                type BitMask = [u8; ($lanes + 7) / 8];\n+            }\n+        )+\n+    };\n }\n+\n+supported_lane_count!(1, 2, 4, 8, 16, 32, 64);\n+#[cfg(feature = \"all_lane_counts\")]\n+supported_lane_count!(\n+    3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+    31, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,\n+    56, 57, 58, 59, 60, 61, 62, 63\n+);"}, {"sha": "e5307de2155209e4b4bd58f6dfe70cee1c55daae", "filename": "library/portable-simd/crates/core_simd/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Flib.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,13 +1,18 @@\n #![no_std]\n #![feature(\n+    const_refs_to_cell,\n+    const_maybe_uninit_as_mut_ptr,\n+    const_mut_refs,\n     convert_float_to_int,\n     decl_macro,\n     intra_doc_pointers,\n     platform_intrinsics,\n     repr_simd,\n     simd_ffi,\n     staged_api,\n-    stdsimd\n+    stdsimd,\n+    strict_provenance,\n+    ptr_metadata\n )]\n #![cfg_attr(feature = \"generic_const_exprs\", feature(generic_const_exprs))]\n #![cfg_attr(feature = \"generic_const_exprs\", allow(incomplete_features))]\n@@ -19,4 +24,3 @@\n #[path = \"mod.rs\"]\n mod core_simd;\n pub use self::core_simd::simd;\n-pub use simd::*;"}, {"sha": "e58df80fca8b54c87e0bbbf65ffc4c363dfac352", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 12, "deletions": 55, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -55,13 +55,15 @@ pub unsafe trait MaskElement: SimdElement + Sealed {}\n macro_rules! impl_element {\n     { $ty:ty } => {\n         impl Sealed for $ty {\n+            #[inline]\n             fn valid<const LANES: usize>(value: Simd<Self, LANES>) -> bool\n             where\n                 LaneCount<LANES>: SupportedLaneCount,\n             {\n                 (value.simd_eq(Simd::splat(0 as _)) | value.simd_eq(Simd::splat(-1 as _))).all()\n             }\n \n+            #[inline]\n             fn eq(self, other: Self) -> bool { self == other }\n \n             const TRUE: Self = -1;\n@@ -83,7 +85,9 @@ impl_element! { isize }\n ///\n /// Masks represent boolean inclusion/exclusion on a per-lane basis.\n ///\n-/// The layout of this type is unspecified.\n+/// The layout of this type is unspecified, and may change between platforms\n+/// and/or Rust versions, and code should not assume that it is equivalent to\n+/// `[T; LANES]`.\n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(mask_impl::Mask<T, LANES>)\n where\n@@ -102,6 +106,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -113,11 +118,13 @@ where\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     /// Construct a mask by setting all lanes to the given value.\n+    #[inline]\n     pub fn splat(value: bool) -> Self {\n         Self(mask_impl::Mask::splat(value))\n     }\n \n     /// Converts an array of bools to a SIMD mask.\n+    #[inline]\n     pub fn from_array(array: [bool; LANES]) -> Self {\n         // SAFETY: Rust's bool has a layout of 1 byte (u8) with a value of\n         //     true:    0b_0000_0001\n@@ -134,6 +141,7 @@ where\n     }\n \n     /// Converts a SIMD mask to an array of bools.\n+    #[inline]\n     pub fn to_array(self) -> [bool; LANES] {\n         // This follows mostly the same logic as from_array.\n         // SAFETY: Rust's bool has a layout of 1 byte (u8) with a value of\n@@ -261,6 +269,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn from(array: [bool; LANES]) -> Self {\n         Self::from_array(array)\n     }\n@@ -271,6 +280,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn from(vector: Mask<T, LANES>) -> Self {\n         vector.to_array()\n     }\n@@ -520,67 +530,14 @@ where\n     }\n }\n \n-/// A mask for SIMD vectors with eight elements of 8 bits.\n-pub type mask8x8 = Mask<i8, 8>;\n-\n-/// A mask for SIMD vectors with 16 elements of 8 bits.\n-pub type mask8x16 = Mask<i8, 16>;\n-\n-/// A mask for SIMD vectors with 32 elements of 8 bits.\n-pub type mask8x32 = Mask<i8, 32>;\n-\n-/// A mask for SIMD vectors with 64 elements of 8 bits.\n-pub type mask8x64 = Mask<i8, 64>;\n-\n-/// A mask for SIMD vectors with four elements of 16 bits.\n-pub type mask16x4 = Mask<i16, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of 16 bits.\n-pub type mask16x8 = Mask<i16, 8>;\n-\n-/// A mask for SIMD vectors with 16 elements of 16 bits.\n-pub type mask16x16 = Mask<i16, 16>;\n-\n-/// A mask for SIMD vectors with 32 elements of 16 bits.\n-pub type mask16x32 = Mask<i16, 32>;\n-\n-/// A mask for SIMD vectors with two elements of 32 bits.\n-pub type mask32x2 = Mask<i32, 2>;\n-\n-/// A mask for SIMD vectors with four elements of 32 bits.\n-pub type mask32x4 = Mask<i32, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of 32 bits.\n-pub type mask32x8 = Mask<i32, 8>;\n-\n-/// A mask for SIMD vectors with 16 elements of 32 bits.\n-pub type mask32x16 = Mask<i32, 16>;\n-\n-/// A mask for SIMD vectors with two elements of 64 bits.\n-pub type mask64x2 = Mask<i64, 2>;\n-\n-/// A mask for SIMD vectors with four elements of 64 bits.\n-pub type mask64x4 = Mask<i64, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of 64 bits.\n-pub type mask64x8 = Mask<i64, 8>;\n-\n-/// A mask for SIMD vectors with two elements of pointer width.\n-pub type masksizex2 = Mask<isize, 2>;\n-\n-/// A mask for SIMD vectors with four elements of pointer width.\n-pub type masksizex4 = Mask<isize, 4>;\n-\n-/// A mask for SIMD vectors with eight elements of pointer width.\n-pub type masksizex8 = Mask<isize, 8>;\n-\n macro_rules! impl_from {\n     { $from:ty  => $($to:ty),* } => {\n         $(\n         impl<const LANES: usize> From<Mask<$from, LANES>> for Mask<$to, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n+            #[inline]\n             fn from(value: Mask<$from, LANES>) -> Self {\n                 value.cast()\n             }"}, {"sha": "20465ba9b07ec72381c89fbfff087f94d0ec2069", "filename": "library/portable-simd/crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -26,6 +26,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn clone(&self) -> Self {\n         *self\n     }\n@@ -36,6 +37,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.0.as_ref() == other.0.as_ref()\n     }\n@@ -46,6 +48,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n@@ -63,6 +66,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.as_ref().cmp(other.0.as_ref())\n     }"}, {"sha": "1d13c45b8e70bb26f7c8b2dc8336015a323bcbbb", "filename": "library/portable-simd/crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -37,6 +37,7 @@ where\n     T: MaskElement + PartialEq,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         self.0.eq(&other.0)\n     }\n@@ -47,6 +48,7 @@ where\n     T: MaskElement + PartialOrd,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.partial_cmp(&other.0)\n     }\n@@ -64,6 +66,7 @@ where\n     T: MaskElement + Ord,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.cmp(&other.0)\n     }\n@@ -262,6 +265,7 @@ where\n     T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n+    #[inline]\n     fn from(value: Mask<T, LANES>) -> Self {\n         value.0\n     }"}, {"sha": "fc7d6b781f2f5f50bc3abbc7ff73702e5e3bc774", "filename": "library/portable-simd/crates/core_simd/src/masks/to_bitmask.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -48,10 +48,12 @@ macro_rules! impl_integer_intrinsic {\n         impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n             type BitMask = $int;\n \n+            #[inline]\n             fn to_bitmask(self) -> $int {\n                 self.0.to_bitmask_integer()\n             }\n \n+            #[inline]\n             fn from_bitmask(bitmask: $int) -> Self {\n                 Self(mask_impl::Mask::from_bitmask_integer(bitmask))\n             }\n@@ -83,10 +85,12 @@ where\n {\n     const BYTES: usize = bitmask_len(LANES);\n \n+    #[inline]\n     fn to_bitmask_array(self) -> [u8; Self::BYTES] {\n         self.0.to_bitmask_array()\n     }\n \n+    #[inline]\n     fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self {\n         Mask(mask_impl::Mask::from_bitmask_array(bitmask))\n     }"}, {"sha": "35c659b7a429a6b151220f262dd1cc2072dcca41", "filename": "library/portable-simd/crates/core_simd/src/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -6,6 +6,8 @@ pub(crate) mod intrinsics;\n #[cfg(feature = \"generic_const_exprs\")]\n mod to_bytes;\n \n+mod alias;\n+mod cast;\n mod elements;\n mod eq;\n mod fmt;\n@@ -15,18 +17,22 @@ mod masks;\n mod ops;\n mod ord;\n mod select;\n+mod swizzle_dyn;\n mod vector;\n mod vendor;\n \n #[doc = include_str!(\"core_simd_docs.md\")]\n pub mod simd {\n     pub(crate) use crate::core_simd::intrinsics;\n \n+    pub use crate::core_simd::alias::*;\n+    pub use crate::core_simd::cast::*;\n     pub use crate::core_simd::elements::*;\n     pub use crate::core_simd::eq::*;\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;\n     pub use crate::core_simd::ord::*;\n     pub use crate::core_simd::swizzle::*;\n+    pub use crate::core_simd::swizzle_dyn::*;\n     pub use crate::core_simd::vector::*;\n }"}, {"sha": "1ae9cd061fb2d23f731655bfc82e736cdbe20ec9", "filename": "library/portable-simd/crates/core_simd/src/ord.rs", "status": "modified", "additions": 101, "deletions": 1, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Ford.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,4 +1,6 @@\n-use crate::simd::{intrinsics, LaneCount, Mask, Simd, SimdPartialEq, SupportedLaneCount};\n+use crate::simd::{\n+    intrinsics, LaneCount, Mask, Simd, SimdConstPtr, SimdMutPtr, SimdPartialEq, SupportedLaneCount,\n+};\n \n /// Parallel `PartialOrd`.\n pub trait SimdPartialOrd: SimdPartialEq {\n@@ -211,3 +213,101 @@ macro_rules! impl_mask {\n }\n \n impl_mask! { i8, i16, i32, i64, isize }\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_lt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        self.addr().simd_le(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_gt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ge(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*const T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdPartialOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_lt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_lt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_le(self, other: Self) -> Self::Mask {\n+        self.addr().simd_le(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_gt(self, other: Self) -> Self::Mask {\n+        self.addr().simd_gt(other.addr())\n+    }\n+\n+    #[inline]\n+    fn simd_ge(self, other: Self) -> Self::Mask {\n+        self.addr().simd_ge(other.addr())\n+    }\n+}\n+\n+impl<T, const LANES: usize> SimdOrd for Simd<*mut T, LANES>\n+where\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    #[inline]\n+    fn simd_max(self, other: Self) -> Self {\n+        self.simd_lt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_min(self, other: Self) -> Self {\n+        self.simd_gt(other).select(other, self)\n+    }\n+\n+    #[inline]\n+    fn simd_clamp(self, min: Self, max: Self) -> Self {\n+        assert!(\n+            min.simd_le(max).all(),\n+            \"each lane in `min` must be less than or equal to the corresponding lane in `max`\",\n+        );\n+        self.simd_max(min).simd_min(max)\n+    }\n+}"}, {"sha": "68f20516cf5bca46e4dccbe363fa538ed0dc53a3", "filename": "library/portable-simd/crates/core_simd/src/swizzle.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -265,16 +265,13 @@ where\n \n     /// Interleave two vectors.\n     ///\n-    /// Produces two vectors with lanes taken alternately from `self` and `other`.\n+    /// The resulting vectors contain lanes taken alternatively from `self` and `other`, first\n+    /// filling the first result, and then the second.\n     ///\n-    /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n-    /// alternating, starting with the first lane of `self`.\n-    ///\n-    /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n-    /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n+    /// The reverse of this operation is [`Simd::deinterleave`].\n     ///\n     /// ```\n-    /// #![feature(portable_simd)]\n+    /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let a = Simd::from_array([0, 1, 2, 3]);\n     /// let b = Simd::from_array([4, 5, 6, 7]);\n@@ -285,29 +282,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn interleave(self, other: Self) -> (Self, Self) {\n-        const fn lo<const LANES: usize>() -> [Which; LANES] {\n-            let mut idx = [Which::First(0); LANES];\n-            let mut i = 0;\n-            while i < LANES {\n-                let offset = i / 2;\n-                idx[i] = if i % 2 == 0 {\n-                    Which::First(offset)\n-                } else {\n-                    Which::Second(offset)\n-                };\n-                i += 1;\n-            }\n-            idx\n-        }\n-        const fn hi<const LANES: usize>() -> [Which; LANES] {\n+        const fn interleave<const LANES: usize>(high: bool) -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n             let mut i = 0;\n             while i < LANES {\n-                let offset = (LANES + i) / 2;\n-                idx[i] = if i % 2 == 0 {\n-                    Which::First(offset)\n+                // Treat the source as a concatenated vector\n+                let dst_index = if high { i + LANES } else { i };\n+                let src_index = dst_index / 2 + (dst_index % 2) * LANES;\n+                idx[i] = if src_index < LANES {\n+                    Which::First(src_index)\n                 } else {\n-                    Which::Second(offset)\n+                    Which::Second(src_index % LANES)\n                 };\n                 i += 1;\n             }\n@@ -318,11 +303,11 @@ where\n         struct Hi;\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Lo {\n-            const INDEX: [Which; LANES] = lo::<LANES>();\n+            const INDEX: [Which; LANES] = interleave::<LANES>(false);\n         }\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Hi {\n-            const INDEX: [Which; LANES] = hi::<LANES>();\n+            const INDEX: [Which; LANES] = interleave::<LANES>(true);\n         }\n \n         (Lo::swizzle2(self, other), Hi::swizzle2(self, other))\n@@ -336,8 +321,10 @@ where\n     /// The second result takes every other lane of `self` and then `other`, starting with\n     /// the second lane.\n     ///\n+    /// The reverse of this operation is [`Simd::interleave`].\n+    ///\n     /// ```\n-    /// #![feature(portable_simd)]\n+    /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let a = Simd::from_array([0, 4, 1, 5]);\n     /// let b = Simd::from_array([2, 6, 3, 7]);\n@@ -348,22 +335,17 @@ where\n     #[inline]\n     #[must_use = \"method returns a new vector and does not mutate the original inputs\"]\n     pub fn deinterleave(self, other: Self) -> (Self, Self) {\n-        const fn even<const LANES: usize>() -> [Which; LANES] {\n-            let mut idx = [Which::First(0); LANES];\n-            let mut i = 0;\n-            while i < LANES / 2 {\n-                idx[i] = Which::First(2 * i);\n-                idx[i + LANES / 2] = Which::Second(2 * i);\n-                i += 1;\n-            }\n-            idx\n-        }\n-        const fn odd<const LANES: usize>() -> [Which; LANES] {\n+        const fn deinterleave<const LANES: usize>(second: bool) -> [Which; LANES] {\n             let mut idx = [Which::First(0); LANES];\n             let mut i = 0;\n-            while i < LANES / 2 {\n-                idx[i] = Which::First(2 * i + 1);\n-                idx[i + LANES / 2] = Which::Second(2 * i + 1);\n+            while i < LANES {\n+                // Treat the source as a concatenated vector\n+                let src_index = i * 2 + second as usize;\n+                idx[i] = if src_index < LANES {\n+                    Which::First(src_index)\n+                } else {\n+                    Which::Second(src_index % LANES)\n+                };\n                 i += 1;\n             }\n             idx\n@@ -373,11 +355,11 @@ where\n         struct Odd;\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Even {\n-            const INDEX: [Which; LANES] = even::<LANES>();\n+            const INDEX: [Which; LANES] = deinterleave::<LANES>(false);\n         }\n \n         impl<const LANES: usize> Swizzle2<LANES, LANES> for Odd {\n-            const INDEX: [Which; LANES] = odd::<LANES>();\n+            const INDEX: [Which; LANES] = deinterleave::<LANES>(true);\n         }\n \n         (Even::swizzle2(self, other), Odd::swizzle2(self, other))"}, {"sha": "6065d6459378e9fab7b2f05cfa0b8741d2dd994c", "filename": "library/portable-simd/crates/core_simd/src/swizzle_dyn.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fswizzle_dyn.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,157 @@\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use core::mem;\n+\n+impl<const N: usize> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Swizzle a vector of bytes according to the index vector.\n+    /// Indices within range select the appropriate byte.\n+    /// Indices \"out of bounds\" instead select 0.\n+    ///\n+    /// Note that the current implementation is selected during build-time\n+    /// of the standard library, so `cargo build -Zbuild-std` may be necessary\n+    /// to unlock better performance, especially for larger vectors.\n+    /// A planned compiler improvement will enable using `#[target_feature]` instead.\n+    #[inline]\n+    pub fn swizzle_dyn(self, idxs: Simd<u8, N>) -> Self {\n+        #![allow(unused_imports, unused_unsafe)]\n+        #[cfg(target_arch = \"aarch64\")]\n+        use core::arch::aarch64::{uint8x8_t, vqtbl1q_u8, vtbl1_u8};\n+        #[cfg(all(target_arch = \"arm\", target_feature = \"v7\", target_feature = \"neon\"))]\n+        use core::arch::arm::{uint8x8_t, vtbl1_u8};\n+        #[cfg(target_arch = \"wasm32\")]\n+        use core::arch::wasm32 as wasm;\n+        #[cfg(target_arch = \"x86\")]\n+        use core::arch::x86;\n+        #[cfg(target_arch = \"x86_64\")]\n+        use core::arch::x86_64 as x86;\n+        // SAFETY: Intrinsics covered by cfg\n+        unsafe {\n+            match N {\n+                #[cfg(target_feature = \"neon\")]\n+                8 => transize(vtbl1_u8, self, idxs),\n+                #[cfg(target_feature = \"ssse3\")]\n+                16 => transize(x86::_mm_shuffle_epi8, self, idxs),\n+                #[cfg(target_feature = \"simd128\")]\n+                16 => transize(wasm::i8x16_swizzle, self, idxs),\n+                #[cfg(all(target_arch = \"aarch64\", target_feature = \"neon\"))]\n+                16 => transize(vqtbl1q_u8, self, idxs),\n+                #[cfg(all(target_feature = \"avx2\", not(target_feature = \"avx512vbmi\")))]\n+                32 => transize_raw(avx2_pshufb, self, idxs),\n+                #[cfg(target_feature = \"avx512vl,avx512vbmi\")]\n+                32 => transize(x86::_mm256_permutexvar_epi8, self, idxs),\n+                // Notable absence: avx512bw shuffle\n+                // If avx512bw is available, odds of avx512vbmi are good\n+                // FIXME: initial AVX512VBMI variant didn't actually pass muster\n+                // #[cfg(target_feature = \"avx512vbmi\")]\n+                // 64 => transize(x86::_mm512_permutexvar_epi8, self, idxs),\n+                _ => {\n+                    let mut array = [0; N];\n+                    for (i, k) in idxs.to_array().into_iter().enumerate() {\n+                        if (k as usize) < N {\n+                            array[i] = self[k as usize];\n+                        };\n+                    }\n+                    array.into()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// \"vpshufb like it was meant to be\" on AVX2\n+///\n+/// # Safety\n+/// This requires AVX2 to work\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[target_feature(enable = \"avx2\")]\n+#[allow(unused)]\n+#[inline]\n+#[allow(clippy::let_and_return)]\n+unsafe fn avx2_pshufb(bytes: Simd<u8, 32>, idxs: Simd<u8, 32>) -> Simd<u8, 32> {\n+    use crate::simd::SimdPartialOrd;\n+    #[cfg(target_arch = \"x86\")]\n+    use core::arch::x86;\n+    #[cfg(target_arch = \"x86_64\")]\n+    use core::arch::x86_64 as x86;\n+    use x86::_mm256_permute2x128_si256 as avx2_cross_shuffle;\n+    use x86::_mm256_shuffle_epi8 as avx2_half_pshufb;\n+    let mid = Simd::splat(16u8);\n+    let high = mid + mid;\n+    // SAFETY: Caller promised AVX2\n+    unsafe {\n+        // This is ordering sensitive, and LLVM will order these how you put them.\n+        // Most AVX2 impls use ~5 \"ports\", and only 1 or 2 are capable of permutes.\n+        // But the \"compose\" step will lower to ops that can also use at least 1 other port.\n+        // So this tries to break up permutes so composition flows through \"open\" ports.\n+        // Comparative benches should be done on multiple AVX2 CPUs before reordering this\n+\n+        let hihi = avx2_cross_shuffle::<0x11>(bytes.into(), bytes.into());\n+        let hi_shuf = Simd::from(avx2_half_pshufb(\n+            hihi,        // duplicate the vector's top half\n+            idxs.into(), // so that using only 4 bits of an index still picks bytes 16-31\n+        ));\n+        // A zero-fill during the compose step gives the \"all-Neon-like\" OOB-is-0 semantics\n+        let compose = idxs.simd_lt(high).select(hi_shuf, Simd::splat(0));\n+        let lolo = avx2_cross_shuffle::<0x00>(bytes.into(), bytes.into());\n+        let lo_shuf = Simd::from(avx2_half_pshufb(lolo, idxs.into()));\n+        // Repeat, then pick indices < 16, overwriting indices 0-15 from previous compose step\n+        let compose = idxs.simd_lt(mid).select(lo_shuf, compose);\n+        compose\n+    }\n+}\n+\n+/// This sets up a call to an architecture-specific function, and in doing so\n+/// it persuades rustc that everything is the correct size. Which it is.\n+/// This would not be needed if one could convince Rust that, by matching on N,\n+/// N is that value, and thus it would be valid to substitute e.g. 16.\n+///\n+/// # Safety\n+/// The correctness of this function hinges on the sizes agreeing in actuality.\n+#[allow(dead_code)]\n+#[inline(always)]\n+unsafe fn transize<T, const N: usize>(\n+    f: unsafe fn(T, T) -> T,\n+    bytes: Simd<u8, N>,\n+    idxs: Simd<u8, N>,\n+) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    let idxs = zeroing_idxs(idxs);\n+    // SAFETY: Same obligation to use this function as to use mem::transmute_copy.\n+    unsafe { mem::transmute_copy(&f(mem::transmute_copy(&bytes), mem::transmute_copy(&idxs))) }\n+}\n+\n+/// Make indices that yield 0 for this architecture\n+#[inline(always)]\n+fn zeroing_idxs<const N: usize>(idxs: Simd<u8, N>) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    // On x86, make sure the top bit is set.\n+    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+    let idxs = {\n+        use crate::simd::SimdPartialOrd;\n+        idxs.simd_lt(Simd::splat(N as u8))\n+            .select(idxs, Simd::splat(u8::MAX))\n+    };\n+    // Simply do nothing on most architectures.\n+    idxs\n+}\n+\n+/// As transize but no implicit call to `zeroing_idxs`.\n+#[allow(dead_code)]\n+#[inline(always)]\n+unsafe fn transize_raw<T, const N: usize>(\n+    f: unsafe fn(T, T) -> T,\n+    bytes: Simd<u8, N>,\n+    idxs: Simd<u8, N>,\n+) -> Simd<u8, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    // SAFETY: Same obligation to use this function as to use mem::transmute_copy.\n+    unsafe { mem::transmute_copy(&f(mem::transmute_copy(&bytes), mem::transmute_copy(&idxs))) }\n+}"}, {"sha": "3809cc961515b691663523fb962fcc671a8fff14", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 475, "deletions": 190, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,60 +1,63 @@\n-mod float;\n-mod int;\n-mod uint;\n-\n-pub use float::*;\n-pub use int::*;\n-pub use uint::*;\n-\n-// Vectors of pointers are not for public use at the current time.\n-pub(crate) mod ptr;\n-\n use crate::simd::{\n-    intrinsics, LaneCount, Mask, MaskElement, SimdPartialOrd, SupportedLaneCount, Swizzle,\n+    intrinsics, LaneCount, Mask, MaskElement, SimdCast, SimdCastPtr, SimdConstPtr, SimdMutPtr,\n+    SimdPartialOrd, SupportedLaneCount, Swizzle,\n };\n+use core::convert::{TryFrom, TryInto};\n \n-/// A SIMD vector of `LANES` elements of type `T`. `Simd<T, N>` has the same shape as [`[T; N]`](array), but operates like `T`.\n+/// A SIMD vector with the shape of `[T; N]` but the operations of `T`.\n ///\n-/// Two vectors of the same type and length will, by convention, support the operators (+, *, etc.) that `T` does.\n-/// These take the lanes at each index on the left-hand side and right-hand side, perform the operation,\n-/// and return the result in the same lane in a vector of equal size. For a given operator, this is equivalent to zipping\n-/// the two arrays together and mapping the operator over each lane.\n+/// `Simd<T, N>` supports the operators (+, *, etc.) that `T` does in \"elementwise\" fashion.\n+/// These take the element at each index from the left-hand side and right-hand side,\n+/// perform the operation, then return the result in the same index in a vector of equal size.\n+/// However, `Simd` differs from normal iteration and normal arrays:\n+/// - `Simd<T, N>` executes `N` operations in a single step with no `break`s\n+/// - `Simd<T, N>` can have an alignment greater than `T`, for better mechanical sympathy\n+///\n+/// By always imposing these constraints on `Simd`, it is easier to compile elementwise operations\n+/// into machine instructions that can themselves be executed in parallel.\n ///\n /// ```rust\n-/// # #![feature(array_zip, portable_simd)]\n+/// # #![feature(portable_simd)]\n /// # use core::simd::{Simd};\n-/// let a0: [i32; 4] = [-2, 0, 2, 4];\n-/// let a1 = [10, 9, 8, 7];\n-/// let zm_add = a0.zip(a1).map(|(lhs, rhs)| lhs + rhs);\n-/// let zm_mul = a0.zip(a1).map(|(lhs, rhs)| lhs * rhs);\n+/// # use core::array;\n+/// let a: [i32; 4] = [-2, 0, 2, 4];\n+/// let b = [10, 9, 8, 7];\n+/// let sum = array::from_fn(|i| a[i] + b[i]);\n+/// let prod = array::from_fn(|i| a[i] * b[i]);\n ///\n /// // `Simd<T, N>` implements `From<[T; N]>`\n-/// let (v0, v1) = (Simd::from(a0), Simd::from(a1));\n+/// let (v, w) = (Simd::from(a), Simd::from(b));\n /// // Which means arrays implement `Into<Simd<T, N>>`.\n-/// assert_eq!(v0 + v1, zm_add.into());\n-/// assert_eq!(v0 * v1, zm_mul.into());\n+/// assert_eq!(v + w, sum.into());\n+/// assert_eq!(v * w, prod.into());\n /// ```\n ///\n-/// `Simd` with integers has the quirk that these operations are also inherently wrapping, as if `T` was [`Wrapping<T>`].\n+///\n+/// `Simd` with integer elements treats operators as wrapping, as if `T` was [`Wrapping<T>`].\n /// Thus, `Simd` does not implement `wrapping_add`, because that is the default behavior.\n /// This means there is no warning on overflows, even in \"debug\" builds.\n /// For most applications where `Simd` is appropriate, it is \"not a bug\" to wrap,\n /// and even \"debug builds\" are unlikely to tolerate the loss of performance.\n /// You may want to consider using explicitly checked arithmetic if such is required.\n-/// Division by zero still causes a panic, so you may want to consider using floating point numbers if that is unacceptable.\n+/// Division by zero on integers still causes a panic, so\n+/// you may want to consider using `f32` or `f64` if that is unacceptable.\n ///\n /// [`Wrapping<T>`]: core::num::Wrapping\n ///\n /// # Layout\n-/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), but with a greater alignment.\n+/// `Simd<T, N>` has a layout similar to `[T; N]` (identical \"shapes\"), with a greater alignment.\n /// `[T; N]` is aligned to `T`, but `Simd<T, N>` will have an alignment based on both `T` and `N`.\n-/// It is thus sound to [`transmute`] `Simd<T, N>` to `[T; N]`, and will typically optimize to zero cost,\n-/// but the reverse transmutation is more likely to require a copy the compiler cannot simply elide.\n+/// Thus it is sound to [`transmute`] `Simd<T, N>` to `[T; N]` and should optimize to \"zero cost\",\n+/// but the reverse transmutation may require a copy the compiler cannot simply elide.\n ///\n /// # ABI \"Features\"\n-/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed to and from functions via memory, not SIMD registers,\n-/// except as an optimization. `#[inline]` hints are recommended on functions that accept `Simd<T, N>` or return it.\n-/// The need for this may be corrected in the future.\n+/// Due to Rust's safety guarantees, `Simd<T, N>` is currently passed and returned via memory,\n+/// not SIMD registers, except as an optimization. Using `#[inline]` on functions that accept\n+/// `Simd<T, N>` or return it is recommended, at the cost of code generation time, as\n+/// inlining SIMD-using functions can omit a large function prolog or epilog and thus\n+/// improve both speed and code size. The need for this may be corrected in the future.\n+///\n+/// Using `#[inline(always)]` still requires additional care.\n ///\n /// # Safe SIMD with Unsafe Rust\n ///\n@@ -65,18 +68,22 @@ use crate::simd::{\n /// Thus, when using `unsafe` Rust to read and write `Simd<T, N>` through [raw pointers], it is a good idea to first try with\n /// [`read_unaligned`] and [`write_unaligned`]. This is because:\n /// - [`read`] and [`write`] require full alignment (in this case, `Simd<T, N>`'s alignment)\n-/// - the likely source for reading or destination for writing `Simd<T, N>` is [`[T]`](slice) and similar types, aligned to `T`\n-/// - combining these actions would violate the `unsafe` contract and explode the program into a puff of **undefined behavior**\n-/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned if it sees the optimization\n-/// - most contemporary processors suffer no performance penalty for \"unaligned\" reads and writes that are aligned at runtime\n+/// - `Simd<T, N>` is often read from or written to [`[T]`](slice) and other types aligned to `T`\n+/// - combining these actions violates the `unsafe` contract and explodes the program into\n+///   a puff of **undefined behavior**\n+/// - the compiler can implicitly adjust layouts to make unaligned reads or writes fully aligned\n+///   if it sees the optimization\n+/// - most contemporary processors with \"aligned\" and \"unaligned\" read and write instructions\n+///   exhibit no performance difference if the \"unaligned\" variant is aligned at runtime\n ///\n-/// By imposing less obligations, unaligned functions are less likely to make the program unsound,\n+/// Less obligations mean unaligned reads and writes are less likely to make the program unsound,\n /// and may be just as fast as stricter alternatives.\n-/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for converting `[T]` to `[Simd<T, N>]`,\n-/// and allows soundly operating on an aligned SIMD body, but it may cost more time when handling the scalar head and tail.\n-/// If these are not sufficient, then it is most ideal to design data structures to be already aligned\n-/// to the `Simd<T, N>` you wish to use before using `unsafe` Rust to read or write.\n-/// More conventional ways to compensate for these facts, like materializing `Simd` to or from an array first,\n+/// When trying to guarantee alignment, [`[T]::as_simd`][as_simd] is an option for\n+/// converting `[T]` to `[Simd<T, N>]`, and allows soundly operating on an aligned SIMD body,\n+/// but it may cost more time when handling the scalar head and tail.\n+/// If these are not enough, it is most ideal to design data structures to be already aligned\n+/// to `mem::align_of::<Simd<T, N>>()` before using `unsafe` Rust to read or write.\n+/// Other ways to compensate for these facts, like materializing `Simd` to or from an array first,\n /// are handled by safe methods like [`Simd::from_array`] and [`Simd::from_slice`].\n ///\n /// [`transmute`]: core::mem::transmute\n@@ -86,21 +93,26 @@ use crate::simd::{\n /// [`read`]: pointer::read\n /// [`write`]: pointer::write\n /// [as_simd]: slice::as_simd\n+//\n+// NOTE: Accessing the inner array directly in any way (e.g. by using the `.0` field syntax) or\n+// directly constructing an instance of the type (i.e. `let vector = Simd(array)`) should be\n+// avoided, as it will likely become illegal on `#[repr(simd)]` structs in the future. It also\n+// causes rustc to emit illegal LLVM IR in some cases.\n #[repr(simd)]\n-pub struct Simd<T, const LANES: usize>([T; LANES])\n+pub struct Simd<T, const N: usize>([T; N])\n where\n-    T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount;\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement;\n \n-impl<T, const LANES: usize> Simd<T, LANES>\n+impl<T, const N: usize> Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    /// Number of lanes in this vector.\n-    pub const LANES: usize = LANES;\n+    /// Number of elements in this vector.\n+    pub const LANES: usize = N;\n \n-    /// Returns the number of lanes in this SIMD vector.\n+    /// Returns the number of elements in this SIMD vector.\n     ///\n     /// # Examples\n     ///\n@@ -111,10 +123,10 @@ where\n     /// assert_eq!(v.lanes(), 4);\n     /// ```\n     pub const fn lanes(&self) -> usize {\n-        LANES\n+        Self::LANES\n     }\n \n-    /// Constructs a new SIMD vector with all lanes set to the given value.\n+    /// Constructs a new SIMD vector with all elements set to the given value.\n     ///\n     /// # Examples\n     ///\n@@ -125,11 +137,11 @@ where\n     /// assert_eq!(v.as_array(), &[8, 8, 8, 8]);\n     /// ```\n     pub fn splat(value: T) -> Self {\n-        // This is preferred over `[value; LANES]`, since it's explicitly a splat:\n+        // This is preferred over `[value; N]`, since it's explicitly a splat:\n         // https://github.com/rust-lang/rust/issues/97804\n         struct Splat;\n-        impl<const LANES: usize> Swizzle<1, LANES> for Splat {\n-            const INDEX: [usize; LANES] = [0; LANES];\n+        impl<const N: usize> Swizzle<1, N> for Splat {\n+            const INDEX: [usize; N] = [0; N];\n         }\n         Splat::swizzle(Simd::<T, 1>::from([value]))\n     }\n@@ -144,32 +156,100 @@ where\n     /// let v: u64x4 = Simd::from_array([0, 1, 2, 3]);\n     /// assert_eq!(v.as_array(), &[0, 1, 2, 3]);\n     /// ```\n-    pub const fn as_array(&self) -> &[T; LANES] {\n-        &self.0\n+    pub const fn as_array(&self) -> &[T; N] {\n+        // SAFETY: `Simd<T, N>` is just an overaligned `[T; N]` with\n+        // potential padding at the end, so pointer casting to a\n+        // `&[T; N]` is safe.\n+        //\n+        // NOTE: This deliberately doesn't just use `&self.0`, see the comment\n+        // on the struct definition for details.\n+        unsafe { &*(self as *const Self as *const [T; N]) }\n     }\n \n     /// Returns a mutable array reference containing the entire SIMD vector.\n-    pub fn as_mut_array(&mut self) -> &mut [T; LANES] {\n-        &mut self.0\n+    pub fn as_mut_array(&mut self) -> &mut [T; N] {\n+        // SAFETY: `Simd<T, N>` is just an overaligned `[T; N]` with\n+        // potential padding at the end, so pointer casting to a\n+        // `&mut [T; N]` is safe.\n+        //\n+        // NOTE: This deliberately doesn't just use `&mut self.0`, see the comment\n+        // on the struct definition for details.\n+        unsafe { &mut *(self as *mut Self as *mut [T; N]) }\n+    }\n+\n+    /// Load a vector from an array of `T`.\n+    ///\n+    /// This function is necessary since `repr(simd)` has padding for non-power-of-2 vectors (at the time of writing).\n+    /// With padding, `read_unaligned` will read past the end of an array of N elements.\n+    ///\n+    /// # Safety\n+    /// Reading `ptr` must be safe, as if by `<*const [T; N]>::read_unaligned`.\n+    const unsafe fn load(ptr: *const [T; N]) -> Self {\n+        // There are potentially simpler ways to write this function, but this should result in\n+        // LLVM `load <N x T>`\n+\n+        let mut tmp = core::mem::MaybeUninit::<Self>::uninit();\n+        // SAFETY: `Simd<T, N>` always contains `N` elements of type `T`.  It may have padding\n+        // which does not need to be initialized.  The safety of reading `ptr` is ensured by the\n+        // caller.\n+        unsafe {\n+            core::ptr::copy_nonoverlapping(ptr, tmp.as_mut_ptr().cast(), 1);\n+            tmp.assume_init()\n+        }\n+    }\n+\n+    /// Store a vector to an array of `T`.\n+    ///\n+    /// See `load` as to why this function is necessary.\n+    ///\n+    /// # Safety\n+    /// Writing to `ptr` must be safe, as if by `<*mut [T; N]>::write_unaligned`.\n+    const unsafe fn store(self, ptr: *mut [T; N]) {\n+        // There are potentially simpler ways to write this function, but this should result in\n+        // LLVM `store <N x T>`\n+\n+        // Creating a temporary helps LLVM turn the memcpy into a store.\n+        let tmp = self;\n+        // SAFETY: `Simd<T, N>` always contains `N` elements of type `T`.  The safety of writing\n+        // `ptr` is ensured by the caller.\n+        unsafe { core::ptr::copy_nonoverlapping(tmp.as_array(), ptr, 1) }\n     }\n \n     /// Converts an array to a SIMD vector.\n-    pub const fn from_array(array: [T; LANES]) -> Self {\n-        Self(array)\n+    pub const fn from_array(array: [T; N]) -> Self {\n+        // SAFETY: `&array` is safe to read.\n+        //\n+        // FIXME: We currently use a pointer load instead of `transmute_copy` because `repr(simd)`\n+        // results in padding for non-power-of-2 vectors (so vectors are larger than arrays).\n+        //\n+        // NOTE: This deliberately doesn't just use `Self(array)`, see the comment\n+        // on the struct definition for details.\n+        unsafe { Self::load(&array) }\n     }\n \n     /// Converts a SIMD vector to an array.\n-    pub const fn to_array(self) -> [T; LANES] {\n-        self.0\n+    pub const fn to_array(self) -> [T; N] {\n+        let mut tmp = core::mem::MaybeUninit::uninit();\n+        // SAFETY: writing to `tmp` is safe and initializes it.\n+        //\n+        // FIXME: We currently use a pointer store instead of `transmute_copy` because `repr(simd)`\n+        // results in padding for non-power-of-2 vectors (so vectors are larger than arrays).\n+        //\n+        // NOTE: This deliberately doesn't just use `self.0`, see the comment\n+        // on the struct definition for details.\n+        unsafe {\n+            self.store(tmp.as_mut_ptr());\n+            tmp.assume_init()\n+        }\n     }\n \n-    /// Converts a slice to a SIMD vector containing `slice[..LANES]`.\n+    /// Converts a slice to a SIMD vector containing `slice[..N]`.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the slice's length is less than the vector's `Simd::LANES`.\n+    /// Panics if the slice's length is less than the vector's `Simd::N`.\n     ///\n-    /// # Examples\n+    /// # Example\n     ///\n     /// ```\n     /// # #![feature(portable_simd)]\n@@ -180,22 +260,49 @@ where\n     /// ```\n     #[must_use]\n     pub const fn from_slice(slice: &[T]) -> Self {\n-        assert!(slice.len() >= LANES, \"slice length must be at least the number of lanes\");\n-        let mut array = [slice[0]; LANES];\n-        let mut i = 0;\n-        while i < LANES {\n-            array[i] = slice[i];\n-            i += 1;\n-        }\n-        Self(array)\n+        assert!(\n+            slice.len() >= Self::LANES,\n+            \"slice length must be at least the number of elements\"\n+        );\n+        // SAFETY: We just checked that the slice contains\n+        // at least `N` elements.\n+        unsafe { Self::load(slice.as_ptr().cast()) }\n+    }\n+\n+    /// Writes a SIMD vector to the first `N` elements of a slice.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the slice's length is less than the vector's `Simd::N`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::u32x4;\n+    /// let mut dest = vec![0; 6];\n+    /// let v = u32x4::from_array([1, 2, 3, 4]);\n+    /// v.copy_to_slice(&mut dest);\n+    /// assert_eq!(&dest, &[1, 2, 3, 4, 0, 0]);\n+    /// ```\n+    pub fn copy_to_slice(self, slice: &mut [T]) {\n+        assert!(\n+            slice.len() >= Self::LANES,\n+            \"slice length must be at least the number of elements\"\n+        );\n+        // SAFETY: We just checked that the slice contains\n+        // at least `N` elements.\n+        unsafe { self.store(slice.as_mut_ptr().cast()) }\n     }\n \n-    /// Performs lanewise conversion of a SIMD vector's elements to another SIMD-valid type.\n+    /// Performs elementwise conversion of a SIMD vector's elements to another SIMD-valid type.\n     ///\n-    /// This follows the semantics of Rust's `as` conversion for casting\n-    /// integers to unsigned integers (interpreting as the other type, so `-1` to `MAX`),\n-    /// and from floats to integers (truncating, or saturating at the limits) for each lane,\n-    /// or vice versa.\n+    /// This follows the semantics of Rust's `as` conversion for casting integers between\n+    /// signed and unsigned (interpreting integers as 2s complement, so `-1` to `U::MAX` and\n+    /// `1 << (U::BITS -1)` becoming `I::MIN` ), and from floats to integers (truncating,\n+    /// or saturating at the limits) for each element.\n     ///\n     /// # Examples\n     /// ```\n@@ -215,11 +322,26 @@ where\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n-        // Safety: The input argument is a vector of a valid SIMD element type.\n+    pub fn cast<U: SimdCast>(self) -> Simd<U, N>\n+    where\n+        T: SimdCast,\n+    {\n+        // Safety: supported types are guaranteed by SimdCast\n         unsafe { intrinsics::simd_as(self) }\n     }\n \n+    /// Casts a vector of pointers to another pointer type.\n+    #[must_use]\n+    #[inline]\n+    pub fn cast_ptr<U>(self) -> Simd<U, N>\n+    where\n+        T: SimdCastPtr<U>,\n+        U: SimdElement,\n+    {\n+        // Safety: supported types are guaranteed by SimdCastPtr\n+        unsafe { intrinsics::simd_cast_ptr(self) }\n+    }\n+\n     /// Rounds toward zero and converts to the same-width integer type, assuming that\n     /// the value is finite and fits in that type.\n     ///\n@@ -235,90 +357,90 @@ where\n     ///\n     /// [cast]: Simd::cast\n     #[inline]\n-    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, LANES>\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn to_int_unchecked<I>(self) -> Simd<I, N>\n     where\n-        T: core::convert::FloatToInt<I>,\n-        I: SimdElement,\n+        T: core::convert::FloatToInt<I> + SimdCast,\n+        I: SimdCast,\n     {\n-        // Safety: `self` is a vector, and `FloatToInt` ensures the type can be casted to\n-        // an integer.\n+        // Safety: supported types are guaranteed by SimdCast, the caller is responsible for the extra invariants\n         unsafe { intrinsics::simd_cast(self) }\n     }\n \n     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n+    /// If an index is out-of-bounds, the element is instead selected from the `or` vector.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);  // Note the index that is out-of-bounds\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n     ///\n-    /// let result = Simd::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_or(&vec, idxs, alt);\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or(slice: &[T], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+    pub fn gather_or(slice: &[T], idxs: Simd<usize, N>, or: Self) -> Self {\n         Self::gather_select(slice, Mask::splat(true), idxs, or)\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// If an index is out-of-bounds, the lane is set to the default value for the type.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// If an index is out-of-bounds, the element is set to the default given by `T: Default`.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);  // Note the index that is out-of-bounds\n     ///\n-    /// let result = Simd::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_or_default(&vec, idxs);\n     /// assert_eq!(result, Simd::from_array([0, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, LANES>) -> Self\n+    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, N>) -> Self\n     where\n         T: Default,\n     {\n         Self::gather_or(slice, idxs, Self::splat(T::default()))\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an index is disabled or is out-of-bounds, the lane is selected from the `or` vector.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an index is disabled or is out-of-bounds, the element is selected from the `or` vector.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::{Simd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     ///\n-    /// let result = Simd::gather_select(&vec, enable, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// let result = Simd::gather_select(&vec, enable, idxs, alt);\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     #[must_use]\n     #[inline]\n     pub fn gather_select(\n         slice: &[T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n         or: Self,\n     ) -> Self {\n-        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n-        // Safety: We have masked-off out-of-bounds lanes.\n+        let enable: Mask<isize, N> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n+        // Safety: We have masked-off out-of-bounds indices.\n         unsafe { Self::gather_select_unchecked(slice, enable, idxs, or) }\n     }\n \n-    /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an index is disabled, the lane is selected from the `or` vector.\n+    /// Reads from indices in `slice` to construct a SIMD vector.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an index is disabled, the element is selected from the `or` vector.\n     ///\n     /// # Safety\n     ///\n@@ -332,57 +454,123 @@ where\n     /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n     /// # use simd::{Simd, SimdPartialOrd, Mask};\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]); // Includes an out-of-bounds index\n     /// let alt = Simd::from_array([-5, -4, -3, -2]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the final mask lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     /// // If this mask was used to gather, it would be unsound. Let's fix that.\n     /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n-    /// // We have masked the OOB lane, so it's safe to gather now.\n+    /// // The out-of-bounds index has been masked, so it's safe to gather now.\n     /// let result = unsafe { Simd::gather_select_unchecked(&vec, enable, idxs, alt) };\n     /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     #[must_use]\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn gather_select_unchecked(\n         slice: &[T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n         or: Self,\n     ) -> Self {\n-        let base_ptr = crate::simd::ptr::SimdConstPtr::splat(slice.as_ptr());\n+        let base_ptr = Simd::<*const T, N>::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n-        // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-        unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n+        // Safety: The caller is responsible for determining the indices are okay to read\n+        unsafe { Self::gather_select_ptr(ptrs, enable, or) }\n+    }\n+\n+    /// Read elementwise from pointers into a SIMD vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Each read must satisfy the same conditions as [`core::ptr::read`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdConstPtr};\n+    /// let values = [6, 2, 4, 9];\n+    /// let offsets = Simd::from_array([1, 0, 0, 3]);\n+    /// let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n+    /// let gathered = unsafe { Simd::gather_ptr(source) };\n+    /// assert_eq!(gathered, Simd::from_array([2, 6, 6, 9]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn gather_ptr(source: Simd<*const T, N>) -> Self\n+    where\n+        T: Default,\n+    {\n+        // TODO: add an intrinsic that doesn't use a passthru vector, and remove the T: Default bound\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { Self::gather_select_ptr(source, Mask::splat(true), Self::default()) }\n+    }\n+\n+    /// Conditionally read elementwise from pointers into a SIMD vector.\n+    /// The mask `enable`s all `true` pointers and disables all `false` pointers.\n+    /// If a pointer is disabled, the element is selected from the `or` vector,\n+    /// and no read is performed.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Enabled elements must satisfy the same conditions as [`core::ptr::read`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Mask, Simd, SimdConstPtr};\n+    /// let values = [6, 2, 4, 9];\n+    /// let enable = Mask::from_array([true, true, false, true]);\n+    /// let offsets = Simd::from_array([1, 0, 0, 3]);\n+    /// let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n+    /// let gathered = unsafe { Simd::gather_select_ptr(source, enable, Simd::splat(0)) };\n+    /// assert_eq!(gathered, Simd::from_array([2, 6, 0, 9]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn gather_select_ptr(\n+        source: Simd<*const T, N>,\n+        enable: Mask<isize, N>,\n+        or: Self,\n+    ) -> Self {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { intrinsics::simd_gather(or, source, enable.to_int()) }\n     }\n \n     /// Writes the values in a SIMD vector to potentially discontiguous indices in `slice`.\n-    /// If two lanes in the scattered vector would write to the same index\n-    /// only the last lane is guaranteed to actually be written.\n+    /// If an index is out-of-bounds, the write is suppressed without panicking.\n+    /// If two elements in the scattered vector would write to the same index\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Examples\n     /// ```\n     /// # #![feature(portable_simd)]\n     /// # use core::simd::Simd;\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]); // Note the duplicate index.\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n     ///\n-    /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n+    /// vals.scatter(&mut vec, idxs); // two logical writes means the last wins.\n     /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, LANES>) {\n+    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, N>) {\n         self.scatter_select(slice, Mask::splat(true), idxs)\n     }\n \n-    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If an enabled index is out-of-bounds, the lane is not written.\n-    /// If two enabled lanes in the scattered vector would write to the same index,\n-    /// only the last lane is guaranteed to actually be written.\n+    /// Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If an enabled index is out-of-bounds, the write is suppressed without panicking.\n+    /// If two enabled elements in the scattered vector would write to the same index,\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Examples\n     /// ```\n@@ -391,29 +579,24 @@ where\n     /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n     /// # use simd::{Simd, Mask};\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]); // Includes an out-of-bounds index\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Includes a masked element\n     ///\n-    /// vals.scatter_select(&mut vec, enable, idxs); // index 0's second write is masked, thus omitted.\n+    /// vals.scatter_select(&mut vec, enable, idxs); // The last write is masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter_select(\n-        self,\n-        slice: &mut [T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n-    ) {\n-        let enable: Mask<isize, LANES> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n-        // Safety: We have masked-off out-of-bounds lanes.\n+    pub fn scatter_select(self, slice: &mut [T], enable: Mask<isize, N>, idxs: Simd<usize, N>) {\n+        let enable: Mask<isize, N> = enable & idxs.simd_lt(Simd::splat(slice.len()));\n+        // Safety: We have masked-off out-of-bounds indices.\n         unsafe { self.scatter_select_unchecked(slice, enable, idxs) }\n     }\n \n-    /// Writes the values in a SIMD vector to multiple potentially discontiguous indices in `slice`.\n-    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n-    /// If two enabled lanes in the scattered vector would write to the same index,\n-    /// only the last lane is guaranteed to actually be written.\n+    /// Writes values from a SIMD vector to multiple potentially discontiguous indices in `slice`.\n+    /// The mask `enable`s all `true` indices and disables all `false` indices.\n+    /// If two enabled elements in the scattered vector would write to the same index,\n+    /// only the last element is guaranteed to actually be written.\n     ///\n     /// # Safety\n     ///\n@@ -429,22 +612,23 @@ where\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n     /// let idxs = Simd::from_array([9, 3, 0, 0]);\n     /// let vals = Simd::from_array([-27, 82, -41, 124]);\n-    /// let enable = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let enable = Mask::from_array([true, true, true, false]); // Masks the final index\n     /// // If this mask was used to scatter, it would be unsound. Let's fix that.\n     /// let enable = enable & idxs.simd_lt(Simd::splat(vec.len()));\n     ///\n-    /// // We have masked the OOB lane, so it's safe to scatter now.\n+    /// // We have masked the OOB index, so it's safe to scatter now.\n     /// unsafe { vals.scatter_select_unchecked(&mut vec, enable, idxs); }\n-    /// // index 0's second write is masked, thus was omitted.\n+    /// // The second write to index 0 was masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n     pub unsafe fn scatter_select_unchecked(\n         self,\n         slice: &mut [T],\n-        enable: Mask<isize, LANES>,\n-        idxs: Simd<usize, LANES>,\n+        enable: Mask<isize, N>,\n+        idxs: Simd<usize, N>,\n     ) {\n         // Safety: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n@@ -458,36 +642,89 @@ where\n         // 3. &mut [T] which will become our base ptr.\n         unsafe {\n             // Now Entering \u2622\ufe0f *mut T Zone\n-            let base_ptr = crate::simd::ptr::SimdMutPtr::splat(slice.as_mut_ptr());\n+            let base_ptr = Simd::<*mut T, N>::splat(slice.as_mut_ptr());\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-            intrinsics::simd_scatter(self, ptrs, enable.to_int())\n+            self.scatter_select_ptr(ptrs, enable);\n             // Cleared \u2622\ufe0f *mut T Zone\n         }\n     }\n+\n+    /// Write pointers elementwise into a SIMD vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Each write must satisfy the same conditions as [`core::ptr::write`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdMutPtr};\n+    /// let mut values = [0; 4];\n+    /// let offset = Simd::from_array([3, 2, 1, 0]);\n+    /// let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n+    /// unsafe { Simd::from_array([6, 3, 5, 7]).scatter_ptr(ptrs); }\n+    /// assert_eq!(values, [7, 5, 3, 6]);\n+    /// ```\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, N>) {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { self.scatter_select_ptr(dest, Mask::splat(true)) }\n+    }\n+\n+    /// Conditionally write pointers elementwise into a SIMD vector.\n+    /// The mask `enable`s all `true` pointers and disables all `false` pointers.\n+    /// If a pointer is disabled, the write to its pointee is skipped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Enabled pointers must satisfy the same conditions as [`core::ptr::write`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Mask, Simd, SimdMutPtr};\n+    /// let mut values = [0; 4];\n+    /// let offset = Simd::from_array([3, 2, 1, 0]);\n+    /// let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n+    /// let enable = Mask::from_array([true, true, false, false]);\n+    /// unsafe { Simd::from_array([6, 3, 5, 7]).scatter_select_ptr(ptrs, enable); }\n+    /// assert_eq!(values, [0, 0, 3, 6]);\n+    /// ```\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn scatter_select_ptr(self, dest: Simd<*mut T, N>, enable: Mask<isize, N>) {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { intrinsics::simd_scatter(self, dest, enable.to_int()) }\n+    }\n }\n \n-impl<T, const LANES: usize> Copy for Simd<T, LANES>\n+impl<T, const N: usize> Copy for Simd<T, N>\n where\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<T, const LANES: usize> Clone for Simd<T, LANES>\n+impl<T, const N: usize> Clone for Simd<T, N>\n where\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n-    LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<T, const LANES: usize> Default for Simd<T, LANES>\n+impl<T, const N: usize> Default for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Default,\n {\n     #[inline]\n@@ -496,20 +733,20 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> PartialEq for Simd<T, LANES>\n+impl<T, const N: usize> PartialEq for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + PartialEq,\n {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n         // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n         let mask = unsafe {\n-            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_eq(*self, *other);\n+            let tfvec: Simd<<T as SimdElement>::Mask, N> = intrinsics::simd_eq(*self, *other);\n             Mask::from_int_unchecked(tfvec)\n         };\n \n-        // Two vectors are equal if all lanes tested true for vertical equality.\n+        // Two vectors are equal if all elements are equal when compared elementwise\n         mask.all()\n     }\n \n@@ -518,18 +755,18 @@ where\n     fn ne(&self, other: &Self) -> bool {\n         // Safety: All SIMD vectors are SimdPartialEq, and the comparison produces a valid mask.\n         let mask = unsafe {\n-            let tfvec: Simd<<T as SimdElement>::Mask, LANES> = intrinsics::simd_ne(*self, *other);\n+            let tfvec: Simd<<T as SimdElement>::Mask, N> = intrinsics::simd_ne(*self, *other);\n             Mask::from_int_unchecked(tfvec)\n         };\n \n-        // Two vectors are non-equal if any lane tested true for vertical non-equality.\n+        // Two vectors are non-equal if any elements are non-equal when compared elementwise\n         mask.any()\n     }\n }\n \n-impl<T, const LANES: usize> PartialOrd for Simd<T, LANES>\n+impl<T, const N: usize> PartialOrd for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + PartialOrd,\n {\n     #[inline]\n@@ -539,16 +776,16 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> Eq for Simd<T, LANES>\n+impl<T, const N: usize> Eq for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Eq,\n {\n }\n \n-impl<T, const LANES: usize> Ord for Simd<T, LANES>\n+impl<T, const N: usize> Ord for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + Ord,\n {\n     #[inline]\n@@ -558,9 +795,9 @@ where\n     }\n }\n \n-impl<T, const LANES: usize> core::hash::Hash for Simd<T, LANES>\n+impl<T, const N: usize> core::hash::Hash for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement + core::hash::Hash,\n {\n     #[inline]\n@@ -573,72 +810,96 @@ where\n }\n \n // array references\n-impl<T, const LANES: usize> AsRef<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> AsRef<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n-    fn as_ref(&self) -> &[T; LANES] {\n-        &self.0\n+    fn as_ref(&self) -> &[T; N] {\n+        self.as_array()\n     }\n }\n \n-impl<T, const LANES: usize> AsMut<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> AsMut<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n-    fn as_mut(&mut self) -> &mut [T; LANES] {\n-        &mut self.0\n+    fn as_mut(&mut self) -> &mut [T; N] {\n+        self.as_mut_array()\n     }\n }\n \n // slice references\n-impl<T, const LANES: usize> AsRef<[T]> for Simd<T, LANES>\n+impl<T, const N: usize> AsRef<[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n     fn as_ref(&self) -> &[T] {\n-        &self.0\n+        self.as_array()\n     }\n }\n \n-impl<T, const LANES: usize> AsMut<[T]> for Simd<T, LANES>\n+impl<T, const N: usize> AsMut<[T]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n     #[inline]\n     fn as_mut(&mut self) -> &mut [T] {\n-        &mut self.0\n+        self.as_mut_array()\n     }\n }\n \n // vector/array conversion\n-impl<T, const LANES: usize> From<[T; LANES]> for Simd<T, LANES>\n+impl<T, const N: usize> From<[T; N]> for Simd<T, N>\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    fn from(array: [T; LANES]) -> Self {\n-        Self(array)\n+    fn from(array: [T; N]) -> Self {\n+        Self::from_array(array)\n     }\n }\n \n-impl<T, const LANES: usize> From<Simd<T, LANES>> for [T; LANES]\n+impl<T, const N: usize> From<Simd<T, N>> for [T; N]\n where\n-    LaneCount<LANES>: SupportedLaneCount,\n+    LaneCount<N>: SupportedLaneCount,\n     T: SimdElement,\n {\n-    fn from(vector: Simd<T, LANES>) -> Self {\n+    fn from(vector: Simd<T, N>) -> Self {\n         vector.to_array()\n     }\n }\n \n+impl<T, const N: usize> TryFrom<&[T]> for Simd<T, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    type Error = core::array::TryFromSliceError;\n+\n+    fn try_from(slice: &[T]) -> Result<Self, core::array::TryFromSliceError> {\n+        Ok(Self::from_array(slice.try_into()?))\n+    }\n+}\n+\n+impl<T, const N: usize> TryFrom<&mut [T]> for Simd<T, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+    T: SimdElement,\n+{\n+    type Error = core::array::TryFromSliceError;\n+\n+    fn try_from(slice: &mut [T]) -> Result<Self, core::array::TryFromSliceError> {\n+        Ok(Self::from_array(slice.try_into()?))\n+    }\n+}\n+\n mod sealed {\n     pub trait Sealed {}\n }\n@@ -740,3 +1001,27 @@ impl Sealed for f64 {}\n unsafe impl SimdElement for f64 {\n     type Mask = i64;\n }\n+\n+impl<T> Sealed for *const T {}\n+\n+// Safety: (thin) const pointers are valid SIMD element types, and are supported by this API\n+//\n+// Fat pointers may be supported in the future.\n+unsafe impl<T> SimdElement for *const T\n+where\n+    T: core::ptr::Pointee<Metadata = ()>,\n+{\n+    type Mask = isize;\n+}\n+\n+impl<T> Sealed for *mut T {}\n+\n+// Safety: (thin) mut pointers are valid SIMD element types, and are supported by this API\n+//\n+// Fat pointers may be supported in the future.\n+unsafe impl<T> SimdElement for *mut T\n+where\n+    T: core::ptr::Pointee<Metadata = ()>,\n+{\n+    type Mask = isize;\n+}"}, {"sha": "f836c99b1e2dc41564f0e85ad648f5ad2d476c04", "filename": "library/portable-simd/crates/core_simd/src/vector/float.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=01937562505363962cf7a5c45a81d82cfe79dd4f", "patch": "@@ -1,24 +0,0 @@\n-#![allow(non_camel_case_types)]\n-\n-use crate::simd::Simd;\n-\n-/// A 64-bit SIMD vector with two elements of type `f32`.\n-pub type f32x2 = Simd<f32, 2>;\n-\n-/// A 128-bit SIMD vector with four elements of type `f32`.\n-pub type f32x4 = Simd<f32, 4>;\n-\n-/// A 256-bit SIMD vector with eight elements of type `f32`.\n-pub type f32x8 = Simd<f32, 8>;\n-\n-/// A 512-bit SIMD vector with 16 elements of type `f32`.\n-pub type f32x16 = Simd<f32, 16>;\n-\n-/// A 128-bit SIMD vector with two elements of type `f64`.\n-pub type f64x2 = Simd<f64, 2>;\n-\n-/// A 256-bit SIMD vector with four elements of type `f64`.\n-pub type f64x4 = Simd<f64, 4>;\n-\n-/// A 512-bit SIMD vector with eight elements of type `f64`.\n-pub type f64x8 = Simd<f64, 8>;"}, {"sha": "20e56c7dc6443bdca6b8922dc3659e4f554c665e", "filename": "library/portable-simd/crates/core_simd/src/vector/int.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=01937562505363962cf7a5c45a81d82cfe79dd4f", "patch": "@@ -1,63 +0,0 @@\n-#![allow(non_camel_case_types)]\n-\n-use crate::simd::Simd;\n-\n-/// A SIMD vector with two elements of type `isize`.\n-pub type isizex2 = Simd<isize, 2>;\n-\n-/// A SIMD vector with four elements of type `isize`.\n-pub type isizex4 = Simd<isize, 4>;\n-\n-/// A SIMD vector with eight elements of type `isize`.\n-pub type isizex8 = Simd<isize, 8>;\n-\n-/// A 32-bit SIMD vector with two elements of type `i16`.\n-pub type i16x2 = Simd<i16, 2>;\n-\n-/// A 64-bit SIMD vector with four elements of type `i16`.\n-pub type i16x4 = Simd<i16, 4>;\n-\n-/// A 128-bit SIMD vector with eight elements of type `i16`.\n-pub type i16x8 = Simd<i16, 8>;\n-\n-/// A 256-bit SIMD vector with 16 elements of type `i16`.\n-pub type i16x16 = Simd<i16, 16>;\n-\n-/// A 512-bit SIMD vector with 32 elements of type `i16`.\n-pub type i16x32 = Simd<i16, 32>;\n-\n-/// A 64-bit SIMD vector with two elements of type `i32`.\n-pub type i32x2 = Simd<i32, 2>;\n-\n-/// A 128-bit SIMD vector with four elements of type `i32`.\n-pub type i32x4 = Simd<i32, 4>;\n-\n-/// A 256-bit SIMD vector with eight elements of type `i32`.\n-pub type i32x8 = Simd<i32, 8>;\n-\n-/// A 512-bit SIMD vector with 16 elements of type `i32`.\n-pub type i32x16 = Simd<i32, 16>;\n-\n-/// A 128-bit SIMD vector with two elements of type `i64`.\n-pub type i64x2 = Simd<i64, 2>;\n-\n-/// A 256-bit SIMD vector with four elements of type `i64`.\n-pub type i64x4 = Simd<i64, 4>;\n-\n-/// A 512-bit SIMD vector with eight elements of type `i64`.\n-pub type i64x8 = Simd<i64, 8>;\n-\n-/// A 32-bit SIMD vector with four elements of type `i8`.\n-pub type i8x4 = Simd<i8, 4>;\n-\n-/// A 64-bit SIMD vector with eight elements of type `i8`.\n-pub type i8x8 = Simd<i8, 8>;\n-\n-/// A 128-bit SIMD vector with 16 elements of type `i8`.\n-pub type i8x16 = Simd<i8, 16>;\n-\n-/// A 256-bit SIMD vector with 32 elements of type `i8`.\n-pub type i8x32 = Simd<i8, 32>;\n-\n-/// A 512-bit SIMD vector with 64 elements of type `i8`.\n-pub type i8x64 = Simd<i8, 64>;"}, {"sha": "fa756344db91ae3d57b1096848849fe957e18345", "filename": "library/portable-simd/crates/core_simd/src/vector/ptr.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=01937562505363962cf7a5c45a81d82cfe79dd4f", "patch": "@@ -1,51 +0,0 @@\n-//! Private implementation details of public gather/scatter APIs.\n-use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n-\n-/// A vector of *const T.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdConstPtr<T, const LANES: usize>([*const T; LANES]);\n-\n-impl<T, const LANES: usize> SimdConstPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *const T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}\n-\n-/// A vector of *mut T. Be very careful around potential aliasing.\n-#[derive(Debug, Copy, Clone)]\n-#[repr(simd)]\n-pub(crate) struct SimdMutPtr<T, const LANES: usize>([*mut T; LANES]);\n-\n-impl<T, const LANES: usize> SimdMutPtr<T, LANES>\n-where\n-    LaneCount<LANES>: SupportedLaneCount,\n-    T: Sized,\n-{\n-    #[inline]\n-    #[must_use]\n-    pub fn splat(ptr: *mut T) -> Self {\n-        Self([ptr; LANES])\n-    }\n-\n-    #[inline]\n-    #[must_use]\n-    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n-        // Safety: this intrinsic doesn't have a precondition\n-        unsafe { intrinsics::simd_arith_offset(self, addend) }\n-    }\n-}"}, {"sha": "b4a69c44363f1d5a0d9297ccc06504f1ea65ac78", "filename": "library/portable-simd/crates/core_simd/src/vector/uint.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01937562505363962cf7a5c45a81d82cfe79dd4f/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=01937562505363962cf7a5c45a81d82cfe79dd4f", "patch": "@@ -1,63 +0,0 @@\n-#![allow(non_camel_case_types)]\n-\n-use crate::simd::Simd;\n-\n-/// A SIMD vector with two elements of type `usize`.\n-pub type usizex2 = Simd<usize, 2>;\n-\n-/// A SIMD vector with four elements of type `usize`.\n-pub type usizex4 = Simd<usize, 4>;\n-\n-/// A SIMD vector with eight elements of type `usize`.\n-pub type usizex8 = Simd<usize, 8>;\n-\n-/// A 32-bit SIMD vector with two elements of type `u16`.\n-pub type u16x2 = Simd<u16, 2>;\n-\n-/// A 64-bit SIMD vector with four elements of type `u16`.\n-pub type u16x4 = Simd<u16, 4>;\n-\n-/// A 128-bit SIMD vector with eight elements of type `u16`.\n-pub type u16x8 = Simd<u16, 8>;\n-\n-/// A 256-bit SIMD vector with 16 elements of type `u16`.\n-pub type u16x16 = Simd<u16, 16>;\n-\n-/// A 512-bit SIMD vector with 32 elements of type `u16`.\n-pub type u16x32 = Simd<u16, 32>;\n-\n-/// A 64-bit SIMD vector with two elements of type `u32`.\n-pub type u32x2 = Simd<u32, 2>;\n-\n-/// A 128-bit SIMD vector with four elements of type `u32`.\n-pub type u32x4 = Simd<u32, 4>;\n-\n-/// A 256-bit SIMD vector with eight elements of type `u32`.\n-pub type u32x8 = Simd<u32, 8>;\n-\n-/// A 512-bit SIMD vector with 16 elements of type `u32`.\n-pub type u32x16 = Simd<u32, 16>;\n-\n-/// A 128-bit SIMD vector with two elements of type `u64`.\n-pub type u64x2 = Simd<u64, 2>;\n-\n-/// A 256-bit SIMD vector with four elements of type `u64`.\n-pub type u64x4 = Simd<u64, 4>;\n-\n-/// A 512-bit SIMD vector with eight elements of type `u64`.\n-pub type u64x8 = Simd<u64, 8>;\n-\n-/// A 32-bit SIMD vector with four elements of type `u8`.\n-pub type u8x4 = Simd<u8, 4>;\n-\n-/// A 64-bit SIMD vector with eight elements of type `u8`.\n-pub type u8x8 = Simd<u8, 8>;\n-\n-/// A 128-bit SIMD vector with 16 elements of type `u8`.\n-pub type u8x16 = Simd<u8, 16>;\n-\n-/// A 256-bit SIMD vector with 32 elements of type `u8`.\n-pub type u8x32 = Simd<u8, 32>;\n-\n-/// A 512-bit SIMD vector with 64 elements of type `u8`.\n-pub type u8x64 = Simd<u8, 64>;"}, {"sha": "3181826ef59a659df203c31d08469924bcbe98c3", "filename": "library/portable-simd/crates/core_simd/tests/autoderef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fautoderef.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,6 +1,6 @@\n // Test that we handle all our \"auto-deref\" cases correctly.\n #![feature(portable_simd)]\n-use core_simd::f32x4;\n+use core_simd::simd::f32x4;\n \n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;"}, {"sha": "faafa5fa51f1877415b91e3bebbab084920fb1f5", "filename": "library/portable-simd/crates/core_simd/tests/mask_ops_impl/mask_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmask_ops_impl%2Fmask_macros.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -2,7 +2,7 @@ macro_rules! mask_tests {\n     { $vector:ident, $lanes:literal } => {\n         #[cfg(test)]\n         mod $vector {\n-            use core_simd::$vector as Vector;\n+            use core_simd::simd::$vector as Vector;\n             const LANES: usize = $lanes;\n \n             #[cfg(target_arch = \"wasm32\")]"}, {"sha": "9f8bad1c36c082e6a9bbe9bc01b65d4e66b8f5c6", "filename": "library/portable-simd/crates/core_simd/tests/masks.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -13,11 +13,13 @@ macro_rules! test_mask_api {\n             #[cfg(target_arch = \"wasm32\")]\n             use wasm_bindgen_test::*;\n \n+            use core_simd::simd::Mask;\n+\n             #[test]\n             #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n             fn set_and_test() {\n                 let values = [true, false, false, true, false, false, true, false];\n-                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let mut mask = Mask::<$type, 8>::splat(false);\n                 for (lane, value) in values.iter().copied().enumerate() {\n                     mask.set(lane, value);\n                 }\n@@ -29,90 +31,90 @@ macro_rules! test_mask_api {\n             #[test]\n             #[should_panic]\n             fn set_invalid_lane() {\n-                let mut mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let mut mask = Mask::<$type, 8>::splat(false);\n                 mask.set(8, true);\n                 let _ = mask;\n             }\n \n             #[test]\n             #[should_panic]\n             fn test_invalid_lane() {\n-                let mask = core_simd::Mask::<$type, 8>::splat(false);\n+                let mask = Mask::<$type, 8>::splat(false);\n                 let _ = mask.test(8);\n             }\n \n             #[test]\n             fn any() {\n-                assert!(!core_simd::Mask::<$type, 8>::splat(false).any());\n-                assert!(core_simd::Mask::<$type, 8>::splat(true).any());\n-                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n+                assert!(!Mask::<$type, 8>::splat(false).any());\n+                assert!(Mask::<$type, 8>::splat(true).any());\n+                let mut v = Mask::<$type, 8>::splat(false);\n                 v.set(2, true);\n                 assert!(v.any());\n             }\n \n             #[test]\n             fn all() {\n-                assert!(!core_simd::Mask::<$type, 8>::splat(false).all());\n-                assert!(core_simd::Mask::<$type, 8>::splat(true).all());\n-                let mut v = core_simd::Mask::<$type, 8>::splat(false);\n+                assert!(!Mask::<$type, 8>::splat(false).all());\n+                assert!(Mask::<$type, 8>::splat(true).all());\n+                let mut v = Mask::<$type, 8>::splat(false);\n                 v.set(2, true);\n                 assert!(!v.all());\n             }\n \n             #[test]\n             fn roundtrip_int_conversion() {\n                 let values = [true, false, false, true, false, false, true, false];\n-                let mask = core_simd::Mask::<$type, 8>::from_array(values);\n+                let mask = Mask::<$type, 8>::from_array(values);\n                 let int = mask.to_int();\n                 assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n-                assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n+                assert_eq!(Mask::<$type, 8>::from_int(int), mask);\n             }\n \n             #[test]\n             fn roundtrip_bitmask_conversion() {\n-                use core_simd::ToBitMask;\n+                use core_simd::simd::ToBitMask;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n-                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let mask = Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, 0b1000001101001001);\n-                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n+                assert_eq!(Mask::<$type, 16>::from_bitmask(bitmask), mask);\n             }\n \n             #[test]\n             fn roundtrip_bitmask_conversion_short() {\n-                use core_simd::ToBitMask;\n+                use core_simd::simd::ToBitMask;\n \n                 let values = [\n                     false, false, false, true,\n                 ];\n-                let mask = core_simd::Mask::<$type, 4>::from_array(values);\n+                let mask = Mask::<$type, 4>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, 0b1000);\n-                assert_eq!(core_simd::Mask::<$type, 4>::from_bitmask(bitmask), mask);\n+                assert_eq!(Mask::<$type, 4>::from_bitmask(bitmask), mask);\n \n                 let values = [true, false];\n-                let mask = core_simd::Mask::<$type, 2>::from_array(values);\n+                let mask = Mask::<$type, 2>::from_array(values);\n                 let bitmask = mask.to_bitmask();\n                 assert_eq!(bitmask, 0b01);\n-                assert_eq!(core_simd::Mask::<$type, 2>::from_bitmask(bitmask), mask);\n+                assert_eq!(Mask::<$type, 2>::from_bitmask(bitmask), mask);\n             }\n \n             #[test]\n             fn cast() {\n-                fn cast_impl<T: core_simd::MaskElement>()\n+                fn cast_impl<T: core_simd::simd::MaskElement>()\n                 where\n-                    core_simd::Mask<$type, 8>: Into<core_simd::Mask<T, 8>>,\n+                    Mask<$type, 8>: Into<Mask<T, 8>>,\n                 {\n                     let values = [true, false, false, true, false, false, true, false];\n-                    let mask = core_simd::Mask::<$type, 8>::from_array(values);\n+                    let mask = Mask::<$type, 8>::from_array(values);\n \n                     let cast_mask = mask.cast::<T>();\n                     assert_eq!(values, cast_mask.to_array());\n \n-                    let into_mask: core_simd::Mask<T, 8> = mask.into();\n+                    let into_mask: Mask<T, 8> = mask.into();\n                     assert_eq!(values, into_mask.to_array());\n                 }\n \n@@ -126,15 +128,15 @@ macro_rules! test_mask_api {\n             #[cfg(feature = \"generic_const_exprs\")]\n             #[test]\n             fn roundtrip_bitmask_array_conversion() {\n-                use core_simd::ToBitMaskArray;\n+                use core_simd::simd::ToBitMaskArray;\n                 let values = [\n                     true, false, false, true, false, false, true, false,\n                     true, true, false, false, false, false, false, true,\n                 ];\n-                let mask = core_simd::Mask::<$type, 16>::from_array(values);\n+                let mask = Mask::<$type, 16>::from_array(values);\n                 let bitmask = mask.to_bitmask_array();\n                 assert_eq!(bitmask, [0b01001001, 0b10000011]);\n-                assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask_array(bitmask), mask);\n+                assert_eq!(Mask::<$type, 16>::from_bitmask_array(bitmask), mask);\n             }\n         }\n     }\n@@ -150,9 +152,10 @@ mod mask_api {\n \n #[test]\n fn convert() {\n+    use core_simd::simd::Mask;\n     let values = [true, false, false, true, false, false, true, false];\n     assert_eq!(\n-        core_simd::Mask::<i8, 8>::from_array(values),\n-        core_simd::Mask::<i32, 8>::from_array(values).into()\n+        Mask::<i8, 8>::from_array(values),\n+        Mask::<i32, 8>::from_array(values).into()\n     );\n }"}, {"sha": "3a02f3f01e1cf8c36b233f01f6d342aec725c015", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -7,7 +7,7 @@ macro_rules! impl_unary_op_test {\n         test_helpers::test_lanes! {\n             fn $fn<const LANES: usize>() {\n                 test_helpers::test_unary_elementwise(\n-                    &<core_simd::Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n+                    &<core_simd::simd::Simd<$scalar, LANES> as core::ops::$trait>::$fn,\n                     &$scalar_fn,\n                     &|_| true,\n                 );\n@@ -27,7 +27,7 @@ macro_rules! impl_binary_op_test {\n     { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr } => {\n         mod $fn {\n             use super::*;\n-            use core_simd::Simd;\n+            use core_simd::simd::Simd;\n \n             test_helpers::test_lanes! {\n                 fn normal<const LANES: usize>() {\n@@ -64,7 +64,7 @@ macro_rules! impl_binary_checked_op_test {\n     { $scalar:ty, $trait:ident :: $fn:ident, $trait_assign:ident :: $fn_assign:ident, $scalar_fn:expr, $check_fn:expr } => {\n         mod $fn {\n             use super::*;\n-            use core_simd::Simd;\n+            use core_simd::simd::Simd;\n \n             test_helpers::test_lanes! {\n                 fn normal<const LANES: usize>() {\n@@ -173,7 +173,7 @@ macro_rules! impl_signed_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n             use core_simd::simd::SimdInt;\n-            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_common_integer_tests! { Vector, Scalar }\n@@ -314,7 +314,7 @@ macro_rules! impl_unsigned_tests {\n     { $scalar:tt } => {\n         mod $scalar {\n             use core_simd::simd::SimdUint;\n-            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_common_integer_tests! { Vector, Scalar }\n@@ -348,8 +348,8 @@ macro_rules! impl_unsigned_tests {\n macro_rules! impl_float_tests {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n-            use core_simd::SimdFloat;\n-            type Vector<const LANES: usize> = core_simd::Simd<Scalar, LANES>;\n+            use core_simd::simd::SimdFloat;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<Scalar, LANES>;\n             type Scalar = $scalar;\n \n             impl_unary_op_test!(Scalar, Neg::neg);"}, {"sha": "0ae8f83b8b97dce9fa792f4359ba8ffeae432c03", "filename": "library/portable-simd/crates/core_simd/tests/pointers.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fpointers.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,111 @@\n+#![feature(portable_simd, strict_provenance)]\n+\n+use core_simd::simd::{Simd, SimdConstPtr, SimdMutPtr};\n+\n+macro_rules! common_tests {\n+    { $constness:ident } => {\n+        test_helpers::test_lanes! {\n+            fn is_null<const LANES: usize>() {\n+                test_helpers::test_unary_mask_elementwise(\n+                    &Simd::<*$constness u32, LANES>::is_null,\n+                    &<*$constness u32>::is_null,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn addr<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::addr,\n+                    &<*$constness u32>::addr,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn with_addr<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::with_addr,\n+                    &<*$constness u32>::with_addr,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn expose_addr<const LANES: usize>() {\n+                test_helpers::test_unary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::expose_addr,\n+                    &<*$constness u32>::expose_addr,\n+                    &|_| true,\n+                );\n+            }\n+\n+            fn wrapping_offset<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_offset,\n+                    &<*$constness u32>::wrapping_offset,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn wrapping_add<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_add,\n+                    &<*$constness u32>::wrapping_add,\n+                    &|_, _| true,\n+                );\n+            }\n+\n+            fn wrapping_sub<const LANES: usize>() {\n+                test_helpers::test_binary_elementwise(\n+                    &Simd::<*$constness u32, LANES>::wrapping_sub,\n+                    &<*$constness u32>::wrapping_sub,\n+                    &|_, _| true,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+mod const_ptr {\n+    use super::*;\n+    common_tests! { const }\n+\n+    test_helpers::test_lanes! {\n+        fn cast_mut<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*const u32, LANES>::cast_mut,\n+                &<*const u32>::cast_mut,\n+                &|_| true,\n+            );\n+        }\n+\n+        fn from_exposed_addr<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*const u32, LANES>::from_exposed_addr,\n+                &core::ptr::from_exposed_addr::<u32>,\n+                &|_| true,\n+            );\n+        }\n+    }\n+}\n+\n+mod mut_ptr {\n+    use super::*;\n+    common_tests! { mut }\n+\n+    test_helpers::test_lanes! {\n+        fn cast_const<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*mut u32, LANES>::cast_const,\n+                &<*mut u32>::cast_const,\n+                &|_| true,\n+            );\n+        }\n+\n+        fn from_exposed_addr<const LANES: usize>() {\n+            test_helpers::test_unary_elementwise(\n+                &Simd::<*mut u32, LANES>::from_exposed_addr,\n+                &core::ptr::from_exposed_addr_mut::<u32>,\n+                &|_| true,\n+            );\n+        }\n+    }\n+}"}, {"sha": "8b9638ad466712c299aebe4e19904de11e40ce11", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -5,7 +5,7 @@ macro_rules! float_rounding_test {\n         mod $scalar {\n             use std_float::StdFloat;\n \n-            type Vector<const LANES: usize> = core_simd::Simd<$scalar, LANES>;\n+            type Vector<const LANES: usize> = core_simd::simd::Simd<$scalar, LANES>;\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;\n "}, {"sha": "8cd7c33e823fb799901d53cddf36825ced6c29ec", "filename": "library/portable-simd/crates/core_simd/tests/swizzle.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,5 +1,5 @@\n #![feature(portable_simd)]\n-use core_simd::{Simd, Swizzle};\n+use core_simd::simd::{Simd, Swizzle};\n \n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;\n@@ -60,3 +60,17 @@ fn interleave() {\n     assert_eq!(even, a);\n     assert_eq!(odd, b);\n }\n+\n+// portable-simd#298\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn interleave_one() {\n+    let a = Simd::from_array([0]);\n+    let b = Simd::from_array([1]);\n+    let (lo, hi) = a.interleave(b);\n+    assert_eq!(lo.to_array(), [0]);\n+    assert_eq!(hi.to_array(), [1]);\n+    let (even, odd) = lo.deinterleave(hi);\n+    assert_eq!(even, a);\n+    assert_eq!(odd, b);\n+}"}, {"sha": "646cd5f338335075624f5b747d0bb44856364eb1", "filename": "library/portable-simd/crates/core_simd/tests/swizzle_dyn.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fswizzle_dyn.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,74 @@\n+#![feature(portable_simd)]\n+use core::{fmt, ops::RangeInclusive};\n+use proptest;\n+use test_helpers::{self, biteq, make_runner, prop_assert_biteq};\n+\n+fn swizzle_dyn_scalar_ver<const N: usize>(values: [u8; N], idxs: [u8; N]) -> [u8; N] {\n+    let mut array = [0; N];\n+    for (i, k) in idxs.into_iter().enumerate() {\n+        if (k as usize) < N {\n+            array[i] = values[k as usize];\n+        };\n+    }\n+    array\n+}\n+\n+test_helpers::test_lanes! {\n+    fn swizzle_dyn<const N: usize>() {\n+        match_simd_with_fallback(\n+            &core_simd::simd::Simd::<u8, N>::swizzle_dyn,\n+            &swizzle_dyn_scalar_ver,\n+            &|_, _| true,\n+        );\n+    }\n+}\n+\n+fn match_simd_with_fallback<Scalar, ScalarResult, Vector, VectorResult, const N: usize>(\n+    fv: &dyn Fn(Vector, Vector) -> VectorResult,\n+    fs: &dyn Fn([Scalar; N], [Scalar; N]) -> [ScalarResult; N],\n+    check: &dyn Fn([Scalar; N], [Scalar; N]) -> bool,\n+) where\n+    Scalar: Copy + fmt::Debug + SwizzleStrategy,\n+    ScalarResult: Copy + biteq::BitEq + fmt::Debug + SwizzleStrategy,\n+    Vector: Into<[Scalar; N]> + From<[Scalar; N]> + Copy,\n+    VectorResult: Into<[ScalarResult; N]> + From<[ScalarResult; N]> + Copy,\n+{\n+    test_swizzles_2(&|x: [Scalar; N], y: [Scalar; N]| {\n+        proptest::prop_assume!(check(x, y));\n+        let result_v: [ScalarResult; N] = fv(x.into(), y.into()).into();\n+        let result_s: [ScalarResult; N] = fs(x, y);\n+        crate::prop_assert_biteq!(result_v, result_s);\n+        Ok(())\n+    });\n+}\n+\n+fn test_swizzles_2<A: fmt::Debug + SwizzleStrategy, B: fmt::Debug + SwizzleStrategy>(\n+    f: &dyn Fn(A, B) -> proptest::test_runner::TestCaseResult,\n+) {\n+    let mut runner = make_runner();\n+    runner\n+        .run(\n+            &(A::swizzled_strategy(), B::swizzled_strategy()),\n+            |(a, b)| f(a, b),\n+        )\n+        .unwrap();\n+}\n+\n+pub trait SwizzleStrategy {\n+    type Strategy: proptest::strategy::Strategy<Value = Self>;\n+    fn swizzled_strategy() -> Self::Strategy;\n+}\n+\n+impl SwizzleStrategy for u8 {\n+    type Strategy = RangeInclusive<u8>;\n+    fn swizzled_strategy() -> Self::Strategy {\n+        0..=64\n+    }\n+}\n+\n+impl<T: fmt::Debug + SwizzleStrategy, const N: usize> SwizzleStrategy for [T; N] {\n+    type Strategy = test_helpers::array::UniformArrayStrategy<T::Strategy, Self>;\n+    fn swizzled_strategy() -> Self::Strategy {\n+        Self::Strategy::new(T::swizzled_strategy())\n+    }\n+}"}, {"sha": "be0ee4349c579ceb6d89f55a88977bed48fc36cb", "filename": "library/portable-simd/crates/core_simd/tests/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fto_bytes.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -2,7 +2,7 @@\n #![allow(incomplete_features)]\n #![cfg(feature = \"generic_const_exprs\")]\n \n-use core_simd::Simd;\n+use core_simd::simd::Simd;\n \n #[test]\n fn byte_convert() {"}, {"sha": "859e3b94f2cd4fa8fee3b6ef00b036a8a18aca18", "filename": "library/portable-simd/crates/core_simd/tests/try_from_slice.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ftry_from_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ftry_from_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Ftry_from_slice.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,25 @@\n+#![feature(portable_simd)]\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+use core_simd::simd::i32x4;\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn try_from_slice() {\n+    // Equal length\n+    assert_eq!(\n+        i32x4::try_from([1, 2, 3, 4].as_slice()).unwrap(),\n+        i32x4::from_array([1, 2, 3, 4])\n+    );\n+\n+    // Slice length > vector length\n+    assert!(i32x4::try_from([1, 2, 3, 4, 5].as_slice()).is_err());\n+\n+    // Slice length < vector length\n+    assert!(i32x4::try_from([1, 2, 3].as_slice()).is_err());\n+}"}, {"sha": "1d2bc8b519aa6355e2916b27af8dcecdaf8a598d", "filename": "library/portable-simd/crates/test_helpers/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -8,3 +8,6 @@ publish = false\n version = \"0.10\"\n default-features = false\n features = [\"alloc\"]\n+\n+[features]\n+all_lane_counts = []"}, {"sha": "984a427320deb746345847a93f04f6181ce490a3", "filename": "library/portable-simd/crates/test_helpers/src/array.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Farray.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -41,6 +41,7 @@ where\n \n     fn new_tree(&self, runner: &mut TestRunner) -> NewTree<Self> {\n         let tree: [S::Tree; LANES] = unsafe {\n+            #[allow(clippy::uninit_assumed_init)]\n             let mut tree: [MaybeUninit<S::Tree>; LANES] = MaybeUninit::uninit().assume_init();\n             for t in tree.iter_mut() {\n                 *t = MaybeUninit::new(self.strategy.new_tree(runner)?)\n@@ -60,6 +61,7 @@ impl<T: ValueTree, const LANES: usize> ValueTree for ArrayValueTree<[T; LANES]>\n \n     fn current(&self) -> Self::Value {\n         unsafe {\n+            #[allow(clippy::uninit_assumed_init)]\n             let mut value: [MaybeUninit<T::Value>; LANES] = MaybeUninit::uninit().assume_init();\n             for (tree_elem, value_elem) in self.tree.iter().zip(value.iter_mut()) {\n                 *value_elem = MaybeUninit::new(tree_elem.current());"}, {"sha": "7d91260d838a63b6be90f19e0e1de9d0e45d3eb0", "filename": "library/portable-simd/crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -55,6 +55,26 @@ macro_rules! impl_float_biteq {\n \n impl_float_biteq! { f32, f64 }\n \n+impl<T> BitEq for *const T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+impl<T> BitEq for *mut T {\n+    fn biteq(&self, other: &Self) -> bool {\n+        self == other\n+    }\n+\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n impl<T: BitEq, const N: usize> BitEq for [T; N] {\n     fn biteq(&self, other: &Self) -> bool {\n         self.iter()"}, {"sha": "b26cdc311a215678e3083960c4e477d5b412f7f9", "filename": "library/portable-simd/crates/test_helpers/src/lib.rs", "status": "modified", "additions": 242, "deletions": 104, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Ftest_helpers%2Fsrc%2Flib.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -38,6 +38,28 @@ impl_num! { usize }\n impl_num! { f32 }\n impl_num! { f64 }\n \n+impl<T> DefaultStrategy for *const T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *const T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *const T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n+impl<T> DefaultStrategy for *mut T {\n+    type Strategy = proptest::strategy::Map<proptest::num::isize::Any, fn(isize) -> *mut T>;\n+    fn default_strategy() -> Self::Strategy {\n+        fn map<T>(x: isize) -> *mut T {\n+            x as _\n+        }\n+        use proptest::strategy::Strategy;\n+        proptest::num::isize::ANY.prop_map(map)\n+    }\n+}\n+\n #[cfg(not(target_arch = \"wasm32\"))]\n impl DefaultStrategy for u128 {\n     type Strategy = proptest::num::u128::Any;\n@@ -135,21 +157,21 @@ pub fn test_unary_elementwise<Scalar, ScalarResult, Vector, VectorResult, const\n     fs: &dyn Fn(Scalar) -> ScalarResult,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_1(&|x: [Scalar; LANES]| {\n         proptest::prop_assume!(check(x));\n         let result_1: [ScalarResult; LANES] = fv(x.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for (i, o) in x.iter().zip(result.iter_mut()) {\n-                *o = fs(*i);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .map(fs)\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });\n@@ -162,7 +184,7 @@ pub fn test_unary_mask_elementwise<Scalar, Vector, Mask, const LANES: usize>(\n     fs: &dyn Fn(Scalar) -> bool,\n     check: &dyn Fn([Scalar; LANES]) -> bool,\n ) where\n-    Scalar: Copy + Default + core::fmt::Debug + DefaultStrategy,\n+    Scalar: Copy + core::fmt::Debug + DefaultStrategy,\n     Vector: Into<[Scalar; LANES]> + From<[Scalar; LANES]> + Copy,\n     Mask: Into<[bool; LANES]> + From<[bool; LANES]> + Copy,\n {\n@@ -196,23 +218,24 @@ pub fn test_binary_elementwise<\n     fs: &dyn Fn(Scalar1, Scalar2) -> ScalarResult,\n     check: &dyn Fn([Scalar1; LANES], [Scalar2; LANES]) -> bool,\n ) where\n-    Scalar1: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    Scalar2: Copy + Default + core::fmt::Debug + DefaultStrategy,\n-    ScalarResult: Copy + Default + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n+    Scalar1: Copy + core::fmt::Debug + DefaultStrategy,\n+    Scalar2: Copy + core::fmt::Debug + DefaultStrategy,\n+    ScalarResult: Copy + biteq::BitEq + core::fmt::Debug + DefaultStrategy,\n     Vector1: Into<[Scalar1; LANES]> + From<[Scalar1; LANES]> + Copy,\n     Vector2: Into<[Scalar2; LANES]> + From<[Scalar2; LANES]> + Copy,\n     VectorResult: Into<[ScalarResult; LANES]> + From<[ScalarResult; LANES]> + Copy,\n {\n     test_2(&|x: [Scalar1; LANES], y: [Scalar2; LANES]| {\n         proptest::prop_assume!(check(x, y));\n         let result_1: [ScalarResult; LANES] = fv(x.into(), y.into()).into();\n-        let result_2: [ScalarResult; LANES] = {\n-            let mut result = [ScalarResult::default(); LANES];\n-            for ((i1, i2), o) in x.iter().zip(y.iter()).zip(result.iter_mut()) {\n-                *o = fs(*i1, *i2);\n-            }\n-            result\n-        };\n+        let result_2: [ScalarResult; LANES] = x\n+            .iter()\n+            .copied()\n+            .zip(y.iter().copied())\n+            .map(|(x, y)| fs(x, y))\n+            .collect::<Vec<_>>()\n+            .try_into()\n+            .unwrap();\n         crate::prop_assert_biteq!(result_1, result_2);\n         Ok(())\n     });\n@@ -333,6 +356,39 @@ pub fn test_ternary_elementwise<\n     );\n }\n \n+#[doc(hidden)]\n+#[macro_export]\n+macro_rules! test_lanes_helper {\n+    ($($(#[$meta:meta])* $fn_name:ident $lanes:literal;)+) => {\n+        $(\n+            #[test]\n+            $(#[$meta])*\n+            fn $fn_name() {\n+                implementation::<$lanes>();\n+            }\n+        )+\n+    };\n+    (\n+        $(#[$meta:meta])+;\n+        $($(#[$meta_before:meta])+ $fn_name_before:ident $lanes_before:literal;)*\n+        $fn_name:ident $lanes:literal;\n+        $($fn_name_rest:ident $lanes_rest:literal;)*\n+    ) => {\n+        $crate::test_lanes_helper!(\n+            $(#[$meta])+;\n+            $($(#[$meta_before])+ $fn_name_before $lanes_before;)*\n+            $(#[$meta])+ $fn_name $lanes;\n+            $($fn_name_rest $lanes_rest;)*\n+        );\n+    };\n+    (\n+        $(#[$meta_ignored:meta])+;\n+        $($(#[$meta:meta])+ $fn_name:ident $lanes:literal;)+\n+    ) => {\n+        $crate::test_lanes_helper!($($(#[$meta])+ $fn_name $lanes;)+);\n+    };\n+}\n+\n /// Expand a const-generic test into separate tests for each possible lane count.\n #[macro_export]\n macro_rules! test_lanes {\n@@ -345,57 +401,96 @@ macro_rules! test_lanes {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n+                    core_simd::simd::LaneCount<$lanes>: core_simd::simd::SupportedLaneCount,\n                 $body\n \n                 #[cfg(target_arch = \"wasm32\")]\n                 wasm_bindgen_test::wasm_bindgen_test_configure!(run_in_browser);\n \n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_1() {\n-                    implementation::<1>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_2() {\n-                    implementation::<2>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                fn lanes_4() {\n-                    implementation::<4>();\n-                }\n+                $crate::test_lanes_helper!(\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_1 1;\n+                    lanes_2 2;\n+                    lanes_4 4;\n+                );\n \n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n                 #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_8() {\n-                    implementation::<8>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n+                $crate::test_lanes_helper!(\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_8 8;\n+                    lanes_16 16;\n+                    lanes_32 32;\n+                    lanes_64 64;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n+                $crate::test_lanes_helper!(\n+                    // test some odd and even non-power-of-2 lengths on miri\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_3 3;\n+                    lanes_5 5;\n+                    lanes_6 6;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n                 #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_16() {\n-                    implementation::<16>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_32() {\n-                    implementation::<32>();\n-                }\n-\n-                #[test]\n-                #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)]\n-                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n-                fn lanes_64() {\n-                    implementation::<64>();\n-                }\n+                $crate::test_lanes_helper!(\n+                    #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test::wasm_bindgen_test)];\n+                    lanes_7 7;\n+                    lanes_9 9;\n+                    lanes_10 10;\n+                    lanes_11 11;\n+                    lanes_12 12;\n+                    lanes_13 13;\n+                    lanes_14 14;\n+                    lanes_15 15;\n+                    lanes_17 17;\n+                    lanes_18 18;\n+                    lanes_19 19;\n+                    lanes_20 20;\n+                    lanes_21 21;\n+                    lanes_22 22;\n+                    lanes_23 23;\n+                    lanes_24 24;\n+                    lanes_25 25;\n+                    lanes_26 26;\n+                    lanes_27 27;\n+                    lanes_28 28;\n+                    lanes_29 29;\n+                    lanes_30 30;\n+                    lanes_31 31;\n+                    lanes_33 33;\n+                    lanes_34 34;\n+                    lanes_35 35;\n+                    lanes_36 36;\n+                    lanes_37 37;\n+                    lanes_38 38;\n+                    lanes_39 39;\n+                    lanes_40 40;\n+                    lanes_41 41;\n+                    lanes_42 42;\n+                    lanes_43 43;\n+                    lanes_44 44;\n+                    lanes_45 45;\n+                    lanes_46 46;\n+                    lanes_47 47;\n+                    lanes_48 48;\n+                    lanes_49 49;\n+                    lanes_50 50;\n+                    lanes_51 51;\n+                    lanes_52 52;\n+                    lanes_53 53;\n+                    lanes_54 54;\n+                    lanes_55 55;\n+                    lanes_56 56;\n+                    lanes_57 57;\n+                    lanes_58 58;\n+                    lanes_59 59;\n+                    lanes_60 60;\n+                    lanes_61 61;\n+                    lanes_62 62;\n+                    lanes_63 63;\n+                );\n             }\n         )*\n     }\n@@ -413,50 +508,93 @@ macro_rules! test_lanes_panic {\n \n                 fn implementation<const $lanes: usize>()\n                 where\n-                    core_simd::LaneCount<$lanes>: core_simd::SupportedLaneCount,\n+                    core_simd::simd::LaneCount<$lanes>: core_simd::simd::SupportedLaneCount,\n                 $body\n \n-                #[test]\n-                #[should_panic]\n-                fn lanes_1() {\n-                    implementation::<1>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_2() {\n-                    implementation::<2>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_4() {\n-                    implementation::<4>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_8() {\n-                    implementation::<8>();\n-                }\n+                $crate::test_lanes_helper!(\n+                    #[should_panic];\n+                    lanes_1 1;\n+                    lanes_2 2;\n+                    lanes_4 4;\n+                );\n \n-                #[test]\n-                #[should_panic]\n-                fn lanes_16() {\n-                    implementation::<16>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_32() {\n-                    implementation::<32>();\n-                }\n-\n-                #[test]\n-                #[should_panic]\n-                fn lanes_64() {\n-                    implementation::<64>();\n-                }\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n+                $crate::test_lanes_helper!(\n+                    #[should_panic];\n+                    lanes_8 8;\n+                    lanes_16 16;\n+                    lanes_32 32;\n+                    lanes_64 64;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n+                $crate::test_lanes_helper!(\n+                    // test some odd and even non-power-of-2 lengths on miri\n+                    #[should_panic];\n+                    lanes_3 3;\n+                    lanes_5 5;\n+                    lanes_6 6;\n+                );\n+\n+                #[cfg(feature = \"all_lane_counts\")]\n+                #[cfg(not(miri))] // Miri intrinsic implementations are uniform and larger tests are sloooow\n+                $crate::test_lanes_helper!(\n+                    #[should_panic];\n+                    lanes_7 7;\n+                    lanes_9 9;\n+                    lanes_10 10;\n+                    lanes_11 11;\n+                    lanes_12 12;\n+                    lanes_13 13;\n+                    lanes_14 14;\n+                    lanes_15 15;\n+                    lanes_17 17;\n+                    lanes_18 18;\n+                    lanes_19 19;\n+                    lanes_20 20;\n+                    lanes_21 21;\n+                    lanes_22 22;\n+                    lanes_23 23;\n+                    lanes_24 24;\n+                    lanes_25 25;\n+                    lanes_26 26;\n+                    lanes_27 27;\n+                    lanes_28 28;\n+                    lanes_29 29;\n+                    lanes_30 30;\n+                    lanes_31 31;\n+                    lanes_33 33;\n+                    lanes_34 34;\n+                    lanes_35 35;\n+                    lanes_36 36;\n+                    lanes_37 37;\n+                    lanes_38 38;\n+                    lanes_39 39;\n+                    lanes_40 40;\n+                    lanes_41 41;\n+                    lanes_42 42;\n+                    lanes_43 43;\n+                    lanes_44 44;\n+                    lanes_45 45;\n+                    lanes_46 46;\n+                    lanes_47 47;\n+                    lanes_48 48;\n+                    lanes_49 49;\n+                    lanes_50 50;\n+                    lanes_51 51;\n+                    lanes_52 52;\n+                    lanes_53 53;\n+                    lanes_54 54;\n+                    lanes_55 55;\n+                    lanes_56 56;\n+                    lanes_57 57;\n+                    lanes_58 58;\n+                    lanes_59 59;\n+                    lanes_60 60;\n+                    lanes_61 61;\n+                    lanes_62 62;\n+                    lanes_63 63;\n+                );\n             }\n         )*\n     }"}, {"sha": "280757a41a2ba635b7f3c3de3274f155d189a71f", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -9,7 +9,7 @@ use crate::io;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n use crate::ptr;\n-use crate::sys::c;\n+use crate::sys;\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n@@ -190,14 +190,14 @@ impl BorrowedHandle<'_> {\n     /// object as the existing `BorrowedHandle` instance.\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone_to_owned(&self) -> crate::io::Result<OwnedHandle> {\n-        self.duplicate(0, false, c::DUPLICATE_SAME_ACCESS)\n+        self.duplicate(0, false, sys::c::DUPLICATE_SAME_ACCESS)\n     }\n \n     pub(crate) fn duplicate(\n         &self,\n-        access: c::DWORD,\n+        access: u32,\n         inherit: bool,\n-        options: c::DWORD,\n+        options: u32,\n     ) -> io::Result<OwnedHandle> {\n         let handle = self.as_raw_handle();\n \n@@ -211,14 +211,14 @@ impl BorrowedHandle<'_> {\n \n         let mut ret = ptr::null_mut();\n         cvt(unsafe {\n-            let cur_proc = c::GetCurrentProcess();\n-            c::DuplicateHandle(\n+            let cur_proc = sys::c::GetCurrentProcess();\n+            sys::c::DuplicateHandle(\n                 cur_proc,\n                 handle,\n                 cur_proc,\n                 &mut ret,\n                 access,\n-                inherit as c::BOOL,\n+                inherit as sys::c::BOOL,\n                 options,\n             )\n         })?;\n@@ -233,7 +233,7 @@ impl TryFrom<HandleOrInvalid> for OwnedHandle {\n     #[inline]\n     fn try_from(handle_or_invalid: HandleOrInvalid) -> Result<Self, InvalidHandleError> {\n         let owned_handle = handle_or_invalid.0;\n-        if owned_handle.handle == c::INVALID_HANDLE_VALUE {\n+        if owned_handle.handle == sys::c::INVALID_HANDLE_VALUE {\n             // Don't call `CloseHandle`; it'd be harmless, except that it could\n             // overwrite the `GetLastError` error.\n             forget(owned_handle);\n@@ -365,7 +365,7 @@ impl Drop for OwnedHandle {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            let _ = c::CloseHandle(self.handle);\n+            let _ = sys::c::CloseHandle(self.handle);\n         }\n     }\n }"}, {"sha": "1759e2e7f3f91e31b1b6784770e70927154c0391", "filename": "library/std/src/os/windows/io/raw.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fraw.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -11,7 +11,6 @@ use crate::os::windows::io::{OwnedHandle, OwnedSocket};\n use crate::os::windows::raw;\n use crate::ptr;\n use crate::sys;\n-use crate::sys::c;\n use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n \n /// Raw HANDLEs.\n@@ -104,42 +103,42 @@ impl AsRawHandle for fs::File {\n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stdin {\n     fn as_raw_handle(&self) -> RawHandle {\n-        stdio_handle(unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle })\n+        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_INPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stdout {\n     fn as_raw_handle(&self) -> RawHandle {\n-        stdio_handle(unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle })\n+        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_OUTPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawHandle for io::Stderr {\n     fn as_raw_handle(&self) -> RawHandle {\n-        stdio_handle(unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle })\n+        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_ERROR_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StdinLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        stdio_handle(unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle })\n+        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_INPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StdoutLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        stdio_handle(unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle })\n+        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_OUTPUT_HANDLE) as RawHandle })\n     }\n }\n \n #[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n impl<'a> AsRawHandle for io::StderrLock<'a> {\n     fn as_raw_handle(&self) -> RawHandle {\n-        stdio_handle(unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle })\n+        stdio_handle(unsafe { sys::c::GetStdHandle(sys::c::STD_ERROR_HANDLE) as RawHandle })\n     }\n }\n \n@@ -152,14 +151,14 @@ fn stdio_handle(raw: RawHandle) -> RawHandle {\n     // console. In that case, return null to the user, which is consistent\n     // with what they'd get in the parent, and which avoids the problem that\n     // `INVALID_HANDLE_VALUE` aliases the current process handle.\n-    if raw == c::INVALID_HANDLE_VALUE { ptr::null_mut() } else { raw }\n+    if raw == sys::c::INVALID_HANDLE_VALUE { ptr::null_mut() } else { raw }\n }\n \n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     #[inline]\n     unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {\n-        let handle = handle as c::HANDLE;\n+        let handle = handle as sys::c::HANDLE;\n         fs::File::from_inner(sys::fs::File::from_inner(FromInner::from_inner(\n             OwnedHandle::from_raw_handle(handle),\n         )))"}, {"sha": "eb6097a89a61e745e2a149c97a8ea2fac1d65a41", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -9,7 +9,6 @@ use crate::marker::PhantomData;\n use crate::mem;\n use crate::mem::forget;\n use crate::sys;\n-use crate::sys::c;\n #[cfg(not(target_vendor = \"uwp\"))]\n use crate::sys::cvt;\n \n@@ -76,7 +75,7 @@ impl BorrowedSocket<'_> {\n     #[rustc_const_stable(feature = \"io_safety\", since = \"1.63.0\")]\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub const unsafe fn borrow_raw(socket: RawSocket) -> Self {\n-        assert!(socket != c::INVALID_SOCKET as RawSocket);\n+        assert!(socket != sys::c::INVALID_SOCKET as RawSocket);\n         Self { socket, _phantom: PhantomData }\n     }\n }\n@@ -94,7 +93,11 @@ impl OwnedSocket {\n     #[cfg(not(target_vendor = \"uwp\"))]\n     pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n         cvt(unsafe {\n-            c::SetHandleInformation(self.as_raw_socket() as c::HANDLE, c::HANDLE_FLAG_INHERIT, 0)\n+            sys::c::SetHandleInformation(\n+                self.as_raw_socket() as sys::c::HANDLE,\n+                sys::c::HANDLE_FLAG_INHERIT,\n+                0,\n+            )\n         })\n         .map(drop)\n     }\n@@ -110,43 +113,47 @@ impl BorrowedSocket<'_> {\n     /// object as the existing `BorrowedSocket` instance.\n     #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n     pub fn try_clone_to_owned(&self) -> io::Result<OwnedSocket> {\n-        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFOW>() };\n+        let mut info = unsafe { mem::zeroed::<sys::c::WSAPROTOCOL_INFOW>() };\n         let result = unsafe {\n-            c::WSADuplicateSocketW(self.as_raw_socket(), c::GetCurrentProcessId(), &mut info)\n+            sys::c::WSADuplicateSocketW(\n+                self.as_raw_socket(),\n+                sys::c::GetCurrentProcessId(),\n+                &mut info,\n+            )\n         };\n         sys::net::cvt(result)?;\n         let socket = unsafe {\n-            c::WSASocketW(\n+            sys::c::WSASocketW(\n                 info.iAddressFamily,\n                 info.iSocketType,\n                 info.iProtocol,\n                 &mut info,\n                 0,\n-                c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n+                sys::c::WSA_FLAG_OVERLAPPED | sys::c::WSA_FLAG_NO_HANDLE_INHERIT,\n             )\n         };\n \n-        if socket != c::INVALID_SOCKET {\n+        if socket != sys::c::INVALID_SOCKET {\n             unsafe { Ok(OwnedSocket::from_raw_socket(socket)) }\n         } else {\n-            let error = unsafe { c::WSAGetLastError() };\n+            let error = unsafe { sys::c::WSAGetLastError() };\n \n-            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+            if error != sys::c::WSAEPROTOTYPE && error != sys::c::WSAEINVAL {\n                 return Err(io::Error::from_raw_os_error(error));\n             }\n \n             let socket = unsafe {\n-                c::WSASocketW(\n+                sys::c::WSASocketW(\n                     info.iAddressFamily,\n                     info.iSocketType,\n                     info.iProtocol,\n                     &mut info,\n                     0,\n-                    c::WSA_FLAG_OVERLAPPED,\n+                    sys::c::WSA_FLAG_OVERLAPPED,\n                 )\n             };\n \n-            if socket == c::INVALID_SOCKET {\n+            if socket == sys::c::INVALID_SOCKET {\n                 return Err(last_error());\n             }\n \n@@ -161,7 +168,7 @@ impl BorrowedSocket<'_> {\n \n /// Returns the last error from the Windows socket interface.\n fn last_error() -> io::Error {\n-    io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })\n+    io::Error::from_raw_os_error(unsafe { sys::c::WSAGetLastError() })\n }\n \n #[stable(feature = \"io_safety\", since = \"1.63.0\")]\n@@ -194,7 +201,7 @@ impl IntoRawSocket for OwnedSocket {\n impl FromRawSocket for OwnedSocket {\n     #[inline]\n     unsafe fn from_raw_socket(socket: RawSocket) -> Self {\n-        debug_assert_ne!(socket, c::INVALID_SOCKET as RawSocket);\n+        debug_assert_ne!(socket, sys::c::INVALID_SOCKET as RawSocket);\n         Self { socket }\n     }\n }\n@@ -204,7 +211,7 @@ impl Drop for OwnedSocket {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n-            let _ = c::closesocket(self.socket);\n+            let _ = sys::c::closesocket(self.socket);\n         }\n     }\n }"}, {"sha": "c72be13804d20f4185f5e1d0fe8b9a392a0c17d4", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -52,31 +52,6 @@ cfg_if::cfg_if! {\n     }\n }\n \n-// Import essential modules from platforms used in `std::os` when documenting.\n-//\n-// Note that on some platforms those modules don't compile\n-// (missing things in `libc` which is empty), so they are not included in `std::os` and can be\n-// omitted here as well.\n-\n-#[cfg(doc)]\n-#[cfg(not(any(\n-    all(target_arch = \"wasm32\", not(target_os = \"wasi\")),\n-    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n-)))]\n-cfg_if::cfg_if! {\n-    if #[cfg(not(windows))] {\n-        // On non-Windows platforms (aka linux/osx/etc) pull in a \"minimal\"\n-        // amount of windows goop which ends up compiling\n-\n-        #[macro_use]\n-        #[path = \"windows/compat.rs\"]\n-        pub mod compat;\n-\n-        #[path = \"windows/c.rs\"]\n-        pub mod c;\n-    }\n-}\n-\n cfg_if::cfg_if! {\n     // Fuchsia components default to full backtrace.\n     if #[cfg(target_os = \"fuchsia\")] {"}, {"sha": "d183d4ace05b92877cec0b45daa9e26b09182d7d", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1 +1 @@\n-0.15.0\n\\ No newline at end of file\n+0.16.0\n\\ No newline at end of file"}, {"sha": "73343ba9df51bc7f9e29a95646f9f0ee5a8b00f2", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -27,6 +27,7 @@\n     - [armv7-unknown-linux-uclibceabihf](platform-support/armv7-unknown-linux-uclibceabihf.md)\n     - [\\*-android and \\*-androideabi](platform-support/android.md)\n     - [\\*-linux-ohos](platform-support/openharmony.md)\n+    - [\\*-esp-espidf](platform-support/esp-idf.md)\n     - [\\*-unknown-fuchsia](platform-support/fuchsia.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n     - [loongarch\\*-unknown-linux-\\*](platform-support/loongarch-linux.md)"}, {"sha": "d22e1cf7f684addab48acbada4ce26dc6157a70e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -297,7 +297,7 @@ target | std | host | notes\n `riscv32gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)\n `riscv32im-unknown-none-elf` | * |  | Bare RISC-V (RV32IM ISA)\n [`riscv32imac-unknown-xous-elf`](platform-support/riscv32imac-unknown-xous-elf.md) | ? |  | RISC-V Xous (RV32IMAC ISA)\n-`riscv32imc-esp-espidf` | \u2713 |  | RISC-V ESP-IDF\n+[`riscv32imc-esp-espidf`](platform-support/esp-idf.md) | \u2713 |  | RISC-V ESP-IDF\n `riscv64gc-unknown-freebsd` |   |   | RISC-V FreeBSD\n `riscv64gc-unknown-fuchsia` |   |   | RISC-V Fuchsia\n `riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)"}, {"sha": "8a4ca347e22f5b19d13868f93412f112fd453729", "filename": "src/doc/rustc/src/platform-support/esp-idf.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fesp-idf.md", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fesp-idf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fesp-idf.md?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,41 @@\n+# `*-esp-espidf`\n+\n+**Tier: 3**\n+\n+Targets for the [ESP-IDF](https://github.com/espressif/esp-idf) development framework running on RISC-V and Xtensa CPUs.\n+\n+## Target maintainers\n+\n+- Ivan Markov [@ivmarkov](https://github.com/ivmarkov)\n+- Scott Mabin [@MabezDev](https://github.com/MabezDev)\n+\n+## Requirements\n+\n+The target names follow this format: `$ARCH-esp-espidf`, where `$ARCH` specifies the target processor architecture. The following targets are currently defined:\n+\n+|          Target name           | Target CPU(s)         |\n+|--------------------------------|-----------------------|\n+| `riscv32imc-esp-espidf`        |  [ESP32-C3](https://www.espressif.com/en/products/socs/esp32-c3)             |\n+\n+The minimum supported ESP-IDF version is `v4.3`, though it is recommended to use the latest stable release if possible.\n+\n+## Building the target\n+\n+The target can be built by enabling it for a `rustc` build. The `build-std` feature is required to build the standard library for ESP-IDF. `ldproxy` is also required for linking, it can be installed from crates.io.\n+\n+```toml\n+[build]\n+target = [\"$ARCH-esp-espidf\"]\n+\n+[target.$ARCH-esp-espidf]\n+linker = \"ldproxy\"\n+\n+[unstable]\n+build-std = [\"std\", \"panic_abort\"]\n+```\n+\n+The `esp-idf-sys` crate will handle the compilation of ESP-IDF, including downloading the relevant toolchains for the build.\n+\n+## Cross-compilation toolchains and C code\n+\n+`esp-idf-sys` exposes the toolchain used in the compilation of ESP-IDF, see the crate [documentation for build output propagation](https://github.com/esp-rs/esp-idf-sys#conditional-compilation) for more information."}, {"sha": "59a3e63172406892bf116ff252e1268fae0a39cd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 50, "deletions": 32, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -119,7 +119,39 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n     });\n \n     let kind = ModuleItem(Module { items, span });\n-    Item::from_def_id_and_parts(doc.def_id.to_def_id(), Some(doc.name), kind, cx)\n+    generate_item_with_correct_attrs(cx, kind, doc.def_id, doc.name, doc.import_id, doc.renamed)\n+}\n+\n+fn generate_item_with_correct_attrs(\n+    cx: &mut DocContext<'_>,\n+    kind: ItemKind,\n+    local_def_id: LocalDefId,\n+    name: Symbol,\n+    import_id: Option<LocalDefId>,\n+    renamed: Option<Symbol>,\n+) -> Item {\n+    let def_id = local_def_id.to_def_id();\n+    let target_attrs = inline::load_attrs(cx, def_id);\n+    let attrs = if let Some(import_id) = import_id {\n+        let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n+            .lists(sym::doc)\n+            .get_word_attr(sym::inline)\n+            .is_some();\n+        let mut attrs = get_all_import_attributes(cx, import_id, local_def_id, is_inline);\n+        add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n+        attrs\n+    } else {\n+        // We only keep the item's attributes.\n+        target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n+    };\n+\n+    let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n+    let attrs = Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n+\n+    let name = renamed.or(Some(name));\n+    let mut item = Item::from_def_id_and_attrs_and_parts(def_id, name, kind, Box::new(attrs), cfg);\n+    item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n+    item\n }\n \n fn clean_generic_bound<'tcx>(\n@@ -2345,29 +2377,14 @@ fn clean_maybe_renamed_item<'tcx>(\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        let target_attrs = inline::load_attrs(cx, def_id);\n-        let attrs = if let Some(import_id) = import_id {\n-            let is_inline = inline::load_attrs(cx, import_id.to_def_id())\n-                .lists(sym::doc)\n-                .get_word_attr(sym::inline)\n-                .is_some();\n-            let mut attrs =\n-                get_all_import_attributes(cx, import_id, item.owner_id.def_id, is_inline);\n-            add_without_unwanted_attributes(&mut attrs, target_attrs, is_inline, None);\n-            attrs\n-        } else {\n-            // We only keep the item's attributes.\n-            target_attrs.iter().map(|attr| (Cow::Borrowed(attr), None)).collect()\n-        };\n-\n-        let cfg = attrs.cfg(cx.tcx, &cx.cache.hidden_cfg);\n-        let attrs =\n-            Attributes::from_ast_iter(attrs.iter().map(|(attr, did)| (&**attr, *did)), false);\n-\n-        let mut item =\n-            Item::from_def_id_and_attrs_and_parts(def_id, Some(name), kind, Box::new(attrs), cfg);\n-        item.inline_stmt_id = import_id.map(|local| local.to_def_id());\n-        vec![item]\n+        vec![generate_item_with_correct_attrs(\n+            cx,\n+            kind,\n+            item.owner_id.def_id,\n+            name,\n+            import_id,\n+            renamed,\n+        )]\n     })\n }\n \n@@ -2397,14 +2414,15 @@ fn clean_impl<'tcx>(\n     }\n \n     let for_ = clean_ty(impl_.self_ty, cx);\n-    let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n-        DefKind::TyAlias => Some(clean_middle_ty(\n-            ty::Binder::dummy(tcx.type_of(did).subst_identity()),\n-            cx,\n-            Some(did),\n-        )),\n-        _ => None,\n-    });\n+    let type_alias =\n+        for_.def_id(&cx.cache).and_then(|alias_def_id: DefId| match tcx.def_kind(alias_def_id) {\n+            DefKind::TyAlias => Some(clean_middle_ty(\n+                ty::Binder::dummy(tcx.type_of(def_id).subst_identity()),\n+                cx,\n+                Some(def_id.to_def_id()),\n+            )),\n+            _ => None,\n+        });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Box::new(Impl {\n             unsafety: impl_.unsafety,"}, {"sha": "c0730e90740ebf02e06641a0fd9af3f04177b7f9", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -195,7 +195,13 @@ impl Cache {\n impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.item_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.item_id);\n+            let is_stripped = matches!(*item.kind, clean::ItemKind::StrippedItem(..));\n+            debug!(\n+                \"folding {} (stripped: {is_stripped:?}) \\\"{:?}\\\", id {:?}\",\n+                item.type_(),\n+                item.name,\n+                item.item_id\n+            );\n         }\n \n         // If this is a stripped module,"}, {"sha": "10295cbd189b110357ff0f981a972b8062463a8f", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -95,7 +95,7 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n     }\n \n     if cx.tcx.is_doc_hidden(def_id.to_def_id())\n-        || inherits_doc_hidden(cx.tcx, def_id)\n+        || inherits_doc_hidden(cx.tcx, def_id, None)\n         || cx.tcx.def_span(def_id.to_def_id()).in_derive_expansion()\n     {\n         return false;"}, {"sha": "972b0c5ec190ea85d0c53d0781c20b4601aff48d", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,5 +1,6 @@\n //! Strip all doc(hidden) items from the output.\n \n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n use std::mem;\n@@ -29,6 +30,7 @@ pub(crate) fn strip_hidden(krate: clean::Crate, cx: &mut DocContext<'_>) -> clea\n             update_retained: true,\n             tcx: cx.tcx,\n             is_in_hidden_item: false,\n+            last_reexport: None,\n         };\n         stripper.fold_crate(krate)\n     };\n@@ -49,13 +51,24 @@ struct Stripper<'a, 'tcx> {\n     update_retained: bool,\n     tcx: TyCtxt<'tcx>,\n     is_in_hidden_item: bool,\n+    last_reexport: Option<LocalDefId>,\n }\n \n impl<'a, 'tcx> Stripper<'a, 'tcx> {\n+    fn set_last_reexport_then_fold_item(&mut self, i: Item) -> Item {\n+        let prev_from_reexport = self.last_reexport;\n+        if i.inline_stmt_id.is_some() {\n+            self.last_reexport = i.item_id.as_def_id().and_then(|def_id| def_id.as_local());\n+        }\n+        let ret = self.fold_item_recur(i);\n+        self.last_reexport = prev_from_reexport;\n+        ret\n+    }\n+\n     fn set_is_in_hidden_item_and_fold(&mut self, is_in_hidden_item: bool, i: Item) -> Item {\n         let prev = self.is_in_hidden_item;\n         self.is_in_hidden_item |= is_in_hidden_item;\n-        let ret = self.fold_item_recur(i);\n+        let ret = self.set_last_reexport_then_fold_item(i);\n         self.is_in_hidden_item = prev;\n         ret\n     }\n@@ -64,7 +77,7 @@ impl<'a, 'tcx> Stripper<'a, 'tcx> {\n     /// of `is_in_hidden_item` to `true` because the impl children inherit its visibility.\n     fn recurse_in_impl_or_exported_macro(&mut self, i: Item) -> Item {\n         let prev = mem::replace(&mut self.is_in_hidden_item, false);\n-        let ret = self.fold_item_recur(i);\n+        let ret = self.set_last_reexport_then_fold_item(i);\n         self.is_in_hidden_item = prev;\n         ret\n     }\n@@ -86,13 +99,20 @@ impl<'a, 'tcx> DocFolder for Stripper<'a, 'tcx> {\n         if !is_impl_or_exported_macro {\n             is_hidden = self.is_in_hidden_item || has_doc_hidden;\n             if !is_hidden && i.inline_stmt_id.is_none() {\n-                // We don't need to check if it's coming from a reexport since the reexport itself was\n-                // already checked.\n+                // `i.inline_stmt_id` is `Some` if the item is directly reexported. If it is, we\n+                // don't need to check it, because the reexport itself was already checked.\n+                //\n+                // If this item is the child of a reexported module, `self.last_reexport` will be\n+                // `Some` even though `i.inline_stmt_id` is `None`. Hiddenness inheritance needs to\n+                // account for the possibility that an item's true parent module is hidden, but it's\n+                // inlined into a visible module true. This code shouldn't be reachable if the\n+                // module's reexport is itself hidden, for the same reason it doesn't need to be\n+                // checked if `i.inline_stmt_id` is Some: hidden reexports are never inlined.\n                 is_hidden = i\n                     .item_id\n                     .as_def_id()\n                     .and_then(|def_id| def_id.as_local())\n-                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id))\n+                    .map(|def_id| inherits_doc_hidden(self.tcx, def_id, self.last_reexport))\n                     .unwrap_or(false);\n             }\n         }"}, {"sha": "deb29b1e7a9115166387374e43017155028f4704", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -27,6 +27,8 @@ pub(crate) struct Module<'hir> {\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n     pub(crate) def_id: LocalDefId,\n+    pub(crate) renamed: Option<Symbol>,\n+    pub(crate) import_id: Option<LocalDefId>,\n     /// The key is the item `ItemId` and the value is: (item, renamed, import_id).\n     /// We use `FxIndexMap` to keep the insert order.\n     pub(crate) items: FxIndexMap<\n@@ -37,11 +39,19 @@ pub(crate) struct Module<'hir> {\n }\n \n impl Module<'_> {\n-    pub(crate) fn new(name: Symbol, def_id: LocalDefId, where_inner: Span) -> Self {\n+    pub(crate) fn new(\n+        name: Symbol,\n+        def_id: LocalDefId,\n+        where_inner: Span,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) -> Self {\n         Module {\n             name,\n             def_id,\n             where_inner,\n+            renamed,\n+            import_id,\n             mods: Vec::new(),\n             items: FxIndexMap::default(),\n             foreigns: Vec::new(),\n@@ -60,9 +70,16 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut def_id: LocalDefId) -> bool {\n+pub(crate) fn inherits_doc_hidden(\n+    tcx: TyCtxt<'_>,\n+    mut def_id: LocalDefId,\n+    stop_at: Option<LocalDefId>,\n+) -> bool {\n     let hir = tcx.hir();\n     while let Some(id) = tcx.opt_local_parent(def_id) {\n+        if let Some(stop_at) = stop_at && id == stop_at {\n+            return false;\n+        }\n         def_id = id;\n         if tcx.is_doc_hidden(def_id.to_def_id()) {\n             return true;\n@@ -100,6 +117,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             cx.tcx.crate_name(LOCAL_CRATE),\n             CRATE_DEF_ID,\n             cx.tcx.hir().root_module().spans.inner_span,\n+            None,\n+            None,\n         );\n \n         RustdocVisitor {\n@@ -261,7 +280,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n         let is_private =\n             !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, ori_res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n+        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did, None);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n@@ -278,7 +297,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 .cache\n                 .effective_visibilities\n                 .is_directly_public(self.cx.tcx, item_def_id.to_def_id()) &&\n-            !inherits_doc_hidden(self.cx.tcx, item_def_id)\n+            !inherits_doc_hidden(self.cx.tcx, item_def_id, None)\n         {\n             // The imported item is public and not `doc(hidden)` so no need to inline it.\n             return false;\n@@ -427,7 +446,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                self.enter_mod(item.owner_id.def_id, m, name);\n+                self.enter_mod(item.owner_id.def_id, m, name, renamed, import_id);\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)\n@@ -480,8 +499,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// This method will create a new module and push it onto the \"modules stack\" then call\n     /// `visit_mod_contents`. Once done, it'll remove it from the \"modules stack\" and instead\n     /// add into the list of modules of the current module.\n-    fn enter_mod(&mut self, id: LocalDefId, m: &'tcx hir::Mod<'tcx>, name: Symbol) {\n-        self.modules.push(Module::new(name, id, m.spans.inner_span));\n+    fn enter_mod(\n+        &mut self,\n+        id: LocalDefId,\n+        m: &'tcx hir::Mod<'tcx>,\n+        name: Symbol,\n+        renamed: Option<Symbol>,\n+        import_id: Option<LocalDefId>,\n+    ) {\n+        self.modules.push(Module::new(name, id, m.spans.inner_span, renamed, import_id));\n \n         self.visit_mod_contents(id, m);\n \n@@ -501,19 +527,14 @@ impl<'a, 'tcx> Visitor<'tcx> for RustdocVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         self.visit_item_inner(i, None, None);\n-        let new_value = if self.is_importable_from_parent {\n-            matches!(\n+        let new_value = self.is_importable_from_parent\n+            && matches!(\n                 i.kind,\n                 hir::ItemKind::Mod(..)\n                     | hir::ItemKind::ForeignMod { .. }\n                     | hir::ItemKind::Impl(..)\n                     | hir::ItemKind::Trait(..)\n-            )\n-        } else {\n-            // Whatever the context, if it's an impl block, the items inside it can be used so they\n-            // should be visible.\n-            matches!(i.kind, hir::ItemKind::Impl(..))\n-        };\n+            );\n         let prev = mem::replace(&mut self.is_importable_from_parent, new_value);\n         walk_item(self, i);\n         self.is_importable_from_parent = prev;"}, {"sha": "13413c64ff88dd6c2824e9eb9374fc5f10895d28", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1 +1 @@\n-Subproject commit 26b73d15a68fb94579f6d3590585ec0e9d81d3d5\n+Subproject commit 13413c64ff88dd6c2824e9eb9374fc5f10895d28"}, {"sha": "0d42504c7f4ca1ccbe79d46ac8916c4deeaf24e7", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -28,7 +28,7 @@ libc = \"0.2\"\n miow = \"0.5\"\n \n [target.'cfg(windows)'.dependencies.windows]\n-version = \"0.46.0\"\n+version = \"0.48.0\"\n features = [\n     \"Win32_Foundation\",\n     \"Win32_System_Diagnostics_Debug\","}, {"sha": "f49fa49d09d5e6070def6504d29411dbb6b2259c", "filename": "src/tools/miri/tests/fail/deny_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdeny_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdeny_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdeny_lint.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,6 +1,6 @@\n //@error-in-other-file: miri cannot be run on programs that fail compilation\n \n-#![deny(warnings)]\n+#![deny(warnings, unused)]\n \n struct Foo;\n //~^ ERROR: struct `Foo` is never constructed"}, {"sha": "d1c9b4818071ac0be8b7c5ce954cee18b6db71ea", "filename": "src/tools/miri/tests/fail/deny_lint.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdeny_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdeny_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdeny_lint.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -4,7 +4,12 @@ error: struct `Foo` is never constructed\n LL | struct Foo;\n    |        ^^^\n    |\n-   = note: `-D dead-code` implied by `-D unused`\n+note: the lint level is defined here\n+  --> $DIR/deny_lint.rs:LL:CC\n+   |\n+LL | #![deny(warnings, unused)]\n+   |                   ^^^^^^\n+   = note: `#[deny(dead_code)]` implied by `#[deny(unused)]`\n \n error: miri cannot be run on programs that fail compilation\n "}, {"sha": "10939c0f1c38a82bb57f6ab3caf8a887e5c47878", "filename": "src/tools/miri/tests/fail/intrinsics/simd-float-to-int.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,9 +1,8 @@\n-//@error-in-other-file: cannot be represented in target type `i32`\n #![feature(portable_simd)]\n use std::simd::*;\n \n fn main() {\n     unsafe {\n-        let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n+        let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked(); //~ERROR: cannot be represented in target type `i32`\n     }\n }"}, {"sha": "ea5ad62aea908765d616d27fd9f9a7c6d2694974", "filename": "src/tools/miri/tests/fail/intrinsics/simd-float-to-int.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-float-to-int.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,18 +1,13 @@\n error: Undefined Behavior: `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n+  --> $DIR/simd-float-to-int.rs:LL:CC\n    |\n-LL |         unsafe { intrinsics::simd_cast(self) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n+LL |         let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `float_to_int_unchecked` intrinsic called on 3.40282347E+38 which cannot be represented in target type `i32`\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:\n-   = note: inside `std::simd::Simd::<f32, 2>::to_int_unchecked::<i32>` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-note: inside `main`\n-  --> $DIR/simd-float-to-int.rs:LL:CC\n-   |\n-LL |         let _x: i32x2 = f32x2::from_array([f32::MAX, f32::MIN]).to_int_unchecked();\n-   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: inside `main` at $DIR/simd-float-to-int.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "ceb7beebd8abad93bd8e3559032a049b372f41e5", "filename": "src/tools/miri/tests/fail/intrinsics/simd-gather.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,11 +1,10 @@\n-//@error-in-other-file: pointer to 1 byte starting at offset 9 is out-of-bounds\n #![feature(portable_simd)]\n use std::simd::*;\n \n fn main() {\n     unsafe {\n         let vec: &[i8] = &[10, 11, 12, 13, 14, 15, 16, 17, 18];\n         let idxs = Simd::from_array([9, 3, 0, 17]);\n-        let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0));\n+        let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0)); //~ERROR: pointer to 1 byte starting at offset 9 is out-of-bounds\n     }\n }"}, {"sha": "f82b30a9633ee4e29ee449815ae6daa64edbd5f3", "filename": "src/tools/miri/tests/fail/intrinsics/simd-gather.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-gather.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,18 +1,13 @@\n error: Undefined Behavior: dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n+  --> $DIR/simd-gather.rs:LL:CC\n    |\n-LL |         unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n+LL |         let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0));\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n    |\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n    = note: BACKTRACE:\n-   = note: inside `std::simd::Simd::<i8, 4>::gather_select_unchecked` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-note: inside `main`\n-  --> $DIR/simd-gather.rs:LL:CC\n-   |\n-LL |         let _result = Simd::gather_select_unchecked(&vec, Mask::splat(true), idxs, Simd::splat(0));\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: inside `main` at $DIR/simd-gather.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "606a6b2798a088854beb00d34e81f544408c47a1", "filename": "src/tools/miri/tests/fail/intrinsics/simd-scatter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,12 +1,11 @@\n-//@error-in-other-file: pointer to 1 byte starting at offset 9 is out-of-bounds\n #![feature(portable_simd)]\n use std::simd::*;\n \n fn main() {\n     unsafe {\n         let mut vec: Vec<i8> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n         let idxs = Simd::from_array([9, 3, 0, 17]);\n-        Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(\n+        Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked( //~ERROR: pointer to 1 byte starting at offset 9 is out-of-bounds\n             &mut vec,\n             Mask::splat(true),\n             idxs,"}, {"sha": "6d959af85fa751021b9c20f48382350ed87d05fb", "filename": "src/tools/miri/tests/fail/intrinsics/simd-scatter.stderr", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fsimd-scatter.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,22 +1,17 @@\n error: Undefined Behavior: dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n-  --> RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-   |\n-LL |             intrinsics::simd_scatter(self, ptrs, enable.to_int())\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n-   |\n-   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n-   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n-   = note: inside `std::simd::Simd::<i8, 4>::scatter_select_unchecked` at RUSTLIB/core/src/../../portable-simd/crates/core_simd/src/vector.rs:LL:CC\n-note: inside `main`\n   --> $DIR/simd-scatter.rs:LL:CC\n    |\n LL | /         Simd::from_array([-27, 82, -41, 124]).scatter_select_unchecked(\n LL | |             &mut vec,\n LL | |             Mask::splat(true),\n LL | |             idxs,\n LL | |         );\n-   | |_________^\n+   | |_________^ dereferencing pointer failed: ALLOC has size 9, so pointer to 1 byte starting at offset 9 is out-of-bounds\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/simd-scatter.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n "}, {"sha": "b26480f668b370f67bae98a3b5317e186af79ffc", "filename": "src/tools/rustdoc-gui/tester.js", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Frustdoc-gui%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Frustdoc-gui%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-gui%2Ftester.js?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -143,7 +143,7 @@ async function runTests(opts, framework_options, files, results, status_bar, sho\n     const tests_queue = [];\n \n     for (const testPath of files) {\n-        const callback = runTest(testPath, framework_options)\n+        const callback = runTest(testPath, {\"options\": framework_options})\n             .then(out => {\n                 const [output, nb_failures] = out;\n                 results[nb_failures === 0 ? \"successful\" : \"failed\"].push({\n@@ -323,6 +323,7 @@ async function main(argv) {\n     if (results.failed.length > 0 || results.errored.length > 0) {\n         process.exit(1);\n     }\n+    process.exit(0);\n }\n \n main(process.argv);"}, {"sha": "afa6bce943f34b249d7abff91439ef0701beaff5", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -6,47 +6,53 @@ use std::path::Path;\n \n /// These are licenses that are allowed for all crates, including the runtime,\n /// rustc, tools, etc.\n+#[rustfmt::skip]\n const LICENSES: &[&str] = &[\n-    \"MIT/Apache-2.0\",\n-    \"MIT / Apache-2.0\",\n-    \"Apache-2.0/MIT\",\n+    // tidy-alphabetical-start\n+    \"(MIT OR Apache-2.0) AND Unicode-DFS-2016\",            // unicode_ident\n+    \"0BSD OR MIT OR Apache-2.0\",                           // adler license\n+    \"0BSD\",\n     \"Apache-2.0 / MIT\",\n-    \"MIT OR Apache-2.0\",\n     \"Apache-2.0 OR MIT\",\n     \"Apache-2.0 WITH LLVM-exception OR Apache-2.0 OR MIT\", // wasi license\n-    \"MIT\",\n+    \"Apache-2.0/MIT\",\n     \"ISC\",\n-    \"Unlicense/MIT\",\n+    \"MIT / Apache-2.0\",\n+    \"MIT OR Apache-2.0 OR Zlib\",                           // tinyvec_macros\n+    \"MIT OR Apache-2.0\",\n+    \"MIT OR Zlib OR Apache-2.0\",                           // miniz_oxide\n+    \"MIT\",\n+    \"MIT/Apache-2.0\",\n+    \"Unicode-DFS-2016\",                                    // tinystr and icu4x\n     \"Unlicense OR MIT\",\n-    \"0BSD\",\n-    \"0BSD OR MIT OR Apache-2.0\",                // adler license\n-    \"Zlib OR Apache-2.0 OR MIT\",                // tinyvec\n-    \"MIT OR Apache-2.0 OR Zlib\",                // tinyvec_macros\n-    \"MIT OR Zlib OR Apache-2.0\",                // miniz_oxide\n-    \"(MIT OR Apache-2.0) AND Unicode-DFS-2016\", // unicode_ident\n-    \"Unicode-DFS-2016\",                         // tinystr and icu4x\n+    \"Unlicense/MIT\",\n+    \"Zlib OR Apache-2.0 OR MIT\",                           // tinyvec\n+    // tidy-alphabetical-end\n ];\n \n /// These are exceptions to Rust's permissive licensing policy, and\n /// should be considered bugs. Exceptions are only allowed in Rust\n /// tooling. It is _crucial_ that no exception crates be dependencies\n /// of the Rust runtime (std/test).\n+#[rustfmt::skip]\n const EXCEPTIONS: &[(&str, &str)] = &[\n+    // tidy-alphabetical-start\n     (\"ar_archive_writer\", \"Apache-2.0 WITH LLVM-exception\"), // rustc\n-    (\"mdbook\", \"MPL-2.0\"),                                   // mdbook\n+    (\"codespan-reporting\", \"Apache-2.0\"),                    // cxx via iana-time-zone-haiku via time, only on haiku\n     (\"colored\", \"MPL-2.0\"),                                  // rustfmt\n+    (\"dissimilar\", \"Apache-2.0\"),                            // rustdoc, rustc_lexer (few tests) via expect-test, (dev deps)\n+    (\"fluent-langneg\", \"Apache-2.0\"),                        // rustc (fluent translations)\n+    (\"fortanix-sgx-abi\", \"MPL-2.0\"),                         // libstd but only for `sgx` target. FIXME: this dependency violates the documentation comment above.\n+    (\"instant\", \"BSD-3-Clause\"),                             // rustc_driver/tracing-subscriber/parking_lot\n+    (\"mdbook\", \"MPL-2.0\"),                                   // mdbook\n     (\"ryu\", \"Apache-2.0 OR BSL-1.0\"),                        // cargo/... (because of serde)\n-    (\"codespan-reporting\", \"Apache-2.0\"), // cxx via iana-time-zone-haiku via time, only on haiku\n-    (\"instant\", \"BSD-3-Clause\"),          // rustc_driver/tracing-subscriber/parking_lot\n-    (\"snap\", \"BSD-3-Clause\"),             // rustc\n-    (\"fluent-langneg\", \"Apache-2.0\"),     // rustc (fluent translations)\n-    (\"self_cell\", \"Apache-2.0\"),          // rustc (fluent translations)\n-    // FIXME: this dependency violates the documentation comment above:\n-    (\"fortanix-sgx-abi\", \"MPL-2.0\"), // libstd but only for `sgx` target\n-    (\"dissimilar\", \"Apache-2.0\"),    // rustdoc, rustc_lexer (few tests) via expect-test, (dev deps)\n+    (\"self_cell\", \"Apache-2.0\"),                             // rustc (fluent translations)\n+    (\"snap\", \"BSD-3-Clause\"),                                // rustc\n+    // tidy-alphabetical-end\n ];\n \n const EXCEPTIONS_CARGO: &[(&str, &str)] = &[\n+    // tidy-alphabetical-start\n     (\"bitmaps\", \"MPL-2.0+\"),\n     (\"bytesize\", \"Apache-2.0\"),\n     (\"dunce\", \"CC0-1.0 OR MIT-0\"),\n@@ -62,9 +68,11 @@ const EXCEPTIONS_CARGO: &[(&str, &str)] = &[\n     (\"sized-chunks\", \"MPL-2.0+\"),\n     (\"subtle\", \"BSD-3-Clause\"),\n     (\"unicode-bom\", \"Apache-2.0\"),\n+    // tidy-alphabetical-end\n ];\n \n const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n+    // tidy-alphabetical-start\n     (\"cranelift-bforest\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-codegen\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"cranelift-codegen-meta\", \"Apache-2.0 WITH LLVM-exception\"),\n@@ -80,6 +88,7 @@ const EXCEPTIONS_CRANELIFT: &[(&str, &str)] = &[\n     (\"regalloc2\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"target-lexicon\", \"Apache-2.0 WITH LLVM-exception\"),\n     (\"wasmtime-jit-icache-coherence\", \"Apache-2.0 WITH LLVM-exception\"),\n+    // tidy-alphabetical-end\n ];\n \n const EXCEPTIONS_BOOTSTRAP: &[(&str, &str)] = &[\n@@ -95,6 +104,7 @@ const RUNTIME_CRATES: &[&str] = &[\"std\", \"core\", \"alloc\", \"test\", \"panic_abort\",\n /// This list is here to provide a speed-bump to adding a new dependency to\n /// rustc. Please check with the compiler team before adding an entry.\n const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n+    // tidy-alphabetical-start\n     \"addr2line\",\n     \"adler\",\n     \"ahash\",\n@@ -113,8 +123,8 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"chalk-engine\",\n     \"chalk-ir\",\n     \"chalk-solve\",\n-    \"convert_case\", // dependency of derive_more\n     \"compiler_builtins\",\n+    \"convert_case\", // dependency of derive_more\n     \"cpufeatures\",\n     \"crc32fast\",\n     \"crossbeam-channel\",\n@@ -187,8 +197,8 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"ppv-lite86\",\n     \"proc-macro-hack\",\n     \"proc-macro2\",\n-    \"pulldown-cmark\",\n     \"psm\",\n+    \"pulldown-cmark\",\n     \"punycode\",\n     \"quote\",\n     \"rand\",\n@@ -227,14 +237,14 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"tempfile\",\n     \"termcolor\",\n     \"termize\",\n+    \"thin-vec\",\n     \"thiserror\",\n     \"thiserror-impl\",\n     \"thorin-dwp\",\n     \"thread_local\",\n     \"tinystr\",\n     \"tinyvec\",\n     \"tinyvec_macros\",\n-    \"thin-vec\",\n     \"tracing\",\n     \"tracing-attributes\",\n     \"tracing-core\",\n@@ -263,29 +273,37 @@ const PERMITTED_RUSTC_DEPENDENCIES: &[&str] = &[\n     \"valuable\",\n     \"version_check\",\n     \"wasi\",\n-    \"windows\",\n     \"winapi\",\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-util\",\n     \"winapi-x86_64-pc-windows-gnu\",\n+    \"windows\",\n+    \"windows-targets\",\n+    \"windows_aarch64_gnullvm\",\n+    \"windows_aarch64_msvc\",\n+    \"windows_i686_gnu\",\n+    \"windows_i686_msvc\",\n+    \"windows_x86_64_gnu\",\n+    \"windows_x86_64_gnullvm\",\n+    \"windows_x86_64_msvc\",\n     \"writeable\",\n-    // this is a false-positive: it's only used by rustfmt, but because it's enabled through a\n-    // feature, tidy thinks it's used by rustc as well.\n-    \"yansi-term\",\n+    \"yansi-term\", // this is a false-positive: it's only used by rustfmt, but because it's enabled through a feature, tidy thinks it's used by rustc as well.\n     \"yoke\",\n     \"yoke-derive\",\n     \"zerofrom\",\n     \"zerofrom-derive\",\n     \"zerovec\",\n     \"zerovec-derive\",\n+    // tidy-alphabetical-end\n ];\n \n const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n+    // tidy-alphabetical-start\n     \"ahash\",\n     \"anyhow\",\n     \"autocfg\",\n-    \"bumpalo\",\n     \"bitflags\",\n+    \"bumpalo\",\n     \"byteorder\",\n     \"cfg-if\",\n     \"cranelift-bforest\",\n@@ -324,6 +342,7 @@ const PERMITTED_CRANELIFT_DEPENDENCIES: &[&str] = &[\n     \"winapi-i686-pc-windows-gnu\",\n     \"winapi-x86_64-pc-windows-gnu\",\n     \"windows-sys\",\n+    // tidy-alphabetical-end\n ];\n \n /// Dependency checks."}, {"sha": "ab5dcec7936ca2db6621aa9f2860e54d0ab54510", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-trait-objects.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-trait-objects.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,44 @@\n+// Verifies that type metadata identifiers for trait objects are emitted correctly.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+trait Trait1 {\n+    fn foo(&self);\n+}\n+\n+struct Type1;\n+\n+impl Trait1 for Type1 {\n+    fn foo(&self) {\n+    }\n+}\n+\n+pub fn foo() {\n+    let a = Type1;\n+    a.foo();\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_cfi_emit_type_metadata_trait_objects::Type1 as sanitizer_cfi_emit_type_metadata_trait_objects::Trait1>::foo\n+}\n+\n+pub fn bar() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}bar{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0|%1}}, metadata !\"[[TYPE1:[[:print:]]+]]\")\n+}\n+\n+pub fn baz() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    a.foo();\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}baz{{.*}}!type !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_cfi_emit_type_metadata_trait_objects::Type1 as sanitizer_cfi_emit_type_metadata_trait_objects::Trait1>::foo\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0|%1}}, metadata !\"[[TYPE1:[[:print:]]+]]\")\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i64 0, !\"[[TYPE1]]\"}"}, {"sha": "81e0d9344f7e4413d88f4a31c1d8efdaad181b0d", "filename": "tests/codegen/sanitizer-kcfi-emit-type-metadata-trait-objects.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fcodegen%2Fsanitizer-kcfi-emit-type-metadata-trait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fcodegen%2Fsanitizer-kcfi-emit-type-metadata-trait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-type-metadata-trait-objects.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,69 @@\n+// Verifies that type metadata identifiers for trait objects are emitted correctly.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Copt-level=0\n+\n+#![crate_type=\"lib\"]\n+#![feature(arbitrary_self_types, no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+#[lang=\"receiver\"]\n+trait Receiver { }\n+#[lang=\"dispatch_from_dyn\"]\n+trait DispatchFromDyn<T> { }\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+#[lang = \"unsize\"]\n+trait Unsize<T: ?Sized> { }\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T: ?Sized> { }\n+impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+#[lang=\"freeze\"]\n+trait Freeze { }\n+#[lang=\"drop_in_place\"]\n+fn drop_in_place_fn<T>() { }\n+\n+trait Trait1 {\n+    fn foo(&self);\n+}\n+\n+struct Type1;\n+\n+impl Trait1 for Type1 {\n+    fn foo(&self) {\n+    }\n+}\n+\n+pub fn foo() {\n+    let a = Type1;\n+    a.foo();\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_kcfi_emit_type_metadata_trait_objects::Type1 as sanitizer_kcfi_emit_type_metadata_trait_objects::Trait1>::foo\n+}\n+\n+pub fn bar() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}bar{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       call void %0({{\\{\\}\\*|ptr}} align 1 {{%b\\.0|%_1}}){{.*}}[ \"kcfi\"(i32 [[TYPE1:[[:print:]]+]]) ]\n+}\n+\n+pub fn baz() {\n+    let a = Type1;\n+    let b = &a as &dyn Trait1;\n+    a.foo();\n+    b.foo();\n+    // CHECK-LABEL: define{{.*}}baz{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       call <sanitizer_kcfi_emit_type_metadata_trait_objects::Type1 as sanitizer_kcfi_emit_type_metadata_trait_objects::Trait1>::foo\n+    // CHECK:       call void %0({{\\{\\}\\*|ptr}} align 1 {{%b\\.0|%_1}}){{.*}}[ \"kcfi\"(i32 [[TYPE1:[[:print:]]+]]) ]\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 [[TYPE1]]}"}, {"sha": "88b7edff260939ac95edfd013551862c69f518a2", "filename": "tests/codegen/vec-shrink-panik.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fcodegen%2Fvec-shrink-panik.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fcodegen%2Fvec-shrink-panik.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvec-shrink-panik.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -25,7 +25,7 @@ pub fn issue71861(vec: Vec<u32>) -> Box<[u32]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: filter\n+    // old: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n \n@@ -40,7 +40,7 @@ pub fn issue75636<'a>(iter: &[&'a str]) -> Box<[&'a str]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected,\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: filter\n+    // old: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n "}, {"sha": "5866439055e8da5b560fa0d9d7e16114301bc667", "filename": "tests/mir-opt/copy-prop/partial_init.main.CopyProp.diff", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.main.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.main.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.main.CopyProp.diff?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,13 @@\n+- // MIR for `main` before CopyProp\n++ // MIR for `main` after CopyProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/partial_init.rs:+0:15: +0:15\n+      let mut _1: (isize,);                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+          (_1.0: isize) = const 1_isize;   // scope 0 at $DIR/partial_init.rs:+4:13: +4:20\n+          return;                          // scope 0 at $DIR/partial_init.rs:+5:13: +5:21\n+      }\n+  }\n+  "}, {"sha": "f5ab9974f71e514b7e49a26939508bcd2d9cb359", "filename": "tests/mir-opt/copy-prop/partial_init.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,18 @@\n+// unit-test: CopyProp\n+// Verify that we do not ICE on partial initializations.\n+\n+#![feature(custom_mir, core_intrinsics)]\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR partial_init.main.CopyProp.diff\n+#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\n+pub fn main() {\n+    mir! (\n+        let x: (isize, );\n+        {\n+            x.0 = 1;\n+            Return()\n+        }\n+    )\n+}"}, {"sha": "217f27efe5cc9eff3f1226110f9552c1725addcb", "filename": "tests/mir-opt/lower_intrinsics.wrapping.LowerIntrinsics.diff", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Flower_intrinsics.wrapping.LowerIntrinsics.diff?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -30,10 +30,10 @@\n           _4 = _1;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:45: +1:46\n           StorageLive(_5);                 // scope 0 at $DIR/lower_intrinsics.rs:+1:48: +1:49\n           _5 = _2;                         // scope 0 at $DIR/lower_intrinsics.rs:+1:48: +1:49\n--         _3 = wrapping_add::<i32>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n+-         _3 = std::intrinsics::wrapping_add::<i32>(move _4, move _5) -> [return: bb1, unwind unreachable]; // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:9:14: 9:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_add::<i32>}, val: Value(<ZST>) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {std::intrinsics::wrapping_add::<i32>}, val: Value(<ZST>) }\n +         _3 = Add(move _4, move _5);      // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n +         goto -> bb1;                     // scope 0 at $DIR/lower_intrinsics.rs:+1:14: +1:50\n       }\n@@ -46,10 +46,10 @@\n           _7 = _1;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:45: +2:46\n           StorageLive(_8);                 // scope 1 at $DIR/lower_intrinsics.rs:+2:48: +2:49\n           _8 = _2;                         // scope 1 at $DIR/lower_intrinsics.rs:+2:48: +2:49\n--         _6 = wrapping_sub::<i32>(move _7, move _8) -> [return: bb2, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n+-         _6 = std::intrinsics::wrapping_sub::<i32>(move _7, move _8) -> [return: bb2, unwind unreachable]; // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n -                                          // mir::Constant\n -                                          // + span: $DIR/lower_intrinsics.rs:10:14: 10:44\n--                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {wrapping_sub::<i32>}, val: Value(<ZST>) }\n+-                                          // + literal: Const { ty: extern \"rust-intrinsic\" fn(i32, i32) -> i32 {std::intrinsics::wrapping_sub::<i32>}, val: Value(<ZST>) }\n +         _6 = Sub(move _7, move _8);      // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n +         goto -> bb2;                     // scope 1 at $DIR/lower_intrinsics.rs:+2:14: +2:50\n       }"}, {"sha": "af8ee2411d36dc9cc70fd6aeae4ce43246e40fb9", "filename": "tests/mir-opt/reference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,74 @@\n+- // MIR for `mut_raw_then_mut_shr` before ReferencePropagation\n++ // MIR for `mut_raw_then_mut_shr` after ReferencePropagation\n+  \n+  fn mut_raw_then_mut_shr() -> (i32, i32) {\n+      let mut _0: (i32, i32);              // return place in scope 0 at $DIR/reference_prop.rs:+0:30: +0:40\n+      let mut _1: i32;                     // in scope 0 at $DIR/reference_prop.rs:+1:9: +1:14\n+      let mut _4: *mut i32;                // in scope 0 at $DIR/reference_prop.rs:+3:16: +3:36\n+      let mut _5: &mut i32;                // in scope 0 at $DIR/reference_prop.rs:+3:16: +3:26\n+      let _8: ();                          // in scope 0 at $DIR/reference_prop.rs:+7:5: +7:26\n+      let mut _9: i32;                     // in scope 0 at $DIR/reference_prop.rs:+8:6: +8:7\n+      let mut _10: i32;                    // in scope 0 at $DIR/reference_prop.rs:+8:9: +8:10\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/reference_prop.rs:+1:9: +1:14\n+          let _2: &mut i32;                // in scope 1 at $DIR/reference_prop.rs:+2:9: +2:13\n+          scope 2 {\n+              debug xref => _2;            // in scope 2 at $DIR/reference_prop.rs:+2:9: +2:13\n+              let _3: *mut i32;            // in scope 2 at $DIR/reference_prop.rs:+3:9: +3:13\n+              scope 3 {\n+                  debug xraw => _3;        // in scope 3 at $DIR/reference_prop.rs:+3:9: +3:13\n+                  let _6: &i32;            // in scope 3 at $DIR/reference_prop.rs:+4:9: +4:13\n+                  scope 4 {\n+                      debug xshr => _6;    // in scope 4 at $DIR/reference_prop.rs:+4:9: +4:13\n+                      let _7: i32;         // in scope 4 at $DIR/reference_prop.rs:+6:9: +6:10\n+                      scope 5 {\n+                          debug a => _7;   // in scope 5 at $DIR/reference_prop.rs:+6:9: +6:10\n+                          scope 6 {\n+                          }\n+                      }\n+                  }\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/reference_prop.rs:+1:9: +1:14\n+          _1 = const 2_i32;                // scope 0 at $DIR/reference_prop.rs:+1:17: +1:18\n+-         StorageLive(_2);                 // scope 1 at $DIR/reference_prop.rs:+2:9: +2:13\n+          _2 = &mut _1;                    // scope 1 at $DIR/reference_prop.rs:+2:16: +2:22\n+          StorageLive(_3);                 // scope 2 at $DIR/reference_prop.rs:+3:9: +3:13\n+-         StorageLive(_4);                 // scope 2 at $DIR/reference_prop.rs:+3:16: +3:36\n+-         StorageLive(_5);                 // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n+-         _5 = &mut (*_2);                 // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n+-         _4 = &raw mut (*_5);             // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n++         _4 = &raw mut _1;                // scope 2 at $DIR/reference_prop.rs:+3:16: +3:26\n+          _3 = _4;                         // scope 2 at $DIR/reference_prop.rs:+3:16: +3:36\n+-         StorageDead(_5);                 // scope 2 at $DIR/reference_prop.rs:+3:36: +3:37\n+-         StorageDead(_4);                 // scope 2 at $DIR/reference_prop.rs:+3:36: +3:37\n+          StorageLive(_6);                 // scope 3 at $DIR/reference_prop.rs:+4:9: +4:13\n+-         _6 = &(*_2);                     // scope 3 at $DIR/reference_prop.rs:+4:16: +4:22\n++         _6 = &_1;                        // scope 3 at $DIR/reference_prop.rs:+4:16: +4:22\n+          StorageLive(_7);                 // scope 4 at $DIR/reference_prop.rs:+6:9: +6:10\n+-         _7 = (*_6);                      // scope 4 at $DIR/reference_prop.rs:+6:13: +6:18\n+-         StorageLive(_8);                 // scope 5 at $DIR/reference_prop.rs:+7:5: +7:26\n+-         (*_3) = const 4_i32;             // scope 6 at $DIR/reference_prop.rs:+7:14: +7:23\n+-         _8 = const ();                   // scope 6 at $DIR/reference_prop.rs:+7:5: +7:26\n+-         StorageDead(_8);                 // scope 5 at $DIR/reference_prop.rs:+7:25: +7:26\n++         _7 = _1;                         // scope 4 at $DIR/reference_prop.rs:+6:13: +6:18\n++         _1 = const 4_i32;                // scope 6 at $DIR/reference_prop.rs:+7:14: +7:23\n+          StorageLive(_9);                 // scope 5 at $DIR/reference_prop.rs:+8:6: +8:7\n+          _9 = _7;                         // scope 5 at $DIR/reference_prop.rs:+8:6: +8:7\n+          StorageLive(_10);                // scope 5 at $DIR/reference_prop.rs:+8:9: +8:10\n+          _10 = _1;                        // scope 5 at $DIR/reference_prop.rs:+8:9: +8:10\n+          _0 = (move _9, move _10);        // scope 5 at $DIR/reference_prop.rs:+8:5: +8:11\n+          StorageDead(_10);                // scope 5 at $DIR/reference_prop.rs:+8:10: +8:11\n+          StorageDead(_9);                 // scope 5 at $DIR/reference_prop.rs:+8:10: +8:11\n+          StorageDead(_7);                 // scope 4 at $DIR/reference_prop.rs:+9:1: +9:2\n+          StorageDead(_6);                 // scope 3 at $DIR/reference_prop.rs:+9:1: +9:2\n+          StorageDead(_3);                 // scope 2 at $DIR/reference_prop.rs:+9:1: +9:2\n+-         StorageDead(_2);                 // scope 1 at $DIR/reference_prop.rs:+9:1: +9:2\n+          StorageDead(_1);                 // scope 0 at $DIR/reference_prop.rs:+9:1: +9:2\n+          return;                          // scope 0 at $DIR/reference_prop.rs:+9:2: +9:2\n+      }\n+  }\n+  "}, {"sha": "75c1f8f57ccae3219bd7ca787c2eb4f7f5d6a7b1", "filename": "tests/mir-opt/reference_prop.read_through_raw.ReferencePropagation.diff", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.read_through_raw.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.read_through_raw.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.read_through_raw.ReferencePropagation.diff?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -9,15 +9,14 @@\n       let mut _5: *mut usize;              // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n   \n       bb0: {\n-          _2 = &mut (*_1);                 // scope 0 at $DIR/reference_prop.rs:+10:13: +10:25\n+-         _2 = &mut (*_1);                 // scope 0 at $DIR/reference_prop.rs:+10:13: +10:25\n -         _3 = &mut (*_2);                 // scope 0 at $DIR/reference_prop.rs:+11:13: +11:26\n -         _4 = &raw mut (*_2);             // scope 0 at $DIR/reference_prop.rs:+12:13: +12:30\n -         _5 = &raw mut (*_3);             // scope 0 at $DIR/reference_prop.rs:+13:13: +13:30\n -         _0 = (*_4);                      // scope 0 at $DIR/reference_prop.rs:+15:13: +15:22\n -         _0 = (*_5);                      // scope 0 at $DIR/reference_prop.rs:+16:13: +16:22\n-+         _3 = &mut (*_1);                 // scope 0 at $DIR/reference_prop.rs:+11:13: +11:26\n-+         _0 = (*_2);                      // scope 0 at $DIR/reference_prop.rs:+15:13: +15:22\n-+         _0 = (*_3);                      // scope 0 at $DIR/reference_prop.rs:+16:13: +16:22\n++         _0 = (*_1);                      // scope 0 at $DIR/reference_prop.rs:+15:13: +15:22\n++         _0 = (*_1);                      // scope 0 at $DIR/reference_prop.rs:+16:13: +16:22\n           return;                          // scope 0 at $DIR/reference_prop.rs:+17:13: +17:21\n       }\n   }"}, {"sha": "93f8d1df8e85ad1ccd1eb63e1910c20ce52cfd78", "filename": "tests/mir-opt/reference_prop.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -433,6 +433,29 @@ fn maybe_dead(m: bool) {\n     )\n }\n \n+fn mut_raw_then_mut_shr() -> (i32, i32) {\n+    let mut x = 2;\n+    let xref = &mut x;\n+    let xraw = &mut *xref as *mut _;\n+    let xshr = &*xref;\n+    // Verify that we completely replace with `x` in both cases.\n+    let a = *xshr;\n+    unsafe { *xraw = 4; }\n+    (a, x)\n+}\n+\n+fn unique_with_copies() {\n+    let y = {\n+        let mut a = 0;\n+        let x = &raw mut a;\n+        // `*y` is not replacable below, so we must not replace `*x`.\n+        unsafe { opaque(*x) };\n+        x\n+    };\n+    // But rewriting as `*x` is ok.\n+    unsafe { opaque(*y) };\n+}\n+\n fn main() {\n     let mut x = 5_usize;\n     let mut y = 7_usize;\n@@ -444,6 +467,8 @@ fn main() {\n     multiple_storage();\n     dominate_storage();\n     maybe_dead(true);\n+    mut_raw_then_mut_shr();\n+    unique_with_copies();\n }\n \n // EMIT_MIR reference_prop.reference_propagation.ReferencePropagation.diff\n@@ -454,3 +479,5 @@ fn main() {\n // EMIT_MIR reference_prop.multiple_storage.ReferencePropagation.diff\n // EMIT_MIR reference_prop.dominate_storage.ReferencePropagation.diff\n // EMIT_MIR reference_prop.maybe_dead.ReferencePropagation.diff\n+// EMIT_MIR reference_prop.mut_raw_then_mut_shr.ReferencePropagation.diff\n+// EMIT_MIR reference_prop.unique_with_copies.ReferencePropagation.diff"}, {"sha": "2cda2409e8093a87c2799d1918c4183476eadeb1", "filename": "tests/mir-opt/reference_prop.unique_with_copies.ReferencePropagation.diff", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.unique_with_copies.ReferencePropagation.diff", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fmir-opt%2Freference_prop.unique_with_copies.ReferencePropagation.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Freference_prop.unique_with_copies.ReferencePropagation.diff?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,66 @@\n+- // MIR for `unique_with_copies` before ReferencePropagation\n++ // MIR for `unique_with_copies` after ReferencePropagation\n+  \n+  fn unique_with_copies() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/reference_prop.rs:+0:25: +0:25\n+      let _1: *mut i32;                    // in scope 0 at $DIR/reference_prop.rs:+1:9: +1:10\n+      let mut _2: i32;                     // in scope 0 at $DIR/reference_prop.rs:+2:13: +2:18\n+      let _4: ();                          // in scope 0 at $DIR/reference_prop.rs:+5:18: +5:28\n+      let mut _5: i32;                     // in scope 0 at $DIR/reference_prop.rs:+5:25: +5:27\n+      let _6: ();                          // in scope 0 at $DIR/reference_prop.rs:+9:14: +9:24\n+      let mut _7: i32;                     // in scope 0 at $DIR/reference_prop.rs:+9:21: +9:23\n+      scope 1 {\n+          debug y => _1;                   // in scope 1 at $DIR/reference_prop.rs:+1:9: +1:10\n+          scope 5 {\n+          }\n+      }\n+      scope 2 {\n+          debug a => _2;                   // in scope 2 at $DIR/reference_prop.rs:+2:13: +2:18\n+          let _3: *mut i32;                // in scope 2 at $DIR/reference_prop.rs:+3:13: +3:14\n+          scope 3 {\n+              debug x => _3;               // in scope 3 at $DIR/reference_prop.rs:+3:13: +3:14\n+              scope 4 {\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/reference_prop.rs:+1:9: +1:10\n+          StorageLive(_2);                 // scope 0 at $DIR/reference_prop.rs:+2:13: +2:18\n+          _2 = const 0_i32;                // scope 0 at $DIR/reference_prop.rs:+2:21: +2:22\n+-         StorageLive(_3);                 // scope 2 at $DIR/reference_prop.rs:+3:13: +3:14\n+          _3 = &raw mut _2;                // scope 2 at $DIR/reference_prop.rs:+3:17: +3:27\n+          StorageLive(_4);                 // scope 3 at $DIR/reference_prop.rs:+5:9: +5:30\n+          StorageLive(_5);                 // scope 4 at $DIR/reference_prop.rs:+5:25: +5:27\n+          _5 = (*_3);                      // scope 4 at $DIR/reference_prop.rs:+5:25: +5:27\n+          _4 = opaque::<i32>(move _5) -> bb1; // scope 4 at $DIR/reference_prop.rs:+5:18: +5:28\n+                                           // mir::Constant\n+                                           // + span: $DIR/reference_prop.rs:452:18: 452:24\n+                                           // + literal: Const { ty: fn(i32) {opaque::<i32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_5);                 // scope 4 at $DIR/reference_prop.rs:+5:27: +5:28\n+          StorageDead(_4);                 // scope 3 at $DIR/reference_prop.rs:+5:30: +5:31\n+          _1 = _3;                         // scope 3 at $DIR/reference_prop.rs:+6:9: +6:10\n+-         StorageDead(_3);                 // scope 2 at $DIR/reference_prop.rs:+7:5: +7:6\n+          StorageDead(_2);                 // scope 0 at $DIR/reference_prop.rs:+7:5: +7:6\n+          StorageLive(_6);                 // scope 1 at $DIR/reference_prop.rs:+9:5: +9:26\n+          StorageLive(_7);                 // scope 5 at $DIR/reference_prop.rs:+9:21: +9:23\n+-         _7 = (*_1);                      // scope 5 at $DIR/reference_prop.rs:+9:21: +9:23\n++         _7 = (*_3);                      // scope 5 at $DIR/reference_prop.rs:+9:21: +9:23\n+          _6 = opaque::<i32>(move _7) -> bb2; // scope 5 at $DIR/reference_prop.rs:+9:14: +9:24\n+                                           // mir::Constant\n+                                           // + span: $DIR/reference_prop.rs:456:14: 456:20\n+                                           // + literal: Const { ty: fn(i32) {opaque::<i32>}, val: Value(<ZST>) }\n+      }\n+  \n+      bb2: {\n+          StorageDead(_7);                 // scope 5 at $DIR/reference_prop.rs:+9:23: +9:24\n+          StorageDead(_6);                 // scope 1 at $DIR/reference_prop.rs:+9:26: +9:27\n+          _0 = const ();                   // scope 0 at $DIR/reference_prop.rs:+0:25: +10:2\n+          StorageDead(_1);                 // scope 0 at $DIR/reference_prop.rs:+10:1: +10:2\n+          return;                          // scope 0 at $DIR/reference_prop.rs:+10:2: +10:2\n+      }\n+  }\n+  "}, {"sha": "0ae409c4119e84de3adee8cf5af4c76d08a3e325", "filename": "tests/run-make/coverage-reports/Makefile", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2FMakefile?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -138,6 +138,7 @@ endif\n \t\t\t) \\\n \t\t2> \"$(TMPDIR)\"/show_coverage_stderr.$@.txt \\\n \t\t| \"$(PYTHON)\" $(BASEDIR)/normalize_paths.py \\\n+\t\t| \"$(PYTHON)\" $(BASEDIR)/sort_subviews.py \\\n \t\t> \"$(TMPDIR)\"/actual_show_coverage.$@.txt || \\\n \t( status=$$? ; \\\n \t\t>&2 cat \"$(TMPDIR)\"/show_coverage_stderr.$@.txt ; \\\n@@ -158,23 +159,15 @@ ifdef RUSTC_BLESS_TEST\n else\n \t# Compare the show coverage output (`--bless` refreshes `typical` files).\n \t#\n-\t# FIXME(richkadel): None of the Rust test source samples have the\n-\t# `// ignore-llvm-cov-show-diffs` anymore. This directive exists to work around a limitation\n-\t# with `llvm-cov show`. When reporting coverage for multiple instantiations of a generic function,\n-\t# with different type substitutions, `llvm-cov show` prints these in a non-deterministic order,\n-\t# breaking the `diff` comparison.\n+\t# `llvm-cov show` normally prints instantiation groups in an unpredictable\n+\t# order, but we have used `sort_subviews.py` to sort them, so we can still\n+\t# check the output directly with `diff`.\n \t#\n-\t# A partial workaround is implemented below, with `diff --ignore-matching-lines=RE`\n-\t# to ignore each line prefixing each generic instantiation coverage code region.\n-\t#\n-\t# This workaround only works if the coverage counts are identical across all reported\n-\t# instantiations. If there is no way to ensure this, you may need to apply the\n-\t# `// ignore-llvm-cov-show-diffs` directive, and check for differences using the\n-\t# `.json` files to validate that results have not changed. (Until then, the JSON\n-\t# files are redundant, so there is no need to generate `expected_*.json` files or\n-\t# compare actual JSON results.)\n-\n-\t$(DIFF) --ignore-matching-lines='^  \\| .*::<.*>.*:$$' --ignore-matching-lines='^  \\| <.*>::.*:$$' \\\n+\t# Some of the test cases are currently not working (since #110393) and have\n+\t# been marked with `// ignore-llvm-cov-show-diffs` so that they don't fail\n+\t# the build.\n+\n+\t$(DIFF) \\\n \t\texpected_show_coverage.$@.txt \"$(TMPDIR)\"/actual_show_coverage.$@.txt || \\\n \t\t( grep -q '^\\/\\/ ignore-llvm-cov-show-diffs' $(SOURCEDIR)/$@.rs && \\\n \t\t\t>&2 echo 'diff failed, but suppressed with `// ignore-llvm-cov-show-diffs` in $(SOURCEDIR)/$@.rs' \\"}, {"sha": "93c1535b06b50907a9ecb5ee9a8b096baabede87", "filename": "tests/run-make/coverage-reports/expected_show_coverage.async.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.async.txt?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -41,9 +41,9 @@\n    41|      1|                    // executed asynchronously.\n    42|      1|    match x {\n    43|      1|        y if c(x).await == y + 1 => { d().await; }\n-                      ^0       ^0                   ^0 ^0\n+                      ^0        ^0                  ^0  ^0\n    44|      1|        y if f().await == y + 1 => (),\n-                      ^0      ^0                 ^0\n+                      ^0       ^0                ^0\n    45|      1|        _ => (),\n    46|       |    }\n    47|      1|}"}, {"sha": "81468cb35dac37081c5dcff61f5b4787c59e25a1", "filename": "tests/run-make/coverage-reports/expected_show_coverage.sort_groups.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.sort_groups.txt", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.sort_groups.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.sort_groups.txt?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,49 @@\n+    1|       |// compile-flags: --edition=2021\n+    2|       |\n+    3|       |// Demonstrate that `sort_subviews.py` can sort instantiation groups into a\n+    4|       |// predictable order, while preserving their heterogeneous contents.\n+    5|       |\n+    6|      1|fn main() {\n+    7|      1|    let cond = std::env::args().len() > 1;\n+    8|      1|    generic_fn::<()>(cond);\n+    9|      1|    generic_fn::<&'static str>(!cond);\n+   10|      1|    if false {\n+   11|      0|        generic_fn::<char>(cond);\n+   12|      1|    }\n+   13|      1|    generic_fn::<i32>(cond);\n+   14|      1|    other_fn();\n+   15|      1|}\n+   16|       |\n+   17|      3|fn generic_fn<T>(cond: bool) {\n+   18|      3|    if cond {\n+   19|      1|        println!(\"{}\", std::any::type_name::<T>());\n+   20|      2|    }\n+   21|      3|}\n+  ------------------\n+  | Unexecuted instantiation: sort_groups::generic_fn::<char>\n+  ------------------\n+  | sort_groups::generic_fn::<&str>:\n+  |   17|      1|fn generic_fn<T>(cond: bool) {\n+  |   18|      1|    if cond {\n+  |   19|      1|        println!(\"{}\", std::any::type_name::<T>());\n+  |   20|      1|    }\n+  |                   ^0\n+  |   21|      1|}\n+  ------------------\n+  | sort_groups::generic_fn::<()>:\n+  |   17|      1|fn generic_fn<T>(cond: bool) {\n+  |   18|      1|    if cond {\n+  |   19|      0|        println!(\"{}\", std::any::type_name::<T>());\n+  |   20|      1|    }\n+  |   21|      1|}\n+  ------------------\n+  | sort_groups::generic_fn::<i32>:\n+  |   17|      1|fn generic_fn<T>(cond: bool) {\n+  |   18|      1|    if cond {\n+  |   19|      0|        println!(\"{}\", std::any::type_name::<T>());\n+  |   20|      1|    }\n+  |   21|      1|}\n+  ------------------\n+   22|       |\n+   23|      1|fn other_fn() {}\n+"}, {"sha": "412f4a93b9c99c93375015b3072a9b340bd2f603", "filename": "tests/run-make/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -19,29 +19,29 @@\n    18|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    19|      2|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n+  | Unexecuted instantiation: used_crate::used_only_from_bin_crate_generic_function::<_>\n+  ------------------\n+  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n   ------------------\n-  | used_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_bin_crate_generic_function::<&str>:\n   |   17|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   18|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   19|      1|}\n-  ------------------\n-  | Unexecuted instantiation: used_crate::used_only_from_bin_crate_generic_function::<_>\n   ------------------\n    20|       |// Expect for above function: `Unexecuted instantiation` (see below)\n    21|      2|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n    22|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n    23|      2|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}\n@@ -51,12 +51,12 @@\n    26|      2|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n    27|      2|}\n   ------------------\n-  | used_crate::used_from_bin_crate_and_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_crate::used_from_bin_crate_and_lib_crate_generic_function::<&str>:\n   |   25|      1|pub fn used_from_bin_crate_and_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   26|      1|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n   |   27|      1|}\n   ------------------\n-  | used_crate::used_from_bin_crate_and_lib_crate_generic_function::<&str>:\n+  | used_crate::used_from_bin_crate_and_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   25|      1|pub fn used_from_bin_crate_and_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   26|      1|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n   |   27|      1|}"}, {"sha": "66ca9e80a32789c7699d891752abef9efccc2a66", "filename": "tests/run-make/coverage-reports/expected_show_coverage.uses_inline_crate.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2Fexpected_show_coverage.uses_inline_crate.txt?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -42,6 +42,8 @@\n    40|      2|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n    41|      2|}\n   ------------------\n+  | Unexecuted instantiation: used_inline_crate::used_only_from_bin_crate_generic_function::<_>\n+  ------------------\n   | used_inline_crate::used_only_from_bin_crate_generic_function::<&alloc::vec::Vec<i32>>:\n   |   39|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   40|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n@@ -51,8 +53,6 @@\n   |   39|      1|pub fn used_only_from_bin_crate_generic_function<T: Debug>(arg: T) {\n   |   40|      1|    println!(\"used_only_from_bin_crate_generic_function with {:?}\", arg);\n   |   41|      1|}\n-  ------------------\n-  | Unexecuted instantiation: used_inline_crate::used_only_from_bin_crate_generic_function::<_>\n   ------------------\n    42|       |// Expect for above function: `Unexecuted instantiation` (see notes in `used_crate.rs`)\n    43|       |\n@@ -77,15 +77,15 @@\n    51|      3|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n    52|      3|}\n   ------------------\n-  | used_inline_crate::used_from_bin_crate_and_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n-  |   50|      1|pub fn used_from_bin_crate_and_lib_crate_generic_function<T: Debug>(arg: T) {\n-  |   51|      1|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n-  |   52|      1|}\n-  ------------------\n   | used_inline_crate::used_from_bin_crate_and_lib_crate_generic_function::<&str>:\n   |   50|      2|pub fn used_from_bin_crate_and_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   51|      2|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n   |   52|      2|}\n+  ------------------\n+  | used_inline_crate::used_from_bin_crate_and_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  |   50|      1|pub fn used_from_bin_crate_and_lib_crate_generic_function<T: Debug>(arg: T) {\n+  |   51|      1|    println!(\"used_from_bin_crate_and_lib_crate_generic_function with {:?}\", arg);\n+  |   52|      1|}\n   ------------------\n    53|       |\n    54|       |#[inline(always)]"}, {"sha": "10cfc51d44771534abfb3871fe5ac696cf32ab15", "filename": "tests/run-make/coverage-reports/sort_subviews.py", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fsort_subviews.py", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage-reports%2Fsort_subviews.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage-reports%2Fsort_subviews.py?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,50 @@\n+#!/usr/bin/env python3\n+\n+# `llvm-cov show` prints grouped subviews (e.g. for generic functions) in an\n+# unstable order, which is inconvenient when checking output snapshots with\n+# `diff`. To work around that, this script detects consecutive subviews in its\n+# piped input, and sorts them while preserving their contents.\n+\n+from __future__ import print_function\n+\n+import sys\n+\n+\n+def main():\n+    subviews = []\n+\n+    def flush_subviews():\n+        if not subviews:\n+            return\n+\n+        # The last \"subview\" should be just a boundary line on its own, so\n+        # temporarily remove it before sorting the accumulated subviews.\n+        terminator = subviews.pop()\n+        subviews.sort()\n+        subviews.append(terminator)\n+\n+        for view in subviews:\n+            for line in view:\n+                print(line, end=\"\")\n+\n+        subviews.clear()\n+\n+    for line in sys.stdin:\n+        if line.startswith(\"  ------------------\"):\n+            # This is a subview boundary line, so start a new subview.\n+            subviews.append([line])\n+        elif line.startswith(\"  |\"):\n+            # Add this line to the current subview.\n+            subviews[-1].append(line)\n+        else:\n+            # This line is not part of a subview, so sort and print any\n+            # accumulated subviews, and then print the line as-is.\n+            flush_subviews()\n+            print(line, end=\"\")\n+\n+    flush_subviews()\n+    assert not subviews\n+\n+\n+if __name__ == \"__main__\":\n+    main()"}, {"sha": "f89f9f3ec61fad45fae9718f88159d4950894fa5", "filename": "tests/run-make/coverage/sort_groups.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage%2Fsort_groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fcoverage%2Fsort_groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fcoverage%2Fsort_groups.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,23 @@\n+// compile-flags: --edition=2021\n+\n+// Demonstrate that `sort_subviews.py` can sort instantiation groups into a\n+// predictable order, while preserving their heterogeneous contents.\n+\n+fn main() {\n+    let cond = std::env::args().len() > 1;\n+    generic_fn::<()>(cond);\n+    generic_fn::<&'static str>(!cond);\n+    if false {\n+        generic_fn::<char>(cond);\n+    }\n+    generic_fn::<i32>(cond);\n+    other_fn();\n+}\n+\n+fn generic_fn<T>(cond: bool) {\n+    if cond {\n+        println!(\"{}\", std::any::type_name::<T>());\n+    }\n+}\n+\n+fn other_fn() {}"}, {"sha": "a1e86a7ce4b652ea5f3794e6fa84cd02776076e2", "filename": "tests/run-make/staticlib-dylib-linkage/Makefile", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fstaticlib-dylib-linkage%2FMakefile?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,21 @@\n+include ../tools.mk\n+\n+# ignore-cross-compile\n+# ignore-msvc FIXME(bjorn3) can't figure out how to link with the MSVC toolchain\n+# ignore-wasm wasm doesn't support dynamic libraries\n+\n+all:\n+\t$(RUSTC) -C prefer-dynamic bar.rs\n+\t$(RUSTC) foo.rs --crate-type staticlib --print native-static-libs \\\n+\t\t-Z staticlib-allow-rdylib-deps 2>&1 | grep 'note: native-static-libs: ' \\\n+\t\t| sed 's/note: native-static-libs: \\(.*\\)/\\1/' > $(TMPDIR)/libs.txt\n+\tcat $(TMPDIR)/libs.txt\n+\n+ifdef IS_MSVC\n+\t$(CC) $(CFLAGS) /c foo.c /Fo:$(TMPDIR)/foo.o\n+\t$(RUSTC_LINKER) $(TMPDIR)/foo.o $(TMPDIR)/foo.lib $$(cat $(TMPDIR)/libs.txt) $(call OUT_EXE,foo)\n+else\n+\t$(CC) $(CFLAGS) foo.c -L $(TMPDIR) -lfoo $$(cat $(TMPDIR)/libs.txt) -o $(call RUN_BINFILE,foo)\n+endif\n+\n+\t$(call RUN,foo)"}, {"sha": "b3a7539abaeffe6d4ac414f79e0448a582298b6d", "filename": "tests/run-make/staticlib-dylib-linkage/bar.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Fbar.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,5 @@\n+#![crate_type = \"dylib\"]\n+\n+pub fn bar() {\n+    println!(\"hello!\");\n+}"}, {"sha": "154f9682ef8f1dd678cdb5a3605a11cee1cb92bf", "filename": "tests/run-make/staticlib-dylib-linkage/foo.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Ffoo.c", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Ffoo.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Ffoo.c?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,10 @@\n+#include <assert.h>\n+\n+extern void foo();\n+extern unsigned bar(unsigned a, unsigned b);\n+\n+int main() {\n+  foo();\n+  assert(bar(1, 2) == 3);\n+  return 0;\n+}"}, {"sha": "af439391c757e8f6ef1ea172cd7920f184a5b8d0", "filename": "tests/run-make/staticlib-dylib-linkage/foo.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-make%2Fstaticlib-dylib-linkage%2Ffoo.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,13 @@\n+#![crate_type = \"staticlib\"]\n+\n+extern crate bar;\n+\n+#[no_mangle]\n+pub extern \"C\" fn foo() {\n+    bar::bar();\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn bar(a: u32, b: u32) -> u32 {\n+    a + b\n+}"}, {"sha": "f25c88690e55146242eb622801bf74a917f30f37", "filename": "tests/rustdoc-gui/check-stab-in-docblock.goml", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fcheck-stab-in-docblock.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fcheck-stab-in-docblock.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fcheck-stab-in-docblock.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -7,20 +7,26 @@ set-window-size: (786, 600)\n // Confirms that there 3 paragraphs.\n assert-count: (\".top-doc .docblock p\", 3)\n // Checking that there is no scrollable content.\n-store-property: (clientHeight, \".top-doc .docblock p:nth-of-type(1)\", \"clientHeight\")\n-store-property: (clientWidth, \".top-doc .docblock p:nth-of-type(1)\", \"clientWidth\")\n+store-property: (\".top-doc .docblock p:nth-of-type(1)\", {\n+    \"clientHeight\": clientHeight,\n+    \"clientWidth\": clientWidth,\n+})\n assert-property: (\n     \".top-doc .docblock p:nth-of-type(1)\",\n     {\"scrollHeight\": |clientHeight|, \"scrollWidth\": |clientWidth|},\n )\n-store-property: (clientHeight, \".top-doc .docblock p:nth-of-type(2)\", \"clientHeight\")\n-store-property: (clientWidth, \".top-doc .docblock p:nth-of-type(2)\", \"clientWidth\")\n+store-property: (\".top-doc .docblock p:nth-of-type(2)\", {\n+    \"clientHeight\": clientHeight,\n+    \"clientWidth\": clientWidth,\n+})\n assert-property: (\n     \".top-doc .docblock p:nth-of-type(2)\",\n     {\"scrollHeight\": |clientHeight|, \"scrollWidth\": |clientWidth|},\n )\n-store-property: (clientHeight, \".top-doc .docblock p:nth-of-type(3)\", \"clientHeight\")\n-store-property: (clientWidth, \".top-doc .docblock p:nth-of-type(3)\", \"clientWidth\")\n+store-property: (\".top-doc .docblock p:nth-of-type(3)\", {\n+    \"clientHeight\": clientHeight,\n+    \"clientWidth\": clientWidth,\n+})\n assert-property: (\n     \".top-doc .docblock p:nth-of-type(3)\",\n     {\"scrollHeight\": |clientHeight|, \"scrollWidth\": |clientWidth|},"}, {"sha": "a4b0558765abe00139630aa30896cd2a51bedc9d", "filename": "tests/rustdoc-gui/codeblock-sub.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fcodeblock-sub.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fcodeblock-sub.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fcodeblock-sub.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,5 +1,5 @@\n // Test that code blocks nested within <sub> do not have a line height of 0.\n go-to: \"file://\" + |DOC_PATH| + \"/test_docs/codeblock_sub/index.html\"\n \n-store-property: (codeblock_sub_1, \"#codeblock-sub-1\", \"offsetHeight\")\n+store-property: (\"#codeblock-sub-1\", {\"offsetHeight\": codeblock_sub_1})\n assert-property-false: (\"#codeblock-sub-3\", { \"offsetHeight\": |codeblock_sub_1| })"}, {"sha": "8e6d2ba824f732ec6b394c319dad1b7e88c6caf6", "filename": "tests/rustdoc-gui/docblock-details.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fdocblock-details.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fdocblock-details.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fdocblock-details.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -9,7 +9,7 @@ reload:\n assert-text: (\".top-doc .docblock > h3\", \"Hello\")\n assert-css: (\n     \".top-doc .docblock > h3\",\n-    {\"border-bottom\": \"1px solid rgb(210, 210, 210)\"},\n+    {\"border-bottom\": \"1px solid #d2d2d2\"},\n )\n // We now check that the `<summary>` doesn't have a bottom border and has the correct display.\n assert-css: ("}, {"sha": "030ff8f8a3e7086c3af542c3bd5ec835033ad570", "filename": "tests/rustdoc-gui/item-info.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fitem-info.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fitem-info.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fitem-info.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -4,8 +4,8 @@ go-to: \"file://\" + |DOC_PATH| + \"/lib2/struct.Foo.html\"\n // We set a fixed size so there is no chance of \"random\" resize.\n set-window-size: (1100, 800)\n // We check that \".item-info\" is bigger than its content.\n-assert-css: (\".item-info\", {\"width\": \"840px\"})\n-assert-css: (\".item-info .stab\", {\"width\": \"289px\"})\n+assert-size: (\".item-info\", {\"width\": 840})\n+assert-size: (\".item-info .stab\", {\"width\": 289})\n assert-position: (\".item-info .stab\", {\"x\": 245})\n \n // Now we ensure that they're not rendered on the same line."}, {"sha": "ecb57c274a5d3e09a40ddc2466b84053785a284e", "filename": "tests/rustdoc-gui/notable-trait.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fnotable-trait.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fnotable-trait.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fnotable-trait.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -225,12 +225,12 @@ assert: \"#method\\.create_an_iterator_from_read .tooltip:focus\"\n \n // Now we check that the focus isn't given back to the wrong item when opening\n // another popover.\n-store-window-property: (scroll, \"scrollY\")\n+store-window-property: {\"scrollY\": scroll}\n click: \"#method\\.create_an_iterator_from_read .fn\"\n // We ensure that the scroll position changed.\n assert-window-property-false: {\"scrollY\": |scroll|}\n // Store the new position.\n-store-window-property: (scroll, \"scrollY\")\n+store-window-property: {\"scrollY\": scroll}\n click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\"\n wait-for: \"//*[@class='tooltip popover']\"\n click: \"#settings-menu a\"\n@@ -239,12 +239,12 @@ click: \".search-input\"\n assert-window-property-false: {\"scrollY\": |scroll|}\n \n // Same but with Escape handling.\n-store-window-property: (scroll, \"scrollY\")\n+store-window-property: {\"scrollY\": scroll}\n click: \"#method\\.create_an_iterator_from_read .fn\"\n // We ensure that the scroll position changed.\n assert-window-property-false: {\"scrollY\": |scroll|}\n // Store the new position.\n-store-window-property: (scroll, \"scrollY\")\n+store-window-property: {\"scrollY\": scroll}\n click: \"//*[@id='method.create_an_iterator_from_read']//*[@class='tooltip']\"\n wait-for: \"//*[@class='tooltip popover']\"\n click: \"#settings-menu a\""}, {"sha": "af4293dfc0057c3f384ed59d5fd28580f1cf749e", "filename": "tests/rustdoc-gui/scrape-examples-button-focus.goml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fscrape-examples-button-focus.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fscrape-examples-button-focus.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -3,7 +3,7 @@\n go-to: \"file://\" + |DOC_PATH| + \"/scrape_examples/fn.test.html\"\n \n // The next/prev buttons vertically scroll the code viewport between examples\n-store-property: (initialScrollTop, \".scraped-example-list > .scraped-example pre\", \"scrollTop\")\n+store-property: (\".scraped-example-list > .scraped-example pre\", {\"scrollTop\": initialScrollTop})\n focus: \".scraped-example-list > .scraped-example .next\"\n press-key: \"Enter\"\n assert-property-false: (\".scraped-example-list > .scraped-example pre\", {\n@@ -16,7 +16,7 @@ assert-property: (\".scraped-example-list > .scraped-example pre\", {\n }, NEAR)\n \n // The expand button increases the scrollHeight of the minimized code viewport\n-store-property: (smallOffsetHeight, \".scraped-example-list > .scraped-example pre\", \"offsetHeight\")\n+store-property: (\".scraped-example-list > .scraped-example pre\", {\"offsetHeight\": smallOffsetHeight})\n assert-property-false: (\".scraped-example-list > .scraped-example pre\", {\n     \"scrollHeight\": |smallOffsetHeight|\n }, NEAR)\n@@ -25,7 +25,7 @@ press-key: \"Enter\"\n assert-property-false: (\".scraped-example-list > .scraped-example pre\", {\n     \"offsetHeight\": |smallOffsetHeight|\n }, NEAR)\n-store-property: (fullOffsetHeight, \".scraped-example-list > .scraped-example pre\", \"offsetHeight\")\n+store-property: (\".scraped-example-list > .scraped-example pre\", {\"offsetHeight\": fullOffsetHeight})\n assert-property: (\".scraped-example-list > .scraped-example pre\", {\n     \"scrollHeight\": |fullOffsetHeight|\n }, NEAR)"}, {"sha": "4fc1c1ac065f407e27670684bc02264f4dfeb0d1", "filename": "tests/rustdoc-gui/scrape-examples-layout.goml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fscrape-examples-layout.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fscrape-examples-layout.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fscrape-examples-layout.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -9,9 +9,8 @@ assert-property-false: (\n \n // Check that examples with very long lines have the same width as ones that don't.\n store-property: (\n-    clientWidth,\n     \".more-scraped-examples .scraped-example:nth-child(2) .code-wrapper .src-line-numbers\",\n-    \"clientWidth\"\n+    {\"clientWidth\": clientWidth},\n )\n \n assert-property: (\n@@ -40,8 +39,8 @@ assert-property: (\n store-value: (offset_y, 4)\n \n // First with desktop\n-assert-position: (\".scraped-example .code-wrapper\", {\"y\": 253})\n-assert-position: (\".scraped-example .code-wrapper .prev\", {\"y\": 253 + |offset_y|})\n+assert-position: (\".scraped-example .code-wrapper\", {\"y\": 226})\n+assert-position: (\".scraped-example .code-wrapper .prev\", {\"y\": 226 + |offset_y|})\n \n // Then with mobile\n set-window-size: (600, 600)"}, {"sha": "ee5598e4b21d0e80492fe8ba500f78b5e93b4573", "filename": "tests/rustdoc-gui/search-result-display.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsearch-result-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsearch-result-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsearch-result-display.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -32,8 +32,8 @@ set-text: (\n )\n \n // Then we compare again to confirm the height didn't change.\n-assert-css: (\"#crate-search\", {\"width\": \"527px\"})\n-assert-css: (\".search-results-title\", {\"height\": \"50px\", \"width\": \"640px\"})\n+assert-size: (\"#crate-search\", {\"width\": 527})\n+assert-size: (\".search-results-title\", {\"height\": 50, \"width\": 640})\n // And we check that the `<select>` isn't bigger than its container (\".search-results-title\").\n assert-css: (\"#search\", {\"width\": \"640px\"})\n "}, {"sha": "bf1fe7be9103664c9bc2a9de9ec9ce18afc660e3", "filename": "tests/rustdoc-gui/settings.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsettings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsettings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsettings.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -10,7 +10,7 @@ wait-for: \"#settings\"\n assert-css: (\"#settings\", {\"display\": \"block\"})\n \n // Store the line margin to compare with the settings.html later.\n-store-css: (setting_line_margin, \".setting-line\", \"margin\")\n+store-css: (\".setting-line\", {\"margin\": setting_line_margin})\n \n // Let's close it by clicking on the same button.\n click: \"#settings-menu\""}, {"sha": "0c680bcc9fba903a073db5cbebd4efa00408447f", "filename": "tests/rustdoc-gui/sidebar-source-code-display.goml", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsidebar-source-code-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsidebar-source-code-display.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -121,28 +121,28 @@ define-function: (\n \n call-function: (\"check-colors\", {\n     \"theme\": \"light\",\n-    \"color\": \"rgb(0, 0, 0)\",\n-    \"color_hover\": \"rgb(0, 0, 0)\",\n-    \"background\": \"rgb(255, 255, 255)\",\n-    \"background_hover\": \"rgb(224, 224, 224)\",\n+    \"color\": \"black\",\n+    \"color_hover\": \"#000\",\n+    \"background\": \"#fff\",\n+    \"background_hover\": \"#e0e0e0\",\n     \"background_toggle\": \"rgba(0, 0, 0, 0)\",\n-    \"background_toggle_hover\": \"rgb(224, 224, 224)\",\n+    \"background_toggle_hover\": \"#e0e0e0\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"dark\",\n-    \"color\": \"rgb(221, 221, 221)\",\n-    \"color_hover\": \"rgb(221, 221, 221)\",\n-    \"background\": \"rgb(51, 51, 51)\",\n-    \"background_hover\": \"rgb(68, 68, 68)\",\n+    \"color\": \"#ddd\",\n+    \"color_hover\": \"#ddd\",\n+    \"background\": \"#333\",\n+    \"background_hover\": \"#444\",\n     \"background_toggle\": \"rgba(0, 0, 0, 0)\",\n-    \"background_toggle_hover\": \"rgb(103, 103, 103)\",\n+    \"background_toggle_hover\": \"#676767\",\n })\n call-function: (\"check-colors\", {\n     \"theme\": \"ayu\",\n-    \"color\": \"rgb(197, 197, 197)\",\n-    \"color_hover\": \"rgb(255, 180, 76)\",\n+    \"color\": \"#c5c5c5\",\n+    \"color_hover\": \"#ffb44c\",\n     \"background\": \"rgb(20, 25, 31)\",\n-    \"background_hover\": \"rgb(20, 25, 31)\",\n+    \"background_hover\": \"#14191f\",\n     \"background_toggle\": \"rgba(0, 0, 0, 0)\",\n     \"background_toggle_hover\": \"rgba(70, 70, 70, 0.33)\",\n })"}, {"sha": "574cc629a04303c4816882a0aca2900e6bbb0166", "filename": "tests/rustdoc-gui/sidebar.goml", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsidebar.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsidebar.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsidebar.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -152,14 +152,16 @@ assert-property: (\".sidebar\", {\"clientWidth\": \"200\"})\n \n // Checks that all.html and index.html have their sidebar link in the same place.\n go-to: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n-store-property: (index_sidebar_width, \".sidebar .location a\", \"clientWidth\")\n-store-property: (index_sidebar_height, \".sidebar .location a\", \"clientHeight\")\n-store-property: (index_sidebar_x, \".sidebar .location a\", \"offsetTop\")\n-store-property: (index_sidebar_y, \".sidebar .location a\", \"offsetLeft\")\n+store-property: (\".sidebar .location a\", {\n+    \"clientWidth\": index_sidebar_width,\n+    \"clientHeight\": index_sidebar_height,\n+    \"offsetTop\": index_sidebar_y,\n+    \"offsetLeft\": index_sidebar_x,\n+})\n go-to: \"file://\" + |DOC_PATH| + \"/test_docs/all.html\"\n assert-property: (\".sidebar .location a\", {\n     \"clientWidth\": |index_sidebar_width|,\n     \"clientHeight\": |index_sidebar_height|,\n-    \"offsetTop\": |index_sidebar_x|,\n-    \"offsetLeft\": |index_sidebar_y|,\n+    \"offsetTop\": |index_sidebar_y|,\n+    \"offsetLeft\": |index_sidebar_x|,\n })"}, {"sha": "5c795928bdc9a4aa6d9b1caa253474113325ca53", "filename": "tests/rustdoc-gui/source-code-page.goml", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsource-code-page.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsource-code-page.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsource-code-page.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -117,9 +117,8 @@ assert-property: (\"#source-sidebar details:first-of-type\", {\"open\": \"true\"})\n \n // Check the sidebar directory entries have a marker and spacing (desktop).\n store-property: (\n-    link_height,\n     \"#source-sidebar > details:first-of-type.dir-entry[open] > .files > a\",\n-    \"offsetHeight\"\n+    {\"offsetHeight\": link_height},\n )\n define-function: (\n     \"check-sidebar-dir-entry\",\n@@ -147,16 +146,10 @@ define-function: (\n         )\n     }\n )\n-store-property: (\n-    source_sidebar_title_height,\n-    \"#source-sidebar > .title\",\n-    \"offsetHeight\"\n-)\n-store-property: (\n-    source_sidebar_title_y,\n-    \"#source-sidebar > .title\",\n-    \"offsetTop\"\n-)\n+store-property: (\"#source-sidebar > .title\", {\n+    \"offsetHeight\": source_sidebar_title_height,\n+    \"offsetTop\": source_sidebar_title_y,\n+})\n call-function: (\"check-sidebar-dir-entry\", {\n     \"x\": 0,\n     // border + margin = 6\n@@ -182,16 +175,10 @@ assert-property: (\"#main-content\", {\"offsetTop\": 76})\n // 21 = 76 - 34 - 21\n \n // Check the sidebar directory entries have a marker and spacing (tablet).\n-store-property: (\n-    source_sidebar_title_height,\n-    \"#source-sidebar > .title\",\n-    \"offsetHeight\"\n-)\n-store-property: (\n-    source_sidebar_title_y,\n-    \"#source-sidebar > .title\",\n-    \"offsetTop\"\n-)\n+store-property: (\"#source-sidebar > .title\", {\n+    \"offsetHeight\": source_sidebar_title_height,\n+    \"offsetTop\": source_sidebar_title_y,\n+})\n call-function: (\"check-sidebar-dir-entry\", {\n     \"x\": 0,\n     \"y\": |source_sidebar_title_y| + |source_sidebar_title_height| + 6,\n@@ -202,22 +189,16 @@ set-window-size: (450, 700)\n assert-css: (\"nav.sub\", {\"flex-direction\": \"column\"})\n \n // Check the sidebar directory entries have a marker and spacing (phone).\n-store-property: (\n-    source_sidebar_title_height,\n-    \"#source-sidebar > .title\",\n-    \"offsetHeight\"\n-)\n-store-property: (\n-    source_sidebar_title_y,\n-    \"#source-sidebar > .title\",\n-    \"offsetTop\"\n-)\n+store-property: (\"#source-sidebar > .title\", {\n+    \"offsetHeight\": source_sidebar_title_height,\n+    \"offsetTop\": source_sidebar_title_y,\n+})\n call-function: (\"check-sidebar-dir-entry\", {\n     \"x\": 0,\n     \"y\": |source_sidebar_title_y| + |source_sidebar_title_height| + 6,\n })\n \n // Now we check that the logo has a bottom margin so it's not stuck to the search input.\n assert-css: (\".sub-logo-container > img\", {\"margin-bottom\": \"8px\"})\n-store-property: (logo_height, \".sub-logo-container\", \"clientHeight\")\n+store-property: (\".sub-logo-container\", {\"clientHeight\": logo_height})\n assert-position: (\".search-form\", {\"y\": |logo_height| + 8})"}, {"sha": "ff30bcdf2a22305b747ba2f32ef64a09576ab13e", "filename": "tests/rustdoc-gui/src-font-size.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsrc-font-size.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fsrc-font-size.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsrc-font-size.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -11,6 +11,6 @@ assert-css: (\".impl-items .srclink\", {\"font-size\": \"16px\", \"font-weight\": 400},\n assert-css: (\".impl-items .code-header\", {\"font-size\": \"16px\", \"font-weight\": 600}, ALL)\n \n // Check that we can click on source link\n-store-document-property: (url, \"URL\")\n+store-document-property: {\"URL\": url}\n click: \".impl-items .srclink\"\n assert-document-property-false: {\"URL\": |url|}"}, {"sha": "3c87a4cd65427b11d6ae83cb8f4520379baaa687", "filename": "tests/rustdoc-gui/struct-fields.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fstruct-fields.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Fstruct-fields.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fstruct-fields.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,5 +1,5 @@\n // This test ensures that each field is on its own line (In other words, they have display: block).\n go-to: \"file://\" + |DOC_PATH| + \"/test_docs/struct.StructWithPublicUndocumentedFields.html\"\n \n-store-property: (first_top, \"//*[@id='structfield.first']\", \"offsetTop\")\n+store-property: (\"//*[@id='structfield.first']\", {\"offsetTop\": first_top})\n assert-property-false: (\"//*[@id='structfield.second']\", { \"offsetTop\": |first_top| })"}, {"sha": "f212781e9b340badd20fa6896b6b03c36a4defa0", "filename": "tests/rustdoc-gui/type-declation-overflow.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Ftype-declation-overflow.goml", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-gui%2Ftype-declation-overflow.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftype-declation-overflow.goml?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -39,7 +39,7 @@ assert-property: (\"pre.item-decl\", {\"scrollWidth\": \"950\"})\n set-window-size: (600, 600)\n go-to: \"file://\" + |DOC_PATH| + \"/lib2/too_long/struct.SuperIncrediblyLongLongLongLongLongLongLongGigaGigaGigaMegaLongLongLongStructName.html\"\n // It shouldn't have an overflow in the topbar either.\n-store-property: (scrollWidth, \".mobile-topbar h2\", \"scrollWidth\")\n+store-property: (\".mobile-topbar h2\", {\"scrollWidth\": scrollWidth})\n assert-property: (\".mobile-topbar h2\", {\"clientWidth\": |scrollWidth|})\n assert-css: (\".mobile-topbar h2\", {\"overflow-x\": \"hidden\"})\n "}, {"sha": "8ede91cf8f4f4493caa8c0d386f7b53093878eaa", "filename": "tests/rustdoc-ui/ice-bug-report-url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-ui%2Fice-bug-report-url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-ui%2Fice-bug-report-url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fice-bug-report-url.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -6,8 +6,8 @@\n // normalize-stderr-test \"note: compiler flags.*\\n\\n\" -> \"\"\n // normalize-stderr-test \"note: rustc.*running on.*\" -> \"note: rustc {version} running on {platform}\"\n // normalize-stderr-test \"thread.*panicked at .*, compiler.*\" -> \"thread panicked at 'aborting due to `-Z treat-err-as-bug`'\"\n-// normalize-stderr-test \"\\s*\\d{1,}: .*\\n\" -> \"\"\n-// normalize-stderr-test \"\\s at .*\\n\" -> \"\"\n+// normalize-stderr-test \" +\\d{1,}: .*\\n\" -> \"\"\n+// normalize-stderr-test \" + at .*\\n\" -> \"\"\n // normalize-stderr-test \".*note: Some details are omitted.*\\n\" -> \"\"\n \n fn wrong()"}, {"sha": "98c08b9a8944b7962c0c9669abf8aa9c2acb8a2a", "filename": "tests/rustdoc-ui/ice-bug-report-url.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-ui%2Fice-bug-report-url.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc-ui%2Fice-bug-report-url.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fice-bug-report-url.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -6,6 +6,7 @@ LL | fn wrong()\n \n thread panicked at 'aborting due to `-Z treat-err-as-bug`'\n stack backtrace:\n+\n error: the compiler unexpectedly panicked. this is a bug.\n \n note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-rustdoc&template=ice.md"}, {"sha": "82dfffe5f1c223320d656de9bbfc9e2a8b899db1", "filename": "tests/rustdoc/impl-alias-substituted.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc%2Fimpl-alias-substituted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc%2Fimpl-alias-substituted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fimpl-alias-substituted.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,9 @@\n+pub struct Matrix<T, const N: usize, const M: usize>([[T; N]; M]);\n+\n+pub type Vector<T, const N: usize> = Matrix<T, N, 1>;\n+\n+// @has \"impl_alias_substituted/struct.Matrix.html\" '//*[@class=\"impl\"]//h3[@class=\"code-header\"]' \\\n+//  \"impl<T: Copy> Matrix<T, 3, 1>\"\n+impl<T: Copy> Vector<T, 3> {\n+    pub fn test() {}\n+}"}, {"sha": "8e1029a1ca3df9fc54c1f67539dd5a5475ddc193", "filename": "tests/rustdoc/issue-111064-reexport-trait-from-hidden-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden-2.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,31 @@\n+#![feature(no_core)]\n+#![no_core]\n+#![crate_name = \"foo\"]\n+\n+// @!has 'foo/hidden/index.html'\n+// FIXME: add missing `@` for the two next tests once issue is fixed!\n+// To be done in <https://github.com/rust-lang/rust/issues/111249>.\n+// !has 'foo/hidden/inner/index.html'\n+// !has 'foo/hidden/inner/trait.Foo.html'\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub mod inner {\n+        pub trait Foo {\n+            /// Hello, world!\n+            fn test();\n+        }\n+    }\n+}\n+\n+// @has 'foo/visible/index.html'\n+// @has 'foo/visible/trait.Foo.html'\n+#[doc(inline)]\n+pub use hidden::inner as visible;\n+\n+// @has 'foo/struct.Bar.html'\n+// @count - '//*[@id=\"impl-Foo-for-Bar\"]' 1\n+pub struct Bar;\n+\n+impl visible::Foo for Bar {\n+    fn test() {}\n+}"}, {"sha": "a9ce4a34507e6e73d82c96f201bfaa325c164c18", "filename": "tests/rustdoc/issue-111064-reexport-trait-from-hidden.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-111064-reexport-trait-from-hidden.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/111064>.\n+// Methods from a re-exported trait inside a `#[doc(hidden)]` item should\n+// be visible.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"item-name\"]/a[@href=\"trait.Foo.html\"]' 'Foo'\n+\n+// @has 'foo/trait.Foo.html'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"code-header\"]' 'fn test()'\n+\n+#[doc(hidden)]\n+mod hidden {\n+    pub trait Foo {\n+        /// Hello, world!\n+        fn test();\n+    }\n+}\n+\n+pub use hidden::Foo;"}, {"sha": "a3db2e9ef24c4a2db9e86dd0078b9b3e546e5fa2", "filename": "tests/ui-fulldeps/stable-mir/crate-info.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-fulldeps%2Fstable-mir%2Fcrate-info.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -40,6 +40,7 @@ fn test_stable_mir(tcx: TyCtxt<'_>) {\n \n     let bar = get_item(tcx, &items, (DefKind::Fn, \"bar\")).unwrap();\n     let body = bar.body();\n+    assert_eq!(body.locals.len(), 2);\n     assert_eq!(body.blocks.len(), 1);\n     let block = &body.blocks[0];\n     assert_eq!(block.statements.len(), 1);\n@@ -54,6 +55,7 @@ fn test_stable_mir(tcx: TyCtxt<'_>) {\n \n     let foo_bar = get_item(tcx, &items, (DefKind::Fn, \"foo_bar\")).unwrap();\n     let body = foo_bar.body();\n+    assert_eq!(body.locals.len(), 7);\n     assert_eq!(body.blocks.len(), 4);\n     let block = &body.blocks[0];\n     match &block.terminator {\n@@ -123,7 +125,7 @@ impl Callbacks for SMirCalls {\n         queries: &'tcx Queries<'tcx>,\n     ) -> Compilation {\n         queries.global_ctxt().unwrap().enter(|tcx| {\n-            test_stable_mir(tcx);\n+            rustc_smir::rustc_internal::run(tcx, || test_stable_mir(tcx));\n         });\n         // No need to keep going.\n         Compilation::Stop"}, {"sha": "88327f864237ac2a9ad4849bbbc033059051de1b", "filename": "tests/ui/associated-inherent-types/issue-109790.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fissue-109790.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(inherent_associated_types)]\n #![allow(incomplete_features)]\n+#![deny(single_use_lifetimes)]\n \n struct Foo<T>(T);\n "}, {"sha": "91b81428b38a4d4785c2a14382067c9029cd94c2", "filename": "tests/ui/check-cfg/order-independant.names_after.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_after.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_after.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_after.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,19 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:8:7\n+   |\n+LL | #[cfg(a)]\n+   |       ^- help: specify a config value: `= \"b\"`\n+   |\n+   = note: expected values for `a` are: `b`\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:12:7\n+   |\n+LL | #[cfg(a = \"unk\")]\n+   |       ^^^^^^^^^\n+   |\n+   = note: expected values for `a` are: `b`\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "91b81428b38a4d4785c2a14382067c9029cd94c2", "filename": "tests/ui/check-cfg/order-independant.names_before.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_before.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_before.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_before.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,19 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:8:7\n+   |\n+LL | #[cfg(a)]\n+   |       ^- help: specify a config value: `= \"b\"`\n+   |\n+   = note: expected values for `a` are: `b`\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:12:7\n+   |\n+LL | #[cfg(a = \"unk\")]\n+   |       ^^^^^^^^^\n+   |\n+   = note: expected values for `a` are: `b`\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "ce056b8dcd6f858c7159488ed47d4bc46399f41d", "filename": "tests/ui/check-cfg/order-independant.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fcheck-cfg%2Forder-independant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fcheck-cfg%2Forder-independant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Forder-independant.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// revisions: names_before names_after\n+// compile-flags: -Z unstable-options\n+// compile-flags: --check-cfg=names(names_before,names_after)\n+// [names_before]compile-flags: --check-cfg=names(a) --check-cfg=values(a,\"b\")\n+// [names_after]compile-flags: --check-cfg=values(a,\"b\") --check-cfg=names(a)\n+\n+#[cfg(a)]\n+//~^ WARNING unexpected `cfg` condition value\n+fn my_cfg() {}\n+\n+#[cfg(a = \"unk\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn my_cfg() {}\n+\n+fn main() {}"}, {"sha": "a7bf9b67d453ef2da607c74630b19f5c6679d765", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,23 @@\n+// regression test for #108683\n+// edition:2021\n+\n+enum Refutable {\n+    A,\n+    B,\n+}\n+\n+fn example(v1: u32, v2: [u32; 4], v3: Refutable) {\n+    const PAT: u32 = 0;\n+    let v4 = &v2[..];\n+    || {\n+        let 0 = v1; //~ ERROR refutable pattern in local binding\n+        let (0 | 1) = v1; //~ ERROR refutable pattern in local binding\n+        let 1.. = v1; //~ ERROR refutable pattern in local binding\n+        let [0, 0, 0, 0] = v2; //~ ERROR refutable pattern in local binding\n+        let [0] = v4; //~ ERROR refutable pattern in local binding\n+        let Refutable::A = v3; //~ ERROR refutable pattern in local binding\n+        let PAT = v1; //~ ERROR refutable pattern in local binding\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "ca8c2a16d323f9fcbca2c72d7c4a8377438e9ae1", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,113 @@\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:13:13\n+   |\n+LL |         let 0 = v1;\n+   |             ^ pattern `1_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 0 = v1 { todo!() };\n+   |         ++            +++++++++++\n+help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+   |\n+LL |         let _0 = v1;\n+   |             +\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:14:14\n+   |\n+LL |         let (0 | 1) = v1;\n+   |              ^^^^^ pattern `2_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let (0 | 1) = v1 { todo!() };\n+   |         ++                  +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:15:13\n+   |\n+LL |         let 1.. = v1;\n+   |             ^^^ pattern `0_u32` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 1.. = v1 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:16:13\n+   |\n+LL |         let [0, 0, 0, 0] = v2;\n+   |             ^^^^^^^^^^^^ pattern `[1_u32..=u32::MAX, _, _, _]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `[u32; 4]`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let [0, 0, 0, 0] = v2 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:17:13\n+   |\n+LL |         let [0] = v4;\n+   |             ^^^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `&[u32]`\n+help: you might want to use `if let` to ignore the variants that aren't matched\n+   |\n+LL |         if let [0] = v4 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:18:13\n+   |\n+LL |         let Refutable::A = v3;\n+   |             ^^^^^^^^^^^^ pattern `Refutable::B` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Refutable` defined here\n+  --> $DIR/bad-pattern.rs:4:6\n+   |\n+LL | enum Refutable {\n+   |      ^^^^^^^^^\n+LL |     A,\n+LL |     B,\n+   |     - not covered\n+   = note: the matched value is of type `Refutable`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let Refutable::A = v3 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:19:13\n+   |\n+LL |         let PAT = v1;\n+   |             ^^^\n+   |             |\n+   |             pattern `1_u32..=u32::MAX` not covered\n+   |             missing patterns are not covered because `PAT` is interpreted as a constant pattern, not a new variable\n+   |             help: introduce a variable instead: `PAT_var`\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0005`."}, {"sha": "ba42f619a5461dbb1c2fbeae7e57648444e9cb71", "filename": "tests/ui/dyn-star/check-size-at-cast-polymorphic-bad.current.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.current.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.current.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.current.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: `&T` needs to have the same ABI as a pointer\n-  --> $DIR/check-size-at-cast-polymorphic-bad.rs:11:15\n+  --> $DIR/check-size-at-cast-polymorphic-bad.rs:14:15\n    |\n LL |     dyn_debug(t);\n    |               ^ `&T` needs to be a pointer-like type", "previous_filename": "tests/ui/dyn-star/check-size-at-cast-polymorphic-bad.stderr"}, {"sha": "ba42f619a5461dbb1c2fbeae7e57648444e9cb71", "filename": "tests/ui/dyn-star/check-size-at-cast-polymorphic-bad.next.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.next.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.next.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.next.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: `&T` needs to have the same ABI as a pointer\n+  --> $DIR/check-size-at-cast-polymorphic-bad.rs:14:15\n+   |\n+LL |     dyn_debug(t);\n+   |               ^ `&T` needs to be a pointer-like type\n+   |\n+   = help: the trait `PointerLike` is not implemented for `&T`\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn polymorphic<T: Debug + ?Sized>(t: &T) where &T: PointerLike {\n+   |                                          +++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9846f87142457fd21c003c635cd48b39d6f5ee74", "filename": "tests/ui/dyn-star/check-size-at-cast-polymorphic-bad.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdyn-star%2Fcheck-size-at-cast-polymorphic-bad.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -1,3 +1,6 @@\n+// revisions: current next\n+//[next] compile-flags: -Ztrait-solver=next\n+\n #![feature(dyn_star)]\n #![allow(incomplete_features)]\n "}, {"sha": "b0dddd3b1e8d01b1dde5eae95cc448e40de46b67", "filename": "tests/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -15,7 +15,7 @@ LL |     format!(\"{:X}\", \"3\");\n              NonZeroI64\n              NonZeroI8\n              NonZeroIsize\n-           and 21 others\n+           and 20 others\n    = note: required for `&str` to implement `UpperHex`\n note: required by a bound in `core::fmt::rt::Argument::<'a>::new_upper_hex`\n   --> $SRC_DIR/core/src/fmt/rt.rs:LL:COL"}, {"sha": "7171bd8a42dd2dbbff6380d268037c0503951f1f", "filename": "tests/ui/resolve/explicit-self-lowercase-param.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fresolve%2Fexplicit-self-lowercase-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fresolve%2Fexplicit-self-lowercase-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fexplicit-self-lowercase-param.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,8 @@\n+struct Foo;\n+\n+impl Foo {\n+    fn do_nothing(self: Box<self>) {} //~ ERROR attempt to use a non-constant value in a constant\n+    //~^ HELP try using `Self`\n+}\n+\n+fn main() {}"}, {"sha": "cd64dbb3854afc9a0e140cff01c6aae03374e4be", "filename": "tests/ui/resolve/explicit-self-lowercase-param.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fresolve%2Fexplicit-self-lowercase-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Fresolve%2Fexplicit-self-lowercase-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fresolve%2Fexplicit-self-lowercase-param.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,8 @@\n+error: attempt to use a non-constant value in a constant\n+  --> $DIR/explicit-self-lowercase-param.rs:4:29\n+   |\n+LL |     fn do_nothing(self: Box<self>) {}\n+   |                             ^^^^ help: try using `Self`\n+\n+error: aborting due to previous error\n+"}, {"sha": "00294c708f1fa059701f02808d1fad4f3e018378", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// Makes sure that alias bounds are not unsound!\n+\n+#![feature(trivial_bounds)]\n+\n+trait Foo {\n+    type Item: Copy\n+    where\n+        <Self as Foo>::Item: Copy;\n+\n+    fn copy_me(x: &Self::Item) -> Self::Item {\n+        *x\n+    }\n+}\n+\n+impl Foo for () {\n+    type Item = String where String: Copy;\n+}\n+\n+fn main() {\n+    let x = String::from(\"hello, world\");\n+    drop(<() as Foo>::copy_me(&x));\n+    //~^ ERROR `<() as Foo>::Item: Copy` is not satisfied\n+    //~| ERROR `<() as Foo>::Item` is not well-formed\n+    println!(\"{x}\");\n+}"}, {"sha": "9a43d2a6639ce86bf4ded8d1ca86277a8fa41b01", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `<() as Foo>::Item: Copy` is not satisfied\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `<() as Foo>::Item`\n+   |\n+note: required by a bound in `Foo::Item`\n+  --> $DIR/alias-bound-unsound.rs:10:30\n+   |\n+LL |     type Item: Copy\n+   |          ---- required by a bound in this associated type\n+LL |     where\n+LL |         <Self as Foo>::Item: Copy;\n+   |                              ^^^^ required by this bound in `Foo::Item`\n+\n+error: the type `<() as Foo>::Item` is not well-formed\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c365902dbe5e833a07f1e5f98f247d1774b708aa", "filename": "tests/ui/traits/new-solver/nested-alias-bound.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait A {\n+    type A: B;\n+}\n+\n+trait B {\n+    type B: C;\n+}\n+\n+trait C {}\n+\n+fn needs_c<T: C>() {}\n+\n+fn test<T: A>() {\n+    needs_c::<<T::A as B>::B>();\n+}\n+\n+fn main() {}"}, {"sha": "9e96323ab54bbaa6cf8e26fa6814c09d4544e499", "filename": "tests/ui/type-alias-impl-trait/wf-in-associated-type.fail.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.fail.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,25 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-in-associated-type.rs:36:23\n+   |\n+LL |         type Opaque = impl Sized + 'a;\n+   |                       ^^^^^^^^^^^^^^^ ...so that the type `&'a T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     impl<'a, T: 'a> Trait<'a, T> for () {\n+   |               ++++\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-in-associated-type.rs:36:23\n+   |\n+LL |         type Opaque = impl Sized + 'a;\n+   |                       ^^^^^^^^^^^^^^^ ...so that the reference type `&'a T` does not outlive the data it points at\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     impl<'a, T: 'a> Trait<'a, T> for () {\n+   |               ++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0309`."}, {"sha": "31fbef9f78f834b0b9acd9bf74a63192519cac06", "filename": "tests/ui/type-alias-impl-trait/wf-in-associated-type.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-in-associated-type.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,45 @@\n+// WF check for impl Trait in associated type position.\n+//\n+// revisions: pass fail\n+// [pass] check-pass\n+// [fail] check-fail\n+\n+#![feature(impl_trait_in_assoc_type)]\n+\n+// The hidden type here (`&'a T`) requires proving `T: 'a`.\n+// We know it holds because of implied bounds from the impl header.\n+#[cfg(pass)]\n+mod pass {\n+    trait Trait<Req> {\n+        type Opaque1;\n+        fn constrain_opaque1(req: Req) -> Self::Opaque1;\n+    }\n+\n+    impl<'a, T> Trait<&'a T> for () {\n+        type Opaque1 = impl IntoIterator<Item = impl Sized + 'a>;\n+        fn constrain_opaque1(req: &'a T) -> Self::Opaque1 {\n+            [req]\n+        }\n+    }\n+}\n+\n+// The hidden type here (`&'a T`) requires proving `T: 'a`,\n+// but that is not known to hold in the impl.\n+#[cfg(fail)]\n+mod fail {\n+    trait Trait<'a, T> {\n+        type Opaque;\n+        fn constrain_opaque(req: &'a T) -> Self::Opaque;\n+    }\n+\n+    impl<'a, T> Trait<'a, T> for () {\n+        type Opaque = impl Sized + 'a;\n+        //[fail]~^ ERROR the parameter type `T` may not live long enough\n+        //[fail]~| ERROR the parameter type `T` may not live long enough\n+        fn constrain_opaque(req: &'a T) -> Self::Opaque {\n+            req\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "753a46e882eda4e64964a7760bcd4972e34f5e8a", "filename": "tests/ui/type-alias-impl-trait/wf-nested.fail.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.fail.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,19 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-nested.rs:55:27\n+   |\n+LL |     type InnerOpaque<T> = impl Sized;\n+   |                           ^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds...\n+   |\n+note: ...that is required by this bound\n+  --> $DIR/wf-nested.rs:12:20\n+   |\n+LL | struct IsStatic<T: 'static>(T);\n+   |                    ^^^^^^^\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     type InnerOpaque<T: 'static> = impl Sized;\n+   |                       +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "9ab6685a7f73fd305b218d7fdfae30706ce110ea", "filename": "tests/ui/type-alias-impl-trait/wf-nested.pass_sound.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.pass_sound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.pass_sound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.pass_sound.stderr?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,14 @@\n+error[E0310]: the parameter type `T` may not live long enough\n+  --> $DIR/wf-nested.rs:46:17\n+   |\n+LL |         let _ = outer.get();\n+   |                 ^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n+   |\n+help: consider adding an explicit lifetime bound...\n+   |\n+LL |     fn test<T: 'static>() {\n+   |              +++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0310`."}, {"sha": "de38832948918c82627c07afa95630156e800cf8", "filename": "tests/ui/type-alias-impl-trait/wf-nested.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype-alias-impl-trait%2Fwf-nested.rs?ref=154c7a5e91ff9ebf8ab08d8f7db30ed2070e56a5", "patch": "@@ -0,0 +1,60 @@\n+// Well-formedness of nested opaque types, i.e. `impl Sized` in\n+// `type Outer = impl Trait<Assoc = impl Sized>`.\n+// See the comments below.\n+//\n+// revisions: pass pass_sound fail\n+// [pass] check-pass\n+// [pass_sound] check-fail\n+// [fail] check-fail\n+\n+#![feature(type_alias_impl_trait)]\n+\n+struct IsStatic<T: 'static>(T);\n+\n+trait Trait<In> {\n+    type Out;\n+\n+    fn get(&self) -> Result<Self::Out, ()> {\n+        Err(())\n+    }\n+}\n+\n+impl<T> Trait<&'static T> for () {\n+    type Out = IsStatic<T>;\n+}\n+\n+// The hidden type for `impl Sized` is `IsStatic<T>`, which requires `T: 'static`.\n+// We know it is well-formed because it can *only* be referenced as a projection:\n+// <OuterOpaque<T> as Trait<&'static T>>::Out`.\n+// So any instantiation of the type already requires proving `T: 'static`.\n+#[cfg(pass)]\n+mod pass {\n+    use super::*;\n+    type OuterOpaque<T> = impl Trait<&'static T, Out = impl Sized>;\n+    fn define<T>() -> OuterOpaque<T> {}\n+}\n+\n+// Test the soundness of `pass` - We should require `T: 'static` at the use site.\n+#[cfg(pass_sound)]\n+mod pass_sound {\n+    use super::*;\n+    type OuterOpaque<T> = impl Trait<&'static T, Out = impl Sized>;\n+    fn define<T>() -> OuterOpaque<T> {}\n+\n+    fn test<T>() {\n+        let outer = define::<T>();\n+        let _ = outer.get(); //[pass_sound]~ ERROR `T` may not live long enough\n+    }\n+}\n+\n+// Similar to `pass` but here `impl Sized` can be referenced directly as\n+// InnerOpaque<T>, so we require an explicit bound `T: 'static`.\n+#[cfg(fail)]\n+mod fail {\n+    use super::*;\n+    type InnerOpaque<T> = impl Sized; //[fail]~ ERROR `T` may not live long enough\n+    type OuterOpaque<T> = impl Trait<&'static T, Out = InnerOpaque<T>>;\n+    fn define<T>() -> OuterOpaque<T> {}\n+}\n+\n+fn main() {}"}]}