{"sha": "888067c623387d615504f595c097e2da55f6b123", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ODA2N2M2MjMzODdkNjE1NTA0ZjU5NWMwOTdlMmRhNTVmNmIxMjM=", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2020-08-04T10:06:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-04T10:06:40Z"}, "message": "Rollup merge of #5848 - Ryan1729:add-derive_ord_xor_partial_ord-lint, r=matthiaskrgr\n\nAdd derive_ord_xor_partial_ord lint\n\nFix #1621\n\nSome remarks:\nThis PR follows the example of the analogous derive_hash_xor_partial_eq lint where possible.\nI initially tried using the `match_path` function to identify `Ord` implementation like the derive_hash_xor_partial_eq lint currently does, for `Hash` implementations but that didn't work.\n\nSpecifically, the structs at the top level were getting paths that matched `&[\"$crate\", \"cmp\", \"Ord\"]` instead of `&[\"std\", \"cmp\", \"Ord\"]`. While trying to figure out what to do instead I saw the comment at the top of [clippy_lints/src/utils/paths.rs](https://github.com/rust-lang/rust-clippy/blob/f5d429cd762423901f946abd800dc2cd91366ccf/clippy_lints/src/utils/paths.rs#L5) that mentioned [this issue](https://github.com/rust-lang/rust-clippy/issues/5393) and suggested to use diagnostic items instead of hardcoded paths whenever possible. I looked for a way to identify `Ord` implementations with diagnostic items, but (possibly because this was the first time I had heard of diagnostic items,) I was unable to find one.\n\nEventually I tried using `get_trait_def_id` and comparing `DefId` values directly and that seems to work as expected. Maybe there's a better approach however?\n\nchangelog: new lint: derive_ord_xor_partial_ord", "tree": {"sha": "48b7c596fb5d31d2d10b50cc18530e060d8d39ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b7c596fb5d31d2d10b50cc18530e060d8d39ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/888067c623387d615504f595c097e2da55f6b123", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfKTMwCRBK7hj4Ov3rIwAAdHIIAEAggG97ng7s/s4v0k8WKjuI\ngz0bluYZnqhaS+3gUvHnKWDRt2HC7WCwwLKof25Cw8Rs8S1pUrbHrmnps1reXXTZ\narCpiAlKjBpIEqcsjKiLyWFD9jjdrTLje8IjLbwDBQes+g09TTmvEALYB4Gg+IoF\nqtZijTmC3q5NFFwkhXsXX/v5TJRj27W7pnYXH7DvdstcJruzvVjg8rehg/tdyMeD\nn3g8aOKohgy/8Tul8FzoAiNAXwT1d2wHsIBg9/B3u5qt41XeTJ+qFAp2/rVMQ5x4\nWR2xhxCiZCwPWqYQNxqE9YdpV6EmxkpRAUjU5x/HCG8nS9+K9IEg7mLAVHUKxeQ=\n=CqPh\n-----END PGP SIGNATURE-----\n", "payload": "tree 48b7c596fb5d31d2d10b50cc18530e060d8d39ab\nparent 378ba2e03e192cbf3a416c151c6fe98e69375e25\nparent 94b10a6e5ab003a03b6c7b60ffe5a3b366e0529a\nauthor Philipp Krones <hello@philkrones.com> 1596535600 +0200\ncommitter GitHub <noreply@github.com> 1596535600 +0200\n\nRollup merge of #5848 - Ryan1729:add-derive_ord_xor_partial_ord-lint, r=matthiaskrgr\n\nAdd derive_ord_xor_partial_ord lint\n\nFix #1621\n\nSome remarks:\nThis PR follows the example of the analogous derive_hash_xor_partial_eq lint where possible.\nI initially tried using the `match_path` function to identify `Ord` implementation like the derive_hash_xor_partial_eq lint currently does, for `Hash` implementations but that didn't work.\n\nSpecifically, the structs at the top level were getting paths that matched `&[\"$crate\", \"cmp\", \"Ord\"]` instead of `&[\"std\", \"cmp\", \"Ord\"]`. While trying to figure out what to do instead I saw the comment at the top of [clippy_lints/src/utils/paths.rs](https://github.com/rust-lang/rust-clippy/blob/f5d429cd762423901f946abd800dc2cd91366ccf/clippy_lints/src/utils/paths.rs#L5) that mentioned [this issue](https://github.com/rust-lang/rust-clippy/issues/5393) and suggested to use diagnostic items instead of hardcoded paths whenever possible. I looked for a way to identify `Ord` implementations with diagnostic items, but (possibly because this was the first time I had heard of diagnostic items,) I was unable to find one.\n\nEventually I tried using `get_trait_def_id` and comparing `DefId` values directly and that seems to work as expected. Maybe there's a better approach however?\n\nchangelog: new lint: derive_ord_xor_partial_ord\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/888067c623387d615504f595c097e2da55f6b123", "html_url": "https://github.com/rust-lang/rust/commit/888067c623387d615504f595c097e2da55f6b123", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/888067c623387d615504f595c097e2da55f6b123/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "378ba2e03e192cbf3a416c151c6fe98e69375e25", "url": "https://api.github.com/repos/rust-lang/rust/commits/378ba2e03e192cbf3a416c151c6fe98e69375e25", "html_url": "https://github.com/rust-lang/rust/commit/378ba2e03e192cbf3a416c151c6fe98e69375e25"}, {"sha": "94b10a6e5ab003a03b6c7b60ffe5a3b366e0529a", "url": "https://api.github.com/repos/rust-lang/rust/commits/94b10a6e5ab003a03b6c7b60ffe5a3b366e0529a", "html_url": "https://github.com/rust-lang/rust/commit/94b10a6e5ab003a03b6c7b60ffe5a3b366e0529a"}], "stats": {"total": 266, "additions": 264, "deletions": 2}, "files": [{"sha": "a178072504439e6e3ad273ac829dd32210af9c55", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/888067c623387d615504f595c097e2da55f6b123/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/888067c623387d615504f595c097e2da55f6b123/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=888067c623387d615504f595c097e2da55f6b123", "patch": "@@ -1454,6 +1454,7 @@ Released 2018-09-13\n [`deprecated_semver`]: https://rust-lang.github.io/rust-clippy/master/index.html#deprecated_semver\n [`deref_addrof`]: https://rust-lang.github.io/rust-clippy/master/index.html#deref_addrof\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n+[`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons"}, {"sha": "08d8100a88545bc7ee8ada5d6ec8bc6f92e992dc", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 114, "deletions": 2, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/888067c623387d615504f595c097e2da55f6b123/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888067c623387d615504f595c097e2da55f6b123/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=888067c623387d615504f595c097e2da55f6b123", "patch": "@@ -1,6 +1,7 @@\n use crate::utils::paths;\n use crate::utils::{\n-    is_automatically_derived, is_copy, match_path, span_lint_and_help, span_lint_and_note, span_lint_and_then,\n+    get_trait_def_id, is_automatically_derived, is_copy, match_path, span_lint_and_help, span_lint_and_note,\n+    span_lint_and_then,\n };\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n@@ -43,6 +44,57 @@ declare_clippy_lint! {\n     \"deriving `Hash` but implementing `PartialEq` explicitly\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for deriving `Ord` but implementing `PartialOrd`\n+    /// explicitly or vice versa.\n+    ///\n+    /// **Why is this bad?** The implementation of these traits must agree (for\n+    /// example for use with `sort`) so it\u2019s probably a bad idea to use a\n+    /// default-generated `Ord` implementation with an explicitly defined\n+    /// `PartialOrd`. In particular, the following must hold for any type\n+    /// implementing `Ord`:\n+    ///\n+    /// ```text\n+    /// k1.cmp(&k2) == k1.partial_cmp(&k2).unwrap()\n+    /// ```\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// #[derive(Ord, PartialEq, Eq)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialOrd for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// #[derive(PartialEq, Eq)]\n+    /// struct Foo;\n+    ///\n+    /// impl PartialOrd for Foo {\n+    ///     fn partial_cmp(&self, other: &Foo) -> Option<Ordering> {\n+    ///        Some(self.cmp(other))\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Ord for Foo {\n+    ///     ...\n+    /// }\n+    /// ```\n+    /// or, if you don't need a custom ordering:\n+    /// ```rust,ignore\n+    /// #[derive(Ord, PartialOrd, PartialEq, Eq)]\n+    /// struct Foo;\n+    /// ```\n+    pub DERIVE_ORD_XOR_PARTIAL_ORD,\n+    correctness,\n+    \"deriving `Ord` but implementing `PartialOrd` explicitly\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit `Clone` implementations for `Copy`\n     /// types.\n@@ -103,7 +155,12 @@ declare_clippy_lint! {\n     \"deriving `serde::Deserialize` on a type that has methods using `unsafe`\"\n }\n \n-declare_lint_pass!(Derive => [EXPL_IMPL_CLONE_ON_COPY, DERIVE_HASH_XOR_EQ, UNSAFE_DERIVE_DESERIALIZE]);\n+declare_lint_pass!(Derive => [\n+    EXPL_IMPL_CLONE_ON_COPY,\n+    DERIVE_HASH_XOR_EQ,\n+    DERIVE_ORD_XOR_PARTIAL_ORD,\n+    UNSAFE_DERIVE_DESERIALIZE\n+]);\n \n impl<'tcx> LateLintPass<'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n@@ -116,6 +173,7 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n+            check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);\n \n             if is_automatically_derived {\n                 check_unsafe_derive_deserialize(cx, item, trait_ref, ty);\n@@ -180,6 +238,60 @@ fn check_hash_peq<'tcx>(\n     }\n }\n \n+/// Implementation of the `DERIVE_ORD_XOR_PARTIAL_ORD` lint.\n+fn check_ord_partial_ord<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    trait_ref: &TraitRef<'_>,\n+    ty: Ty<'tcx>,\n+    ord_is_automatically_derived: bool,\n+) {\n+    if_chain! {\n+        if let Some(ord_trait_def_id) = get_trait_def_id(cx, &paths::ORD);\n+        if let Some(partial_ord_trait_def_id) = cx.tcx.lang_items().partial_ord_trait();\n+        if let Some(def_id) = &trait_ref.trait_def_id();\n+        if *def_id == ord_trait_def_id;\n+        then {\n+            // Look for the PartialOrd implementations for `ty`\n+            cx.tcx.for_each_relevant_impl(partial_ord_trait_def_id, ty, |impl_id| {\n+                let partial_ord_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+\n+                if partial_ord_is_automatically_derived == ord_is_automatically_derived {\n+                    return;\n+                }\n+\n+                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+\n+                // Only care about `impl PartialOrd<Foo> for Foo`\n+                // For `impl PartialOrd<B> for A, input_types is [A, B]\n+                if trait_ref.substs.type_at(1) == ty {\n+                    let mess = if partial_ord_is_automatically_derived {\n+                        \"you are implementing `Ord` explicitly but have derived `PartialOrd`\"\n+                    } else {\n+                        \"you are deriving `Ord` but have implemented `PartialOrd` explicitly\"\n+                    };\n+\n+                    span_lint_and_then(\n+                        cx,\n+                        DERIVE_ORD_XOR_PARTIAL_ORD,\n+                        span,\n+                        mess,\n+                        |diag| {\n+                            if let Some(local_def_id) = impl_id.as_local() {\n+                                let hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+                                diag.span_note(\n+                                    cx.tcx.hir().span(hir_id),\n+                                    \"`PartialOrd` implemented here\"\n+                                );\n+                            }\n+                        }\n+                    );\n+                }\n+            });\n+        }\n+    }\n+}\n+\n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &TraitRef<'_>, ty: Ty<'tcx>) {\n     if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {"}, {"sha": "996aad31d3e1f4f7ab0d0eb6b48fd2ba7334bbea", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/888067c623387d615504f595c097e2da55f6b123/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888067c623387d615504f595c097e2da55f6b123/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=888067c623387d615504f595c097e2da55f6b123", "patch": "@@ -513,6 +513,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &default_trait_access::DEFAULT_TRAIT_ACCESS,\n         &dereference::EXPLICIT_DEREF_METHODS,\n         &derive::DERIVE_HASH_XOR_EQ,\n+        &derive::DERIVE_ORD_XOR_PARTIAL_ORD,\n         &derive::EXPL_IMPL_CLONE_ON_COPY,\n         &derive::UNSAFE_DERIVE_DESERIALIZE,\n         &doc::DOC_MARKDOWN,\n@@ -1230,6 +1231,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n+        LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&doc::MISSING_SAFETY_DOC),\n         LintId::of(&doc::NEEDLESS_DOCTEST_MAIN),\n         LintId::of(&double_comparison::DOUBLE_COMPARISONS),\n@@ -1648,6 +1650,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&copies::IFS_SAME_COND),\n         LintId::of(&copies::IF_SAME_THEN_ELSE),\n         LintId::of(&derive::DERIVE_HASH_XOR_EQ),\n+        LintId::of(&derive::DERIVE_ORD_XOR_PARTIAL_ORD),\n         LintId::of(&drop_bounds::DROP_BOUNDS),\n         LintId::of(&drop_forget_ref::DROP_COPY),\n         LintId::of(&drop_forget_ref::DROP_REF),"}, {"sha": "119908b3cc45dc69d6a8fb8cd8ada57c99ee0f48", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/888067c623387d615504f595c097e2da55f6b123/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888067c623387d615504f595c097e2da55f6b123/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=888067c623387d615504f595c097e2da55f6b123", "patch": "@@ -360,6 +360,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"derive\",\n     },\n+    Lint {\n+        name: \"derive_ord_xor_partial_ord\",\n+        group: \"correctness\",\n+        desc: \"deriving `Ord` but implementing `PartialOrd` explicitly\",\n+        deprecation: None,\n+        module: \"derive\",\n+    },\n     Lint {\n         name: \"diverging_sub_expression\",\n         group: \"complexity\","}, {"sha": "b82dc518a3ba60520d21f016e2b213ddb430bed4", "filename": "tests/ui/derive_ord_xor_partial_ord.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/888067c623387d615504f595c097e2da55f6b123/tests%2Fui%2Fderive_ord_xor_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888067c623387d615504f595c097e2da55f6b123/tests%2Fui%2Fderive_ord_xor_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_ord_xor_partial_ord.rs?ref=888067c623387d615504f595c097e2da55f6b123", "patch": "@@ -0,0 +1,68 @@\n+#![warn(clippy::derive_ord_xor_partial_ord)]\n+\n+use std::cmp::Ordering;\n+\n+#[derive(PartialOrd, Ord, PartialEq, Eq)]\n+struct DeriveBoth;\n+\n+impl PartialEq<u64> for DeriveBoth {\n+    fn eq(&self, _: &u64) -> bool {\n+        true\n+    }\n+}\n+\n+impl PartialOrd<u64> for DeriveBoth {\n+    fn partial_cmp(&self, _: &u64) -> Option<Ordering> {\n+        Some(Ordering::Equal)\n+    }\n+}\n+\n+#[derive(Ord, PartialEq, Eq)]\n+struct DeriveOrd;\n+\n+impl PartialOrd for DeriveOrd {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(other.cmp(self))\n+    }\n+}\n+\n+#[derive(Ord, PartialEq, Eq)]\n+struct DeriveOrdWithExplicitTypeVariable;\n+\n+impl PartialOrd<DeriveOrdWithExplicitTypeVariable> for DeriveOrdWithExplicitTypeVariable {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(other.cmp(self))\n+    }\n+}\n+\n+#[derive(PartialOrd, PartialEq, Eq)]\n+struct DerivePartialOrd;\n+\n+impl std::cmp::Ord for DerivePartialOrd {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        Ordering::Less\n+    }\n+}\n+\n+#[derive(PartialOrd, PartialEq, Eq)]\n+struct ImplUserOrd;\n+\n+trait Ord {}\n+\n+// We don't want to lint on user-defined traits called `Ord`\n+impl Ord for ImplUserOrd {}\n+\n+mod use_ord {\n+    use std::cmp::{Ord, Ordering};\n+\n+    #[derive(PartialOrd, PartialEq, Eq)]\n+    struct DerivePartialOrdInUseOrd;\n+\n+    impl Ord for DerivePartialOrdInUseOrd {\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            Ordering::Less\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "66bc4d42ce8c3c85e80d571bcbb658884a92cbe3", "filename": "tests/ui/derive_ord_xor_partial_ord.stderr", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/888067c623387d615504f595c097e2da55f6b123/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/888067c623387d615504f595c097e2da55f6b123/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive_ord_xor_partial_ord.stderr?ref=888067c623387d615504f595c097e2da55f6b123", "patch": "@@ -0,0 +1,71 @@\n+error: you are deriving `Ord` but have implemented `PartialOrd` explicitly\n+  --> $DIR/derive_ord_xor_partial_ord.rs:20:10\n+   |\n+LL | #[derive(Ord, PartialEq, Eq)]\n+   |          ^^^\n+   |\n+   = note: `-D clippy::derive-ord-xor-partial-ord` implied by `-D warnings`\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:23:1\n+   |\n+LL | / impl PartialOrd for DeriveOrd {\n+LL | |     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+LL | |         Some(other.cmp(self))\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are deriving `Ord` but have implemented `PartialOrd` explicitly\n+  --> $DIR/derive_ord_xor_partial_ord.rs:29:10\n+   |\n+LL | #[derive(Ord, PartialEq, Eq)]\n+   |          ^^^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:32:1\n+   |\n+LL | / impl PartialOrd<DeriveOrdWithExplicitTypeVariable> for DeriveOrdWithExplicitTypeVariable {\n+LL | |     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+LL | |         Some(other.cmp(self))\n+LL | |     }\n+LL | | }\n+   | |_^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are implementing `Ord` explicitly but have derived `PartialOrd`\n+  --> $DIR/derive_ord_xor_partial_ord.rs:41:1\n+   |\n+LL | / impl std::cmp::Ord for DerivePartialOrd {\n+LL | |     fn cmp(&self, other: &Self) -> Ordering {\n+LL | |         Ordering::Less\n+LL | |     }\n+LL | | }\n+   | |_^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:38:10\n+   |\n+LL | #[derive(PartialOrd, PartialEq, Eq)]\n+   |          ^^^^^^^^^^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: you are implementing `Ord` explicitly but have derived `PartialOrd`\n+  --> $DIR/derive_ord_xor_partial_ord.rs:61:5\n+   |\n+LL | /     impl Ord for DerivePartialOrdInUseOrd {\n+LL | |         fn cmp(&self, other: &Self) -> Ordering {\n+LL | |             Ordering::Less\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+note: `PartialOrd` implemented here\n+  --> $DIR/derive_ord_xor_partial_ord.rs:58:14\n+   |\n+LL |     #[derive(PartialOrd, PartialEq, Eq)]\n+   |              ^^^^^^^^^^\n+   = note: this error originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 4 previous errors\n+"}]}