{"sha": "0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MDBiMTc4YWEwZTlmMzEwMDY3YmY4Y2NhZjczNmU3N2EwM2ViMWQ=", "commit": {"author": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-09-24T06:21:31Z"}, "committer": {"name": "Valerii Lashmanov", "email": "vflashm@gmail.com", "date": "2020-09-26T19:30:05Z"}, "message": "SsoHashSet/SsoHashMap API greatly expanded\n\nNow both provide almost complete API of their non-SSO counterparts.", "tree": {"sha": "cabfe4537ed3bcec07dc66cfe64675993584a989", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cabfe4537ed3bcec07dc66cfe64675993584a989"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "html_url": "https://github.com/rust-lang/rust/commit/0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/comments", "author": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "committer": {"login": "VFLashM", "id": 3723853, "node_id": "MDQ6VXNlcjM3MjM4NTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3723853?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VFLashM", "html_url": "https://github.com/VFLashM", "followers_url": "https://api.github.com/users/VFLashM/followers", "following_url": "https://api.github.com/users/VFLashM/following{/other_user}", "gists_url": "https://api.github.com/users/VFLashM/gists{/gist_id}", "starred_url": "https://api.github.com/users/VFLashM/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VFLashM/subscriptions", "organizations_url": "https://api.github.com/users/VFLashM/orgs", "repos_url": "https://api.github.com/users/VFLashM/repos", "events_url": "https://api.github.com/users/VFLashM/events{/privacy}", "received_events_url": "https://api.github.com/users/VFLashM/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c224a484dc6ba2a70c9cd0d73a04849f6d7aa68", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c224a484dc6ba2a70c9cd0d73a04849f6d7aa68", "html_url": "https://github.com/rust-lang/rust/commit/5c224a484dc6ba2a70c9cd0d73a04849f6d7aa68"}], "stats": {"total": 887, "additions": 864, "deletions": 23}, "files": [{"sha": "258368c8ef3221a0f455b7d6860266cd82bbce2d", "filename": "compiler/rustc_data_structures/src/sso/map.rs", "status": "modified", "additions": 488, "deletions": 20, "changes": 508, "blob_url": "https://github.com/rust-lang/rust/blob/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmap.rs?ref=0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "patch": "@@ -1,32 +1,202 @@\n+use super::EitherIter;\n use crate::fx::FxHashMap;\n use arrayvec::ArrayVec;\n-\n+use std::borrow::Borrow;\n+use std::fmt;\n use std::hash::Hash;\n+use std::iter::FromIterator;\n+use std::ops::Index;\n \n-/// Small-storage-optimized implementation of a map\n-/// made specifically for caching results.\n+/// Small-storage-optimized implementation of a map.\n ///\n /// Stores elements in a small array up to a certain length\n /// and switches to `HashMap` when that length is exceeded.\n+///\n+/// Implements subset of HashMap API.\n+///\n+/// Missing HashMap API:\n+///   all hasher-related\n+///   try_reserve (unstable)\n+///   shrink_to (unstable)\n+///   drain_filter (unstable)\n+///   into_keys/into_values (unstable)\n+///   all raw_entry-related\n+///   PartialEq/Eq (requires sorting the array)\n+///   Entry::or_insert_with_key (unstable)\n+///   Vacant/Occupied entries and related\n+#[derive(Clone)]\n pub enum SsoHashMap<K, V> {\n     Array(ArrayVec<[(K, V); 8]>),\n     Map(FxHashMap<K, V>),\n }\n \n-impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n+impl<K, V> SsoHashMap<K, V> {\n     /// Creates an empty `SsoHashMap`.\n     pub fn new() -> Self {\n         SsoHashMap::Array(ArrayVec::new())\n     }\n \n-    /// Inserts or updates value in the map.\n-    pub fn insert(&mut self, key: K, value: V) {\n+    /// Creates an empty `SsoHashMap` with the specified capacity.\n+    pub fn with_capacity(cap: usize) -> Self {\n+        let array = ArrayVec::new();\n+        if array.capacity() >= cap {\n+            SsoHashMap::Array(array)\n+        } else {\n+            SsoHashMap::Map(FxHashMap::with_capacity_and_hasher(cap, Default::default()))\n+        }\n+    }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    pub fn clear(&mut self) {\n+        match self {\n+            SsoHashMap::Array(array) => array.clear(),\n+            SsoHashMap::Map(map) => map.clear(),\n+        }\n+    }\n+\n+    /// Returns the number of elements the map can hold without reallocating.\n+    pub fn capacity(&self) -> usize {\n+        match self {\n+            SsoHashMap::Array(array) => array.capacity(),\n+            SsoHashMap::Map(map) => map.capacity(),\n+        }\n+    }\n+\n+    /// Returns the number of elements in the map.\n+    pub fn len(&self) -> usize {\n+        match self {\n+            SsoHashMap::Array(array) => array.len(),\n+            SsoHashMap::Map(map) => map.len(),\n+        }\n+    }\n+\n+    /// Returns `true` if the map contains no elements.\n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            SsoHashMap::Array(array) => array.is_empty(),\n+            SsoHashMap::Map(map) => map.is_empty(),\n+        }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// The iterator element type is `(&'a K, &'a V)`.\n+    pub fn iter(&self) -> impl Iterator<Item = (&'_ K, &'_ V)> {\n+        self.into_iter()\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// The iterator element type is `(&'a K, &'a mut V)`.\n+    pub fn iter_mut(&mut self) -> impl Iterator<Item = (&'_ K, &'_ mut V)> {\n+        self.into_iter()\n+    }\n+\n+    /// An iterator visiting all keys in arbitrary order.\n+    /// The iterator element type is `&'a K`.\n+    pub fn keys(&self) -> impl Iterator<Item = &'_ K> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(k, _v)| k)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.keys()),\n+        }\n+    }\n+\n+    /// An iterator visiting all values in arbitrary order.\n+    /// The iterator element type is `&'a V`.\n+    pub fn values(&self) -> impl Iterator<Item = &'_ V> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.values()),\n+        }\n+    }\n+\n+    /// An iterator visiting all values mutably in arbitrary order.\n+    /// The iterator element type is `&'a mut V`.\n+    pub fn values_mut(&mut self) -> impl Iterator<Item = &'_ mut V> {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.iter_mut().map(|(_k, v)| v)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.values_mut()),\n+        }\n+    }\n+\n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    pub fn drain(&mut self) -> impl Iterator<Item = (K, V)> + '_ {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.drain(..)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.drain()),\n+        }\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n+    /// Changes underlying storage from array to hashmap\n+    /// if array is full.\n+    fn migrate_if_full(&mut self) {\n+        if let SsoHashMap::Array(array) = self {\n+            if array.is_full() {\n+                *self = SsoHashMap::Map(array.drain(..).collect());\n+            }\n+        }\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `SsoHashMap`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    pub fn reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if array.capacity() < (array.len() + additional) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    map.reserve(additional);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.reserve(additional),\n+        }\n+    }\n+\n+    /// Shrinks the capacity of the map as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    pub fn shrink_to_fit(&mut self) {\n+        if let SsoHashMap::Map(map) = self {\n+            let mut array = ArrayVec::new();\n+            if map.len() <= array.capacity() {\n+                array.extend(map.drain());\n+                *self = SsoHashMap::Array(array);\n+            } else {\n+                map.shrink_to_fit();\n+            }\n+        }\n+    }\n+\n+    /// Retains only the elements specified by the predicate.\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => array.retain(|(k, v)| f(k, v)),\n+            SsoHashMap::Map(map) => map.retain(f),\n+        }\n+    }\n+\n+    /// Inserts a key-value pair into the map.\n+    ///\n+    /// If the map did not have this key present, [`None`] is returned.\n+    ///\n+    /// If the map did have this key present, the value is updated, and the old\n+    /// value is returned. The key is not updated, though; this matters for\n+    /// types that can be `==` without being identical. See the [module-level\n+    /// documentation] for more.\n+    pub fn insert(&mut self, key: K, value: V) -> Option<V> {\n         match self {\n             SsoHashMap::Array(array) => {\n-                for pair in array.iter_mut() {\n-                    if pair.0 == key {\n-                        pair.1 = value;\n-                        return;\n+                for (k, v) in array.iter_mut() {\n+                    if *k == key {\n+                        let old_value = std::mem::replace(v, value);\n+                        return Some(old_value);\n                     }\n                 }\n                 if let Err(error) = array.try_push((key, value)) {\n@@ -35,27 +205,325 @@ impl<K: Eq + Hash, V> SsoHashMap<K, V> {\n                     map.insert(key, value);\n                     *self = SsoHashMap::Map(map);\n                 }\n+                None\n             }\n-            SsoHashMap::Map(map) => {\n-                map.insert(key, value);\n+            SsoHashMap::Map(map) => map.insert(key, value),\n+        }\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    pub fn remove<Q: ?Sized>(&mut self, key: &Q) -> Option<V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if let Some(index) = array.iter().position(|(k, _v)| k.borrow() == key) {\n+                    Some(array.swap_remove(index).1)\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.remove(key),\n+        }\n+    }\n+\n+    /// Removes a key from the map, returning the stored key and value if the\n+    /// key was previously in the map.\n+    pub fn remove_entry<Q: ?Sized>(&mut self, key: &Q) -> Option<(K, V)>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if let Some(index) = array.iter().position(|(k, _v)| k.borrow() == key) {\n+                    Some(array.swap_remove(index))\n+                } else {\n+                    None\n+                }\n             }\n+            SsoHashMap::Map(map) => map.remove_entry(key),\n         }\n     }\n \n-    /// Return value by key if any.\n-    pub fn get(&self, key: &K) -> Option<&V> {\n+    /// Returns a reference to the value corresponding to the key.\n+    pub fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n         match self {\n             SsoHashMap::Array(array) => {\n-                for pair in array {\n-                    if pair.0 == *key {\n-                        return Some(&pair.1);\n+                for (k, v) in array {\n+                    if k.borrow() == key {\n+                        return Some(v);\n                     }\n                 }\n-                return None;\n+                None\n             }\n-            SsoHashMap::Map(map) => {\n-                return map.get(key);\n+            SsoHashMap::Map(map) => map.get(key),\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    pub fn get_mut<Q: ?Sized>(&mut self, key: &Q) -> Option<&mut V>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if (*k).borrow() == key {\n+                        return Some(v);\n+                    }\n+                }\n+                None\n             }\n+            SsoHashMap::Map(map) => map.get_mut(key),\n         }\n     }\n+\n+    /// Returns the key-value pair corresponding to the supplied key.\n+    pub fn get_key_value<Q: ?Sized>(&self, key: &Q) -> Option<(&K, &V)>\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                for (k, v) in array {\n+                    if k.borrow() == key {\n+                        return Some((k, v));\n+                    }\n+                }\n+                None\n+            }\n+            SsoHashMap::Map(map) => map.get_key_value(key),\n+        }\n+    }\n+\n+    /// Returns `true` if the map contains a value for the specified key.\n+    pub fn contains_key<Q: ?Sized>(&self, key: &Q) -> bool\n+    where\n+        K: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashMap::Array(array) => array.iter().any(|(k, _v)| k.borrow() == key),\n+            SsoHashMap::Map(map) => map.contains_key(key),\n+        }\n+    }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n+        Entry { ssomap: self, key }\n+    }\n+}\n+\n+impl<K, V> Default for SsoHashMap<K, V> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> FromIterator<(K, V)> for SsoHashMap<K, V> {\n+    fn from_iter<I: IntoIterator<Item = (K, V)>>(iter: I) -> SsoHashMap<K, V> {\n+        let mut map: SsoHashMap<K, V> = Default::default();\n+        map.extend(iter);\n+        map\n+    }\n+}\n+\n+impl<K: Eq + Hash, V> Extend<(K, V)> for SsoHashMap<K, V> {\n+    fn extend<I>(&mut self, iter: I)\n+    where\n+        I: IntoIterator<Item = (K, V)>,\n+    {\n+        for (key, value) in iter.into_iter() {\n+            self.insert(key, value);\n+        }\n+    }\n+\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashMap::Array(array) => {\n+                if array.capacity() < (array.len() + additional) {\n+                    let mut map: FxHashMap<K, V> = array.drain(..).collect();\n+                    map.extend_reserve(additional);\n+                    *self = SsoHashMap::Map(map);\n+                }\n+            }\n+            SsoHashMap::Map(map) => map.extend_reserve(additional),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> Extend<(&'a K, &'a V)> for SsoHashMap<K, V>\n+where\n+    K: Eq + Hash + Copy,\n+    V: Copy,\n+{\n+    fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n+        self.extend(iter.into_iter().map(|(k, v)| (k.clone(), v.clone())))\n+    }\n+\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<(K, V)>::extend_reserve(self, additional)\n+    }\n+}\n+\n+impl<K, V> IntoIterator for SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        <ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+        <FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter()),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+/// adapts Item of array reference iterator to Item of hashmap reference iterator.\n+fn adapt_array_ref_it<K, V>(pair: &'a (K, V)) -> (&'a K, &'a V) {\n+    let (a, b) = pair;\n+    (a, b)\n+}\n+\n+/// adapts Item of array mut reference iterator to Item of hashmap mut reference iterator.\n+fn adapt_array_mut_it<K, V>(pair: &'a mut (K, V)) -> (&'a K, &'a mut V) {\n+    let (a, b) = pair;\n+    (a, b)\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        std::iter::Map<\n+            <&'a ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            fn(&'a (K, V)) -> (&'a K, &'a V),\n+        >,\n+        <&'a FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_ref_it)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> IntoIterator for &'a mut SsoHashMap<K, V> {\n+    type IntoIter = EitherIter<\n+        std::iter::Map<\n+            <&'a mut ArrayVec<[(K, V); 8]> as IntoIterator>::IntoIter,\n+            fn(&'a mut (K, V)) -> (&'a K, &'a mut V),\n+        >,\n+        <&'a mut FxHashMap<K, V> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashMap::Array(array) => EitherIter::Left(array.into_iter().map(adapt_array_mut_it)),\n+            SsoHashMap::Map(map) => EitherIter::Right(map.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<K, V> fmt::Debug for SsoHashMap<K, V>\n+where\n+    K: fmt::Debug,\n+    V: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_map().entries(self.iter()).finish()\n+    }\n+}\n+\n+impl<'a, K, Q: ?Sized, V> Index<&'a Q> for SsoHashMap<K, V>\n+where\n+    K: Eq + Hash + Borrow<Q>,\n+    Q: Eq + Hash,\n+{\n+    type Output = V;\n+\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+/// A view into a single entry in a map.\n+pub struct Entry<'a, K, V> {\n+    ssomap: &'a mut SsoHashMap<K, V>,\n+    key: K,\n+}\n+\n+impl<'a, K: Eq + Hash, V> Entry<'a, K, V> {\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    pub fn and_modify<F>(self, f: F) -> Self\n+    where\n+        F: FnOnce(&mut V),\n+    {\n+        if let Some(value) = self.ssomap.get_mut(&self.key) {\n+            f(value);\n+        }\n+        self\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    pub fn or_insert(self, value: V) -> &'a mut V {\n+        self.or_insert_with(|| value)\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        self.ssomap.migrate_if_full();\n+        match self.ssomap {\n+            SsoHashMap::Array(array) => {\n+                let key_ref = &self.key;\n+                let found_index = array.iter().position(|(k, _v)| k == key_ref);\n+                let index = if let Some(index) = found_index {\n+                    index\n+                } else {\n+                    array.try_push((self.key, default())).unwrap();\n+                    array.len() - 1\n+                };\n+                &mut array[index].1\n+            }\n+            SsoHashMap::Map(map) => map.entry(self.key).or_insert_with(default),\n+        }\n+    }\n+\n+    /// Returns a reference to this entry's key.\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+}\n+\n+impl<'a, K: Eq + Hash, V: Default> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    pub fn or_default(self) -> &'a mut V {\n+        self.or_insert_with(Default::default)\n+    }\n }"}, {"sha": "bcc4240721e614e3593f214de1cd0deede6c073c", "filename": "compiler/rustc_data_structures/src/sso/mod.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fmod.rs?ref=0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "patch": "@@ -1,3 +1,75 @@\n+use std::fmt;\n+use std::iter::ExactSizeIterator;\n+use std::iter::FusedIterator;\n+use std::iter::Iterator;\n+\n+/// Iterator which may contain instance of\n+/// one of two specific implementations.\n+///\n+/// Used by both SsoHashMap and SsoHashSet.\n+#[derive(Clone)]\n+pub enum EitherIter<L, R> {\n+    Left(L),\n+    Right(R),\n+}\n+\n+impl<L, R> Iterator for EitherIter<L, R>\n+where\n+    L: Iterator,\n+    R: Iterator<Item = L::Item>,\n+{\n+    type Item = L::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self {\n+            EitherIter::Left(l) => l.next(),\n+            EitherIter::Right(r) => r.next(),\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        match self {\n+            EitherIter::Left(l) => l.size_hint(),\n+            EitherIter::Right(r) => r.size_hint(),\n+        }\n+    }\n+}\n+\n+impl<L, R> ExactSizeIterator for EitherIter<L, R>\n+where\n+    L: ExactSizeIterator,\n+    R: ExactSizeIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+    fn len(&self) -> usize {\n+        match self {\n+            EitherIter::Left(l) => l.len(),\n+            EitherIter::Right(r) => r.len(),\n+        }\n+    }\n+}\n+\n+impl<L, R> FusedIterator for EitherIter<L, R>\n+where\n+    L: FusedIterator,\n+    R: FusedIterator,\n+    EitherIter<L, R>: Iterator,\n+{\n+}\n+\n+impl<L, R> fmt::Debug for EitherIter<L, R>\n+where\n+    L: fmt::Debug,\n+    R: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            EitherIter::Left(l) => l.fmt(f),\n+            EitherIter::Right(r) => r.fmt(f),\n+        }\n+    }\n+}\n+\n mod map;\n mod set;\n "}, {"sha": "6ec70524368d9cb6fe70060b243ea8007ac0a274", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "modified", "additions": 304, "deletions": 3, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0600b178aa0e9f310067bf8ccaf736e77a03eb1d/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=0600b178aa0e9f310067bf8ccaf736e77a03eb1d", "patch": "@@ -1,26 +1,197 @@\n+use super::EitherIter;\n use crate::fx::FxHashSet;\n use arrayvec::ArrayVec;\n+use std::borrow::Borrow;\n+use std::fmt;\n use std::hash::Hash;\n+use std::iter::FromIterator;\n+\n /// Small-storage-optimized implementation of a set.\n ///\n /// Stores elements in a small array up to a certain length\n /// and switches to `HashSet` when that length is exceeded.\n+///\n+/// Implements subset of HashSet API.\n+///\n+/// Missing HashSet API:\n+///   all hasher-related\n+///   try_reserve (unstable)\n+///   shrink_to (unstable)\n+///   drain_filter (unstable)\n+///   get_or_insert/get_or_insert_owned/get_or_insert_with (unstable)\n+///   difference/symmetric_difference/intersection/union\n+///   is_disjoint/is_subset/is_superset\n+///   PartialEq/Eq (requires sorting the array)\n+///   BitOr/BitAnd/BitXor/Sub\n+#[derive(Clone)]\n pub enum SsoHashSet<T> {\n     Array(ArrayVec<[T; 8]>),\n     Set(FxHashSet<T>),\n }\n \n-impl<T: Eq + Hash> SsoHashSet<T> {\n+impl<T> SsoHashSet<T> {\n     /// Creates an empty `SsoHashSet`.\n     pub fn new() -> Self {\n         SsoHashSet::Array(ArrayVec::new())\n     }\n \n+    /// Creates an empty `SsoHashSet` with the specified capacity.\n+    pub fn with_capacity(cap: usize) -> Self {\n+        let array = ArrayVec::new();\n+        if array.capacity() >= cap {\n+            SsoHashSet::Array(array)\n+        } else {\n+            SsoHashSet::Set(FxHashSet::with_capacity_and_hasher(cap, Default::default()))\n+        }\n+    }\n+\n+    /// Clears the set, removing all values.\n+    pub fn clear(&mut self) {\n+        match self {\n+            SsoHashSet::Array(array) => array.clear(),\n+            SsoHashSet::Set(set) => set.clear(),\n+        }\n+    }\n+\n+    /// Returns the number of elements the set can hold without reallocating.\n+    pub fn capacity(&self) -> usize {\n+        match self {\n+            SsoHashSet::Array(array) => array.capacity(),\n+            SsoHashSet::Set(set) => set.capacity(),\n+        }\n+    }\n+\n+    /// Returns the number of elements in the set.\n+    pub fn len(&self) -> usize {\n+        match self {\n+            SsoHashSet::Array(array) => array.len(),\n+            SsoHashSet::Set(set) => set.len(),\n+        }\n+    }\n+\n+    /// Returns `true` if the set contains no elements.\n+    pub fn is_empty(&self) -> bool {\n+        match self {\n+            SsoHashSet::Array(array) => array.is_empty(),\n+            SsoHashSet::Set(set) => set.is_empty(),\n+        }\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// The iterator element type is `&'a T`.\n+    pub fn iter(&'a self) -> impl Iterator<Item = &'a T> {\n+        self.into_iter()\n+    }\n+\n+    /// Clears the set, returning all elements in an iterator.\n+    pub fn drain(&mut self) -> impl Iterator<Item = T> + '_ {\n+        match self {\n+            SsoHashSet::Array(array) => EitherIter::Left(array.drain(..)),\n+            SsoHashSet::Set(set) => EitherIter::Right(set.drain()),\n+        }\n+    }\n+}\n+\n+impl<T: Eq + Hash> SsoHashSet<T> {\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `SsoHashSet`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    pub fn reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashSet::Array(array) => {\n+                if array.capacity() < (array.len() + additional) {\n+                    let mut set: FxHashSet<T> = array.drain(..).collect();\n+                    set.reserve(additional);\n+                    *self = SsoHashSet::Set(set);\n+                }\n+            }\n+            SsoHashSet::Set(set) => set.reserve(additional),\n+        }\n+    }\n+\n+    /// Shrinks the capacity of the set as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    pub fn shrink_to_fit(&mut self) {\n+        if let SsoHashSet::Set(set) = self {\n+            let mut array = ArrayVec::new();\n+            if set.len() <= array.capacity() {\n+                array.extend(set.drain());\n+                *self = SsoHashSet::Array(array);\n+            } else {\n+                set.shrink_to_fit();\n+            }\n+        }\n+    }\n+\n+    /// Retains only the elements specified by the predicate.\n+    pub fn retain<F>(&mut self, mut f: F)\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        match self {\n+            SsoHashSet::Array(array) => array.retain(|v| f(v)),\n+            SsoHashSet::Set(set) => set.retain(f),\n+        }\n+    }\n+\n+    /// Removes and returns the value in the set, if any, that is equal to the given one.\n+    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n+    where\n+        T: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashSet::Array(array) => {\n+                if let Some(index) = array.iter().position(|val| val.borrow() == value) {\n+                    Some(array.swap_remove(index))\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashSet::Set(set) => set.take(value),\n+        }\n+    }\n+\n+    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n+    /// one. Returns the replaced value.\n+    pub fn replace(&mut self, value: T) -> Option<T> {\n+        match self {\n+            SsoHashSet::Array(array) => {\n+                if let Some(index) = array.iter().position(|val| *val == value) {\n+                    let old_value = std::mem::replace(&mut array[index], value);\n+                    Some(old_value)\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashSet::Set(set) => set.replace(value),\n+        }\n+    }\n+\n+    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n+    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n+    where\n+        T: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashSet::Array(array) => {\n+                if let Some(index) = array.iter().position(|val| val.borrow() == value) {\n+                    Some(&array[index])\n+                } else {\n+                    None\n+                }\n+            }\n+            SsoHashSet::Set(set) => set.get(value),\n+        }\n+    }\n+\n     /// Adds a value to the set.\n     ///\n-    /// If the set did not have this value present, true is returned.\n+    /// If the set did not have this value present, `true` is returned.\n     ///\n-    /// If the set did have this value present, false is returned.\n+    /// If the set did have this value present, `false` is returned.\n     pub fn insert(&mut self, elem: T) -> bool {\n         match self {\n             SsoHashSet::Array(array) => {\n@@ -38,4 +209,134 @@ impl<T: Eq + Hash> SsoHashSet<T> {\n             SsoHashSet::Set(set) => set.insert(elem),\n         }\n     }\n+\n+    /// Removes a value from the set. Returns whether the value was\n+    /// present in the set.\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n+    where\n+        T: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashSet::Array(array) => {\n+                if let Some(index) = array.iter().position(|val| val.borrow() == value) {\n+                    array.swap_remove(index);\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+            SsoHashSet::Set(set) => set.remove(value),\n+        }\n+    }\n+\n+    /// Returns `true` if the set contains a value.\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n+    where\n+        T: Borrow<Q>,\n+        Q: Hash + Eq,\n+    {\n+        match self {\n+            SsoHashSet::Array(array) => array.iter().any(|v| v.borrow() == value),\n+            SsoHashSet::Set(set) => set.contains(value),\n+        }\n+    }\n+}\n+\n+impl<T> Default for SsoHashSet<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+impl<T: Eq + Hash> FromIterator<T> for SsoHashSet<T> {\n+    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> SsoHashSet<T> {\n+        let mut set: SsoHashSet<T> = Default::default();\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+impl<T: Eq + Hash> Extend<T> for SsoHashSet<T> {\n+    fn extend<I>(&mut self, iter: I)\n+    where\n+        I: IntoIterator<Item = T>,\n+    {\n+        for val in iter.into_iter() {\n+            self.insert(val);\n+        }\n+    }\n+\n+    fn extend_one(&mut self, item: T) {\n+        self.insert(item);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        match self {\n+            SsoHashSet::Array(array) => {\n+                if array.capacity() < (array.len() + additional) {\n+                    let mut set: FxHashSet<T> = array.drain(..).collect();\n+                    set.extend_reserve(additional);\n+                    *self = SsoHashSet::Set(set);\n+                }\n+            }\n+            SsoHashSet::Set(set) => set.extend_reserve(additional),\n+        }\n+    }\n+}\n+\n+impl<'a, T> Extend<&'a T> for SsoHashSet<T>\n+where\n+    T: 'a + Eq + Hash + Copy,\n+{\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n+        self.extend(iter.into_iter().cloned());\n+    }\n+\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.insert(item);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<T>::extend_reserve(self, additional)\n+    }\n+}\n+\n+impl<T> IntoIterator for SsoHashSet<T> {\n+    type IntoIter = EitherIter<\n+        <ArrayVec<[T; 8]> as IntoIterator>::IntoIter,\n+        <FxHashSet<T> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashSet::Array(array) => EitherIter::Left(array.into_iter()),\n+            SsoHashSet::Set(set) => EitherIter::Right(set.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<'a, T> IntoIterator for &'a SsoHashSet<T> {\n+    type IntoIter = EitherIter<\n+        <&'a ArrayVec<[T; 8]> as IntoIterator>::IntoIter,\n+        <&'a FxHashSet<T> as IntoIterator>::IntoIter,\n+    >;\n+    type Item = <Self::IntoIter as Iterator>::Item;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        match self {\n+            SsoHashSet::Array(array) => EitherIter::Left(array.into_iter()),\n+            SsoHashSet::Set(set) => EitherIter::Right(set.into_iter()),\n+        }\n+    }\n+}\n+\n+impl<T> fmt::Debug for SsoHashSet<T>\n+where\n+    T: fmt::Debug,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_set().entries(self.iter()).finish()\n+    }\n }"}]}