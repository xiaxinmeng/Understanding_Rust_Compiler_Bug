{"sha": "300d865fa4642f0a76b2676539efa3155ceaeddf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMGQ4NjVmYTQ2NDJmMGE3NmIyNjc2NTM5ZWZhMzE1NWNlYWVkZGY=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-07T03:14:54Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:08:00Z"}, "message": "Add a mechanism to convert from Vec<T> to ~[T]\n\nAdd a new trait FromVec with one self-less method from_vec(). This is\nkind of like FromIterator, but it consumes a Vec<T>. It's only\nimplemented for ~[T], but the idea is post-DST it can be implemented for\nany Boxed<[T]>.", "tree": {"sha": "77cec48f95a8981067477672f40a0d5d7ff1731c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77cec48f95a8981067477672f40a0d5d7ff1731c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/300d865fa4642f0a76b2676539efa3155ceaeddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/300d865fa4642f0a76b2676539efa3155ceaeddf", "html_url": "https://github.com/rust-lang/rust/commit/300d865fa4642f0a76b2676539efa3155ceaeddf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/300d865fa4642f0a76b2676539efa3155ceaeddf/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbbb847bf033003c89e105e337419649dae5384c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbbb847bf033003c89e105e337419649dae5384c", "html_url": "https://github.com/rust-lang/rust/commit/dbbb847bf033003c89e105e337419649dae5384c"}], "stats": {"total": 74, "additions": 73, "deletions": 1}, "files": [{"sha": "82ec1cbc56c064d8c4d103810cfe14c88a1bc17e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/300d865fa4642f0a76b2676539efa3155ceaeddf/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/300d865fa4642f0a76b2676539efa3155ceaeddf/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=300d865fa4642f0a76b2676539efa3155ceaeddf", "patch": "@@ -28,6 +28,7 @@ use ptr::RawPtr;\n use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n+use RawVec = raw::Vec;\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n use slice::{MutableVectorAllocating};\n@@ -1465,6 +1466,50 @@ pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (Vec<T>, Vec<U>) {\n     (ts, us)\n }\n \n+/// Mechanism to convert from a `Vec<T>` to a `[T]`.\n+///\n+/// In a post-DST world this will be used to convert to any `Ptr<[T]>`.\n+///\n+/// This could be implemented on more types than just pointers to vectors, but\n+/// the recommended approach for those types is to implement `FromIterator`.\n+// FIXME(#12938): Update doc comment when DST lands\n+pub trait FromVec<T> {\n+    /// Convert a `Vec<T>` into the receiver type.\n+    fn from_vec(v: Vec<T>) -> Self;\n+}\n+\n+impl<T> FromVec<T> for ~[T] {\n+    fn from_vec(mut v: Vec<T>) -> ~[T] {\n+        let len = v.len();\n+        let data_size = len.checked_mul(&mem::size_of::<T>());\n+        let data_size = data_size.expect(\"overflow in from_vec()\");\n+        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n+        let size = size.expect(\"overflow in from_vec()\");\n+\n+        // In a post-DST world, we can attempt to reuse the Vec allocation by calling\n+        // shrink_to_fit() on it. That may involve a reallocation+memcpy, but that's no\n+        // diffrent than what we're doing manually here.\n+\n+        let vp = v.as_mut_ptr();\n+\n+        unsafe {\n+            let ret = malloc_raw(size) as *mut RawVec<()>;\n+\n+            (*ret).fill = len * mem::nonzero_size_of::<T>();\n+            (*ret).alloc = len * mem::nonzero_size_of::<T>();\n+\n+            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n+                                            vp as *u8, data_size);\n+\n+            // we've transferred ownership of the contents from v, but we can't drop it\n+            // as it still needs to free its own allocation.\n+            v.set_len(0);\n+\n+            transmute(ret)\n+        }\n+    }\n+}\n+\n /// Unsafe operations\n pub mod raw {\n     use super::Vec;\n@@ -1488,7 +1533,8 @@ pub mod raw {\n mod tests {\n     use prelude::*;\n     use mem::size_of;\n-    use super::{unzip, raw};\n+    use kinds::marker;\n+    use super::{unzip, raw, FromVec};\n \n     #[test]\n     fn test_small_vec_struct() {\n@@ -1765,4 +1811,30 @@ mod tests {\n             assert_eq!(d, vec![1, 2, 3, 4, 5]);\n         }\n     }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let a = vec![1u, 2, 3];\n+        let b: ~[uint] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[1u, 2, 3]);\n+\n+        let a = vec![];\n+        let b: ~[u8] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[]);\n+\n+        let a = vec![\"one\".to_owned(), \"two\".to_owned()];\n+        let b: ~[~str] = FromVec::from_vec(a);\n+        assert_eq!(b.as_slice(), &[\"one\".to_owned(), \"two\".to_owned()]);\n+\n+        struct Foo {\n+            x: uint,\n+            nocopy: marker::NoCopy\n+        }\n+\n+        let a = vec![Foo{x: 42, nocopy: marker::NoCopy}, Foo{x: 84, nocopy: marker::NoCopy}];\n+        let b: ~[Foo] = FromVec::from_vec(a);\n+        assert_eq!(b.len(), 2);\n+        assert_eq!(b[0].x, 42);\n+        assert_eq!(b[1].x, 84);\n+    }\n }"}]}