{"sha": "532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMmM5NGQwZjEyY2IyYzU2ODcwYzI4Mzk0N2FhMTJjZTJjOWI5YjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-17T15:20:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-18T02:45:48Z"}, "message": "Propagate expected types through block expressions.\n\nr=graydon", "tree": {"sha": "b68ae8a8b5b5c39d197f5a52f45bd78fcd96d9ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b68ae8a8b5b5c39d197f5a52f45bd78fcd96d9ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "html_url": "https://github.com/rust-lang/rust/commit/532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fed56ed9035912a2657b07ab1b7671706bd9576", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fed56ed9035912a2657b07ab1b7671706bd9576", "html_url": "https://github.com/rust-lang/rust/commit/9fed56ed9035912a2657b07ab1b7671706bd9576"}], "stats": {"total": 190, "additions": 112, "deletions": 78}, "files": [{"sha": "2e82d531e155911b371039f97146e9ae34dada88", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "patch": "@@ -14,7 +14,7 @@ use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::pat_util::{pat_is_variant_or_struct};\n use middle::ty;\n use middle::typeck::check::demand;\n-use middle::typeck::check::{check_block, check_expr_with, fn_ctxt};\n+use middle::typeck::check::{check_block, check_expr_has_type, fn_ctxt};\n use middle::typeck::check::{instantiate_path, lookup_def, lookup_local};\n use middle::typeck::check::{structure_of, valid_range_bounds};\n use middle::typeck::require_same_types;\n@@ -35,7 +35,7 @@ fn check_match(fcx: @fn_ctxt,\n     let mut bot;\n \n     let pattern_ty = fcx.infcx().next_ty_var();\n-    bot = check_expr_with(fcx, discrim, pattern_ty);\n+    bot = check_expr_has_type(fcx, discrim, pattern_ty);\n \n     // Typecheck the patterns first, so that we get types for all the\n     // bindings.\n@@ -55,7 +55,7 @@ fn check_match(fcx: @fn_ctxt,\n     let mut arm_non_bot = false;\n     for arms.each |arm| {\n         match arm.guard {\n-          Some(e) => { check_expr_with(fcx, e, ty::mk_bool(tcx)); },\n+          Some(e) => { check_expr_has_type(fcx, e, ty::mk_bool(tcx)); },\n           None => ()\n         }\n         if !check_block(fcx, arm.body) { arm_non_bot = true; }\n@@ -334,12 +334,12 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fcx.write_ty(pat.id, expected);\n       }\n       ast::pat_lit(lt) => {\n-        check_expr_with(fcx, lt, expected);\n+        check_expr_has_type(fcx, lt, expected);\n         fcx.write_ty(pat.id, fcx.expr_ty(lt));\n       }\n       ast::pat_range(begin, end) => {\n-        check_expr_with(fcx, begin, expected);\n-        check_expr_with(fcx, end, expected);\n+        check_expr_has_type(fcx, begin, expected);\n+        check_expr_has_type(fcx, end, expected);\n         let b_ty =\n             fcx.infcx().resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty ="}, {"sha": "d151b0aee45ac0377c519211ce1edfcb4f066a57", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 94, "deletions": 72, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "patch": "@@ -147,7 +147,7 @@ export DontDerefArgs;\n export DoDerefArgs;\n export check_item_types;\n export check_block;\n-export check_expr_with;\n+export check_expr_has_type;\n export fn_ctxt;\n export lookup_def;\n export structure_of;\n@@ -971,27 +971,40 @@ fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n     const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n }\n \n-fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n-    check_expr(fcx, expr, Some(expected))\n+fn check_expr_has_type(\n+    fcx: @fn_ctxt, expr: @ast::expr,\n+    expected: ty::t) -> bool\n+{\n+    do check_expr_with_unifier(fcx, expr, Some(expected)) {\n+        demand::suptype(fcx, expr.span, expected, fcx.expr_ty(expr));\n+    }\n }\n \n-fn check_expr_with_assignability(fcx: @fn_ctxt,\n-                                 expr: @ast::expr,\n-                                 expected: ty::t)\n-                              -> bool {\n+fn check_expr_assignable_to_type(\n+    fcx: @fn_ctxt, expr: @ast::expr,\n+    expected: ty::t) -> bool\n+{\n     do check_expr_with_unifier(fcx, expr, Some(expected)) {\n         demand::assign(fcx, expr.span, expected, expr)\n     }\n }\n \n+fn check_expr_with_hint(\n+    fcx: @fn_ctxt, expr: @ast::expr,\n+    expected: ty::t) -> bool\n+{\n+    check_expr_with_unifier(fcx, expr, Some(expected), || ())\n+}\n \n-fn check_expr(fcx: @fn_ctxt, expr: @ast::expr,\n-              expected: Option<ty::t>) -> bool {\n-    return do check_expr_with_unifier(fcx, expr, expected) {\n-        for expected.each |t| {\n-            demand::suptype(fcx, expr.span, *t, fcx.expr_ty(expr));\n-        }\n-    };\n+fn check_expr_with_opt_hint(\n+    fcx: @fn_ctxt, expr: @ast::expr,\n+    expected: Option<ty::t>) -> bool\n+{\n+    check_expr_with_unifier(fcx, expr, expected, || ())\n+}\n+\n+fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n+    check_expr_with_unifier(fcx, expr, None, || ())\n }\n \n // determine the `self` type, using fresh variables for all variables\n@@ -1083,8 +1096,8 @@ fn break_here() {\n fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expr: @ast::expr,\n                            expected: Option<ty::t>,\n-                           unifier: fn()) -> bool {\n-\n+                           unifier: fn()) -> bool\n+{\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n     // A generic function to factor out common logic from call and\n@@ -1206,8 +1219,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     }\n \n                     // mismatch error happens in here\n-                    bot |= check_expr_with_assignability(fcx,\n-                                                         *arg, formal_ty);\n+                    bot |= check_expr_assignable_to_type(\n+                        fcx, *arg, formal_ty);\n \n                 }\n             }\n@@ -1222,9 +1235,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         rhs: @ast::expr,\n                         id: ast::node_id)\n                      -> bool {\n-        let mut bot = check_expr(fcx, lhs, None);\n+        let mut bot = check_expr(fcx, lhs);\n         let lhs_type = fcx.expr_ty(lhs);\n-        bot |= check_expr_with_assignability(fcx, rhs, lhs_type);\n+        bot |= check_expr_assignable_to_type(fcx, rhs, lhs_type);\n         fcx.write_ty(id, ty::mk_nil(fcx.ccx.tcx));\n         return bot;\n     }\n@@ -1273,7 +1286,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             ast::expr_field(base, field, tys) => {\n                 check_field(fcx, f, true, base, field, tys)\n             }\n-            _ => check_expr(fcx, f, None)\n+            _ => check_expr(fcx, f)\n         };\n \n         check_call_or_method(fcx,\n@@ -1293,7 +1306,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                          +args: ~[@ast::expr],\n                          tps: ~[@ast::Ty])\n                       -> bool {\n-        let bot = check_expr(fcx, rcvr, None);\n+        let bot = check_expr(fcx, rcvr);\n         let expr_t = structurally_resolved_type(fcx,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n@@ -1362,7 +1375,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     let thn_bot = check_block(fcx, thn);\n                     let thn_t = fcx.node_ty(thn.node.id);\n                     demand::suptype(fcx, thn.span, if_t, thn_t);\n-                    let els_bot = check_expr_with(fcx, els, if_t);\n+                    let els_bot = check_expr_has_type(fcx, els, if_t);\n                     (if_t, thn_bot & els_bot)\n                 }\n                 None => {\n@@ -1403,13 +1416,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                    rhs: @ast::expr) -> bool {\n         let tcx = fcx.ccx.tcx;\n \n-        let lhs_bot = check_expr(fcx, lhs, None);\n+        let lhs_bot = check_expr(fcx, lhs);\n         let lhs_t = fcx.expr_ty(lhs);\n         let lhs_t = structurally_resolved_type(fcx, lhs.span, lhs_t);\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n             // Shift is a special case: rhs can be any integral type\n-            let rhs_bot = check_expr(fcx, rhs, None);\n+            let rhs_bot = check_expr(fcx, rhs);\n             let rhs_t = fcx.expr_ty(rhs);\n             require_integral(fcx, rhs.span, rhs_t);\n             fcx.write_ty(expr.id, lhs_t);\n@@ -1419,7 +1432,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         if ty::is_binopable(tcx, lhs_t, op) {\n             let tvar = fcx.infcx().next_ty_var();\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n-            let rhs_bot = check_expr_with(fcx, rhs, tvar);\n+            let rhs_bot = check_expr_has_type(fcx, rhs, tvar);\n \n             let result_t = match op {\n                 ast::eq | ast::ne | ast::lt | ast::le | ast::ge |\n@@ -1467,7 +1480,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n           _ => ()\n         }\n-        check_expr(fcx, rhs, None);\n+        check_expr(fcx, rhs);\n         fcx.type_error_message(ex.span,\n            |actual| {\n                fmt!(\"binary operation %s cannot be applied to type `%s`\",\n@@ -1602,7 +1615,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         -> bool\n     {\n         let tcx = fcx.ccx.tcx;\n-        let bot = check_expr(fcx, base, None);\n+        let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         let (base_t, derefs) = do_autoderef(fcx, expr.span, expr_t);\n@@ -1718,7 +1731,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                         ty::lookup_field_type(\n                             tcx, class_id, field_id, substitutions);\n                     bot |=\n-                        check_expr_with_assignability(\n+                        check_expr_assignable_to_type(\n                             fcx,\n                             field.node.expr,\n                             expected_field_type);\n@@ -1831,7 +1844,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match base_expr {\n             None => {}\n             Some(base_expr) => {\n-                bot = check_expr(fcx, base_expr, Some(struct_type)) || bot\n+                bot = check_expr_has_type(fcx, base_expr, struct_type) || bot\n             }\n         }\n \n@@ -1935,15 +1948,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 _ => mutability = mutbl\n             }\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n+            for args.each |e| { bot |= check_expr_has_type(fcx, *e, t); }\n             ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n           }\n           ast::expr_repeat(element, count_expr, mutbl) => {\n             let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n             fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, count, vst);\n             let t: ty::t = fcx.infcx().next_ty_var();\n-            bot |= check_expr_with(fcx, element, t);\n+            bot |= check_expr_has_type(fcx, element, t);\n             ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl}, tt)\n           }\n           _ =>\n@@ -1982,7 +1995,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               ast::deref => None\n             }\n         };\n-        bot = check_expr(fcx, oprnd, exp_inner);\n+        bot = check_expr_with_opt_hint(fcx, oprnd, exp_inner);\n         let mut oprnd_t = fcx.expr_ty(oprnd);\n         match unop {\n           ast::box(mutbl) => {\n@@ -2055,9 +2068,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, oprnd_t);\n       }\n       ast::expr_addr_of(mutbl, oprnd) => {\n-        bot = check_expr(fcx, oprnd, unpack_expected(fcx, expected, |sty|\n-            match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty), _ => None }\n-        ));\n+          let hint = unpack_expected(\n+              fcx, expected,\n+              |sty| match *sty { ty::ty_rptr(_, ref mt) => Some(mt.ty),\n+                                 _ => None });\n+        bot = check_expr_with_opt_hint(fcx, oprnd, hint);\n \n         // Note: at this point, we cannot say what the best lifetime\n         // is to use for resulting pointer.  We want to use the\n@@ -2092,8 +2107,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match expr_opt {\n           None => {/* do nothing */ }\n           Some(e) => {\n-            check_expr_with(fcx, e,\n-                            ty::mk_estr(tcx, ty::vstore_uniq));\n+            check_expr_has_type(\n+                fcx, e, ty::mk_estr(tcx, ty::vstore_uniq));\n           }\n         }\n         fcx.write_bot(id);\n@@ -2115,31 +2130,31 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     ~\"`return;` in function returning non-nil\");\n             }\n           },\n-          Some(e) => { check_expr_with(fcx, e, ret_ty); }\n+          Some(e) => {\n+              check_expr_has_type(fcx, e, ret_ty);\n+          }\n         }\n         fcx.write_bot(id);\n       }\n       ast::expr_log(_, lv, e) => {\n-        bot = check_expr_with(fcx, lv, ty::mk_mach_uint(tcx, ast::ty_u32));\n+        bot = check_expr_has_type(fcx, lv,\n+                                  ty::mk_mach_uint(tcx, ast::ty_u32));\n+\n         // Note: this does not always execute, so do not propagate bot:\n-        check_expr(fcx, e, None);\n+        check_expr(fcx, e);\n         fcx.write_nil(id);\n       }\n       ast::expr_assert(e) => {\n-        bot = check_expr_with(fcx, e, ty::mk_bool(tcx));\n+        bot = check_expr_has_type(fcx, e, ty::mk_bool(tcx));\n         fcx.write_nil(id);\n       }\n       ast::expr_copy(a) | ast::expr_unary_move(a) => {\n-        bot = check_expr(fcx, a, expected);\n+        bot = check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n       }\n       ast::expr_paren(a) => {\n-        bot = check_expr_with_unifier(fcx, a, expected, || ());\n+        bot = check_expr_with_opt_hint(fcx, a, expected);\n         fcx.write_ty(id, fcx.expr_ty(a));\n-        do expected.iter |i| {\n-            demand::assign(fcx, expr.span, *i, expr);\n-            demand::assign(fcx, a.span, *i, a);\n-        };\n       }\n       ast::expr_assign(lhs, rhs) => {\n         bot = check_assignment(fcx, lhs, rhs, id);\n@@ -2148,11 +2163,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_assignment(fcx, lhs, rhs, id);\n       }\n       ast::expr_if(cond, ref thn, elsopt) => {\n-        bot = check_expr_with(fcx, cond, ty::mk_bool(tcx)) |\n-            check_then_else(fcx, (*thn), elsopt, id, expr.span);\n+        bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n+        bot |= check_then_else(fcx, *thn, elsopt, id, expr.span);\n       }\n       ast::expr_while(cond, ref body) => {\n-        bot = check_expr_with(fcx, cond, ty::mk_bool(tcx));\n+        bot = check_expr_has_type(fcx, cond, ty::mk_bool(tcx));\n         check_block_no_value(fcx, (*body));\n         fcx.write_ty(id, ty::mk_nil(tcx));\n       }\n@@ -2279,9 +2294,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_block(ref b) => {\n         // If this is an unchecked block, turn off purity-checking\n-        bot = check_block(fcx, (*b));\n+        bot = check_block_with_expected(fcx, *b, expected);\n         let typ =\n-            match (*b).node.expr {\n+            match b.node.expr {\n               Some(expr) => fcx.expr_ty(expr),\n               None => ty::mk_nil(tcx)\n             };\n@@ -2294,7 +2309,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_method_call(fcx, expr, rcvr, ident, args, tps);\n       }\n       ast::expr_cast(e, t) => {\n-        bot = check_expr(fcx, e, None);\n+        bot = check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n@@ -2338,7 +2353,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_vec(args, mutbl) => {\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        for args.each |e| { bot |= check_expr_with(fcx, *e, t); }\n+        for args.each |e| { bot |= check_expr_has_type(fcx, *e, t); }\n         let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                               ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n@@ -2347,7 +2362,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let count = ty::eval_repeat_count(tcx, count_expr, expr.span);\n         fcx.write_ty(count_expr.id, ty::mk_uint(tcx));\n         let t: ty::t = fcx.infcx().next_ty_var();\n-        bot |= check_expr_with(fcx, element, t);\n+        bot |= check_expr_has_type(fcx, element, t);\n         let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n                             ty::vstore_fixed(count));\n         fcx.write_ty(id, t);\n@@ -2357,27 +2372,28 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             match *sty { ty::ty_tup(ref flds) => Some(copy *flds), _ => None }\n         });\n         let elt_ts = do elts.mapi |i, e| {\n-            check_expr(fcx, *e, flds.map(|fs| fs[i]));\n+            check_expr_with_opt_hint(fcx, *e, flds.map(|fs| fs[i]));\n             fcx.expr_ty(*e)\n         };\n         let typ = ty::mk_tup(tcx, elt_ts);\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_rec(ref fields, base) => {\n-        option::iter(&base, |b| { check_expr(fcx, *b, expected); });\n-        let expected = if expected.is_none() && base.is_some() {\n-            Some(fcx.expr_ty(base.get()))\n-        } else { expected };\n+        for base.each |b| { check_expr_with_opt_hint(fcx, *b, expected); }\n+        let expected = option::or(expected,\n+                                  base.map(|b| fcx.expr_ty(*b)));\n         let flds = unpack_expected(fcx, expected, |sty|\n             match *sty {\n                 ty::ty_rec(ref flds) => Some(copy *flds),\n                 _ => None\n             }\n         );\n-        let fields_t = vec::map((*fields), |f| {\n-            bot |= check_expr(fcx, f.node.expr, flds.chain_ref(|flds|\n-                vec::find(*flds, |tf| tf.ident == f.node.ident)\n-            ).map(|tf| tf.mt.ty));\n+        let fields_t = fields.map(|f| {\n+            let hint_mt =\n+                flds.chain_ref(\n+                    |flds| vec::find(*flds, |tf| tf.ident == f.node.ident));\n+            let hint = hint_mt.map(|tf| tf.mt.ty);\n+            bot |= check_expr_with_opt_hint(fcx, f.node.expr, hint);\n             let expr_t = fcx.expr_ty(f.node.expr);\n             let expr_mt = ty::mt {ty: expr_t, mutbl: f.node.mutbl};\n             // for the most precise error message,\n@@ -2450,10 +2466,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         bot = check_field(fcx, expr, false, base, field, tys);\n       }\n       ast::expr_index(base, idx) => {\n-          bot |= check_expr(fcx, base, None);\n+          bot |= check_expr(fcx, base);\n           let raw_base_t = fcx.expr_ty(base);\n           let (base_t, derefs) = do_autoderef(fcx, expr.span, raw_base_t);\n-          bot |= check_expr(fcx, idx, None);\n+          bot |= check_expr(fcx, idx);\n           let idx_t = fcx.expr_ty(idx);\n           let base_sty = structure_of(fcx, expr.span, base_t);\n           match ty::index_sty(tcx, &base_sty) {\n@@ -2510,7 +2526,7 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n                           init: @ast::expr) -> bool {\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.span, nid));\n-    return check_expr_with_assignability(fcx, init, lty);\n+    return check_expr_assignable_to_type(fcx, init, lty);\n }\n \n fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n@@ -2554,11 +2570,11 @@ fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n       }\n       ast::stmt_expr(expr, id) => {\n         node_id = id;\n-        bot = check_expr_with(fcx, expr, ty::mk_nil(fcx.ccx.tcx));\n+        bot = check_expr_has_type(fcx, expr, ty::mk_nil(fcx.ccx.tcx));\n       }\n       ast::stmt_semi(expr, id) => {\n         node_id = id;\n-        bot = check_expr(fcx, expr, None);\n+        bot = check_expr(fcx, expr);\n       }\n       ast::stmt_mac(*) => fcx.ccx.tcx.sess.bug(~\"unexpanded macro\")\n     }\n@@ -2577,6 +2593,12 @@ fn check_block_no_value(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n }\n \n fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n+    check_block_with_expected(fcx0, blk, None)\n+}\n+\n+fn check_block_with_expected(fcx0: @fn_ctxt,\n+                             blk: ast::blk,\n+                             expected: Option<ty::t>) -> bool {\n     let fcx = match blk.node.rules {\n       ast::unsafe_blk => @fn_ctxt {purity: ast::unsafe_fn,.. copy *fcx0},\n       ast::default_blk => fcx0\n@@ -2605,7 +2627,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n             if bot && !warned {\n                 fcx.ccx.tcx.sess.span_warn(e.span, ~\"unreachable expression\");\n             }\n-            bot |= check_expr(fcx, e, None);\n+            bot |= check_expr_with_opt_hint(fcx, e, expected);\n             let ety = fcx.expr_ty(e);\n             fcx.write_ty(blk.node.id, ety);\n           }\n@@ -2626,7 +2648,7 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n \n fn check_const_with_ty(fcx: @fn_ctxt, _sp: span, e: @ast::expr,\n                        declty: ty::t) {\n-    check_expr(fcx, e, None);\n+    check_expr(fcx, e);\n     let cty = fcx.expr_ty(e);\n     demand::suptype(fcx, e.span, declty, cty);\n     regionck::regionck_expr(fcx, e);"}, {"sha": "3c40d2e36c1c329f23ac62ad725ffe0c62df7729", "filename": "src/test/run-pass/propagate-expected-type-through-block.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/src%2Ftest%2Frun-pass%2Fpropagate-expected-type-through-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532c94d0f12cb2c56870c283947aa12ce2c9b9b6/src%2Ftest%2Frun-pass%2Fpropagate-expected-type-through-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpropagate-expected-type-through-block.rs?ref=532c94d0f12cb2c56870c283947aa12ce2c9b9b6", "patch": "@@ -0,0 +1,12 @@\n+// Test that expected type propagates through `{}` expressions.  If it\n+// did not, then the type of `x` would not be known and a compilation\n+// error would result.\n+\n+fn main() {\n+    let y = ~3;\n+    let foo: @fn(&int) -> int = {\n+        let y = copy y;\n+        |x| *x + *y\n+    };\n+    assert foo(@22) == 25;\n+}\n\\ No newline at end of file"}]}