{"sha": "e8df0b893235aa06c6362d1a8646296310f79f81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZGYwYjg5MzIzNWFhMDZjNjM2MmQxYTg2NDYyOTYzMTBmNzlmODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-17T14:13:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-17T14:13:13Z"}, "message": "Auto merge of #74940 - oli-obk:const_is_null, r=RalfJung\n\nMake `<*const T>::is_null` const fn\n\nr? @RalfJung\n\ncc @rust-lang/wg-const-eval\n\ntracking issue: #74939", "tree": {"sha": "64332bc6a0612f1db05ba4daafcf4372a47e1120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64332bc6a0612f1db05ba4daafcf4372a47e1120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8df0b893235aa06c6362d1a8646296310f79f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8df0b893235aa06c6362d1a8646296310f79f81", "html_url": "https://github.com/rust-lang/rust/commit/e8df0b893235aa06c6362d1a8646296310f79f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8df0b893235aa06c6362d1a8646296310f79f81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cdc94e84040ce797fd33d0a7cfda4ec4f2f2421", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cdc94e84040ce797fd33d0a7cfda4ec4f2f2421", "html_url": "https://github.com/rust-lang/rust/commit/8cdc94e84040ce797fd33d0a7cfda4ec4f2f2421"}, {"sha": "daf7a375105b55de7a808aa096194280249f0fc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf7a375105b55de7a808aa096194280249f0fc5", "html_url": "https://github.com/rust-lang/rust/commit/daf7a375105b55de7a808aa096194280249f0fc5"}], "stats": {"total": 211, "additions": 204, "deletions": 7}, "files": [{"sha": "9e8b0b414108e2bd117b3369e5602ec5cdb881d8", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8df0b893235aa06c6362d1a8646296310f79f81/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8df0b893235aa06c6362d1a8646296310f79f81/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=e8df0b893235aa06c6362d1a8646296310f79f81", "patch": "@@ -13,6 +13,15 @@ impl<T: ?Sized> *const T {\n     /// Therefore, two pointers that are null may still not compare equal to\n     /// each other.\n     ///\n+    /// ## Behavior during const evaluation\n+    ///\n+    /// When this function is used during const evaluation, it may return `false` for pointers\n+    /// that turn out to be null at runtime. Specifically, when a pointer to some memory\n+    /// is offset beyond its bounds in such a way that the resulting pointer is null,\n+    /// the function will still return `false`. There is no way for CTFE to know\n+    /// the absolute position of that memory, so we cannot tell if the pointer is\n+    /// null or not.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -23,11 +32,12 @@ impl<T: ?Sized> *const T {\n     /// assert!(!ptr.is_null());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n     #[inline]\n-    pub fn is_null(self) -> bool {\n+    pub const fn is_null(self) -> bool {\n         // Compare via a cast to a thin pointer, so fat pointers are only\n         // considering their \"data\" part for null-ness.\n-        (self as *const u8) == null()\n+        (self as *const u8).guaranteed_eq(null())\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "811e58875d5bb3033333f2e8b2de65811698da32", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8df0b893235aa06c6362d1a8646296310f79f81/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8df0b893235aa06c6362d1a8646296310f79f81/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=e8df0b893235aa06c6362d1a8646296310f79f81", "patch": "@@ -12,6 +12,15 @@ impl<T: ?Sized> *mut T {\n     /// Therefore, two pointers that are null may still not compare equal to\n     /// each other.\n     ///\n+    /// ## Behavior during const evaluation\n+    ///\n+    /// When this function is used during const evaluation, it may return `false` for pointers\n+    /// that turn out to be null at runtime. Specifically, when a pointer to some memory\n+    /// is offset beyond its bounds in such a way that the resulting pointer is null,\n+    /// the function will still return `false`. There is no way for CTFE to know\n+    /// the absolute position of that memory, so we cannot tell if the pointer is\n+    /// null or not.\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -22,11 +31,12 @@ impl<T: ?Sized> *mut T {\n     /// assert!(!ptr.is_null());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_is_null\", issue = \"74939\")]\n     #[inline]\n-    pub fn is_null(self) -> bool {\n+    pub const fn is_null(self) -> bool {\n         // Compare via a cast to a thin pointer, so fat pointers are only\n         // considering their \"data\" part for null-ness.\n-        (self as *mut u8) == null_mut()\n+        (self as *mut u8).guaranteed_eq(null_mut())\n     }\n \n     /// Casts to a pointer of another type."}, {"sha": "2c0a42a9bf32629ee423ffd61d5c69b0221d5d32", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=e8df0b893235aa06c6362d1a8646296310f79f81", "patch": "@@ -329,9 +329,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                // FIXME: return `true` for at least some comparisons where we can reliably\n-                // determine the result of runtime (in)equality tests at compile-time.\n-                self.write_scalar(Scalar::from_bool(false), dest)?;\n+                let a = self.read_immediate(args[0])?.to_scalar()?;\n+                let b = self.read_immediate(args[1])?.to_scalar()?;\n+                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n+                    self.guaranteed_eq(a, b)\n+                } else {\n+                    self.guaranteed_ne(a, b)\n+                };\n+                self.write_scalar(Scalar::from_bool(cmp), dest)?;\n             }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n@@ -448,6 +453,37 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(true)\n     }\n \n+    fn guaranteed_eq(&mut self, a: Scalar<M::PointerTag>, b: Scalar<M::PointerTag>) -> bool {\n+        match (a, b) {\n+            // Comparisons between integers are always known.\n+            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a == b,\n+            // Equality with integers can never be known for sure.\n+            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            // FIXME: return `true` for when both sides are the same pointer, *except* that\n+            // some things (like functions and vtables) do not have stable addresses\n+            // so we need to be careful around them.\n+            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+        }\n+    }\n+\n+    fn guaranteed_ne(&mut self, a: Scalar<M::PointerTag>, b: Scalar<M::PointerTag>) -> bool {\n+        match (a, b) {\n+            // Comparisons between integers are always known.\n+            (Scalar::Raw { .. }, Scalar::Raw { .. }) => a != b,\n+            // Comparisons of abstract pointers with null pointers are known if the pointer\n+            // is in bounds, because if they are in bounds, the pointer can't be null.\n+            (Scalar::Raw { data: 0, .. }, Scalar::Ptr(ptr))\n+            | (Scalar::Ptr(ptr), Scalar::Raw { data: 0, .. }) => !self.memory.ptr_may_be_null(ptr),\n+            // Inequality with integers other than null can never be known for sure.\n+            (Scalar::Raw { .. }, Scalar::Ptr(_)) | (Scalar::Ptr(_), Scalar::Raw { .. }) => false,\n+            // FIXME: return `true` for at least some comparisons where we can reliably\n+            // determine the result of runtime inequality tests at compile-time.\n+            // Examples include comparison of addresses in static items, for these we can\n+            // give reliable results.\n+            (Scalar::Ptr(_), Scalar::Ptr(_)) => false,\n+        }\n+    }\n+\n     pub fn exact_div(\n         &mut self,\n         a: ImmTy<'tcx, M::PointerTag>,"}, {"sha": "be998c800381d629d304464b38f0964bd1c97a3f", "filename": "src/test/ui/consts/ptr_comparisons.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs?ref=e8df0b893235aa06c6362d1a8646296310f79f81", "patch": "@@ -0,0 +1,78 @@\n+// compile-flags: --crate-type=lib\n+// normalize-stderr-32bit: \"offset 8\" -> \"offset $$TWO_WORDS\"\n+// normalize-stderr-64bit: \"offset 16\" -> \"offset $$TWO_WORDS\"\n+// normalize-stderr-32bit: \"size 4\" -> \"size $$WORD\"\n+// normalize-stderr-64bit: \"size 8\" -> \"size $$WORD\"\n+\n+#![feature(\n+    const_panic,\n+    core_intrinsics,\n+    const_raw_ptr_comparison,\n+    const_ptr_offset,\n+    const_raw_ptr_deref,\n+    raw_ref_macros\n+)]\n+\n+const FOO: &usize = &42;\n+\n+macro_rules! check {\n+    (eq, $a:expr, $b:expr) => {\n+        pub const _: () =\n+            assert!(std::intrinsics::ptr_guaranteed_eq($a as *const u8, $b as *const u8));\n+    };\n+    (ne, $a:expr, $b:expr) => {\n+        pub const _: () =\n+            assert!(std::intrinsics::ptr_guaranteed_ne($a as *const u8, $b as *const u8));\n+    };\n+    (!eq, $a:expr, $b:expr) => {\n+        pub const _: () =\n+            assert!(!std::intrinsics::ptr_guaranteed_eq($a as *const u8, $b as *const u8));\n+    };\n+    (!ne, $a:expr, $b:expr) => {\n+        pub const _: () =\n+            assert!(!std::intrinsics::ptr_guaranteed_ne($a as *const u8, $b as *const u8));\n+    };\n+}\n+\n+check!(eq, 0, 0);\n+check!(ne, 0, 1);\n+check!(!eq, 0, 1);\n+check!(!ne, 0, 0);\n+check!(ne, FOO as *const _, 0);\n+check!(!eq, FOO as *const _, 0);\n+// We want pointers to be equal to themselves, but aren't checking this yet because\n+// there are some open questions (e.g. whether function pointers to the same function\n+// compare equal, they don't necessarily at runtime).\n+// The case tested here should work eventually, but does not work yet.\n+check!(!eq, FOO as *const _, FOO as *const _);\n+check!(ne, unsafe { (FOO as *const usize).offset(1) }, 0);\n+check!(!eq, unsafe { (FOO as *const usize).offset(1) }, 0);\n+\n+check!(ne, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n+check!(!eq, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// If any of the below start compiling, make sure to add a `check` test for it.\n+// These invocations exist as canaries so we don't forget to check that the\n+// behaviour of `guaranteed_eq` and `guaranteed_ne` is still correct.\n+// All of these try to obtain an out of bounds pointer in some manner. If we\n+// can create out of bounds pointers, we can offset a pointer far enough that\n+// at runtime it would be zero and at compile-time it would not be zero.\n+\n+const _: *const usize = unsafe { (FOO as *const usize).offset(2) };\n+//~^ NOTE\n+\n+const _: *const u8 =\n+//~^ NOTE\n+    unsafe { std::ptr::raw_const!((*(FOO as *const usize as *const [u8; 1000]))[999]) };\n+//~^ ERROR any use of this value will cause an error\n+\n+const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n+//~^ ERROR any use of this value will cause an error\n+//~| NOTE \"pointer-to-integer cast\" needs an rfc\n+//~| NOTE\n+\n+const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n+//~^ ERROR any use of this value will cause an error\n+//~| NOTE \"pointer-to-integer cast\" needs an rfc\n+//~| NOTE"}, {"sha": "493d9be8f71b7077f9ddb4be345d143531fdfe2c", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=e8df0b893235aa06c6362d1a8646296310f79f81", "patch": "@@ -0,0 +1,47 @@\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  inbounds test failed: pointer must be in-bounds at offset $TWO_WORDS, but is outside bounds of alloc2 which has size $WORD\n+   |                  inside `std::ptr::const_ptr::<impl *const usize>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |                  inside `_` at $DIR/ptr_comparisons.rs:62:34\n+   | \n+  ::: $DIR/ptr_comparisons.rs:62:1\n+   |\n+LL | const _: *const usize = unsafe { (FOO as *const usize).offset(2) };\n+   | -------------------------------------------------------------------\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $DIR/ptr_comparisons.rs:67:14\n+   |\n+LL | / const _: *const u8 =\n+LL | |\n+LL | |     unsafe { std::ptr::raw_const!((*(FOO as *const usize as *const [u8; 1000]))[999]) };\n+   | |______________^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^__-\n+   |                |\n+   |                memory access failed: pointer must be in-bounds at offset 1000, but is outside bounds of alloc2 which has size $WORD\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: any use of this value will cause an error\n+  --> $DIR/ptr_comparisons.rs:70:27\n+   |\n+LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n+   | --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                           |\n+   |                           \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n+\n+error: any use of this value will cause an error\n+  --> $DIR/ptr_comparisons.rs:75:27\n+   |\n+LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n+   | --------------------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---\n+   |                           |\n+   |                           \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "324f59443f721f46647ca41f54f070b10eafb3b0", "filename": "src/test/ui/consts/ptr_is_null.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Ftest%2Fui%2Fconsts%2Fptr_is_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8df0b893235aa06c6362d1a8646296310f79f81/src%2Ftest%2Fui%2Fconsts%2Fptr_is_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_is_null.rs?ref=e8df0b893235aa06c6362d1a8646296310f79f81", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: --crate-type=lib\n+// check-pass\n+\n+#![feature(const_ptr_is_null, const_panic)]\n+\n+const FOO: &usize = &42;\n+\n+pub const _: () = assert!(!(FOO as *const usize).is_null());\n+\n+pub const _: () = assert!(!(42 as *const usize).is_null());\n+\n+pub const _: () = assert!((0 as *const usize).is_null());\n+\n+pub const _: () = assert!(std::ptr::null::<usize>().is_null());\n+\n+pub const _: () = assert!(!(\"foo\" as *const str).is_null());"}]}