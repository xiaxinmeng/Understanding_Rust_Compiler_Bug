{"sha": "e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "node_id": "C_kwDOAAsO6NoAKGUwZjhlNjBkZGRmZWNmYzkwOTNlZTlkOWY0MjU1N2Q4MjYwYzAzNTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-18T07:46:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-18T07:46:49Z"}, "message": "Auto merge of #103177 - lnicola:rust-analyzer-2022-10-18, r=lnicola\n\n:arrow_up: rust-analyzer\n\nr? `@ghost`", "tree": {"sha": "74b83dfff50543205c322fe783fd9f283bd994e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74b83dfff50543205c322fe783fd9f283bd994e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "html_url": "https://github.com/rust-lang/rust/commit/e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a03ca01f4750e643a28731563e530917d314f729", "url": "https://api.github.com/repos/rust-lang/rust/commits/a03ca01f4750e643a28731563e530917d314f729", "html_url": "https://github.com/rust-lang/rust/commit/a03ca01f4750e643a28731563e530917d314f729"}, {"sha": "cb8fdff56da1b72ab942e41dc213059d83b58456", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb8fdff56da1b72ab942e41dc213059d83b58456", "html_url": "https://github.com/rust-lang/rust/commit/cb8fdff56da1b72ab942e41dc213059d83b58456"}], "stats": {"total": 4758, "additions": 3127, "deletions": 1631}, "files": [{"sha": "bb77324378a40ae6a7844503553661a3e22a8d93", "filename": "src/tools/rust-analyzer/.github/workflows/ci.yaml", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -43,14 +43,31 @@ jobs:\n           rustup component add rustfmt rust-src\n \n       - name: Cache Dependencies\n-        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+        uses: Swatinem/rust-cache@76686c56f2b581d1bb5bda44b51f7e24bd9b8b8e\n \n-      - name: Compile\n+      - name: Bump opt-level\n+        if: matrix.os == 'ubuntu-latest'\n+        run: sed -i '/\\[profile.dev]/a opt-level=1' Cargo.toml\n+\n+      - name: Compile (tests)\n         run: cargo test --no-run --locked\n \n+      # It's faster to `test` before `build` \u00af\\_(\u30c4)_/\u00af\n+      - name: Compile (rust-analyzer)\n+        if: matrix.os == 'ubuntu-latest'\n+        run: cargo build --quiet\n+\n       - name: Test\n         run: cargo test -- --nocapture --quiet\n \n+      - name: Run analysis-stats on rust-analyzer\n+        if: matrix.os == 'ubuntu-latest'\n+        run: target/${{ matrix.target }}/debug/rust-analyzer analysis-stats .\n+\n+      - name: Run analysis-stats on rust std library\n+        if: matrix.os == 'ubuntu-latest'\n+        run: target/${{ matrix.target }}/debug/rust-analyzer analysis-stats --with-deps $(rustc --print sysroot)/lib/rustlib/src/rust/library/std\n+\n   # Weird targets to catch non-portable code\n   rust-cross:\n     if: github.repository == 'rust-lang/rust-analyzer'\n@@ -73,7 +90,7 @@ jobs:\n           rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n \n       - name: Cache Dependencies\n-        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+        uses: Swatinem/rust-cache@76686c56f2b581d1bb5bda44b51f7e24bd9b8b8e\n \n       - name: Check\n         run: |\n@@ -99,9 +116,9 @@ jobs:\n         uses: actions/checkout@v3\n \n       - name: Install Nodejs\n-        uses: actions/setup-node@v1\n+        uses: actions/setup-node@v3\n         with:\n-          node-version: 16.x\n+          node-version: 16\n \n       - name: Install xvfb\n         if: matrix.os == 'ubuntu-latest'"}, {"sha": "422fe29f9d5c37576060b0698aaa0c6c60aab603", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -76,9 +76,9 @@ jobs:\n           rustup component add rust-src\n \n       - name: Install Node.js\n-        uses: actions/setup-node@v1\n+        uses: actions/setup-node@v3\n         with:\n-          node-version: 16.x\n+          node-version: 16\n \n       - name: Update apt repositories\n         if: matrix.target == 'aarch64-unknown-linux-gnu' || matrix.target == 'arm-unknown-linux-gnueabihf'\n@@ -184,9 +184,9 @@ jobs:\n     needs: [\"dist\", \"dist-x86_64-unknown-linux-musl\"]\n     steps:\n       - name: Install Nodejs\n-        uses: actions/setup-node@v1\n+        uses: actions/setup-node@v3\n         with:\n-          node-version: 16.x\n+          node-version: 16\n \n       - run: echo \"TAG=$(date --iso -u)\" >> $GITHUB_ENV\n         if: github.ref == 'refs/heads/release'\n@@ -259,6 +259,7 @@ jobs:\n         working-directory: ./editors/code\n         # token from https://dev.azure.com/rust-analyzer/\n         run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n+        timeout-minutes: 2\n \n       - name: Publish Extension (Code Marketplace, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n@@ -269,3 +270,4 @@ jobs:\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n         run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n+        timeout-minutes: 2"}, {"sha": "0ddea2f728d7806bb5d363b95a6214de6c88c5b4", "filename": "src/tools/rust-analyzer/Cargo.lock", "status": "modified", "additions": 90, "deletions": 99, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.lock?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -37,9 +37,9 @@ dependencies = [\n \n [[package]]\n name = \"anyhow\"\n-version = \"1.0.62\"\n+version = \"1.0.65\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1485d4d2cc45e7b201ee3767015c96faa5904387c9d87c6efdd0fb511f12d305\"\n+checksum = \"98161a4e3e2184da77bb14f02184cdd111e83bbbcc9979dfee3c44b9a85f5602\"\n \n [[package]]\n name = \"anymap\"\n@@ -49,9 +49,9 @@ checksum = \"8f1f8f5a6f3d50d89e3797d7593a50f96bb2aaa20ca0cc7be1fb673232c91d72\"\n \n [[package]]\n name = \"arbitrary\"\n-version = \"1.1.3\"\n+version = \"1.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5a7924531f38b1970ff630f03eb20a2fde69db5c590c93b0f3482e95dcc5fd60\"\n+checksum = \"d86fd10d912cab78764cc44307d9cd5f164e09abbeb87fb19fb6d95937e8da5f\"\n \n [[package]]\n name = \"arrayvec\"\n@@ -171,9 +171,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf29c109d57f8d57b0e7675391be37a9285d86dd93278bd5f14a0ad3c447a6c2\"\n+checksum = \"5499d415d855b5094366a824815341893ad3de0ecb6048c430118bdae6d27402\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -183,9 +183,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d391763027b5e50a5e15caf6d2857ec585fd68160367bbeac9e1804209620918\"\n+checksum = \"3800118c76a48507b0eece3a01f3a429b5c478d203c493096e6040c67ab960e1\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-derive\",\n@@ -194,9 +194,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afafd92dcdc7fe0ea940ee94bdd8cc5bd18f4a4a84c593d6d7025fe16c150478\"\n+checksum = \"1baf60628fd73104d1f8562586a52d48f37f1e84435aab2e62674b1fd935b8c8\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -207,9 +207,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.84.0\"\n+version = \"0.86.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3af1d111f11c91c48ace02e93e470c5bae6d2631bd112e4545317da53660d7fc\"\n+checksum = \"0e9c3c068f9358786348e58a1b94ef0a5cf90a9810fc1f10fda896f0b5d80185\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -270,45 +270,44 @@ dependencies = [\n \n [[package]]\n name = \"crossbeam-epoch\"\n-version = \"0.9.10\"\n+version = \"0.9.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"045ebe27666471bb549370b4b0b3e51b07f56325befa4284db65fc89c02511b1\"\n+checksum = \"f916dfc5d356b0ed9dae65f1db9fc9770aa2851d2662b988ccf4fe3516e86348\"\n dependencies = [\n  \"autocfg\",\n  \"cfg-if\",\n  \"crossbeam-utils\",\n  \"memoffset\",\n- \"once_cell\",\n  \"scopeguard\",\n ]\n \n [[package]]\n name = \"crossbeam-utils\"\n-version = \"0.8.11\"\n+version = \"0.8.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"51887d4adc7b564537b15adcfb307936f8075dfcd5f00dde9a9f1d29383682bc\"\n+checksum = \"edbafec5fa1f196ca66527c1b12c2ec4745ca14b50f1ad8f9f6f720b55d11fac\"\n dependencies = [\n  \"cfg-if\",\n- \"once_cell\",\n ]\n \n [[package]]\n name = \"dashmap\"\n-version = \"5.3.4\"\n+version = \"5.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3495912c9c1ccf2e18976439f4443f3fee0fd61f424ff99fde6a66b15ecb448f\"\n+checksum = \"907076dfda823b0b36d2a1bb5f90c96660a5bbcd7729e10727f07858f22c4edc\"\n dependencies = [\n  \"cfg-if\",\n  \"hashbrown\",\n  \"lock_api\",\n+ \"once_cell\",\n  \"parking_lot_core 0.9.3\",\n ]\n \n [[package]]\n name = \"derive_arbitrary\"\n-version = \"1.1.3\"\n+version = \"1.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c9a577516173adb681466d517d39bd468293bc2c2a16439375ef0f35bba45f3d\"\n+checksum = \"226ad66541d865d7a7173ad6a9e691c33fdb910ac723f4bc734b3e5294a1f931\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -404,11 +403,10 @@ dependencies = [\n \n [[package]]\n name = \"form_urlencoded\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5fc25a87fa4fd2094bffb06925852034d90a17f0d1e05197d4956d3555752191\"\n+checksum = \"a9c384f161156f5260c24a097c56119f9be8c798586aecc13afbcbe7b7e26bf8\"\n dependencies = [\n- \"matches\",\n  \"percent-encoding\",\n ]\n \n@@ -546,6 +544,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"arrayvec\",\n  \"base-db\",\n+ \"chalk-derive\",\n  \"chalk-ir\",\n  \"chalk-recursive\",\n  \"chalk-solve\",\n@@ -573,9 +572,9 @@ dependencies = [\n \n [[package]]\n name = \"home\"\n-version = \"0.5.3\"\n+version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2456aef2e6b6a9784192ae780c0f15bc57df0e918585282325e8c8ac27737654\"\n+checksum = \"747309b4b440c06d57b0b25f2aee03ee9b5e5397d288c60e21fc709bb98a7408\"\n dependencies = [\n  \"winapi\",\n ]\n@@ -714,11 +713,10 @@ dependencies = [\n \n [[package]]\n name = \"idna\"\n-version = \"0.2.3\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"418a0a6fab821475f634efe3ccc45c013f742efe03d853e8d3355d5cb850ecf8\"\n+checksum = \"e14ddfc70884202db2244c223200c204c2bda1bc6e0998d11b5e024d657209e6\"\n dependencies = [\n- \"matches\",\n  \"unicode-bidi\",\n  \"unicode-normalization\",\n ]\n@@ -764,18 +762,18 @@ dependencies = [\n \n [[package]]\n name = \"itertools\"\n-version = \"0.10.3\"\n+version = \"0.10.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9a9d19fa1e79b6215ff29b9d6880b706147f16e9b1dbb1e4e5947b5b02bc5e3\"\n+checksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\n dependencies = [\n  \"either\",\n ]\n \n [[package]]\n name = \"itoa\"\n-version = \"1.0.3\"\n+version = \"1.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6c8af84674fe1f223a982c933a0ee1086ac4d4052aa0fb8060c12c6ad838e754\"\n+checksum = \"4217ad341ebadf8d8e724e264f13e593e0648f5b3e94b3896a5df283be015ecc\"\n \n [[package]]\n name = \"jod-thread\"\n@@ -815,9 +813,9 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.132\"\n+version = \"0.2.135\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n+checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n \n [[package]]\n name = \"libloading\"\n@@ -831,9 +829,9 @@ dependencies = [\n \n [[package]]\n name = \"libmimalloc-sys\"\n-version = \"0.1.25\"\n+version = \"0.1.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11ca136052550448f55df7898c6dbe651c6b574fe38a0d9ea687a9f8088a2e2c\"\n+checksum = \"8fc093ab289b0bfda3aa1bdfab9c9542be29c7ef385cfcbe77f8c9813588eb48\"\n dependencies = [\n  \"cc\",\n ]\n@@ -844,9 +842,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"lock_api\"\n-version = \"0.4.7\"\n+version = \"0.4.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"327fa5b6a6940e4699ec49a9beae1ea4845c6bab9314e4f84ac68742139d8c53\"\n+checksum = \"435011366fe56583b16cf956f9df0095b405b82d76425bc8981c0e22e60ec4df\"\n dependencies = [\n  \"autocfg\",\n  \"scopeguard\",\n@@ -894,12 +892,6 @@ dependencies = [\n  \"regex-automata\",\n ]\n \n-[[package]]\n-name = \"matches\"\n-version = \"0.1.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a3e378b66a060d48947b590737b30a1be76706c8dd7b8ba0f2fe3989c68a853f\"\n-\n [[package]]\n name = \"mbe\"\n version = \"0.0.0\"\n@@ -941,18 +933,18 @@ dependencies = [\n \n [[package]]\n name = \"mimalloc\"\n-version = \"0.1.29\"\n+version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2f64ad83c969af2e732e907564deb0d0ed393cec4af80776f77dd77a1a427698\"\n+checksum = \"76ce6a4b40d3bff9eb3ce9881ca0737a85072f9f975886082640cd46a75cdb35\"\n dependencies = [\n  \"libmimalloc-sys\",\n ]\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.5.3\"\n+version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f5c75688da582b8ffc1f1799e9db273f32133c49e048f614d22ec3256773ccc\"\n+checksum = \"96590ba8f175222643a85693f33d26e9c8a015f599c216509b1a6894af675d34\"\n dependencies = [\n  \"adler\",\n ]\n@@ -980,9 +972,9 @@ dependencies = [\n \n [[package]]\n name = \"notify\"\n-version = \"5.0.0-pre.16\"\n+version = \"5.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"530f6314d6904508082f4ea424a0275cf62d341e118b313663f266429cb19693\"\n+checksum = \"ed2c66da08abae1c024c01d635253e402341b4060a12e99b31c7594063bf490a\"\n dependencies = [\n  \"bitflags\",\n  \"crossbeam-channel\",\n@@ -1017,9 +1009,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.13.1\"\n+version = \"1.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"074864da206b4973b84eb91683020dbefd6a8c3f0f38e054d93954e891935e4e\"\n+checksum = \"e82dad04139b71a90c080c8463fe0dc7902db5192d939bd0950f074d014339e1\"\n \n [[package]]\n name = \"oorandom\"\n@@ -1088,19 +1080,19 @@ dependencies = [\n \n [[package]]\n name = \"paste\"\n-version = \"1.0.8\"\n+version = \"1.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9423e2b32f7a043629287a536f21951e8c6a82482d0acb1eeebfc90bc2225b22\"\n+checksum = \"b1de2e551fb905ac83f73f7aedf2f0cb4a0da7e35efa24a202a936269f1f18e1\"\n \n [[package]]\n name = \"paths\"\n version = \"0.0.0\"\n \n [[package]]\n name = \"percent-encoding\"\n-version = \"2.1.0\"\n+version = \"2.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n+checksum = \"478c572c3d73181ff3c2539045f6eb99e5491218eae919370993b890cdbdd98e\"\n \n [[package]]\n name = \"perf-event\"\n@@ -1190,9 +1182,9 @@ version = \"0.0.0\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.46\"\n+version = \"1.0.47\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94e2ef8dbfc347b10c094890f778ee2e36ca9bb4262e86dc99cd217e35f3470b\"\n+checksum = \"5ea3d908b0e36316caf9e9e2c4625cdde190a7e6f440d794667ed17a1855e725\"\n dependencies = [\n  \"unicode-ident\",\n ]\n@@ -1265,9 +1257,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark-to-cmark\"\n-version = \"10.0.2\"\n+version = \"10.0.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c1353ac408192fa925228d3e60ff746167d03f4f7e54835d78ef79e08225d913\"\n+checksum = \"0194e6e1966c23cc5fd988714f85b18d548d773e81965413555d96569931833d\"\n dependencies = [\n  \"pulldown-cmark\",\n ]\n@@ -1340,9 +1332,9 @@ checksum = \"a3f87b73ce11b1619a3c6332f45341e0047173771e8b8b73f87bfeefb7b56244\"\n \n [[package]]\n name = \"rowan\"\n-version = \"0.15.8\"\n+version = \"0.15.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e88acf7b001007e9e8c989fe7449f6601d909e5dd2c56399fc158977ad6c56e8\"\n+checksum = \"5811547e7ba31e903fe48c8ceab10d40d70a101f3d15523c847cce91aa71f332\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\",\n@@ -1493,27 +1485,27 @@ checksum = \"d29ab0c6d3fc0ee92fe66e2d99f700eab17a8d57d1c1d3b748380fb20baa78cd\"\n \n [[package]]\n name = \"semver\"\n-version = \"1.0.13\"\n+version = \"1.0.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93f6841e709003d68bb2deee8c343572bf446003ec20a583e76f7b15cebf3711\"\n+checksum = \"e25dfac463d778e353db5be2449d1cce89bd6fd23c9f1ea21310ce6e5a1b29c4\"\n dependencies = [\n  \"serde\",\n ]\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.144\"\n+version = \"1.0.145\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0f747710de3dcd43b88c9168773254e809d8ddbdf9653b84e2554ab219f17860\"\n+checksum = \"728eb6351430bccb993660dfffc5a72f91ccc1295abaa8ce19b27ebe4f75568b\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.144\"\n+version = \"1.0.145\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94ed3a816fb1d101812f83e789f888322c34e291f894f19590dc310963e87a00\"\n+checksum = \"81fa1584d3d1bcacd84c277a0dfe21f5b0f6accf4a23d04d4c6d61f1af522b4c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1522,9 +1514,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.85\"\n+version = \"1.0.86\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e55a28e3aaef9d5ce0506d0a14dbba8054ddc7e499ef522dd8b26859ec9d4a44\"\n+checksum = \"41feea4228a6f1cd09ec7a3593a682276702cd67b5273544757dae23c096f074\"\n dependencies = [\n  \"indexmap\",\n  \"itoa\",\n@@ -1554,9 +1546,9 @@ dependencies = [\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n \n [[package]]\n name = \"smol_str\"\n@@ -1666,18 +1658,18 @@ checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n [[package]]\n name = \"thiserror\"\n-version = \"1.0.31\"\n+version = \"1.0.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a\"\n+checksum = \"10deb33631e3c9018b9baf9dcbbc4f737320d2b576bac10f6aefa048fa407e3e\"\n dependencies = [\n  \"thiserror-impl\",\n ]\n \n [[package]]\n name = \"thiserror-impl\"\n-version = \"1.0.31\"\n+version = \"1.0.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a\"\n+checksum = \"982d17546b47146b28f7c22e3d08465f6b8903d0ea13c1660d9d84a6e7adcdbb\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1715,9 +1707,9 @@ dependencies = [\n \n [[package]]\n name = \"tikv-jemalloc-sys\"\n-version = \"0.5.1+5.3.0-patched\"\n+version = \"0.5.2+5.3.0-patched\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"931e876f91fed0827f863a2d153897790da0b24d882c721a79cb3beb0b903261\"\n+checksum = \"ec45c14da997d0925c7835883e4d5c181f196fa142f8c19d7643d1e9af2592c3\"\n dependencies = [\n  \"cc\",\n  \"fs_extra\",\n@@ -1758,9 +1750,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.36\"\n+version = \"0.1.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2fce9567bd60a67d08a16488756721ba392f24f29006402881e43b19aac64307\"\n+checksum = \"8ce8c33a8d48bd45d624a6e523445fd21ec13d3653cd51f681abf67418f54eb8\"\n dependencies = [\n  \"cfg-if\",\n  \"pin-project-lite\",\n@@ -1770,9 +1762,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.22\"\n+version = \"0.1.23\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"11c75893af559bc8e10716548bdef5cb2b983f8e637db9d0e15126b61b484ee2\"\n+checksum = \"4017f8f45139870ca7e672686113917c71c7a6e02d4924eda67186083c03081a\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1781,9 +1773,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.29\"\n+version = \"0.1.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5aeea4303076558a00714b823f9ad67d58a3bbda1df83d8827d21193156e22f7\"\n+checksum = \"24eb03ba0eab1fd845050058ce5e616558e8f8d8fca633e6b163fe25c797213a\"\n dependencies = [\n  \"once_cell\",\n  \"valuable\",\n@@ -1802,9 +1794,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.3.15\"\n+version = \"0.3.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"60db860322da191b40952ad9affe65ea23e7dd6a5c442c2c42865810c6ab8e6b\"\n+checksum = \"a6176eae26dd70d0c919749377897b54a9276bd7061339665dd68777926b5a70\"\n dependencies = [\n  \"matchers\",\n  \"once_cell\",\n@@ -1866,40 +1858,39 @@ checksum = \"099b7128301d285f79ddd55b9a83d5e6b9e97c92e0ea0daebee7263e932de992\"\n \n [[package]]\n name = \"unicode-ident\"\n-version = \"1.0.1\"\n+version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5bd2fe26506023ed7b5e1e315add59d6f584c621d037f9368fea9cfb988f368c\"\n+checksum = \"6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3\"\n \n [[package]]\n name = \"unicode-normalization\"\n-version = \"0.1.21\"\n+version = \"0.1.22\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"854cbdc4f7bc6ae19c820d44abdc3277ac3e1b2b93db20a636825d9322fb60e6\"\n+checksum = \"5c5713f0fc4b5db668a2ac63cdb7bb4469d8c9fed047b1d0292cc7b0ce2ba921\"\n dependencies = [\n  \"tinyvec\",\n ]\n \n [[package]]\n name = \"unicode-segmentation\"\n-version = \"1.9.0\"\n+version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e8820f5d777f6224dc4be3632222971ac30164d4a258d595640799554ebfd99\"\n+checksum = \"0fdbf052a0783de01e944a6ce7a8cb939e295b1e7be835a1112c3b9a7f047a5a\"\n \n [[package]]\n name = \"unicode-xid\"\n-version = \"0.2.3\"\n+version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"957e51f3646910546462e67d5f7599b9e4fb8acdd304b087a6494730f9eebf04\"\n+checksum = \"f962df74c8c05a667b5ee8bcf162993134c104e96440b663c8daa176dc772d8c\"\n \n [[package]]\n name = \"url\"\n-version = \"2.2.2\"\n+version = \"2.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a507c383b2d33b5fc35d1861e77e6b383d158b2da5e14fe51b83dfedf6fd578c\"\n+checksum = \"0d68c799ae75762b8c3fe375feb6600ef5602c883c5d21eb51c09f22b83c4643\"\n dependencies = [\n  \"form_urlencoded\",\n  \"idna\",\n- \"matches\",\n  \"percent-encoding\",\n  \"serde\",\n ]"}, {"sha": "286ef1e7dcb4dfde854c8ee20ab38575fed61264", "filename": "src/tools/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -27,6 +27,7 @@ debug = 0\n # chalk-solve = { path = \"../chalk/chalk-solve\" }\n # chalk-ir = { path = \"../chalk/chalk-ir\" }\n # chalk-recursive = { path = \"../chalk/chalk-recursive\" }\n+# chalk-derive = { path = \"../chalk/chalk-derive\" }\n \n # ungrammar = { path = \"../ungrammar\" }\n "}, {"sha": "ee1ad677a95f27ad3ff5a7d0049fb66e2c97f6a7", "filename": "src/tools/rust-analyzer/crates/cfg/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fcfg%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -22,5 +22,5 @@ oorandom = \"11.1.3\"\n # We depend on both individually instead of using `features = [\"derive\"]` to microoptimize the\n # build graph: if the feature was enabled, syn would be built early on in the graph if `smolstr`\n # supports `arbitrary`. This way, we avoid feature unification.\n-arbitrary = \"1.1.0\"\n-derive_arbitrary = \"1.1.0\"\n+arbitrary = \"1.1.7\"\n+derive_arbitrary = \"1.1.6\""}, {"sha": "2ad32d24837d7771f0126ac6052c5965308cccae", "filename": "src/tools/rust-analyzer/crates/flycheck/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fflycheck%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -11,11 +11,11 @@ doctest = false\n \n [dependencies]\n crossbeam-channel = \"0.5.5\"\n-tracing = \"0.1.35\"\n+tracing = \"0.1.37\"\n cargo_metadata = \"0.15.0\"\n rustc-hash = \"1.1.0\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n-serde_json = \"1.0.81\"\n+serde_json = \"1.0.86\"\n jod-thread = \"0.1.2\"\n \n toolchain = { path = \"../toolchain\", version = \"0.0.0\" }"}, {"sha": "4ad8e75970b5995909bea43cb6157b13c321b850", "filename": "src/tools/rust-analyzer/crates/hir-def/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -15,17 +15,17 @@ arrayvec = \"0.7.2\"\n bitflags = \"1.3.2\"\n cov-mark = \"2.0.0-pre.1\"\n # We need to freeze the version of the crate, as the raw-api feature is considered unstable\n-dashmap = { version = \"=5.3.4\", features = [\"raw-api\"] }\n+dashmap = { version = \"=5.4.0\", features = [\"raw-api\"] }\n drop_bomb = \"0.1.5\"\n either = \"1.7.0\"\n fst = { version = \"0.4.7\", default-features = false }\n hashbrown = { version = \"0.12.1\", default-features = false }\n indexmap = \"1.9.1\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.9.0\"\n+smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "759f3b8c04b6cdb1e2ea7cd02cc52b2df7f4b894", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -311,7 +311,20 @@ impl Body {\n             DefWithBodyId::FunctionId(f) => {\n                 let f = f.lookup(db);\n                 let src = f.source(db);\n-                params = src.value.param_list();\n+                params = src.value.param_list().map(|param_list| {\n+                    let item_tree = f.id.item_tree(db);\n+                    let func = &item_tree[f.id.value];\n+                    let krate = f.container.module(db).krate;\n+                    let crate_graph = db.crate_graph();\n+                    (\n+                        param_list,\n+                        func.params.clone().map(move |param| {\n+                            item_tree\n+                                .attrs(db, krate, param.into())\n+                                .is_cfg_enabled(&crate_graph[krate].cfg_options)\n+                        }),\n+                    )\n+                });\n                 (src.file_id, f.module(db), src.value.body().map(ast::Expr::from))\n             }\n             DefWithBodyId::ConstId(c) => {\n@@ -334,6 +347,7 @@ impl Body {\n         let expander = Expander::new(db, file_id, module);\n         let (mut body, source_map) = Body::new(db, expander, params, body);\n         body.shrink_to_fit();\n+\n         (Arc::new(body), Arc::new(source_map))\n     }\n \n@@ -370,7 +384,7 @@ impl Body {\n     fn new(\n         db: &dyn DefDatabase,\n         expander: Expander,\n-        params: Option<ast::ParamList>,\n+        params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n         lower::lower(db, expander, params, body)"}, {"sha": "ccc01c3efca51468eb320a664128bba7d61473e7", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -77,7 +77,7 @@ impl<'a> LowerCtx<'a> {\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     expander: Expander,\n-    params: Option<ast::ParamList>,\n+    params: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n     ExprCollector {\n@@ -119,11 +119,13 @@ struct ExprCollector<'a> {\n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n-        param_list: Option<ast::ParamList>,\n+        param_list: Option<(ast::ParamList, impl Iterator<Item = bool>)>,\n         body: Option<ast::Expr>,\n     ) -> (Body, BodySourceMap) {\n-        if let Some(param_list) = param_list {\n-            if let Some(self_param) = param_list.self_param() {\n+        if let Some((param_list, mut attr_enabled)) = param_list {\n+            if let Some(self_param) =\n+                param_list.self_param().filter(|_| attr_enabled.next().unwrap_or(false))\n+            {\n                 let ptr = AstPtr::new(&self_param);\n                 let param_pat = self.alloc_pat(\n                     Pat::Bind {\n@@ -139,7 +141,11 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for pat in param_list.params().filter_map(|param| param.pat()) {\n+            for pat in param_list\n+                .params()\n+                .zip(attr_enabled)\n+                .filter_map(|(param, enabled)| param.pat().filter(|_| enabled))\n+            {\n                 let param_pat = self.collect_pat(pat);\n                 self.body.params.push(param_pat);\n             }"}, {"sha": "c04cd1651926dfb86d412835c2c343e219a40e7f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -93,12 +93,12 @@ macro_rules! option_env {() => {}}\n \n fn main() { option_env!(\"TEST_ENV_VAR\"); }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! option_env {() => {}}\n \n-fn main() { std::option::Option::None:: < &str>; }\n-\"##]],\n+fn main() { $crate::option::Option::None:: < &str>; }\n+\"#]],\n     );\n }\n \n@@ -191,17 +191,17 @@ fn main() {\n     format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(arg1(a, b, c)), std::fmt::Display::fmt), std::fmt::ArgumentV1::new(&(arg2), std::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Display::fmt), ]);\n }\n-\"##]],\n+\"#]],\n     );\n }\n \n@@ -219,17 +219,17 @@ fn main() {\n     format_args!(\"{} {:?}\", a::<A,B>(), b);\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a::<A, B>()), std::fmt::Display::fmt), std::fmt::ArgumentV1::new(&(b), std::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Display::fmt), ]);\n }\n-\"##]],\n+\"#]],\n     );\n }\n \n@@ -248,7 +248,7 @@ fn main() {\n         format_args!/*+errors*/(\"{} {:?}\", a.);\n }\n \"#,\n-        expect![[r##\"\n+        expect![[r#\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n@@ -258,9 +258,9 @@ macro_rules! format_args {\n fn main() {\n     let _ =\n         /* parse error: expected field name or number */\n-std::fmt::Arguments::new_v1(&[], &[std::fmt::ArgumentV1::new(&(a.), std::fmt::Display::fmt), ]);\n+$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), ]);\n }\n-\"##]],\n+\"#]],\n     );\n }\n "}, {"sha": "3359c99b3961c098ef788b2ec02086160a1e9d98", "filename": "src/tools/rust-analyzer/crates/hir-expand/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -15,11 +15,11 @@ tracing = \"0.1.35\"\n either = \"1.7.0\"\n rustc-hash = \"1.1.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n hashbrown = { version = \"0.12.1\", features = [\n     \"inline-more\",\n ], default-features = false }\n-smallvec = { version = \"1.9.0\", features = [\"const_new\"] }\n+smallvec = { version = \"1.10.0\", features = [\"const_new\"] }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n base-db = { path = \"../base-db\", version = \"0.0.0\" }"}, {"sha": "7b19518e25a8437a16c302dcb8f9399a2faebd34", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -238,9 +238,9 @@ fn format_args_expand(\n ) -> ExpandResult<tt::Subtree> {\n     // We expand `format_args!(\"\", a1, a2)` to\n     // ```\n-    // std::fmt::Arguments::new_v1(&[], &[\n-    //   std::fmt::ArgumentV1::new(&arg1,std::fmt::Display::fmt),\n-    //   std::fmt::ArgumentV1::new(&arg2,std::fmt::Display::fmt),\n+    // $crate::fmt::Arguments::new_v1(&[], &[\n+    //   $crate::fmt::ArgumentV1::new(&arg1,$crate::fmt::Display::fmt),\n+    //   $crate::fmt::ArgumentV1::new(&arg2,$crate::fmt::Display::fmt),\n     // ])\n     // ```,\n     // which is still not really correct, but close enough for now\n@@ -262,10 +262,10 @@ fn format_args_expand(\n     }\n     let _format_string = args.remove(0);\n     let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { std::fmt::ArgumentV1::new(&(#arg), std::fmt::Display::fmt), }\n+        quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n     }.token_trees);\n     let expanded = quote! {\n-        std::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])\n     };\n     ExpandResult::ok(expanded)\n }\n@@ -675,8 +675,8 @@ fn option_env_expand(\n     };\n \n     let expanded = match get_env_inner(db, arg_id, &key) {\n-        None => quote! { std::option::Option::None::<&str> },\n-        Some(s) => quote! { std::option::Some(#s) },\n+        None => quote! { #DOLLAR_CRATE::option::Option::None::<&str> },\n+        Some(s) => quote! { #DOLLAR_CRATE::option::Some(#s) },\n     };\n \n     ExpandResult::ok(ExpandedEager::new(expanded))"}, {"sha": "87e4db03984ab9dbecf555e67e36046b7c7da5c3", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/db.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -221,8 +221,16 @@ pub fn expand_speculative(\n     fixup::reverse_fixups(&mut speculative_expansion.value, &spec_args_tmap, &fixups.undo_info);\n     let (node, rev_tmap) = token_tree_to_syntax_node(&speculative_expansion.value, expand_to);\n \n-    let range = rev_tmap.first_range_by_token(token_id, token_to_map.kind())?;\n-    let token = node.syntax_node().covering_element(range).into_token()?;\n+    let syntax_node = node.syntax_node();\n+    let token = rev_tmap\n+        .ranges_by_token(token_id, token_to_map.kind())\n+        .filter_map(|range| syntax_node.covering_element(range).into_token())\n+        .min_by_key(|t| {\n+            // prefer tokens of the same kind and text\n+            // Note the inversion of the score here, as we want to prefer the first token in case\n+            // of all tokens having the same score\n+            (t.kind() != token_to_map.kind()) as u8 + (t.text() != token_to_map.text()) as u8\n+        })?;\n     Some((node.syntax_node(), token))\n }\n "}, {"sha": "68413df420c7d7053c1f707f31fb5cc21d7affa0", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -259,6 +259,7 @@ macro_rules! __known_path {\n     (core::future::Future) => {};\n     (core::future::IntoFuture) => {};\n     (core::ops::Try) => {};\n+    (core::ops::FromResidual) => {};\n     ($path:path) => {\n         compile_error!(\"Please register your known path in the path module\")\n     };"}, {"sha": "8a735b965ab8460a49003399a12b25e13cb9830b", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -279,6 +279,8 @@ pub mod known {\n         RangeToInclusive,\n         RangeTo,\n         Range,\n+        Residual,\n+        FromResidual,\n         Neg,\n         Not,\n         None,"}, {"sha": "ed13275bab8fecd36b516048b8c8d17188123805", "filename": "src/tools/rust-analyzer/crates/hir-ty/Cargo.toml", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -11,18 +11,19 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n-smallvec = \"1.9.0\"\n+smallvec = \"1.10.0\"\n ena = \"0.14.0\"\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n scoped-tls = \"1.0.0\"\n-chalk-solve = { version = \"0.84.0\", default-features = false }\n-chalk-ir = \"0.84.0\"\n-chalk-recursive = { version = \"0.84.0\", default-features = false }\n+chalk-solve = { version = \"0.86.0\", default-features = false }\n+chalk-ir = \"0.86.0\"\n+chalk-recursive = { version = \"0.86.0\", default-features = false }\n+chalk-derive = \"0.86.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n typed-arena = \"2.0.1\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n@@ -37,7 +38,7 @@ limit = { path = \"../limit\", version = \"0.0.0\" }\n test-utils = { path = \"../test-utils\" }\n expect-test = \"1.4.0\"\n tracing = \"0.1.35\"\n-tracing-subscriber = { version = \"0.3.14\", default-features = false, features = [\n+tracing-subscriber = { version = \"0.3.16\", default-features = false, features = [\n     \"env-filter\",\n     \"registry\",\n ] }"}, {"sha": "43c3451cab37bb865c74e65b0cf39027f0354892", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -823,10 +823,10 @@ pub(super) fn generic_predicate_to_inline_bound(\n             Some(chalk_ir::Binders::new(binders, rust_ir::InlineBound::TraitBound(trait_bound)))\n         }\n         WhereClause::AliasEq(AliasEq { alias: AliasTy::Projection(projection_ty), ty }) => {\n-            if projection_ty.self_type_parameter(Interner) != self_ty_shifted_in {\n+            let trait_ = projection_ty.trait_(db);\n+            if projection_ty.self_type_parameter(db) != self_ty_shifted_in {\n                 return None;\n             }\n-            let trait_ = projection_ty.trait_(db);\n             let args_no_self = projection_ty.substitution.as_slice(Interner)[1..]\n                 .iter()\n                 .map(|ty| ty.clone().cast(Interner))"}, {"sha": "e2099d7e509278b9b8ce8cb031c89d107f6c0972", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -262,7 +262,7 @@ impl TyExt for Ty {\n                                     WhereClause::AliasEq(AliasEq {\n                                         alias: AliasTy::Projection(proj),\n                                         ty: _,\n-                                    }) => &proj.self_type_parameter(Interner) == self,\n+                                    }) => &proj.self_type_parameter(db) == self,\n                                     _ => false,\n                                 })\n                                 .collect::<Vec<_>>();\n@@ -333,6 +333,7 @@ impl TyExt for Ty {\n pub trait ProjectionTyExt {\n     fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef;\n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId;\n+    fn self_type_parameter(&self, db: &dyn HirDatabase) -> Ty;\n }\n \n impl ProjectionTyExt for ProjectionTy {\n@@ -349,6 +350,10 @@ impl ProjectionTyExt for ProjectionTy {\n             _ => panic!(\"projection ty without parent trait\"),\n         }\n     }\n+\n+    fn self_type_parameter(&self, db: &dyn HirDatabase) -> Ty {\n+        self.trait_ref(db).self_type_parameter(Interner)\n+    }\n }\n \n pub trait TraitRefExt {"}, {"sha": "0221f922feb2ff396a2c602880eb1ad363dab60e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/display.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -291,7 +291,7 @@ impl HirDisplay for ProjectionTy {\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n         write!(f, \"<\")?;\n-        self.self_type_parameter(Interner).hir_fmt(f)?;\n+        self.self_type_parameter(f.db).hir_fmt(f)?;\n         write!(f, \" as {}\", trait_.name)?;\n         if self.substitution.len(Interner) > 1 {\n             write!(f, \"<\")?;\n@@ -731,7 +731,7 @@ impl HirDisplay for Ty {\n                                         WhereClause::AliasEq(AliasEq {\n                                             alias: AliasTy::Projection(proj),\n                                             ty: _,\n-                                        }) => &proj.self_type_parameter(Interner) == self,\n+                                        }) => &proj.self_type_parameter(f.db) == self,\n                                         _ => false,\n                                     })\n                                     .collect::<Vec<_>>();\n@@ -751,9 +751,19 @@ impl HirDisplay for Ty {\n             }\n             TyKind::BoundVar(idx) => idx.hir_fmt(f)?,\n             TyKind::Dyn(dyn_ty) => {\n+                // Reorder bounds to satisfy `write_bounds_like_dyn_trait()`'s expectation.\n+                // FIXME: `Iterator::partition_in_place()` or `Vec::drain_filter()` may make it\n+                // more efficient when either of them hits stable.\n+                let mut bounds: SmallVec<[_; 4]> =\n+                    dyn_ty.bounds.skip_binders().iter(Interner).cloned().collect();\n+                let (auto_traits, others): (SmallVec<[_; 4]>, _) =\n+                    bounds.drain(1..).partition(|b| b.skip_binders().trait_id().is_some());\n+                bounds.extend(others);\n+                bounds.extend(auto_traits);\n+\n                 write_bounds_like_dyn_trait_with_prefix(\n                     \"dyn\",\n-                    dyn_ty.bounds.skip_binders().interned(),\n+                    &bounds,\n                     SizedByDefault::NotSized,\n                     f,\n                 )?;"}, {"sha": "6a5c4966f7ba5ee423b0b62273fa046ba1cbb37b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -190,7 +190,9 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n+    IncorrectTryTarget { expr: ExprId },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n+    DoesNotImplement { expr: ExprId, trait_: TraitId, ty: Ty },\n }\n \n /// A mismatch between an expected and an inferred type.\n@@ -905,17 +907,6 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Item])\n     }\n \n-    fn resolve_ops_try_ok(&self) -> Option<TypeAliasId> {\n-        // FIXME resolve via lang_item once try v2 is stable\n-        let path = path![core::ops::Try];\n-        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n-        let trait_data = self.db.trait_data(trait_);\n-        trait_data\n-            // FIXME remove once try v2 is stable\n-            .associated_type_by_name(&name![Ok])\n-            .or_else(|| trait_data.associated_type_by_name(&name![Output]))\n-    }\n-\n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n         let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])"}, {"sha": "59ab50d0717ba6d5050e28c533f3c3543a881740", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 91, "deletions": 8, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -19,24 +19,24 @@ use hir_def::{\n     resolver::resolver_for_expr,\n     ConstParamId, FieldId, ItemContainerId, Lookup,\n };\n-use hir_expand::name::Name;\n+use hir_expand::{name, name::Name};\n use stdx::always;\n use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n+    infer::{coerce::CoerceMany, find_continuable, path, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n     method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n-    static_lifetime, to_chalk_trait_id,\n+    static_lifetime, to_assoc_type_id, to_chalk_trait_id,\n     utils::{generics, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner, Rawness, Scalar,\n-    Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    AdtId, AliasEq, AliasTy, Binders, CallableDefId, FnPointer, FnSig, FnSubst, Interner,\n+    ProjectionTy, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n use super::{\n@@ -564,9 +564,29 @@ impl<'a> InferenceContext<'a> {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n                 self.resolve_associated_type(inner_ty, self.resolve_future_future_output())\n             }\n-            Expr::Try { expr } => {\n-                let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n-                self.resolve_associated_type(inner_ty, self.resolve_ops_try_ok())\n+            &Expr::Try { expr } => {\n+                let inner_ty = self.infer_expr_inner(expr, &Expectation::none());\n+                match self.resolve_try_impl_for(inner_ty.clone()) {\n+                    Some((_, Some((output, residual)))) => {\n+                        if let Some((_trait, false)) =\n+                            self.implements_from_residual(self.return_ty.clone(), residual)\n+                        {\n+                            self.push_diagnostic(InferenceDiagnostic::IncorrectTryTarget {\n+                                expr: tgt_expr,\n+                            });\n+                        }\n+                        output\n+                    }\n+                    Some((trait_, None)) => {\n+                        self.push_diagnostic(InferenceDiagnostic::DoesNotImplement {\n+                            expr,\n+                            trait_,\n+                            ty: inner_ty,\n+                        });\n+                        self.err_ty()\n+                    }\n+                    None => self.err_ty(),\n+                }\n             }\n             Expr::Cast { expr, type_ref } => {\n                 // FIXME: propagate the \"castable to\" expectation (and find a test case that shows this is necessary)\n@@ -1530,4 +1550,67 @@ impl<'a> InferenceContext<'a> {\n         let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n         (ctx.may_break.then(|| ctx.coerce.complete()), res)\n     }\n+\n+    /// Check whether `ty` implements `FromResidual<r>`\n+    fn implements_from_residual(&mut self, ty: Ty, r: Ty) -> Option<(hir_def::TraitId, bool)> {\n+        let from_residual_trait = self\n+            .resolver\n+            .resolve_known_trait(self.db.upcast(), &(super::path![core::ops::FromResidual]))?;\n+        let r = GenericArgData::Ty(r).intern(Interner);\n+        let b = TyBuilder::trait_ref(self.db, from_residual_trait);\n+        if b.remaining() != 2 {\n+            return Some((from_residual_trait, false));\n+        }\n+        let trait_ref = b.push(ty).push(r).build();\n+        Some((from_residual_trait, self.table.try_obligation(trait_ref.cast(Interner)).is_some()))\n+    }\n+\n+    fn resolve_try_impl_for(&mut self, ty: Ty) -> Option<(hir_def::TraitId, Option<(Ty, Ty)>)> {\n+        let path = path![core::ops::Try];\n+        let trait_ = self.resolver.resolve_known_trait(self.db.upcast(), &path)?;\n+\n+        let trait_ref = TyBuilder::trait_ref(self.db, trait_).push(ty).build();\n+        let substitution = trait_ref.substitution.clone();\n+        self.push_obligation(trait_ref.clone().cast(Interner));\n+\n+        let trait_data = self.db.trait_data(trait_);\n+        let output = trait_data.associated_type_by_name(&name![Output]);\n+        let residual = trait_data.associated_type_by_name(&name![Residual]);\n+\n+        let output_ty = match output {\n+            Some(output) => {\n+                let output_ty = self.table.new_type_var();\n+                let alias_eq = AliasEq {\n+                    alias: AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(output),\n+                        substitution: substitution.clone(),\n+                    }),\n+                    ty: output_ty.clone(),\n+                };\n+                self.push_obligation(alias_eq.cast(Interner));\n+                output_ty\n+            }\n+            None => self.err_ty(),\n+        };\n+        let residual_ty = match residual {\n+            Some(residual) => {\n+                let residual_ty = self.table.new_type_var();\n+                let alias_eq = AliasEq {\n+                    alias: AliasTy::Projection(ProjectionTy {\n+                        associated_ty_id: to_assoc_type_id(residual),\n+                        substitution,\n+                    }),\n+                    ty: residual_ty.clone(),\n+                };\n+                self.push_obligation(alias_eq.cast(Interner));\n+                residual_ty\n+            }\n+            None => self.err_ty(),\n+        };\n+        // FIXME: We are doing the work twice here I think?\n+        Some((\n+            trait_,\n+            self.table.try_obligation(trait_ref.cast(Interner)).map(|_| (output_ty, residual_ty)),\n+        ))\n+    }\n }"}, {"sha": "b00e3216b2d2ce7c384c09ff42f71f152a80bf1a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -4,7 +4,7 @@ use std::{fmt, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::TypeFoldable, interner::HasInterner, zip::Zip, CanonicalVarKind, FloatTy,\n-    IntTy, NoSolution, TyVariableKind, UniverseIndex,\n+    IntTy, TyVariableKind, UniverseIndex,\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n@@ -331,7 +331,6 @@ impl<'a> InferenceTable<'a> {\n             &mut resolve::Resolver { table: self, var_stack, fallback },\n             DebruijnIndex::INNERMOST,\n         )\n-        .expect(\"fold failed unexpectedly\")\n     }\n \n     pub(crate) fn resolve_completely<T>(&mut self, t: T) -> T\n@@ -452,13 +451,14 @@ impl<'a> InferenceTable<'a> {\n         f: impl FnOnce(&mut Self) -> T,\n     ) -> T {\n         use chalk_ir::fold::TypeFolder;\n+\n+        #[derive(chalk_derive::FallibleTypeFolder)]\n+        #[has_interner(Interner)]\n         struct VarFudger<'a, 'b> {\n             table: &'a mut InferenceTable<'b>,\n             highest_known_var: InferenceVar,\n         }\n         impl<'a, 'b> TypeFolder<Interner> for VarFudger<'a, 'b> {\n-            type Error = NoSolution;\n-\n             fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n                 self\n             }\n@@ -472,37 +472,37 @@ impl<'a> InferenceTable<'a> {\n                 var: chalk_ir::InferenceVar,\n                 kind: TyVariableKind,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Ty<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Ty<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_ty(Interner, kind)\n                 } else {\n                     self.table.new_type_var()\n-                })\n+                }\n             }\n \n             fn fold_inference_lifetime(\n                 &mut self,\n                 var: chalk_ir::InferenceVar,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Lifetime<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Lifetime<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_lifetime(Interner)\n                 } else {\n                     self.table.new_lifetime_var()\n-                })\n+                }\n             }\n \n             fn fold_inference_const(\n                 &mut self,\n                 ty: chalk_ir::Ty<Interner>,\n                 var: chalk_ir::InferenceVar,\n                 _outer_binder: chalk_ir::DebruijnIndex,\n-            ) -> chalk_ir::Fallible<chalk_ir::Const<Interner>> {\n-                Ok(if var < self.highest_known_var {\n+            ) -> chalk_ir::Const<Interner> {\n+                if var < self.highest_known_var {\n                     var.to_const(Interner, ty)\n                 } else {\n                     self.table.new_const_var(ty)\n-                })\n+                }\n             }\n         }\n \n@@ -512,7 +512,6 @@ impl<'a> InferenceTable<'a> {\n         self.rollback_to(snapshot);\n         result\n             .fold_with(&mut VarFudger { table: self, highest_known_var }, DebruijnIndex::INNERMOST)\n-            .expect(\"fold_with with VarFudger\")\n     }\n \n     /// This checks whether any of the free variables in the `canonicalized`\n@@ -639,21 +638,24 @@ mod resolve {\n     use chalk_ir::{\n         cast::Cast,\n         fold::{TypeFoldable, TypeFolder},\n-        Fallible, NoSolution,\n     };\n     use hir_def::type_ref::ConstScalar;\n \n-    pub(super) struct Resolver<'a, 'b, F> {\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    pub(super) struct Resolver<\n+        'a,\n+        'b,\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n+    > {\n         pub(super) table: &'a mut InferenceTable<'b>,\n         pub(super) var_stack: &'a mut Vec<InferenceVar>,\n         pub(super) fallback: F,\n     }\n-    impl<'a, 'b, 'i, F> TypeFolder<Interner> for Resolver<'a, 'b, F>\n+    impl<'a, 'b, F> TypeFolder<Interner> for Resolver<'a, 'b, F>\n     where\n-        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg + 'i,\n+        F: Fn(InferenceVar, VariableKind, GenericArg, DebruijnIndex) -> GenericArg,\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -667,20 +669,19 @@ mod resolve {\n             var: InferenceVar,\n             kind: TyVariableKind,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Ty> {\n+        ) -> Ty {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             if self.var_stack.contains(&var) {\n                 // recursive type\n                 let default = self.table.fallback_value(var, kind).cast(Interner);\n-                return Ok((self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n+                return (self.fallback)(var, VariableKind::Ty(kind), default, outer_binder)\n                     .assert_ty_ref(Interner)\n-                    .clone());\n+                    .clone();\n             }\n             let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n-                let result =\n-                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                let result = known_ty.fold_with(self, outer_binder);\n                 self.var_stack.pop();\n                 result.assert_ty_ref(Interner).clone()\n             } else {\n@@ -689,15 +690,15 @@ mod resolve {\n                     .assert_ty_ref(Interner)\n                     .clone()\n             };\n-            Ok(result)\n+            result\n         }\n \n         fn fold_inference_const(\n             &mut self,\n             ty: Ty,\n             var: InferenceVar,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Const> {\n+        ) -> Const {\n             let var = self.table.var_unification_table.inference_var_root(var);\n             let default = ConstData {\n                 ty: ty.clone(),\n@@ -707,35 +708,33 @@ mod resolve {\n             .cast(Interner);\n             if self.var_stack.contains(&var) {\n                 // recursive\n-                return Ok((self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n+                return (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n                     .assert_const_ref(Interner)\n-                    .clone());\n+                    .clone();\n             }\n-            let result = if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n+            if let Some(known_ty) = self.table.var_unification_table.probe_var(var) {\n                 // known_ty may contain other variables that are known by now\n                 self.var_stack.push(var);\n-                let result =\n-                    known_ty.fold_with(self, outer_binder).expect(\"fold failed unexpectedly\");\n+                let result = known_ty.fold_with(self, outer_binder);\n                 self.var_stack.pop();\n                 result.assert_const_ref(Interner).clone()\n             } else {\n                 (self.fallback)(var, VariableKind::Const(ty), default, outer_binder)\n                     .assert_const_ref(Interner)\n                     .clone()\n-            };\n-            Ok(result)\n+            }\n         }\n \n         fn fold_inference_lifetime(\n             &mut self,\n             _var: InferenceVar,\n             _outer_binder: DebruijnIndex,\n-        ) -> Fallible<Lifetime> {\n+        ) -> Lifetime {\n             // fall back all lifetimes to 'static -- currently we don't deal\n             // with any lifetimes, but we can sometimes get some lifetime\n             // variables through Chalk's unification, and this at least makes\n             // sure we don't leak them outside of inference\n-            Ok(crate::static_lifetime())\n+            crate::static_lifetime()\n         }\n     }\n }"}, {"sha": "c4b700cbce6db78284321f80bd956e9a4e5f5165", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -254,13 +254,13 @@ impl CallableSig {\n }\n \n impl TypeFoldable<Interner> for CallableSig {\n-    fn fold_with<E>(\n+    fn try_fold_with<E>(\n         self,\n-        folder: &mut dyn chalk_ir::fold::TypeFolder<Interner, Error = E>,\n+        folder: &mut dyn chalk_ir::fold::FallibleTypeFolder<Interner, Error = E>,\n         outer_binder: DebruijnIndex,\n     ) -> Result<Self, E> {\n         let vec = self.params_and_return.to_vec();\n-        let folded = vec.fold_with(folder, outer_binder)?;\n+        let folded = vec.try_fold_with(folder, outer_binder)?;\n         Ok(CallableSig { params_and_return: folded.into(), is_varargs: self.is_varargs })\n     }\n }\n@@ -292,16 +292,19 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + TypeFoldable<\n     for_ty: impl FnMut(BoundVar, DebruijnIndex) -> Ty,\n     for_const: impl FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n ) -> T {\n-    use chalk_ir::{fold::TypeFolder, Fallible};\n-    struct FreeVarFolder<F1, F2>(F1, F2);\n+    use chalk_ir::fold::TypeFolder;\n+\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    struct FreeVarFolder<\n+        F1: FnMut(BoundVar, DebruijnIndex) -> Ty,\n+        F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n+    >(F1, F2);\n     impl<\n-            'i,\n-            F1: FnMut(BoundVar, DebruijnIndex) -> Ty + 'i,\n-            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const + 'i,\n+            F1: FnMut(BoundVar, DebruijnIndex) -> Ty,\n+            F2: FnMut(Ty, BoundVar, DebruijnIndex) -> Const,\n         > TypeFolder<Interner> for FreeVarFolder<F1, F2>\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -310,25 +313,20 @@ pub(crate) fn fold_free_vars<T: HasInterner<Interner = Interner> + TypeFoldable<\n             Interner\n         }\n \n-        fn fold_free_var_ty(\n-            &mut self,\n-            bound_var: BoundVar,\n-            outer_binder: DebruijnIndex,\n-        ) -> Fallible<Ty> {\n-            Ok(self.0(bound_var, outer_binder))\n+        fn fold_free_var_ty(&mut self, bound_var: BoundVar, outer_binder: DebruijnIndex) -> Ty {\n+            self.0(bound_var, outer_binder)\n         }\n \n         fn fold_free_var_const(\n             &mut self,\n             ty: Ty,\n             bound_var: BoundVar,\n             outer_binder: DebruijnIndex,\n-        ) -> Fallible<Const> {\n-            Ok(self.1(ty, bound_var, outer_binder))\n+        ) -> Const {\n+            self.1(ty, bound_var, outer_binder)\n         }\n     }\n     t.fold_with(&mut FreeVarFolder(for_ty, for_const), DebruijnIndex::INNERMOST)\n-        .expect(\"fold failed unexpectedly\")\n }\n \n pub(crate) fn fold_tys<T: HasInterner<Interner = Interner> + TypeFoldable<Interner>>(\n@@ -351,16 +349,13 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n     f: impl FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>,\n     binders: DebruijnIndex,\n ) -> T {\n-    use chalk_ir::{\n-        fold::{TypeFolder, TypeSuperFoldable},\n-        Fallible,\n-    };\n-    struct TyFolder<F>(F);\n-    impl<'i, F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const> + 'i>\n-        TypeFolder<Interner> for TyFolder<F>\n+    use chalk_ir::fold::{TypeFolder, TypeSuperFoldable};\n+    #[derive(chalk_derive::FallibleTypeFolder)]\n+    #[has_interner(Interner)]\n+    struct TyFolder<F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>>(F);\n+    impl<F: FnMut(Either<Ty, Const>, DebruijnIndex) -> Either<Ty, Const>> TypeFolder<Interner>\n+        for TyFolder<F>\n     {\n-        type Error = NoSolution;\n-\n         fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n@@ -369,16 +364,16 @@ pub(crate) fn fold_tys_and_consts<T: HasInterner<Interner = Interner> + TypeFold\n             Interner\n         }\n \n-        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n-            let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-            Ok(self.0(Either::Left(ty), outer_binder).left().unwrap())\n+        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Ty {\n+            let ty = ty.super_fold_with(self.as_dyn(), outer_binder);\n+            self.0(Either::Left(ty), outer_binder).left().unwrap()\n         }\n \n-        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Fallible<Const> {\n-            Ok(self.0(Either::Right(c), outer_binder).right().unwrap())\n+        fn fold_const(&mut self, c: Const, outer_binder: DebruijnIndex) -> Const {\n+            self.0(Either::Right(c), outer_binder).right().unwrap()\n         }\n     }\n-    t.fold_with(&mut TyFolder(f), binders).expect(\"fold failed unexpectedly\")\n+    t.fold_with(&mut TyFolder(f), binders)\n }\n \n /// 'Canonicalizes' the `t` by replacing any errors with new variables. Also\n@@ -390,35 +385,34 @@ where\n     T: HasInterner<Interner = Interner>,\n {\n     use chalk_ir::{\n-        fold::{TypeFolder, TypeSuperFoldable},\n+        fold::{FallibleTypeFolder, TypeSuperFoldable},\n         Fallible,\n     };\n     struct ErrorReplacer {\n         vars: usize,\n     }\n-    impl TypeFolder<Interner> for ErrorReplacer {\n+    impl FallibleTypeFolder<Interner> for ErrorReplacer {\n         type Error = NoSolution;\n \n-        fn as_dyn(&mut self) -> &mut dyn TypeFolder<Interner, Error = Self::Error> {\n+        fn as_dyn(&mut self) -> &mut dyn FallibleTypeFolder<Interner, Error = Self::Error> {\n             self\n         }\n \n         fn interner(&self) -> Interner {\n             Interner\n         }\n \n-        fn fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n+        fn try_fold_ty(&mut self, ty: Ty, outer_binder: DebruijnIndex) -> Fallible<Ty> {\n             if let TyKind::Error = ty.kind(Interner) {\n                 let index = self.vars;\n                 self.vars += 1;\n                 Ok(TyKind::BoundVar(BoundVar::new(outer_binder, index)).intern(Interner))\n             } else {\n-                let ty = ty.super_fold_with(self.as_dyn(), outer_binder)?;\n-                Ok(ty)\n+                ty.try_super_fold_with(self.as_dyn(), outer_binder)\n             }\n         }\n \n-        fn fold_inference_ty(\n+        fn try_fold_inference_ty(\n             &mut self,\n             _var: InferenceVar,\n             _kind: TyVariableKind,\n@@ -433,7 +427,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_ty(\n+        fn try_fold_free_var_ty(\n             &mut self,\n             _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n@@ -447,7 +441,7 @@ where\n             }\n         }\n \n-        fn fold_inference_const(\n+        fn try_fold_inference_const(\n             &mut self,\n             ty: Ty,\n             _var: InferenceVar,\n@@ -460,7 +454,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_const(\n+        fn try_fold_free_var_const(\n             &mut self,\n             ty: Ty,\n             _bound_var: BoundVar,\n@@ -473,7 +467,7 @@ where\n             }\n         }\n \n-        fn fold_inference_lifetime(\n+        fn try_fold_inference_lifetime(\n             &mut self,\n             _var: InferenceVar,\n             _outer_binder: DebruijnIndex,\n@@ -485,7 +479,7 @@ where\n             }\n         }\n \n-        fn fold_free_var_lifetime(\n+        fn try_fold_free_var_lifetime(\n             &mut self,\n             _bound_var: BoundVar,\n             _outer_binder: DebruijnIndex,\n@@ -498,7 +492,7 @@ where\n         }\n     }\n     let mut error_replacer = ErrorReplacer { vars: 0 };\n-    let value = match t.clone().fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n+    let value = match t.clone().try_fold_with(&mut error_replacer, DebruijnIndex::INNERMOST) {\n         Ok(t) => t,\n         Err(_) => panic!(\"Encountered unbound or inference vars in {:?}\", t),\n     };"}, {"sha": "a79efeb6daa84dbc0a736ff01668dbcaa139b0e3", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -1111,6 +1111,24 @@ pub fn resolve_indexing_op(\n     }\n     None\n }\n+/// Returns the receiver type for the try branch trait call.\n+pub fn resolve_branch_op(\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    ty: Canonical<Ty>,\n+    try_trait: TraitId,\n+) -> Option<ReceiverAdjustments> {\n+    let mut table = InferenceTable::new(db, env.clone());\n+    let ty = table.instantiate_canonical(ty);\n+    let (deref_chain, adj) = autoderef_method_receiver(&mut table, ty);\n+    for (ty, adj) in deref_chain.into_iter().zip(adj) {\n+        let goal = generic_implements_goal(db, env.clone(), try_trait, &ty);\n+        if db.trait_solve(env.krate, goal.cast(Interner)).is_some() {\n+            return Some(adj);\n+        }\n+    }\n+    None\n+}\n \n macro_rules! check_that {\n     ($cond:expr) => {"}, {"sha": "8a8ff08cfe8cdab81a7250bdd273175ec3a47179", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/display_source_code.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -55,6 +55,28 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn render_dyn_ty_independent_of_order() {\n+    check_types_source_code(\n+        r#\"\n+auto trait Send {}\n+trait A {\n+    type Assoc;\n+}\n+trait B: A {}\n+\n+fn test(\n+    _: &(dyn A<Assoc = ()> + Send),\n+  //^ &(dyn A<Assoc = ()> + Send)\n+    _: &(dyn Send + A<Assoc = ()>),\n+  //^ &(dyn A<Assoc = ()> + Send)\n+    _: &dyn B<Assoc = ()>,\n+  //^ &(dyn B<Assoc = ()>)\n+) {}\n+        \"#,\n+    );\n+}\n+\n #[test]\n fn render_dyn_for_ty() {\n     // FIXME"}, {"sha": "74de33117ee7d6dff7a4f90fb79fabd3e77cb7b9", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/patterns.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -1070,3 +1070,13 @@ fn main() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn cfg_params() {\n+    check_types(\n+        r#\"\n+fn my_fn(#[cfg(feature = \"feature\")] u8: u8, u32: u32) {}\n+                                           //^^^ u32\n+\"#,\n+    );\n+}"}, {"sha": "b91172e33422d67ad40c74ad62f4167399240754", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 5, "deletions": 87, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -162,98 +162,16 @@ fn test() {\n     );\n }\n \n-#[test]\n-fn infer_try() {\n-    check_types(\n-        r#\"\n-//- /main.rs crate:main deps:core\n-fn test() {\n-    let r: Result<i32, u64> = Result::Ok(1);\n-    let v = r?;\n-    v;\n-} //^ i32\n-\n-//- /core.rs crate:core\n-pub mod ops {\n-    pub trait Try {\n-        type Ok;\n-        type Error;\n-    }\n-}\n-\n-pub mod result {\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> crate::ops::Try for Result<O, E> {\n-        type Ok = O;\n-        type Error = E;\n-    }\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::{result::*, ops::*};\n-    }\n-}\n-\"#,\n-    );\n-}\n-\n #[test]\n fn infer_try_trait_v2() {\n     check_types(\n         r#\"\n-//- /main.rs crate:main deps:core\n-fn test() {\n-    let r: Result<i32, u64> = Result::Ok(1);\n+//- minicore: try\n+fn test() -> core::ops::ControlFlow<u32, f32> {\n+    let r: core::ops::ControlFlow<u32, f32> = core::ops::ControlFlow::Continue(1.0);\n     let v = r?;\n-    v;\n-} //^ i32\n-\n-//- /core.rs crate:core\n-mod ops {\n-    mod try_trait {\n-        pub trait Try: FromResidual {\n-            type Output;\n-            type Residual;\n-        }\n-        pub trait FromResidual<R = <Self as Try>::Residual> {}\n-    }\n-\n-    pub use self::try_trait::FromResidual;\n-    pub use self::try_trait::Try;\n-}\n-\n-mod convert {\n-    pub trait From<T> {}\n-    impl<T> From<T> for T {}\n-}\n-\n-pub mod result {\n-    use crate::convert::From;\n-    use crate::ops::{Try, FromResidual};\n-\n-    pub enum Infallible {}\n-    pub enum Result<O, E> {\n-        Ok(O),\n-        Err(E)\n-    }\n-\n-    impl<O, E> Try for Result<O, E> {\n-        type Output = O;\n-        type Error = Result<Infallible, E>;\n-    }\n-\n-    impl<T, E, F: From<E>> FromResidual<Result<Infallible, E>> for Result<T, F> {}\n-}\n-\n-pub mod prelude {\n-    pub mod rust_2018 {\n-        pub use crate::result::*;\n-    }\n+      //^ f32\n+    r\n }\n \"#,\n     );"}, {"sha": "c425f35acfe7e188612bbd3827104793987eca5c", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -13,8 +13,8 @@ use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n-    Guidance, InEnvironment, Interner, ProjectionTy, Solution, TraitRefExt, Ty, TyKind,\n-    WhereClause,\n+    Guidance, InEnvironment, Interner, ProjectionTy, ProjectionTyExt, Solution, TraitRefExt, Ty,\n+    TyKind, WhereClause,\n };\n \n /// This controls how much 'time' we give the Chalk solver before giving up.\n@@ -95,7 +95,7 @@ pub(crate) fn trait_solve_query(\n         ..\n     }))) = &goal.value.goal.data(Interner)\n     {\n-        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(Interner).kind(Interner) {\n+        if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(db).kind(Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "e1418de3cdc24df1169a748178272863b1641565", "filename": "src/tools/rust-analyzer/crates/hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -13,9 +13,9 @@ doctest = false\n rustc-hash = \"1.1.0\"\n either = \"1.7.0\"\n arrayvec = \"0.7.2\"\n-itertools = \"0.10.3\"\n-smallvec = \"1.9.0\"\n-once_cell = \"1.12.0\"\n+itertools = \"0.10.5\"\n+smallvec = \"1.10.0\"\n+once_cell = \"1.15.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "6c8b3088adc0f1c56779c651136d18d06fea5712", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -6,7 +6,7 @@\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n-use hir_def::path::ModPath;\n+use hir_def::{path::ModPath, TraitId};\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n@@ -33,13 +33,15 @@ diagnostics![\n     BreakOutsideOfLoop,\n     InactiveCode,\n     IncorrectCase,\n+    IncorrectTryExpr,\n     InvalidDeriveTarget,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n     MissingFields,\n     MissingMatchArms,\n     MissingUnsafe,\n+    NotImplemented,\n     NoSuchField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n@@ -153,6 +155,16 @@ pub struct MismatchedArgCount {\n     pub expected: usize,\n     pub found: usize,\n }\n+#[derive(Debug)]\n+pub struct IncorrectTryExpr {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+}\n+#[derive(Debug)]\n+pub struct NotImplemented {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub trait_: TraitId,\n+    pub ty: Type,\n+}\n \n #[derive(Debug)]\n pub struct MissingMatchArms {"}, {"sha": "e6c5c6b5833980eaf9f8679fc5945c9ee3ec18dd", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -81,11 +81,12 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n-        MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n-        UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedModule, UnresolvedProcMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, IncorrectTryExpr,\n+        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n+        MissingMatchArms, MissingUnsafe, NoSuchField, NotImplemented,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall, UnresolvedModule,\n+        UnresolvedProcMacro,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1282,30 +1283,45 @@ impl DefWithBody {\n         let infer = db.infer(self.into());\n         let source_map = Lazy::new(|| db.body_with_source_map(self.into()).1);\n         for d in &infer.diagnostics {\n-            match d {\n+            match *d {\n                 hir_ty::InferenceDiagnostic::NoSuchField { expr } => {\n-                    let field = source_map.field_syntax(*expr);\n+                    let field = source_map.field_syntax(expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n+                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n                         .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n                     acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(*call_expr) {\n+                    match source_map.expr_syntax(call_expr) {\n                         Ok(source_ptr) => acc.push(\n                             MismatchedArgCount {\n                                 call_expr: source_ptr,\n-                                expected: *expected,\n-                                found: *found,\n+                                expected: expected,\n+                                found: found,\n                             }\n                             .into(),\n                         ),\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n+                hir_ty::InferenceDiagnostic::IncorrectTryTarget { expr } => {\n+                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n+                    acc.push(IncorrectTryExpr { expr }.into())\n+                }\n+                hir_ty::InferenceDiagnostic::DoesNotImplement { expr, trait_, ref ty } => {\n+                    let expr = source_map.expr_syntax(expr).expect(\"try in synthetic syntax\");\n+                    acc.push(\n+                        NotImplemented {\n+                            expr,\n+                            trait_,\n+                            ty: Type::new(db, DefWithBodyId::from(self), ty.clone()),\n+                        }\n+                        .into(),\n+                    )\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {"}, {"sha": "57a41f3d9a9378faa7c03994b83e53be9fdfc229", "filename": "src/tools/rust-analyzer/crates/ide-assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n \n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n either = \"1.7.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "678dc877d1381c69028953ac882dedc9d606b1e1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -156,6 +156,8 @@ pub(super) fn find_importable_node(\n     {\n         ImportAssets::for_method_call(&method_under_caret, &ctx.sema)\n             .zip(Some(method_under_caret.syntax().clone().into()))\n+    } else if let Some(_) = ctx.find_node_at_offset_with_descend::<ast::Param>() {\n+        None\n     } else if let Some(pat) = ctx\n         .find_node_at_offset_with_descend::<ast::IdentPat>()\n         .filter(ast::IdentPat::is_simple_ident)\n@@ -268,6 +270,20 @@ mod tests {\n         assert_eq!(labels, order);\n     }\n \n+    #[test]\n+    fn ignore_parameter_name() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            r\"\n+            mod foo {\n+                pub mod bar {}\n+            }\n+\n+            fn foo(bar$0: &str) {}\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn prefer_shorter_paths() {\n         let before = r\""}, {"sha": "8d11e0bac9413f24b8dcfbc72faff73e0bd602ef", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs", "status": "added", "additions": 822, "deletions": 0, "changes": 822, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_named_struct_to_tuple_struct.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -0,0 +1,822 @@\n+use either::Either;\n+use ide_db::defs::Definition;\n+use itertools::Itertools;\n+use syntax::{\n+    ast::{self, AstNode, HasGenericParams, HasVisibility},\n+    match_ast, SyntaxKind, SyntaxNode,\n+};\n+\n+use crate::{assist_context::SourceChangeBuilder, AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_named_struct_to_tuple_struct\n+//\n+// Converts struct with named fields to tuple struct, and analogously for enum variants with named\n+// fields.\n+//\n+// ```\n+// struct Point$0 { x: f32, y: f32 }\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point { x, y }\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.x\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.y\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Point(f32, f32);\n+//\n+// impl Point {\n+//     pub fn new(x: f32, y: f32) -> Self {\n+//         Point(x, y)\n+//     }\n+//\n+//     pub fn x(&self) -> f32 {\n+//         self.0\n+//     }\n+//\n+//     pub fn y(&self) -> f32 {\n+//         self.1\n+//     }\n+// }\n+// ```\n+pub(crate) fn convert_named_struct_to_tuple_struct(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    let strukt = ctx\n+        .find_node_at_offset::<ast::Struct>()\n+        .map(Either::Left)\n+        .or_else(|| ctx.find_node_at_offset::<ast::Variant>().map(Either::Right))?;\n+    let field_list = strukt.as_ref().either(|s| s.field_list(), |v| v.field_list())?;\n+    let record_fields = match field_list {\n+        ast::FieldList::RecordFieldList(it) => it,\n+        ast::FieldList::TupleFieldList(_) => return None,\n+    };\n+    let strukt_def = match &strukt {\n+        Either::Left(s) => Either::Left(ctx.sema.to_def(s)?),\n+        Either::Right(v) => Either::Right(ctx.sema.to_def(v)?),\n+    };\n+    let target = strukt.as_ref().either(|s| s.syntax(), |v| v.syntax()).text_range();\n+\n+    acc.add(\n+        AssistId(\"convert_named_struct_to_tuple_struct\", AssistKind::RefactorRewrite),\n+        \"Convert to tuple struct\",\n+        target,\n+        |edit| {\n+            edit_field_references(ctx, edit, record_fields.fields());\n+            edit_struct_references(ctx, edit, strukt_def);\n+            edit_struct_def(ctx, edit, &strukt, record_fields);\n+        },\n+    )\n+}\n+\n+fn edit_struct_def(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    strukt: &Either<ast::Struct, ast::Variant>,\n+    record_fields: ast::RecordFieldList,\n+) {\n+    let tuple_fields = record_fields\n+        .fields()\n+        .filter_map(|f| Some(ast::make::tuple_field(f.visibility(), f.ty()?)));\n+    let tuple_fields = ast::make::tuple_field_list(tuple_fields);\n+    let record_fields_text_range = record_fields.syntax().text_range();\n+\n+    edit.edit_file(ctx.file_id());\n+    edit.replace(record_fields_text_range, tuple_fields.syntax().text());\n+\n+    if let Either::Left(strukt) = strukt {\n+        if let Some(w) = strukt.where_clause() {\n+            let mut where_clause = w.to_string();\n+            if where_clause.ends_with(',') {\n+                where_clause.pop();\n+            }\n+            where_clause.push(';');\n+\n+            edit.delete(w.syntax().text_range());\n+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());\n+            edit.insert(record_fields_text_range.end(), where_clause);\n+            edit.insert(record_fields_text_range.end(), ast::make::tokens::single_newline().text());\n+\n+            if let Some(tok) = strukt\n+                .generic_param_list()\n+                .and_then(|l| l.r_angle_token())\n+                .and_then(|tok| tok.next_token())\n+                .filter(|tok| tok.kind() == SyntaxKind::WHITESPACE)\n+            {\n+                edit.delete(tok.text_range());\n+            }\n+        } else {\n+            edit.insert(record_fields_text_range.end(), \";\");\n+        }\n+    }\n+\n+    if let Some(tok) = record_fields\n+        .l_curly_token()\n+        .and_then(|tok| tok.prev_token())\n+        .filter(|tok| tok.kind() == SyntaxKind::WHITESPACE)\n+    {\n+        edit.delete(tok.text_range())\n+    }\n+}\n+\n+fn edit_struct_references(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    strukt: Either<hir::Struct, hir::Variant>,\n+) {\n+    let strukt_def = match strukt {\n+        Either::Left(s) => Definition::Adt(hir::Adt::Struct(s)),\n+        Either::Right(v) => Definition::Variant(v),\n+    };\n+    let usages = strukt_def.usages(&ctx.sema).include_self_refs().all();\n+\n+    let edit_node = |edit: &mut SourceChangeBuilder, node: SyntaxNode| -> Option<()> {\n+        match_ast! {\n+            match node {\n+                ast::RecordPat(record_struct_pat) => {\n+                    edit.replace(\n+                        record_struct_pat.syntax().text_range(),\n+                        ast::make::tuple_struct_pat(\n+                            record_struct_pat.path()?,\n+                            record_struct_pat\n+                                .record_pat_field_list()?\n+                                .fields()\n+                                .filter_map(|pat| pat.pat())\n+                        )\n+                        .to_string()\n+                    );\n+                },\n+                ast::RecordExpr(record_expr) => {\n+                    let path = record_expr.path()?;\n+                    let args = record_expr\n+                        .record_expr_field_list()?\n+                        .fields()\n+                        .filter_map(|f| f.expr())\n+                        .join(\", \");\n+\n+                    edit.replace(record_expr.syntax().text_range(), format!(\"{path}({args})\"));\n+                },\n+                _ => return None,\n+            }\n+        }\n+        Some(())\n+    };\n+\n+    for (file_id, refs) in usages {\n+        edit.edit_file(file_id);\n+        for r in refs {\n+            for node in r.name.syntax().ancestors() {\n+                if edit_node(edit, node).is_some() {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn edit_field_references(\n+    ctx: &AssistContext<'_>,\n+    edit: &mut SourceChangeBuilder,\n+    fields: impl Iterator<Item = ast::RecordField>,\n+) {\n+    for (index, field) in fields.enumerate() {\n+        let field = match ctx.sema.to_def(&field) {\n+            Some(it) => it,\n+            None => continue,\n+        };\n+        let def = Definition::Field(field);\n+        let usages = def.usages(&ctx.sema).all();\n+        for (file_id, refs) in usages {\n+            edit.edit_file(file_id);\n+            for r in refs {\n+                if let Some(name_ref) = r.name.as_name_ref() {\n+                    // Only edit the field reference if it's part of a `.field` access\n+                    if name_ref.syntax().parent().and_then(ast::FieldExpr::cast).is_some() {\n+                        edit.replace(name_ref.syntax().text_range(), index.to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_other_than_record_struct() {\n+        check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#\"struct Foo$0(u32)\"#);\n+        check_assist_not_applicable(convert_named_struct_to_tuple_struct, r#\"struct Foo$0;\"#);\n+    }\n+\n+    #[test]\n+    fn convert_simple_struct() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A { inner }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> A {\n+        A(inner)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_referenced_via_self_kw() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self { inner }\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn new(inner: Inner) -> Self {\n+        Self(inner)\n+    }\n+\n+    fn new_with_default() -> Self {\n+        Self::new(Inner)\n+    }\n+\n+    fn into_inner(self) -> Inner {\n+        self.0\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_struct() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A { inner: a } = self;\n+        a\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self { inner } = self;\n+        inner\n+    }\n+}\"#,\n+            r#\"\n+struct Inner;\n+struct A(Inner);\n+\n+impl A {\n+    fn into_inner(self) -> Inner {\n+        let A(a) = self;\n+        a\n+    }\n+\n+    fn into_inner_via_self(self) -> Inner {\n+        let Self(inner) = self;\n+        inner\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_visibility() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct A$0 {\n+    pub first: u32,\n+    pub(crate) second: u64\n+}\n+\n+impl A {\n+    fn new() -> A {\n+        A { first: 42, second: 42 }\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.first\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.second\n+    }\n+}\"#,\n+            r#\"\n+struct A(pub u32, pub(crate) u64);\n+\n+impl A {\n+    fn new() -> A {\n+        A(42, 42)\n+    }\n+\n+    fn into_first(self) -> u32 {\n+        self.0\n+    }\n+\n+    fn into_second(self) -> u64 {\n+        self.1\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_wrapped_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner$0 { uint: u32 }\n+struct Outer { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner { uint: 42 } }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner { uint: x } } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner(u32);\n+struct Outer { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner(42) }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.0\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner(x) } = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Inner { uint: u32 }\n+struct Outer$0 { inner: Inner }\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self { inner: Inner { uint: 42 } }\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.inner.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer { inner: Inner { uint: x } } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+struct Inner { uint: u32 }\n+struct Outer(Inner);\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self(Inner { uint: 42 })\n+    }\n+\n+    fn into_inner(self) -> u32 {\n+        self.0.uint\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer(Inner { uint: x }) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_multi_file_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A$0 { inner: Inner }\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A { inner: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+struct A(Inner);\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A(Inner);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_struct_with_where_clause() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+struct Wrap$0<T>\n+where\n+    T: Display,\n+{ field1: T }\n+\"#,\n+            r#\"\n+struct Wrap<T>(T)\n+where\n+    T: Display;\n+\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_other_than_record_variant() {\n+        check_assist_not_applicable(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"enum Enum { Variant$0(usize) };\"#,\n+        );\n+        check_assist_not_applicable(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"enum Enum { Variant$0 }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_simple_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        A::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        A::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            A::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_referenced_via_self_kw() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant { field1: value }\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant { field1: value } => value,\n+        }\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn new(value: usize) -> A {\n+        Self::Variant(value)\n+    }\n+\n+    fn new_with_default() -> A {\n+        Self::new(Default::default())\n+    }\n+\n+    fn value(self) -> usize {\n+        match self {\n+            Self::Variant(value) => value,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_destructured_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum A {\n+    $0Variant { field1: usize },\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant { field1: first } = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant { field1: first } = self;\n+        first\n+    }\n+}\"#,\n+            r#\"\n+enum A {\n+    Variant(usize),\n+}\n+\n+impl A {\n+    fn into_inner(self) -> usize {\n+        let A::Variant(first) = self;\n+        first\n+    }\n+\n+    fn into_inner_via_self(self) -> usize {\n+        let Self::Variant(first) = self;\n+        first\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_wrapped_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum Inner {\n+    $0Variant { field1: usize },\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant { field1: 42 })\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant { field1: x }) = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    $0Variant { field1: Inner },\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant { field1: Inner::Variant(42) }\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant { field1: Inner::Variant(x) } = self;\n+        x\n+    }\n+}\"#,\n+            r#\"\n+enum Inner {\n+    Variant(usize),\n+}\n+enum Outer {\n+    Variant(Inner),\n+}\n+\n+impl Outer {\n+    fn new() -> Self {\n+        Self::Variant(Inner::Variant(42))\n+    }\n+\n+    fn into_inner_destructed(self) -> u32 {\n+        let Outer::Variant(Inner::Variant(x)) = self;\n+        x\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_variant_with_multi_file_references() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant { field1: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A, Inner};\n+fn f() {\n+    let a = A::Variant(Inner);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_directly_used_variant() {\n+        check_assist(\n+            convert_named_struct_to_tuple_struct,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    $0Variant { field1: Inner },\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant { field1: Inner };\n+}\n+\"#,\n+            r#\"\n+//- /main.rs\n+struct Inner;\n+enum A {\n+    Variant(Inner),\n+}\n+\n+mod foo;\n+\n+//- /foo.rs\n+use crate::{A::Variant, Inner};\n+fn f() {\n+    let a = Variant(Inner);\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "970e948dfd930f4226be3c9697f0e19dead8d044", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 32, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -9,7 +9,7 @@ use ide_db::{\n     search::FileReference,\n     FxHashSet, RootDatabase,\n };\n-use itertools::{Itertools, Position};\n+use itertools::Itertools;\n use syntax::{\n     ast::{\n         self, edit::IndentLevel, edit_in_place::Indent, make, AstNode, HasAttrs, HasGenericParams,\n@@ -298,37 +298,7 @@ fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList\n     let name = variant.name()?;\n     let ty = generics\n         .filter(|generics| generics.generic_params().count() > 0)\n-        .map(|generics| {\n-            let mut generic_str = String::with_capacity(8);\n-\n-            for (p, more) in generics.generic_params().with_position().map(|p| match p {\n-                Position::First(p) | Position::Middle(p) => (p, true),\n-                Position::Last(p) | Position::Only(p) => (p, false),\n-            }) {\n-                match p {\n-                    ast::GenericParam::ConstParam(konst) => {\n-                        if let Some(name) = konst.name() {\n-                            generic_str.push_str(name.text().as_str());\n-                        }\n-                    }\n-                    ast::GenericParam::LifetimeParam(lt) => {\n-                        if let Some(lt) = lt.lifetime() {\n-                            generic_str.push_str(lt.text().as_str());\n-                        }\n-                    }\n-                    ast::GenericParam::TypeParam(ty) => {\n-                        if let Some(name) = ty.name() {\n-                            generic_str.push_str(name.text().as_str());\n-                        }\n-                    }\n-                }\n-                if more {\n-                    generic_str.push_str(\", \");\n-                }\n-            }\n-\n-            make::ty(&format!(\"{}<{}>\", &name.text(), &generic_str))\n-        })\n+        .map(|generics| make::ty(&format!(\"{}{}\", &name.text(), generics.to_generic_args())))\n         .unwrap_or_else(|| make::ty(&name.text()));\n \n     // change from a record to a tuple field list"}, {"sha": "8b67982f9158234b91afa04bf28c691b543b2d10", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -1,4 +1,4 @@\n-use hir::{HasSource, HirDisplay, Module, Semantics, TypeInfo};\n+use hir::{Adt, HasSource, HirDisplay, Module, Semantics, TypeInfo};\n use ide_db::{\n     base_db::FileId,\n     defs::{Definition, NameRefClass},\n@@ -145,7 +145,8 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n         return None;\n     }\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name.text().as_str())?;\n-    let (target, insert_offset) = get_method_target(ctx, &target_module, &impl_)?;\n+    let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n+\n     let function_builder =\n         FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n     let text_range = call.syntax().text_range();\n@@ -174,10 +175,11 @@ fn add_func_to_accumulator(\n     label: String,\n ) -> Option<()> {\n     acc.add(AssistId(\"generate_function\", AssistKind::Generate), label, text_range, |builder| {\n-        let function_template = function_builder.render();\n+        let indent = IndentLevel::from_node(function_builder.target.syntax());\n+        let function_template = function_builder.render(adt_name.is_some());\n         let mut func = function_template.to_string(ctx.config.snippet_cap);\n         if let Some(name) = adt_name {\n-            func = format!(\"\\nimpl {} {{\\n{}\\n}}\", name, func);\n+            func = format!(\"\\n{}impl {} {{\\n{}\\n{}}}\", indent, name, func, indent);\n         }\n         builder.edit_file(file);\n         match ctx.config.snippet_cap {\n@@ -307,7 +309,7 @@ impl FunctionBuilder {\n         })\n     }\n \n-    fn render(self) -> FunctionTemplate {\n+    fn render(self, is_method: bool) -> FunctionTemplate {\n         let placeholder_expr = make::ext::expr_todo();\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n         let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n@@ -325,8 +327,14 @@ impl FunctionBuilder {\n \n         match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n-                let indent = IndentLevel::from_node(&it);\n-                leading_ws = format!(\"\\n\\n{}\", indent);\n+                let mut indent = IndentLevel::from_node(&it);\n+                if is_method {\n+                    indent = indent + 1;\n+                    leading_ws = format!(\"{}\", indent);\n+                } else {\n+                    leading_ws = format!(\"\\n\\n{}\", indent);\n+                }\n+\n                 fn_def = fn_def.indent(indent);\n                 trailing_ws = String::new();\n             }\n@@ -411,14 +419,13 @@ fn get_fn_target(\n \n fn get_method_target(\n     ctx: &AssistContext<'_>,\n-    target_module: &Module,\n     impl_: &Option<ast::Impl>,\n+    adt: &Adt,\n ) -> Option<(GeneratedFunctionTarget, TextSize)> {\n     let target = match impl_ {\n         Some(impl_) => next_space_for_fn_in_impl(impl_)?,\n         None => {\n-            next_space_for_fn_in_module(ctx.sema.db, &target_module.definition_source(ctx.sema.db))?\n-                .1\n+            GeneratedFunctionTarget::BehindItem(adt.source(ctx.sema.db)?.syntax().value.clone())\n         }\n     };\n     Some((target.clone(), get_insert_offset(&target)))\n@@ -437,7 +444,7 @@ fn assoc_fn_target_info(\n         return None;\n     }\n     let (impl_, file) = get_adt_source(ctx, &adt, fn_name)?;\n-    let (target, insert_offset) = get_method_target(ctx, &module, &impl_)?;\n+    let (target, insert_offset) = get_method_target(ctx, &impl_, &adt)?;\n     let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n     Some(TargetInfo::new(target_module, adt_name, target, file, insert_offset))\n }\n@@ -1468,14 +1475,12 @@ fn foo() {S.bar$0();}\n \",\n             r\"\n struct S;\n-fn foo() {S.bar();}\n impl S {\n-\n-\n-fn bar(&self) ${0:-> _} {\n-    todo!()\n-}\n+    fn bar(&self) ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S.bar();}\n \",\n         )\n     }\n@@ -1516,14 +1521,12 @@ fn foo() {s::S.bar$0();}\n             r\"\n mod s {\n     pub struct S;\n-impl S {\n-\n-\n-    pub(crate) fn bar(&self) ${0:-> _} {\n-        todo!()\n+    impl S {\n+        pub(crate) fn bar(&self) ${0:-> _} {\n+            todo!()\n+        }\n     }\n }\n-}\n fn foo() {s::S.bar();}\n \",\n         )\n@@ -1544,18 +1547,16 @@ mod s {\n \",\n             r\"\n struct S;\n+impl S {\n+    fn bar(&self) ${0:-> _} {\n+        todo!()\n+    }\n+}\n mod s {\n     fn foo() {\n         super::S.bar();\n     }\n }\n-impl S {\n-\n-\n-fn bar(&self) ${0:-> _} {\n-    todo!()\n-}\n-}\n \n \",\n         )\n@@ -1571,14 +1572,12 @@ fn foo() {$0S.bar();}\n \",\n             r\"\n struct S;\n-fn foo() {S.bar();}\n impl S {\n-\n-\n-fn bar(&self) ${0:-> _} {\n-    todo!()\n-}\n+    fn bar(&self) ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S.bar();}\n \",\n         )\n     }\n@@ -1593,14 +1592,12 @@ fn foo() {S::bar$0();}\n \",\n             r\"\n struct S;\n-fn foo() {S::bar();}\n impl S {\n-\n-\n-fn bar() ${0:-> _} {\n-    todo!()\n-}\n+    fn bar() ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S::bar();}\n \",\n         )\n     }\n@@ -1641,14 +1638,12 @@ fn foo() {s::S::bar$0();}\n             r\"\n mod s {\n     pub struct S;\n-impl S {\n-\n-\n-    pub(crate) fn bar() ${0:-> _} {\n-        todo!()\n+    impl S {\n+        pub(crate) fn bar() ${0:-> _} {\n+            todo!()\n+        }\n     }\n }\n-}\n fn foo() {s::S::bar();}\n \",\n         )\n@@ -1664,14 +1659,12 @@ fn foo() {$0S::bar();}\n \",\n             r\"\n struct S;\n-fn foo() {S::bar();}\n impl S {\n-\n-\n-fn bar() ${0:-> _} {\n-    todo!()\n-}\n+    fn bar() ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn foo() {S::bar();}\n \",\n         )\n     }\n@@ -1841,15 +1834,13 @@ fn main() {\n \",\n             r\"\n enum Foo {}\n-fn main() {\n-    Foo::new();\n-}\n impl Foo {\n-\n-\n-fn new() ${0:-> _} {\n-    todo!()\n+    fn new() ${0:-> _} {\n+        todo!()\n+    }\n }\n+fn main() {\n+    Foo::new();\n }\n \",\n         )"}, {"sha": "307cea3d0a4f875aee3a92d954c133c0688c22c1", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/generate_impl.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -52,6 +52,7 @@ mod tests {\n \n     use super::*;\n \n+    // FIXME: break up into separate test fns\n     #[test]\n     fn test_add_impl() {\n         check_assist(\n@@ -134,6 +135,18 @@ mod tests {\n             }\"#,\n         );\n \n+        check_assist(\n+            generate_impl,\n+            r#\"\n+            struct Defaulted<const N: i32 = 0> {}$0\"#,\n+            r#\"\n+            struct Defaulted<const N: i32 = 0> {}\n+\n+            impl<const N: i32> Defaulted<N> {\n+                $0\n+            }\"#,\n+        );\n+\n         check_assist(\n             generate_impl,\n             r#\"pub trait Trait {}"}, {"sha": "a07318cefad273dbdb4410b12a670f06f86107f9", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -121,6 +121,7 @@ mod handlers {\n     mod convert_iter_for_each_to_for;\n     mod convert_let_else_to_match;\n     mod convert_tuple_struct_to_named_struct;\n+    mod convert_named_struct_to_tuple_struct;\n     mod convert_to_guarded_return;\n     mod convert_two_arm_bool_match_to_matches_macro;\n     mod convert_while_to_loop;\n@@ -218,6 +219,7 @@ mod handlers {\n             convert_iter_for_each_to_for::convert_iter_for_each_to_for,\n             convert_iter_for_each_to_for::convert_for_loop_with_for_each,\n             convert_let_else_to_match::convert_let_else_to_match,\n+            convert_named_struct_to_tuple_struct::convert_named_struct_to_tuple_struct,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n             convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,"}, {"sha": "f7f2417d0745d7a4088ed75a11f7241875bb5663", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -232,6 +232,7 @@ fn assist_order_field_struct() {\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a mut getter method\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Generate a setter method\");\n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Convert to tuple struct\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Add `#[derive]`\");\n }\n "}, {"sha": "2c4000efe0fa25a9f0c159d0c5f2f046ab04c9b5", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -407,6 +407,47 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_convert_named_struct_to_tuple_struct() {\n+    check_doc_test(\n+        \"convert_named_struct_to_tuple_struct\",\n+        r#####\"\n+struct Point$0 { x: f32, y: f32 }\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point { x, y }\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.x\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.y\n+    }\n+}\n+\"#####,\n+        r#####\"\n+struct Point(f32, f32);\n+\n+impl Point {\n+    pub fn new(x: f32, y: f32) -> Self {\n+        Point(x, y)\n+    }\n+\n+    pub fn x(&self) -> f32 {\n+        self.0\n+    }\n+\n+    pub fn y(&self) -> f32 {\n+        self.1\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_to_guarded_return() {\n     check_doc_test("}, {"sha": "38396cd7d7bafd47c36e4d4d473915cdc41f827a", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/utils.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Futils.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -2,8 +2,6 @@\n \n use std::ops;\n \n-use itertools::Itertools;\n-\n pub(crate) use gen_trait_fn_body::gen_trait_fn_body;\n use hir::{db::HirDatabase, HirDisplay, Semantics};\n use ide_db::{famous_defs::FamousDefs, path_transform::PathTransform, RootDatabase, SnippetCap};\n@@ -15,7 +13,7 @@ use syntax::{\n         edit_in_place::{AttrsOwnerEdit, Removable},\n         make, HasArgList, HasAttrs, HasGenericParams, HasName, HasTypeBounds, Whitespace,\n     },\n-    ted, AstNode, AstToken, Direction, SmolStr, SourceFile,\n+    ted, AstNode, AstToken, Direction, SourceFile,\n     SyntaxKind::*,\n     SyntaxNode, TextRange, TextSize, T,\n };\n@@ -424,34 +422,44 @@ pub(crate) fn generate_trait_impl_text(adt: &ast::Adt, trait_text: &str, code: &\n }\n \n fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str) -> String {\n-    let generic_params = adt.generic_param_list();\n+    // Ensure lifetime params are before type & const params\n+    let generic_params = adt.generic_param_list().map(|generic_params| {\n+        let lifetime_params =\n+            generic_params.lifetime_params().map(ast::GenericParam::LifetimeParam);\n+        let ty_or_const_params = generic_params.type_or_const_params().filter_map(|param| {\n+            // remove defaults since they can't be specified in impls\n+            match param {\n+                ast::TypeOrConstParam::Type(param) => {\n+                    let param = param.clone_for_update();\n+                    param.remove_default();\n+                    Some(ast::GenericParam::TypeParam(param))\n+                }\n+                ast::TypeOrConstParam::Const(param) => {\n+                    let param = param.clone_for_update();\n+                    param.remove_default();\n+                    Some(ast::GenericParam::ConstParam(param))\n+                }\n+            }\n+        });\n+\n+        make::generic_param_list(itertools::chain(lifetime_params, ty_or_const_params))\n+    });\n+\n+    // FIXME: use syntax::make & mutable AST apis instead\n+    // `trait_text` and `code` can't be opaque blobs of text\n     let mut buf = String::with_capacity(code.len());\n+\n+    // Copy any cfg attrs from the original adt\n     buf.push_str(\"\\n\\n\");\n-    adt.attrs()\n-        .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == \"cfg\").unwrap_or(false))\n-        .for_each(|attr| buf.push_str(format!(\"{}\\n\", attr).as_str()));\n+    let cfg_attrs = adt\n+        .attrs()\n+        .filter(|attr| attr.as_simple_call().map(|(name, _arg)| name == \"cfg\").unwrap_or(false));\n+    cfg_attrs.for_each(|attr| buf.push_str(&format!(\"{attr}\\n\")));\n+\n+    // `impl{generic_params} {trait_text} for {name}{generic_params.to_generic_args()}`\n     buf.push_str(\"impl\");\n     if let Some(generic_params) = &generic_params {\n-        let lifetimes = generic_params.lifetime_params().map(|lt| format!(\"{}\", lt.syntax()));\n-        let toc_params = generic_params.type_or_const_params().map(|toc_param| {\n-            let type_param = match toc_param {\n-                ast::TypeOrConstParam::Type(x) => x,\n-                ast::TypeOrConstParam::Const(x) => return x.syntax().to_string(),\n-            };\n-            let mut buf = String::new();\n-            if let Some(it) = type_param.name() {\n-                format_to!(buf, \"{}\", it.syntax());\n-            }\n-            if let Some(it) = type_param.colon_token() {\n-                format_to!(buf, \"{} \", it);\n-            }\n-            if let Some(it) = type_param.type_bound_list() {\n-                format_to!(buf, \"{}\", it.syntax());\n-            }\n-            buf\n-        });\n-        let generics = lifetimes.chain(toc_params).format(\", \");\n-        format_to!(buf, \"<{}>\", generics);\n+        format_to!(buf, \"{generic_params}\");\n     }\n     buf.push(' ');\n     if let Some(trait_text) = trait_text {\n@@ -460,23 +468,15 @@ fn generate_impl_text_inner(adt: &ast::Adt, trait_text: Option<&str>, code: &str\n     }\n     buf.push_str(&adt.name().unwrap().text());\n     if let Some(generic_params) = generic_params {\n-        let lifetime_params = generic_params\n-            .lifetime_params()\n-            .filter_map(|it| it.lifetime())\n-            .map(|it| SmolStr::from(it.text()));\n-        let toc_params = generic_params\n-            .type_or_const_params()\n-            .filter_map(|it| it.name())\n-            .map(|it| SmolStr::from(it.text()));\n-        format_to!(buf, \"<{}>\", lifetime_params.chain(toc_params).format(\", \"))\n+        format_to!(buf, \"{}\", generic_params.to_generic_args());\n     }\n \n     match adt.where_clause() {\n         Some(where_clause) => {\n-            format_to!(buf, \"\\n{}\\n{{\\n{}\\n}}\", where_clause, code);\n+            format_to!(buf, \"\\n{where_clause}\\n{{\\n{code}\\n}}\");\n         }\n         None => {\n-            format_to!(buf, \" {{\\n{}\\n}}\", code);\n+            format_to!(buf, \" {{\\n{code}\\n}}\");\n         }\n     }\n "}, {"sha": "75835bce95da19749e2b6abfc7416950d04aa6c0", "filename": "src/tools/rust-analyzer/crates/ide-completion/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -11,10 +11,10 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n \n-once_cell = \"1.12.0\"\n-smallvec = \"1.9.0\"\n+once_cell = \"1.15.0\"\n+smallvec = \"1.10.0\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "296dfc14250f75013e748352511adcf8b26ff066", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -19,6 +19,7 @@ pub(crate) mod snippet;\n pub(crate) mod r#type;\n pub(crate) mod use_;\n pub(crate) mod vis;\n+pub(crate) mod env_vars;\n \n use std::iter;\n "}, {"sha": "09e95e53de63ce42f31791d8c092a2772b4e9501", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/env_vars.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -0,0 +1,150 @@\n+//! Completes environment variables defined by Cargo (https://doc.rust-lang.org/cargo/reference/environment-variables.html)\n+use hir::Semantics;\n+use ide_db::{syntax_helpers::node_ext::macro_call_for_string_token, RootDatabase};\n+use syntax::ast::{self, IsString};\n+\n+use crate::{\n+    completions::Completions, context::CompletionContext, CompletionItem, CompletionItemKind,\n+};\n+\n+const CARGO_DEFINED_VARS: &[(&str, &str)] = &[\n+    (\"CARGO\",\"Path to the cargo binary performing the build\"),\n+    (\"CARGO_MANIFEST_DIR\",\"The directory containing the manifest of your package\"),\n+    (\"CARGO_PKG_VERSION\",\"The full version of your package\"),\n+    (\"CARGO_PKG_VERSION_MAJOR\",\"The major version of your package\"),\n+    (\"CARGO_PKG_VERSION_MINOR\",\"The minor version of your package\"),\n+    (\"CARGO_PKG_VERSION_PATCH\",\"The patch version of your package\"),\n+    (\"CARGO_PKG_VERSION_PRE\",\"The pre-release version of your package\"),\n+    (\"CARGO_PKG_AUTHORS\",\"Colon separated list of authors from the manifest of your package\"),\n+    (\"CARGO_PKG_NAME\",\"The name of your package\"),\n+    (\"CARGO_PKG_DESCRIPTION\",\"The description from the manifest of your package\"),\n+    (\"CARGO_PKG_HOMEPAGE\",\"The home page from the manifest of your package\"),\n+    (\"CARGO_PKG_REPOSITORY\",\"The repository from the manifest of your package\"),\n+    (\"CARGO_PKG_LICENSE\",\"The license from the manifest of your package\"),\n+    (\"CARGO_PKG_LICENSE_FILE\",\"The license file from the manifest of your package\"),\n+    (\"CARGO_PKG_RUST_VERSION\",\"The Rust version from the manifest of your package. Note that this is the minimum Rust version supported by the package, not the current Rust version\"),\n+    (\"CARGO_CRATE_NAME\",\"The name of the crate that is currently being compiled\"),\n+    (\"CARGO_BIN_NAME\",\"The name of the binary that is currently being compiled (if it is a binary). This name does not include any file extension, such as .exe\"),\n+    (\"CARGO_PRIMARY_PACKAGE\",\"This environment variable will be set if the package being built is primary. Primary packages are the ones the user selected on the command-line, either with -p flags or the defaults based on the current directory and the default workspace members. This environment variable will not be set when building dependencies. This is only set when compiling the package (not when running binaries or tests)\"),\n+    (\"CARGO_TARGET_TMPDIR\",\"Only set when building integration test or benchmark code. This is a path to a directory inside the target directory where integration tests or benchmarks are free to put any data needed by the tests/benches. Cargo initially creates this directory but doesn't manage its content in any way, this is the responsibility of the test code\")\n+];\n+\n+pub(crate) fn complete_cargo_env_vars(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext<'_>,\n+    expanded: &ast::String,\n+) -> Option<()> {\n+    guard_env_macro(expanded, &ctx.sema)?;\n+    let range = expanded.text_range_between_quotes()?;\n+\n+    CARGO_DEFINED_VARS.iter().for_each(|(var, detail)| {\n+        let mut item = CompletionItem::new(CompletionItemKind::Keyword, range, var);\n+        item.detail(*detail);\n+        item.add_to(acc);\n+    });\n+\n+    Some(())\n+}\n+\n+fn guard_env_macro(string: &ast::String, semantics: &Semantics<'_, RootDatabase>) -> Option<()> {\n+    let call = macro_call_for_string_token(string)?;\n+    let name = call.path()?.segment()?.name_ref()?;\n+    let makro = semantics.resolve_macro_call(&call)?;\n+    let db = semantics.db;\n+\n+    match name.text().as_str() {\n+        \"env\" | \"option_env\" if makro.kind(db) == hir::MacroKind::BuiltIn => Some(()),\n+        _ => None,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_edit, completion_list};\n+\n+    fn check(macro_name: &str) {\n+        check_edit(\n+            \"CARGO_BIN_NAME\",\n+            &format!(\n+                r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! {} {{\n+                ($var:literal) => {{ 0 }}\n+            }}\n+\n+            fn main() {{\n+                let foo = {}!(\"CAR$0\");\n+            }}\n+        \"#,\n+                macro_name, macro_name\n+            ),\n+            &format!(\n+                r#\"\n+            #[rustc_builtin_macro]\n+            macro_rules! {} {{\n+                ($var:literal) => {{ 0 }}\n+            }}\n+\n+            fn main() {{\n+                let foo = {}!(\"CARGO_BIN_NAME\");\n+            }}\n+        \"#,\n+                macro_name, macro_name\n+            ),\n+        );\n+    }\n+    #[test]\n+    fn completes_env_variable_in_env() {\n+        check(\"env\")\n+    }\n+\n+    #[test]\n+    fn completes_env_variable_in_option_env() {\n+        check(\"option_env\");\n+    }\n+\n+    #[test]\n+    fn doesnt_complete_in_random_strings() {\n+        let fixture = r#\"\n+            fn main() {\n+                let foo = \"CA$0\";\n+            }\n+        \"#;\n+\n+        let completions = completion_list(fixture);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions);\n+    }\n+\n+    #[test]\n+    fn doesnt_complete_in_random_macro() {\n+        let fixture = r#\"\n+            macro_rules! bar {\n+                ($($arg:tt)*) => { 0 }\n+            }\n+\n+            fn main() {\n+                let foo = bar!(\"CA$0\");\n+\n+            }\n+        \"#;\n+\n+        let completions = completion_list(fixture);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions);\n+    }\n+\n+    #[test]\n+    fn doesnt_complete_for_shadowed_macro() {\n+        let fixture = r#\"\n+            macro_rules! env {\n+                ($var:literal) => { 0 }\n+            }\n+\n+            fn main() {\n+                let foo = env!(\"CA$0\");\n+            }\n+        \"#;\n+\n+        let completions = completion_list(fixture);\n+        assert!(completions.is_empty(), \"Completions weren't empty: {}\", completions)\n+    }\n+}"}, {"sha": "9850813a0ce1c1b936f9671e67b838815cfa7f74", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -1,4 +1,4 @@\n-//! See `CompletionContext` structure.\n+//! See [`CompletionContext`] structure.\n \n mod analysis;\n #[cfg(test)]\n@@ -23,7 +23,10 @@ use syntax::{\n };\n use text_edit::Indel;\n \n-use crate::CompletionConfig;\n+use crate::{\n+    context::analysis::{expand_and_analyze, AnalysisResult},\n+    CompletionConfig,\n+};\n \n const COMPLETION_MARKER: &str = \"intellijRulezz\";\n \n@@ -561,15 +564,27 @@ impl<'a> CompletionContext<'a> {\n             let edit = Indel::insert(offset, COMPLETION_MARKER.to_string());\n             parse.reparse(&edit).tree()\n         };\n-        let fake_ident_token =\n-            file_with_fake_ident.syntax().token_at_offset(offset).right_biased()?;\n \n+        // always pick the token to the immediate left of the cursor, as that is what we are actually\n+        // completing on\n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n-        let token = sema.descend_into_macros_single(original_token.clone());\n+\n+        let AnalysisResult {\n+            analysis,\n+            expected: (expected_type, expected_name),\n+            qualifier_ctx,\n+            token,\n+            offset,\n+        } = expand_and_analyze(\n+            &sema,\n+            original_file.syntax().clone(),\n+            file_with_fake_ident.syntax().clone(),\n+            offset,\n+            &original_token,\n+        )?;\n \n         // adjust for macro input, this still fails if there is no token written yet\n-        let scope_offset = if original_token == token { offset } else { token.text_range().end() };\n-        let scope = sema.scope_at_offset(&token.parent()?, scope_offset)?;\n+        let scope = sema.scope_at_offset(&token.parent()?, offset)?;\n \n         let krate = scope.krate();\n         let module = scope.module();\n@@ -583,7 +598,7 @@ impl<'a> CompletionContext<'a> {\n \n         let depth_from_crate_root = iter::successors(module.parent(db), |m| m.parent(db)).count();\n \n-        let mut ctx = CompletionContext {\n+        let ctx = CompletionContext {\n             sema,\n             scope,\n             db,\n@@ -593,19 +608,13 @@ impl<'a> CompletionContext<'a> {\n             token,\n             krate,\n             module,\n-            expected_name: None,\n-            expected_type: None,\n-            qualifier_ctx: Default::default(),\n+            expected_name,\n+            expected_type,\n+            qualifier_ctx,\n             locals,\n             depth_from_crate_root,\n         };\n-        let ident_ctx = ctx.expand_and_analyze(\n-            original_file.syntax().clone(),\n-            file_with_fake_ident.syntax().clone(),\n-            offset,\n-            fake_ident_token,\n-        )?;\n-        Some((ctx, ident_ctx))\n+        Some((ctx, analysis))\n     }\n }\n "}, {"sha": "04111ec7efaa68e4dad225e25a8a220861d6b490", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 985, "deletions": 954, "changes": 1939, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -11,1063 +11,1094 @@ use syntax::{\n };\n \n use crate::context::{\n-    AttrCtx, CompletionAnalysis, CompletionContext, DotAccess, DotAccessKind, ExprCtx,\n-    ItemListKind, LifetimeContext, LifetimeKind, NameContext, NameKind, NameRefContext,\n-    NameRefKind, ParamContext, ParamKind, PathCompletionCtx, PathKind, PatternContext,\n-    PatternRefutability, Qualified, QualifierCtx, TypeAscriptionTarget, TypeLocation,\n-    COMPLETION_MARKER,\n+    AttrCtx, CompletionAnalysis, DotAccess, DotAccessKind, ExprCtx, ItemListKind, LifetimeContext,\n+    LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamContext, ParamKind,\n+    PathCompletionCtx, PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx,\n+    TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n };\n \n-impl<'a> CompletionContext<'a> {\n-    /// Expand attributes and macro calls at the current cursor position for both the original file\n-    /// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n-    /// and speculative states stay in sync.\n-    pub(super) fn expand_and_analyze(\n-        &mut self,\n-        mut original_file: SyntaxNode,\n-        mut speculative_file: SyntaxNode,\n-        mut offset: TextSize,\n-        mut fake_ident_token: SyntaxToken,\n-    ) -> Option<CompletionAnalysis> {\n-        let _p = profile::span(\"CompletionContext::expand_and_fill\");\n-        let mut derive_ctx = None;\n-\n-        'expansion: loop {\n-            let parent_item =\n-                |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n-            let ancestor_items = iter::successors(\n-                Option::zip(\n-                    find_node_at_offset::<ast::Item>(&original_file, offset),\n-                    find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+struct ExpansionResult {\n+    original_file: SyntaxNode,\n+    speculative_file: SyntaxNode,\n+    offset: TextSize,\n+    fake_ident_token: SyntaxToken,\n+    derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n+}\n+\n+pub(super) struct AnalysisResult {\n+    pub(super) analysis: CompletionAnalysis,\n+    pub(super) expected: (Option<Type>, Option<ast::NameOrNameRef>),\n+    pub(super) qualifier_ctx: QualifierCtx,\n+    pub(super) token: SyntaxToken,\n+    pub(super) offset: TextSize,\n+}\n+\n+pub(super) fn expand_and_analyze(\n+    sema: &Semantics<'_, RootDatabase>,\n+    original_file: SyntaxNode,\n+    speculative_file: SyntaxNode,\n+    offset: TextSize,\n+    original_token: &SyntaxToken,\n+) -> Option<AnalysisResult> {\n+    // as we insert after the offset, right biased will *always* pick the identifier no matter\n+    // if there is an ident already typed or not\n+    let fake_ident_token = speculative_file.token_at_offset(offset).right_biased()?;\n+    // the relative offset between the cursor and the *identifier* token we are completing on\n+    let relative_offset = offset - fake_ident_token.text_range().start();\n+    // make the offset point to the start of the original token, as that is what the\n+    // intermediate offsets calculated in expansion always points to\n+    let offset = offset - relative_offset;\n+    let expansion = expand(sema, original_file, speculative_file, offset, fake_ident_token);\n+    // add the relative offset back, so that left_biased finds the proper token\n+    let offset = expansion.offset + relative_offset;\n+    let token = expansion.original_file.token_at_offset(offset).left_biased()?;\n+\n+    analyze(sema, expansion, original_token, &token).map(|(analysis, expected, qualifier_ctx)| {\n+        AnalysisResult { analysis, expected, qualifier_ctx, token, offset }\n+    })\n+}\n+\n+/// Expand attributes and macro calls at the current cursor position for both the original file\n+/// and fake file repeatedly. As soon as one of the two expansions fail we stop so the original\n+/// and speculative states stay in sync.\n+fn expand(\n+    sema: &Semantics<'_, RootDatabase>,\n+    mut original_file: SyntaxNode,\n+    mut speculative_file: SyntaxNode,\n+    mut offset: TextSize,\n+    mut fake_ident_token: SyntaxToken,\n+) -> ExpansionResult {\n+    let _p = profile::span(\"CompletionContext::expand\");\n+    let mut derive_ctx = None;\n+\n+    'expansion: loop {\n+        let parent_item =\n+            |item: &ast::Item| item.syntax().ancestors().skip(1).find_map(ast::Item::cast);\n+        let ancestor_items = iter::successors(\n+            Option::zip(\n+                find_node_at_offset::<ast::Item>(&original_file, offset),\n+                find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+            ),\n+            |(a, b)| parent_item(a).zip(parent_item(b)),\n+        );\n+\n+        // first try to expand attributes as these are always the outermost macro calls\n+        'ancestors: for (actual_item, item_with_fake_ident) in ancestor_items {\n+            match (\n+                sema.expand_attr_macro(&actual_item),\n+                sema.speculative_expand_attr_macro(\n+                    &actual_item,\n+                    &item_with_fake_ident,\n+                    fake_ident_token.clone(),\n                 ),\n-                |(a, b)| parent_item(a).zip(parent_item(b)),\n-            );\n-\n-            // first try to expand attributes as these are always the outermost macro calls\n-            'ancestors: for (actual_item, item_with_fake_ident) in ancestor_items {\n-                match (\n-                    self.sema.expand_attr_macro(&actual_item),\n-                    self.sema.speculative_expand_attr_macro(\n-                        &actual_item,\n-                        &item_with_fake_ident,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    // maybe parent items have attributes, so continue walking the ancestors\n-                    (None, None) => continue 'ancestors,\n-                    // successful expansions\n-                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n-                        let new_offset = fake_mapped_token.text_range().start();\n-                        if new_offset > actual_expansion.text_range().end() {\n-                            // offset outside of bounds from the original expansion,\n-                            // stop here to prevent problems from happening\n-                            break 'expansion;\n-                        }\n-                        original_file = actual_expansion;\n-                        speculative_file = fake_expansion;\n-                        fake_ident_token = fake_mapped_token;\n-                        offset = new_offset;\n-                        continue 'expansion;\n+            ) {\n+                // maybe parent items have attributes, so continue walking the ancestors\n+                (None, None) => continue 'ancestors,\n+                // successful expansions\n+                (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                    let new_offset = fake_mapped_token.text_range().start();\n+                    if new_offset > actual_expansion.text_range().end() {\n+                        // offset outside of bounds from the original expansion,\n+                        // stop here to prevent problems from happening\n+                        break 'expansion;\n                     }\n-                    // exactly one expansion failed, inconsistent state so stop expanding completely\n-                    _ => break 'expansion,\n+                    original_file = actual_expansion;\n+                    speculative_file = fake_expansion;\n+                    fake_ident_token = fake_mapped_token;\n+                    offset = new_offset;\n+                    continue 'expansion;\n                 }\n+                // exactly one expansion failed, inconsistent state so stop expanding completely\n+                _ => break 'expansion,\n             }\n+        }\n \n-            // No attributes have been expanded, so look for macro_call! token trees or derive token trees\n-            let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n-                Some(it) => it,\n-                None => break 'expansion,\n-            };\n-            let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n-                Some(it) => it,\n-                None => break 'expansion,\n-            };\n+        // No attributes have been expanded, so look for macro_call! token trees or derive token trees\n+        let orig_tt = match find_node_at_offset::<ast::TokenTree>(&original_file, offset) {\n+            Some(it) => it,\n+            None => break 'expansion,\n+        };\n+        let spec_tt = match find_node_at_offset::<ast::TokenTree>(&speculative_file, offset) {\n+            Some(it) => it,\n+            None => break 'expansion,\n+        };\n \n-            // Expand pseudo-derive expansion\n-            if let (Some(orig_attr), Some(spec_attr)) = (\n-                orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n-                spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+        // Expand pseudo-derive expansion\n+        if let (Some(orig_attr), Some(spec_attr)) = (\n+            orig_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+            spec_tt.syntax().parent().and_then(ast::Meta::cast).and_then(|it| it.parent_attr()),\n+        ) {\n+            if let (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) = (\n+                sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n+                sema.speculative_expand_derive_as_pseudo_attr_macro(\n+                    &orig_attr,\n+                    &spec_attr,\n+                    fake_ident_token.clone(),\n+                ),\n             ) {\n-                if let (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) = (\n-                    self.sema.expand_derive_as_pseudo_attr_macro(&orig_attr),\n-                    self.sema.speculative_expand_derive_as_pseudo_attr_macro(\n-                        &orig_attr,\n-                        &spec_attr,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    derive_ctx = Some((\n-                        actual_expansion,\n-                        fake_expansion,\n-                        fake_mapped_token.text_range().start(),\n-                        orig_attr,\n-                    ));\n-                }\n-                // at this point we won't have any more successful expansions, so stop\n+                derive_ctx = Some((\n+                    actual_expansion,\n+                    fake_expansion,\n+                    fake_mapped_token.text_range().start(),\n+                    orig_attr,\n+                ));\n+            }\n+            // at this point we won't have any more successful expansions, so stop\n+            break 'expansion;\n+        }\n+\n+        // Expand fn-like macro calls\n+        if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+            orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+            spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+        ) {\n+            let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n+            let mac_call_path1 =\n+                macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n+\n+            // inconsistent state, stop expanding\n+            if mac_call_path0 != mac_call_path1 {\n                 break 'expansion;\n             }\n+            let speculative_args = match macro_call_with_fake_ident.token_tree() {\n+                Some(tt) => tt,\n+                None => break 'expansion,\n+            };\n \n-            // Expand fn-like macro calls\n-            if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-                orig_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n-                spec_tt.syntax().ancestors().find_map(ast::MacroCall::cast),\n+            match (\n+                sema.expand(&actual_macro_call),\n+                sema.speculative_expand(\n+                    &actual_macro_call,\n+                    &speculative_args,\n+                    fake_ident_token.clone(),\n+                ),\n             ) {\n-                let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n-                let mac_call_path1 =\n-                    macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n-\n-                // inconsistent state, stop expanding\n-                if mac_call_path0 != mac_call_path1 {\n-                    break 'expansion;\n-                }\n-                let speculative_args = match macro_call_with_fake_ident.token_tree() {\n-                    Some(tt) => tt,\n-                    None => break 'expansion,\n-                };\n-\n-                match (\n-                    self.sema.expand(&actual_macro_call),\n-                    self.sema.speculative_expand(\n-                        &actual_macro_call,\n-                        &speculative_args,\n-                        fake_ident_token.clone(),\n-                    ),\n-                ) {\n-                    // successful expansions\n-                    (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n-                        let new_offset = fake_mapped_token.text_range().start();\n-                        if new_offset > actual_expansion.text_range().end() {\n-                            // offset outside of bounds from the original expansion,\n-                            // stop here to prevent problems from happening\n-                            break 'expansion;\n-                        }\n-                        original_file = actual_expansion;\n-                        speculative_file = fake_expansion;\n-                        fake_ident_token = fake_mapped_token;\n-                        offset = new_offset;\n-                        continue 'expansion;\n+                // successful expansions\n+                (Some(actual_expansion), Some((fake_expansion, fake_mapped_token))) => {\n+                    let new_offset = fake_mapped_token.text_range().start();\n+                    if new_offset > actual_expansion.text_range().end() {\n+                        // offset outside of bounds from the original expansion,\n+                        // stop here to prevent problems from happening\n+                        break 'expansion;\n                     }\n-                    // at least on expansion failed, we won't have anything to expand from this point\n-                    // onwards so break out\n-                    _ => break 'expansion,\n+                    original_file = actual_expansion;\n+                    speculative_file = fake_expansion;\n+                    fake_ident_token = fake_mapped_token;\n+                    offset = new_offset;\n+                    continue 'expansion;\n                 }\n+                // at least on expansion failed, we won't have anything to expand from this point\n+                // onwards so break out\n+                _ => break 'expansion,\n             }\n-\n-            // none of our states have changed so stop the loop\n-            break 'expansion;\n         }\n \n-        self.analyze(&original_file, speculative_file, offset, derive_ctx)\n+        // none of our states have changed so stop the loop\n+        break 'expansion;\n     }\n+    ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx }\n+}\n \n-    /// Calculate the expected type and name of the cursor position.\n-    fn expected_type_and_name(\n-        &self,\n-        name_like: &ast::NameLike,\n-    ) -> (Option<Type>, Option<NameOrNameRef>) {\n-        let mut node = match self.token.parent() {\n-            Some(it) => it,\n-            None => return (None, None),\n-        };\n+/// Fill the completion context, this is what does semantic reasoning about the surrounding context\n+/// of the completion location.\n+fn analyze(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expansion_result: ExpansionResult,\n+    original_token: &SyntaxToken,\n+    self_token: &SyntaxToken,\n+) -> Option<(CompletionAnalysis, (Option<Type>, Option<ast::NameOrNameRef>), QualifierCtx)> {\n+    let _p = profile::span(\"CompletionContext::analyze\");\n+    let ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx } =\n+        expansion_result;\n+    let syntax_element = NodeOrToken::Token(fake_ident_token);\n+    if is_in_token_of_for_loop(syntax_element.clone()) {\n+        // for pat $0\n+        // there is nothing to complete here except `in` keyword\n+        // don't bother populating the context\n+        // FIXME: the completion calculations should end up good enough\n+        // such that this special case becomes unnecessary\n+        return None;\n+    }\n \n-        let strip_refs = |mut ty: Type| match name_like {\n-            ast::NameLike::NameRef(n) => {\n-                let p = match n.syntax().parent() {\n-                    Some(it) => it,\n-                    None => return ty,\n-                };\n-                let top_syn = match_ast! {\n-                    match p {\n-                        ast::FieldExpr(e) => e\n-                            .syntax()\n-                            .ancestors()\n-                            .map_while(ast::FieldExpr::cast)\n-                            .last()\n-                            .map(|it| it.syntax().clone()),\n-                        ast::PathSegment(e) => e\n-                            .syntax()\n-                            .ancestors()\n-                            .skip(1)\n-                            .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n-                            .find_map(ast::PathExpr::cast)\n-                            .map(|it| it.syntax().clone()),\n-                        _ => None\n-                    }\n+    // Overwrite the path kind for derives\n+    if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n+        if let Some(ast::NameLike::NameRef(name_ref)) =\n+            find_node_at_offset(&file_with_fake_ident, offset)\n+        {\n+            let parent = name_ref.syntax().parent()?;\n+            let (mut nameref_ctx, _) = classify_name_ref(&sema, &original_file, name_ref, parent)?;\n+            if let NameRefKind::Path(path_ctx) = &mut nameref_ctx.kind {\n+                path_ctx.kind = PathKind::Derive {\n+                    existing_derives: sema\n+                        .resolve_derive_macro(&origin_attr)\n+                        .into_iter()\n+                        .flatten()\n+                        .flatten()\n+                        .collect(),\n                 };\n-                let top_syn = match top_syn {\n-                    Some(it) => it,\n-                    None => return ty,\n-                };\n-                for _ in top_syn.ancestors().skip(1).map_while(ast::RefExpr::cast) {\n-                    cov_mark::hit!(expected_type_fn_param_ref);\n-                    ty = ty.strip_reference();\n-                }\n-                ty\n             }\n-            _ => ty,\n-        };\n+            return Some((\n+                CompletionAnalysis::NameRef(nameref_ctx),\n+                (None, None),\n+                QualifierCtx::default(),\n+            ));\n+        }\n+        return None;\n+    }\n \n-        loop {\n-            break match_ast! {\n-                match node {\n-                    ast::LetStmt(it) => {\n-                        cov_mark::hit!(expected_type_let_with_leading_char);\n-                        cov_mark::hit!(expected_type_let_without_leading_char);\n-                        let ty = it.pat()\n-                            .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.initializer().and_then(|it| self.sema.type_of_expr(&it)))\n-                            .map(TypeInfo::original);\n-                        let name = match it.pat() {\n-                            Some(ast::Pat::IdentPat(ident)) => ident.name().map(NameOrNameRef::Name),\n-                            Some(_) | None => None,\n-                        };\n-\n-                        (ty, name)\n-                    },\n-                    ast::LetExpr(it) => {\n-                        cov_mark::hit!(expected_type_if_let_without_leading_char);\n-                        let ty = it.pat()\n-                            .and_then(|pat| self.sema.type_of_pat(&pat))\n-                            .or_else(|| it.expr().and_then(|it| self.sema.type_of_expr(&it)))\n-                            .map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::ArgList(_) => {\n-                        cov_mark::hit!(expected_type_fn_param);\n-                        ActiveParameter::at_token(\n-                            &self.sema,\n-                            self.token.clone(),\n-                        ).map(|ap| {\n-                            let name = ap.ident().map(NameOrNameRef::Name);\n-\n-                            let ty = strip_refs(ap.ty);\n-                            (Some(ty), name)\n-                        })\n-                        .unwrap_or((None, None))\n-                    },\n-                    ast::RecordExprFieldList(it) => {\n-                        // wouldn't try {} be nice...\n-                        (|| {\n-                            if self.token.kind() == T![..]\n-                                || self.token.prev_token().map(|t| t.kind()) == Some(T![..])\n-                            {\n-                                cov_mark::hit!(expected_type_struct_func_update);\n-                                let record_expr = it.syntax().parent().and_then(ast::RecordExpr::cast)?;\n-                                let ty = self.sema.type_of_expr(&record_expr.into())?;\n-                                Some((\n-                                    Some(ty.original),\n-                                    None\n-                                ))\n-                            } else {\n-                                cov_mark::hit!(expected_type_struct_field_without_leading_char);\n-                                let expr_field = self.token.prev_sibling_or_token()?\n-                                    .into_node()\n-                                    .and_then(ast::RecordExprField::cast)?;\n-                                let (_, _, ty) = self.sema.resolve_record_field(&expr_field)?;\n-                                Some((\n-                                    Some(ty),\n-                                    expr_field.field_name().map(NameOrNameRef::NameRef),\n-                                ))\n-                            }\n-                        })().unwrap_or((None, None))\n-                    },\n-                    ast::RecordExprField(it) => {\n-                        if let Some(expr) = it.expr() {\n-                            cov_mark::hit!(expected_type_struct_field_with_leading_char);\n-                            (\n-                                self.sema.type_of_expr(&expr).map(TypeInfo::original),\n-                                it.field_name().map(NameOrNameRef::NameRef),\n-                            )\n-                        } else {\n-                            cov_mark::hit!(expected_type_struct_field_followed_by_comma);\n-                            let ty = self.sema.resolve_record_field(&it)\n-                                .map(|(_, _, ty)| ty);\n-                            (\n-                                ty,\n-                                it.field_name().map(NameOrNameRef::NameRef),\n-                            )\n-                        }\n-                    },\n-                    // match foo { $0 }\n-                    // match foo { ..., pat => $0 }\n-                    ast::MatchExpr(it) => {\n-                        let on_arrow = previous_non_trivia_token(self.token.clone()).map_or(false, |it| T![=>] == it.kind());\n-\n-                        let ty = if on_arrow {\n-                            // match foo { ..., pat => $0 }\n-                            cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n-                            cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n-                            self.sema.type_of_expr(&it.into())\n-                        } else {\n-                            // match foo { $0 }\n-                            cov_mark::hit!(expected_type_match_arm_without_leading_char);\n-                            it.expr().and_then(|e| self.sema.type_of_expr(&e))\n-                        }.map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::IfExpr(it) => {\n-                        let ty = it.condition()\n-                            .and_then(|e| self.sema.type_of_expr(&e))\n-                            .map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::IdentPat(it) => {\n-                        cov_mark::hit!(expected_type_if_let_with_leading_char);\n-                        cov_mark::hit!(expected_type_match_arm_with_leading_char);\n-                        let ty = self.sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n-                        (ty, None)\n-                    },\n-                    ast::Fn(it) => {\n-                        cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n-                        cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n-                        let def = self.sema.to_def(&it);\n-                        (def.map(|def| def.ret_type(self.db)), None)\n-                    },\n-                    ast::ClosureExpr(it) => {\n-                        let ty = self.sema.type_of_expr(&it.into());\n-                        ty.and_then(|ty| ty.original.as_callable(self.db))\n-                            .map(|c| (Some(c.return_type()), None))\n-                            .unwrap_or((None, None))\n-                    },\n-                    ast::ParamList(_) => (None, None),\n-                    ast::Stmt(_) => (None, None),\n-                    ast::Item(_) => (None, None),\n-                    _ => {\n-                        match node.parent() {\n-                            Some(n) => {\n-                                node = n;\n-                                continue;\n-                            },\n-                            None => (None, None),\n-                        }\n-                    },\n+    let name_like = match find_node_at_offset(&speculative_file, offset) {\n+        Some(it) => it,\n+        None => {\n+            let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n+                CompletionAnalysis::String {\n+                    original,\n+                    expanded: ast::String::cast(self_token.clone()),\n+                }\n+            } else {\n+                // Fix up trailing whitespace problem\n+                // #[attr(foo = $0\n+                let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n+                let p = token.parent()?;\n+                if p.kind() == SyntaxKind::TOKEN_TREE\n+                    && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+                {\n+                    let colon_prefix = previous_non_trivia_token(self_token.clone())\n+                        .map_or(false, |it| T![:] == it.kind());\n+                    CompletionAnalysis::UnexpandedAttrTT {\n+                        fake_attribute_under_caret: syntax_element\n+                            .ancestors()\n+                            .find_map(ast::Attr::cast),\n+                        colon_prefix,\n+                    }\n+                } else {\n+                    return None;\n                 }\n             };\n+            return Some((analysis, (None, None), QualifierCtx::default()));\n         }\n-    }\n-\n-    /// Fill the completion context, this is what does semantic reasoning about the surrounding context\n-    /// of the completion location.\n-    fn analyze(\n-        &mut self,\n-        original_file: &SyntaxNode,\n-        file_with_fake_ident: SyntaxNode,\n-        offset: TextSize,\n-        derive_ctx: Option<(SyntaxNode, SyntaxNode, TextSize, ast::Attr)>,\n-    ) -> Option<CompletionAnalysis> {\n-        let fake_ident_token = file_with_fake_ident.token_at_offset(offset).right_biased()?;\n-        let syntax_element = NodeOrToken::Token(fake_ident_token);\n-        if is_in_token_of_for_loop(syntax_element.clone()) {\n-            // for pat $0\n-            // there is nothing to complete here except `in` keyword\n-            // don't bother populating the context\n-            // FIXME: the completion calculations should end up good enough\n-            // such that this special case becomes unnecessary\n-            return None;\n+    };\n+    let expected = expected_type_and_name(sema, &self_token, &name_like);\n+    let mut qual_ctx = QualifierCtx::default();\n+    let analysis = match name_like {\n+        ast::NameLike::Lifetime(lifetime) => {\n+            CompletionAnalysis::Lifetime(classify_lifetime(sema, &original_file, lifetime)?)\n+        }\n+        ast::NameLike::NameRef(name_ref) => {\n+            let parent = name_ref.syntax().parent()?;\n+            let (nameref_ctx, qualifier_ctx) =\n+                classify_name_ref(sema, &original_file, name_ref, parent.clone())?;\n+            qual_ctx = qualifier_ctx;\n+            CompletionAnalysis::NameRef(nameref_ctx)\n+        }\n+        ast::NameLike::Name(name) => {\n+            let name_ctx = classify_name(sema, &original_file, name)?;\n+            CompletionAnalysis::Name(name_ctx)\n         }\n+    };\n+    Some((analysis, expected, qual_ctx))\n+}\n \n-        // Overwrite the path kind for derives\n-        if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n-            if let Some(ast::NameLike::NameRef(name_ref)) =\n-                find_node_at_offset(&file_with_fake_ident, offset)\n-            {\n-                let parent = name_ref.syntax().parent()?;\n-                let (mut nameref_ctx, _) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent)?;\n-                if let NameRefKind::Path(path_ctx) = &mut nameref_ctx.kind {\n-                    path_ctx.kind = PathKind::Derive {\n-                        existing_derives: self\n-                            .sema\n-                            .resolve_derive_macro(&origin_attr)\n-                            .into_iter()\n-                            .flatten()\n-                            .flatten()\n-                            .collect(),\n-                    };\n+/// Calculate the expected type and name of the cursor position.\n+fn expected_type_and_name(\n+    sema: &Semantics<'_, RootDatabase>,\n+    token: &SyntaxToken,\n+    name_like: &ast::NameLike,\n+) -> (Option<Type>, Option<NameOrNameRef>) {\n+    let mut node = match token.parent() {\n+        Some(it) => it,\n+        None => return (None, None),\n+    };\n+\n+    let strip_refs = |mut ty: Type| match name_like {\n+        ast::NameLike::NameRef(n) => {\n+            let p = match n.syntax().parent() {\n+                Some(it) => it,\n+                None => return ty,\n+            };\n+            let top_syn = match_ast! {\n+                match p {\n+                    ast::FieldExpr(e) => e\n+                        .syntax()\n+                        .ancestors()\n+                        .map_while(ast::FieldExpr::cast)\n+                        .last()\n+                        .map(|it| it.syntax().clone()),\n+                    ast::PathSegment(e) => e\n+                        .syntax()\n+                        .ancestors()\n+                        .skip(1)\n+                        .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n+                        .find_map(ast::PathExpr::cast)\n+                        .map(|it| it.syntax().clone()),\n+                    _ => None\n                 }\n-                return Some(CompletionAnalysis::NameRef(nameref_ctx));\n+            };\n+            let top_syn = match top_syn {\n+                Some(it) => it,\n+                None => return ty,\n+            };\n+            for _ in top_syn.ancestors().skip(1).map_while(ast::RefExpr::cast) {\n+                cov_mark::hit!(expected_type_fn_param_ref);\n+                ty = ty.strip_reference();\n             }\n-            return None;\n+            ty\n         }\n+        _ => ty,\n+    };\n \n-        let name_like = match find_node_at_offset(&file_with_fake_ident, offset) {\n-            Some(it) => it,\n-            None => {\n-                let analysis =\n-                    if let Some(original) = ast::String::cast(self.original_token.clone()) {\n-                        CompletionAnalysis::String {\n-                            original,\n-                            expanded: ast::String::cast(self.token.clone()),\n-                        }\n-                    } else {\n-                        // Fix up trailing whitespace problem\n-                        // #[attr(foo = $0\n-                        let token =\n-                            syntax::algo::skip_trivia_token(self.token.clone(), Direction::Prev)?;\n-                        let p = token.parent()?;\n-                        if p.kind() == SyntaxKind::TOKEN_TREE\n-                            && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+    loop {\n+        break match_ast! {\n+            match node {\n+                ast::LetStmt(it) => {\n+                    cov_mark::hit!(expected_type_let_with_leading_char);\n+                    cov_mark::hit!(expected_type_let_without_leading_char);\n+                    let ty = it.pat()\n+                        .and_then(|pat| sema.type_of_pat(&pat))\n+                        .or_else(|| it.initializer().and_then(|it| sema.type_of_expr(&it)))\n+                        .map(TypeInfo::original);\n+                    let name = match it.pat() {\n+                        Some(ast::Pat::IdentPat(ident)) => ident.name().map(NameOrNameRef::Name),\n+                        Some(_) | None => None,\n+                    };\n+\n+                    (ty, name)\n+                },\n+                ast::LetExpr(it) => {\n+                    cov_mark::hit!(expected_type_if_let_without_leading_char);\n+                    let ty = it.pat()\n+                        .and_then(|pat| sema.type_of_pat(&pat))\n+                        .or_else(|| it.expr().and_then(|it| sema.type_of_expr(&it)))\n+                        .map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::ArgList(_) => {\n+                    cov_mark::hit!(expected_type_fn_param);\n+                    ActiveParameter::at_token(\n+                        &sema,\n+                       token.clone(),\n+                    ).map(|ap| {\n+                        let name = ap.ident().map(NameOrNameRef::Name);\n+\n+                        let ty = strip_refs(ap.ty);\n+                        (Some(ty), name)\n+                    })\n+                    .unwrap_or((None, None))\n+                },\n+                ast::RecordExprFieldList(it) => {\n+                    // wouldn't try {} be nice...\n+                    (|| {\n+                        if token.kind() == T![..]\n+                            ||token.prev_token().map(|t| t.kind()) == Some(T![..])\n                         {\n-                            let colon_prefix = previous_non_trivia_token(self.token.clone())\n-                                .map_or(false, |it| T![:] == it.kind());\n-                            CompletionAnalysis::UnexpandedAttrTT {\n-                                fake_attribute_under_caret: syntax_element\n-                                    .ancestors()\n-                                    .find_map(ast::Attr::cast),\n-                                colon_prefix,\n-                            }\n+                            cov_mark::hit!(expected_type_struct_func_update);\n+                            let record_expr = it.syntax().parent().and_then(ast::RecordExpr::cast)?;\n+                            let ty = sema.type_of_expr(&record_expr.into())?;\n+                            Some((\n+                                Some(ty.original),\n+                                None\n+                            ))\n                         } else {\n-                            return None;\n+                            cov_mark::hit!(expected_type_struct_field_without_leading_char);\n+                            let expr_field = token.prev_sibling_or_token()?\n+                                .into_node()\n+                                .and_then(ast::RecordExprField::cast)?;\n+                            let (_, _, ty) = sema.resolve_record_field(&expr_field)?;\n+                            Some((\n+                                Some(ty),\n+                                expr_field.field_name().map(NameOrNameRef::NameRef),\n+                            ))\n                         }\n-                    };\n-                return Some(analysis);\n+                    })().unwrap_or((None, None))\n+                },\n+                ast::RecordExprField(it) => {\n+                    if let Some(expr) = it.expr() {\n+                        cov_mark::hit!(expected_type_struct_field_with_leading_char);\n+                        (\n+                            sema.type_of_expr(&expr).map(TypeInfo::original),\n+                            it.field_name().map(NameOrNameRef::NameRef),\n+                        )\n+                    } else {\n+                        cov_mark::hit!(expected_type_struct_field_followed_by_comma);\n+                        let ty = sema.resolve_record_field(&it)\n+                            .map(|(_, _, ty)| ty);\n+                        (\n+                            ty,\n+                            it.field_name().map(NameOrNameRef::NameRef),\n+                        )\n+                    }\n+                },\n+                // match foo { $0 }\n+                // match foo { ..., pat => $0 }\n+                ast::MatchExpr(it) => {\n+                    let on_arrow = previous_non_trivia_token(token.clone()).map_or(false, |it| T![=>] == it.kind());\n+\n+                    let ty = if on_arrow {\n+                        // match foo { ..., pat => $0 }\n+                        cov_mark::hit!(expected_type_match_arm_body_without_leading_char);\n+                        cov_mark::hit!(expected_type_match_arm_body_with_leading_char);\n+                        sema.type_of_expr(&it.into())\n+                    } else {\n+                        // match foo { $0 }\n+                        cov_mark::hit!(expected_type_match_arm_without_leading_char);\n+                        it.expr().and_then(|e| sema.type_of_expr(&e))\n+                    }.map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::IfExpr(it) => {\n+                    let ty = it.condition()\n+                        .and_then(|e| sema.type_of_expr(&e))\n+                        .map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::IdentPat(it) => {\n+                    cov_mark::hit!(expected_type_if_let_with_leading_char);\n+                    cov_mark::hit!(expected_type_match_arm_with_leading_char);\n+                    let ty = sema.type_of_pat(&ast::Pat::from(it)).map(TypeInfo::original);\n+                    (ty, None)\n+                },\n+                ast::Fn(it) => {\n+                    cov_mark::hit!(expected_type_fn_ret_with_leading_char);\n+                    cov_mark::hit!(expected_type_fn_ret_without_leading_char);\n+                    let def = sema.to_def(&it);\n+                    (def.map(|def| def.ret_type(sema.db)), None)\n+                },\n+                ast::ClosureExpr(it) => {\n+                    let ty = sema.type_of_expr(&it.into());\n+                    ty.and_then(|ty| ty.original.as_callable(sema.db))\n+                        .map(|c| (Some(c.return_type()), None))\n+                        .unwrap_or((None, None))\n+                },\n+                ast::ParamList(_) => (None, None),\n+                ast::Stmt(_) => (None, None),\n+                ast::Item(_) => (None, None),\n+                _ => {\n+                    match node.parent() {\n+                        Some(n) => {\n+                            node = n;\n+                            continue;\n+                        },\n+                        None => (None, None),\n+                    }\n+                },\n             }\n         };\n-        (self.expected_type, self.expected_name) = self.expected_type_and_name(&name_like);\n-        let analysis = match name_like {\n-            ast::NameLike::Lifetime(lifetime) => CompletionAnalysis::Lifetime(\n-                Self::classify_lifetime(&self.sema, original_file, lifetime)?,\n-            ),\n-            ast::NameLike::NameRef(name_ref) => {\n-                let parent = name_ref.syntax().parent()?;\n-                let (nameref_ctx, qualifier_ctx) =\n-                    Self::classify_name_ref(&self.sema, &original_file, name_ref, parent.clone())?;\n+    }\n+}\n \n-                self.qualifier_ctx = qualifier_ctx;\n-                CompletionAnalysis::NameRef(nameref_ctx)\n-            }\n-            ast::NameLike::Name(name) => {\n-                let name_ctx = Self::classify_name(&self.sema, original_file, name)?;\n-                CompletionAnalysis::Name(name_ctx)\n-            }\n-        };\n-        Some(analysis)\n+fn classify_lifetime(\n+    _sema: &Semantics<'_, RootDatabase>,\n+    original_file: &SyntaxNode,\n+    lifetime: ast::Lifetime,\n+) -> Option<LifetimeContext> {\n+    let parent = lifetime.syntax().parent()?;\n+    if parent.kind() == SyntaxKind::ERROR {\n+        return None;\n     }\n \n-    fn classify_lifetime(\n-        _sema: &Semantics<'_, RootDatabase>,\n-        original_file: &SyntaxNode,\n-        lifetime: ast::Lifetime,\n-    ) -> Option<LifetimeContext> {\n-        let parent = lifetime.syntax().parent()?;\n-        if parent.kind() == SyntaxKind::ERROR {\n-            return None;\n+    let kind = match_ast! {\n+        match parent {\n+            ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n+                is_decl: param.lifetime().as_ref() == Some(&lifetime),\n+                param\n+            },\n+            ast::BreakExpr(_) => LifetimeKind::LabelRef,\n+            ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n+            ast::Label(_) => LifetimeKind::LabelDef,\n+            _ => LifetimeKind::Lifetime,\n         }\n+    };\n+    let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n \n-        let kind = match_ast! {\n-            match parent {\n-                ast::LifetimeParam(param) => LifetimeKind::LifetimeParam {\n-                    is_decl: param.lifetime().as_ref() == Some(&lifetime),\n-                    param\n-                },\n-                ast::BreakExpr(_) => LifetimeKind::LabelRef,\n-                ast::ContinueExpr(_) => LifetimeKind::LabelRef,\n-                ast::Label(_) => LifetimeKind::LabelDef,\n-                _ => LifetimeKind::Lifetime,\n-            }\n-        };\n-        let lifetime = find_node_at_offset(&original_file, lifetime.syntax().text_range().start());\n+    Some(LifetimeContext { lifetime, kind })\n+}\n \n-        Some(LifetimeContext { lifetime, kind })\n-    }\n+fn classify_name(\n+    sema: &Semantics<'_, RootDatabase>,\n+    original_file: &SyntaxNode,\n+    name: ast::Name,\n+) -> Option<NameContext> {\n+    let parent = name.syntax().parent()?;\n+    let kind = match_ast! {\n+        match parent {\n+            ast::Const(_) => NameKind::Const,\n+            ast::ConstParam(_) => NameKind::ConstParam,\n+            ast::Enum(_) => NameKind::Enum,\n+            ast::Fn(_) => NameKind::Function,\n+            ast::IdentPat(bind_pat) => {\n+                let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n+                if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n+                    pat_ctx.record_pat = find_node_in_file_compensated(sema, original_file, &record_field.parent_record_pat());\n+                }\n \n-    fn classify_name(\n-        sema: &Semantics<'_, RootDatabase>,\n-        original_file: &SyntaxNode,\n-        name: ast::Name,\n-    ) -> Option<NameContext> {\n-        let parent = name.syntax().parent()?;\n-        let kind = match_ast! {\n-            match parent {\n-                ast::Const(_) => NameKind::Const,\n-                ast::ConstParam(_) => NameKind::ConstParam,\n-                ast::Enum(_) => NameKind::Enum,\n-                ast::Fn(_) => NameKind::Function,\n-                ast::IdentPat(bind_pat) => {\n-                    let mut pat_ctx = pattern_context_for(sema, original_file, bind_pat.into());\n-                    if let Some(record_field) = ast::RecordPatField::for_field_name(&name) {\n-                        pat_ctx.record_pat = find_node_in_file_compensated(sema, original_file, &record_field.parent_record_pat());\n-                    }\n+                NameKind::IdentPat(pat_ctx)\n+            },\n+            ast::MacroDef(_) => NameKind::MacroDef,\n+            ast::MacroRules(_) => NameKind::MacroRules,\n+            ast::Module(module) => NameKind::Module(module),\n+            ast::RecordField(_) => NameKind::RecordField,\n+            ast::Rename(_) => NameKind::Rename,\n+            ast::SelfParam(_) => NameKind::SelfParam,\n+            ast::Static(_) => NameKind::Static,\n+            ast::Struct(_) => NameKind::Struct,\n+            ast::Trait(_) => NameKind::Trait,\n+            ast::TypeAlias(_) => NameKind::TypeAlias,\n+            ast::TypeParam(_) => NameKind::TypeParam,\n+            ast::Union(_) => NameKind::Union,\n+            ast::Variant(_) => NameKind::Variant,\n+            _ => return None,\n+        }\n+    };\n+    let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n+    Some(NameContext { name, kind })\n+}\n \n-                    NameKind::IdentPat(pat_ctx)\n-                },\n-                ast::MacroDef(_) => NameKind::MacroDef,\n-                ast::MacroRules(_) => NameKind::MacroRules,\n-                ast::Module(module) => NameKind::Module(module),\n-                ast::RecordField(_) => NameKind::RecordField,\n-                ast::Rename(_) => NameKind::Rename,\n-                ast::SelfParam(_) => NameKind::SelfParam,\n-                ast::Static(_) => NameKind::Static,\n-                ast::Struct(_) => NameKind::Struct,\n-                ast::Trait(_) => NameKind::Trait,\n-                ast::TypeAlias(_) => NameKind::TypeAlias,\n-                ast::TypeParam(_) => NameKind::TypeParam,\n-                ast::Union(_) => NameKind::Union,\n-                ast::Variant(_) => NameKind::Variant,\n-                _ => return None,\n-            }\n-        };\n-        let name = find_node_at_offset(&original_file, name.syntax().text_range().start());\n-        Some(NameContext { name, kind })\n+fn classify_name_ref(\n+    sema: &Semantics<'_, RootDatabase>,\n+    original_file: &SyntaxNode,\n+    name_ref: ast::NameRef,\n+    parent: SyntaxNode,\n+) -> Option<(NameRefContext, QualifierCtx)> {\n+    let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n+\n+    let make_res = |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n+\n+    if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n+        let dot_prefix = previous_non_trivia_token(name_ref.syntax().clone())\n+            .map_or(false, |it| T![.] == it.kind());\n+\n+        return find_node_in_file_compensated(\n+            sema,\n+            original_file,\n+            &record_field.parent_record_lit(),\n+        )\n+        .map(|expr| NameRefKind::RecordExpr { expr, dot_prefix })\n+        .map(make_res);\n     }\n-\n-    fn classify_name_ref(\n-        sema: &Semantics<'_, RootDatabase>,\n-        original_file: &SyntaxNode,\n-        name_ref: ast::NameRef,\n-        parent: SyntaxNode,\n-    ) -> Option<(NameRefContext, QualifierCtx)> {\n-        let nameref = find_node_at_offset(&original_file, name_ref.syntax().text_range().start());\n-\n-        let make_res =\n-            |kind| (NameRefContext { nameref: nameref.clone(), kind }, Default::default());\n-\n-        if let Some(record_field) = ast::RecordExprField::for_field_name(&name_ref) {\n-            let dot_prefix = previous_non_trivia_token(name_ref.syntax().clone())\n-                .map_or(false, |it| T![.] == it.kind());\n-\n-            return find_node_in_file_compensated(\n+    if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n+        let kind = NameRefKind::Pattern(PatternContext {\n+            param_ctx: None,\n+            has_type_ascription: false,\n+            ref_token: None,\n+            mut_token: None,\n+            record_pat: find_node_in_file_compensated(\n                 sema,\n                 original_file,\n-                &record_field.parent_record_lit(),\n+                &record_field.parent_record_pat(),\n+            ),\n+            ..pattern_context_for(\n+                sema,\n+                original_file,\n+                record_field.parent_record_pat().clone().into(),\n             )\n-            .map(|expr| NameRefKind::RecordExpr { expr, dot_prefix })\n-            .map(make_res);\n+        });\n+        return Some(make_res(kind));\n+    }\n+\n+    let segment = match_ast! {\n+        match parent {\n+            ast::PathSegment(segment) => segment,\n+            ast::FieldExpr(field) => {\n+                let receiver = find_opt_node_in_file(original_file, field.expr());\n+                let receiver_is_ambiguous_float_literal = match &receiver {\n+                    Some(ast::Expr::Literal(l)) => matches! {\n+                        l.kind(),\n+                        ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n+                    },\n+                    _ => false,\n+                };\n+                let kind = NameRefKind::DotAccess(DotAccess {\n+                    receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n+                    kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n+                    receiver\n+                });\n+                return Some(make_res(kind));\n+            },\n+            ast::MethodCallExpr(method) => {\n+                let receiver = find_opt_node_in_file(original_file, method.receiver());\n+                let kind = NameRefKind::DotAccess(DotAccess {\n+                    receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n+                    kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n+                    receiver\n+                });\n+                return Some(make_res(kind));\n+            },\n+            _ => return None,\n         }\n-        if let Some(record_field) = ast::RecordPatField::for_field_name_ref(&name_ref) {\n-            let kind = NameRefKind::Pattern(PatternContext {\n-                param_ctx: None,\n-                has_type_ascription: false,\n-                ref_token: None,\n-                mut_token: None,\n-                record_pat: find_node_in_file_compensated(\n-                    sema,\n-                    original_file,\n-                    &record_field.parent_record_pat(),\n-                ),\n-                ..pattern_context_for(\n-                    sema,\n-                    original_file,\n-                    record_field.parent_record_pat().clone().into(),\n-                )\n-            });\n-            return Some(make_res(kind));\n+    };\n+\n+    let path = segment.parent_path();\n+    let original_path = find_node_in_file_compensated(sema, original_file, &path);\n+\n+    let mut path_ctx = PathCompletionCtx {\n+        has_call_parens: false,\n+        has_macro_bang: false,\n+        qualified: Qualified::No,\n+        parent: None,\n+        path: path.clone(),\n+        original_path,\n+        kind: PathKind::Item { kind: ItemListKind::SourceFile },\n+        has_type_args: false,\n+        use_tree_parent: false,\n+    };\n+\n+    let is_in_block = |it: &SyntaxNode| {\n+        it.parent()\n+            .map(|node| {\n+                ast::ExprStmt::can_cast(node.kind()) || ast::StmtList::can_cast(node.kind())\n+            })\n+            .unwrap_or(false)\n+    };\n+    let func_update_record = |syn: &SyntaxNode| {\n+        if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n+            find_node_in_file_compensated(sema, original_file, &record_expr)\n+        } else {\n+            None\n+        }\n+    };\n+    let after_if_expr = |node: SyntaxNode| {\n+        let prev_expr = (|| {\n+            let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n+            ast::ExprStmt::cast(prev_sibling)?.expr()\n+        })();\n+        matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n+    };\n+\n+    // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n+    // ex. trait Foo $0 {}\n+    // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n+    // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n+    // expression or an item list.\n+    // The following code checks if the body is missing, if it is we either cut off the body\n+    // from the item or it was missing in the first place\n+    let inbetween_body_and_decl_check = |node: SyntaxNode| {\n+        if let Some(NodeOrToken::Node(n)) =\n+            syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n+        {\n+            if let Some(item) = ast::Item::cast(n) {\n+                let is_inbetween = match &item {\n+                    ast::Item::Const(it) => it.body().is_none(),\n+                    ast::Item::Enum(it) => it.variant_list().is_none(),\n+                    ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n+                    ast::Item::Fn(it) => it.body().is_none(),\n+                    ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n+                    ast::Item::Module(it) => it.item_list().is_none(),\n+                    ast::Item::Static(it) => it.body().is_none(),\n+                    ast::Item::Struct(it) => it.field_list().is_none(),\n+                    ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n+                    ast::Item::TypeAlias(it) => it.ty().is_none(),\n+                    ast::Item::Union(it) => it.record_field_list().is_none(),\n+                    _ => false,\n+                };\n+                if is_inbetween {\n+                    return Some(item);\n+                }\n+            }\n         }\n+        None\n+    };\n \n-        let segment = match_ast! {\n+    let type_location = |node: &SyntaxNode| {\n+        let parent = node.parent()?;\n+        let res = match_ast! {\n             match parent {\n-                ast::PathSegment(segment) => segment,\n-                ast::FieldExpr(field) => {\n-                    let receiver = find_opt_node_in_file(original_file, field.expr());\n-                    let receiver_is_ambiguous_float_literal = match &receiver {\n-                        Some(ast::Expr::Literal(l)) => matches! {\n-                            l.kind(),\n-                            ast::LiteralKind::FloatNumber { .. } if l.syntax().last_token().map_or(false, |it| it.text().ends_with('.'))\n-                        },\n-                        _ => false,\n+                ast::Const(it) => {\n+                    let name = find_opt_node_in_file(original_file, it.name())?;\n+                    let original = ast::Const::cast(name.syntax().parent()?)?;\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n+                },\n+                ast::RetType(it) => {\n+                    if it.thin_arrow_token().is_none() {\n+                        return None;\n+                    }\n+                    let parent = match ast::Fn::cast(parent.parent()?) {\n+                        Some(x) => x.param_list(),\n+                        None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n                     };\n-                    let kind = NameRefKind::DotAccess(DotAccess {\n-                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n-                        kind: DotAccessKind::Field { receiver_is_ambiguous_float_literal },\n-                        receiver\n-                    });\n-                    return Some(make_res(kind));\n+\n+                    let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n+                        match parent {\n+                            ast::ClosureExpr(it) => {\n+                                it.body()\n+                            },\n+                            ast::Fn(it) => {\n+                                it.body().map(ast::Expr::BlockExpr)\n+                            },\n+                            _ => return None,\n+                        }\n+                    }))\n                 },\n-                ast::MethodCallExpr(method) => {\n-                    let receiver = find_opt_node_in_file(original_file, method.receiver());\n-                    let kind = NameRefKind::DotAccess(DotAccess {\n-                        receiver_ty: receiver.as_ref().and_then(|it| sema.type_of_expr(it)),\n-                        kind: DotAccessKind::Method { has_parens: method.arg_list().map_or(false, |it| it.l_paren_token().is_some()) },\n-                        receiver\n-                    });\n-                    return Some(make_res(kind));\n+                ast::Param(it) => {\n+                    if it.colon_token().is_none() {\n+                        return None;\n+                    }\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n                 },\n+                ast::LetStmt(it) => {\n+                    if it.colon_token().is_none() {\n+                        return None;\n+                    }\n+                    TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n+                },\n+                ast::Impl(it) => {\n+                    match it.trait_() {\n+                        Some(t) if t.syntax() == node => TypeLocation::ImplTrait,\n+                        _ => match it.self_ty() {\n+                            Some(t) if t.syntax() == node => TypeLocation::ImplTarget,\n+                            _ => return None,\n+                        },\n+                    }\n+                },\n+                ast::TypeBound(_) => TypeLocation::TypeBound,\n+                // is this case needed?\n+                ast::TypeBoundList(_) => TypeLocation::TypeBound,\n+                ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n+                // is this case needed?\n+                ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, Some(it))),\n+                ast::TupleField(_) => TypeLocation::TupleField,\n                 _ => return None,\n             }\n         };\n+        Some(res)\n+    };\n \n-        let path = segment.parent_path();\n-        let original_path = find_node_in_file_compensated(sema, original_file, &path);\n-\n-        let mut path_ctx = PathCompletionCtx {\n-            has_call_parens: false,\n-            has_macro_bang: false,\n-            qualified: Qualified::No,\n-            parent: None,\n-            path: path.clone(),\n-            original_path,\n-            kind: PathKind::Item { kind: ItemListKind::SourceFile },\n-            has_type_args: false,\n-            use_tree_parent: false,\n-        };\n-\n-        let is_in_block = |it: &SyntaxNode| {\n-            it.parent()\n-                .map(|node| {\n-                    ast::ExprStmt::can_cast(node.kind()) || ast::StmtList::can_cast(node.kind())\n-                })\n-                .unwrap_or(false)\n-        };\n-        let func_update_record = |syn: &SyntaxNode| {\n-            if let Some(record_expr) = syn.ancestors().nth(2).and_then(ast::RecordExpr::cast) {\n-                find_node_in_file_compensated(sema, original_file, &record_expr)\n+    let is_in_condition = |it: &ast::Expr| {\n+        (|| {\n+            let parent = it.syntax().parent()?;\n+            if let Some(expr) = ast::WhileExpr::cast(parent.clone()) {\n+                Some(expr.condition()? == *it)\n+            } else if let Some(expr) = ast::IfExpr::cast(parent) {\n+                Some(expr.condition()? == *it)\n             } else {\n                 None\n             }\n-        };\n-        let after_if_expr = |node: SyntaxNode| {\n-            let prev_expr = (|| {\n-                let prev_sibling = non_trivia_sibling(node.into(), Direction::Prev)?.into_node()?;\n-                ast::ExprStmt::cast(prev_sibling)?.expr()\n-            })();\n-            matches!(prev_expr, Some(ast::Expr::IfExpr(_)))\n-        };\n+        })()\n+        .unwrap_or(false)\n+    };\n \n-        // We do not want to generate path completions when we are sandwiched between an item decl signature and its body.\n-        // ex. trait Foo $0 {}\n-        // in these cases parser recovery usually kicks in for our inserted identifier, causing it\n-        // to either be parsed as an ExprStmt or a MacroCall, depending on whether it is in a block\n-        // expression or an item list.\n-        // The following code checks if the body is missing, if it is we either cut off the body\n-        // from the item or it was missing in the first place\n-        let inbetween_body_and_decl_check = |node: SyntaxNode| {\n-            if let Some(NodeOrToken::Node(n)) =\n-                syntax::algo::non_trivia_sibling(node.into(), syntax::Direction::Prev)\n-            {\n-                if let Some(item) = ast::Item::cast(n) {\n-                    let is_inbetween = match &item {\n-                        ast::Item::Const(it) => it.body().is_none(),\n-                        ast::Item::Enum(it) => it.variant_list().is_none(),\n-                        ast::Item::ExternBlock(it) => it.extern_item_list().is_none(),\n-                        ast::Item::Fn(it) => it.body().is_none(),\n-                        ast::Item::Impl(it) => it.assoc_item_list().is_none(),\n-                        ast::Item::Module(it) => it.item_list().is_none(),\n-                        ast::Item::Static(it) => it.body().is_none(),\n-                        ast::Item::Struct(it) => it.field_list().is_none(),\n-                        ast::Item::Trait(it) => it.assoc_item_list().is_none(),\n-                        ast::Item::TypeAlias(it) => it.ty().is_none(),\n-                        ast::Item::Union(it) => it.record_field_list().is_none(),\n-                        _ => false,\n-                    };\n-                    if is_inbetween {\n-                        return Some(item);\n+    let make_path_kind_expr = |expr: ast::Expr| {\n+        let it = expr.syntax();\n+        let in_block_expr = is_in_block(it);\n+        let in_loop_body = is_in_loop_body(it);\n+        let after_if_expr = after_if_expr(it.clone());\n+        let ref_expr_parent =\n+            path.as_single_name_ref().and_then(|_| it.parent()).and_then(ast::RefExpr::cast);\n+        let (innermost_ret_ty, self_param) = {\n+            let find_ret_ty = |it: SyntaxNode| {\n+                if let Some(item) = ast::Item::cast(it.clone()) {\n+                    match item {\n+                        ast::Item::Fn(f) => Some(sema.to_def(&f).map(|it| it.ret_type(sema.db))),\n+                        ast::Item::MacroCall(_) => None,\n+                        _ => Some(None),\n                     }\n-                }\n-            }\n-            None\n-        };\n-\n-        let type_location = |node: &SyntaxNode| {\n-            let parent = node.parent()?;\n-            let res = match_ast! {\n-                match parent {\n-                    ast::Const(it) => {\n-                        let name = find_opt_node_in_file(original_file, it.name())?;\n-                        let original = ast::Const::cast(name.syntax().parent()?)?;\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::Const(original.body()))\n-                    },\n-                    ast::RetType(it) => {\n-                        if it.thin_arrow_token().is_none() {\n-                            return None;\n-                        }\n-                        let parent = match ast::Fn::cast(parent.parent()?) {\n-                            Some(x) => x.param_list(),\n-                            None => ast::ClosureExpr::cast(parent.parent()?)?.param_list(),\n-                        };\n-\n-                        let parent = find_opt_node_in_file(original_file, parent)?.syntax().parent()?;\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::RetType(match_ast! {\n-                            match parent {\n-                                ast::ClosureExpr(it) => {\n-                                    it.body()\n-                                },\n-                                ast::Fn(it) => {\n-                                    it.body().map(ast::Expr::BlockExpr)\n-                                },\n-                                _ => return None,\n-                            }\n-                        }))\n-                    },\n-                    ast::Param(it) => {\n-                        if it.colon_token().is_none() {\n-                            return None;\n-                        }\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::FnParam(find_opt_node_in_file(original_file, it.pat())))\n-                    },\n-                    ast::LetStmt(it) => {\n-                        if it.colon_token().is_none() {\n-                            return None;\n-                        }\n-                        TypeLocation::TypeAscription(TypeAscriptionTarget::Let(find_opt_node_in_file(original_file, it.pat())))\n-                    },\n-                    ast::Impl(it) => {\n-                        match it.trait_() {\n-                            Some(t) if t.syntax() == node => TypeLocation::ImplTrait,\n-                            _ => match it.self_ty() {\n-                                Some(t) if t.syntax() == node => TypeLocation::ImplTarget,\n-                                _ => return None,\n-                            },\n-                        }\n-                    },\n-                    ast::TypeBound(_) => TypeLocation::TypeBound,\n-                    // is this case needed?\n-                    ast::TypeBoundList(_) => TypeLocation::TypeBound,\n-                    ast::GenericArg(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, it.syntax().parent().and_then(ast::GenericArgList::cast))),\n-                    // is this case needed?\n-                    ast::GenericArgList(it) => TypeLocation::GenericArgList(find_opt_node_in_file_compensated(sema, original_file, Some(it))),\n-                    ast::TupleField(_) => TypeLocation::TupleField,\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        };\n-\n-        let is_in_condition = |it: &ast::Expr| {\n-            (|| {\n-                let parent = it.syntax().parent()?;\n-                if let Some(expr) = ast::WhileExpr::cast(parent.clone()) {\n-                    Some(expr.condition()? == *it)\n-                } else if let Some(expr) = ast::IfExpr::cast(parent) {\n-                    Some(expr.condition()? == *it)\n                 } else {\n-                    None\n-                }\n-            })()\n-            .unwrap_or(false)\n-        };\n-\n-        let make_path_kind_expr = |expr: ast::Expr| {\n-            let it = expr.syntax();\n-            let in_block_expr = is_in_block(it);\n-            let in_loop_body = is_in_loop_body(it);\n-            let after_if_expr = after_if_expr(it.clone());\n-            let ref_expr_parent =\n-                path.as_single_name_ref().and_then(|_| it.parent()).and_then(ast::RefExpr::cast);\n-            let (innermost_ret_ty, self_param) = {\n-                let find_ret_ty = |it: SyntaxNode| {\n-                    if let Some(item) = ast::Item::cast(it.clone()) {\n-                        match item {\n-                            ast::Item::Fn(f) => {\n-                                Some(sema.to_def(&f).map(|it| it.ret_type(sema.db)))\n-                            }\n-                            ast::Item::MacroCall(_) => None,\n-                            _ => Some(None),\n-                        }\n-                    } else {\n-                        let expr = ast::Expr::cast(it)?;\n-                        let callable = match expr {\n-                            // FIXME\n-                            // ast::Expr::BlockExpr(b) if b.async_token().is_some() || b.try_token().is_some() => sema.type_of_expr(b),\n-                            ast::Expr::ClosureExpr(_) => sema.type_of_expr(&expr),\n-                            _ => return None,\n-                        };\n-                        Some(\n-                            callable\n-                                .and_then(|c| c.adjusted().as_callable(sema.db))\n-                                .map(|it| it.return_type()),\n-                        )\n-                    }\n-                };\n-                let find_fn_self_param = |it| match it {\n-                    ast::Item::Fn(fn_) => {\n-                        Some(sema.to_def(&fn_).and_then(|it| it.self_param(sema.db)))\n-                    }\n-                    ast::Item::MacroCall(_) => None,\n-                    _ => Some(None),\n-                };\n-\n-                match find_node_in_file_compensated(sema, original_file, &expr) {\n-                    Some(it) => {\n-                        let innermost_ret_ty = sema\n-                            .ancestors_with_macros(it.syntax().clone())\n-                            .find_map(find_ret_ty)\n-                            .flatten();\n-\n-                        let self_param = sema\n-                            .ancestors_with_macros(it.syntax().clone())\n-                            .filter_map(ast::Item::cast)\n-                            .find_map(find_fn_self_param)\n-                            .flatten();\n-                        (innermost_ret_ty, self_param)\n-                    }\n-                    None => (None, None),\n+                    let expr = ast::Expr::cast(it)?;\n+                    let callable = match expr {\n+                        // FIXME\n+                        // ast::Expr::BlockExpr(b) if b.async_token().is_some() || b.try_token().is_some() => sema.type_of_expr(b),\n+                        ast::Expr::ClosureExpr(_) => sema.type_of_expr(&expr),\n+                        _ => return None,\n+                    };\n+                    Some(\n+                        callable\n+                            .and_then(|c| c.adjusted().as_callable(sema.db))\n+                            .map(|it| it.return_type()),\n+                    )\n                 }\n             };\n-            let is_func_update = func_update_record(it);\n-            let in_condition = is_in_condition(&expr);\n-            let incomplete_let = it\n-                .parent()\n-                .and_then(ast::LetStmt::cast)\n-                .map_or(false, |it| it.semicolon_token().is_none());\n-            let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n-\n-            let in_match_guard = match it.parent().and_then(ast::MatchArm::cast) {\n-                Some(arm) => arm\n-                    .fat_arrow_token()\n-                    .map_or(true, |arrow| it.text_range().start() < arrow.text_range().start()),\n-                None => false,\n+            let find_fn_self_param = |it| match it {\n+                ast::Item::Fn(fn_) => Some(sema.to_def(&fn_).and_then(|it| it.self_param(sema.db))),\n+                ast::Item::MacroCall(_) => None,\n+                _ => Some(None),\n             };\n \n-            PathKind::Expr {\n-                expr_ctx: ExprCtx {\n-                    in_block_expr,\n-                    in_loop_body,\n-                    after_if_expr,\n-                    in_condition,\n-                    ref_expr_parent,\n-                    is_func_update,\n-                    innermost_ret_ty,\n-                    self_param,\n-                    incomplete_let,\n-                    impl_,\n-                    in_match_guard,\n-                },\n+            match find_node_in_file_compensated(sema, original_file, &expr) {\n+                Some(it) => {\n+                    let innermost_ret_ty = sema\n+                        .ancestors_with_macros(it.syntax().clone())\n+                        .find_map(find_ret_ty)\n+                        .flatten();\n+\n+                    let self_param = sema\n+                        .ancestors_with_macros(it.syntax().clone())\n+                        .filter_map(ast::Item::cast)\n+                        .find_map(find_fn_self_param)\n+                        .flatten();\n+                    (innermost_ret_ty, self_param)\n+                }\n+                None => (None, None),\n             }\n         };\n-        let make_path_kind_type = |ty: ast::Type| {\n-            let location = type_location(ty.syntax());\n-            PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n+        let is_func_update = func_update_record(it);\n+        let in_condition = is_in_condition(&expr);\n+        let incomplete_let = it\n+            .parent()\n+            .and_then(ast::LetStmt::cast)\n+            .map_or(false, |it| it.semicolon_token().is_none());\n+        let impl_ = fetch_immediate_impl(sema, original_file, expr.syntax());\n+\n+        let in_match_guard = match it.parent().and_then(ast::MatchArm::cast) {\n+            Some(arm) => arm\n+                .fat_arrow_token()\n+                .map_or(true, |arrow| it.text_range().start() < arrow.text_range().start()),\n+            None => false,\n         };\n \n-        let mut kind_macro_call = |it: ast::MacroCall| {\n-            path_ctx.has_macro_bang = it.excl_token().is_some();\n-            let parent = it.syntax().parent()?;\n-            // Any path in an item list will be treated as a macro call by the parser\n-            let kind = match_ast! {\n-                match parent {\n-                    ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n-                    ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n-                    ast::MacroType(ty) => make_path_kind_type(ty.into()),\n-                    ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n-                    ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n-                        Some(it) => match_ast! {\n-                            match it {\n-                                ast::Trait(_) => ItemListKind::Trait,\n-                                ast::Impl(it) => if it.trait_().is_some() {\n-                                    ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n-                                } else {\n-                                    ItemListKind::Impl\n-                                },\n-                                _ => return None\n-                            }\n-                        },\n-                        None => return None,\n-                    } },\n-                    ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n-                    ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n-                    _ => return None,\n-                }\n-            };\n-            Some(kind)\n-        };\n-        let make_path_kind_attr = |meta: ast::Meta| {\n-            let attr = meta.parent_attr()?;\n-            let kind = attr.kind();\n-            let attached = attr.syntax().parent()?;\n-            let is_trailing_outer_attr = kind != AttrKind::Inner\n-                && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next)\n-                    .is_none();\n-            let annotated_item_kind =\n-                if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n-            Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n-        };\n+        PathKind::Expr {\n+            expr_ctx: ExprCtx {\n+                in_block_expr,\n+                in_loop_body,\n+                after_if_expr,\n+                in_condition,\n+                ref_expr_parent,\n+                is_func_update,\n+                innermost_ret_ty,\n+                self_param,\n+                incomplete_let,\n+                impl_,\n+                in_match_guard,\n+            },\n+        }\n+    };\n+    let make_path_kind_type = |ty: ast::Type| {\n+        let location = type_location(ty.syntax());\n+        PathKind::Type { location: location.unwrap_or(TypeLocation::Other) }\n+    };\n \n-        // Infer the path kind\n-        let parent = path.syntax().parent()?;\n+    let mut kind_macro_call = |it: ast::MacroCall| {\n+        path_ctx.has_macro_bang = it.excl_token().is_some();\n+        let parent = it.syntax().parent()?;\n+        // Any path in an item list will be treated as a macro call by the parser\n         let kind = match_ast! {\n             match parent {\n-                ast::PathType(it) => make_path_kind_type(it.into()),\n-                ast::PathExpr(it) => {\n-                    if let Some(p) = it.syntax().parent() {\n-                        if ast::ExprStmt::can_cast(p.kind()) {\n-                            if let Some(kind) = inbetween_body_and_decl_check(p) {\n-                                return Some(make_res(NameRefKind::Keyword(kind)));\n-                            }\n-                        }\n-                    }\n-\n-                    path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n-\n-                    make_path_kind_expr(it.into())\n-                },\n-                ast::TupleStructPat(it) => {\n-                    path_ctx.has_call_parens = true;\n-                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                },\n-                ast::RecordPat(it) => {\n-                    path_ctx.has_call_parens = true;\n-                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                },\n-                ast::PathPat(it) => {\n-                    PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                },\n-                ast::MacroCall(it) => {\n-                    // A macro call in this position is usually a result of parsing recovery, so check that\n-                    if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n-                        return Some(make_res(NameRefKind::Keyword(kind)));\n-                    }\n-\n-                    kind_macro_call(it)?\n-                },\n-                ast::Meta(meta) => make_path_kind_attr(meta)?,\n-                ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                ast::UseTree(_) => PathKind::Use,\n-                // completing inside a qualifier\n-                ast::Path(parent) => {\n-                    path_ctx.parent = Some(parent.clone());\n-                    let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n-                    match_ast! {\n-                        match parent {\n-                            ast::PathType(it) => make_path_kind_type(it.into()),\n-                            ast::PathExpr(it) => {\n-                                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n-\n-                                make_path_kind_expr(it.into())\n-                            },\n-                            ast::TupleStructPat(it) => {\n-                                path_ctx.has_call_parens = true;\n-                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                            },\n-                            ast::RecordPat(it) => {\n-                                path_ctx.has_call_parens = true;\n-                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n-                            },\n-                            ast::PathPat(it) => {\n-                                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n-                            },\n-                            ast::MacroCall(it) => {\n-                                kind_macro_call(it)?\n+                ast::MacroExpr(expr) => make_path_kind_expr(expr.into()),\n+                ast::MacroPat(it) => PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())},\n+                ast::MacroType(ty) => make_path_kind_type(ty.into()),\n+                ast::ItemList(_) => PathKind::Item { kind: ItemListKind::Module },\n+                ast::AssocItemList(_) => PathKind::Item { kind: match parent.parent() {\n+                    Some(it) => match_ast! {\n+                        match it {\n+                            ast::Trait(_) => ItemListKind::Trait,\n+                            ast::Impl(it) => if it.trait_().is_some() {\n+                                ItemListKind::TraitImpl(find_node_in_file_compensated(sema, original_file, &it))\n+                            } else {\n+                                ItemListKind::Impl\n                             },\n-                            ast::Meta(meta) => make_path_kind_attr(meta)?,\n-                            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n-                            ast::UseTree(_) => PathKind::Use,\n-                            ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n-                            _ => return None,\n+                            _ => return None\n                         }\n-                    }\n-                },\n-                ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                    },\n+                    None => return None,\n+                } },\n+                ast::ExternItemList(_) => PathKind::Item { kind: ItemListKind::ExternBlock },\n+                ast::SourceFile(_) => PathKind::Item { kind: ItemListKind::SourceFile },\n                 _ => return None,\n             }\n         };\n+        Some(kind)\n+    };\n+    let make_path_kind_attr = |meta: ast::Meta| {\n+        let attr = meta.parent_attr()?;\n+        let kind = attr.kind();\n+        let attached = attr.syntax().parent()?;\n+        let is_trailing_outer_attr = kind != AttrKind::Inner\n+            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n+        let annotated_item_kind = if is_trailing_outer_attr { None } else { Some(attached.kind()) };\n+        Some(PathKind::Attr { attr_ctx: AttrCtx { kind, annotated_item_kind } })\n+    };\n \n-        path_ctx.kind = kind;\n-        path_ctx.has_type_args = segment.generic_arg_list().is_some();\n+    // Infer the path kind\n+    let parent = path.syntax().parent()?;\n+    let kind = match_ast! {\n+        match parent {\n+            ast::PathType(it) => make_path_kind_type(it.into()),\n+            ast::PathExpr(it) => {\n+                if let Some(p) = it.syntax().parent() {\n+                    if ast::ExprStmt::can_cast(p.kind()) {\n+                        if let Some(kind) = inbetween_body_and_decl_check(p) {\n+                            return Some(make_res(NameRefKind::Keyword(kind)));\n+                        }\n+                    }\n+                }\n \n-        // calculate the qualifier context\n-        if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n-            path_ctx.use_tree_parent = use_tree_parent;\n-            if !use_tree_parent && segment.coloncolon_token().is_some() {\n-                path_ctx.qualified = Qualified::Absolute;\n-            } else {\n-                let qualifier = qualifier\n-                    .segment()\n-                    .and_then(|it| find_node_in_file(original_file, &it))\n-                    .map(|it| it.parent_path());\n-                if let Some(qualifier) = qualifier {\n-                    let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n-                        Some(ast::PathSegmentKind::Type {\n-                            type_ref: Some(type_ref),\n-                            trait_ref,\n-                        }) if qualifier.qualifier().is_none() => Some((type_ref, trait_ref)),\n-                        _ => None,\n-                    };\n+                path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                make_path_kind_expr(it.into())\n+            },\n+            ast::TupleStructPat(it) => {\n+                path_ctx.has_call_parens = true;\n+                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+            },\n+            ast::RecordPat(it) => {\n+                path_ctx.has_call_parens = true;\n+                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+            },\n+            ast::PathPat(it) => {\n+                PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+            },\n+            ast::MacroCall(it) => {\n+                // A macro call in this position is usually a result of parsing recovery, so check that\n+                if let Some(kind) = inbetween_body_and_decl_check(it.syntax().clone()) {\n+                    return Some(make_res(NameRefKind::Keyword(kind)));\n+                }\n \n-                    path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n-                        let ty = match ty {\n-                            ast::Type::InferType(_) => None,\n-                            ty => sema.resolve_type(&ty),\n-                        };\n-                        let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n-                        Qualified::TypeAnchor { ty, trait_ }\n-                    } else {\n-                        let res = sema.resolve_path(&qualifier);\n-\n-                        // For understanding how and why super_chain_len is calculated the way it\n-                        // is check the documentation at it's definition\n-                        let mut segment_count = 0;\n-                        let super_count =\n-                            iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n-                                .take_while(|p| {\n-                                    p.segment()\n-                                        .and_then(|s| {\n-                                            segment_count += 1;\n-                                            s.super_token()\n-                                        })\n-                                        .is_some()\n-                                })\n-                                .count();\n+                kind_macro_call(it)?\n+            },\n+            ast::Meta(meta) => make_path_kind_attr(meta)?,\n+            ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+            ast::UseTree(_) => PathKind::Use,\n+            // completing inside a qualifier\n+            ast::Path(parent) => {\n+                path_ctx.parent = Some(parent.clone());\n+                let parent = iter::successors(Some(parent), |it| it.parent_path()).last()?.syntax().parent()?;\n+                match_ast! {\n+                    match parent {\n+                        ast::PathType(it) => make_path_kind_type(it.into()),\n+                        ast::PathExpr(it) => {\n+                            path_ctx.has_call_parens = it.syntax().parent().map_or(false, |it| ast::CallExpr::can_cast(it.kind()));\n+\n+                            make_path_kind_expr(it.into())\n+                        },\n+                        ast::TupleStructPat(it) => {\n+                            path_ctx.has_call_parens = true;\n+                            PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                        },\n+                        ast::RecordPat(it) => {\n+                            path_ctx.has_call_parens = true;\n+                            PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into()) }\n+                        },\n+                        ast::PathPat(it) => {\n+                            PathKind::Pat { pat_ctx: pattern_context_for(sema, original_file, it.into())}\n+                        },\n+                        ast::MacroCall(it) => {\n+                            kind_macro_call(it)?\n+                        },\n+                        ast::Meta(meta) => make_path_kind_attr(meta)?,\n+                        ast::Visibility(it) => PathKind::Vis { has_in_token: it.in_token().is_some() },\n+                        ast::UseTree(_) => PathKind::Use,\n+                        ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+                        _ => return None,\n+                    }\n+                }\n+            },\n+            ast::RecordExpr(it) => make_path_kind_expr(it.into()),\n+            _ => return None,\n+        }\n+    };\n \n-                        let super_chain_len =\n-                            if segment_count > super_count { None } else { Some(super_count) };\n+    path_ctx.kind = kind;\n+    path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n-                        Qualified::With { path: qualifier, resolution: res, super_chain_len }\n+    // calculate the qualifier context\n+    if let Some((qualifier, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+        path_ctx.use_tree_parent = use_tree_parent;\n+        if !use_tree_parent && segment.coloncolon_token().is_some() {\n+            path_ctx.qualified = Qualified::Absolute;\n+        } else {\n+            let qualifier = qualifier\n+                .segment()\n+                .and_then(|it| find_node_in_file(original_file, &it))\n+                .map(|it| it.parent_path());\n+            if let Some(qualifier) = qualifier {\n+                let type_anchor = match qualifier.segment().and_then(|it| it.kind()) {\n+                    Some(ast::PathSegmentKind::Type { type_ref: Some(type_ref), trait_ref })\n+                        if qualifier.qualifier().is_none() =>\n+                    {\n+                        Some((type_ref, trait_ref))\n                     }\n+                    _ => None,\n                 };\n-            }\n-        } else if let Some(segment) = path.segment() {\n-            if segment.coloncolon_token().is_some() {\n-                path_ctx.qualified = Qualified::Absolute;\n-            }\n-        }\n \n-        let mut qualifier_ctx = QualifierCtx::default();\n-        if path_ctx.is_trivial_path() {\n-            // fetch the full expression that may have qualifiers attached to it\n-            let top_node = match path_ctx.kind {\n-                PathKind::Expr { expr_ctx: ExprCtx { in_block_expr: true, .. } } => {\n-                    parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n-                        let parent = p.parent()?;\n-                        if ast::StmtList::can_cast(parent.kind()) {\n-                            Some(p)\n-                        } else if ast::ExprStmt::can_cast(parent.kind()) {\n-                            Some(parent)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                PathKind::Item { .. } => {\n-                    parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+                path_ctx.qualified = if let Some((ty, trait_ref)) = type_anchor {\n+                    let ty = match ty {\n+                        ast::Type::InferType(_) => None,\n+                        ty => sema.resolve_type(&ty),\n+                    };\n+                    let trait_ = trait_ref.and_then(|it| sema.resolve_trait(&it.path()?));\n+                    Qualified::TypeAnchor { ty, trait_ }\n+                } else {\n+                    let res = sema.resolve_path(&qualifier);\n+\n+                    // For understanding how and why super_chain_len is calculated the way it\n+                    // is check the documentation at it's definition\n+                    let mut segment_count = 0;\n+                    let super_count = iter::successors(Some(qualifier.clone()), |p| p.qualifier())\n+                        .take_while(|p| {\n+                            p.segment()\n+                                .and_then(|s| {\n+                                    segment_count += 1;\n+                                    s.super_token()\n+                                })\n+                                .is_some()\n+                        })\n+                        .count();\n+\n+                    let super_chain_len =\n+                        if segment_count > super_count { None } else { Some(super_count) };\n+\n+                    Qualified::With { path: qualifier, resolution: res, super_chain_len }\n                 }\n-                _ => None,\n             };\n-            if let Some(top) = top_node {\n-                if let Some(NodeOrToken::Node(error_node)) =\n-                    syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n-                {\n-                    if error_node.kind() == SyntaxKind::ERROR {\n-                        qualifier_ctx.unsafe_tok = error_node\n-                            .children_with_tokens()\n-                            .filter_map(NodeOrToken::into_token)\n-                            .find(|it| it.kind() == T![unsafe]);\n-                        qualifier_ctx.vis_node =\n-                            error_node.children().find_map(ast::Visibility::cast);\n+        }\n+    } else if let Some(segment) = path.segment() {\n+        if segment.coloncolon_token().is_some() {\n+            path_ctx.qualified = Qualified::Absolute;\n+        }\n+    }\n+\n+    let mut qualifier_ctx = QualifierCtx::default();\n+    if path_ctx.is_trivial_path() {\n+        // fetch the full expression that may have qualifiers attached to it\n+        let top_node = match path_ctx.kind {\n+            PathKind::Expr { expr_ctx: ExprCtx { in_block_expr: true, .. } } => {\n+                parent.ancestors().find(|it| ast::PathExpr::can_cast(it.kind())).and_then(|p| {\n+                    let parent = p.parent()?;\n+                    if ast::StmtList::can_cast(parent.kind()) {\n+                        Some(p)\n+                    } else if ast::ExprStmt::can_cast(parent.kind()) {\n+                        Some(parent)\n+                    } else {\n+                        None\n                     }\n+                })\n+            }\n+            PathKind::Item { .. } => {\n+                parent.ancestors().find(|it| ast::MacroCall::can_cast(it.kind()))\n+            }\n+            _ => None,\n+        };\n+        if let Some(top) = top_node {\n+            if let Some(NodeOrToken::Node(error_node)) =\n+                syntax::algo::non_trivia_sibling(top.clone().into(), syntax::Direction::Prev)\n+            {\n+                if error_node.kind() == SyntaxKind::ERROR {\n+                    qualifier_ctx.unsafe_tok = error_node\n+                        .children_with_tokens()\n+                        .filter_map(NodeOrToken::into_token)\n+                        .find(|it| it.kind() == T![unsafe]);\n+                    qualifier_ctx.vis_node = error_node.children().find_map(ast::Visibility::cast);\n                 }\n+            }\n \n-                if let PathKind::Item { .. } = path_ctx.kind {\n-                    if qualifier_ctx.none() {\n-                        if let Some(t) = top.first_token() {\n-                            if let Some(prev) = t\n-                                .prev_token()\n-                                .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n-                            {\n-                                if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n-                                    // This was inferred to be an item position path, but it seems\n-                                    // to be part of some other broken node which leaked into an item\n-                                    // list\n-                                    return None;\n-                                }\n+            if let PathKind::Item { .. } = path_ctx.kind {\n+                if qualifier_ctx.none() {\n+                    if let Some(t) = top.first_token() {\n+                        if let Some(prev) = t\n+                            .prev_token()\n+                            .and_then(|t| syntax::algo::skip_trivia_token(t, Direction::Prev))\n+                        {\n+                            if ![T![;], T!['}'], T!['{']].contains(&prev.kind()) {\n+                                // This was inferred to be an item position path, but it seems\n+                                // to be part of some other broken node which leaked into an item\n+                                // list\n+                                return None;\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n-        Some((NameRefContext { nameref, kind: NameRefKind::Path(path_ctx) }, qualifier_ctx))\n     }\n+    Some((NameRefContext { nameref, kind: NameRefKind::Path(path_ctx) }, qualifier_ctx))\n }\n \n fn pattern_context_for("}, {"sha": "9d0044e55f598870413f74f7ce879d267342482c", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Flib.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -183,6 +183,7 @@ pub fn completions(\n             CompletionAnalysis::String { original, expanded: Some(expanded) } => {\n                 completions::extern_abi::complete_extern_abi(acc, ctx, expanded);\n                 completions::format_string::format_string(acc, ctx, original, expanded);\n+                completions::env_vars::complete_cargo_env_vars(acc, ctx, expanded);\n             }\n             CompletionAnalysis::UnexpandedAttrTT {\n                 colon_prefix,"}, {"sha": "cf0bcd5c96b2a39e93fed07524c95246f3ff5735", "filename": "src/tools/rust-analyzer/crates/ide-db/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -15,9 +15,9 @@ tracing = \"0.1.35\"\n rayon = \"1.5.3\"\n fst = { version = \"0.4.7\", default-features = false }\n rustc-hash = \"1.1.0\"\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n either = \"1.7.0\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n arrayvec = \"0.7.2\"\n indexmap = \"1.9.1\"\n memchr = \"2.5.0\""}, {"sha": "2d6927cee9953c2fdd9a1a1e7cdc93d6ba2cbdfa", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/format_string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -1,7 +1,8 @@\n //! Tools to work with format string literals for the `format_args!` family of macros.\n+use crate::syntax_helpers::node_ext::macro_call_for_string_token;\n use syntax::{\n     ast::{self, IsString},\n-    AstNode, AstToken, TextRange, TextSize,\n+    TextRange, TextSize,\n };\n \n pub fn is_format_string(string: &ast::String) -> bool {\n@@ -14,8 +15,7 @@ pub fn is_format_string(string: &ast::String) -> bool {\n     // This setup lets us correctly highlight the components of `concat!(\"{}\", \"bla\")` format\n     // strings. It still fails for `concat!(\"{\", \"}\")`, but that is rare.\n     (|| {\n-        let macro_call = string.syntax().parent_ancestors().find_map(ast::MacroCall::cast)?;\n-        let name = macro_call.path()?.segment()?.name_ref()?;\n+        let name = macro_call_for_string_token(string)?.path()?.segment()?.name_ref()?;\n \n         if !matches!(\n             name.text().as_str(),"}, {"sha": "39710b8f13eb5f7024b8fe2a385ead1badda3a21", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -2,8 +2,8 @@\n use itertools::Itertools;\n use parser::T;\n use syntax::{\n-    ast::{self, HasLoopBody, PathSegmentKind, VisibilityKind},\n-    AstNode, Preorder, RustLanguage, WalkEvent,\n+    ast::{self, HasLoopBody, MacroCall, PathSegmentKind, VisibilityKind},\n+    AstNode, AstToken, Preorder, RustLanguage, WalkEvent,\n };\n \n pub fn expr_as_name_ref(expr: &ast::Expr) -> Option<ast::NameRef> {\n@@ -457,3 +457,8 @@ pub fn parse_tt_as_comma_sep_paths(input: ast::TokenTree) -> Option<Vec<ast::Pat\n         .collect();\n     Some(paths)\n }\n+\n+pub fn macro_call_for_string_token(string: &ast::String) -> Option<MacroCall> {\n+    let macro_call = string.syntax().parent_ancestors().find_map(ast::MacroCall::cast)?;\n+    Some(macro_call)\n+}"}, {"sha": "e1d146f4ee561f368c7125ee3330d742394ed4e5", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/Cargo.toml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -11,11 +11,9 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n-\n-\n either = \"1.7.0\"\n-serde_json = \"1.0.82\"\n+itertools = \"0.10.5\"\n+serde_json = \"1.0.86\"\n \n profile = { path = \"../profile\", version = \"0.0.0\" }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "085d8d32598a1301acb9f96512d1f9d7e71a008b", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/incorrect_try_expr.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincorrect_try_expr.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -0,0 +1,37 @@\n+use hir::InFile;\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: incorrect-try-target\n+//\n+// This diagnostic is triggered if a question mark operator was used in a context where it is not applicable.\n+pub(crate) fn incorrect_try_expr(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::IncorrectTryExpr,\n+) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incorrect-try-target\",\n+        format!(\"the return type of the containing function does not implement `FromResidual`\"),\n+        ctx.sema\n+            .diagnostics_display_range(InFile::new(d.expr.file_id, d.expr.value.clone().into()))\n+            .range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn try_ops_diag() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: try\n+fn test() {\n+    core::ops::ControlFlow::<u32, f32>::Continue(1.0)?;\n+ // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: the return type of the containing function does not implement `FromResidual`\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "3bf6a4232298c7884a69c2ccd072f3483ed554c5", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/not_implemented.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fnot_implemented.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -0,0 +1,35 @@\n+use hir::{db::DefDatabase, HirDisplay};\n+\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: not-implemented\n+//\n+// This diagnostic is triggered if a type doesn't implement a necessary trait.\n+pub(crate) fn not_implemented(ctx: &DiagnosticsContext<'_>, d: &hir::NotImplemented) -> Diagnostic {\n+    Diagnostic::new(\n+        \"not-implemented\",\n+        format!(\n+            \"the trait `{}` is not implemented for `{}`\",\n+            ctx.sema.db.trait_data(d.trait_).name,\n+            d.ty.display(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn missing_try_impl() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: try\n+fn main() {\n+    ()?;\n+} //^^ error: the trait `Try` is not implemented for `()`\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "4577072149a72d7b6d3a0d64f391f1bc5ef6404d", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -29,13 +29,15 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incorrect_case;\n+    pub(crate) mod incorrect_try_expr;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n     pub(crate) mod malformed_derive;\n     pub(crate) mod mismatched_arg_count;\n     pub(crate) mod missing_fields;\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n+    pub(crate) mod not_implemented;\n     pub(crate) mod no_such_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n@@ -225,12 +227,14 @@ pub fn diagnostics(\n         let d = match diag {\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::IncorrectTryExpr(d) => handlers::incorrect_try_expr::incorrect_try_expr(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::NotImplemented(d) => handlers::not_implemented::not_implemented(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),"}, {"sha": "4baf786c455525acf462683ac82ab2515ea6bef3", "filename": "src/tools/rust-analyzer/crates/ide-ssr/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-ssr%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -12,8 +12,7 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n \n text-edit = { path = \"../text-edit\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }"}, {"sha": "712459a7ee9c688c3117f38f6546b7f47163b428", "filename": "src/tools/rust-analyzer/crates/ide/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -13,12 +13,12 @@ doctest = false\n cov-mark = \"2.0.0-pre.1\"\n crossbeam-channel = \"0.5.5\"\n either = \"1.7.0\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n tracing = \"0.1.35\"\n oorandom = \"11.1.3\"\n-pulldown-cmark-to-cmark = \"10.0.1\"\n+pulldown-cmark-to-cmark = \"10.0.4\"\n pulldown-cmark = { version = \"0.9.1\", default-features = false }\n-url = \"2.2.2\"\n+url = \"2.3.1\"\n dot = \"0.1.4\"\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }"}, {"sha": "d0be1b3f4047942fd53ef846bea823316709059a", "filename": "src/tools/rust-analyzer/crates/ide/src/goto_definition.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -48,10 +48,14 @@ pub(crate) fn goto_definition(\n             _ => 1,\n         })?;\n     if let Some(doc_comment) = token_as_doc_comment(&original_token) {\n-        return doc_comment.get_definition_with_descend_at(sema, position.offset, |def, _, _| {\n-            let nav = def.try_to_nav(db)?;\n-            Some(RangeInfo::new(original_token.text_range(), vec![nav]))\n-        });\n+        return doc_comment.get_definition_with_descend_at(\n+            sema,\n+            position.offset,\n+            |def, _, link_range| {\n+                let nav = def.try_to_nav(db)?;\n+                Some(RangeInfo::new(link_range, vec![nav]))\n+            },\n+        );\n     }\n     let navs = sema\n         .descend_into_macros(original_token.clone())"}, {"sha": "5cab017a58dbdba582340ca11d9c682bfd58294c", "filename": "src/tools/rust-analyzer/crates/ide/src/hover/tests.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -4913,6 +4913,22 @@ fn foo() -> NotResult<(), Short> {\n                 ```\n             \"#]],\n     );\n+    check_hover_range(\n+        r#\"\n+//- minicore: try\n+use core::ops::ControlFlow;\n+fn foo() -> ControlFlow<()> {\n+    $0ControlFlow::Break(())?$0;\n+    ControlFlow::Continue(())\n+}\n+\"#,\n+        expect![[r#\"\n+            ```text\n+            Try Target Type: ControlFlow<(), {unknown}>\n+            Propagated as:          ControlFlow<(), ()>\n+            ```\n+        \"#]],\n+    );\n }\n \n #[test]\n@@ -4928,9 +4944,9 @@ fn foo() -> Option<()> {\n }\n \"#,\n         expect![[r#\"\n-                ```rust\n-                <Option<i32> as Try>::Output\n-                ```\"#]],\n+            ```rust\n+            i32\n+            ```\"#]],\n     );\n }\n "}, {"sha": "13cd8901031d526c91c7d9561a8e647e0d738242", "filename": "src/tools/rust-analyzer/crates/mbe/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n rustc-hash = \"1.1.0\"\n-smallvec = \"1.9.0\"\n+smallvec = \"1.10.0\"\n tracing = \"0.1.35\"\n \n syntax = { path = \"../syntax\", version = \"0.0.0\" }"}, {"sha": "9c92bae6a1962d593219c3d869bb0c454967ec78", "filename": "src/tools/rust-analyzer/crates/mbe/src/benchmark.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -8,7 +8,7 @@ use syntax::{\n use test_utils::{bench, bench_fixture, skip_slow_tests};\n \n use crate::{\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     syntax_node_to_token_tree, DeclarativeMacro,\n };\n \n@@ -111,35 +111,35 @@ fn invocation_fixtures(rules: &FxHashMap<String, DeclarativeMacro>) -> Vec<(Stri\n \n     fn collect_from_op(op: &Op, parent: &mut tt::Subtree, seed: &mut usize) {\n         return match op {\n-            Op::Var { kind, .. } => match kind.as_ref().map(|it| it.as_str()) {\n-                Some(\"ident\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"ty\") => parent.token_trees.push(make_ident(\"Foo\")),\n-                Some(\"tt\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"vis\") => parent.token_trees.push(make_ident(\"pub\")),\n-                Some(\"pat\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"path\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"literal\") => parent.token_trees.push(make_literal(\"1\")),\n-                Some(\"expr\") => parent.token_trees.push(make_ident(\"foo\")),\n-                Some(\"lifetime\") => {\n+            Op::Var { kind, .. } => match kind.as_ref() {\n+                Some(MetaVarKind::Ident) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Ty) => parent.token_trees.push(make_ident(\"Foo\")),\n+                Some(MetaVarKind::Tt) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Vis) => parent.token_trees.push(make_ident(\"pub\")),\n+                Some(MetaVarKind::Pat) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Path) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Literal) => parent.token_trees.push(make_literal(\"1\")),\n+                Some(MetaVarKind::Expr) => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(MetaVarKind::Lifetime) => {\n                     parent.token_trees.push(make_punct('\\''));\n                     parent.token_trees.push(make_ident(\"a\"));\n                 }\n-                Some(\"block\") => {\n+                Some(MetaVarKind::Block) => {\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None))\n                 }\n-                Some(\"item\") => {\n+                Some(MetaVarKind::Item) => {\n                     parent.token_trees.push(make_ident(\"fn\"));\n                     parent.token_trees.push(make_ident(\"foo\"));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None));\n                 }\n-                Some(\"meta\") => {\n+                Some(MetaVarKind::Meta) => {\n                     parent.token_trees.push(make_ident(\"foo\"));\n                     parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n                 }\n \n                 None => (),\n-                Some(kind) => panic!(\"Unhandled kind {}\", kind),\n+                Some(kind) => panic!(\"Unhandled kind {:?}\", kind),\n             },\n             Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n             Op::Repeat { tokens, kind, separator } => {"}, {"sha": "100ec6bfb93ac17e3cf0006c8c65ed78c5e7b646", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -8,7 +8,7 @@ mod transcriber;\n use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n-use crate::{ExpandError, ExpandResult};\n+use crate::{parser::MetaVarKind, ExpandError, ExpandResult};\n \n pub(crate) fn expand_rules(\n     rules: &[crate::Rule],\n@@ -104,6 +104,7 @@ enum Binding {\n     Fragment(Fragment),\n     Nested(Vec<Binding>),\n     Empty,\n+    Missing(MetaVarKind),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "3f656df25f7d4e04398ed1df21bc046dc0c35d2c", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 35, "deletions": 19, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -66,7 +66,7 @@ use syntax::SmolStr;\n \n use crate::{\n     expander::{Binding, Bindings, ExpandResult, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     tt_iter::TtIter,\n     ExpandError, MetaTemplate,\n };\n@@ -119,6 +119,7 @@ pub(super) fn match_(pattern: &MetaTemplate, input: &tt::Subtree) -> Match {\n             .map(|it| match it {\n                 Binding::Fragment(_) => 1,\n                 Binding::Empty => 1,\n+                Binding::Missing(_) => 1,\n                 Binding::Nested(it) => count(it.iter()),\n             })\n             .sum()\n@@ -130,6 +131,7 @@ enum BindingKind {\n     Empty(SmolStr),\n     Optional(SmolStr),\n     Fragment(SmolStr, Fragment),\n+    Missing(SmolStr, MetaVarKind),\n     Nested(usize, usize),\n }\n \n@@ -190,6 +192,10 @@ impl BindingsBuilder {\n             .push(LinkNode::Node(Rc::new(BindingKind::Fragment(var.clone(), fragment))));\n     }\n \n+    fn push_missing(&mut self, idx: &mut BindingsIdx, var: &SmolStr, kind: MetaVarKind) {\n+        self.nodes[idx.0].push(LinkNode::Node(Rc::new(BindingKind::Missing(var.clone(), kind))));\n+    }\n+\n     fn push_nested(&mut self, parent: &mut BindingsIdx, child: &BindingsIdx) {\n         let BindingsIdx(idx, nidx) = self.copy(child);\n         self.nodes[parent.0].push(LinkNode::Node(Rc::new(BindingKind::Nested(idx, nidx))));\n@@ -222,6 +228,9 @@ impl BindingsBuilder {\n                 BindingKind::Fragment(name, fragment) => {\n                     bindings.inner.insert(name.clone(), Binding::Fragment(fragment.clone()));\n                 }\n+                BindingKind::Missing(name, kind) => {\n+                    bindings.inner.insert(name.clone(), Binding::Missing(*kind));\n+                }\n                 BindingKind::Nested(idx, nested_idx) => {\n                     let mut nested_nodes = Vec::new();\n                     self.collect_nested(*idx, *nested_idx, &mut nested_nodes);\n@@ -458,9 +467,9 @@ fn match_loop_inner<'t>(\n                 }\n             }\n             OpDelimited::Op(Op::Var { kind, name, .. }) => {\n-                if let Some(kind) = kind {\n+                if let &Some(kind) = kind {\n                     let mut fork = src.clone();\n-                    let match_res = match_meta_var(kind.as_str(), &mut fork);\n+                    let match_res = match_meta_var(kind, &mut fork);\n                     match match_res.err {\n                         None => {\n                             // Some meta variables are optional (e.g. vis)\n@@ -475,8 +484,15 @@ fn match_loop_inner<'t>(\n                         }\n                         Some(err) => {\n                             res.add_err(err);\n-                            if let Some(fragment) = match_res.value {\n-                                bindings_builder.push_fragment(&mut item.bindings, name, fragment);\n+                            match match_res.value {\n+                                Some(fragment) => bindings_builder.push_fragment(\n+                                    &mut item.bindings,\n+                                    name,\n+                                    fragment,\n+                                ),\n+                                None => {\n+                                    bindings_builder.push_missing(&mut item.bindings, name, kind)\n+                                }\n                             }\n                             item.is_error = true;\n                             error_items.push(item);\n@@ -668,20 +684,20 @@ fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter<'_>) -> Result<(), ExpandError> {\n     }\n }\n \n-fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n+fn match_meta_var(kind: MetaVarKind, input: &mut TtIter<'_>) -> ExpandResult<Option<Fragment>> {\n     let fragment = match kind {\n-        \"path\" => parser::PrefixEntryPoint::Path,\n-        \"ty\" => parser::PrefixEntryPoint::Ty,\n+        MetaVarKind::Path => parser::PrefixEntryPoint::Path,\n+        MetaVarKind::Ty => parser::PrefixEntryPoint::Ty,\n         // FIXME: These two should actually behave differently depending on the edition.\n         //\n         // https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html\n-        \"pat\" | \"pat_param\" => parser::PrefixEntryPoint::Pat,\n-        \"stmt\" => parser::PrefixEntryPoint::Stmt,\n-        \"block\" => parser::PrefixEntryPoint::Block,\n-        \"meta\" => parser::PrefixEntryPoint::MetaItem,\n-        \"item\" => parser::PrefixEntryPoint::Item,\n-        \"vis\" => parser::PrefixEntryPoint::Vis,\n-        \"expr\" => {\n+        MetaVarKind::Pat | MetaVarKind::PatParam => parser::PrefixEntryPoint::Pat,\n+        MetaVarKind::Stmt => parser::PrefixEntryPoint::Stmt,\n+        MetaVarKind::Block => parser::PrefixEntryPoint::Block,\n+        MetaVarKind::Meta => parser::PrefixEntryPoint::MetaItem,\n+        MetaVarKind::Item => parser::PrefixEntryPoint::Item,\n+        MetaVarKind::Vis => parser::PrefixEntryPoint::Vis,\n+        MetaVarKind::Expr => {\n             // `expr` should not match underscores.\n             // HACK: Macro expansion should not be done using \"rollback and try another alternative\".\n             // rustc [explicitly checks the next token][0].\n@@ -698,17 +714,17 @@ fn match_meta_var(kind: &str, input: &mut TtIter<'_>) -> ExpandResult<Option<Fra\n         }\n         _ => {\n             let tt_result = match kind {\n-                \"ident\" => input\n+                MetaVarKind::Ident => input\n                     .expect_ident()\n                     .map(|ident| tt::Leaf::from(ident.clone()).into())\n                     .map_err(|()| ExpandError::binding_error(\"expected ident\")),\n-                \"tt\" => input\n+                MetaVarKind::Tt => input\n                     .expect_tt()\n                     .map_err(|()| ExpandError::binding_error(\"expected token tree\")),\n-                \"lifetime\" => input\n+                MetaVarKind::Lifetime => input\n                     .expect_lifetime()\n                     .map_err(|()| ExpandError::binding_error(\"expected lifetime\")),\n-                \"literal\" => {\n+                MetaVarKind::Literal => {\n                     let neg = input.eat_char('-');\n                     input\n                         .expect_literal()"}, {"sha": "cbb59ab8e67b5f5278a35c3f5c6c9a7368ad5e14", "filename": "src/tools/rust-analyzer/crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -6,7 +6,7 @@ use tt::{Delimiter, Subtree};\n \n use crate::{\n     expander::{Binding, Bindings, Fragment},\n-    parser::{Op, RepeatKind, Separator},\n+    parser::{MetaVarKind, Op, RepeatKind, Separator},\n     ExpandError, ExpandResult, MetaTemplate,\n };\n \n@@ -15,7 +15,7 @@ impl Bindings {\n         self.inner.contains_key(name)\n     }\n \n-    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n+    fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<Fragment, ExpandError> {\n         macro_rules! binding_err {\n             ($($arg:tt)*) => { ExpandError::binding_error(format!($($arg)*)) };\n         }\n@@ -26,6 +26,7 @@ impl Bindings {\n             nesting_state.hit = true;\n             b = match b {\n                 Binding::Fragment(_) => break,\n+                Binding::Missing(_) => break,\n                 Binding::Nested(bs) => bs.get(nesting_state.idx).ok_or_else(|| {\n                     nesting_state.at_end = true;\n                     binding_err!(\"could not find nested binding `{name}`\")\n@@ -37,7 +38,55 @@ impl Bindings {\n             };\n         }\n         match b {\n-            Binding::Fragment(it) => Ok(it),\n+            Binding::Fragment(it) => Ok(it.clone()),\n+            // emit some reasonable default expansion for missing bindings,\n+            // this gives better recovery than emitting the `$fragment-name` verbatim\n+            Binding::Missing(it) => Ok(match it {\n+                MetaVarKind::Stmt => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Punct(tt::Punct {\n+                        id: tt::TokenId::unspecified(),\n+                        char: ';',\n+                        spacing: tt::Spacing::Alone,\n+                    })))\n+                }\n+                MetaVarKind::Block => Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                    delimiter: Some(tt::Delimiter {\n+                        id: tt::TokenId::unspecified(),\n+                        kind: tt::DelimiterKind::Brace,\n+                    }),\n+                    token_trees: vec![],\n+                })),\n+                // FIXME: Meta and Item should get proper defaults\n+                MetaVarKind::Meta | MetaVarKind::Item | MetaVarKind::Tt | MetaVarKind::Vis => {\n+                    Fragment::Tokens(tt::TokenTree::Subtree(tt::Subtree {\n+                        delimiter: None,\n+                        token_trees: vec![],\n+                    }))\n+                }\n+                MetaVarKind::Path\n+                | MetaVarKind::Ty\n+                | MetaVarKind::Pat\n+                | MetaVarKind::PatParam\n+                | MetaVarKind::Expr\n+                | MetaVarKind::Ident => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"missing\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+                MetaVarKind::Lifetime => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"'missing\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+                MetaVarKind::Literal => {\n+                    Fragment::Tokens(tt::TokenTree::Leaf(tt::Leaf::Ident(tt::Ident {\n+                        text: SmolStr::new_inline(\"\\\"missing\\\"\"),\n+                        id: tt::TokenId::unspecified(),\n+                    })))\n+                }\n+            }),\n             Binding::Nested(_) => {\n                 Err(binding_err!(\"expected simple binding, found nested binding `{name}`\"))\n             }\n@@ -157,7 +206,7 @@ fn expand_var(ctx: &mut ExpandCtx<'_>, v: &SmolStr, id: tt::TokenId) -> ExpandRe\n     } else {\n         ctx.bindings.get(v, &mut ctx.nesting).map_or_else(\n             |e| ExpandResult { value: Fragment::Tokens(tt::TokenTree::empty()), err: Some(e) },\n-            |b| ExpandResult::ok(b.clone()),\n+            |it| ExpandResult::ok(it),\n         )\n     }\n }"}, {"sha": "c4f0fa20d6de03959f3600fd57bf6e52475c2eee", "filename": "src/tools/rust-analyzer/crates/mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Flib.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -21,7 +21,7 @@ mod token_map;\n use std::fmt;\n \n use crate::{\n-    parser::{MetaTemplate, Op},\n+    parser::{MetaTemplate, MetaVarKind, Op},\n     tt_iter::TtIter,\n };\n \n@@ -291,9 +291,9 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n                 // Checks that no repetition which could match an empty token\n                 // https://github.com/rust-lang/rust/blob/a58b1ed44f5e06976de2bdc4d7dc81c36a96934f/src/librustc_expand/mbe/macro_rules.rs#L558\n                 let lsh_is_empty_seq = separator.is_none() && subtree.iter().all(|child_op| {\n-                    match child_op {\n+                    match *child_op {\n                         // vis is optional\n-                        Op::Var { kind: Some(kind), .. } => kind == \"vis\",\n+                        Op::Var { kind: Some(kind), .. } => kind == MetaVarKind::Vis,\n                         Op::Repeat {\n                             kind: parser::RepeatKind::ZeroOrMore | parser::RepeatKind::ZeroOrOne,\n                             .."}, {"sha": "351c359b73c87ea8352a0bb406f7dbb285360849", "filename": "src/tools/rust-analyzer/crates/mbe/src/parser.rs", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fmbe%2Fsrc%2Fparser.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -50,7 +50,7 @@ impl MetaTemplate {\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum Op {\n-    Var { name: SmolStr, kind: Option<SmolStr>, id: tt::TokenId },\n+    Var { name: SmolStr, kind: Option<MetaVarKind>, id: tt::TokenId },\n     Ignore { name: SmolStr, id: tt::TokenId },\n     Index { depth: u32 },\n     Repeat { tokens: MetaTemplate, kind: RepeatKind, separator: Option<Separator> },\n@@ -65,6 +65,24 @@ pub(crate) enum RepeatKind {\n     ZeroOrOne,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum MetaVarKind {\n+    Path,\n+    Ty,\n+    Pat,\n+    PatParam,\n+    Stmt,\n+    Block,\n+    Meta,\n+    Item,\n+    Vis,\n+    Expr,\n+    Ident,\n+    Tt,\n+    Lifetime,\n+    Literal,\n+}\n+\n #[derive(Clone, Debug, Eq)]\n pub(crate) enum Separator {\n     Literal(tt::Literal),\n@@ -179,13 +197,30 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n     Ok(res)\n }\n \n-fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<SmolStr>, ParseError> {\n+fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<MetaVarKind>, ParseError> {\n     if let Mode::Pattern = mode {\n         src.expect_char(':').map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n         let ident = src\n             .expect_ident()\n             .map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n-        return Ok(Some(ident.text.clone()));\n+        let kind = match ident.text.as_str() {\n+            \"path\" => MetaVarKind::Path,\n+            \"ty\" => MetaVarKind::Ty,\n+            \"pat\" => MetaVarKind::Pat,\n+            \"pat_param\" => MetaVarKind::PatParam,\n+            \"stmt\" => MetaVarKind::Stmt,\n+            \"block\" => MetaVarKind::Block,\n+            \"meta\" => MetaVarKind::Meta,\n+            \"item\" => MetaVarKind::Item,\n+            \"vis\" => MetaVarKind::Vis,\n+            \"expr\" => MetaVarKind::Expr,\n+            \"ident\" => MetaVarKind::Ident,\n+            \"tt\" => MetaVarKind::Tt,\n+            \"lifetime\" => MetaVarKind::Lifetime,\n+            \"literal\" => MetaVarKind::Literal,\n+            _ => return Ok(None),\n+        };\n+        return Ok(Some(kind));\n     };\n     Ok(None)\n }"}, {"sha": "54879c1870c050239ca2d8bb511a27fae6be54de", "filename": "src/tools/rust-analyzer/crates/proc-macro-api/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproc-macro-api%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -19,7 +19,7 @@ object = { version = \"0.29.0\", default-features = false, features = [\n ] }\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n serde_json = { version = \"1.0.81\", features = [\"unbounded_depth\"] }\n-tracing = \"0.1.35\"\n+tracing = \"0.1.37\"\n memmap2 = \"0.5.4\"\n snap = \"1.0.5\"\n "}, {"sha": "5697aea964f787a59bf8b0d5c49a4fc8aece848d", "filename": "src/tools/rust-analyzer/crates/profile/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fprofile%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -10,9 +10,9 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n cfg-if = \"1.0.0\"\n-libc = \"0.2.126\"\n+libc = \"0.2.135\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n countme = { version = \"3.0.1\", features = [\"enable\"] }\n jemalloc-ctl = { version = \"0.5.0\", package = \"tikv-jemalloc-ctl\", optional = true }"}, {"sha": "6fd7c3166f821a04b5ae83283a58334fe43ae3d3", "filename": "src/tools/rust-analyzer/crates/project-model/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -13,10 +13,10 @@ doctest = false\n tracing = \"0.1.35\"\n rustc-hash = \"1.1.0\"\n cargo_metadata = \"0.15.0\"\n-semver = \"1.0.10\"\n+semver = \"1.0.14\"\n serde = { version = \"1.0.137\", features = [\"derive\"] }\n-serde_json = \"1.0.81\"\n-anyhow = \"1.0.57\"\n+serde_json = \"1.0.86\"\n+anyhow = \"1.0.62\"\n expect-test = \"1.4.0\"\n la-arena = { version = \"0.3.0\", path = \"../../lib/la-arena\" }\n "}, {"sha": "d9f09c0349566129a762c9f58d528dea9094fa38", "filename": "src/tools/rust-analyzer/crates/project-model/src/build_scripts.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fproject-model%2Fsrc%2Fbuild_scripts.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -154,6 +154,8 @@ impl WorkspaceBuildScripts {\n                             Some(&it) => it,\n                             None => return,\n                         };\n+                        progress(format!(\"running build-script: {}\", workspace[package].name));\n+\n                         let cfgs = {\n                             let mut acc = Vec::new();\n                             for cfg in message.cfgs {\n@@ -189,7 +191,7 @@ impl WorkspaceBuildScripts {\n                             None => return,\n                         };\n \n-                        progress(format!(\"metadata {}\", message.target.name));\n+                        progress(format!(\"building proc-macros: {}\", message.target.name));\n \n                         if message.target.kind.iter().any(|k| k == \"proc-macro\") {\n                             // Skip rmeta file"}, {"sha": "5445028536cb54fcb6d2ac94da44ed6409223caf", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -18,10 +18,10 @@ name = \"rust-analyzer\"\n path = \"src/bin/main.rs\"\n \n [dependencies]\n-anyhow = \"1.0.57\"\n+anyhow = \"1.0.62\"\n crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n scip = \"0.1.1\"\n lsp-types = { version = \"0.93.1\", features = [\"proposed\"] }\n parking_lot = \"0.12.1\"\n@@ -33,10 +33,10 @@ serde_json = { version = \"1.0.81\", features = [\"preserve_order\"] }\n threadpool = \"1.8.1\"\n rayon = \"1.5.3\"\n num_cpus = \"1.13.1\"\n-mimalloc = { version = \"0.1.29\", default-features = false, optional = true }\n+mimalloc = { version = \"0.1.30\", default-features = false, optional = true }\n lsp-server = { version = \"0.7.0\", path = \"../../lib/lsp-server\" }\n tracing = \"0.1.35\"\n-tracing-subscriber = { version = \"0.3.14\", default-features = false, features = [\n+tracing-subscriber = { version = \"0.3.16\", default-features = false, features = [\n     \"env-filter\",\n     \"registry\",\n     \"fmt\","}, {"sha": "24e68eca676d7419ece4bb0125f479f652a617ef", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/tests/slow-tests/tidy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Ftests%2Fslow-tests%2Ftidy.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -177,6 +177,7 @@ fn check_licenses() {\n     let sh = &Shell::new().unwrap();\n \n     let expected = \"\n+(MIT OR Apache-2.0) AND Unicode-DFS-2016\n 0BSD OR MIT OR Apache-2.0\n Apache-2.0\n Apache-2.0 OR BSL-1.0"}, {"sha": "e0657ab0f6d1c20fe439a74720da590b07cf8c3e", "filename": "src/tools/rust-analyzer/crates/stdx/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fstdx%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -10,7 +10,7 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-libc = \"0.2.126\"\n+libc = \"0.2.135\"\n backtrace = { version = \"0.3.65\", optional = true }\n always-assert = { version = \"0.1.2\", features = [\"log\"] }\n # Think twice before adding anything here"}, {"sha": "1ef903371cf896de2c31abf83b17d1b58af112d3", "filename": "src/tools/rust-analyzer/crates/syntax/Cargo.toml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -12,11 +12,11 @@ doctest = false\n \n [dependencies]\n cov-mark = \"2.0.0-pre.1\"\n-itertools = \"0.10.3\"\n-rowan = \"0.15.8\"\n+itertools = \"0.10.5\"\n+rowan = \"0.15.10\"\n rustc_lexer = { version = \"725.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n-once_cell = \"1.12.0\"\n+once_cell = \"1.15.0\"\n indexmap = \"1.9.1\"\n smol_str = \"0.1.23\"\n \n@@ -28,7 +28,7 @@ profile = { path = \"../profile\", version = \"0.0.0\" }\n [dev-dependencies]\n rayon = \"1.5.3\"\n expect-test = \"1.4.0\"\n-proc-macro2 = \"1.0.39\"\n+proc-macro2 = \"1.0.47\"\n quote = \"1.0.20\"\n ungrammar = \"1.16.1\"\n "}, {"sha": "229e7419b736febecf341b114dc86b121e6e006d", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/edit_in_place.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fedit_in_place.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -235,6 +235,24 @@ impl ast::GenericParamList {\n             }\n         }\n     }\n+\n+    /// Constructs a matching [`ast::GenericArgList`]\n+    pub fn to_generic_args(&self) -> ast::GenericArgList {\n+        let args = self.generic_params().filter_map(|param| match param {\n+            ast::GenericParam::LifetimeParam(it) => {\n+                Some(ast::GenericArg::LifetimeArg(make::lifetime_arg(it.lifetime()?)))\n+            }\n+            ast::GenericParam::TypeParam(it) => {\n+                Some(ast::GenericArg::TypeArg(make::type_arg(make::ext::ty_name(it.name()?))))\n+            }\n+            ast::GenericParam::ConstParam(it) => {\n+                // Name-only const params get parsed as `TypeArg`s\n+                Some(ast::GenericArg::TypeArg(make::type_arg(make::ext::ty_name(it.name()?))))\n+            }\n+        });\n+\n+        make::generic_arg_list(args)\n+    }\n }\n \n impl ast::WhereClause {\n@@ -248,6 +266,42 @@ impl ast::WhereClause {\n     }\n }\n \n+impl ast::TypeParam {\n+    pub fn remove_default(&self) {\n+        if let Some((eq, last)) = self\n+            .syntax()\n+            .children_with_tokens()\n+            .find(|it| it.kind() == T![=])\n+            .zip(self.syntax().last_child_or_token())\n+        {\n+            ted::remove_all(eq..=last);\n+\n+            // remove any trailing ws\n+            if let Some(last) = self.syntax().last_token().filter(|it| it.kind() == WHITESPACE) {\n+                last.detach();\n+            }\n+        }\n+    }\n+}\n+\n+impl ast::ConstParam {\n+    pub fn remove_default(&self) {\n+        if let Some((eq, last)) = self\n+            .syntax()\n+            .children_with_tokens()\n+            .find(|it| it.kind() == T![=])\n+            .zip(self.syntax().last_child_or_token())\n+        {\n+            ted::remove_all(eq..=last);\n+\n+            // remove any trailing ws\n+            if let Some(last) = self.syntax().last_token().filter(|it| it.kind() == WHITESPACE) {\n+                last.detach();\n+            }\n+        }\n+    }\n+}\n+\n pub trait Removable: AstNode {\n     fn remove(&self);\n }\n@@ -264,7 +318,7 @@ impl Removable for ast::TypeBoundList {\n impl ast::PathSegment {\n     pub fn get_or_create_generic_arg_list(&self) -> ast::GenericArgList {\n         if self.generic_arg_list().is_none() {\n-            let arg_list = make::generic_arg_list().clone_for_update();\n+            let arg_list = make::generic_arg_list(empty()).clone_for_update();\n             ted::append_child(self.syntax(), arg_list.syntax());\n         }\n         self.generic_arg_list().unwrap()"}, {"sha": "4057a75e7c1e693d053e987ac39bb588ec02b9fa", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/make.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -88,6 +88,9 @@ pub mod ext {\n         block_expr(None, None)\n     }\n \n+    pub fn ty_name(name: ast::Name) -> ast::Type {\n+        ty_path(ident_path(&name.to_string()))\n+    }\n     pub fn ty_bool() -> ast::Type {\n         ty_path(ident_path(\"bool\"))\n     }\n@@ -160,6 +163,7 @@ pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {}\")\n }\n \n+// FIXME: `ty_params` should be `ast::GenericArgList`\n pub fn impl_(\n     ty: ast::Path,\n     params: Option<ast::GenericParamList>,\n@@ -185,10 +189,6 @@ pub fn impl_trait(\n     ast_from_text(&format!(\"impl{ty_params} {trait_} for {ty}{ty_params} {{}}\"))\n }\n \n-pub(crate) fn generic_arg_list() -> ast::GenericArgList {\n-    ast_from_text(\"const S: T<> = ();\")\n-}\n-\n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"type __ = {name_ref};\"))\n }\n@@ -718,6 +718,21 @@ pub fn generic_param_list(\n     ast_from_text(&format!(\"fn f<{args}>() {{ }}\"))\n }\n \n+pub fn type_arg(ty: ast::Type) -> ast::TypeArg {\n+    ast_from_text(&format!(\"const S: T<{ty}> = ();\"))\n+}\n+\n+pub fn lifetime_arg(lifetime: ast::Lifetime) -> ast::LifetimeArg {\n+    ast_from_text(&format!(\"const S: T<{lifetime}> = ();\"))\n+}\n+\n+pub(crate) fn generic_arg_list(\n+    args: impl IntoIterator<Item = ast::GenericArg>,\n+) -> ast::GenericArgList {\n+    let args = args.into_iter().join(\", \");\n+    ast_from_text(&format!(\"const S: T<{args}> = ();\"))\n+}\n+\n pub fn visibility_pub_crate() -> ast::Visibility {\n     ast_from_text(\"pub(crate) struct S\")\n }"}, {"sha": "c824f5af7258485bb8aa97460ab23fc0f216a647", "filename": "src/tools/rust-analyzer/crates/test-utils/src/fixture.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Ffixture.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -61,6 +61,8 @@\n //! \"\n //! ```\n \n+use std::iter;\n+\n use rustc_hash::FxHashMap;\n use stdx::trim_indent;\n \n@@ -259,7 +261,7 @@ impl MiniCore {\n             if res.has_flag(entry) {\n                 panic!(\"duplicate minicore flag: {:?}\", entry);\n             }\n-            res.activated_flags.push(entry.to_string());\n+            res.activated_flags.push(entry.to_owned());\n         }\n \n         res\n@@ -273,35 +275,34 @@ impl MiniCore {\n         let raw_mini_core = include_str!(\"./minicore.rs\");\n         let mut lines = raw_mini_core.split_inclusive('\\n');\n \n-        let mut parsing_flags = false;\n         let mut implications = Vec::new();\n \n         // Parse `//!` preamble and extract flags and dependencies.\n-        for line in lines.by_ref() {\n-            let line = match line.strip_prefix(\"//!\") {\n-                Some(it) => it,\n-                None => {\n-                    assert!(line.trim().is_empty());\n-                    break;\n-                }\n-            };\n-\n-            if parsing_flags {\n-                let (flag, deps) = line.split_once(':').unwrap();\n-                let flag = flag.trim();\n-                self.valid_flags.push(flag.to_string());\n-                for dep in deps.split(\", \") {\n-                    let dep = dep.trim();\n-                    if !dep.is_empty() {\n-                        self.assert_valid_flag(dep);\n-                        implications.push((flag, dep));\n-                    }\n-                }\n+        let trim_doc: fn(&str) -> Option<&str> = |line| match line.strip_prefix(\"//!\") {\n+            Some(it) => Some(it),\n+            None => {\n+                assert!(line.trim().is_empty(), \"expected empty line after minicore header\");\n+                None\n             }\n+        };\n+        for line in lines\n+            .by_ref()\n+            .map_while(trim_doc)\n+            .skip_while(|line| !line.contains(\"Available flags:\"))\n+            .skip(1)\n+        {\n+            let (flag, deps) = line.split_once(':').unwrap();\n+            let flag = flag.trim();\n+\n+            self.valid_flags.push(flag.to_string());\n+            implications.extend(\n+                iter::repeat(flag)\n+                    .zip(deps.split(\", \").map(str::trim).filter(|dep| !dep.is_empty())),\n+            );\n+        }\n \n-            if line.contains(\"Available flags:\") {\n-                parsing_flags = true;\n-            }\n+        for (_, dep) in &implications {\n+            self.assert_valid_flag(dep);\n         }\n \n         for flag in &self.activated_flags {\n@@ -332,7 +333,7 @@ impl MiniCore {\n             }\n             if let Some(region) = trimmed.strip_prefix(\"// endregion:\") {\n                 let prev = active_regions.pop().unwrap();\n-                assert_eq!(prev, region);\n+                assert_eq!(prev, region, \"unbalanced region pairs\");\n                 continue;\n             }\n "}, {"sha": "59b1c147d7f174e08339de3225c5e3541b2af1c9", "filename": "src/tools/rust-analyzer/crates/test-utils/src/minicore.rs", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -8,36 +8,37 @@\n //! We then strip all the code marked with other flags.\n //!\n //! Available flags:\n-//!     sized:\n-//!     unsize: sized\n+//!     add:\n+//!     as_ref: sized\n+//!     bool_impl: option, fn\n+//!     clone: sized\n //!     coerce_unsized: unsize\n-//!     slice:\n-//!     range:\n-//!     deref: sized\n+//!     copy: clone\n+//!     default: sized\n //!     deref_mut: deref\n-//!     index: sized\n+//!     deref: sized\n+//!     derive:\n+//!     drop:\n+//!     eq: sized\n+//!     fmt: result\n //!     fn:\n-//!     try:\n-//!     pin:\n+//!     from: sized\n //!     future: pin\n-//!     option:\n-//!     result:\n+//!     generator: pin\n+//!     hash:\n+//!     index: sized\n+//!     infallible:\n //!     iterator: option\n //!     iterators: iterator, fn\n-//!     default: sized\n-//!     hash:\n-//!     clone: sized\n-//!     copy: clone\n-//!     from: sized\n-//!     eq: sized\n+//!     option:\n //!     ord: eq, option\n-//!     derive:\n-//!     fmt: result\n-//!     bool_impl: option, fn\n-//!     add:\n-//!     as_ref: sized\n-//!     drop:\n-//!     generator: pin\n+//!     pin:\n+//!     range:\n+//!     result:\n+//!     sized:\n+//!     slice:\n+//!     try: infallible\n+//!     unsize: sized\n \n pub mod marker {\n     // region:sized\n@@ -150,6 +151,9 @@ pub mod convert {\n         fn as_ref(&self) -> &T;\n     }\n     // endregion:as_ref\n+    // region:infallible\n+    pub enum Infallible {}\n+    // endregion:infallible\n }\n \n pub mod ops {\n@@ -326,7 +330,7 @@ pub mod ops {\n             Continue(C),\n             Break(B),\n         }\n-        pub trait FromResidual<R = Self::Residual> {\n+        pub trait FromResidual<R = <Self as Try>::Residual> {\n             #[lang = \"from_residual\"]\n             fn from_residual(residual: R) -> Self;\n         }\n@@ -342,13 +346,13 @@ pub mod ops {\n \n         impl<B, C> Try for ControlFlow<B, C> {\n             type Output = C;\n-            type Residual = ControlFlow<B, convert::Infallible>;\n+            type Residual = ControlFlow<B, crate::convert::Infallible>;\n             fn from_output(output: Self::Output) -> Self {}\n             fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {}\n         }\n \n         impl<B, C> FromResidual for ControlFlow<B, C> {\n-            fn from_residual(residual: ControlFlow<B, convert::Infallible>) -> Self {}\n+            fn from_residual(residual: ControlFlow<B, crate::convert::Infallible>) -> Self {}\n         }\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n@@ -469,6 +473,33 @@ pub mod option {\n             }\n         }\n     }\n+    // region:try\n+    impl<T> crate::ops::Try for Option<T> {\n+        type Output = T;\n+        type Residual = Option<crate::convert::Infallible>;\n+\n+        #[inline]\n+        fn from_output(output: Self::Output) -> Self {\n+            Some(output)\n+        }\n+\n+        #[inline]\n+        fn branch(self) -> crate::ops::ControlFlow<Self::Residual, Self::Output> {\n+            match self {\n+                Some(v) => crate::ops::ControlFlow::Continue(v),\n+                None => crate::ops::ControlFlow::Break(None),\n+            }\n+        }\n+    }\n+    impl<T> crate::ops::FromResidual for Option<T> {\n+        #[inline]\n+        fn from_residual(residual: Option<crate::convert::Infallible>) -> Self {\n+            match residual {\n+                None => None,\n+            }\n+        }\n+    }\n+    // endregion:try\n }\n // endregion:option\n \n@@ -584,7 +615,7 @@ pub mod iter {\n             }\n         }\n     }\n-    pub use self::adapters::{Take, FilterMap};\n+    pub use self::adapters::{FilterMap, Take};\n \n     mod sources {\n         mod repeat {"}, {"sha": "7a90d64a98ba9b01a55678f82ec00328724094ba", "filename": "src/tools/rust-analyzer/crates/text-edit/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftext-edit%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -10,5 +10,5 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-itertools = \"0.10.3\"\n+itertools = \"0.10.5\"\n text-size = \"1.1.0\""}, {"sha": "3e0f31f19c507fc417fc413fd0039a5b9d124e8a", "filename": "src/tools/rust-analyzer/crates/toolchain/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Ftoolchain%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -10,4 +10,4 @@ rust-version = \"1.57\"\n doctest = false\n \n [dependencies]\n-home = \"0.5.3\"\n+home = \"0.5.4\""}, {"sha": "df5dc24e2cd12a15806ecef192798595a013e27b", "filename": "src/tools/rust-analyzer/crates/vfs-notify/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fvfs-notify%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -14,7 +14,7 @@ tracing = \"0.1.35\"\n jod-thread = \"0.1.2\"\n walkdir = \"2.3.2\"\n crossbeam-channel = \"0.5.5\"\n-notify = \"=5.0.0-pre.16\"\n+notify = \"5.0\"\n \n vfs = { path = \"../vfs\", version = \"0.0.0\" }\n paths = { path = \"../paths\", version = \"0.0.0\" }"}, {"sha": "52a13da31c5d3ea3d25f963ec94e18b09fdbebd2", "filename": "src/tools/rust-analyzer/docs/dev/guide.md", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fguide.md?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -88,9 +88,8 @@ is lower than Cargo's model of packages: each Cargo package consists of several\n targets, each of which is a separate crate (or several crates, if you try\n different feature combinations).\n \n-Procedural macros should become inputs as well, but currently they are not\n-supported. Procedural macro will be a black box `Box<dyn Fn(TokenStream) -> TokenStream>`\n-function, and will be inserted into the crate graph just like dependencies.\n+Procedural macros are inputs as well, roughly modeled as a crate with a bunch of\n+additional black box `dyn Fn(TokenStream) -> TokenStream` functions.\n \n Soon we'll talk how we build an LSP server on top of `Analysis`, but first,\n let's deal with that paths issue."}, {"sha": "97e376787c828d9bb9ef5c9f391f3bbb637f7829", "filename": "src/tools/rust-analyzer/docs/dev/syntax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fdev%2Fsyntax.md?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -8,10 +8,10 @@ This guide describes the current state of syntax trees and parsing in rust-analy\n \n The things described are implemented in three places\n \n-* [rowan](https://github.com/rust-analyzer/rowan/tree/v0.9.0) -- a generic library for rowan syntax trees.\n-* [ra_syntax](https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/ra_syntax) crate inside rust-analyzer which wraps `rowan` into rust-analyzer specific API.\n+* [rowan](https://github.com/rust-analyzer/rowan/tree/v0.15.10) -- a generic library for rowan syntax trees.\n+* [syntax](https://github.com/rust-lang/rust-analyzer/tree/36a70b7435c48837018c71576d7bb4e8f763f501/crates/syntax) crate inside rust-analyzer which wraps `rowan` into rust-analyzer specific API.\n   Nothing in rust-analyzer except this crate knows about `rowan`.\n-* [parser](https://github.com/rust-lang/rust-analyzer/tree/cf5bdf464cad7ceb9a67e07985a3f4d3799ec0b6/crates/parser) crate parses input tokens into an `ra_syntax` tree\n+* [parser](https://github.com/rust-lang/rust-analyzer/tree/36a70b7435c48837018c71576d7bb4e8f763f501/crates/parser) crate parses input tokens into a `syntax` tree\n \n ## Design Goals\n "}, {"sha": "c30838e5f5e1e09b10ac34ce19c718d195f67a07", "filename": "src/tools/rust-analyzer/docs/user/manual.adoc", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fdocs%2Fuser%2Fmanual.adoc?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -174,14 +174,25 @@ On Unix, running the editor from a shell or changing the `.desktop` file to set\n \n ==== `rustup`\n \n-`rust-analyzer` is available in `rustup`, but only in the nightly toolchain:\n+`rust-analyzer` is available in `rustup`:\n \n [source,bash]\n ----\n-$ rustup +nightly component add rust-analyzer-preview\n+$ rustup component add rust-analyzer\n ----\n \n-However, in contrast to `component add clippy` or `component add rustfmt`, this does not actually place a `rust-analyzer` binary in `~/.cargo/bin`, see https://github.com/rust-lang/rustup/issues/2411[this issue].\n+However, in contrast to `component add clippy` or `component add rustfmt`, this does not actually place a `rust-analyzer` binary in `~/.cargo/bin`, see https://github.com/rust-lang/rustup/issues/2411[this issue]. You can find the path to the binary using:\n+[source,bash]\n+----\n+$ rustup which --toolchain stable rust-analyzer\n+----\n+You can link to there from `~/.cargo/bin` or configure your editor to use the full path.\n+\n+Alternatively you might be able to configure your editor to start `rust-analyzer` using the command:\n+[source,bash]\n+----\n+$ rustup run stable rust-analyzer\n+----\n \n ==== Arch Linux\n "}, {"sha": "15846a5e8645e67fd6d2888a81b4b1ca862efefc", "filename": "src/tools/rust-analyzer/editors/code/src/config.ts", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Feditors%2Fcode%2Fsrc%2Fconfig.ts?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -133,7 +133,21 @@ export class Config {\n     }\n \n     get runnableEnv() {\n-        return this.get<RunnableEnvCfg>(\"runnableEnv\");\n+        const item = this.get<any>(\"runnableEnv\");\n+        if (!item) return item;\n+        const fixRecord = (r: Record<string, any>) => {\n+            for (const key in r) {\n+                if (typeof r[key] !== \"string\") {\n+                    r[key] = String(r[key]);\n+                }\n+            }\n+        };\n+        if (item instanceof Array) {\n+            item.forEach((x) => fixRecord(x.env));\n+        } else {\n+            fixRecord(item);\n+        }\n+        return item;\n     }\n \n     get restartServerOnConfigChange() {"}, {"sha": "5922bbfdb483d6d2f679475d9d8c04875c50b558", "filename": "src/tools/rust-analyzer/lib/lsp-server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Flsp-server%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -8,7 +8,7 @@ edition = \"2021\"\n \n [dependencies]\n log = \"0.4.17\"\n-serde_json = \"1.0.85\"\n+serde_json = \"1.0.86\"\n serde = { version = \"1.0.144\", features = [\"derive\"] }\n crossbeam-channel = \"0.5.6\"\n "}, {"sha": "0be0bf920de9dd661d4851c4c03fb5527d97b63d", "filename": "src/tools/rust-analyzer/xtask/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e0f8e60dddfecfc9093ee9d9f42557d8260c0355/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fxtask%2FCargo.toml?ref=e0f8e60dddfecfc9093ee9d9f42557d8260c0355", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n rust-version = \"1.57\"\n \n [dependencies]\n-anyhow = \"1.0.57\"\n+anyhow = \"1.0.62\"\n flate2 = \"1.0.24\"\n write-json = \"0.1.2\"\n xshell = \"0.2.2\""}]}