{"sha": "73091583dd42991213e102daefa9181ce500feb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMDkxNTgzZGQ0Mjk5MTIxM2UxMDJkYWVmYTkxODFjZTUwMGZlYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-29T09:01:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-29T09:01:50Z"}, "message": "auto merge of #10135 : alexcrichton/rust/snapshots, r=thestinger\n\nPlus some migration from `let mut this = self` to `mut self` (yay!)", "tree": {"sha": "d419506d83e62e8f3717edb2791be3a3c00b0555", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d419506d83e62e8f3717edb2791be3a3c00b0555"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73091583dd42991213e102daefa9181ce500feb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73091583dd42991213e102daefa9181ce500feb0", "html_url": "https://github.com/rust-lang/rust/commit/73091583dd42991213e102daefa9181ce500feb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73091583dd42991213e102daefa9181ce500feb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "671ab42a3b86addf7b90ff126554a092579e589a", "url": "https://api.github.com/repos/rust-lang/rust/commits/671ab42a3b86addf7b90ff126554a092579e589a", "html_url": "https://github.com/rust-lang/rust/commit/671ab42a3b86addf7b90ff126554a092579e589a"}, {"sha": "2290131543af4da764343c546efbd5c6dc9e7d71", "url": "https://api.github.com/repos/rust-lang/rust/commits/2290131543af4da764343c546efbd5c6dc9e7d71", "html_url": "https://github.com/rust-lang/rust/commit/2290131543af4da764343c546efbd5c6dc9e7d71"}], "stats": {"total": 217, "additions": 98, "deletions": 119}, "files": [{"sha": "8f28be49782538138ba9df88be424a94c6653520", "filename": "src/libextra/future.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -51,10 +51,9 @@ impl<A:Clone> Future<A> {\n \n impl<A> Future<A> {\n     /// Gets the value from this future, forcing evaluation.\n-    pub fn unwrap(self) -> A {\n-        let mut this = self;\n-        this.get_ref();\n-        let state = replace(&mut this.state, Evaluating);\n+    pub fn unwrap(mut self) -> A {\n+        self.get_ref();\n+        let state = replace(&mut self.state, Evaluating);\n         match state {\n             Forced(v) => v,\n             _ => fail!( \"Logic error.\" ),"}, {"sha": "a3fd4dca5348050da0d2d8814c87b2e3ac716aa9", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -113,7 +113,7 @@ impl<T> ChanOne<T> {\n \n     // 'do_resched' configures whether the scheduler immediately switches to\n     // the receiving task, or leaves the sending task still running.\n-    fn try_send_inner(self, val: T, do_resched: bool) -> bool {\n+    fn try_send_inner(mut self, val: T, do_resched: bool) -> bool {\n         if do_resched {\n             rtassert!(!rt::in_sched_context());\n         }\n@@ -129,9 +129,8 @@ impl<T> ChanOne<T> {\n             sched.maybe_yield();\n         }\n \n-        let mut this = self;\n         let mut recvr_active = true;\n-        let packet = this.packet();\n+        let packet = self.packet();\n \n         unsafe {\n \n@@ -150,15 +149,15 @@ impl<T> ChanOne<T> {\n             // done with the packet. NB: In case of do_resched, this *must*\n             // happen before waking up a blocked task (or be unkillable),\n             // because we might get a kill signal during the reschedule.\n-            this.suppress_finalize = true;\n+            self.suppress_finalize = true;\n \n             match oldstate {\n                 STATE_BOTH => {\n                     // Port is not waiting yet. Nothing to do\n                 }\n                 STATE_ONE => {\n                     // Port has closed. Need to clean up.\n-                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n                     recvr_active = false;\n                 }\n                 task_as_state => {\n@@ -202,22 +201,20 @@ impl<T> PortOne<T> {\n     }\n \n     /// As `recv`, but returns `None` if the send end is closed rather than failing.\n-    pub fn try_recv(self) -> Option<T> {\n-        let mut this = self;\n-\n+    pub fn try_recv(mut self) -> Option<T> {\n         // Optimistic check. If data was sent already, we don't even need to block.\n         // No release barrier needed here; we're not handing off our task pointer yet.\n-        if !this.optimistic_check() {\n+        if !self.optimistic_check() {\n             // No data available yet.\n             // Switch to the scheduler to put the ~Task into the Packet state.\n             let sched: ~Scheduler = Local::take();\n             do sched.deschedule_running_task_and_then |sched, task| {\n-                this.block_on(sched, task);\n+                self.block_on(sched, task);\n             }\n         }\n \n         // Task resumes.\n-        this.recv_ready()\n+        self.recv_ready()\n     }\n }\n \n@@ -325,9 +322,8 @@ impl<T> SelectInner for PortOne<T> {\n impl<T> Select for PortOne<T> { }\n \n impl<T> SelectPortInner<T> for PortOne<T> {\n-    fn recv_ready(self) -> Option<T> {\n-        let mut this = self;\n-        let packet = this.packet();\n+    fn recv_ready(mut self) -> Option<T> {\n+        let packet = self.packet();\n \n         // No further memory barrier is needed here to access the\n         // payload. Some scenarios:\n@@ -348,9 +344,9 @@ impl<T> SelectPortInner<T> for PortOne<T> {\n             let payload = (*packet).payload.take();\n \n             // The sender has closed up shop. Drop the packet.\n-            let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+            let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n             // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n-            this.suppress_finalize = true;\n+            self.suppress_finalize = true;\n             return payload;\n         }\n     }\n@@ -378,18 +374,17 @@ impl<T> Drop for ChanOne<T> {\n         if self.suppress_finalize { return }\n \n         unsafe {\n-            let this = cast::transmute_mut(self);\n-            let oldstate = (*this.packet()).state.swap(STATE_ONE, SeqCst);\n+            let oldstate = (*self.packet()).state.swap(STATE_ONE, SeqCst);\n             match oldstate {\n                 STATE_BOTH => {\n                     // Port still active. It will destroy the Packet.\n                 },\n                 STATE_ONE => {\n-                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n                 },\n                 task_as_state => {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n-                    rtassert!((*this.packet()).payload.is_none());\n+                    rtassert!((*self.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     do recvr.wake().map |woken_task| {\n                         Scheduler::run_task(woken_task);\n@@ -406,14 +401,13 @@ impl<T> Drop for PortOne<T> {\n         if self.suppress_finalize { return }\n \n         unsafe {\n-            let this = cast::transmute_mut(self);\n-            let oldstate = (*this.packet()).state.swap(STATE_ONE, SeqCst);\n+            let oldstate = (*self.packet()).state.swap(STATE_ONE, SeqCst);\n             match oldstate {\n                 STATE_BOTH => {\n                     // Chan still active. It will destroy the packet.\n                 },\n                 STATE_ONE => {\n-                    let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n+                    let _packet: ~Packet<T> = cast::transmute(self.void_packet);\n                 }\n                 task_as_state => {\n                     // This case occurs during unwinding, when the blocked"}, {"sha": "93056314b141d4fc5ca4c87491e49718a0490d50", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 57, "deletions": 75, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -166,12 +166,10 @@ impl Scheduler {\n \n     // Take a main task to run, and a scheduler to run it in. Create a\n     // scheduler task and bootstrap into it.\n-    pub fn bootstrap(~self, task: ~Task) {\n-\n-        let mut this = self;\n+    pub fn bootstrap(mut ~self, task: ~Task) {\n \n         // Build an Idle callback.\n-        this.idle_callback = Some(this.event_loop.pausible_idle_callback());\n+        self.idle_callback = Some(self.event_loop.pausible_idle_callback());\n \n         // Initialize the TLS key.\n         local_ptr::init_tls_key();\n@@ -186,12 +184,12 @@ impl Scheduler {\n         // Before starting our first task, make sure the idle callback\n         // is active. As we do not start in the sleep state this is\n         // important.\n-        this.idle_callback.get_mut_ref().start(Scheduler::run_sched_once);\n+        self.idle_callback.get_mut_ref().start(Scheduler::run_sched_once);\n \n         // Now, as far as all the scheduler state is concerned, we are\n         // inside the \"scheduler\" context. So we can act like the\n         // scheduler and resume the provided task.\n-        this.resume_task_immediately(task);\n+        self.resume_task_immediately(task);\n \n         // Now we are back in the scheduler context, having\n         // successfully run the input task. Start by running the\n@@ -226,20 +224,18 @@ impl Scheduler {\n \n     // This does not return a scheduler, as the scheduler is placed\n     // inside the task.\n-    pub fn run(~self) {\n-\n-        let mut self_sched = self;\n+    pub fn run(mut ~self) {\n \n         // This is unsafe because we need to place the scheduler, with\n         // the event_loop inside, inside our task. But we still need a\n         // mutable reference to the event_loop to give it the \"run\"\n         // command.\n         unsafe {\n-            let event_loop: *mut ~EventLoop = &mut self_sched.event_loop;\n+            let event_loop: *mut ~EventLoop = &mut self.event_loop;\n \n             // Our scheduler must be in the task before the event loop\n             // is started.\n-            let self_sched = Cell::new(self_sched);\n+            let self_sched = Cell::new(self);\n             do Local::borrow |stask: &mut Task| {\n                 stask.sched = Some(self_sched.take());\n             };\n@@ -315,48 +311,46 @@ impl Scheduler {\n     // returns the still-available scheduler. At this point all\n     // message-handling will count as a turn of work, and as a result\n     // return None.\n-    fn interpret_message_queue(~self, effort: EffortLevel) -> Option<~Scheduler> {\n-\n-        let mut this = self;\n+    fn interpret_message_queue(mut ~self, effort: EffortLevel) -> Option<~Scheduler> {\n \n         let msg = if effort == DontTryTooHard {\n             // Do a cheap check that may miss messages\n-            this.message_queue.casual_pop()\n+            self.message_queue.casual_pop()\n         } else {\n-            this.message_queue.pop()\n+            self.message_queue.pop()\n         };\n \n         match msg {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n-                task.give_home(Sched(this.make_handle()));\n-                this.resume_task_immediately(task);\n+                task.give_home(Sched(self.make_handle()));\n+                self.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n                 rtdebug!(\"got a task from a friend. lovely!\");\n-                this.process_task(task, Scheduler::resume_task_immediately_cl);\n+                self.process_task(task, Scheduler::resume_task_immediately_cl);\n                 return None;\n             }\n             Some(RunOnce(task)) => {\n                 // bypass the process_task logic to force running this task once\n                 // on this home scheduler. This is often used for I/O (homing).\n-                Scheduler::resume_task_immediately_cl(this, task);\n+                Scheduler::resume_task_immediately_cl(self, task);\n                 return None;\n             }\n             Some(Wake) => {\n-                this.sleepy = false;\n-                Local::put(this);\n+                self.sleepy = false;\n+                Local::put(self);\n                 return None;\n             }\n             Some(Shutdown) => {\n                 rtdebug!(\"shutting down\");\n-                if this.sleepy {\n+                if self.sleepy {\n                     // There may be an outstanding handle on the\n                     // sleeper list.  Pop them all to make sure that's\n                     // not the case.\n                     loop {\n-                        match this.sleeper_list.pop() {\n+                        match self.sleeper_list.pop() {\n                             Some(handle) => {\n                                 let mut handle = handle;\n                                 handle.send(Wake);\n@@ -367,30 +361,28 @@ impl Scheduler {\n                 }\n                 // No more sleeping. After there are no outstanding\n                 // event loop references we will shut down.\n-                this.no_sleep = true;\n-                this.sleepy = false;\n-                Local::put(this);\n+                self.no_sleep = true;\n+                self.sleepy = false;\n+                Local::put(self);\n                 return None;\n             }\n             None => {\n-                return Some(this);\n+                return Some(self);\n             }\n         }\n     }\n \n-    fn do_work(~self) -> Option<~Scheduler> {\n-        let mut this = self;\n-\n+    fn do_work(mut ~self) -> Option<~Scheduler> {\n         rtdebug!(\"scheduler calling do work\");\n-        match this.find_work() {\n+        match self.find_work() {\n             Some(task) => {\n                 rtdebug!(\"found some work! processing the task\");\n-                this.process_task(task, Scheduler::resume_task_immediately_cl);\n+                self.process_task(task, Scheduler::resume_task_immediately_cl);\n                 return None;\n             }\n             None => {\n                 rtdebug!(\"no work was found, returning the scheduler struct\");\n-                return Some(this);\n+                return Some(self);\n             }\n         }\n     }\n@@ -462,37 +454,34 @@ impl Scheduler {\n     // * Task Routing Functions - Make sure tasks send up in the right\n     // place.\n \n-    fn process_task(~self, task: ~Task,\n+    fn process_task(mut ~self, mut task: ~Task,\n                     schedule_fn: SchedulingFn) {\n-        let mut this = self;\n-        let mut task = task;\n-\n         rtdebug!(\"processing a task\");\n \n         let home = task.take_unwrap_home();\n         match home {\n             Sched(home_handle) => {\n-                if home_handle.sched_id != this.sched_id() {\n+                if home_handle.sched_id != self.sched_id() {\n                     rtdebug!(\"sending task home\");\n                     task.give_home(Sched(home_handle));\n                     Scheduler::send_task_home(task);\n-                    Local::put(this);\n+                    Local::put(self);\n                 } else {\n                     rtdebug!(\"running task here\");\n                     task.give_home(Sched(home_handle));\n-                    schedule_fn(this, task);\n+                    schedule_fn(self, task);\n                 }\n             }\n-            AnySched if this.run_anything => {\n+            AnySched if self.run_anything => {\n                 rtdebug!(\"running anysched task here\");\n                 task.give_home(AnySched);\n-                schedule_fn(this, task);\n+                schedule_fn(self, task);\n             }\n             AnySched => {\n                 rtdebug!(\"sending task to friend\");\n                 task.give_home(AnySched);\n-                this.send_to_friend(task);\n-                Local::put(this);\n+                self.send_to_friend(task);\n+                Local::put(self);\n             }\n         }\n     }\n@@ -531,16 +520,14 @@ impl Scheduler {\n     /// to the work queue directly.\n     pub fn enqueue_task(&mut self, task: ~Task) {\n \n-        let this = self;\n-\n         // We push the task onto our local queue clone.\n-        this.work_queue.push(task);\n-        this.idle_callback.get_mut_ref().resume();\n+        self.work_queue.push(task);\n+        self.idle_callback.get_mut_ref().resume();\n \n         // We've made work available. Notify a\n         // sleeping scheduler.\n \n-        match this.sleeper_list.casual_pop() {\n+        match self.sleeper_list.casual_pop() {\n             Some(handle) => {\n                         let mut handle = handle;\n                 handle.send(Wake)\n@@ -567,11 +554,9 @@ impl Scheduler {\n     // cleanup function f, which takes the scheduler and the\n     // old task as inputs.\n \n-    pub fn change_task_context(~self,\n+    pub fn change_task_context(mut ~self,\n                                next_task: ~Task,\n                                f: &fn(&mut Scheduler, ~Task)) {\n-        let mut this = self;\n-\n         // The current task is grabbed from TLS, not taken as an input.\n         // Doing an unsafe_take to avoid writing back a null pointer -\n         // We're going to call `put` later to do that.\n@@ -590,11 +575,11 @@ impl Scheduler {\n \n         // The current task is placed inside an enum with the cleanup\n         // function. This enum is then placed inside the scheduler.\n-        this.cleanup_job = Some(CleanupJob::new(current_task, f_opaque));\n+        self.cleanup_job = Some(CleanupJob::new(current_task, f_opaque));\n \n         // The scheduler is then placed inside the next task.\n         let mut next_task = next_task;\n-        next_task.sched = Some(this);\n+        next_task.sched = Some(self);\n \n         // However we still need an internal mutable pointer to the\n         // original task. The strategy here was \"arrange memory, then\n@@ -692,13 +677,13 @@ impl Scheduler {\n     /// This passes a Scheduler pointer to the fn after the context switch\n     /// in order to prevent that fn from performing further scheduling operations.\n     /// Doing further scheduling could easily result in infinite recursion.\n-    pub fn deschedule_running_task_and_then(~self, f: &fn(&mut Scheduler, BlockedTask)) {\n+    pub fn deschedule_running_task_and_then(mut ~self,\n+                                            f: &fn(&mut Scheduler, BlockedTask)) {\n         // Trickier - we need to get the scheduler task out of self\n         // and use it as the destination.\n-        let mut this = self;\n-        let stask = this.sched_task.take_unwrap();\n+        let stask = self.sched_task.take_unwrap();\n         // Otherwise this is the same as below.\n-        this.switch_running_tasks_and_then(stask, f);\n+        self.switch_running_tasks_and_then(stask, f);\n     }\n \n     pub fn switch_running_tasks_and_then(~self, next_task: ~Task,\n@@ -725,12 +710,11 @@ impl Scheduler {\n \n     /// Called by a running task to end execution, after which it will\n     /// be recycled by the scheduler for reuse in a new task.\n-    pub fn terminate_current_task(~self) {\n+    pub fn terminate_current_task(mut ~self) {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n-        let mut this = self;\n-        let stask = this.sched_task.take_unwrap();\n-        do this.change_task_context(stask) |sched, mut dead_task| {\n+        let stask = self.sched_task.take_unwrap();\n+        do self.change_task_context(stask) |sched, mut dead_task| {\n             let coroutine = dead_task.coroutine.take_unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n         }\n@@ -752,25 +736,23 @@ impl Scheduler {\n     /// to introduce some amount of randomness to the scheduler. Currently the\n     /// randomness is a result of performing a round of work stealing (which\n     /// may end up stealing from the current scheduler).\n-    pub fn yield_now(~self) {\n-        let mut this = self;\n-        this.yield_check_count = reset_yield_check(&mut this.rng);\n+    pub fn yield_now(mut ~self) {\n+        self.yield_check_count = reset_yield_check(&mut self.rng);\n         // Tell the scheduler to start stealing on the next iteration\n-        this.steal_for_yield = true;\n-        do this.deschedule_running_task_and_then |sched, task| {\n+        self.steal_for_yield = true;\n+        do self.deschedule_running_task_and_then |sched, task| {\n             sched.enqueue_blocked_task(task);\n         }\n     }\n \n-    pub fn maybe_yield(~self) {\n+    pub fn maybe_yield(mut ~self) {\n         // The number of times to do the yield check before yielding, chosen arbitrarily.\n-        let mut this = self;\n-        rtassert!(this.yield_check_count > 0);\n-        this.yield_check_count -= 1;\n-        if this.yield_check_count == 0 {\n-            this.yield_now();\n+        rtassert!(self.yield_check_count > 0);\n+        self.yield_check_count -= 1;\n+        if self.yield_check_count == 0 {\n+            self.yield_now();\n         } else {\n-            Local::put(this);\n+            Local::put(self);\n         }\n     }\n "}, {"sha": "a3731e0b57abb27f2a3271b77a867ba42ba7679f", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -55,13 +55,12 @@ impl Thread {\n         }\n     }\n \n-    pub fn join(self) {\n+    pub fn join(mut self) {\n         #[fixed_stack_segment]; #[inline(never)];\n \n         assert!(!self.joined);\n-        let mut this = self;\n-        unsafe { rust_raw_thread_join(this.raw_thread); }\n-        this.joined = true;\n+        unsafe { rust_raw_thread_join(self.raw_thread); }\n+        self.joined = true;\n     }\n }\n "}, {"sha": "b0e2569a07633f5fe3ff3d5165b1875989f3dbbd", "filename": "src/libstd/rt/uv/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fuv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fmod.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -225,15 +225,14 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n         }\n     }\n \n-    fn close(self, cb: NullCallback) {\n-        let mut this = self;\n+    fn close(mut self, cb: NullCallback) {\n         {\n-            let data = this.get_watcher_data();\n+            let data = self.get_watcher_data();\n             assert!(data.close_cb.is_none());\n             data.close_cb = Some(cb);\n         }\n \n-        unsafe { uvll::close(this.native_handle(), close_cb); }\n+        unsafe { uvll::close(self.native_handle(), close_cb); }\n \n         extern fn close_cb(handle: *uvll::uv_handle_t) {\n             let mut h: Handle = NativeHandle::from_native_handle(handle);"}, {"sha": "bd8466a7925a09e999bcfe7aef568ce51de855d5", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -120,10 +120,9 @@ trait HomingIO {\n         a // return the result of the IO\n     }\n \n-    fn home_for_io_consume<A>(self, io: &fn(Self) -> A) -> A {\n-        let mut this = self;\n-        let home = this.go_to_IO_home();\n-        let a = io(this); // do IO\n+    fn home_for_io_consume<A>(mut self, io: &fn(Self) -> A) -> A {\n+        let home = self.go_to_IO_home();\n+        let a = io(self); // do IO\n         HomingIO::restore_original_home(None::<Self>, home);\n         a // return the result of the IO\n     }"}, {"sha": "1c412791d05e33b4e6b1a38d702fd150a2a69434", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -200,11 +200,10 @@ impl<T: Send> UnsafeArc<T> {\n \n     /// As unwrap above, but without blocking. Returns 'UnsafeArcSelf(self)' if this is\n     /// not the last reference; 'UnsafeArcT(unwrapped_data)' if so.\n-    pub fn try_unwrap(self) -> UnsafeArcUnwrap<T> {\n+    pub fn try_unwrap(mut self) -> UnsafeArcUnwrap<T> {\n         unsafe {\n-            let mut this = self; // FIXME(#4330) mutable self\n             // The ~ dtor needs to run if this code succeeds.\n-            let mut data: ~ArcData<T> = cast::transmute(this.data);\n+            let mut data: ~ArcData<T> = cast::transmute(self.data);\n             // This can of course race with anybody else who has a handle, but in\n             // such a case, the returned count will always be at least 2. If we\n             // see 1, no race was possible. All that matters is 1 or not-1.\n@@ -216,12 +215,12 @@ impl<T: Send> UnsafeArc<T> {\n             // (Note: using is_empty(), not take(), to not free the unwrapper.)\n             if count == 1 && data.unwrapper.is_empty(Acquire) {\n                 // Tell this handle's destructor not to run (we are now it).\n-                this.data = ptr::mut_null();\n+                self.data = ptr::mut_null();\n                 // FIXME(#3224) as above\n                 UnsafeArcT(data.data.take_unwrap())\n             } else {\n                 cast::forget(data);\n-                UnsafeArcSelf(this)\n+                UnsafeArcSelf(self)\n             }\n         }\n     }"}, {"sha": "a749597a3f0b5cc845f2cfe33e66d073be58cc78", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73091583dd42991213e102daefa9181ce500feb0/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/73091583dd42991213e102daefa9181ce500feb0/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=73091583dd42991213e102daefa9181ce500feb0", "patch": "@@ -1,3 +1,11 @@\n+S 2013-10-28 2ab4a6f\n+  freebsd-x86_64 08af04bcf739930bdb7d0ad244b2c8094cd5096a\n+  linux-i386 c233de1ed09872d5c7a3e1ce9ab9eb6e16631201\n+  linux-x86_64 3c16b8e0cf3a1af654cc084a6ccb80f2de8fe84f\n+  macos-i386 0fadb8c5afa4e4656ff37d0949aaa5a382f197a6\n+  macos-x86_64 c8b7a8f30f95bf71542451b8e1a8b9108de1f39a\n+  winnt-i386 c1c9dd8b2ef0c004e3327740732c6e06c3826fde\n+\n S 2013-10-22 ae0905a\n   freebsd-x86_64 6e9d81c160963308c2bf7886fae6726274b365ed\n   linux-i386 1c449504aa04c0345ad09f5bcb5a57b9656d11c3"}]}