{"sha": "2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a", "node_id": "C_kwDOAAsO6NoAKDJhYTQ5ZDQwMDVkMDBlN2YzYjZlZTFjNTk2ZjBjNTg3NWQ3NGQ5MGE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-22T17:09:25Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-03-28T17:02:21Z"}, "message": "Fix mixing lazy TAIT and RPIT in their defining scopes", "tree": {"sha": "a951a0ccaab3fa8e0f124dd91ba5c24dfa2097d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a951a0ccaab3fa8e0f124dd91ba5c24dfa2097d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a", "html_url": "https://github.com/rust-lang/rust/commit/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f6e27d4cf783e4a10326b16596e444dc325cf3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6e27d4cf783e4a10326b16596e444dc325cf3d", "html_url": "https://github.com/rust-lang/rust/commit/4f6e27d4cf783e4a10326b16596e444dc325cf3d"}], "stats": {"total": 107, "additions": 68, "deletions": 39}, "files": [{"sha": "59aea2b20306ad20fc250c7e3d4dbe5458063a83", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a", "patch": "@@ -95,6 +95,45 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let (a, b) = if a_is_expected { (a, b) } else { (b, a) };\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n             ty::Opaque(def_id, substs) => {\n+                let origin = if self.defining_use_anchor.is_some() {\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    self.opaque_type_origin(def_id, cause.span)?\n+                } else {\n+                    self.opaque_ty_origin_unchecked(def_id, cause.span)\n+                };\n                 if let ty::Opaque(did2, _) = *b.kind() {\n                     // We could accept this, but there are various ways to handle this situation, and we don't\n                     // want to make a decision on it right now. Likely this case is so super rare anyway, that\n@@ -126,45 +165,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     cause.clone(),\n                     param_env,\n                     b,\n-                    if self.defining_use_anchor.is_some() {\n-                        // Check that this is `impl Trait` type is\n-                        // declared by `parent_def_id` -- i.e., one whose\n-                        // value we are inferring.  At present, this is\n-                        // always true during the first phase of\n-                        // type-check, but not always true later on during\n-                        // NLL. Once we support named opaque types more fully,\n-                        // this same scenario will be able to arise during all phases.\n-                        //\n-                        // Here is an example using type alias `impl Trait`\n-                        // that indicates the distinction we are checking for:\n-                        //\n-                        // ```rust\n-                        // mod a {\n-                        //   pub type Foo = impl Iterator;\n-                        //   pub fn make_foo() -> Foo { .. }\n-                        // }\n-                        //\n-                        // mod b {\n-                        //   fn foo() -> a::Foo { a::make_foo() }\n-                        // }\n-                        // ```\n-                        //\n-                        // Here, the return type of `foo` references an\n-                        // `Opaque` indeed, but not one whose value is\n-                        // presently being inferred. You can get into a\n-                        // similar situation with closure return types\n-                        // today:\n-                        //\n-                        // ```rust\n-                        // fn foo() -> impl Iterator { .. }\n-                        // fn bar() {\n-                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                        // }\n-                        // ```\n-                        self.opaque_type_origin(def_id, cause.span)?\n-                    } else {\n-                        self.opaque_ty_origin_unchecked(def_id, cause.span)\n-                    },\n+                    origin,\n                 ))\n             }\n             _ => None,"}, {"sha": "7a9d64d339feb1531a526092d0f2b53616c862e1", "filename": "src/test/ui/impl-trait/async_scope_creep.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a/src%2Ftest%2Fui%2Fimpl-trait%2Fasync_scope_creep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a/src%2Ftest%2Fui%2Fimpl-trait%2Fasync_scope_creep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fasync_scope_creep.rs?ref=2aa49d4005d00e7f3b6ee1c596f0c5875d74d90a", "patch": "@@ -0,0 +1,28 @@\n+#![feature(type_alias_impl_trait)]\n+// edition:2021\n+// check-pass\n+\n+struct Pending {}\n+\n+struct CantOpen {}\n+\n+trait AsyncRead {}\n+\n+impl AsyncRead for i32 {}\n+\n+type PendingReader<'a> = impl AsyncRead + 'a;\n+\n+type OpeningReadFuture<'a> =\n+    impl std::future::Future<Output = Result<PendingReader<'a>, CantOpen>>;\n+\n+impl Pending {\n+    async fn read(&mut self) -> Result<impl AsyncRead + '_, CantOpen> {\n+        Ok(42)\n+    }\n+\n+    fn read_fut(&mut self) -> OpeningReadFuture<'_> {\n+        self.read()\n+    }\n+}\n+\n+fn main() {}"}]}