{"sha": "02357e459be7fb2014f57f1a86b38897c2c0816b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMzU3ZTQ1OWJlN2ZiMjAxNGY1N2YxYTg2YjM4ODk3YzJjMDgxNmI=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-09-27T22:56:41Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-10-01T23:16:08Z"}, "message": "Attempt to resolve linking issues.\n\nThis commit takes a different approach to add the `crate::` prefix to\nitem paths than previous commits. Previously, recursion was stopped\nafter a prelude crate name was pushed to the path. It is theorized that\nthis was the cause of the linking issues since the same path logic is\nused for symbol names and that not recursing meant that details were\nbeing missed that affect symbol names. As of this commit, instead of\nceasing recursion, a flag is passed through to any subsequent recursive\ncalls so that the same effect can be achieved by checking that flag.", "tree": {"sha": "92beedfaeca64945c62ea3d4bc071d44c31030fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92beedfaeca64945c62ea3d4bc071d44c31030fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02357e459be7fb2014f57f1a86b38897c2c0816b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAluyqrgACgkQAXYLT59T\n8VQU3RAAnada5HLztzkNwTs+S7yQ++NdioXd4/Yal32LYr5rUY2N1VO8gllEDycv\nAkUot5gEzPBRUL2oXME2CBSz5sC0HdEejQ1TA8O+7+yba5AzwUrOwI4mdiu0BYZl\nTn1fNt3gOX/NnW5ThHf7gcTpQrr2j8LXaqTi0dVjpEHfOPdEphovbuJ/eyQXKOZj\n6qDSgb0D3923bdXufwUZfHjkQd2muuycyczNd99W958ocO+nOt4aRHgUfP7KPyvS\nkROX7GwzE1263ny4JrPKKWb3oaMDsuSGtkG7JiSd4iNtcgLa2KCe+Vfxbis/P8Gl\nZ+0/kmeKAqPz7YR/7fmQjKDD2/ks3zj4BI7rczpEpFgD0OKtKWuIN4rU7EGpejfs\nLfe5t69la/veiIzpTG+fb13Pm2rHHQeHlAvNf+z5bCcNaq+ljYqVgNYObLsr+rg7\nBFoDJZmCZ3z7AuIA0GEenm92dcL/UY2i52dBrOaxO7Aalw72Neu30BOleGVNnhYW\nkfxlKkyX+hcVyMAI90GVtepiHS0LqMV4S1/0RV3g9jD7dQ05udAGhL9H6ybMdcNP\nC3t26ECF/poLhcbh7NQengNjepElyv1NHR27NfLct3G0enmPdBYBRHgT8Y0MNFEa\nw2EUKNnkFOxsH45eIL2X+jp8ye+gXYaeE5s7ARMbqXEI9C7I540=\n=OfjQ\n-----END PGP SIGNATURE-----", "payload": "tree 92beedfaeca64945c62ea3d4bc071d44c31030fb\nparent 4cbd397ce861ae0ee823ab56d1f797dee67e0b64\nauthor David Wood <david@davidtw.co> 1538089001 +0200\ncommitter David Wood <david@davidtw.co> 1538435768 +0200\n\nAttempt to resolve linking issues.\n\nThis commit takes a different approach to add the `crate::` prefix to\nitem paths than previous commits. Previously, recursion was stopped\nafter a prelude crate name was pushed to the path. It is theorized that\nthis was the cause of the linking issues since the same path logic is\nused for symbol names and that not recursing meant that details were\nbeing missed that affect symbol names. As of this commit, instead of\nceasing recursion, a flag is passed through to any subsequent recursive\ncalls so that the same effect can be achieved by checking that flag.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02357e459be7fb2014f57f1a86b38897c2c0816b", "html_url": "https://github.com/rust-lang/rust/commit/02357e459be7fb2014f57f1a86b38897c2c0816b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02357e459be7fb2014f57f1a86b38897c2c0816b/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cbd397ce861ae0ee823ab56d1f797dee67e0b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cbd397ce861ae0ee823ab56d1f797dee67e0b64", "html_url": "https://github.com/rust-lang/rust/commit/4cbd397ce861ae0ee823ab56d1f797dee67e0b64"}], "stats": {"total": 104, "additions": 60, "deletions": 44}, "files": [{"sha": "c8d104e6c321f4c6e3d88a2a412e617660ed96c7", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 58, "deletions": 42, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/02357e459be7fb2014f57f1a86b38897c2c0816b/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02357e459be7fb2014f57f1a86b38897c2c0816b/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=02357e459be7fb2014f57f1a86b38897c2c0816b", "patch": "@@ -78,7 +78,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         });\n         let mut buffer = LocalPathBuffer::new(mode);\n         debug!(\"item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id);\n+        self.push_item_path(&mut buffer, def_id, false);\n         buffer.into_string()\n     }\n \n@@ -92,14 +92,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         let mut buffer = LocalPathBuffer::new(RootMode::Absolute);\n         debug!(\"absolute_item_path_str: buffer={:?} def_id={:?}\", buffer, def_id);\n-        self.push_item_path(&mut buffer, def_id);\n+        self.push_item_path(&mut buffer, def_id, false);\n         buffer.into_string()\n     }\n \n     /// Returns the \"path\" to a particular crate. This can proceed in\n     /// various ways, depending on the `root_mode` of the `buffer`.\n     /// (See `RootMode` enum for more details.)\n-    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum)\n+    ///\n+    /// `pushed_prelude_crate` argument should be `true` when the buffer\n+    /// has had a prelude crate pushed to it. If this is the case, then\n+    /// we do not want to prepend `crate::` (as that would not be a valid\n+    /// path).\n+    pub fn push_krate_path<T>(self, buffer: &mut T, cnum: CrateNum, pushed_prelude_crate: bool)\n         where T: ItemPathBuffer + Debug\n     {\n         debug!(\n@@ -129,19 +134,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }) = *opt_extern_crate\n                     {\n                         debug!(\"push_krate_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id);\n+                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n                     } else {\n                         let name = self.crate_name(cnum).as_str();\n                         debug!(\"push_krate_path: name={:?}\", name);\n                         buffer.push(&name);\n                     }\n-                } else if self.sess.edition() == Edition::Edition2018 {\n+                } else if self.sess.edition() == Edition::Edition2018 && !pushed_prelude_crate {\n                     SHOULD_PREFIX_WITH_CRATE.with(|flag| {\n-                        // We only add the `crate::` keyword where appropriate. This\n-                        // is only possible because of the invariant in `push_item_path`\n-                        // that this function will not be called after printing the path\n-                        // to an item in the standard library. Without this invariant,\n-                        // we would print `crate::std::..` here.\n+                        // We only add the `crate::` keyword where appropriate. In particular,\n+                        // when we've not previously pushed a prelude crate to this path.\n                         if flag.get() {\n                             buffer.push(&keywords::Crate.name().as_str())\n                         }\n@@ -161,7 +163,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `external_def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n-    pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n+    pub fn try_push_visible_item_path<T>(\n+        self,\n+        buffer: &mut T,\n+        external_def_id: DefId,\n+        pushed_prelude_crate: bool,\n+    ) -> bool\n         where T: ItemPathBuffer + Debug\n     {\n         debug!(\n@@ -186,7 +193,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         ..\n                     }) => {\n                         debug!(\"try_push_visible_item_path: def_id={:?}\", def_id);\n-                        self.push_item_path(buffer, def_id);\n+                        self.push_item_path(buffer, def_id, pushed_prelude_crate);\n                         cur_path.iter().rev().for_each(|segment| buffer.push(&segment));\n                         return true;\n                     }\n@@ -230,13 +237,16 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId)\n+    pub fn push_item_path<T>(self, buffer: &mut T, def_id: DefId, pushed_prelude_crate: bool)\n         where T: ItemPathBuffer + Debug\n     {\n-        debug!(\"push_item_path: buffer={:?} def_id={:?}\", buffer, def_id);\n+        debug!(\n+            \"push_item_path: buffer={:?} def_id={:?} pushed_prelude_crate={:?}\",\n+            buffer, def_id, pushed_prelude_crate\n+        );\n         match *buffer.root_mode() {\n             RootMode::Local if !def_id.is_local() =>\n-                if self.try_push_visible_item_path(buffer, def_id) { return },\n+                if self.try_push_visible_item_path(buffer, def_id, pushed_prelude_crate) { return },\n             _ => {}\n         }\n \n@@ -245,11 +255,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match key.disambiguated_data.data {\n             DefPathData::CrateRoot => {\n                 assert!(key.parent.is_none());\n-                self.push_krate_path(buffer, def_id.krate);\n+                self.push_krate_path(buffer, def_id.krate, pushed_prelude_crate);\n             }\n \n             DefPathData::Impl => {\n-                self.push_impl_path(buffer, def_id);\n+                self.push_impl_path(buffer, def_id, pushed_prelude_crate);\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -272,34 +282,37 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::ClosureExpr |\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n-                let parent_def_id = self.parent_def_id(def_id).unwrap();\n-\n-                match self.def_key(parent_def_id).disambiguated_data.data {\n-                    // Skip recursing to print the crate root depending on the\n-                    // current name.\n-                    //\n-                    // In particular, don't recurse to print the crate root if we\n-                    // just printed `std`. In doing this, we are able to add\n-                    // `crate::` to trait import suggestions.\n-                    DefPathData::CrateRoot if self.sess.extern_prelude.contains(\n-                        &data.as_interned_str().as_symbol()\n-                    ) => {},\n-                    _ => self.push_item_path(buffer, parent_def_id),\n+                let parent_did = self.parent_def_id(def_id).unwrap();\n+\n+                // Keep track of whether we are one recursion away from the `CrateRoot` and\n+                // pushing the name of a prelude crate. If we are, we'll want to know this when\n+                // printing the `CrateRoot` so we don't prepend a `crate::` to paths.\n+                let mut is_prelude_crate = false;\n+                if let DefPathData::CrateRoot = self.def_key(parent_did).disambiguated_data.data {\n+                    if self.sess.extern_prelude.contains(&data.as_interned_str().as_symbol()) {\n+                        is_prelude_crate = true;\n+                    }\n                 }\n \n+                self.push_item_path(\n+                    buffer, parent_did, pushed_prelude_crate || is_prelude_crate\n+                );\n                 buffer.push(&data.as_interned_str().as_symbol().as_str());\n             },\n \n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n-                self.push_item_path(buffer, parent_def_id);\n+                self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n             }\n         }\n     }\n \n-    fn push_impl_path<T>(self,\n-                         buffer: &mut T,\n-                         impl_def_id: DefId)\n+    fn push_impl_path<T>(\n+        self,\n+         buffer: &mut T,\n+         impl_def_id: DefId,\n+         pushed_prelude_crate: bool,\n+    )\n         where T: ItemPathBuffer + Debug\n     {\n         debug!(\"push_impl_path: buffer={:?} impl_def_id={:?}\", buffer, impl_def_id);\n@@ -314,7 +327,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         if !use_types {\n-            return self.push_impl_path_fallback(buffer, impl_def_id);\n+            return self.push_impl_path_fallback(buffer, impl_def_id, pushed_prelude_crate);\n         }\n \n         // Decide whether to print the parent path for the impl.\n@@ -338,7 +351,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            self.push_item_path(buffer, parent_def_id);\n+            self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n             if let Some(trait_ref) = impl_trait_ref {\n                 buffer.push(&format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n@@ -364,13 +377,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self_ty.sty {\n             ty::Adt(adt_def, substs) => {\n                 if substs.types().next().is_none() { // ignore regions\n-                    self.push_item_path(buffer, adt_def.did);\n+                    self.push_item_path(buffer, adt_def.did, pushed_prelude_crate);\n                 } else {\n                     buffer.push(&format!(\"<{}>\", self_ty));\n                 }\n             }\n \n-            ty::Foreign(did) => self.push_item_path(buffer, did),\n+            ty::Foreign(did) => self.push_item_path(buffer, did, pushed_prelude_crate),\n \n             ty::Bool |\n             ty::Char |\n@@ -387,16 +400,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn push_impl_path_fallback<T>(self,\n-                                  buffer: &mut T,\n-                                  impl_def_id: DefId)\n+    fn push_impl_path_fallback<T>(\n+        self,\n+        buffer: &mut T,\n+        impl_def_id: DefId,\n+        pushed_prelude_crate: bool,\n+    )\n         where T: ItemPathBuffer + Debug\n     {\n         // If no type info is available, fall back to\n         // pretty printing some span information. This should\n         // only occur very early in the compiler pipeline.\n         let parent_def_id = self.parent_def_id(impl_def_id).unwrap();\n-        self.push_item_path(buffer, parent_def_id);\n+        self.push_item_path(buffer, parent_def_id, pushed_prelude_crate);\n         let node_id = self.hir.as_local_node_id(impl_def_id).unwrap();\n         let item = self.hir.expect_item(node_id);\n         let span_str = self.sess.source_map().span_to_string(item.span);"}, {"sha": "c1e80234a775010067889c7dbb855e541a811e25", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02357e459be7fb2014f57f1a86b38897c2c0816b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02357e459be7fb2014f57f1a86b38897c2c0816b/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=02357e459be7fb2014f57f1a86b38897c2c0816b", "patch": "@@ -228,7 +228,7 @@ fn get_symbol_hash<'a, 'tcx>(\n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     let mut buffer = SymbolPathBuffer::new();\n     item_path::with_forced_absolute_paths(|| {\n-        tcx.push_item_path(&mut buffer, def_id);\n+        tcx.push_item_path(&mut buffer, def_id, false);\n     });\n     buffer.into_interned()\n }"}, {"sha": "371b631723a39bb35beea29188331c330892e215", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02357e459be7fb2014f57f1a86b38897c2c0816b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02357e459be7fb2014f57f1a86b38897c2c0816b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=02357e459be7fb2014f57f1a86b38897c2c0816b", "patch": "@@ -4008,7 +4008,7 @@ where F: Fn(DefId) -> Def {\n \n     let mut apb = AbsolutePathBuffer { names: vec![] };\n \n-    tcx.push_item_path(&mut apb, def_id);\n+    tcx.push_item_path(&mut apb, def_id, false);\n \n     hir::Path {\n         span: DUMMY_SP,"}]}