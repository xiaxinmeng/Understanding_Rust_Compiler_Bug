{"sha": "5448de72c26fd552e80feeceabb056112927c288", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0NDhkZTcyYzI2ZmQ1NTJlODBmZWVjZWFiYjA1NjExMjkyN2MyODg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-18T21:36:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-18T21:36:32Z"}, "message": "generalize bitvector code into a bitmatrix; write some unit tests, but\nprobably not enough. This code is so simple, what could possibly go\nwrong?", "tree": {"sha": "fb80747c226816e0d3c2134218afeb432a16671f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb80747c226816e0d3c2134218afeb432a16671f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5448de72c26fd552e80feeceabb056112927c288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5448de72c26fd552e80feeceabb056112927c288", "html_url": "https://github.com/rust-lang/rust/commit/5448de72c26fd552e80feeceabb056112927c288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5448de72c26fd552e80feeceabb056112927c288/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c11e4a48ec3ac385f32da1879384bc6921bdf75", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c11e4a48ec3ac385f32da1879384bc6921bdf75", "html_url": "https://github.com/rust-lang/rust/commit/6c11e4a48ec3ac385f32da1879384bc6921bdf75"}], "stats": {"total": 185, "additions": 176, "deletions": 9}, "files": [{"sha": "a0e4f4a3f2d60ac5e0f14dd0fb1324ea019cda4d", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 176, "deletions": 9, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/5448de72c26fd552e80feeceabb056112927c288/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5448de72c26fd552e80feeceabb056112927c288/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=5448de72c26fd552e80feeceabb056112927c288", "patch": "@@ -15,26 +15,193 @@ pub struct BitVector {\n \n impl BitVector {\n     pub fn new(num_bits: usize) -> BitVector {\n-        let num_words = (num_bits + 63) / 64;\n+        let num_words = u64s(num_bits);\n         BitVector { data: vec![0; num_words] }\n     }\n \n-    fn word_mask(&self, bit: usize) -> (usize, u64) {\n-        let word = bit / 64;\n-        let mask = 1 << (bit % 64);\n-        (word, mask)\n-    }\n-\n     pub fn contains(&self, bit: usize) -> bool {\n-        let (word, mask) = self.word_mask(bit);\n+        let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n     }\n \n     pub fn insert(&mut self, bit: usize) -> bool {\n-        let (word, mask) = self.word_mask(bit);\n+        let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n         let value = *data;\n         *data = value | mask;\n         (value | mask) != value\n     }\n+\n+    pub fn insert_all(&mut self, all: &BitVector) -> bool {\n+        assert!(self.data.len() == all.data.len());\n+        let mut changed = false;\n+        for (i, j) in self.data.iter_mut().zip(&all.data) {\n+            let value = *i;\n+            *i = value | *j;\n+            if value != *i { changed = true; }\n+        }\n+        changed\n+    }\n+\n+    pub fn grow(&mut self, num_bits: usize) {\n+        let num_words = u64s(num_bits);\n+        let extra_words = self.data.len() - num_words;\n+        self.data.extend((0..extra_words).map(|_| 0));\n+    }\n+}\n+\n+/// A \"bit matrix\" is basically a square matrix of booleans\n+/// represented as one gigantic bitvector. In other words, it is as if\n+/// you have N bitvectors, each of length N.\n+#[derive(Clone)]\n+pub struct BitMatrix {\n+    elements: usize,\n+    vector: Vec<u64>,\n+}\n+\n+impl BitMatrix {\n+    pub fn new(elements: usize) -> BitMatrix {\n+        // For every element, we need one bit for every other\n+        // element. Round up to an even number of u64s.\n+        let u64s_per_elem = u64s(elements);\n+        BitMatrix {\n+            elements: elements,\n+            vector: vec![0; elements * u64s_per_elem]\n+        }\n+    }\n+\n+    /// The range of bits for a given element.\n+    fn range(&self, element: usize) -> (usize, usize) {\n+        let u64s_per_elem = u64s(self.elements);\n+        let start = element * u64s_per_elem;\n+        (start, start + u64s_per_elem)\n+    }\n+\n+    pub fn add(&mut self, source: usize, target: usize) -> bool {\n+        let (start, _) = self.range(source);\n+        let (word, mask) = word_mask(target);\n+        let mut vector = &mut self.vector[..];\n+        let v1 = vector[start+word];\n+        let v2 = v1 | mask;\n+        vector[start+word] = v2;\n+        v1 != v2\n+    }\n+\n+    /// Do the bits from `source` contain `target`?\n+    /// Put another way, can `source` reach `target`?\n+    pub fn contains(&self, source: usize, target: usize) -> bool {\n+        let (start, _) = self.range(source);\n+        let (word, mask) = word_mask(target);\n+        (self.vector[start+word] & mask) != 0\n+    }\n+\n+    /// Returns those indices that are reachable from both source and\n+    /// target. This is an O(n) operation where `n` is the number of\n+    /// elements (somewhat independent from the actual size of the\n+    /// intersection, in particular).\n+    pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n+        let (a_start, a_end) = self.range(a);\n+        let (b_start, b_end) = self.range(b);\n+        let mut result = Vec::with_capacity(self.elements);\n+        for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n+            let mut v = self.vector[i] & self.vector[j];\n+            for bit in 0..64 {\n+                if v == 0 { break; }\n+                if v & 0x1 != 0 { result.push(base*64 + bit); }\n+                v >>= 1;\n+            }\n+        }\n+        result\n+    }\n+\n+    /// Add the bits from source to the bits from destination,\n+    /// return true if anything changed.\n+    ///\n+    /// This is used when computing reachability because if you have\n+    /// an edge `destination -> source`, because in that case\n+    /// `destination` can reach everything that `source` can (and\n+    /// potentially more).\n+    pub fn merge(&mut self, source: usize, destination: usize) -> bool {\n+        let (source_start, source_end) = self.range(source);\n+        let (destination_start, destination_end) = self.range(destination);\n+        let vector = &mut self.vector[..];\n+        let mut changed = false;\n+        for (source_index, destination_index) in\n+            (source_start..source_end).zip(destination_start..destination_end)\n+        {\n+            let v1 = vector[destination_index];\n+            let v2 = v1 | vector[source_index];\n+            vector[destination_index] = v2;\n+            changed = changed | (v1 != v2);\n+        }\n+        changed\n+    }\n+}\n+\n+fn u64s(elements: usize) -> usize {\n+    (elements + 63) / 64\n+}\n+\n+fn word_mask(index: usize) -> (usize, u64) {\n+    let word = index / 64;\n+    let mask = 1 << (index % 64);\n+    (word, mask)\n+}\n+\n+#[test]\n+fn union_two_vecs() {\n+    let mut vec1 = BitVector::new(65);\n+    let mut vec2 = BitVector::new(65);\n+    assert!(vec1.insert(3));\n+    assert!(!vec1.insert(3));\n+    assert!(vec2.insert(5));\n+    assert!(vec2.insert(64));\n+    assert!(vec1.insert_all(&vec2));\n+    assert!(!vec1.insert_all(&vec2));\n+    assert!(vec1.contains(3));\n+    assert!(!vec1.contains(4));\n+    assert!(vec1.contains(5));\n+    assert!(!vec1.contains(63));\n+    assert!(vec1.contains(64));\n+}\n+\n+#[test]\n+fn grow() {\n+    let mut vec1 = BitVector::new(65);\n+    assert!(vec1.insert(3));\n+    assert!(!vec1.insert(3));\n+    assert!(vec1.insert(5));\n+    assert!(vec1.insert(64));\n+    vec1.grow(128);\n+    assert!(vec1.contains(3));\n+    assert!(vec1.contains(5));\n+    assert!(vec1.contains(64));\n+    assert!(!vec1.contains(126));\n+}\n+\n+#[test]\n+fn matrix_intersection() {\n+    let mut vec1 = BitMatrix::new(200);\n+\n+    vec1.add(2, 3);\n+    vec1.add(2, 6);\n+    vec1.add(2, 10);\n+    vec1.add(2, 64);\n+    vec1.add(2, 65);\n+    vec1.add(2, 130);\n+    vec1.add(2, 160);\n+\n+    vec1.add(65, 2);\n+    vec1.add(65, 8);\n+    vec1.add(65, 10); // X\n+    vec1.add(65, 64); // X\n+    vec1.add(65, 68);\n+    vec1.add(65, 133);\n+    vec1.add(65, 160); // X\n+\n+    let intersection = vec1.intersection(2, 64);\n+    assert!(intersection.is_empty());\n+\n+    let intersection = vec1.intersection(2, 65);\n+    assert_eq!(intersection, vec![10, 64, 160]);\n }"}]}