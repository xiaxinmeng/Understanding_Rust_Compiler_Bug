{"sha": "94b0fee6f135da6d507a9e77014ff4dd55bd72ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YjBmZWU2ZjEzNWRhNmQ1MDdhOWU3NzAxNGZmNGRkNTViZDcyZWQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-08T01:54:35Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-08T02:50:23Z"}, "message": "rt: Reorganize and add documentation for rust_upcall.cpp", "tree": {"sha": "5470bb930677bbee8dbfb4b228247fbd35e86c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5470bb930677bbee8dbfb4b228247fbd35e86c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94b0fee6f135da6d507a9e77014ff4dd55bd72ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94b0fee6f135da6d507a9e77014ff4dd55bd72ed", "html_url": "https://github.com/rust-lang/rust/commit/94b0fee6f135da6d507a9e77014ff4dd55bd72ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94b0fee6f135da6d507a9e77014ff4dd55bd72ed/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31fe5d0bd8254878014a8db5712319aaf34269a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/31fe5d0bd8254878014a8db5712319aaf34269a9", "html_url": "https://github.com/rust-lang/rust/commit/31fe5d0bd8254878014a8db5712319aaf34269a9"}], "stats": {"total": 333, "additions": 163, "deletions": 170}, "files": [{"sha": "ed010b24d4182585af88e8cf6371a8abbd47ae50", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 163, "deletions": 170, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/94b0fee6f135da6d507a9e77014ff4dd55bd72ed/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/94b0fee6f135da6d507a9e77014ff4dd55bd72ed/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=94b0fee6f135da6d507a9e77014ff4dd55bd72ed", "patch": "@@ -1,3 +1,11 @@\n+/*\n+  Upcalls\n+\n+  These are runtime functions that the compiler knows about and generates\n+  calls to. They are called on the Rust stack and, in most cases, immediately\n+  switch to the C stack.\n+ */\n+\n #include \"rust_cc.h\"\n #include \"rust_gc.h\"\n #include \"rust_internal.h\"\n@@ -12,6 +20,8 @@ extern \"C\" void record_sp(void *limit);\n \n /**\n  * Switches to the C-stack and invokes |fn_ptr|, passing |args| as argument.\n+ * This is used by the C compiler to call native functions and by other\n+ * upcalls to switch to the C stack.\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n@@ -34,25 +44,6 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n     task->record_stack_limit();\n }\n \n-// Copy elements from one vector to another,\n-// dealing with reference counts\n-static inline void\n-copy_elements(rust_task *task, type_desc *elem_t,\n-              void *pdst, void *psrc, size_t n) {\n-    char *dst = (char *)pdst, *src = (char *)psrc;\n-    memmove(dst, src, n);\n-\n-    // increment the refcount of each element of the vector\n-    if (elem_t->take_glue) {\n-        glue_fn *take_glue = elem_t->take_glue;\n-        size_t elem_size = elem_t->size;\n-        const type_desc **tydescs = elem_t->first_param;\n-        for (char *p = dst; p < dst+n; p += elem_size) {\n-            take_glue(NULL, NULL, tydescs, p);\n-        }\n-    }\n-}\n-\n struct s_fail_args {\n     char const *expr;\n     char const *file;\n@@ -68,6 +59,16 @@ upcall_s_fail(s_fail_args *args) {\n     task->fail();\n }\n \n+extern \"C\" CDECL void\n+upcall_fail(char const *expr,\n+            char const *file,\n+            size_t line) {\n+    // FIXME: Need to fix the stack switching function to unwind properly\n+    // in order to switch stacks here\n+    s_fail_args args = {expr,file,line};\n+    upcall_s_fail(&args);\n+}\n+\n struct s_malloc_args {\n     uintptr_t retval;\n     size_t nbytes;\n@@ -101,14 +102,18 @@ upcall_s_malloc(s_malloc_args *args) {\n     args->retval = (uintptr_t) p;\n }\n \n+extern \"C\" CDECL uintptr_t\n+upcall_malloc(size_t nbytes, type_desc *td) {\n+    s_malloc_args args = {0, nbytes, td};\n+    SWITCH_STACK(&args, upcall_s_malloc);\n+    return args.retval;\n+}\n+\n struct s_free_args {\n     void *ptr;\n     uintptr_t is_gc;\n };\n \n-/**\n- * Called whenever an object's ref count drops to zero.\n- */\n extern \"C\" CDECL void\n upcall_s_free(s_free_args *args) {\n     rust_task *task = rust_scheduler::get_task();\n@@ -125,6 +130,15 @@ upcall_s_free(s_free_args *args) {\n     task->free(args->ptr, (bool) args->is_gc);\n }\n \n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_free(void* ptr, uintptr_t is_gc) {\n+    s_free_args args = {ptr, is_gc};\n+    SWITCH_STACK(&args, upcall_s_free);\n+}\n+\n struct s_shared_malloc_args {\n     uintptr_t retval;\n     size_t nbytes;\n@@ -148,6 +162,13 @@ upcall_s_shared_malloc(s_shared_malloc_args *args) {\n     args->retval = (uintptr_t) p;\n }\n \n+extern \"C\" CDECL uintptr_t\n+upcall_shared_malloc(size_t nbytes, type_desc *td) {\n+    s_shared_malloc_args args = {0, nbytes, td};\n+    SWITCH_STACK(&args, upcall_s_shared_malloc);\n+    return args.retval;\n+}\n+\n struct s_shared_free_args {\n     void *ptr;\n };\n@@ -167,6 +188,15 @@ upcall_s_shared_free(s_shared_free_args *args) {\n     task->kernel->free(args->ptr);\n }\n \n+/**\n+ * Called whenever an object's ref count drops to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_shared_free(void* ptr) {\n+    s_shared_free_args args = {ptr};\n+    SWITCH_STACK(&args, upcall_s_shared_free);\n+}\n+\n struct s_get_type_desc_args {\n     type_desc *retval;\n     size_t size;\n@@ -191,6 +221,18 @@ upcall_s_get_type_desc(s_get_type_desc_args *args) {\n     args->retval = td;\n }\n \n+extern \"C\" CDECL type_desc *\n+upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n+                     size_t size,\n+                     size_t align,\n+                     size_t n_descs,\n+                     type_desc const **descs,\n+                     uintptr_t n_obj_params) {\n+    s_get_type_desc_args args = {0,size,align,n_descs,descs,n_obj_params};\n+    SWITCH_STACK(&args, upcall_s_get_type_desc);\n+    return args.retval;\n+}\n+\n struct s_vec_grow_args {\n     rust_vec** vp;\n     size_t new_sz;\n@@ -204,6 +246,31 @@ upcall_s_vec_grow(s_vec_grow_args *args) {\n     (*args->vp)->fill = args->new_sz;\n }\n \n+extern \"C\" CDECL void\n+upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+    s_vec_grow_args args = {vp, new_sz};\n+    SWITCH_STACK(&args, upcall_s_vec_grow);\n+}\n+\n+// Copy elements from one vector to another,\n+// dealing with reference counts\n+static inline void\n+copy_elements(rust_task *task, type_desc *elem_t,\n+              void *pdst, void *psrc, size_t n) {\n+    char *dst = (char *)pdst, *src = (char *)psrc;\n+    memmove(dst, src, n);\n+\n+    // increment the refcount of each element of the vector\n+    if (elem_t->take_glue) {\n+        glue_fn *take_glue = elem_t->take_glue;\n+        size_t elem_size = elem_t->size;\n+        const type_desc **tydescs = elem_t->first_param;\n+        for (char *p = dst; p < dst+n; p += elem_size) {\n+            take_glue(NULL, NULL, tydescs, p);\n+        }\n+    }\n+}\n+\n struct s_vec_push_args {\n     rust_vec** vp;\n     type_desc* elt_ty;\n@@ -222,46 +289,64 @@ upcall_s_vec_push(s_vec_push_args *args) {\n     v->fill += args->elt_ty->size;\n }\n \n+extern \"C\" CDECL void\n+upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n+    // FIXME: Switching stacks here causes crashes, probably\n+    // because this upcall calls take glue\n+    s_vec_push_args args = {vp, elt_ty, elt};\n+    upcall_s_vec_push(&args);\n+}\n+\n struct s_dynastack_mark_args {\n     void *retval;\n };\n \n+extern \"C\" CDECL void\n+upcall_s_dynastack_mark(s_dynastack_mark_args *args) {\n+    args->retval = rust_scheduler::get_task()->dynastack.mark();\n+}\n+\n /**\n  * Returns a token that can be used to deallocate all of the allocated space\n  * space in the dynamic stack.\n  */\n-extern \"C\" CDECL void\n-upcall_s_dynastack_mark(s_dynastack_mark_args *args) {\n-    args->retval = rust_scheduler::get_task()->dynastack.mark();\n+extern \"C\" CDECL void *\n+upcall_dynastack_mark() {\n+    s_dynastack_mark_args args = {0};\n+    SWITCH_STACK(&args, upcall_s_dynastack_mark);\n+    return args.retval;\n }\n \n struct s_dynastack_alloc_args {\n     void *retval;\n     size_t sz;\n };\n \n-/**\n- * Allocates space in the dynamic stack and returns it.\n- *\n- * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n- */\n extern \"C\" CDECL void\n upcall_s_dynastack_alloc(s_dynastack_alloc_args *args) {\n     size_t sz = args->sz;\n     args->retval = sz ?\n         rust_scheduler::get_task()->dynastack.alloc(sz, NULL) : NULL;\n }\n \n+/**\n+ * Allocates space in the dynamic stack and returns it.\n+ *\n+ * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_alloc(size_t sz) {\n+    s_dynastack_alloc_args args = {0, sz};\n+    SWITCH_STACK(&args, upcall_s_dynastack_alloc);\n+    return args.retval;\n+}\n+\n struct s_dynastack_alloc_2_args {\n     void *retval;\n     size_t sz;\n     type_desc *ty;\n };\n \n-/**\n- * Allocates space associated with a type descriptor in the dynamic stack and\n- * returns it.\n- */\n extern \"C\" CDECL void\n upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n     size_t sz = args->sz;\n@@ -270,16 +355,33 @@ upcall_s_dynastack_alloc_2(s_dynastack_alloc_2_args *args) {\n         rust_scheduler::get_task()->dynastack.alloc(sz, ty) : NULL;\n }\n \n+/**\n+ * Allocates space associated with a type descriptor in the dynamic stack and\n+ * returns it.\n+ */\n+extern \"C\" CDECL void *\n+upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n+    s_dynastack_alloc_2_args args = {0, sz, ty};\n+    SWITCH_STACK(&args, upcall_s_dynastack_alloc_2);\n+    return args.retval;\n+}\n+\n struct s_dynastack_free_args {\n     void *ptr;\n };\n \n-/** Frees space in the dynamic stack. */\n extern \"C\" CDECL void\n upcall_s_dynastack_free(s_dynastack_free_args *args) {\n     return rust_scheduler::get_task()->dynastack.free(args->ptr);\n }\n \n+/** Frees space in the dynamic stack. */\n+extern \"C\" CDECL void\n+upcall_dynastack_free(void *ptr) {\n+    s_dynastack_free_args args = {ptr};\n+    SWITCH_STACK(&args, upcall_s_dynastack_free);\n+}\n+\n extern \"C\" _Unwind_Reason_Code\n __gxx_personality_v0(int version,\n                      _Unwind_Action actions,\n@@ -305,6 +407,24 @@ upcall_s_rust_personality(s_rust_personality_args *args) {\n                                         args->context);\n }\n \n+/**\n+   The exception handling personality function. It figures\n+   out what to do with each landing pad. Just a stack-switching\n+   wrapper around the C++ personality function.\n+*/\n+extern \"C\" _Unwind_Reason_Code\n+upcall_rust_personality(int version,\n+                        _Unwind_Action actions,\n+                        uint64_t exception_class,\n+                        _Unwind_Exception *ue_header,\n+                        _Unwind_Context *context) {\n+    s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n+                                    version, actions, exception_class,\n+                                    ue_header, context};\n+    SWITCH_STACK(&args, upcall_s_rust_personality);\n+    return args.retval;\n+}\n+\n extern \"C\" void\n shape_cmp_type(int8_t *result, const type_desc *tydesc,\n                const type_desc **subtydescs, uint8_t *data_0,\n@@ -325,6 +445,14 @@ upcall_s_cmp_type(s_cmp_type_args *args) {\n                    args->data_0, args->data_1, args->cmp_type);\n }\n \n+extern \"C\" void\n+upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n+                const type_desc **subtydescs, uint8_t *data_0,\n+                uint8_t *data_1, uint8_t cmp_type) {\n+    s_cmp_type_args args = {result, tydesc, subtydescs, data_0, data_1, cmp_type};\n+    SWITCH_STACK(&args, upcall_s_cmp_type);\n+}\n+\n extern \"C\" void\n shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level);\n \n@@ -339,141 +467,6 @@ upcall_s_log_type(s_log_type_args *args) {\n     shape_log_type(args->tydesc, args->data, args->level);\n }\n \n-\n-// ______________________________________________________________________________\n-// Upcalls in original format: deprecated and should be removed once snapshot\n-// transitions them away.\n-\n-extern \"C\" CDECL void\n-upcall_fail(char const *expr,\n-            char const *file,\n-            size_t line) {\n-    // FIXME: Need to fix the stack switching function to unwind properly\n-    // in order to switch stacks here\n-    s_fail_args args = {expr,file,line};\n-    upcall_s_fail(&args);\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-upcall_malloc(size_t nbytes, type_desc *td) {\n-    s_malloc_args args = {0, nbytes, td};\n-    SWITCH_STACK(&args, upcall_s_malloc);\n-    return args.retval;\n-}\n-\n-/**\n- * Called whenever an object's ref count drops to zero.\n- */\n-extern \"C\" CDECL void\n-upcall_free(void* ptr, uintptr_t is_gc) {\n-    s_free_args args = {ptr, is_gc};\n-    SWITCH_STACK(&args, upcall_s_free);\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-upcall_shared_malloc(size_t nbytes, type_desc *td) {\n-    s_shared_malloc_args args = {0, nbytes, td};\n-    SWITCH_STACK(&args, upcall_s_shared_malloc);\n-    return args.retval;\n-}\n-\n-/**\n- * Called whenever an object's ref count drops to zero.\n- */\n-extern \"C\" CDECL void\n-upcall_shared_free(void* ptr) {\n-    s_shared_free_args args = {ptr};\n-    SWITCH_STACK(&args, upcall_s_shared_free);\n-}\n-\n-extern \"C\" CDECL type_desc *\n-upcall_get_type_desc(void *curr_crate, // ignored, legacy compat.\n-                     size_t size,\n-                     size_t align,\n-                     size_t n_descs,\n-                     type_desc const **descs,\n-                     uintptr_t n_obj_params) {\n-    s_get_type_desc_args args = {0,size,align,n_descs,descs,n_obj_params};\n-    SWITCH_STACK(&args, upcall_s_get_type_desc);\n-    return args.retval;\n-}\n-\n-extern \"C\" CDECL void\n-upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n-    s_vec_grow_args args = {vp, new_sz};\n-    SWITCH_STACK(&args, upcall_s_vec_grow);\n-}\n-\n-extern \"C\" CDECL void\n-upcall_vec_push(rust_vec** vp, type_desc* elt_ty, void* elt) {\n-    // FIXME: Switching stacks here causes crashes, probably\n-    // because this upcall calls take glue\n-    s_vec_push_args args = {vp, elt_ty, elt};\n-    upcall_s_vec_push(&args);\n-}\n-\n-/**\n- * Returns a token that can be used to deallocate all of the allocated space\n- * space in the dynamic stack.\n- */\n-extern \"C\" CDECL void *\n-upcall_dynastack_mark() {\n-    s_dynastack_mark_args args = {0};\n-    SWITCH_STACK(&args, upcall_s_dynastack_mark);\n-    return args.retval;\n-}\n-\n-/**\n- * Allocates space in the dynamic stack and returns it.\n- *\n- * FIXME: Deprecated since dynamic stacks need to be self-describing for GC.\n- */\n-extern \"C\" CDECL void *\n-upcall_dynastack_alloc(size_t sz) {\n-    s_dynastack_alloc_args args = {0, sz};\n-    SWITCH_STACK(&args, upcall_s_dynastack_alloc);\n-    return args.retval;\n-}\n-\n-/**\n- * Allocates space associated with a type descriptor in the dynamic stack and\n- * returns it.\n- */\n-extern \"C\" CDECL void *\n-upcall_dynastack_alloc_2(size_t sz, type_desc *ty) {\n-    s_dynastack_alloc_2_args args = {0, sz, ty};\n-    SWITCH_STACK(&args, upcall_s_dynastack_alloc_2);\n-    return args.retval;\n-}\n-\n-/** Frees space in the dynamic stack. */\n-extern \"C\" CDECL void\n-upcall_dynastack_free(void *ptr) {\n-    s_dynastack_free_args args = {ptr};\n-    SWITCH_STACK(&args, upcall_s_dynastack_free);\n-}\n-\n-extern \"C\" _Unwind_Reason_Code\n-upcall_rust_personality(int version,\n-                        _Unwind_Action actions,\n-                        uint64_t exception_class,\n-                        _Unwind_Exception *ue_header,\n-                        _Unwind_Context *context) {\n-    s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n-                                    version, actions, exception_class,\n-                                    ue_header, context};\n-    SWITCH_STACK(&args, upcall_s_rust_personality);\n-    return args.retval;\n-}\n-\n-extern \"C\" void\n-upcall_cmp_type(int8_t *result, const type_desc *tydesc,\n-                const type_desc **subtydescs, uint8_t *data_0,\n-                uint8_t *data_1, uint8_t cmp_type) {\n-    s_cmp_type_args args = {result, tydesc, subtydescs, data_0, data_1, cmp_type};\n-    SWITCH_STACK(&args, upcall_s_cmp_type);\n-}\n-\n extern \"C\" void\n upcall_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n     s_log_type_args args = {tydesc, data, level};"}]}