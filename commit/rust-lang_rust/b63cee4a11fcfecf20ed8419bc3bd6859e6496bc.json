{"sha": "b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2M2NlZTRhMTFmY2ZlY2YyMGVkODQxOWJjM2JkNjg1OWU2NDk2YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-14T17:01:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-14T17:01:11Z"}, "message": "Auto merge of #22158 - Kimundi:the_lonely_uppercase_keyword, r=pnkfelix\n\nIt is only allowed in paths now, where it will either work inside a `trait`\r\nor `impl` item, or not resolve outside of it.\r\n\r\n[breaking-change]\r\n\r\nCloses #22137", "tree": {"sha": "e614f946a2e7811fe886a52ee19899a4ede35dd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e614f946a2e7811fe886a52ee19899a4ede35dd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "html_url": "https://github.com/rust-lang/rust/commit/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d1c1added595c1c3410a1b72d8f0134942e4e24", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d1c1added595c1c3410a1b72d8f0134942e4e24", "html_url": "https://github.com/rust-lang/rust/commit/3d1c1added595c1c3410a1b72d8f0134942e4e24"}, {"sha": "07d00deab22dc07ffc58b8e74d45596242ca8b15", "url": "https://api.github.com/repos/rust-lang/rust/commits/07d00deab22dc07ffc58b8e74d45596242ca8b15", "html_url": "https://github.com/rust-lang/rust/commit/07d00deab22dc07ffc58b8e74d45596242ca8b15"}], "stats": {"total": 165, "additions": 124, "deletions": 41}, "files": [{"sha": "223d46e4e4a93ebbb902c7f1d49fecfa031b77b6", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -101,7 +101,7 @@ impl<'a> SpanUtils<'a> {\n                 return self.make_sub_span(span, result)\n             }\n             if bracket_count == 0 &&\n-               (ts.tok.is_ident() || ts.tok.is_keyword(keywords::Self)) {\n+               (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n                 result = Some(ts.sp);\n             }\n \n@@ -124,7 +124,7 @@ impl<'a> SpanUtils<'a> {\n                 return None;\n             }\n             if bracket_count == 0 &&\n-               (ts.tok.is_ident() || ts.tok.is_keyword(keywords::Self)) {\n+               (ts.tok.is_ident() || ts.tok.is_keyword(keywords::SelfValue)) {\n                 return self.make_sub_span(span, Some(ts.sp));\n             }\n "}, {"sha": "518fbcc80ee95fc8c4b248b55da91c9bc8be585e", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -38,7 +38,7 @@ pub fn expand_deriving_clone<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: Vec::new(),\n-                ret_ty: Self,\n+                ret_ty: Self_,\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(box |c, s, sub| {\n                     cs_clone(\"Clone\", c, s, sub)"}, {"sha": "ab0f64e823f9c197427ee0c27d2725da419b7551", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -76,7 +76,7 @@ fn expand_deriving_decodable_imp<F>(cx: &mut ExtCtxt,\n                 ret_ty: Literal(Path::new_(\n                     pathvec_std!(cx, core::result::Result),\n                     None,\n-                    vec!(box Self, box Literal(Path::new_(\n+                    vec!(box Self_, box Literal(Path::new_(\n                         vec![\"__D\", \"Error\"], None, vec![], false\n                     ))),\n                     true"}, {"sha": "c10975a2d32eb94e370aa0271267a472b6e5048a", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -38,7 +38,7 @@ pub fn expand_deriving_default<F>(cx: &mut ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n                 args: Vec::new(),\n-                ret_ty: Self,\n+                ret_ty: Self_,\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     default_substructure(a, b, c)"}, {"sha": "f878cb5ca8b78ff74377b6817bf6311a392b7885", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -207,7 +207,7 @@ use parse::token::InternedString;\n use parse::token::special_idents;\n use ptr::P;\n \n-use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self, Ty};\n+use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n \n pub mod ty;\n \n@@ -261,7 +261,7 @@ pub struct Substructure<'a> {\n     pub type_ident: Ident,\n     /// ident of the method\n     pub method_ident: Ident,\n-    /// dereferenced access to any `Self` or `Ptr(Self, _)` arguments\n+    /// dereferenced access to any `Self_` or `Ptr(Self_, _)` arguments\n     pub self_args: &'a [P<Expr>],\n     /// verbatim access to any other arguments\n     pub nonself_args: &'a [P<Expr>],\n@@ -679,10 +679,10 @@ impl<'a> MethodDef<'a> {\n             match *ty {\n                 // for static methods, just treat any Self\n                 // arguments as a normal arg\n-                Self if nonstatic  => {\n+                Self_ if nonstatic  => {\n                     self_args.push(arg_expr);\n                 }\n-                Ptr(box Self, _) if nonstatic => {\n+                Ptr(box Self_, _) if nonstatic => {\n                     self_args.push(cx.expr_deref(trait_.span, arg_expr))\n                 }\n                 _ => {"}, {"sha": "ec13b86a8ae2eb0fff69558347e72486d617ad62", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -87,7 +87,7 @@ impl<'a> Path<'a> {\n /// A type. Supports pointers, Self, and literals\n #[derive(Clone)]\n pub enum Ty<'a> {\n-    Self,\n+    Self_,\n     /// &/Box/ Ty\n     Ptr(Box<Ty<'a>>, PtrTy<'a>),\n     /// mod::mod::Type<[lifetime], [Params...]>, including a plain type\n@@ -109,7 +109,7 @@ pub fn borrowed_explicit_self<'r>() -> Option<Option<PtrTy<'r>>> {\n }\n \n pub fn borrowed_self<'r>() -> Ty<'r> {\n-    borrowed(box Self)\n+    borrowed(box Self_)\n }\n \n pub fn nil_ty<'r>() -> Ty<'r> {\n@@ -149,7 +149,7 @@ impl<'a> Ty<'a> {\n                 }\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n-            Self  => {\n+            Self_  => {\n                 cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n             }\n             Tuple(ref fields) => {\n@@ -168,7 +168,7 @@ impl<'a> Ty<'a> {\n                    self_generics: &Generics)\n                    -> ast::Path {\n         match *self {\n-            Self => {\n+            Self_ => {\n                 let self_params = self_generics.ty_params.map(|ty_param| {\n                     cx.ty_ident(span, ty_param.ident)\n                 });"}, {"sha": "22c87d978c9e5aa2771d3971e71b2c155693527a", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -41,7 +41,7 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 args: vec!(Literal(path!(i64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n-                                           vec!(box Self),\n+                                           vec!(box Self_),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs.clone(),\n@@ -56,7 +56,7 @@ pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n                 args: vec!(Literal(path!(u64))),\n                 ret_ty: Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n                                            None,\n-                                           vec!(box Self),\n+                                           vec!(box Self_),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs,"}, {"sha": "029b65351081967166e2793c802ce152d16c8bab", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -53,7 +53,7 @@ pub fn expand_deriving_rand<F>(cx: &mut ExtCtxt,\n                     Ptr(box Literal(Path::new_local(\"R\")),\n                         Borrowed(None, ast::MutMutable))\n                 ),\n-                ret_ty: Self,\n+                ret_ty: Self_,\n                 attributes: Vec::new(),\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     rand_substructure(a, b, c)"}, {"sha": "1a4afa4957c5a61e1322fbc253a143e19324c1af", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -1122,7 +1122,7 @@ impl<'a> StringReader<'a> {\n                 let keyword_checking_token =\n                     &token::Ident(keyword_checking_ident, token::Plain);\n                 let last_bpos = self.last_pos;\n-                if keyword_checking_token.is_keyword(token::keywords::Self) {\n+                if keyword_checking_token.is_keyword(token::keywords::SelfValue) {\n                     self.err_span_(start,\n                                    last_bpos,\n                                    \"invalid lifetime name: 'self \\"}, {"sha": "d2133f033356751b47b97d9a21fc47300a11632a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 51, "deletions": 22, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -516,13 +516,21 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn parse_ident_or_self_type(&mut self) -> ast::Ident {\n+        if self.is_self_type_ident() {\n+            self.expect_self_type_ident()\n+        } else {\n+            self.parse_ident()\n+        }\n+    }\n+\n     pub fn parse_path_list_item(&mut self) -> ast::PathListItem {\n         let lo = self.span.lo;\n         let node = if self.eat_keyword_noexpect(keywords::Mod) {\n             let span = self.last_span;\n             self.span_warn(span, \"deprecated syntax; use the `self` keyword now\");\n             ast::PathListMod { id: ast::DUMMY_NODE_ID }\n-        } else if self.eat_keyword(keywords::Self) {\n+        } else if self.eat_keyword(keywords::SelfValue) {\n             ast::PathListMod { id: ast::DUMMY_NODE_ID }\n         } else {\n             let ident = self.parse_ident();\n@@ -1797,7 +1805,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident();\n+            let identifier = self.parse_ident_or_self_type();\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt() {\n@@ -1850,7 +1858,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident();\n+            let identifier = self.parse_ident_or_self_type();\n \n             // If we do not see a `::`, stop.\n             if !self.eat(&token::ModSep) {\n@@ -1895,7 +1903,7 @@ impl<'a> Parser<'a> {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n-            let identifier = self.parse_ident();\n+            let identifier = self.parse_ident_or_self_type();\n \n             // Assemble and push the result.\n             segments.push(ast::PathSegment {\n@@ -2166,10 +2174,8 @@ impl<'a> Parser<'a> {\n             token::BinOp(token::Or) |  token::OrOr => {\n                 return self.parse_lambda_expr(CaptureByRef);\n             },\n-            // FIXME #13626: Should be able to stick in\n-            // token::SELF_KEYWORD_NAME\n             token::Ident(id @ ast::Ident {\n-                            name: ast::Name(token::SELF_KEYWORD_NAME_NUM),\n+                            name: token::SELF_KEYWORD_NAME,\n                             ctxt: _\n                          }, token::Plain) => {\n                 self.bump();\n@@ -3411,7 +3417,7 @@ impl<'a> Parser<'a> {\n               && self.token != token::ModSep)\n                 || self.token.is_keyword(keywords::True)\n                 || self.token.is_keyword(keywords::False) {\n-            // Parse an expression pattern or exp .. exp.\n+            // Parse an expression pattern or exp ... exp.\n             //\n             // These expressions are limited to literals (possibly\n             // preceded by unary-minus) or identifiers.\n@@ -3532,15 +3538,17 @@ impl<'a> Parser<'a> {\n                                   enum_path.segments.len() == 1 &&\n                                   enum_path.segments[0].parameters.is_empty()\n                               {\n-                                  // it could still be either an enum\n-                                  // or an identifier pattern, resolve\n-                                  // will sort it out:\n-                                  pat = PatIdent(BindByValue(MutImmutable),\n-                                                 codemap::Spanned{\n-                                                    span: enum_path.span,\n-                                                    node: enum_path.segments[0]\n-                                                           .identifier},\n-                                                 None);\n+                                // NB: If enum_path is a single identifier,\n+                                // this should not be reachable due to special\n+                                // handling further above.\n+                                //\n+                                // However, previously a PatIdent got emitted\n+                                // here, so we preserve the branch just in case.\n+                                //\n+                                // A rewrite of the logic in this function\n+                                // would probably make this obvious.\n+                                self.span_bug(enum_path.span,\n+                                              \"ident only path should have been covered already\");\n                               } else {\n                                   pat = PatEnum(enum_path, Some(args));\n                               }\n@@ -4380,6 +4388,27 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn is_self_type_ident(&mut self) -> bool {\n+        match self.token {\n+          token::Ident(id, token::Plain) => id.name == special_idents::type_self.name,\n+          _ => false\n+        }\n+    }\n+\n+    fn expect_self_type_ident(&mut self) -> ast::Ident {\n+        match self.token {\n+            token::Ident(id, token::Plain) if id.name == special_idents::type_self.name => {\n+                self.bump();\n+                id\n+            },\n+            _ => {\n+                let token_str = self.this_token_to_string();\n+                self.fatal(&format!(\"expected `Self`, found `{}`\",\n+                                   token_str)[])\n+            }\n+        }\n+    }\n+\n     /// Parse the argument list and result type of a function\n     /// that may have a self type.\n     fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> (ExplicitSelf, P<FnDecl>) where\n@@ -4396,22 +4425,22 @@ impl<'a> Parser<'a> {\n             //\n             // We already know that the current token is `&`.\n \n-            if this.look_ahead(1, |t| t.is_keyword(keywords::Self)) {\n+            if this.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 SelfRegion(None, MutImmutable, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| t.is_mutability()) &&\n-                      this.look_ahead(2, |t| t.is_keyword(keywords::Self)) {\n+                      this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 let mutability = this.parse_mutability();\n                 SelfRegion(None, mutability, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n-                      this.look_ahead(2, |t| t.is_keyword(keywords::Self)) {\n+                      this.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 SelfRegion(Some(lifetime), MutImmutable, this.expect_self_ident())\n             } else if this.look_ahead(1, |t| t.is_lifetime()) &&\n                       this.look_ahead(2, |t| t.is_mutability()) &&\n-                      this.look_ahead(3, |t| t.is_keyword(keywords::Self)) {\n+                      this.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n                 this.bump();\n                 let lifetime = this.parse_lifetime();\n                 let mutability = this.parse_mutability();\n@@ -4466,7 +4495,7 @@ impl<'a> Parser<'a> {\n                         SelfValue(self_ident)\n                     }\n                 } else if self.token.is_mutability() &&\n-                        self.look_ahead(1, |t| t.is_keyword(keywords::Self)) {\n+                        self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     mutbl_self = self.parse_mutability();\n                     let self_ident = self.expect_self_ident();\n "}, {"sha": "0747a97fa37cc0312e5e17f6ebc965de4fad7179", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -300,6 +300,7 @@ impl Token {\n                    n == SELF_KEYWORD_NAME\n                 || n == STATIC_KEYWORD_NAME\n                 || n == SUPER_KEYWORD_NAME\n+                || n == SELF_TYPE_KEYWORD_NAME\n                 || STRICT_KEYWORD_START <= n\n                 && n <= RESERVED_KEYWORD_FINAL\n             },\n@@ -317,6 +318,7 @@ impl Token {\n                    n == SELF_KEYWORD_NAME\n                 || n == STATIC_KEYWORD_NAME\n                 || n == SUPER_KEYWORD_NAME\n+                || n == SELF_TYPE_KEYWORD_NAME\n                 || STRICT_KEYWORD_START <= n\n                 && n <= STRICT_KEYWORD_FINAL\n             },\n@@ -488,10 +490,12 @@ macro_rules! declare_special_idents_and_keywords {(\n pub const SELF_KEYWORD_NAME: ast::Name = ast::Name(SELF_KEYWORD_NAME_NUM);\n const STATIC_KEYWORD_NAME: ast::Name = ast::Name(STATIC_KEYWORD_NAME_NUM);\n const SUPER_KEYWORD_NAME: ast::Name = ast::Name(SUPER_KEYWORD_NAME_NUM);\n+const SELF_TYPE_KEYWORD_NAME: ast::Name = ast::Name(SELF_TYPE_KEYWORD_NAME_NUM);\n \n pub const SELF_KEYWORD_NAME_NUM: u32 = 1;\n const STATIC_KEYWORD_NAME_NUM: u32 = 2;\n const SUPER_KEYWORD_NAME_NUM: u32 = 3;\n+const SELF_TYPE_KEYWORD_NAME_NUM: u32 = 10;\n \n // NB: leaving holes in the ident table is bad! a different ident will get\n // interned with the id from the hole, but it will be between the min and max\n@@ -514,7 +518,7 @@ declare_special_idents_and_keywords! {\n         (7,                          clownshoe_abi,          \"__rust_abi\");\n         (8,                          opaque,                 \"<opaque>\");\n         (9,                          unnamed_field,          \"<unnamed_field>\");\n-        (10,                         type_self,              \"Self\");\n+        (super::SELF_TYPE_KEYWORD_NAME_NUM, type_self,       \"Self\");\n         (11,                         prelude_import,         \"prelude_import\");\n     }\n \n@@ -545,7 +549,8 @@ declare_special_idents_and_keywords! {\n         (32,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n-        (super::SELF_KEYWORD_NAME_NUM,   Self,   \"self\");\n+        (super::SELF_KEYWORD_NAME_NUM, SelfValue, \"self\");\n+        (super::SELF_TYPE_KEYWORD_NAME_NUM, SelfType, \"Self\");\n         (33,                         Struct,     \"struct\");\n         (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n         (34,                         True,       \"true\");"}, {"sha": "6f5aeead57ecbff5b0a3adf153a94841b05598fc", "filename": "src/test/compile-fail/self_type_keyword.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b63cee4a11fcfecf20ed8419bc3bd6859e6496bc/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fself_type_keyword.rs?ref=b63cee4a11fcfecf20ed8419bc3bd6859e6496bc", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Self;\n+//~^ ERROR expected identifier, found keyword `Self`\n+\n+struct Bar<'Self>;\n+//~^ ERROR invalid lifetime name\n+\n+pub fn main() {\n+    let Self = 5;\n+    //~^ ERROR expected identifier, found keyword `Self`\n+\n+    match 15 {\n+        Self => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+        ref Self => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+        mut Self => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+        ref mut Self => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+        Self!() => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+        Foo { x: Self } => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+        Foo { Self } => (),\n+        //~^ ERROR expected identifier, found keyword `Self`\n+    }\n+}\n+\n+use self::Self as Foo;\n+//~^ ERROR expected identifier, found keyword `Self`\n+\n+use std::option::Option as Self;\n+//~^ ERROR expected identifier, found keyword `Self`\n+\n+extern crate Self;\n+//~^ ERROR expected identifier, found keyword `Self`\n+\n+trait Self {}\n+//~^ ERROR expected identifier, found keyword `Self`"}]}