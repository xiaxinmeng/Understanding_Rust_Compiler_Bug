{"sha": "3442d23c1a12f1f01a0e07b6bec72b58998f49ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NDJkMjNjMWExMmYxZjAxYTBlMDdiNmJlYzcyYjU4OTk4ZjQ5ZWY=", "commit": {"author": {"name": "Mohsen Zohrevandi", "email": "mohsen.zohrevandi@fortanix.com", "date": "2020-06-18T19:50:10Z"}, "committer": {"name": "Mohsen Zohrevandi", "email": "mohsen.zohrevandi@fortanix.com", "date": "2020-06-18T20:19:44Z"}, "message": "Improve wait_timeout_sgx, simplify usercalls::wait", "tree": {"sha": "c9a7736af2777f4c2d70e029c6eddbf34d675fa0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9a7736af2777f4c2d70e029c6eddbf34d675fa0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3442d23c1a12f1f01a0e07b6bec72b58998f49ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3442d23c1a12f1f01a0e07b6bec72b58998f49ef", "html_url": "https://github.com/rust-lang/rust/commit/3442d23c1a12f1f01a0e07b6bec72b58998f49ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3442d23c1a12f1f01a0e07b6bec72b58998f49ef/comments", "author": {"login": "mzohreva", "id": 1142455, "node_id": "MDQ6VXNlcjExNDI0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1142455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzohreva", "html_url": "https://github.com/mzohreva", "followers_url": "https://api.github.com/users/mzohreva/followers", "following_url": "https://api.github.com/users/mzohreva/following{/other_user}", "gists_url": "https://api.github.com/users/mzohreva/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzohreva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzohreva/subscriptions", "organizations_url": "https://api.github.com/users/mzohreva/orgs", "repos_url": "https://api.github.com/users/mzohreva/repos", "events_url": "https://api.github.com/users/mzohreva/events{/privacy}", "received_events_url": "https://api.github.com/users/mzohreva/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mzohreva", "id": 1142455, "node_id": "MDQ6VXNlcjExNDI0NTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1142455?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mzohreva", "html_url": "https://github.com/mzohreva", "followers_url": "https://api.github.com/users/mzohreva/followers", "following_url": "https://api.github.com/users/mzohreva/following{/other_user}", "gists_url": "https://api.github.com/users/mzohreva/gists{/gist_id}", "starred_url": "https://api.github.com/users/mzohreva/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mzohreva/subscriptions", "organizations_url": "https://api.github.com/users/mzohreva/orgs", "repos_url": "https://api.github.com/users/mzohreva/repos", "events_url": "https://api.github.com/users/mzohreva/events{/privacy}", "received_events_url": "https://api.github.com/users/mzohreva/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5d1fcd2309b6903fed82aba6e0fdc2fa85bc874", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d1fcd2309b6903fed82aba6e0fdc2fa85bc874", "html_url": "https://github.com/rust-lang/rust/commit/c5d1fcd2309b6903fed82aba6e0fdc2fa85bc874"}], "stats": {"total": 84, "additions": 56, "deletions": 28}, "files": [{"sha": "69ff7ebf9a19d56154c505353f420a407a2c90c0", "filename": "src/libstd/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3442d23c1a12f1f01a0e07b6bec72b58998f49ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3442d23c1a12f1f01a0e07b6bec72b58998f49ef/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=3442d23c1a12f1f01a0e07b6bec72b58998f49ef", "patch": "@@ -1,4 +1,5 @@\n use crate::cmp;\n+use crate::convert::TryFrom;\n use crate::io::{Error as IoError, IoSlice, IoSliceMut, Result as IoResult};\n use crate::sys::rand::rdrand64;\n use crate::time::Duration;\n@@ -159,17 +160,11 @@ pub fn wait(event_mask: u64, mut timeout: u64) -> IoResult<u64> {\n         // to make things work in other cases. Note that in the SGX threat\n         // model the enclave runner which is serving the wait usercall is not\n         // trusted to ensure accurate timeouts.\n-        let base = cmp::max(1, timeout / 10) * 2 + 1;\n-        let zero = base / 2;\n-        match rdrand64() % base {\n-            jitter if jitter > zero => {\n-                timeout = timeout.checked_add(jitter - zero).unwrap_or(timeout)\n-            }\n-            jitter if jitter < zero => {\n-                timeout = timeout.checked_sub(zero - jitter).unwrap_or(timeout)\n-            }\n-            _ => {}\n-        };\n+        if let Ok(timeout_signed) = i64::try_from(timeout) {\n+            let tenth = 1 + timeout_signed / 10;\n+            let deviation = (rdrand64() as i64).checked_rem(tenth).unwrap_or(0);\n+            timeout = timeout_signed.saturating_add(deviation) as _;\n+        }\n         timeout = cmp::min(u64::MAX - 1, cmp::max(1, timeout));\n     }\n     unsafe { raw::wait(event_mask, timeout).from_sgx_result() }"}, {"sha": "1c957d8ff8032ace6f7668ce0e3b0c025766faf9", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3442d23c1a12f1f01a0e07b6bec72b58998f49ef/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3442d23c1a12f1f01a0e07b6bec72b58998f49ef/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=3442d23c1a12f1f01a0e07b6bec72b58998f49ef", "patch": "@@ -110,43 +110,76 @@ pub fn decode_error_kind(code: i32) -> ErrorKind {\n     }\n }\n \n-// This function makes an effort to sleep at least as long as `duration`.\n-// Note that in general there is no guarantee about accuracy of time and\n-// timeouts in SGX model. The enclave runner serving usercalls may lie about\n-// current time and/or ignore timeout values.\n+// This function makes an effort to wait for a non-spurious event at least as\n+// long as `duration`. Note that in general there is no guarantee about accuracy\n+// of time and timeouts in SGX model. The enclave runner serving usercalls may\n+// lie about current time and/or ignore timeout values.\n //\n-// Once the event is observed, `stop` will be used to determine whether or not\n-// we should continue to wait.\n+// Once the event is observed, `woken_up` will be used to determine whether or\n+// not the event was spurious.\n //\n // FIXME: note these caveats in documentation of all public types that use this\n // function in their execution path.\n-pub fn wait_timeout_sgx<F>(event_mask: u64, duration: crate::time::Duration, stop: F)\n+pub fn wait_timeout_sgx<F>(event_mask: u64, duration: crate::time::Duration, woken_up: F)\n where\n     F: Fn() -> bool,\n {\n     use self::abi::usercalls;\n     use crate::cmp;\n     use crate::io::ErrorKind;\n-    use crate::time::Instant;\n-\n-    let start = Instant::now();\n-    let mut remaining = duration;\n-    loop {\n-        let timeout = cmp::min((u64::MAX - 1) as u128, remaining.as_nanos()) as u64;\n+    use crate::time::{Duration, Instant};\n+\n+    // Calls the wait usercall and checks the result. Returns true if event was\n+    // returned, and false if WouldBlock/TimedOut was returned.\n+    // If duration is None, it will use WAIT_NO.\n+    fn wait_checked(event_mask: u64, duration: Option<Duration>) -> bool {\n+        let timeout = duration.map_or(usercalls::raw::WAIT_NO, |duration| {\n+            cmp::min((u64::MAX - 1) as u128, duration.as_nanos()) as u64\n+        });\n         match usercalls::wait(event_mask, timeout) {\n             Ok(eventset) => {\n                 if event_mask == 0 {\n                     rtabort!(\"expected usercalls::wait() to return Err, found Ok.\");\n                 }\n                 rtassert!(eventset & event_mask == event_mask);\n-                if stop() {\n-                    return;\n-                }\n+                true\n             }\n             Err(e) => {\n-                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock)\n+                rtassert!(e.kind() == ErrorKind::TimedOut || e.kind() == ErrorKind::WouldBlock);\n+                false\n             }\n         }\n+    }\n+\n+    match wait_checked(event_mask, Some(duration)) {\n+        false => return,              // timed out\n+        true if woken_up() => return, // woken up\n+        true => {}                    // spurious event\n+    }\n+\n+    // Drain all cached events.\n+    // Note that `event_mask != 0` is implied if we get here.\n+    loop {\n+        match wait_checked(event_mask, None) {\n+            false => break,               // no more cached events\n+            true if woken_up() => return, // woken up\n+            true => {}                    // spurious event\n+        }\n+    }\n+\n+    // Continue waiting, but take note of time spent waiting so we don't wait\n+    // forever. We intentionally don't call `Instant::now()` before this point\n+    // to avoid the cost of the `insecure_time` usercall in case there are no\n+    // spurious wakeups.\n+\n+    let start = Instant::now();\n+    let mut remaining = duration;\n+    loop {\n+        match wait_checked(event_mask, Some(remaining)) {\n+            false => return,              // timed out\n+            true if woken_up() => return, // woken up\n+            true => {}                    // spurious event\n+        }\n         remaining = match duration.checked_sub(start.elapsed()) {\n             Some(remaining) => remaining,\n             None => break,"}]}