{"sha": "2247cd664368acc07529a498388ab78eed93c431", "node_id": "C_kwDOAAsO6NoAKDIyNDdjZDY2NDM2OGFjYzA3NTI5YTQ5ODM4OGFiNzhlZWQ5M2M0MzE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-07T14:41:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-03-08T14:40:37Z"}, "message": "Simplify visit_statement.", "tree": {"sha": "1786a77f7a528deab0807e4cda30669dfa828915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1786a77f7a528deab0807e4cda30669dfa828915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2247cd664368acc07529a498388ab78eed93c431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2247cd664368acc07529a498388ab78eed93c431", "html_url": "https://github.com/rust-lang/rust/commit/2247cd664368acc07529a498388ab78eed93c431", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2247cd664368acc07529a498388ab78eed93c431/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a56933e8cace1e2169a0ab60854ed41e12f81e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a56933e8cace1e2169a0ab60854ed41e12f81e1", "html_url": "https://github.com/rust-lang/rust/commit/9a56933e8cace1e2169a0ab60854ed41e12f81e1"}], "stats": {"total": 126, "additions": 61, "deletions": 65}, "files": [{"sha": "9a3ccc2f7e4d06d82c91b79ce02c86ca259dabce", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2247cd664368acc07529a498388ab78eed93c431/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2247cd664368acc07529a498388ab78eed93c431/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=2247cd664368acc07529a498388ab78eed93c431", "patch": "@@ -961,13 +961,14 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     }\n                 }\n             }\n-            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+            StatementKind::StorageLive(local) => {\n                 let frame = self.ecx.frame_mut();\n-                frame.locals[local].value = if let StatementKind::StorageLive(_) = statement.kind {\n-                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-                } else {\n-                    LocalValue::Dead\n-                };\n+                frame.locals[local].value =\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+            }\n+            StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = LocalValue::Dead;\n             }\n             _ => {}\n         }"}, {"sha": "030d79ac22dec4749489184d36262fda02a8a4d4", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 54, "deletions": 59, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2247cd664368acc07529a498388ab78eed93c431/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2247cd664368acc07529a498388ab78eed93c431/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=2247cd664368acc07529a498388ab78eed93c431", "patch": "@@ -522,75 +522,70 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (place, ref rval)) = statement.kind {\n-            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-            if let Some(()) = self.const_prop(rval, source_info, place) {\n-                match can_const_prop {\n-                    ConstPropMode::OnlyInsideOwnBlock => {\n-                        trace!(\n-                            \"found local restricted to its block. \\\n+        match statement.kind {\n+            StatementKind::Assign(box (place, ref rval)) => {\n+                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n+                if let Some(()) = self.const_prop(rval, source_info, place) {\n+                    match can_const_prop {\n+                        ConstPropMode::OnlyInsideOwnBlock => {\n+                            trace!(\n+                                \"found local restricted to its block. \\\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n-                            place.local\n-                        );\n-                    }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        trace!(\"can't propagate into {:?}\", place);\n-                        if place.local != RETURN_PLACE {\n-                            Self::remove_const(&mut self.ecx, place.local);\n+                                place.local\n+                            );\n                         }\n-                    }\n-                    ConstPropMode::FullConstProp => {}\n-                }\n-            } else {\n-                // Const prop failed, so erase the destination, ensuring that whatever happens\n-                // from here on, does not know about the previous value.\n-                // This is important in case we have\n-                // ```rust\n-                // let mut x = 42;\n-                // x = SOME_MUTABLE_STATIC;\n-                // // x must now be uninit\n-                // ```\n-                // FIXME: we overzealously erase the entire local, because that's easier to\n-                // implement.\n-                trace!(\n-                    \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                    place,\n-                );\n-                Self::remove_const(&mut self.ecx, place.local);\n-            }\n-        } else {\n-            match statement.kind {\n-                StatementKind::SetDiscriminant { ref place, .. } => {\n-                    match self.ecx.machine.can_const_prop[place.local] {\n-                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                            if self\n-                                .use_ecx(source_info, |this| this.ecx.statement(statement))\n-                                .is_some()\n-                            {\n-                                trace!(\"propped discriminant into {:?}\", place);\n-                            } else {\n+                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                            trace!(\"can't propagate into {:?}\", place);\n+                            if place.local != RETURN_PLACE {\n                                 Self::remove_const(&mut self.ecx, place.local);\n                             }\n                         }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            Self::remove_const(&mut self.ecx, place.local);\n-                        }\n+                        ConstPropMode::FullConstProp => {}\n                     }\n+                } else {\n+                    // Const prop failed, so erase the destination, ensuring that whatever happens\n+                    // from here on, does not know about the previous value.\n+                    // This is important in case we have\n+                    // ```rust\n+                    // let mut x = 42;\n+                    // x = SOME_MUTABLE_STATIC;\n+                    // // x must now be uninit\n+                    // ```\n+                    // FIXME: we overzealously erase the entire local, because that's easier to\n+                    // implement.\n+                    trace!(\n+                        \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                        place,\n+                    );\n+                    Self::remove_const(&mut self.ecx, place.local);\n                 }\n-                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n-                    let frame = self.ecx.frame_mut();\n-                    frame.locals[local].value =\n-                        if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Live(interpret::Operand::Immediate(\n-                                interpret::Immediate::Uninit,\n-                            ))\n+            }\n+            StatementKind::SetDiscriminant { ref place, .. } => {\n+                match self.ecx.machine.can_const_prop[place.local] {\n+                    ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                        if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n+                        {\n+                            trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n-                            LocalValue::Dead\n-                        };\n+                            Self::remove_const(&mut self.ecx, place.local);\n+                        }\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        Self::remove_const(&mut self.ecx, place.local);\n+                    }\n                 }\n-                _ => {}\n             }\n+            StatementKind::StorageLive(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value =\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+            }\n+            StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = LocalValue::Dead;\n+            }\n+            _ => {}\n         }\n \n         self.super_statement(statement, location);"}]}