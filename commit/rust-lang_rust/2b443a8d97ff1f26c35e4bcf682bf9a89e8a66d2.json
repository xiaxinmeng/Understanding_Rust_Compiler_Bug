{"sha": "2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "node_id": "C_kwDOAAsO6NoAKDJiNDQzYThkOTdmZjFmMjZjMzVlNGJjZjY4MmJmOWE4OWU4YTY2ZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-26T21:50:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-26T21:50:09Z"}, "message": "Auto merge of #100043 - RalfJung:scalar-always-init, r=RalfJung\n\ninterpret: remove support for uninitialized scalars\n\nWith Miri no longer supporting `-Zmiri-allow-uninit-numbers`, we no longer need to support storing uninit data in a `Scalar`. We anyway already only use this representation for types with *initialized* `Scalar` layout (and we have to, due to partial initialization), so let's get rid of the `ScalarMaybeUninit` type entirely.\n\nI tried to stage this into meaningful commits, but the one that changes `read_immediate` to always trigger UB on uninit is the largest chunk of the PR and I don't see how it could be subdivided.\n\nFixes https://github.com/rust-lang/miri/issues/2187\nr? `@oli-obk`", "tree": {"sha": "f8fda39334d16175c69f121ad282df2f9d92e9fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8fda39334d16175c69f121ad282df2f9d92e9fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "html_url": "https://github.com/rust-lang/rust/commit/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c07a8b4e09f356c7468b69c50cac7fc5b5000b8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c07a8b4e09f356c7468b69c50cac7fc5b5000b8a", "html_url": "https://github.com/rust-lang/rust/commit/c07a8b4e09f356c7468b69c50cac7fc5b5000b8a"}, {"sha": "62b6a8b7b84ebaa375bd2b3a2f1df75b640be0ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/62b6a8b7b84ebaa375bd2b3a2f1df75b640be0ab", "html_url": "https://github.com/rust-lang/rust/commit/62b6a8b7b84ebaa375bd2b3a2f1df75b640be0ab"}], "stats": {"total": 1441, "additions": 506, "deletions": 935}, "files": [{"sha": "e13ad1c95bd04fb65602132fe7b1dcba9f28f7cd", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -3,7 +3,7 @@ use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n     Immediate, InternKind, InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RefTracking,\n-    ScalarMaybeUninit, StackPopCleanup,\n+    StackPopCleanup,\n };\n \n use rustc_hir::def::DefKind;\n@@ -170,10 +170,7 @@ pub(super) fn op_to_const<'tcx>(\n         // see comment on `let try_as_immediate` above\n         Err(imm) => match *imm {\n             _ if imm.layout.is_zst() => ConstValue::ZeroSized,\n-            Immediate::Scalar(x) => match x {\n-                ScalarMaybeUninit::Scalar(s) => ConstValue::Scalar(s),\n-                ScalarMaybeUninit::Uninit => to_const_value(&op.assert_mem_place()),\n-            },\n+            Immediate::Scalar(x) => ConstValue::Scalar(x),\n             Immediate::ScalarPair(a, b) => {\n                 debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`."}, {"sha": "2a460c74b3d82d3644a313daea2a1b2906256dce", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -347,8 +347,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         };\n         match intrinsic_name {\n             sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                let a = ecx.read_immediate(&args[0])?.to_scalar()?;\n-                let b = ecx.read_immediate(&args[1])?.to_scalar()?;\n+                let a = ecx.read_scalar(&args[0])?;\n+                let b = ecx.read_scalar(&args[1])?;\n                 let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n                     ecx.guaranteed_eq(a, b)?\n                 } else {"}, {"sha": "373b139c86e424d941b779aaddbe7e5912db6301", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -3,7 +3,7 @@ use super::machine::CompileTimeEvalContext;\n use super::{ValTreeCreationError, ValTreeCreationResult, VALTREE_MAX_NODES};\n use crate::interpret::{\n     intern_const_alloc_recursive, ConstValue, ImmTy, Immediate, InternKind, MemPlaceMeta,\n-    MemoryKind, PlaceTy, Scalar, ScalarMaybeUninit,\n+    MemoryKind, PlaceTy, Scalar,\n };\n use crate::interpret::{MPlaceTy, Value};\n use rustc_middle::ty::{self, ScalarInt, Ty, TyCtxt};\n@@ -90,7 +90,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n             let Ok(val) = ecx.read_immediate(&place.into()) else {\n                 return Err(ValTreeCreationError::Other);\n             };\n-            let val = val.to_scalar().unwrap();\n+            let val = val.to_scalar();\n             *num_nodes += 1;\n \n             Ok(ty::ValTree::Leaf(val.assert_int()))\n@@ -349,11 +349,7 @@ fn valtree_into_mplace<'tcx>(\n         ty::Bool | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Char => {\n             let scalar_int = valtree.unwrap_leaf();\n             debug!(\"writing trivial valtree {:?} to place {:?}\", scalar_int, place);\n-            ecx.write_immediate(\n-                Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar_int.into())),\n-                &place.into(),\n-            )\n-            .unwrap();\n+            ecx.write_immediate(Immediate::Scalar(scalar_int.into()), &place.into()).unwrap();\n         }\n         ty::Ref(_, inner_ty, _) => {\n             let mut pointee_place = create_pointee_place(ecx, *inner_ty, valtree);\n@@ -366,11 +362,10 @@ fn valtree_into_mplace<'tcx>(\n             let imm = match inner_ty.kind() {\n                 ty::Slice(_) | ty::Str => {\n                     let len = valtree.unwrap_branch().len();\n-                    let len_scalar =\n-                        ScalarMaybeUninit::Scalar(Scalar::from_machine_usize(len as u64, &tcx));\n+                    let len_scalar = Scalar::from_machine_usize(len as u64, &tcx);\n \n                     Immediate::ScalarPair(\n-                        ScalarMaybeUninit::from_maybe_pointer((*pointee_place).ptr, &tcx),\n+                        Scalar::from_maybe_pointer((*pointee_place).ptr, &tcx),\n                         len_scalar,\n                     )\n                 }"}, {"sha": "07dbd80e077f939bfd7ee0b9d06f3e8b6ab0a709", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -123,10 +123,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match src.layout.ty.kind() {\n             // Floating point\n             Float(FloatTy::F32) => {\n-                return Ok(self.cast_from_float(src.to_scalar()?.to_f32()?, cast_ty).into());\n+                return Ok(self.cast_from_float(src.to_scalar().to_f32()?, cast_ty).into());\n             }\n             Float(FloatTy::F64) => {\n-                return Ok(self.cast_from_float(src.to_scalar()?.to_f64()?, cast_ty).into());\n+                return Ok(self.cast_from_float(src.to_scalar().to_f64()?, cast_ty).into());\n             }\n             // The rest is integer/pointer-\"like\", including fn ptr casts\n             _ => assert!(\n@@ -153,7 +153,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(dest_layout.size, self.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n                 return match **src {\n-                    Immediate::ScalarPair(data, _) => Ok(data.check_init()?.into()),\n+                    Immediate::ScalarPair(data, _) => Ok(data.into()),\n                     Immediate::Scalar(..) => span_bug!(\n                         self.cur_span(),\n                         \"{:?} input to a fat-to-thin cast ({:?} -> {:?})\",\n@@ -167,7 +167,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         // # The remaining source values are scalar and \"int-like\".\n-        let scalar = src.to_scalar()?;\n+        let scalar = src.to_scalar();\n         Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n@@ -179,7 +179,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_matches!(src.layout.ty.kind(), ty::RawPtr(_) | ty::FnPtr(_));\n         assert!(cast_ty.is_integral());\n \n-        let scalar = src.to_scalar()?;\n+        let scalar = src.to_scalar();\n         let ptr = scalar.to_pointer(self)?;\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => M::expose_ptr(self, ptr)?,\n@@ -197,7 +197,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_matches!(cast_ty.kind(), ty::RawPtr(_));\n \n         // First cast to usize.\n-        let scalar = src.to_scalar()?;\n+        let scalar = src.to_scalar();\n         let addr = self.cast_from_int_like(scalar, src.layout, self.tcx.types.usize)?;\n         let addr = addr.to_machine_usize(self)?;\n \n@@ -291,7 +291,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         match (&src_pointee_ty.kind(), &dest_pointee_ty.kind()) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n-                let ptr = self.read_immediate(src)?.to_scalar()?;\n+                let ptr = self.read_scalar(src)?;\n                 // u64 cast is from usize to u64, which is always good\n                 let val =\n                     Immediate::new_slice(ptr, length.eval_usize(*self.tcx, self.param_env), self);\n@@ -303,7 +303,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // A NOP cast that doesn't actually change anything, should be allowed even with mismatching vtables.\n                     return self.write_immediate(*val, dest);\n                 }\n-                let (old_data, old_vptr) = val.to_scalar_pair()?;\n+                let (old_data, old_vptr) = val.to_scalar_pair();\n                 let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n@@ -315,7 +315,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable_ptr(src_pointee_ty, data.principal())?;\n-                let ptr = self.read_immediate(src)?.to_scalar()?;\n+                let ptr = self.read_scalar(src)?;\n                 let val = Immediate::new_dyn_trait(ptr, vtable, &*self.tcx);\n                 self.write_immediate(val, dest)\n             }"}, {"sha": "92596d059cd494cae86023d168ad2a31781f93ac", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -21,7 +21,7 @@ use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayou\n use super::{\n     AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n     MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n-    Scalar, ScalarMaybeUninit, StackPopJump,\n+    Scalar, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -991,16 +991,16 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(fmt, \" {:?}\", val)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val {\n+                        if let Scalar::Ptr(ptr, _size) = val {\n                             allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val1 {\n+                        if let Scalar::Ptr(ptr, _size) = val1 {\n                             allocs.push(ptr.provenance.get_alloc_id());\n                         }\n-                        if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _size)) = val2 {\n+                        if let Scalar::Ptr(ptr, _size) = val2 {\n                             allocs.push(ptr.provenance.get_alloc_id());\n                         }\n                     }"}, {"sha": "6f3bd3bf4c52be06bd7455d9f10e119aada6695c", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -184,7 +184,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let val = self.read_scalar(&args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?;\n                 let bits = val.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(scalar) => scalar.primitive(),\n@@ -256,7 +256,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (val, overflowed, _ty) = self.overflowing_binary_op(bin_op, &l, &r)?;\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n-                    let r_val = r.to_scalar()?.to_bits(layout.size)?;\n+                    let r_val = r.to_scalar().to_bits(layout.size)?;\n                     if let sym::unchecked_shl | sym::unchecked_shr = intrinsic_name {\n                         throw_ub_format!(\"overflowing shift by {} in `{}`\", r_val, intrinsic_name);\n                     } else {\n@@ -269,9 +269,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val = self.read_scalar(&args[0])?.check_init()?;\n+                let val = self.read_scalar(&args[0])?;\n                 let val_bits = val.to_bits(layout.size)?;\n-                let raw_shift = self.read_scalar(&args[1])?.check_init()?;\n+                let raw_shift = self.read_scalar(&args[1])?;\n                 let raw_shift_bits = raw_shift.to_bits(layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n@@ -507,7 +507,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(&args[0], dest, /*allow_transmute*/ false)?;\n             }\n             sym::assume => {\n-                let cond = self.read_scalar(&args[0])?.check_init()?.to_bool()?;\n+                let cond = self.read_scalar(&args[0])?.to_bool()?;\n                 if !cond {\n                     throw_ub_format!(\"`assume` intrinsic called with `false`\");\n                 }\n@@ -570,7 +570,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // term since the sign of the second term can be inferred from this and\n                 // the fact that the operation has overflowed (if either is 0 no\n                 // overflow can occur)\n-                let first_term: u128 = l.to_scalar()?.to_bits(l.layout.size)?;\n+                let first_term: u128 = l.to_scalar().to_bits(l.layout.size)?;\n                 let first_term_positive = first_term & (1 << (num_bits - 1)) == 0;\n                 if first_term_positive {\n                     // Negative overflow not possible since the positive first term"}, {"sha": "6bed8a7a00773a2e35f2b6d2fef28c2834785f2b", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -123,18 +123,15 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether memory accesses should be alignment-checked.\n     fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether, when checking alignment, we should `force_int` and thus support\n+    /// Whether, when checking alignment, we should look at the actual address and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n     ///\n-    /// Requires Provenance::OFFSET_IS_ADDR to be true.\n-    fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    /// If this returns true, Provenance::OFFSET_IS_ADDR must be true.\n+    fn use_addr_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether to enforce integers and floats being initialized.\n-    fn enforce_number_init(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n-\n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         true\n@@ -437,16 +434,11 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type FrameExtra = ();\n \n     #[inline(always)]\n-    fn force_int_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        // We do not support `force_int`.\n+    fn use_addr_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n+        // We do not support `use_addr`.\n         false\n     }\n \n-    #[inline(always)]\n-    fn enforce_number_init(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n-    }\n-\n     #[inline(always)]\n     fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         true"}, {"sha": "c4e9377029294958d6579367861fbc9e316fc737", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -21,7 +21,6 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n use super::{\n     alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n-    ScalarMaybeUninit,\n };\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -445,8 +444,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n-                    if M::force_int_for_alignment_check(self) {\n-                        // `force_int_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n+                    if M::use_addr_for_alignment_check(self) {\n+                        // `use_addr_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n                         check_offset_align(ptr.addr().bytes(), align)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n@@ -901,11 +900,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n /// Reading and writing.\n impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn write_scalar(\n-        &mut self,\n-        range: AllocRange,\n-        val: ScalarMaybeUninit<Prov>,\n-    ) -> InterpResult<'tcx> {\n+    pub fn write_scalar(&mut self, range: AllocRange, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         let range = self.range.subrange(range);\n         debug!(\"write_scalar at {:?}{range:?}: {val:?}\", self.alloc_id);\n         Ok(self\n@@ -915,11 +910,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRefMut<'a, 'tcx, Prov, Extra> {\n     }\n \n     /// `offset` is relative to this allocation reference, not the base of the allocation.\n-    pub fn write_ptr_sized(\n-        &mut self,\n-        offset: Size,\n-        val: ScalarMaybeUninit<Prov>,\n-    ) -> InterpResult<'tcx> {\n+    pub fn write_ptr_sized(&mut self, offset: Size, val: Scalar<Prov>) -> InterpResult<'tcx> {\n         self.write_scalar(alloc_range(offset, self.tcx.data_layout().pointer_size), val)\n     }\n \n@@ -938,7 +929,7 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n         &self,\n         range: AllocRange,\n         read_provenance: bool,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n+    ) -> InterpResult<'tcx, Scalar<Prov>> {\n         let range = self.range.subrange(range);\n         let res = self\n             .alloc\n@@ -949,28 +940,23 @@ impl<'tcx, 'a, Prov: Provenance, Extra> AllocRef<'a, 'tcx, Prov, Extra> {\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n+    pub fn read_integer(&self, range: AllocRange) -> InterpResult<'tcx, Scalar<Prov>> {\n         self.read_scalar(range, /*read_provenance*/ false)\n     }\n \n     /// `offset` is relative to this allocation reference, not the base of the allocation.\n-    pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, ScalarMaybeUninit<Prov>> {\n+    pub fn read_pointer(&self, offset: Size) -> InterpResult<'tcx, Scalar<Prov>> {\n         self.read_scalar(\n             alloc_range(offset, self.tcx.data_layout().pointer_size),\n             /*read_provenance*/ true,\n         )\n     }\n \n     /// `range` is relative to this allocation reference, not the base of the allocation.\n-    pub fn check_bytes(\n-        &self,\n-        range: AllocRange,\n-        allow_uninit: bool,\n-        allow_ptr: bool,\n-    ) -> InterpResult<'tcx> {\n+    pub fn check_bytes(&self, range: AllocRange) -> InterpResult<'tcx> {\n         Ok(self\n             .alloc\n-            .check_bytes(&self.tcx, self.range.subrange(range), allow_uninit, allow_ptr)\n+            .check_bytes(&self.tcx, self.range.subrange(range))\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n "}, {"sha": "e80a82acd585b1780732350d06c7bfc09310f5c5", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 71, "deletions": 106, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,11 +1,9 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n-use std::fmt::Write;\n-\n use rustc_hir::def::Namespace;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n-use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n+use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n use rustc_middle::ty::{ConstInt, DelaySpanBugEmitted, Ty};\n use rustc_middle::{mir, ty};\n use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding};\n@@ -14,7 +12,7 @@ use rustc_target::abi::{VariantIdx, Variants};\n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Place, PlaceTy, Pointer,\n-    Provenance, Scalar, ScalarMaybeUninit,\n+    Provenance, Scalar,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -27,37 +25,28 @@ use super::{\n #[derive(Copy, Clone, Debug)]\n pub enum Immediate<Prov: Provenance = AllocId> {\n     /// A single scalar value (must have *initialized* `Scalar` ABI).\n-    /// FIXME: we also currently often use this for ZST.\n-    /// `ScalarMaybeUninit` should reject ZST, and we should use `Uninit` for them instead.\n-    Scalar(ScalarMaybeUninit<Prov>),\n+    Scalar(Scalar<Prov>),\n     /// A pair of two scalar value (must have `ScalarPair` ABI where both fields are\n     /// `Scalar::Initialized`).\n-    ScalarPair(ScalarMaybeUninit<Prov>, ScalarMaybeUninit<Prov>),\n+    ScalarPair(Scalar<Prov>, Scalar<Prov>),\n     /// A value of fully uninitialized memory. Can have and size and layout.\n     Uninit,\n }\n \n-impl<Prov: Provenance> From<ScalarMaybeUninit<Prov>> for Immediate<Prov> {\n-    #[inline(always)]\n-    fn from(val: ScalarMaybeUninit<Prov>) -> Self {\n-        Immediate::Scalar(val)\n-    }\n-}\n-\n impl<Prov: Provenance> From<Scalar<Prov>> for Immediate<Prov> {\n     #[inline(always)]\n     fn from(val: Scalar<Prov>) -> Self {\n         Immediate::Scalar(val.into())\n     }\n }\n \n-impl<'tcx, Prov: Provenance> Immediate<Prov> {\n+impl<Prov: Provenance> Immediate<Prov> {\n     pub fn from_pointer(p: Pointer<Prov>, cx: &impl HasDataLayout) -> Self {\n-        Immediate::Scalar(ScalarMaybeUninit::from_pointer(p, cx))\n+        Immediate::Scalar(Scalar::from_pointer(p, cx))\n     }\n \n     pub fn from_maybe_pointer(p: Pointer<Option<Prov>>, cx: &impl HasDataLayout) -> Self {\n-        Immediate::Scalar(ScalarMaybeUninit::from_maybe_pointer(p, cx))\n+        Immediate::Scalar(Scalar::from_maybe_pointer(p, cx))\n     }\n \n     pub fn new_slice(val: Scalar<Prov>, len: u64, cx: &impl HasDataLayout) -> Self {\n@@ -69,41 +58,28 @@ impl<'tcx, Prov: Provenance> Immediate<Prov> {\n         vtable: Pointer<Option<Prov>>,\n         cx: &impl HasDataLayout,\n     ) -> Self {\n-        Immediate::ScalarPair(val.into(), ScalarMaybeUninit::from_maybe_pointer(vtable, cx))\n+        Immediate::ScalarPair(val.into(), Scalar::from_maybe_pointer(vtable, cx))\n     }\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Prov> {\n+    pub fn to_scalar(self) -> Scalar<Prov> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a scalar pair where a scalar was expected\"),\n-            Immediate::Uninit => ScalarMaybeUninit::Uninit,\n+            Immediate::Uninit => bug!(\"Got uninit where a scalar was expected\"),\n         }\n     }\n \n     #[inline]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Prov>> {\n-        self.to_scalar_or_uninit().check_init()\n-    }\n-\n-    #[inline]\n-    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_or_uninit_pair(self) -> (ScalarMaybeUninit<Prov>, ScalarMaybeUninit<Prov>) {\n+    pub fn to_scalar_pair(self) -> (Scalar<Prov>, Scalar<Prov>) {\n         match self {\n             Immediate::ScalarPair(val1, val2) => (val1, val2),\n             Immediate::Scalar(..) => bug!(\"Got a scalar where a scalar pair was expected\"),\n-            Immediate::Uninit => (ScalarMaybeUninit::Uninit, ScalarMaybeUninit::Uninit),\n+            Immediate::Uninit => bug!(\"Got uninit where a scalar pair was expected\"),\n         }\n     }\n-\n-    #[inline]\n-    #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Prov>, Scalar<Prov>)> {\n-        let (val1, val2) = self.to_scalar_or_uninit_pair();\n-        Ok((val1.check_init()?, val2.check_init()?))\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n@@ -119,27 +95,17 @@ impl<Prov: Provenance> std::fmt::Display for ImmTy<'_, Prov> {\n         /// Helper function for printing a scalar to a FmtPrinter\n         fn p<'a, 'tcx, Prov: Provenance>(\n             cx: FmtPrinter<'a, 'tcx>,\n-            s: ScalarMaybeUninit<Prov>,\n+            s: Scalar<Prov>,\n             ty: Ty<'tcx>,\n         ) -> Result<FmtPrinter<'a, 'tcx>, std::fmt::Error> {\n             match s {\n-                ScalarMaybeUninit::Scalar(Scalar::Int(int)) => {\n-                    cx.pretty_print_const_scalar_int(int, ty, true)\n-                }\n-                ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr, _sz)) => {\n+                Scalar::Int(int) => cx.pretty_print_const_scalar_int(int, ty, true),\n+                Scalar::Ptr(ptr, _sz) => {\n                     // Just print the ptr value. `pretty_print_const_scalar_ptr` would also try to\n                     // print what is points to, which would fail since it has no access to the local\n                     // memory.\n                     cx.pretty_print_const_pointer(ptr, ty, true)\n                 }\n-                ScalarMaybeUninit::Uninit => cx.typed_value(\n-                    |mut this| {\n-                        this.write_str(\"uninit \")?;\n-                        Ok(this)\n-                    },\n-                    |this| this.print_type(ty),\n-                    \" \",\n-                ),\n             }\n         }\n         ty::tls::with(|tcx| {\n@@ -269,7 +235,7 @@ impl<'tcx, Prov: Provenance> ImmTy<'tcx, Prov> {\n     #[inline]\n     pub fn to_const_int(self) -> ConstInt {\n         assert!(self.layout.ty.is_integral());\n-        let int = self.to_scalar().expect(\"to_const_int doesn't work on scalar pairs\").assert_int();\n+        let int = self.to_scalar().assert_int();\n         ConstInt::new(int, self.layout.ty.is_signed(), self.layout.ty.is_ptr_sized_integral())\n     }\n }\n@@ -327,7 +293,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn read_immediate_from_mplace_raw(\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n-        force: bool,\n     ) -> InterpResult<'tcx, Option<ImmTy<'tcx, M::Provenance>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n@@ -345,47 +310,44 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // case where some of the bytes are initialized and others are not. So, we need an extra\n         // check that walks over the type of `mplace` to make sure it is truly correct to treat this\n         // like a `Scalar` (or `ScalarPair`).\n-        let scalar_layout = match mplace.layout.abi {\n-            // `if` does not work nested inside patterns, making this a bit awkward to express.\n-            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => Some(s),\n-            Abi::Scalar(s) if force => Some(s.primitive()),\n-            _ => None,\n-        };\n-        if let Some(s) = scalar_layout {\n-            let size = s.size(self);\n-            assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n-            let scalar = alloc\n-                .read_scalar(alloc_range(Size::ZERO, size), /*read_provenance*/ s.is_ptr())?;\n-            return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n-        }\n-        let scalar_pair_layout = match mplace.layout.abi {\n+        Ok(match mplace.layout.abi {\n+            Abi::Scalar(abi::Scalar::Initialized { value: s, .. }) => {\n+                let size = s.size(self);\n+                assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n+                let scalar = alloc.read_scalar(\n+                    alloc_range(Size::ZERO, size),\n+                    /*read_provenance*/ s.is_ptr(),\n+                )?;\n+                Some(ImmTy { imm: scalar.into(), layout: mplace.layout })\n+            }\n             Abi::ScalarPair(\n                 abi::Scalar::Initialized { value: a, .. },\n                 abi::Scalar::Initialized { value: b, .. },\n-            ) => Some((a, b)),\n-            Abi::ScalarPair(a, b) if force => Some((a.primitive(), b.primitive())),\n-            _ => None,\n-        };\n-        if let Some((a, b)) = scalar_pair_layout {\n-            // We checked `ptr_align` above, so all fields will have the alignment they need.\n-            // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n-            // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n-            let (a_size, b_size) = (a.size(self), b.size(self));\n-            let b_offset = a_size.align_to(b.align(self).abi);\n-            assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n-            let a_val = alloc.read_scalar(\n-                alloc_range(Size::ZERO, a_size),\n-                /*read_provenance*/ a.is_ptr(),\n-            )?;\n-            let b_val = alloc\n-                .read_scalar(alloc_range(b_offset, b_size), /*read_provenance*/ b.is_ptr())?;\n-            return Ok(Some(ImmTy {\n-                imm: Immediate::ScalarPair(a_val, b_val),\n-                layout: mplace.layout,\n-            }));\n-        }\n-        // Neither a scalar nor scalar pair.\n-        return Ok(None);\n+            ) => {\n+                // We checked `ptr_align` above, so all fields will have the alignment they need.\n+                // We would anyway check against `ptr_align.restrict_for_offset(b_offset)`,\n+                // which `ptr.offset(b_offset)` cannot possibly fail to satisfy.\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n+                let b_offset = a_size.align_to(b.align(self).abi);\n+                assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n+                let a_val = alloc.read_scalar(\n+                    alloc_range(Size::ZERO, a_size),\n+                    /*read_provenance*/ a.is_ptr(),\n+                )?;\n+                let b_val = alloc.read_scalar(\n+                    alloc_range(b_offset, b_size),\n+                    /*read_provenance*/ b.is_ptr(),\n+                )?;\n+                Some(ImmTy {\n+                    imm: Immediate::ScalarPair(a_val.into(), b_val.into()),\n+                    layout: mplace.layout,\n+                })\n+            }\n+            _ => {\n+                // Neither a scalar nor scalar pair.\n+                None\n+            }\n+        })\n     }\n \n     /// Try returning an immediate for the operand. If the layout does not permit loading this as an\n@@ -394,20 +356,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n     ///\n-    /// If `force` is `true`, then even scalars with fields that can be ununit will be\n-    /// read. This means the load is lossy and should not be written back!\n-    /// This flag exists only for validity checking.\n-    ///\n     /// This is an internal function that should not usually be used; call `read_immediate` instead.\n     /// ConstProp needs it, though.\n     pub fn read_immediate_raw(\n         &self,\n         src: &OpTy<'tcx, M::Provenance>,\n-        force: bool,\n     ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::Provenance>, MPlaceTy<'tcx, M::Provenance>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(ref mplace) => {\n-                if let Some(val) = self.read_immediate_from_mplace_raw(mplace, force)? {\n+                if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? {\n                     Ok(val)\n                 } else {\n                     Err(*mplace)\n@@ -418,24 +375,33 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     /// Read an immediate from a place, asserting that that is possible with the given layout.\n+    ///\n+    /// If this suceeds, the `ImmTy` is never `Uninit`.\n     #[inline(always)]\n     pub fn read_immediate(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n-        if let Ok(imm) = self.read_immediate_raw(op, /*force*/ false)? {\n-            Ok(imm)\n-        } else {\n-            span_bug!(self.cur_span(), \"primitive read failed for type: {:?}\", op.layout.ty);\n+        if !matches!(\n+            op.layout.abi,\n+            Abi::Scalar(abi::Scalar::Initialized { .. })\n+                | Abi::ScalarPair(abi::Scalar::Initialized { .. }, abi::Scalar::Initialized { .. })\n+        ) {\n+            span_bug!(self.cur_span(), \"primitive read not possible for type: {:?}\", op.layout.ty);\n+        }\n+        let imm = self.read_immediate_raw(op)?.unwrap();\n+        if matches!(*imm, Immediate::Uninit) {\n+            throw_ub!(InvalidUninitBytes(None));\n         }\n+        Ok(imm)\n     }\n \n     /// Read a scalar from a place\n     pub fn read_scalar(\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::Provenance>> {\n-        Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n+        Ok(self.read_immediate(op)?.to_scalar())\n     }\n \n     /// Read a pointer from a place.\n@@ -727,7 +693,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Figure out which discriminant and variant this corresponds to.\n         Ok(match *tag_encoding {\n             TagEncoding::Direct => {\n-                let scalar = tag_val.to_scalar()?;\n+                let scalar = tag_val.to_scalar();\n                 // Generate a specific error if `tag_val` is not an integer.\n                 // (`tag_bits` itself is only used for error messages below.)\n                 let tag_bits = scalar\n@@ -758,7 +724,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 (discr_val, index.0)\n             }\n             TagEncoding::Niche { dataful_variant, ref niche_variants, niche_start } => {\n-                let tag_val = tag_val.to_scalar()?;\n+                let tag_val = tag_val.to_scalar();\n                 // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n                 // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n@@ -785,9 +751,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n                             self.binary_op(mir::BinOp::Sub, &tag_val, &niche_start_val)?;\n-                        let variant_index_relative = variant_index_relative_val\n-                            .to_scalar()?\n-                            .assert_bits(tag_val.layout.size);\n+                        let variant_index_relative =\n+                            variant_index_relative_val.to_scalar().assert_bits(tag_val.layout.size);\n                         // Check if this is in the range that indicates an actual discriminant.\n                         if variant_index_relative <= u128::from(variants_end - variants_start) {\n                             let variant_index_relative = u32::try_from(variant_index_relative)"}, {"sha": "1f1d0665139d093f005f9c0a81edd2e6d0c7c19a", "filename": "compiler/rustc_const_eval/src/interpret/operator.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperator.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -329,21 +329,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match left.layout.ty.kind() {\n             ty::Char => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?;\n-                let right = right.to_scalar()?;\n+                let left = left.to_scalar();\n+                let right = right.to_scalar();\n                 Ok(self.binary_char_op(bin_op, left.to_char()?, right.to_char()?))\n             }\n             ty::Bool => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?;\n-                let right = right.to_scalar()?;\n+                let left = left.to_scalar();\n+                let right = right.to_scalar();\n                 Ok(self.binary_bool_op(bin_op, left.to_bool()?, right.to_bool()?))\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n                 let ty = left.layout.ty;\n-                let left = left.to_scalar()?;\n-                let right = right.to_scalar()?;\n+                let left = left.to_scalar();\n+                let right = right.to_scalar();\n                 Ok(match fty {\n                     FloatTy::F32 => {\n                         self.binary_float_op(bin_op, ty, left.to_f32()?, right.to_f32()?)\n@@ -363,8 +363,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     right.layout.ty\n                 );\n \n-                let l = left.to_scalar()?.to_bits(left.layout.size)?;\n-                let r = right.to_scalar()?.to_bits(right.layout.size)?;\n+                let l = left.to_scalar().to_bits(left.layout.size)?;\n+                let r = right.to_scalar().to_bits(right.layout.size)?;\n                 self.binary_int_op(bin_op, l, left.layout, r, right.layout)\n             }\n             _ if left.layout.ty.is_any_ptr() => {\n@@ -410,7 +410,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::UnOp::*;\n \n         let layout = val.layout;\n-        let val = val.to_scalar()?;\n+        let val = val.to_scalar();\n         trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty);\n \n         match layout.ty.kind() {"}, {"sha": "7aa76fe1dae0a1f40656e6b4ebe79a777b8b6adc", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -13,7 +13,7 @@ use rustc_target::abi::{self, Abi, Align, HasDataLayout, Size, TagEncoding, Vari\n use super::{\n     alloc_range, mir_assign_valid_types, AllocId, AllocRef, AllocRefMut, CheckInAllocMsg,\n     ConstAlloc, ImmTy, Immediate, InterpCx, InterpResult, Machine, MemoryKind, OpTy, Operand,\n-    Pointer, Provenance, Scalar, ScalarMaybeUninit,\n+    Pointer, Provenance, Scalar,\n };\n \n #[derive(Copy, Clone, Hash, PartialEq, Eq, Debug)]\n@@ -254,8 +254,6 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n // These are defined here because they produce a place.\n impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n-    /// read from the resulting mplace, not to get its address back.\n     pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n         match **self {\n             Operand::Indirect(mplace) => {\n@@ -267,8 +265,6 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    /// Note: do not call `as_ref` on the resulting place. This function should only be used to\n-    /// read from the resulting mplace, not to get its address back.\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n         self.try_as_mplace().unwrap()\n     }\n@@ -312,7 +308,7 @@ where\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match **val {\n             Immediate::Scalar(ptr) => (ptr, MemPlaceMeta::None),\n-            Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta.check_init()?)),\n+            Immediate::ScalarPair(ptr, meta) => (ptr, MemPlaceMeta::Meta(meta)),\n             Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n@@ -467,7 +463,7 @@ where\n     #[inline(always)]\n     pub fn write_scalar(\n         &mut self,\n-        val: impl Into<ScalarMaybeUninit<M::Provenance>>,\n+        val: impl Into<Scalar<M::Provenance>>,\n         dest: &PlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx> {\n         self.write_immediate(Immediate::Scalar(val.into()), dest)\n@@ -644,7 +640,7 @@ where\n \n         // Let us see if the layout is simple so we take a shortcut,\n         // avoid force_allocation.\n-        let src = match self.read_immediate_raw(src, /*force*/ false)? {\n+        let src = match self.read_immediate_raw(src)? {\n             Ok(src_val) => {\n                 assert!(!src.layout.is_unsized(), \"cannot have unsized immediates\");\n                 assert!("}, {"sha": "f23fa573100c3569d5f77bcd10896105e4feaad2", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -129,8 +129,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                let cond_val =\n-                    self.read_immediate(&self.eval_operand(cond, None)?)?.to_scalar()?.to_bool()?;\n+                let cond_val = self.read_scalar(&self.eval_operand(cond, None)?)?.to_bool()?;\n                 if expected == cond_val {\n                     self.go_to_block(target);\n                 } else {"}, {"sha": "e1555f68737774f05000b3361d710fc620aaa127", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 58, "deletions": 102, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -20,8 +20,8 @@ use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, Wr\n use std::hash::Hash;\n \n use super::{\n-    alloc_range, CheckInAllocMsg, GlobalAlloc, Immediate, InterpCx, InterpResult, MPlaceTy,\n-    Machine, MemPlaceMeta, OpTy, Scalar, ScalarMaybeUninit, ValueVisitor,\n+    alloc_range, CheckInAllocMsg, GlobalAlloc, ImmTy, Immediate, InterpCx, InterpResult, MPlaceTy,\n+    Machine, MemPlaceMeta, OpTy, Scalar, ValueVisitor,\n };\n \n macro_rules! throw_validation_failure {\n@@ -304,6 +304,27 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         Ok(r)\n     }\n \n+    fn read_immediate(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+        expected: &str,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::Provenance>> {\n+        Ok(try_validation!(\n+            self.ecx.read_immediate(op),\n+            self.path,\n+            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"{expected}\" },\n+            err_ub!(InvalidUninitBytes(None)) => { \"uninitialized memory\" } expected { \"{expected}\" }\n+        ))\n+    }\n+\n+    fn read_scalar(\n+        &self,\n+        op: &OpTy<'tcx, M::Provenance>,\n+        expected: &str,\n+    ) -> InterpResult<'tcx, Scalar<M::Provenance>> {\n+        Ok(self.read_immediate(op, expected)?.to_scalar())\n+    }\n+\n     fn check_wide_ptr_meta(\n         &mut self,\n         meta: MemPlaceMeta<M::Provenance>,\n@@ -348,18 +369,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         value: &OpTy<'tcx, M::Provenance>,\n         kind: &str,\n     ) -> InterpResult<'tcx> {\n-        let value = try_validation!(\n-            self.ecx.read_immediate(value),\n-            self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n-        );\n+        let place = self.ecx.ref_to_mplace(&self.read_immediate(value, &format!(\"a {kind}\"))?)?;\n         // Handle wide pointers.\n         // Check metadata early, for better diagnostics\n-        let place = try_validation!(\n-            self.ecx.ref_to_mplace(&value),\n-            self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"uninitialized {}\", kind },\n-        );\n         if place.layout.is_unsized() {\n             self.check_wide_ptr_meta(place.meta, place.layout)?;\n         }\n@@ -454,28 +466,6 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         Ok(())\n     }\n \n-    fn read_scalar(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<M::Provenance>> {\n-        Ok(try_validation!(\n-            self.ecx.read_scalar(op),\n-            self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n-        ))\n-    }\n-\n-    fn read_immediate_forced(\n-        &self,\n-        op: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n-        Ok(*try_validation!(\n-            self.ecx.read_immediate_raw(op, /*force*/ true),\n-            self.path,\n-            err_unsup!(ReadPointerAsBytes) => { \"(potentially part of) a pointer\" } expected { \"plain (non-pointer) bytes\" },\n-        ).unwrap())\n-    }\n-\n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n     /// at that type.  Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n@@ -486,41 +476,39 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let ty = value.layout.ty;\n         match ty.kind() {\n             ty::Bool => {\n-                let value = self.read_scalar(value)?;\n+                let value = self.read_scalar(value, \"a boolean\")?;\n                 try_validation!(\n                     value.to_bool(),\n                     self.path,\n-                    err_ub!(InvalidBool(..)) | err_ub!(InvalidUninitBytes(None)) =>\n+                    err_ub!(InvalidBool(..)) =>\n                         { \"{:x}\", value } expected { \"a boolean\" },\n                 );\n                 Ok(true)\n             }\n             ty::Char => {\n-                let value = self.read_scalar(value)?;\n+                let value = self.read_scalar(value, \"a unicode scalar value\")?;\n                 try_validation!(\n                     value.to_char(),\n                     self.path,\n-                    err_ub!(InvalidChar(..)) | err_ub!(InvalidUninitBytes(None)) =>\n+                    err_ub!(InvalidChar(..)) =>\n                         { \"{:x}\", value } expected { \"a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\" },\n                 );\n                 Ok(true)\n             }\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n-                let value = self.read_scalar(value)?;\n                 // NOTE: Keep this in sync with the array optimization for int/float\n                 // types below!\n-                if M::enforce_number_init(self.ecx) {\n-                    try_validation!(\n-                        value.check_init(),\n-                        self.path,\n-                        err_ub!(InvalidUninitBytes(..)) =>\n-                            { \"{:x}\", value } expected { \"initialized bytes\" }\n-                    );\n-                }\n+                let value = self.read_scalar(\n+                    value,\n+                    if matches!(ty.kind(), ty::Float(..)) {\n+                        \"a floating point number\"\n+                    } else {\n+                        \"an integer\"\n+                    },\n+                )?;\n                 // As a special exception we *do* match on a `Scalar` here, since we truly want\n                 // to know its underlying representation (and *not* cast it to an integer).\n-                let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n-                if is_ptr {\n+                if matches!(value, Scalar::Ptr(..)) {\n                     throw_validation_failure!(self.path,\n                         { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n                     )\n@@ -531,12 +519,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // We are conservative with uninit for integers, but try to\n                 // actually enforce the strict rules for raw pointers (mostly because\n                 // that lets us re-use `ref_to_mplace`).\n-                let place = try_validation!(\n-                    self.ecx.read_immediate(value).and_then(|ref i| self.ecx.ref_to_mplace(i)),\n-                    self.path,\n-                    err_ub!(InvalidUninitBytes(None)) => { \"uninitialized raw pointer\" },\n-                    err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n-                );\n+                let place =\n+                    self.ecx.ref_to_mplace(&self.read_immediate(value, \"a raw pointer\")?)?;\n                 if place.layout.is_unsized() {\n                     self.check_wide_ptr_meta(place.meta, place.layout)?;\n                 }\n@@ -557,12 +541,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 Ok(true)\n             }\n             ty::FnPtr(_sig) => {\n-                let value = try_validation!(\n-                    self.ecx.read_scalar(value).and_then(|v| v.check_init()),\n-                    self.path,\n-                    err_unsup!(ReadPointerAsBytes) => { \"part of a pointer\" } expected { \"a proper pointer or integer value\" },\n-                    err_ub!(InvalidUninitBytes(None)) => { \"uninitialized bytes\" } expected { \"a proper pointer or integer value\" },\n-                );\n+                let value = self.read_scalar(value, \"a function pointer\")?;\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n@@ -613,48 +592,23 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n     fn visit_scalar(\n         &mut self,\n-        scalar: ScalarMaybeUninit<M::Provenance>,\n+        scalar: Scalar<M::Provenance>,\n         scalar_layout: ScalarAbi,\n     ) -> InterpResult<'tcx> {\n-        // We check `is_full_range` in a slightly complicated way because *if* we are checking\n-        // number validity, then we want to ensure that `Scalar::Initialized` is indeed initialized,\n-        // i.e. that we go over the `check_init` below.\n         let size = scalar_layout.size(self.ecx);\n-        let is_full_range = match scalar_layout {\n-            ScalarAbi::Initialized { .. } => {\n-                if M::enforce_number_init(self.ecx) {\n-                    false // not \"full\" since uninit is not accepted\n-                } else {\n-                    scalar_layout.is_always_valid(self.ecx)\n-                }\n-            }\n-            ScalarAbi::Union { .. } => true,\n-        };\n-        if is_full_range {\n-            // Nothing to check. Cruciall we don't even `read_scalar` until here, since that would\n-            // fail for `Union` scalars!\n-            return Ok(());\n-        }\n-        // We have something to check: it must at least be initialized.\n         let valid_range = scalar_layout.valid_range(self.ecx);\n         let WrappingRange { start, end } = valid_range;\n         let max_value = size.unsigned_int_max();\n         assert!(end <= max_value);\n-        let value = try_validation!(\n-            scalar.check_init(),\n-            self.path,\n-            err_ub!(InvalidUninitBytes(None)) => { \"{:x}\", scalar }\n-                expected { \"something {}\", wrapping_range_format(valid_range, max_value) },\n-        );\n-        let bits = match value.try_to_int() {\n+        let bits = match scalar.try_to_int() {\n             Ok(int) => int.assert_bits(size),\n             Err(_) => {\n                 // So this is a pointer then, and casting to an int failed.\n                 // Can only happen during CTFE.\n                 // We support 2 kinds of ranges here: full range, and excluding zero.\n                 if start == 1 && end == max_value {\n                     // Only null is the niche.  So make sure the ptr is NOT null.\n-                    if self.ecx.scalar_may_be_null(value)? {\n+                    if self.ecx.scalar_may_be_null(scalar)? {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n                             expected {\n@@ -808,21 +762,27 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 );\n             }\n             Abi::Scalar(scalar_layout) => {\n-                // We use a 'forced' read because we always need a `Immediate` here\n-                // and treating \"partially uninit\" as \"fully uninit\" is fine for us.\n-                let scalar = self.read_immediate_forced(op)?.to_scalar_or_uninit();\n-                self.visit_scalar(scalar, scalar_layout)?;\n+                if !scalar_layout.is_uninit_valid() {\n+                    // There is something to check here.\n+                    let scalar = self.read_scalar(op, \"initiailized scalar value\")?;\n+                    self.visit_scalar(scalar, scalar_layout)?;\n+                }\n             }\n             Abi::ScalarPair(a_layout, b_layout) => {\n                 // There is no `rustc_layout_scalar_valid_range_start` for pairs, so\n                 // we would validate these things as we descend into the fields,\n                 // but that can miss bugs in layout computation. Layout computation\n                 // is subtle due to enums having ScalarPair layout, where one field\n                 // is the discriminant.\n-                if cfg!(debug_assertions) {\n-                    // We use a 'forced' read because we always need a `Immediate` here\n-                    // and treating \"partially uninit\" as \"fully uninit\" is fine for us.\n-                    let (a, b) = self.read_immediate_forced(op)?.to_scalar_or_uninit_pair();\n+                if cfg!(debug_assertions)\n+                    && !a_layout.is_uninit_valid()\n+                    && !b_layout.is_uninit_valid()\n+                {\n+                    // We can only proceed if *both* scalars need to be initialized.\n+                    // FIXME: find a way to also check ScalarPair when one side can be uninit but\n+                    // the other must be init.\n+                    let (a, b) =\n+                        self.read_immediate(op, \"initiailized scalar value\")?.to_scalar_pair();\n                     self.visit_scalar(a, a_layout)?;\n                     self.visit_scalar(b, b_layout)?;\n                 }\n@@ -901,11 +861,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // We also accept uninit, for consistency with the slow path.\n                 let alloc = self.ecx.get_ptr_alloc(mplace.ptr, size, mplace.align)?.expect(\"we already excluded size 0\");\n \n-                match alloc.check_bytes(\n-                    alloc_range(Size::ZERO, size),\n-                    /*allow_uninit*/ !M::enforce_number_init(self.ecx),\n-                    /*allow_ptr*/ false,\n-                ) {\n+                match alloc.check_bytes(alloc_range(Size::ZERO, size)) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}\n                     // Some error happened, try to provide a more detailed description."}, {"sha": "3f618106525cf90cf3d99c93eef1983dcb13cb0e", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -16,8 +16,8 @@ use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n     read_target_uint, write_target_uint, AllocId, InterpError, InterpResult, Pointer, Provenance,\n-    ResourceExhaustionInfo, Scalar, ScalarMaybeUninit, ScalarSizeMismatch, UndefinedBehaviorInfo,\n-    UninitBytesAccess, UnsupportedOpInfo,\n+    ResourceExhaustionInfo, Scalar, ScalarSizeMismatch, UndefinedBehaviorInfo, UninitBytesAccess,\n+    UnsupportedOpInfo,\n };\n use crate::ty;\n \n@@ -415,25 +415,10 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n \n /// Reading and writing.\n impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n-    /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n-    /// relocation. If `allow_uninit`/`allow_ptr` is `false`, also enforces that the memory in the\n-    /// given range contains no uninitialized bytes/relocations.\n-    pub fn check_bytes(\n-        &self,\n-        cx: &impl HasDataLayout,\n-        range: AllocRange,\n-        allow_uninit: bool,\n-        allow_ptr: bool,\n-    ) -> AllocResult {\n-        // Check bounds and relocations on the edges.\n-        self.get_bytes_with_uninit_and_ptr(cx, range)?;\n-        // Check uninit and ptr.\n-        if !allow_uninit {\n-            self.check_init(range)?;\n-        }\n-        if !allow_ptr {\n-            self.check_relocations(cx, range)?;\n-        }\n+    /// Validates that this memory range is initiailized and contains no relocations.\n+    pub fn check_bytes(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n+        // This implicitly does all the checking we are asking for.\n+        self.get_bytes(cx, range)?;\n         Ok(())\n     }\n \n@@ -452,16 +437,14 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n         read_provenance: bool,\n-    ) -> AllocResult<ScalarMaybeUninit<Prov>> {\n+    ) -> AllocResult<Scalar<Prov>> {\n         if read_provenance {\n             assert_eq!(range.size, cx.data_layout().pointer_size);\n         }\n \n         // First and foremost, if anything is uninit, bail.\n         if self.is_init(range).is_err() {\n-            // This inflates uninitialized bytes to the entire scalar, even if only a few\n-            // bytes are uninitialized.\n-            return Ok(ScalarMaybeUninit::Uninit);\n+            return Err(AllocError::InvalidUninitBytes(None));\n         }\n \n         // If we are doing a pointer read, and there is a relocation exactly where we\n@@ -471,7 +454,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n             let bytes = self.get_bytes_even_more_internal(range);\n             let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n             let ptr = Pointer::new(prov, Size::from_bytes(bits));\n-            return Ok(ScalarMaybeUninit::from_pointer(ptr, cx));\n+            return Ok(Scalar::from_pointer(ptr, cx));\n         }\n \n         // If we are *not* reading a pointer, and we can just ignore relocations,\n@@ -480,7 +463,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n             // We just strip provenance.\n             let bytes = self.get_bytes_even_more_internal(range);\n             let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-            return Ok(ScalarMaybeUninit::Scalar(Scalar::from_uint(bits, range.size)));\n+            return Ok(Scalar::from_uint(bits, range.size));\n         }\n \n         // It's complicated. Better make sure there is no provenance anywhere.\n@@ -492,7 +475,7 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         //   underlying bits.\n         let bytes = self.get_bytes(cx, range)?;\n         let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-        Ok(ScalarMaybeUninit::Scalar(Scalar::from_uint(bits, range.size)))\n+        Ok(Scalar::from_uint(bits, range.size))\n     }\n \n     /// Writes a *non-ZST* scalar.\n@@ -507,17 +490,10 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         &mut self,\n         cx: &impl HasDataLayout,\n         range: AllocRange,\n-        val: ScalarMaybeUninit<Prov>,\n+        val: Scalar<Prov>,\n     ) -> AllocResult {\n         assert!(self.mutability == Mutability::Mut);\n \n-        let val = match val {\n-            ScalarMaybeUninit::Scalar(scalar) => scalar,\n-            ScalarMaybeUninit::Uninit => {\n-                return self.write_uninit(cx, range);\n-            }\n-        };\n-\n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n         let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size)? {"}, {"sha": "93fe7e63710b15061f85791bf3071f6692a4bcb6", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -124,7 +124,7 @@ pub use self::error::{\n     UninitBytesAccess, UnsupportedOpInfo,\n };\n \n-pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar, ScalarMaybeUninit};\n+pub use self::value::{get_slice_bytes, ConstAlloc, ConstValue, Scalar};\n \n pub use self::allocation::{\n     alloc_range, AllocRange, Allocation, ConstAllocation, InitChunk, InitChunkIter, InitMask,"}, {"sha": "ba56c5267df0b1af2519dd3b4eef6918f8244238", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -504,139 +504,6 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, TyEncodable, TyDecodable, HashStable, Hash)]\n-pub enum ScalarMaybeUninit<Prov = AllocId> {\n-    Scalar(Scalar<Prov>),\n-    Uninit,\n-}\n-\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ScalarMaybeUninit, 24);\n-\n-impl<Prov> From<Scalar<Prov>> for ScalarMaybeUninit<Prov> {\n-    #[inline(always)]\n-    fn from(s: Scalar<Prov>) -> Self {\n-        ScalarMaybeUninit::Scalar(s)\n-    }\n-}\n-\n-// We want the `Debug` output to be readable as it is used by `derive(Debug)` for\n-// all the Miri types.\n-impl<Prov: Provenance> fmt::Debug for ScalarMaybeUninit<Prov> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            ScalarMaybeUninit::Uninit => write!(f, \"<uninitialized>\"),\n-            ScalarMaybeUninit::Scalar(s) => write!(f, \"{:?}\", s),\n-        }\n-    }\n-}\n-\n-impl<Prov: Provenance> fmt::LowerHex for ScalarMaybeUninit<Prov> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            ScalarMaybeUninit::Uninit => write!(f, \"uninitialized bytes\"),\n-            ScalarMaybeUninit::Scalar(s) => write!(f, \"{:x}\", s),\n-        }\n-    }\n-}\n-\n-impl<Prov> ScalarMaybeUninit<Prov> {\n-    #[inline]\n-    pub fn from_pointer(ptr: Pointer<Prov>, cx: &impl HasDataLayout) -> Self {\n-        ScalarMaybeUninit::Scalar(Scalar::from_pointer(ptr, cx))\n-    }\n-\n-    #[inline]\n-    pub fn from_maybe_pointer(ptr: Pointer<Option<Prov>>, cx: &impl HasDataLayout) -> Self {\n-        ScalarMaybeUninit::Scalar(Scalar::from_maybe_pointer(ptr, cx))\n-    }\n-\n-    #[inline]\n-    pub fn check_init<'tcx>(self) -> InterpResult<'tcx, Scalar<Prov>> {\n-        match self {\n-            ScalarMaybeUninit::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUninit::Uninit => throw_ub!(InvalidUninitBytes(None)),\n-        }\n-    }\n-}\n-\n-impl<'tcx, Prov: Provenance> ScalarMaybeUninit<Prov> {\n-    #[inline(always)]\n-    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n-        self.check_init()?.to_pointer(cx)\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n-        self.check_init()?.to_bool()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_char(self) -> InterpResult<'tcx, char> {\n-        self.check_init()?.to_char()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_f32(self) -> InterpResult<'tcx, Single> {\n-        self.check_init()?.to_f32()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_f64(self) -> InterpResult<'tcx, Double> {\n-        self.check_init()?.to_f64()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_u8(self) -> InterpResult<'tcx, u8> {\n-        self.check_init()?.to_u8()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_u16(self) -> InterpResult<'tcx, u16> {\n-        self.check_init()?.to_u16()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_u32(self) -> InterpResult<'tcx, u32> {\n-        self.check_init()?.to_u32()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_u64(self) -> InterpResult<'tcx, u64> {\n-        self.check_init()?.to_u64()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n-        self.check_init()?.to_machine_usize(cx)\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_i8(self) -> InterpResult<'tcx, i8> {\n-        self.check_init()?.to_i8()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_i16(self) -> InterpResult<'tcx, i16> {\n-        self.check_init()?.to_i16()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_i32(self) -> InterpResult<'tcx, i32> {\n-        self.check_init()?.to_i32()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_i64(self) -> InterpResult<'tcx, i64> {\n-        self.check_init()?.to_i64()\n-    }\n-\n-    #[inline(always)]\n-    pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n-        self.check_init()?.to_machine_isize(cx)\n-    }\n-}\n-\n /// Gets the bytes of a constant slice value.\n pub fn get_slice_bytes<'tcx>(cx: &impl HasDataLayout, val: ConstValue<'tcx>) -> &'tcx [u8] {\n     if let ConstValue::Slice { data, start, end } = val {"}, {"sha": "5ca51c25a9ce17a79306072d31261c4f2b78cc20", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,7 +1,7 @@\n use std::convert::TryFrom;\n use std::fmt;\n \n-use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar, ScalarMaybeUninit};\n+use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar};\n use crate::ty::{self, Instance, PolyTraitRef, Ty, TyCtxt};\n use rustc_ast::Mutability;\n \n@@ -87,7 +87,7 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n                 let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n                 let fn_alloc_id = tcx.create_fn_alloc(instance);\n                 let fn_ptr = Pointer::from(fn_alloc_id);\n-                ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n+                Scalar::from_pointer(fn_ptr, &tcx)\n             }\n             VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n             VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n@@ -97,14 +97,14 @@ pub(super) fn vtable_allocation_provider<'tcx>(\n                 let instance = instance.polymorphize(tcx);\n                 let fn_alloc_id = tcx.create_fn_alloc(instance);\n                 let fn_ptr = Pointer::from(fn_alloc_id);\n-                ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n+                Scalar::from_pointer(fn_ptr, &tcx)\n             }\n             VtblEntry::TraitVPtr(trait_ref) => {\n                 let super_trait_ref = trait_ref\n                     .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n                 let supertrait_alloc_id = tcx.vtable_allocation((ty, Some(super_trait_ref)));\n                 let vptr = Pointer::from(supertrait_alloc_id);\n-                ScalarMaybeUninit::from_pointer(vptr, &tcx)\n+                Scalar::from_pointer(vptr, &tcx)\n             }\n         };\n         vtable"}, {"sha": "9f3a9d0b87826bc13dde2664694ae636a0f129c2", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -28,7 +28,7 @@ use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n     ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, PlaceTy,\n-    Pointer, Scalar, ScalarMaybeUninit, StackPopCleanup, StackPopUnwind,\n+    Pointer, Scalar, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -440,7 +440,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.read_immediate_raw(&op, /*force*/ false) {\n+        Some(match self.ecx.read_immediate_raw(&op) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -532,8 +532,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let left_ty = left.ty(self.local_decls, self.tcx);\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n-            let r_bits = r.to_scalar().ok();\n-            let r_bits = r_bits.and_then(|r| r.to_bits(right_size).ok());\n+            let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 return None;\n             }\n@@ -562,7 +561,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // and use it to do const-prop here and everywhere else\n                     // where it makes sense.\n                     if let interpret::Operand::Immediate(interpret::Immediate::Scalar(\n-                        ScalarMaybeUninit::Scalar(scalar),\n+                        scalar,\n                     )) = *value\n                     {\n                         *operand = self.operand_from_scalar(\n@@ -675,7 +674,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     return this.ecx.eval_rvalue_into_place(rvalue, place);\n                 }\n \n-                let arg_value = const_arg.to_scalar()?.to_bits(const_arg.layout.size)?;\n+                let arg_value = const_arg.to_scalar().to_bits(const_arg.layout.size)?;\n                 let dest = this.ecx.eval_place(place)?;\n \n                 match op {\n@@ -689,7 +688,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     BinOp::Mul if const_arg.layout.ty.is_integral() && arg_value == 0 => {\n                         if let Rvalue::CheckedBinaryOp(_, _) = rvalue {\n                             let val = Immediate::ScalarPair(\n-                                const_arg.to_scalar()?.into(),\n+                                const_arg.to_scalar().into(),\n                                 Scalar::from_bool(false).into(),\n                             );\n                             this.ecx.write_immediate(val, &dest)\n@@ -743,21 +742,18 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME> figure out what to do when read_immediate_raw fails\n-        let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value, /*force*/ false));\n+        let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value));\n \n         if let Some(Ok(imm)) = imm {\n             match *imm {\n-                interpret::Immediate::Scalar(ScalarMaybeUninit::Scalar(scalar)) => {\n+                interpret::Immediate::Scalar(scalar) => {\n                     *rval = Rvalue::Use(self.operand_from_scalar(\n                         scalar,\n                         value.layout.ty,\n                         source_info.span,\n                     ));\n                 }\n-                Immediate::ScalarPair(\n-                    ScalarMaybeUninit::Scalar(_),\n-                    ScalarMaybeUninit::Scalar(_),\n-                ) => {\n+                Immediate::ScalarPair(..) => {\n                     // Found a value represented as a pair. For now only do const-prop if the type\n                     // of `rvalue` is also a tuple with two scalars.\n                     // FIXME: enable the general case stated above ^.\n@@ -812,13 +808,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         match **op {\n-            interpret::Operand::Immediate(Immediate::Scalar(ScalarMaybeUninit::Scalar(s))) => {\n-                s.try_to_int().is_ok()\n+            interpret::Operand::Immediate(Immediate::Scalar(s)) => s.try_to_int().is_ok(),\n+            interpret::Operand::Immediate(Immediate::ScalarPair(l, r)) => {\n+                l.try_to_int().is_ok() && r.try_to_int().is_ok()\n             }\n-            interpret::Operand::Immediate(Immediate::ScalarPair(\n-                ScalarMaybeUninit::Scalar(l),\n-                ScalarMaybeUninit::Scalar(r),\n-            )) => l.try_to_int().is_ok() && r.try_to_int().is_ok(),\n             _ => false,\n         }\n     }\n@@ -1079,7 +1072,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             TerminatorKind::Assert { expected, ref mut cond, .. } => {\n                 if let Some(ref value) = self.eval_operand(&cond) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n+                    let expected = Scalar::from_bool(*expected);\n                     let value_const = self.ecx.read_scalar(&value).unwrap();\n                     if expected != value_const {\n                         // Poison all places this operand references so that further code\n@@ -1092,13 +1085,11 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                         }\n                     } else {\n                         if self.should_const_prop(value) {\n-                            if let ScalarMaybeUninit::Scalar(scalar) = value_const {\n-                                *cond = self.operand_from_scalar(\n-                                    scalar,\n-                                    self.tcx.types.bool,\n-                                    source_info.span,\n-                                );\n-                            }\n+                            *cond = self.operand_from_scalar(\n+                                value_const,\n+                                self.tcx.types.bool,\n+                                source_info.span,\n+                            );\n                         }\n                     }\n                 }"}, {"sha": "1bc65721ea601451e3bbcc4c01a6fdd13d33ed5f", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -7,8 +7,7 @@ use crate::const_prop::ConstPropMode;\n use crate::MirLint;\n use rustc_const_eval::const_eval::ConstEvalErr;\n use rustc_const_eval::interpret::{\n-    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar,\n-    ScalarMaybeUninit, StackPopCleanup,\n+    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n@@ -239,7 +238,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n \n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n-        Some(match self.ecx.read_immediate_raw(&op, /*force*/ false) {\n+        Some(match self.ecx.read_immediate_raw(&op) {\n             Ok(Ok(imm)) => imm.into(),\n             _ => op,\n         })\n@@ -401,8 +400,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let left_ty = left.ty(self.local_decls, self.tcx);\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n-            let r_bits = r.to_scalar().ok();\n-            let r_bits = r_bits.and_then(|r| r.to_bits(right_size).ok());\n+            let r_bits = r.to_scalar().to_bits(right_size).ok();\n             if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", source_info);\n                 self.report_assert_as_lint(\n@@ -625,7 +623,7 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             TerminatorKind::Assert { expected, ref msg, ref cond, .. } => {\n                 if let Some(ref value) = self.eval_operand(&cond, source_info) {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    let expected = ScalarMaybeUninit::from(Scalar::from_bool(*expected));\n+                    let expected = Scalar::from_bool(*expected);\n                     let value_const = self.ecx.read_scalar(&value).unwrap();\n                     if expected != value_const {\n                         enum DbgVal<T> {"}, {"sha": "be92429e3abc5880575f9a203ab363920ea64ad4", "filename": "src/test/ui/const-generics/min_const_generics/invalid-patterns.32bit.stderr", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -22,19 +22,14 @@ error[E0308]: mismatched types\n LL |   get_flag::<42, 0x5ad>();\n    |                  ^^^^^ expected `char`, found `u8`\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:38:21\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/invalid-patterns.rs:38:32\n    |\n LL |   get_flag::<false, { unsafe { char_raw.character } }>();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                ^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:40:14\n+  --> $DIR/invalid-patterns.rs:41:14\n    |\n LL |   get_flag::<{ unsafe { bool_raw.boolean } }, 'z'>();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x42, but expected a boolean\n@@ -45,7 +40,7 @@ LL |   get_flag::<{ unsafe { bool_raw.boolean } }, 'z'>();\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:42:14\n+  --> $DIR/invalid-patterns.rs:43:14\n    |\n LL |   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character } }>();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x42, but expected a boolean\n@@ -55,16 +50,11 @@ LL |   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character\n                42                                              \u2502 B\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:42:47\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/invalid-patterns.rs:43:58\n    |\n LL |   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character } }>();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                                          ^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 8 previous errors\n "}, {"sha": "be92429e3abc5880575f9a203ab363920ea64ad4", "filename": "src/test/ui/const-generics/min_const_generics/invalid-patterns.64bit.stderr", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -22,19 +22,14 @@ error[E0308]: mismatched types\n LL |   get_flag::<42, 0x5ad>();\n    |                  ^^^^^ expected `char`, found `u8`\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:38:21\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/invalid-patterns.rs:38:32\n    |\n LL |   get_flag::<false, { unsafe { char_raw.character } }>();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                ^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:40:14\n+  --> $DIR/invalid-patterns.rs:41:14\n    |\n LL |   get_flag::<{ unsafe { bool_raw.boolean } }, 'z'>();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x42, but expected a boolean\n@@ -45,7 +40,7 @@ LL |   get_flag::<{ unsafe { bool_raw.boolean } }, 'z'>();\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:42:14\n+  --> $DIR/invalid-patterns.rs:43:14\n    |\n LL |   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character } }>();\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0x42, but expected a boolean\n@@ -55,16 +50,11 @@ LL |   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character\n                42                                              \u2502 B\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/invalid-patterns.rs:42:47\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/invalid-patterns.rs:43:58\n    |\n LL |   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character } }>();\n-   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                                          ^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 8 previous errors\n "}, {"sha": "13b2cca2f241e4f013fa257e41615046d5c75207", "filename": "src/test/ui/const-generics/min_const_generics/invalid-patterns.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Finvalid-patterns.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -36,10 +36,12 @@ fn main() {\n \n \n   get_flag::<false, { unsafe { char_raw.character } }>();\n-  //~^ ERROR it is undefined behavior\n+  //~^ ERROR evaluation of constant value failed\n+  //~| uninitialized\n   get_flag::<{ unsafe { bool_raw.boolean } }, 'z'>();\n   //~^ ERROR it is undefined behavior\n   get_flag::<{ unsafe { bool_raw.boolean } }, { unsafe { char_raw.character } }>();\n-  //~^ ERROR it is undefined behavior\n+  //~^ ERROR evaluation of constant value failed\n+  //~| uninitialized\n   //~| ERROR it is undefined behavior\n }"}, {"sha": "1cbf78173a7aeee5d4a365e7ffd11d0b6607da92", "filename": "src/test/ui/consts/const-err4.32bit.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,13 +1,8 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const-err4.rs:9:11\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-err4.rs:9:21\n    |\n LL |     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                     ^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to previous error\n "}, {"sha": "1cbf78173a7aeee5d4a365e7ffd11d0b6607da92", "filename": "src/test/ui/consts/const-err4.64bit.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,13 +1,8 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const-err4.rs:9:11\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-err4.rs:9:21\n    |\n LL |     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                     ^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to previous error\n "}, {"sha": "107dc3f8234f333c9c23fcabd63852184ddcce2c", "filename": "src/test/ui/consts/const-err4.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err4.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -7,7 +7,8 @@ union Foo {\n \n enum Bar {\n     Boo = [unsafe { Foo { b: () }.a }; 4][3],\n-    //~^ ERROR it is undefined behavior to use this value\n+    //~^ ERROR evaluation of constant value failed\n+    //~| uninitialized\n }\n \n fn main() {"}, {"sha": "82afa70309da04a8ec8c3428150fafc39ff18519", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.64bit.stderr", "status": "modified", "additions": 50, "deletions": 60, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -44,19 +44,14 @@ LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uin\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const-pointer-values-in-various-types.rs:46:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-pointer-values-in-various-types.rs:46:47\n    |\n LL |     const I32_REF_U128_UNION: u128 = unsafe { Nonsense { int_32_ref: &3 }.uint_128 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:49:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:50:43\n    |\n LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8 };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -65,7 +60,7 @@ LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:53:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:54:45\n    |\n LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int_16 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -74,7 +69,7 @@ LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:57:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:58:45\n    |\n LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int_32 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -83,27 +78,22 @@ LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:61:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:62:45\n    |\n LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int_64 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/const-pointer-values-in-various-types.rs:65:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/const-pointer-values-in-various-types.rs:66:47\n    |\n LL |     const I32_REF_I128_UNION: i128 = unsafe { Nonsense { int_32_ref: &3 }.int_128 };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:68:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:70:45\n    |\n LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.float_32 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -112,7 +102,7 @@ LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.flo\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:72:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:74:45\n    |\n LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.float_64 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -121,7 +111,7 @@ LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.flo\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:76:47\n+  --> $DIR/const-pointer-values-in-various-types.rs:78:47\n    |\n LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.truthy_falsey };\n    |     ------------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -130,7 +120,7 @@ LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.t\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:80:47\n+  --> $DIR/const-pointer-values-in-various-types.rs:82:47\n    |\n LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.character };\n    |     ------------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -139,7 +129,7 @@ LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.c\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:84:39\n+  --> $DIR/const-pointer-values-in-various-types.rs:86:39\n    |\n LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n    |     ----------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -148,7 +138,7 @@ LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:88:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:90:41\n    |\n LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -157,7 +147,7 @@ LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 }\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:92:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:94:41\n    |\n LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -166,7 +156,7 @@ LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 }\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:96:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:98:41\n    |\n LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -175,7 +165,7 @@ LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 }\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:100:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:102:43\n    |\n LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_128 };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -184,7 +174,7 @@ LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_12\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:104:39\n+  --> $DIR/const-pointer-values-in-various-types.rs:106:39\n    |\n LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n    |     ----------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -193,7 +183,7 @@ LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:108:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:110:41\n    |\n LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -202,7 +192,7 @@ LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:112:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:114:41\n    |\n LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -211,7 +201,7 @@ LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:116:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:118:41\n    |\n LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -220,7 +210,7 @@ LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:120:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:122:43\n    |\n LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128 };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -229,7 +219,7 @@ LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:124:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:126:41\n    |\n LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -238,7 +228,7 @@ LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:128:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:130:41\n    |\n LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -247,7 +237,7 @@ LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:132:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:134:43\n    |\n LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_falsey };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -256,7 +246,7 @@ LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:136:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:138:43\n    |\n LL |     const STR_CHAR_UNION: char = unsafe { Nonsense { stringy: \"3\" }.character };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -324,7 +314,7 @@ LL |     const I32_REF_U64_UNION: u64 = unsafe { Nonsense { int_32_ref: &3 }.uin\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:49:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:50:43\n    |\n LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8 };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -335,7 +325,7 @@ LL |     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:53:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:54:45\n    |\n LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int_16 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -346,7 +336,7 @@ LL |     const I32_REF_I16_UNION: i16 = unsafe { Nonsense { int_32_ref: &3 }.int\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:57:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:58:45\n    |\n LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int_32 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -357,7 +347,7 @@ LL |     const I32_REF_I32_UNION: i32 = unsafe { Nonsense { int_32_ref: &3 }.int\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:61:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:62:45\n    |\n LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int_64 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -368,7 +358,7 @@ LL |     const I32_REF_I64_UNION: i64 = unsafe { Nonsense { int_32_ref: &3 }.int\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:68:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:70:45\n    |\n LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.float_32 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -379,7 +369,7 @@ LL |     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.flo\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:72:45\n+  --> $DIR/const-pointer-values-in-various-types.rs:74:45\n    |\n LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.float_64 };\n    |     ----------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -390,7 +380,7 @@ LL |     const I32_REF_F64_UNION: f64 = unsafe { Nonsense { int_32_ref: &3 }.flo\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:76:47\n+  --> $DIR/const-pointer-values-in-various-types.rs:78:47\n    |\n LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.truthy_falsey };\n    |     ------------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -401,7 +391,7 @@ LL |     const I32_REF_BOOL_UNION: bool = unsafe { Nonsense { int_32_ref: &3 }.t\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:80:47\n+  --> $DIR/const-pointer-values-in-various-types.rs:82:47\n    |\n LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.character };\n    |     ------------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -412,7 +402,7 @@ LL |     const I32_REF_CHAR_UNION: char = unsafe { Nonsense { int_32_ref: &3 }.c\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:84:39\n+  --> $DIR/const-pointer-values-in-various-types.rs:86:39\n    |\n LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n    |     ----------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -423,7 +413,7 @@ LL |     const STR_U8_UNION: u8 = unsafe { Nonsense { stringy: \"3\" }.uint_8 };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:88:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:90:41\n    |\n LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -434,7 +424,7 @@ LL |     const STR_U16_UNION: u16 = unsafe { Nonsense { stringy: \"3\" }.uint_16 }\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:92:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:94:41\n    |\n LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -445,7 +435,7 @@ LL |     const STR_U32_UNION: u32 = unsafe { Nonsense { stringy: \"3\" }.uint_32 }\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:96:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:98:41\n    |\n LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -456,7 +446,7 @@ LL |     const STR_U64_UNION: u64 = unsafe { Nonsense { stringy: \"3\" }.uint_64 }\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:100:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:102:43\n    |\n LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_128 };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -467,7 +457,7 @@ LL |     const STR_U128_UNION: u128 = unsafe { Nonsense { stringy: \"3\" }.uint_12\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:104:39\n+  --> $DIR/const-pointer-values-in-various-types.rs:106:39\n    |\n LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n    |     ----------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -478,7 +468,7 @@ LL |     const STR_I8_UNION: i8 = unsafe { Nonsense { stringy: \"3\" }.int_8 };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:108:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:110:41\n    |\n LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -489,7 +479,7 @@ LL |     const STR_I16_UNION: i16 = unsafe { Nonsense { stringy: \"3\" }.int_16 };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:112:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:114:41\n    |\n LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -500,7 +490,7 @@ LL |     const STR_I32_UNION: i32 = unsafe { Nonsense { stringy: \"3\" }.int_32 };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:116:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:118:41\n    |\n LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -511,7 +501,7 @@ LL |     const STR_I64_UNION: i64 = unsafe { Nonsense { stringy: \"3\" }.int_64 };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:120:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:122:43\n    |\n LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128 };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -522,7 +512,7 @@ LL |     const STR_I128_UNION: i128 = unsafe { Nonsense { stringy: \"3\" }.int_128\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:124:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:126:41\n    |\n LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -533,7 +523,7 @@ LL |     const STR_F32_UNION: f32 = unsafe { Nonsense { stringy: \"3\" }.float_32\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:128:41\n+  --> $DIR/const-pointer-values-in-various-types.rs:130:41\n    |\n LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64 };\n    |     ------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -544,7 +534,7 @@ LL |     const STR_F64_UNION: f64 = unsafe { Nonsense { stringy: \"3\" }.float_64\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:132:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:134:43\n    |\n LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_falsey };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -555,7 +545,7 @@ LL |     const STR_BOOL_UNION: bool = unsafe { Nonsense { stringy: \"3\" }.truthy_\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/const-pointer-values-in-various-types.rs:136:43\n+  --> $DIR/const-pointer-values-in-various-types.rs:138:43\n    |\n LL |     const STR_CHAR_UNION: char = unsafe { Nonsense { stringy: \"3\" }.character };\n    |     --------------------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "f6a5e4d3c2b7ddfb55b6dd270f86f02383ad97cf", "filename": "src/test/ui/consts/const-eval/const-pointer-values-in-various-types.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-pointer-values-in-various-types.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -44,7 +44,8 @@ fn main() {\n     //~| WARN this was previously accepted by the compiler but is being phased out\n \n     const I32_REF_U128_UNION: u128 = unsafe { Nonsense { int_32_ref: &3 }.uint_128 };\n-    //~^ ERROR it is undefined behavior to use this value\n+    //~^ ERROR evaluation of constant value failed\n+    //~| uninitialized\n \n     const I32_REF_I8_UNION: i8 = unsafe { Nonsense { int_32_ref: &3 }.int_8 };\n     //~^ ERROR any use of this value will cause an error\n@@ -63,7 +64,8 @@ fn main() {\n     //~| WARN this was previously accepted by the compiler but is being phased out\n \n     const I32_REF_I128_UNION: i128 = unsafe { Nonsense { int_32_ref: &3 }.int_128 };\n-    //~^ ERROR it is undefined behavior to use this value\n+    //~^ ERROR evaluation of constant value failed\n+    //~| uninitialized\n \n     const I32_REF_F32_UNION: f32 = unsafe { Nonsense { int_32_ref: &3 }.float_32 };\n     //~^ ERROR any use of this value will cause an error"}, {"sha": "a0f4519eaad3a7d1fe8fbf55163d7824cd2e9c81", "filename": "src/test/ui/consts/const-eval/heap/alloc_intrinsic_uninit.32bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/alloc_intrinsic_uninit.rs:8:1\n    |\n LL | const BAR: &i32 = unsafe { &*(intrinsics::const_allocate(4, 4) as *mut i32) };\n-   | ^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized bytes, but expected initialized bytes\n+   | ^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized memory, but expected an integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 4, align: 4) {"}, {"sha": "d2bffa42561ac38f9897ce2abda89a303d4c705b", "filename": "src/test/ui/consts/const-eval/heap/alloc_intrinsic_uninit.64bit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fheap%2Falloc_intrinsic_uninit.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -2,7 +2,7 @@ error[E0080]: it is undefined behavior to use this value\n   --> $DIR/alloc_intrinsic_uninit.rs:8:1\n    |\n LL | const BAR: &i32 = unsafe { &*(intrinsics::const_allocate(4, 4) as *mut i32) };\n-   | ^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized bytes, but expected initialized bytes\n+   | ^^^^^^^^^^^^^^^ constructing invalid value at .<deref>: encountered uninitialized memory, but expected an integer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n    = note: the raw bytes of the constant (size: 8, align: 8) {"}, {"sha": "086a1001d11ca96d38c704b3f67c460b6a3f2280", "filename": "src/test/ui/consts/const-eval/ub-enum-overwrite.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-overwrite.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -6,12 +6,13 @@ enum E {\n }\n \n const _: u8 = {\n-    //~^ ERROR is undefined behavior\n     let mut e = E::A(1);\n     let p = if let E::A(x) = &mut e { x as *mut u8 } else { unreachable!() };\n     // Make sure overwriting `e` uninitializes other bytes\n     e = E::B;\n     unsafe { *p }\n+    //~^ ERROR evaluation of constant value failed\n+    //~| uninitialized\n };\n \n fn main() {}"}, {"sha": "5750212b44c8fc5334dccb3389c3dd2c19f643ef", "filename": "src/test/ui/consts/const-eval/ub-enum-overwrite.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-overwrite.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-overwrite.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-overwrite.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,13 +1,8 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum-overwrite.rs:8:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum-overwrite.rs:13:14\n    |\n-LL | const _: u8 = {\n-   | ^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               __                                              \u2502 \u2591\n-           }\n+LL |     unsafe { *p }\n+   |              ^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to previous error\n "}, {"sha": "1e80dd7c765daedcf5aeda0ab15dc509d351f13a", "filename": "src/test/ui/consts/const-eval/ub-enum.32bit.stderr", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -57,19 +57,14 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:59:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum.rs:59:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:63:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -78,7 +73,7 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:81:1\n+  --> $DIR/ub-enum.rs:82:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n@@ -89,7 +84,7 @@ LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:83:1\n+  --> $DIR/ub-enum.rs:84:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n@@ -100,7 +95,7 @@ LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:91:1\n+  --> $DIR/ub-enum.rs:92:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n@@ -111,13 +106,13 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:96:77\n+  --> $DIR/ub-enum.rs:97:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:98:77\n+  --> $DIR/ub-enum.rs:99:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n@@ -171,7 +166,7 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:63:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "a6208f30c22a068204c2ab161c9025fe8a0afc37", "filename": "src/test/ui/consts/const-eval/ub-enum.64bit.stderr", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -57,19 +57,14 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:59:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-enum.rs:59:42\n    |\n LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-tag>: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:63:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -78,7 +73,7 @@ LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:81:1\n+  --> $DIR/ub-enum.rs:82:1\n    |\n LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute(1u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(B)>.0: encountered a value of the never type `!`\n@@ -89,7 +84,7 @@ LL | const BAD_UNINHABITED_VARIANT1: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:83:1\n+  --> $DIR/ub-enum.rs:84:1\n    |\n LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute(3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(D)>.0: encountered a value of uninhabited type Never\n@@ -100,7 +95,7 @@ LL | const BAD_UNINHABITED_VARIANT2: UninhDiscriminant = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:91:1\n+  --> $DIR/ub-enum.rs:92:1\n    |\n LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::transmute(!0u32) }));\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<enum-variant(Some)>.0.1: encountered 0xffffffff, but expected a valid unicode scalar value (in `0..=0x10FFFF` but not in `0xD800..=0xDFFF`)\n@@ -111,13 +106,13 @@ LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { mem::tran\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:96:77\n+  --> $DIR/ub-enum.rs:97:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA1: Result<(i32, Never), (i32, !)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-enum.rs:98:77\n+  --> $DIR/ub-enum.rs:99:77\n    |\n LL | const BAD_UNINHABITED_WITH_DATA2: Result<(i32, !), (i32, Never)> = unsafe { mem::transmute(0u64) };\n    |                                                                             ^^^^^^^^^^^^^^^^^^^^ transmuting to uninhabited type\n@@ -171,7 +166,7 @@ LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { mem::transmute(&0) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-enum.rs:63:1\n+  --> $DIR/ub-enum.rs:64:1\n    |\n LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}, {"sha": "0e8744e790f6bdf95fb6cd99d31ac255b34a2d22", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -57,7 +57,8 @@ union MaybeUninit<T: Copy> {\n     init: T,\n }\n const BAD_ENUM2_UNDEF : Enum2 = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR is undefined behavior\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n \n // Pointer value in an enum with a niche that is not just 0.\n const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { mem::transmute(&0) };"}, {"sha": "6100a98d161e264e0a3b3ed89dc8fde8278562e0", "filename": "src/test/ui/consts/const-eval/ub-int-array.32bit.stderr", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,35 +1,20 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-int-array.rs:14:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-int-array.rs:16:9\n    |\n-LL | const UNINIT_INT_0: [u32; 3] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 12, align: 4) {\n-               __ __ __ __ 01 00 00 00 02 00 00 00             \u2502 \u2591\u2591\u2591\u2591........\n-           }\n+LL |         MaybeUninit { uninit: () }.init,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-int-array.rs:23:1\n-   |\n-LL | const UNINIT_INT_1: [u32; 3] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [1]: encountered uninitialized bytes\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-int-array.rs:31:13\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 12, align: 4) {\n-               00 00 00 00 01 __ 01 01 02 02 __ 02             \u2502 .....\u2591....\u2591.\n-           }\n+LL |             MaybeUninit { uninit: () }.init,\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-int-array.rs:43:1\n-   |\n-LL | const UNINIT_INT_2: [u32; 3] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [2]: encountered uninitialized bytes\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-int-array.rs:57:13\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 12, align: 4) {\n-               00 00 00 00 01 01 01 01 02 02 02 __             \u2502 ...........\u2591\n-           }\n+LL |             MaybeUninit { uninit: () }.init,\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6100a98d161e264e0a3b3ed89dc8fde8278562e0", "filename": "src/test/ui/consts/const-eval/ub-int-array.64bit.stderr", "status": "modified", "additions": 12, "deletions": 27, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,35 +1,20 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-int-array.rs:14:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-int-array.rs:16:9\n    |\n-LL | const UNINIT_INT_0: [u32; 3] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [0]: encountered uninitialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 12, align: 4) {\n-               __ __ __ __ 01 00 00 00 02 00 00 00             \u2502 \u2591\u2591\u2591\u2591........\n-           }\n+LL |         MaybeUninit { uninit: () }.init,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-int-array.rs:23:1\n-   |\n-LL | const UNINIT_INT_1: [u32; 3] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [1]: encountered uninitialized bytes\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-int-array.rs:31:13\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 12, align: 4) {\n-               00 00 00 00 01 __ 01 01 02 02 __ 02             \u2502 .....\u2591....\u2591.\n-           }\n+LL |             MaybeUninit { uninit: () }.init,\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-int-array.rs:43:1\n-   |\n-LL | const UNINIT_INT_2: [u32; 3] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at [2]: encountered uninitialized bytes\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-int-array.rs:57:13\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 12, align: 4) {\n-               00 00 00 00 01 01 01 01 02 02 02 __             \u2502 ...........\u2591\n-           }\n+LL |             MaybeUninit { uninit: () }.init,\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 3 previous errors\n "}, {"sha": "cb85e3b016a98eda5ec413cb71ba9e1c4a45bb76", "filename": "src/test/ui/consts/const-eval/ub-int-array.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-int-array.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -12,17 +12,15 @@ union MaybeUninit<T: Copy> {\n }\n \n const UNINIT_INT_0: [u32; 3] = unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n-//~| constructing invalid value at [0]: encountered uninitialized bytes\n     [\n         MaybeUninit { uninit: () }.init,\n+        //~^ ERROR evaluation of constant value failed\n+        //~| uninitialized\n         1,\n         2,\n     ]\n };\n const UNINIT_INT_1: [u32; 3] = unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n-//~| constructing invalid value at [1]: encountered uninitialized bytes\n     mem::transmute(\n         [\n             0u8,\n@@ -31,6 +29,8 @@ const UNINIT_INT_1: [u32; 3] = unsafe {\n             0u8,\n             1u8,\n             MaybeUninit { uninit: () }.init,\n+            //~^ ERROR evaluation of constant value failed\n+            //~| uninitialized\n             1u8,\n             1u8,\n             2u8,\n@@ -41,8 +41,6 @@ const UNINIT_INT_1: [u32; 3] = unsafe {\n     )\n };\n const UNINIT_INT_2: [u32; 3] = unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n-//~| constructing invalid value at [2]: encountered uninitialized bytes\n     mem::transmute(\n         [\n             0u8,\n@@ -57,6 +55,8 @@ const UNINIT_INT_2: [u32; 3] = unsafe {\n             2u8,\n             2u8,\n             MaybeUninit { uninit: () }.init,\n+            //~^ ERROR evaluation of constant value failed\n+            //~| uninitialized\n         ]\n     )\n };"}, {"sha": "693c0e99bfd959e142ce2c43a153cac0946b4cc4", "filename": "src/test/ui/consts/const-eval/ub-nonnull.32bit.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -37,19 +37,14 @@ LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n                00 00 00 00                                     \u2502 ....\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:33:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-nonnull.rs:33:36\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               __                                              \u2502 \u2591\n-           }\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:41:1\n+  --> $DIR/ub-nonnull.rs:42:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n@@ -60,7 +55,7 @@ LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:47:1\n+  --> $DIR/ub-nonnull.rs:48:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30"}, {"sha": "d22191213ac3695f93fcc978a02a9a2397757b48", "filename": "src/test/ui/consts/const-eval/ub-nonnull.64bit.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -37,19 +37,14 @@ LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n                00 00 00 00 00 00 00 00                         \u2502 ........\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:33:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-nonnull.rs:33:36\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               __                                              \u2502 \u2591\n-           }\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:41:1\n+  --> $DIR/ub-nonnull.rs:42:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 42, but expected something in the range 10..=30\n@@ -60,7 +55,7 @@ LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:47:1\n+  --> $DIR/ub-nonnull.rs:48:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 20, but expected something less or equal to 10, or greater or equal to 30"}, {"sha": "777c6d9880e1b0af07cd73393ccd4e6088381879", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -31,7 +31,8 @@ union MaybeUninit<T: Copy> {\n     init: T,\n }\n const UNINIT: NonZeroU8 = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n \n // Also test other uses of rustc_layout_scalar_valid_range_start\n "}, {"sha": "25560d8003d436f11463656bb9388a49611ee609", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -110,19 +110,14 @@ LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n                39 05 00 00                                     \u2502 9...\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:53:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-ref-ptr.rs:53:41\n    |\n LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized raw pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:56:1\n+  --> $DIR/ub-ref-ptr.rs:57:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n@@ -132,19 +127,14 @@ LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n                00 00 00 00                                     \u2502 ....\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:58:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-ref-ptr.rs:59:38\n    |\n LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a proper pointer or integer value\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 4, align: 4) {\n-               __ __ __ __                                     \u2502 \u2591\u2591\u2591\u2591\n-           }\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:60:1\n+  --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n@@ -155,7 +145,7 @@ LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:62:1\n+  --> $DIR/ub-ref-ptr.rs:64:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer"}, {"sha": "8c86ddbfa5f9b92764fd0ab89923a32ae855dda0", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -110,19 +110,14 @@ LL | const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n                39 05 00 00 00 00 00 00                         \u2502 9.......\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:53:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-ref-ptr.rs:53:41\n    |\n LL | const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized raw pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:56:1\n+  --> $DIR/ub-ref-ptr.rs:57:1\n    |\n LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a function pointer\n@@ -132,19 +127,14 @@ LL | const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n                00 00 00 00 00 00 00 00                         \u2502 ........\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:58:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-ref-ptr.rs:59:38\n    |\n LL | const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a proper pointer or integer value\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:60:1\n+  --> $DIR/ub-ref-ptr.rs:62:1\n    |\n LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered 0xd[noalloc], but expected a function pointer\n@@ -155,7 +145,7 @@ LL | const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref-ptr.rs:62:1\n+  --> $DIR/ub-ref-ptr.rs:64:1\n    |\n LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered alloc41, but expected a function pointer"}, {"sha": "c62848f70db04526ec2618a1bdf75715220f6be7", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -51,12 +51,14 @@ const USIZE_AS_BOX: Box<u8> = unsafe { mem::transmute(1337usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n const UNINIT_PTR: *const i32 = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n \n const NULL_FN_PTR: fn() = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n const UNINIT_FN_PTR: fn() = unsafe { MaybeUninit { uninit: () }.init };\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n const DANGLING_FN_PTR: fn() = unsafe { mem::transmute(13usize) };\n //~^ ERROR it is undefined behavior to use this value\n const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };"}, {"sha": "09a877400d0a36b74501d84efac1c87b418f6144", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.32bit.stderr", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -72,19 +72,14 @@ LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUni\n                \u257e\u2500allocN\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-wide-ptr.rs:63:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized reference\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               2a 00 00 00 __ __ __ __                         \u2502 *...\u2591\u2591\u2591\u2591\n-           }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:69:1\n+  --> $DIR/ub-wide-ptr.rs:70:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n@@ -95,7 +90,7 @@ LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:72:1\n+  --> $DIR/ub-wide-ptr.rs:73:1\n    |\n LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n@@ -106,7 +101,7 @@ LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, is\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:75:1\n+  --> $DIR/ub-wide-ptr.rs:76:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -115,7 +110,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:79:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n@@ -126,7 +121,7 @@ LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999us\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:82:1\n+  --> $DIR/ub-wide-ptr.rs:83:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -135,7 +130,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:88:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n@@ -146,7 +141,7 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:87:40\n+  --> $DIR/ub-wide-ptr.rs:88:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -155,7 +150,7 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:96:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n@@ -166,7 +161,7 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:95:42\n+  --> $DIR/ub-wide-ptr.rs:96:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -175,7 +170,7 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:100:1\n+  --> $DIR/ub-wide-ptr.rs:101:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n@@ -186,27 +181,22 @@ LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::tran\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:100:42\n+  --> $DIR/ub-wide-ptr.rs:101:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:109:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:110:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized raw pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 4) {\n-               2a 00 00 00 __ __ __ __                         \u2502 *...\u2591\u2591\u2591\u2591\n-           }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:119:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n@@ -217,7 +207,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:121:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n@@ -228,7 +218,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+  --> $DIR/ub-wide-ptr.rs:127:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n@@ -239,25 +229,25 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:128:57\n+  --> $DIR/ub-wide-ptr.rs:130:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:131:57\n+  --> $DIR/ub-wide-ptr.rs:133:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:134:56\n+  --> $DIR/ub-wide-ptr.rs:136:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n+  --> $DIR/ub-wide-ptr.rs:139:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n@@ -268,7 +258,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:142:1\n+  --> $DIR/ub-wide-ptr.rs:144:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -279,7 +269,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:147:1\n+  --> $DIR/ub-wide-ptr.rs:149:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n@@ -290,7 +280,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:149:1\n+  --> $DIR/ub-wide-ptr.rs:151:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n@@ -301,13 +291,13 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:155:5\n+  --> $DIR/ub-wide-ptr.rs:157:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:159:5\n+  --> $DIR/ub-wide-ptr.rs:161:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n@@ -339,7 +329,7 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:75:1\n+  --> $DIR/ub-wide-ptr.rs:76:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -350,7 +340,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:82:1\n+  --> $DIR/ub-wide-ptr.rs:83:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -361,7 +351,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:87:40\n+  --> $DIR/ub-wide-ptr.rs:88:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -372,7 +362,7 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:95:42\n+  --> $DIR/ub-wide-ptr.rs:96:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -383,7 +373,7 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:100:42\n+  --> $DIR/ub-wide-ptr.rs:101:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors"}, {"sha": "79fa7a83e84459db7e6d7137f088d5a1d51fbda9", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.64bit.stderr", "status": "modified", "additions": 33, "deletions": 43, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -72,19 +72,14 @@ LL | const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUni\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500allocN\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n+error[E0080]: evaluation of constant value failed\n   --> $DIR/ub-wide-ptr.rs:63:1\n    |\n LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized reference\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:69:1\n+  --> $DIR/ub-wide-ptr.rs:70:1\n    |\n LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling reference (going beyond the bounds of its allocation)\n@@ -95,7 +90,7 @@ LL | const SLICE_TOO_LONG: &[u8] = unsafe { mem::transmute((&42u8, 999usize)) };\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:72:1\n+  --> $DIR/ub-wide-ptr.rs:73:1\n    |\n LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, isize::MAX)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered invalid reference metadata: slice is bigger than largest supported object\n@@ -106,7 +101,7 @@ LL | const SLICE_TOO_LONG_OVERFLOW: &[u32] = unsafe { mem::transmute((&42u32, is\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:75:1\n+  --> $DIR/ub-wide-ptr.rs:76:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -115,7 +110,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:79:1\n+  --> $DIR/ub-wide-ptr.rs:80:1\n    |\n LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered a dangling box (going beyond the bounds of its allocation)\n@@ -126,7 +121,7 @@ LL | const SLICE_TOO_LONG_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, 999us\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:82:1\n+  --> $DIR/ub-wide-ptr.rs:83:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -135,7 +130,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:87:1\n+  --> $DIR/ub-wide-ptr.rs:88:1\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>[0]: encountered 0x03, but expected a boolean\n@@ -146,7 +141,7 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:87:40\n+  --> $DIR/ub-wide-ptr.rs:88:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -155,7 +150,7 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:95:1\n+  --> $DIR/ub-wide-ptr.rs:96:1\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.0: encountered 0x03, but expected a boolean\n@@ -166,7 +161,7 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:95:42\n+  --> $DIR/ub-wide-ptr.rs:96:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -175,7 +170,7 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:100:1\n+  --> $DIR/ub-wide-ptr.rs:101:1\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.1[0]: encountered 0x03, but expected a boolean\n@@ -186,27 +181,22 @@ LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::tran\n            }\n \n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:100:42\n+  --> $DIR/ub-wide-ptr.rs:101:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:109:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/ub-wide-ptr.rs:110:1\n    |\n LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized raw pointer\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:119:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u8))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n@@ -217,7 +207,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_1: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:121:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &3u64))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n@@ -228,7 +218,7 @@ LL | const TRAIT_OBJ_SHORT_VTABLE_2: W<&dyn Trait> = unsafe { mem::transmute(W((\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:125:1\n+  --> $DIR/ub-wide-ptr.rs:127:1\n    |\n LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, 4usize))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered 0x4[noalloc], but expected a vtable pointer\n@@ -239,25 +229,25 @@ LL | const TRAIT_OBJ_INT_VTABLE: W<&dyn Trait> = unsafe { mem::transmute(W((&92u\n            }\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:128:57\n+  --> $DIR/ub-wide-ptr.rs:130:57\n    |\n LL | const TRAIT_OBJ_UNALIGNED_VTABLE: &dyn Trait = unsafe { mem::transmute((&92u8, &[0u8; 128])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:131:57\n+  --> $DIR/ub-wide-ptr.rs:133:57\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NULL: &dyn Trait = unsafe { mem::transmute((&92u8, &[0usize; 8])) };\n    |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ub-wide-ptr.rs:134:56\n+  --> $DIR/ub-wide-ptr.rs:136:56\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_INT: &dyn Trait = unsafe { mem::transmute((&92u8, &[1usize; 8])) };\n    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:137:1\n+  --> $DIR/ub-wide-ptr.rs:139:1\n    |\n LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::transmute(W((&92u8, &[&42u8; 8]))) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .0: encountered allocN, but expected a vtable pointer\n@@ -268,7 +258,7 @@ LL | const TRAIT_OBJ_BAD_DROP_FN_NOT_FN_PTR: W<&dyn Trait> = unsafe { mem::trans\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:142:1\n+  --> $DIR/ub-wide-ptr.rs:144:1\n    |\n LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_, &bool>(&3u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .<deref>.<dyn-downcast>: encountered 0x03, but expected a boolean\n@@ -279,7 +269,7 @@ LL | const TRAIT_OBJ_CONTENT_INVALID: &dyn Trait = unsafe { mem::transmute::<_,\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:147:1\n+  --> $DIR/ub-wide-ptr.rs:149:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute((&92u8, 0usize)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered null pointer, but expected a vtable pointer\n@@ -290,7 +280,7 @@ LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { mem::transmute\n            }\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-wide-ptr.rs:149:1\n+  --> $DIR/ub-wide-ptr.rs:151:1\n    |\n LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transmute((&92u8, &3u64)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered allocN, but expected a vtable pointer\n@@ -301,13 +291,13 @@ LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { mem::transm\n            }\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:155:5\n+  --> $DIR/ub-wide-ptr.rs:157:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, 0usize))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds pointer use: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ub-wide-ptr.rs:159:5\n+  --> $DIR/ub-wide-ptr.rs:161:5\n    |\n LL |     mem::transmute::<_, &dyn Trait>((&92u8, &3u64))\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using allocN as vtable pointer but it does not point to a vtable\n@@ -339,7 +329,7 @@ LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { mem::transmute((&42u8, &3)) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:75:1\n+  --> $DIR/ub-wide-ptr.rs:76:1\n    |\n LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -350,7 +340,7 @@ LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { mem::transmute((&42u8, &3)) };\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:82:1\n+  --> $DIR/ub-wide-ptr.rs:83:1\n    |\n LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -361,7 +351,7 @@ LL | const SLICE_LENGTH_PTR_BOX: Box<[u8]> = unsafe { mem::transmute((&42u8, &3)\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:87:40\n+  --> $DIR/ub-wide-ptr.rs:88:40\n    |\n LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n    | ------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -372,7 +362,7 @@ LL | const SLICE_CONTENT_INVALID: &[bool] = &[unsafe { mem::transmute(3u8) }];\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:95:42\n+  --> $DIR/ub-wide-ptr.rs:96:42\n    |\n LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3u8) }, [false]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n@@ -383,7 +373,7 @@ LL | const MYSLICE_PREFIX_BAD: &MySliceBool = &MySlice(unsafe { mem::transmute(3\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ub-wide-ptr.rs:100:42\n+  --> $DIR/ub-wide-ptr.rs:101:42\n    |\n LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n    | --------------------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors"}, {"sha": "788403a6df67a3fd7b9ec41442aaec32cb6a4a49", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -61,7 +61,8 @@ const MYSTR_NO_INIT: &MyStr = unsafe { mem::transmute::<&[_], _>(&[MaybeUninit::\n const SLICE_VALID: &[u8] = unsafe { mem::transmute((&42u8, 1usize)) };\n // bad slice: length uninit\n const SLICE_LENGTH_UNINIT: &[u8] = unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n     let uninit_len = MaybeUninit::<usize> { uninit: () };\n     mem::transmute((42, uninit_len))\n };\n@@ -107,7 +108,8 @@ const RAW_SLICE_VALID: *const [u8] = unsafe { mem::transmute((&42u8, 1usize)) };\n const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, 999usize)) }; // ok because raw\n const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { mem::transmute((&42u8, usize::MAX)) }; // ok because raw\n const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n     let uninit_len = MaybeUninit::<usize> { uninit: () };\n     mem::transmute((42, uninit_len))\n };"}, {"sha": "d88bf2a84793a98d9d913b83f9dde11fa5990deb", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -26,7 +26,8 @@ const fn read_field2() -> Field2 {\n \n const fn read_field3() -> Field3 {\n     const FIELD3: Field3 = unsafe { UNION.field3 };\n-    //~^ ERROR it is undefined behavior to use this value\n+    //~^ ERROR evaluation of constant value failed\n+    //~| uninitialized\n     FIELD3\n     //~^ ERROR erroneous constant used [E0080]\n }"}, {"sha": "00964489e040fb821b56d469bb413f0f43994c38", "filename": "src/test/ui/consts/const-eval/union-const-eval-field.stderr", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-const-eval-field.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,16 +1,11 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-const-eval-field.rs:28:5\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/union-const-eval-field.rs:28:37\n    |\n LL |     const FIELD3: Field3 = unsafe { UNION.field3 };\n-   |     ^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                     ^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error[E0080]: erroneous constant used\n-  --> $DIR/union-const-eval-field.rs:30:5\n+  --> $DIR/union-const-eval-field.rs:31:5\n    |\n LL |     FIELD3\n    |     ^^^^^^ referenced constant has errors"}, {"sha": "dd970a355626ce0fd75e18c7c372f4846b87b947", "filename": "src/test/ui/consts/const-eval/union-ice.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -11,22 +11,28 @@ union DummyUnion {\n \n const UNION: DummyUnion = DummyUnion { field1: 1065353216 };\n \n-const FIELD3: Field3 = unsafe { UNION.field3 }; //~ ERROR it is undefined behavior to use this value\n+const FIELD3: Field3 = unsafe { UNION.field3 };\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n \n-const FIELD_PATH: Struct = Struct { //~ ERROR it is undefined behavior to use this value\n+const FIELD_PATH: Struct = Struct {\n     a: 42,\n     b: unsafe { UNION.field3 },\n+    //~^ ERROR evaluation of constant value failed\n+    //~| uninitialized\n };\n \n struct Struct {\n     a: u8,\n     b: Field3,\n }\n \n-const FIELD_PATH2: Struct2 = Struct2 { //~ ERROR it is undefined behavior to use this value\n+const FIELD_PATH2: Struct2 = Struct2 {\n     b: [\n         21,\n         unsafe { UNION.field3 },\n+        //~^ ERROR evaluation of constant value failed\n+        //~| uninitialized\n         23,\n         24,\n     ],"}, {"sha": "bd39a05510b9d35e1101b8897ec74849beb927dc", "filename": "src/test/ui/consts/const-eval/union-ice.stderr", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ice.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -1,37 +1,20 @@\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ice.rs:14:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/union-ice.rs:14:33\n    |\n LL | const FIELD3: Field3 = unsafe { UNION.field3 };\n-   | ^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected initialized bytes\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 8, align: 8) {\n-               __ __ __ __ __ __ __ __                         \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+   |                                 ^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ice.rs:16:1\n-   |\n-LL | const FIELD_PATH: Struct = Struct {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .b: encountered uninitialized bytes, but expected initialized bytes\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/union-ice.rs:20:17\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 16, align: 8) {\n-               __ __ __ __ __ __ __ __ 2a __ __ __ __ __ __ __ \u2502 \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591*\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+LL |     b: unsafe { UNION.field3 },\n+   |                 ^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ice.rs:26:1\n-   |\n-LL | const FIELD_PATH2: Struct2 = Struct2 {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value at .b[1]: encountered uninitialized bytes\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/union-ice.rs:33:18\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 40, align: 8) {\n-               0x00 \u2502 15 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __ \u2502 ........\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-               0x10 \u2502 17 00 00 00 00 00 00 00 18 00 00 00 00 00 00 00 \u2502 ................\n-               0x20 \u2502 2a __ __ __ __ __ __ __                         \u2502 *\u2591\u2591\u2591\u2591\u2591\u2591\u2591\n-           }\n+LL |         unsafe { UNION.field3 },\n+   |                  ^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 3 previous errors\n "}, {"sha": "38ded4d65cfb6a7290afce0855ca9b285dc96f77", "filename": "src/test/ui/consts/const-eval/union-ub.32bit.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.32bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -9,16 +9,11 @@ LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n                2a                                              \u2502 *\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub.rs:35:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/union-ub.rs:35:36\n    |\n LL | const UNINIT_BOOL: bool = unsafe { DummyUnion { unit: () }.bool};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               __                                              \u2502 \u2591\n-           }\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 2 previous errors\n "}, {"sha": "38ded4d65cfb6a7290afce0855ca9b285dc96f77", "filename": "src/test/ui/consts/const-eval/union-ub.64bit.stderr", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.64bit.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -9,16 +9,11 @@ LL | const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n                2a                                              \u2502 *\n            }\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub.rs:35:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/union-ub.rs:35:36\n    |\n LL | const UNINIT_BOOL: bool = unsafe { DummyUnion { unit: () }.bool};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^ constructing invalid value: encountered uninitialized bytes, but expected a boolean\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n-   = note: the raw bytes of the constant (size: 1, align: 1) {\n-               __                                              \u2502 \u2591\n-           }\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n \n error: aborting due to 2 previous errors\n "}, {"sha": "bb29edcf8b0118b18643259f35570f3759e10173", "filename": "src/test/ui/consts/const-eval/union-ub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Funion-ub.rs?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -33,7 +33,8 @@ union Bar {\n const BAD_BOOL: bool = unsafe { DummyUnion { u8: 42 }.bool};\n //~^ ERROR it is undefined behavior to use this value\n const UNINIT_BOOL: bool = unsafe { DummyUnion { unit: () }.bool};\n-//~^ ERROR it is undefined behavior to use this value\n+//~^ ERROR evaluation of constant value failed\n+//~| uninitialized\n \n // The value is not valid for any union variant, but that's fine\n // unions are just a convenient way to transmute bits around"}, {"sha": "b940a77f8a5090e5bad204970493e587f1e1f2ff", "filename": "src/test/ui/consts/extra-const-ub/detect-extra-ub.with_flag.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fdetect-extra-ub.with_flag.stderr?ref=2b443a8d97ff1f26c35e4bcf682bf9a89e8a66d2", "patch": "@@ -8,13 +8,13 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/detect-extra-ub.rs:15:21\n    |\n LL |     let _x: usize = transmute(&3u8);\n-   |                     ^^^^^^^^^^^^^^^ constructing invalid value: encountered (potentially part of) a pointer, but expected plain (non-pointer) bytes\n+   |                     ^^^^^^^^^^^^^^^ constructing invalid value: encountered (potentially part of) a pointer, but expected an integer\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/detect-extra-ub.rs:22:30\n    |\n LL |     let _x: (usize, usize) = transmute(x);\n-   |                              ^^^^^^^^^^^^ constructing invalid value at .0: encountered (potentially part of) a pointer, but expected plain (non-pointer) bytes\n+   |                              ^^^^^^^^^^^^ constructing invalid value at .0: encountered (potentially part of) a pointer, but expected an integer\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/detect-extra-ub.rs:28:20"}]}