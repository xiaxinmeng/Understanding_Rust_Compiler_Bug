{"sha": "53eab246db86d0b2a0e664196dcd434746724e8b", "node_id": "C_kwDOAAsO6NoAKDUzZWFiMjQ2ZGI4NmQwYjJhMGU2NjQxOTZkY2Q0MzQ3NDY3MjRlOGI", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2022-11-23T03:54:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-23T03:54:38Z"}, "message": "Rollup merge of #103488 - oli-obk:impl_trait_for_tait, r=lcnr\n\nAllow opaque types in trait impl headers and rely on coherence to reject unsound cases\n\nr? ````@lcnr````\n\nfixes #99840", "tree": {"sha": "e59e08ef65d198d4470e019c2a4d56da905a498e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e59e08ef65d198d4470e019c2a4d56da905a498e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53eab246db86d0b2a0e664196dcd434746724e8b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjfZl+CRBK7hj4Ov3rIwAAk1IIAByvtBdtdEitzqvWQVOz1OKW\nh+HU6MSx134EoWmWMTMtepy2dlBDtx8jc2squYGK68SOyB1WlncfalRBYQvvHFzX\n0GRTJMCgeCIt+6wQMwR4NrjKNK0IY8Tt4VfxMRWE8SZ0WnnESH4TlcdOVPGxVhw0\nbevHlvGVjGCHefYp0dLane/6LPfpeSli3tsxCUxvuqUx0OedXDAxSuZ9H71dsGNg\nbm2TeA/mvs0tPZ/f4o8+kBscpjpBgujXmEaGTmM0ssEKtfj+LMssmZkhZ+XRKd5m\nqlRhqKQFEAdgcOMrmiiHrl0Q0DUDKfYdC0KYhmlU3J7XO7HQk3Ykhf5q7h9XGIM=\n=zx5r\n-----END PGP SIGNATURE-----\n", "payload": "tree e59e08ef65d198d4470e019c2a4d56da905a498e\nparent 604d52108e9272d75618ab6a7b5eb006857fce52\nparent c16a90f5e3cb26b15e12c8d24d7b1cafbe90e24a\nauthor Manish Goregaokar <manishsmail@gmail.com> 1669175678 -0500\ncommitter GitHub <noreply@github.com> 1669175678 -0500\n\nRollup merge of #103488 - oli-obk:impl_trait_for_tait, r=lcnr\n\nAllow opaque types in trait impl headers and rely on coherence to reject unsound cases\n\nr? ````@lcnr````\n\nfixes #99840\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53eab246db86d0b2a0e664196dcd434746724e8b", "html_url": "https://github.com/rust-lang/rust/commit/53eab246db86d0b2a0e664196dcd434746724e8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53eab246db86d0b2a0e664196dcd434746724e8b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "604d52108e9272d75618ab6a7b5eb006857fce52", "url": "https://api.github.com/repos/rust-lang/rust/commits/604d52108e9272d75618ab6a7b5eb006857fce52", "html_url": "https://github.com/rust-lang/rust/commit/604d52108e9272d75618ab6a7b5eb006857fce52"}, {"sha": "c16a90f5e3cb26b15e12c8d24d7b1cafbe90e24a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16a90f5e3cb26b15e12c8d24d7b1cafbe90e24a", "html_url": "https://github.com/rust-lang/rust/commit/c16a90f5e3cb26b15e12c8d24d7b1cafbe90e24a"}], "stats": {"total": 854, "additions": 543, "deletions": 311}, "files": [{"sha": "b2702eafd33bd8cec66eca5c29241d2ea8417acd", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -2,9 +2,8 @@ use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRe\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::TypeRelation;\n-use rustc_middle::ty::{self, Const, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::Fallible;\n \n@@ -141,13 +140,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         );\n     }\n \n-    // We don't have to worry about the equality of consts during borrow checking\n-    // as consts always have a static lifetime.\n-    // FIXME(oli-obk): is this really true? We can at least have HKL and with\n-    // inline consts we may have further lifetimes that may be unsound to treat as\n-    // 'static.\n-    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {}\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }\n@@ -156,10 +148,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         true\n     }\n \n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: PredicateObligations<'tcx>,\n-    ) -> Result<(), TypeError<'tcx>> {\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.type_checker\n             .fully_perform_op(\n                 self.locations,\n@@ -172,6 +161,5 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n                 },\n             )\n             .unwrap();\n-        Ok(())\n     }\n }"}, {"sha": "e0b465bab16d9bb0f8790ab2c414a3a95f3d5fcc", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -244,6 +244,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         self.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -256,6 +260,10 @@ impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "d66b6585fb6f7c10d27304bc5741a88818145bef", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, DelayDm};\n use rustc_errors::{Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IgnoreRegions;\n use rustc_middle::ty::{\n@@ -47,58 +46,6 @@ fn do_orphan_check_impl<'tcx>(\n     let sp = tcx.def_span(def_id);\n     let tr = impl_.of_trait.as_ref().unwrap();\n \n-    // Ensure no opaque types are present in this impl header. See issues #76202 and #86411 for examples,\n-    // and #84660 where it would otherwise allow unsoundness.\n-    if trait_ref.has_opaque_types() {\n-        trace!(\"{:#?}\", item);\n-        // First we find the opaque type in question.\n-        for ty in trait_ref.substs {\n-            for ty in ty.walk() {\n-                let ty::subst::GenericArgKind::Type(ty) = ty.unpack() else { continue };\n-                let ty::Opaque(def_id, _) = *ty.kind() else { continue };\n-                trace!(?def_id);\n-\n-                // Then we search for mentions of the opaque type's type alias in the HIR\n-                struct SpanFinder<'tcx> {\n-                    sp: Span,\n-                    def_id: DefId,\n-                    tcx: TyCtxt<'tcx>,\n-                }\n-                impl<'v, 'tcx> hir::intravisit::Visitor<'v> for SpanFinder<'tcx> {\n-                    #[instrument(level = \"trace\", skip(self, _id))]\n-                    fn visit_path(&mut self, path: &'v hir::Path<'v>, _id: hir::HirId) {\n-                        // You can't mention an opaque type directly, so we look for type aliases\n-                        if let hir::def::Res::Def(hir::def::DefKind::TyAlias, def_id) = path.res {\n-                            // And check if that type alias's type contains the opaque type we're looking for\n-                            for arg in self.tcx.type_of(def_id).walk() {\n-                                if let GenericArgKind::Type(ty) = arg.unpack() {\n-                                    if let ty::Opaque(def_id, _) = *ty.kind() {\n-                                        if def_id == self.def_id {\n-                                            // Finally we update the span to the mention of the type alias\n-                                            self.sp = path.span;\n-                                            return;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        hir::intravisit::walk_path(self, path)\n-                    }\n-                }\n-\n-                let mut visitor = SpanFinder { sp, def_id, tcx };\n-                hir::intravisit::walk_item(&mut visitor, item);\n-                let reported = tcx\n-                    .sess\n-                    .struct_span_err(visitor.sp, \"cannot implement trait on type alias impl trait\")\n-                    .span_note(tcx.def_span(def_id), \"type alias impl trait defined here\")\n-                    .emit();\n-                return Err(reported);\n-            }\n-        }\n-        span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n-    }\n-\n     match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error("}, {"sha": "bae43138b4d520ef56765809865e6def7565f589", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -517,6 +517,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "f0381353551c2b1a0ed5c0b58db47048a85631ed", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -59,6 +59,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Coerce(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::Ambiguous\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }"}, {"sha": "c7bfe99aa9a8a0ab03025901e7d947f1bb9cb4d8", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -702,6 +702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // code is looking for a self type of an unresolved\n                 // inference variable.\n                 | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             },\n         )"}, {"sha": "44c3edf06a8837a492959696d9beb06aebd15dbe", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -803,6 +803,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::TypeOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });"}, {"sha": "2483ab724a4e32142a0e7078f1a277d22ba38131", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -81,6 +81,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 .normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate: self.intercrate,\n         }\n     }\n }"}, {"sha": "b4a427a5d419a9519c127d76947841b303b70cd0", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -23,11 +23,10 @@ use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, BoundVar, Const, ToPredicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, BoundVar, ToPredicate, Ty, TyCtxt};\n use rustc_span::Span;\n use std::fmt::Debug;\n use std::iter;\n@@ -729,10 +728,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         });\n     }\n \n-    fn const_equate(&mut self, _a: Const<'tcx>, _b: Const<'tcx>) {\n-        span_bug!(self.cause.span(), \"generic_const_exprs: unreachable `const_equate`\");\n-    }\n-\n     fn normalization() -> NormalizationStrategy {\n         NormalizationStrategy::Eager\n     }\n@@ -741,11 +736,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         true\n     }\n \n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: PredicateObligations<'tcx>,\n-    ) -> Result<(), TypeError<'tcx>> {\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.obligations.extend(obligations);\n-        Ok(())\n     }\n }"}, {"sha": "eec938cefbb70a0494b1e0f000c3a3338c174236", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -450,6 +450,15 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             ty::Binder::dummy(predicate),\n         ));\n     }\n+\n+    pub fn mark_ambiguous(&mut self) {\n+        self.obligations.push(Obligation::new(\n+            self.tcx(),\n+            self.trace.cause.clone(),\n+            self.param_env,\n+            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n+        ));\n+    }\n }\n \n struct Generalizer<'cx, 'tcx> {\n@@ -521,6 +530,11 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -533,6 +547,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        span_bug!(self.cause.span, \"opaque types are handled in `tys`\");\n+    }\n+\n     fn binders<T>(\n         &mut self,\n         a: ty::Binder<'tcx, T>,\n@@ -657,6 +675,10 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 // relatable.\n                 Ok(t)\n             }\n+            ty::Opaque(def_id, substs) => {\n+                let s = self.relate(substs, substs)?;\n+                Ok(if s == substs { t } else { self.infcx.tcx.mk_opaque(def_id, s) })\n+            }\n             _ => relate::super_relate_tys(self, t, t),\n         }?;\n \n@@ -799,6 +821,11 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.infcx.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n@@ -811,6 +838,10 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "8682f4d3b7aed970783395d50e8ca09a8b648d64", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -32,6 +32,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.fields.tcx()\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.fields.param_env\n     }\n@@ -40,6 +44,10 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        self.fields.mark_ambiguous();\n+    }\n+\n     fn relate_item_substs(\n         &mut self,\n         _item_def_id: DefId,"}, {"sha": "0dee3be705474ac01ae178b18d05c28fef924e72", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -2937,6 +2937,11 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         self.0.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.0.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         // Unused, only for consts which we treat as always equal\n         ty::ParamEnv::empty()\n@@ -2950,6 +2955,10 @@ impl<'tcx> TypeRelation<'tcx> for SameTypeModuloInfer<'_, 'tcx> {\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: relate::Relate<'tcx>>(\n         &mut self,\n         _variance: ty::Variance,"}, {"sha": "7f27b35a54e4f8808c0350a30677abd61d77bed8", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -30,6 +30,11 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         \"Glb\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.fields.infcx.intercrate);\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -42,6 +47,10 @@ impl<'tcx> TypeRelation<'tcx> for Glb<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!(\"mark_ambiguous used outside of coherence\");\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "97ed4729bd0d9e67af8250645909cc3ba567950a", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -30,6 +30,11 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         \"Lub\"\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.fields.infcx.intercrate);\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.tcx()\n     }\n@@ -42,6 +47,10 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!(\"mark_ambiguous used outside of coherence\");\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "2798477d1815d81f70d2fc7e741e4e6e1dffa722", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -337,6 +337,26 @@ pub struct InferCtxt<'tcx> {\n \n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n+\n+    /// During coherence we have to assume that other crates may add\n+    /// additional impls which we currently don't know about.\n+    ///\n+    /// To deal with this evaluation should be conservative\n+    /// and consider the possibility of impls from outside this crate.\n+    /// This comes up primarily when resolving ambiguity. Imagine\n+    /// there is some trait reference `$0: Bar` where `$0` is an\n+    /// inference variable. If `intercrate` is true, then we can never\n+    /// say for sure that this reference is not implemented, even if\n+    /// there are *no impls at all for `Bar`*, because `$0` could be\n+    /// bound to some type that in a downstream crate that implements\n+    /// `Bar`.\n+    ///\n+    /// Outside of coherence we set this to false because we are only\n+    /// interested in types that the user could actually have written.\n+    /// In other words, we consider `$0: Bar` to be unimplemented if\n+    /// there is no type that the user could *actually name* that\n+    /// would satisfy it. This avoids crippling inference, basically.\n+    pub intercrate: bool,\n }\n \n /// See the `error_reporting` module for more details.\n@@ -552,6 +572,8 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n+    /// Whether we are in coherence mode.\n+    intercrate: bool,\n     normalize_fn_sig_for_diagnostic:\n         Option<Lrc<dyn Fn(&InferCtxt<'tcx>, ty::PolyFnSig<'tcx>) -> ty::PolyFnSig<'tcx>>>,\n }\n@@ -567,6 +589,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n             normalize_fn_sig_for_diagnostic: None,\n+            intercrate: false,\n         }\n     }\n }\n@@ -583,6 +606,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn intercrate(mut self) -> Self {\n+        self.intercrate = true;\n+        self\n+    }\n+\n     pub fn ignoring_regions(mut self) -> Self {\n         self.considering_regions = false;\n         self\n@@ -622,6 +650,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             defining_use_anchor,\n             considering_regions,\n             ref normalize_fn_sig_for_diagnostic,\n+            intercrate,\n         } = *self;\n         InferCtxt {\n             tcx,\n@@ -641,6 +670,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             normalize_fn_sig_for_diagnostic: normalize_fn_sig_for_diagnostic\n                 .as_ref()\n                 .map(|f| f.clone()),\n+            intercrate,\n         }\n     }\n }"}, {"sha": "4f8460955c3de0d4098673c597666ecc09d52dbf", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -25,7 +25,7 @@ use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::traits::PredicateObligation;\n+use crate::traits::{Obligation, PredicateObligation};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n@@ -92,11 +92,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n-    fn const_equate(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n-    fn register_opaque_type_obligations(\n-        &mut self,\n-        obligations: Vec<PredicateObligation<'tcx>>,\n-    ) -> Result<(), TypeError<'tcx>>;\n+    fn register_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n@@ -419,7 +415,7 @@ where\n             .infcx\n             .handle_opaque_type(a, b, true, &cause, self.delegate.param_env())?\n             .obligations;\n-        self.delegate.register_opaque_type_obligations(obligations)?;\n+        self.delegate.register_obligations(obligations);\n         trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n         Ok(a)\n     }\n@@ -531,6 +527,10 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        self.infcx.intercrate\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -543,6 +543,17 @@ where\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        let cause = ObligationCause::dummy_with_span(self.delegate.span());\n+        let param_env = self.delegate.param_env();\n+        self.delegate.register_obligations(vec![Obligation::new(\n+            self.tcx(),\n+            cause,\n+            param_env,\n+            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n+        )]);\n+    }\n+\n     #[instrument(skip(self, info), level = \"trace\", ret)]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n@@ -800,8 +811,12 @@ impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.delegate.const_equate(a, b);\n+    fn const_equate_obligation(&mut self, _a: ty::Const<'tcx>, _b: ty::Const<'tcx>) {\n+        // We don't have to worry about the equality of consts during borrow checking\n+        // as consts always have a static lifetime.\n+        // FIXME(oli-obk): is this really true? We can at least have HKL and with\n+        // inline consts we may have further lifetimes that may be unsound to treat as\n+        // 'static.\n     }\n }\n \n@@ -898,6 +913,11 @@ where\n         self.infcx.tcx\n     }\n \n+    fn intercrate(&self) -> bool {\n+        assert!(!self.infcx.intercrate);\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.delegate.param_env()\n     }\n@@ -910,6 +930,10 @@ where\n         true\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,"}, {"sha": "8f7805794513d7cd0056c29c1a5f4ca709cb0ae8", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -29,6 +29,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))"}, {"sha": "5d204dd70ed0cb2c838aba7b53971cdd83d313ad", "filename": "compiler/rustc_infer/src/infer/outlives/test_type_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Ftest_type_match.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -136,6 +136,11 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Match\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -146,6 +151,10 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n         true\n     } // irrelevant\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "2c6987cc3f45670d5290b6ba8d04ecc9d3d0aae2", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -35,6 +35,11 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn tag(&self) -> &'static str {\n         \"Sub\"\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        self.fields.infcx.intercrate\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.fields.infcx.tcx\n     }\n@@ -47,6 +52,10 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n         self.a_is_expected\n     }\n \n+    fn mark_ambiguous(&mut self) {\n+        self.fields.mark_ambiguous()\n+    }\n+\n     fn with_cause<F, R>(&mut self, cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,"}, {"sha": "b2a31ac7e6f1af2dda0c165198532f377c834a6d", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -285,6 +285,7 @@ impl<'tcx> Elaborator<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 // Nothing to elaborate\n             }\n+            ty::PredicateKind::Ambiguous => {}\n         }\n     }\n }"}, {"sha": "ada3c3b67fb051f2d0e058083666c030ba308db7", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1659,6 +1659,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     Coerce(..) |\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n+                    Ambiguous |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {"}, {"sha": "cd147d7e55813d5b4aaec1ab09461a4fd6405abd", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -36,13 +36,22 @@ impl<'tcx> TypeRelation<'tcx> for Match<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n+\n+    fn intercrate(&self) -> bool {\n+        false\n+    }\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx> {\n         self.param_env\n     }\n     fn a_is_expected(&self) -> bool {\n         true\n     } // irrelevant\n \n+    fn mark_ambiguous(&mut self) {\n+        bug!()\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         _: ty::Variance,"}, {"sha": "1ee4985cf8de044ae3c69696403b3999455d51d4", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -42,7 +42,6 @@ where\n     ClosureSimplifiedType(D),\n     GeneratorSimplifiedType(D),\n     GeneratorWitnessSimplifiedType(usize),\n-    OpaqueSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     PlaceholderSimplifiedType,\n }\n@@ -127,7 +126,7 @@ pub fn simplify_type<'tcx>(\n             TreatParams::AsPlaceholder => Some(PlaceholderSimplifiedType),\n             TreatParams::AsInfer => None,\n         },\n-        ty::Projection(_) => match treat_params {\n+        ty::Opaque(..) | ty::Projection(_) => match treat_params {\n             // When treating `ty::Param` as a placeholder, projections also\n             // don't unify with anything else as long as they are fully normalized.\n             //\n@@ -138,7 +137,6 @@ pub fn simplify_type<'tcx>(\n             }\n             TreatParams::AsPlaceholder | TreatParams::AsInfer => None,\n         },\n-        ty::Opaque(def_id, _) => Some(OpaqueSimplifiedType(def_id)),\n         ty::Foreign(def_id) => Some(ForeignSimplifiedType(def_id)),\n         ty::Bound(..) | ty::Infer(_) | ty::Error(_) => None,\n     }\n@@ -151,8 +149,7 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             | ForeignSimplifiedType(d)\n             | TraitSimplifiedType(d)\n             | ClosureSimplifiedType(d)\n-            | GeneratorSimplifiedType(d)\n-            | OpaqueSimplifiedType(d) => Some(d),\n+            | GeneratorSimplifiedType(d) => Some(d),\n             _ => None,\n         }\n     }\n@@ -182,7 +179,6 @@ impl<D: Copy + Debug + Eq> SimplifiedTypeGen<D> {\n             ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n             GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n             GeneratorWitnessSimplifiedType(n) => GeneratorWitnessSimplifiedType(n),\n-            OpaqueSimplifiedType(d) => OpaqueSimplifiedType(map(d)),\n             FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n             PlaceholderSimplifiedType => PlaceholderSimplifiedType,\n         }\n@@ -229,7 +225,7 @@ impl DeepRejectCtxt {\n         match impl_ty.kind() {\n             // Start by checking whether the type in the impl may unify with\n             // pretty much everything. Just return `true` in that case.\n-            ty::Param(_) | ty::Projection(_) | ty::Error(_) => return true,\n+            ty::Param(_) | ty::Projection(_) | ty::Error(_) | ty::Opaque(..) => return true,\n             // These types only unify with inference variables or their own\n             // variant.\n             ty::Bool\n@@ -247,8 +243,7 @@ impl DeepRejectCtxt {\n             | ty::Never\n             | ty::Tuple(..)\n             | ty::FnPtr(..)\n-            | ty::Foreign(..)\n-            | ty::Opaque(..) => {}\n+            | ty::Foreign(..) => {}\n             ty::FnDef(..)\n             | ty::Closure(..)\n             | ty::Generator(..)\n@@ -328,10 +323,7 @@ impl DeepRejectCtxt {\n                 _ => false,\n             },\n \n-            // Opaque types in impls should be forbidden, but that doesn't\n-            // stop compilation. So this match arm should never return true\n-            // if compilation succeeds.\n-            ty::Opaque(..) => matches!(k, ty::Opaque(..)),\n+            ty::Opaque(..) => true,\n \n             // Impls cannot contain these types as these cannot be named directly.\n             ty::FnDef(..) | ty::Closure(..) | ty::Generator(..) => false,"}, {"sha": "ee4b8f91c54873a075d1ed9712359e231b02fa86", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -259,6 +259,7 @@ impl FlagComputation {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n+            ty::PredicateKind::Ambiguous => {}\n         }\n     }\n "}, {"sha": "0458c4abd3d4cbe9ca9f3fa4367ea58e165f3297", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -620,6 +620,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Coerce(_)\n             | PredicateKind::ConstEvaluatable(_)\n             | PredicateKind::ConstEquate(_, _)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(_) => true,\n         }\n     }\n@@ -702,6 +703,10 @@ pub enum PredicateKind<'tcx> {\n     ///\n     /// Only used for Chalk.\n     TypeWellFormedFromEnv(Ty<'tcx>),\n+\n+    /// A marker predicate that is always ambiguous.\n+    /// Used for coherence to mark opaque types as possibly equal to each other but ambiguous.\n+    Ambiguous,\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -1186,6 +1191,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1204,6 +1210,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::TypeOutlives(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n@@ -1222,6 +1229,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::ClosureKind(..)\n             | PredicateKind::ConstEvaluatable(..)\n             | PredicateKind::ConstEquate(..)\n+            | PredicateKind::Ambiguous\n             | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }"}, {"sha": "bddcdd0b693caf367e739a5482b1f68e1ddecc34", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -2704,6 +2704,7 @@ define_print_and_forward_display! {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n+            ty::PredicateKind::Ambiguous => p!(\"ambiguous\"),\n         }\n     }\n "}, {"sha": "3d47b71b7ce62ea8df8754ae1502699df4679f1b", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -23,6 +23,8 @@ pub enum Cause {\n pub trait TypeRelation<'tcx>: Sized {\n     fn tcx(&self) -> TyCtxt<'tcx>;\n \n+    fn intercrate(&self) -> bool;\n+\n     fn param_env(&self) -> ty::ParamEnv<'tcx>;\n \n     /// Returns a static string we can use for printouts.\n@@ -32,6 +34,9 @@ pub trait TypeRelation<'tcx>: Sized {\n     /// relation. Just affects error messages.\n     fn a_is_expected(&self) -> bool;\n \n+    /// Used during coherence. If called, must emit an always-ambiguous obligation.\n+    fn mark_ambiguous(&mut self);\n+\n     fn with_cause<F, R>(&mut self, _cause: Cause, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n@@ -562,16 +567,23 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let opt_variances = tcx.variances_of(a_def_id);\n-            let substs = relate_substs_with_variances(\n-                relation,\n-                a_def_id,\n-                opt_variances,\n-                a_substs,\n-                b_substs,\n-                false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n-            )?;\n-            Ok(tcx.mk_opaque(a_def_id, substs))\n+            if relation.intercrate() {\n+                // During coherence, opaque types should be treated as equal to each other, even if their generic params\n+                // differ, as they could resolve to the same hidden type, even for different generic params.\n+                relation.mark_ambiguous();\n+                Ok(a)\n+            } else {\n+                let opt_variances = tcx.variances_of(a_def_id);\n+                let substs = relate_substs_with_variances(\n+                    relation,\n+                    a_def_id,\n+                    opt_variances,\n+                    a_substs,\n+                    b_substs,\n+                    false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n+                )?;\n+                Ok(tcx.mk_opaque(a_def_id, substs))\n+            }\n         }\n \n         _ => Err(TypeError::Sorts(expected_found(relation, a, b))),"}, {"sha": "64b4fd11762522159beb29ec3368466be0c3c10a", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -173,6 +173,7 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n+            ty::PredicateKind::Ambiguous => write!(f, \"Ambiguous\"),\n         }\n     }\n }"}, {"sha": "78af187cd8f80216661c35c502bcc5633ae70788", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -841,6 +841,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+                ty::PredicateKind::Ambiguous => return false,\n             };\n         }\n         true"}, {"sha": "741bf206d037e20a15693f5a51af3386c584472a", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -18,7 +18,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::CRATE_HIR_ID;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n@@ -94,8 +94,9 @@ pub fn overlapping_impls<'tcx>(\n         return None;\n     }\n \n-    let infcx = tcx.infer_ctxt().build();\n-    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n     let overlaps =\n         overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n     if !overlaps {\n@@ -105,8 +106,9 @@ pub fn overlapping_impls<'tcx>(\n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx = tcx.infer_ctxt().build();\n-    let selcx = &mut SelectionContext::intercrate(&infcx);\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).intercrate().build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n     selcx.enable_tracking_intercrate_ambiguity_causes();\n     Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n }"}, {"sha": "ef3d300020a39086edaa7cb0f0a2ee80c20f83ba", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1168,6 +1168,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         )\n                     }\n \n+                    ty::PredicateKind::Ambiguous => span_bug!(span, \"ambiguous\"),\n+\n                     ty::PredicateKind::TypeWellFormedFromEnv(..) => span_bug!(\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\""}, {"sha": "d238e7556aea33a45c5a27a947db829e89594ad3", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -336,6 +336,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         ty::Binder::dummy(infcx.replace_bound_vars_with_placeholders(binder));\n                     ProcessResult::Changed(mk_pending(vec![obligation.with(infcx.tcx, pred)]))\n                 }\n+                ty::PredicateKind::Ambiguous => ProcessResult::Unchanged,\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n@@ -569,6 +570,7 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                         }\n                     }\n                 }\n+                ty::PredicateKind::Ambiguous => ProcessResult::Unchanged,\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }"}, {"sha": "7c4c58ba361670f6429abd50bbf636876cdcc441", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -319,6 +319,7 @@ fn predicate_references_self<'tcx>(\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }\n@@ -350,6 +351,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::TypeOutlives(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }\n     })"}, {"sha": "2803a2d38c807b97143273d8b24f59d5acbe138f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 13, "deletions": 36, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -110,25 +110,6 @@ pub struct SelectionContext<'cx, 'tcx> {\n     /// require themselves.\n     freshener: TypeFreshener<'cx, 'tcx>,\n \n-    /// During coherence we have to assume that other crates may add\n-    /// additional impls which we currently don't know about.\n-    ///\n-    /// To deal with this evaluation should be conservative\n-    /// and consider the possibility of impls from outside this crate.\n-    /// This comes up primarily when resolving ambiguity. Imagine\n-    /// there is some trait reference `$0: Bar` where `$0` is an\n-    /// inference variable. If `intercrate` is true, then we can never\n-    /// say for sure that this reference is not implemented, even if\n-    /// there are *no impls at all for `Bar`*, because `$0` could be\n-    /// bound to some type that in a downstream crate that implements\n-    /// `Bar`.\n-    ///\n-    /// Outside of coherence we set this to false because we are only\n-    /// interested in types that the user could actually have written.\n-    /// In other words, we consider `$0: Bar` to be unimplemented if\n-    /// there is no type that the user could *actually name* that\n-    /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: bool,\n     /// If `intercrate` is set, we remember predicates which were\n     /// considered ambiguous because of impls potentially added in other crates.\n     /// This is used in coherence to give improved diagnostics.\n@@ -226,16 +207,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener_keep_static(),\n-            intercrate: false,\n             intercrate_ambiguity_causes: None,\n             query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'tcx>) -> SelectionContext<'cx, 'tcx> {\n-        SelectionContext { intercrate: true, ..SelectionContext::new(infcx) }\n-    }\n-\n     pub fn with_query_mode(\n         infcx: &'cx InferCtxt<'tcx>,\n         query_mode: TraitQueryMode,\n@@ -247,7 +223,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Enables tracking of intercrate ambiguity causes. See\n     /// the documentation of [`Self::intercrate_ambiguity_causes`] for more.\n     pub fn enable_tracking_intercrate_ambiguity_causes(&mut self) {\n-        assert!(self.intercrate);\n+        assert!(self.is_intercrate());\n         assert!(self.intercrate_ambiguity_causes.is_none());\n         self.intercrate_ambiguity_causes = Some(FxIndexSet::default());\n         debug!(\"selcx: enable_tracking_intercrate_ambiguity_causes\");\n@@ -257,7 +233,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// was enabled and disables tracking at the same time. If\n     /// tracking is not enabled, just returns an empty vector.\n     pub fn take_intercrate_ambiguity_causes(&mut self) -> FxIndexSet<IntercrateAmbiguityCause> {\n-        assert!(self.intercrate);\n+        assert!(self.is_intercrate());\n         self.intercrate_ambiguity_causes.take().unwrap_or_default()\n     }\n \n@@ -270,7 +246,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     pub fn is_intercrate(&self) -> bool {\n-        self.intercrate\n+        self.infcx.intercrate\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -741,6 +717,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n+                ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n             }\n         })\n     }\n@@ -751,7 +728,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n         mut obligation: TraitObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        if !self.intercrate\n+        if !self.is_intercrate()\n             && obligation.is_global()\n             && obligation.param_env.caller_bounds().iter().all(|bound| bound.needs_subst())\n         {\n@@ -1014,7 +991,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return None;\n         }\n \n@@ -1044,7 +1021,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return;\n         }\n \n@@ -1225,9 +1202,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn is_knowable<'o>(&mut self, stack: &TraitObligationStack<'o, 'tcx>) -> Result<(), Conflict> {\n-        debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n+        debug!(\"is_knowable(intercrate={:?})\", self.is_intercrate());\n \n-        if !self.intercrate || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n+        if !self.is_intercrate() || stack.obligation.polarity() == ty::ImplPolarity::Negative {\n             return Ok(());\n         }\n \n@@ -1258,7 +1235,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate, I don't think.\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return false;\n         }\n \n@@ -1275,7 +1252,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return None;\n         }\n         let tcx = self.tcx();\n@@ -1314,7 +1291,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // mode, so don't do any caching. In particular, we might\n         // re-use the same `InferCtxt` with both an intercrate\n         // and non-intercrate `SelectionContext`\n-        if self.intercrate {\n+        if self.is_intercrate() {\n             return false;\n         }\n         match result {\n@@ -2191,7 +2168,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{e}`\"))?;\n         nested_obligations.extend(obligations);\n \n-        if !self.intercrate\n+        if !self.is_intercrate()\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {\n             debug!(\"reservation impls only apply in intercrate mode\");"}, {"sha": "5e506a23f383f353cdbdd035f95b07660efbf397", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -155,6 +155,7 @@ pub fn predicate_obligations<'tcx>(\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n+        ty::PredicateKind::Ambiguous => {}\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }\n@@ -875,6 +876,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::RegionOutlives(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty"}, {"sha": "ee013515e86c410b9a4f19597e8bc0921ee73a52", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -121,6 +121,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::Ambiguous\n                 | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n             let value = chalk_ir::ProgramClauseImplication {\n@@ -212,6 +213,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n@@ -625,6 +627,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n@@ -754,6 +757,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }"}, {"sha": "2d1a386992617260d52a5313dba1f60dad4d2b54", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -97,6 +97,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ConstEvaluatable(..)\n                     | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::Ambiguous\n                     | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                     ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);"}, {"sha": "5200908527a1610f9d072b4cd8a041bc4d1c41e8", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -66,6 +66,7 @@ fn not_outlives_predicate<'tcx>(p: ty::Predicate<'tcx>) -> bool {\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,\n     }\n }"}, {"sha": "b5d4ab55b4a8363f16f8f4700ec2914a780ea2dd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -318,6 +318,7 @@ pub(crate) fn clean_predicate<'tcx>(\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::Ambiguous\n         | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n     }\n }"}, {"sha": "5b6a62b24d4b32281173d42358401d8fc2788ebc", "filename": "src/test/ui/coherence/coherence-with-closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -8,7 +8,6 @@ fn defining_use() -> OpaqueClosure {\n struct Wrapper<T>(T);\n trait Trait {}\n impl Trait for Wrapper<OpaqueClosure> {}\n-//~^ ERROR cannot implement trait on type alias impl trait\n impl<T: Sync> Trait for Wrapper<T> {}\n //~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueClosure>`\n "}, {"sha": "431108e14d7d85949809482b045d2d3fb433f35d", "filename": "src/test/ui/coherence/coherence-with-closure.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-closure.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,24 +1,11 @@\n error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueClosure>`\n-  --> $DIR/coherence-with-closure.rs:12:1\n+  --> $DIR/coherence-with-closure.rs:11:1\n    |\n LL | impl Trait for Wrapper<OpaqueClosure> {}\n    | ------------------------------------- first implementation here\n-LL |\n LL | impl<T: Sync> Trait for Wrapper<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Wrapper<OpaqueClosure>`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/coherence-with-closure.rs:10:24\n-   |\n-LL | impl Trait for Wrapper<OpaqueClosure> {}\n-   |                        ^^^^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/coherence-with-closure.rs:3:22\n-   |\n-LL | type OpaqueClosure = impl Sized;\n-   |                      ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "70665ba06f95435b138f5c608ae0d2dfed43153f", "filename": "src/test/ui/coherence/coherence-with-generator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -12,7 +12,6 @@ fn defining_use() -> OpaqueGenerator {\n struct Wrapper<T>(T);\n trait Trait {}\n impl Trait for Wrapper<OpaqueGenerator> {}\n-//~^ ERROR cannot implement trait on type alias impl trait\n impl<T: Sync> Trait for Wrapper<T> {}\n //~^ ERROR conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n "}, {"sha": "6d3be2e16c6578b37746a5bd5cc5f5b2ac39c229", "filename": "src/test/ui/coherence/coherence-with-generator.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-with-generator.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,24 +1,11 @@\n error[E0119]: conflicting implementations of trait `Trait` for type `Wrapper<OpaqueGenerator>`\n-  --> $DIR/coherence-with-generator.rs:16:1\n+  --> $DIR/coherence-with-generator.rs:15:1\n    |\n LL | impl Trait for Wrapper<OpaqueGenerator> {}\n    | --------------------------------------- first implementation here\n-LL |\n LL | impl<T: Sync> Trait for Wrapper<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Wrapper<OpaqueGenerator>`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/coherence-with-generator.rs:14:24\n-   |\n-LL | impl Trait for Wrapper<OpaqueGenerator> {}\n-   |                        ^^^^^^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/coherence-with-generator.rs:3:24\n-   |\n-LL | type OpaqueGenerator = impl Sized;\n-   |                        ^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "35994e4a5ba3f5b7556ef82e9cbb6c0def9e12e6", "filename": "src/test/ui/impl-trait/auto-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -20,7 +20,6 @@ impl<T: Send> AnotherTrait for T {}\n // in the future.)\n impl AnotherTrait for D<OpaqueType> {\n     //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n-    //~| ERROR cannot implement trait on type alias impl trait\n }\n \n fn main() {}"}, {"sha": "81009413c9a268f550e356fe32381bf0e3526a88", "filename": "src/test/ui/impl-trait/auto-trait.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -7,18 +7,6 @@ LL | impl<T: Send> AnotherTrait for T {}\n LL | impl AnotherTrait for D<OpaqueType> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `D<OpaqueType>`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/auto-trait.rs:21:25\n-   |\n-LL | impl AnotherTrait for D<OpaqueType> {\n-   |                         ^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/auto-trait.rs:7:19\n-   |\n-LL | type OpaqueType = impl OpaqueTrait;\n-   |                   ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "70e24a3a9d029b946073b198b4d1cbf7583381a1", "filename": "src/test/ui/impl-trait/negative-reasoning.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -18,7 +18,6 @@ impl<T: std::fmt::Debug> AnotherTrait for T {}\n // This is in error, because we cannot assume that `OpaqueType: !Debug`\n impl AnotherTrait for D<OpaqueType> {\n     //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `D<OpaqueType>`\n-    //~| ERROR cannot implement trait on type alias impl trait\n }\n \n fn main() {}"}, {"sha": "6b8cc9e7374239c2c14036bf2ce6bfd6628323ad", "filename": "src/test/ui/impl-trait/negative-reasoning.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnegative-reasoning.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -9,18 +9,6 @@ LL | impl AnotherTrait for D<OpaqueType> {\n    |\n    = note: upstream crates may add a new impl of trait `std::fmt::Debug` for type `OpaqueType` in future versions\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/negative-reasoning.rs:19:25\n-   |\n-LL | impl AnotherTrait for D<OpaqueType> {\n-   |                         ^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/negative-reasoning.rs:7:19\n-   |\n-LL | type OpaqueType = impl OpaqueTrait;\n-   |                   ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "af9dfe25bb4ce0b4ecaeb198800be7c6e81bd25b", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -5,13 +5,13 @@ type Foo = impl PartialEq<(Foo, i32)>;\n struct Bar;\n \n impl PartialEq<(Foo, i32)> for Bar {\n-//~^ ERROR cannot implement trait on type alias impl trait\n     fn eq(&self, _other: &(Foo, i32)) -> bool {\n         true\n     }\n }\n \n fn foo() -> Foo {\n+    //~^ ERROR can't compare `Bar` with `(Bar, i32)`\n     Bar\n }\n "}, {"sha": "7b63a3d0b9f104fbbe52c964cd4eef44293594ca", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,14 +1,15 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:7:17\n+error[E0277]: can't compare `Bar` with `(Bar, i32)`\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:13:13\n    |\n-LL | impl PartialEq<(Foo, i32)> for Bar {\n-   |                 ^^^\n+LL | fn foo() -> Foo {\n+   |             ^^^ no implementation for `Bar == (Bar, i32)`\n+LL |\n+LL |     Bar\n+   |     --- return type was inferred to be `Bar` here\n    |\n-note: type alias impl trait defined here\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle-2.rs:3:12\n-   |\n-LL | type Foo = impl PartialEq<(Foo, i32)>;\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: the trait `PartialEq<(Bar, i32)>` is not implemented for `Bar`\n+   = help: the trait `PartialEq<(Foo, i32)>` is implemented for `Bar`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "91f1ed48133f574014eecf8a0fffc31e896bd014", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -2,24 +2,27 @@\n \n mod a {\n     type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR: unconstrained opaque type\n \n     struct Bar;\n \n     impl PartialEq<(Bar, i32)> for Bar {\n         fn eq(&self, _other: &(Foo, i32)) -> bool {\n+            //~^ ERROR: `eq` has an incompatible type for trait\n             true\n         }\n     }\n }\n \n mod b {\n     type Foo = impl PartialEq<(Foo, i32)>;\n+    //~^ ERROR: unconstrained opaque type\n \n     struct Bar;\n \n     impl PartialEq<(Foo, i32)> for Bar {\n-        //~^ ERROR cannot implement trait on type alias impl trait\n         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+            //~^ ERROR: `eq` has an incompatible type for trait\n             true\n         }\n     }"}, {"sha": "3dda5761ada6b34a97ef22bab914c84611f369cf", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle.stderr", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,14 +1,49 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:20:21\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:4:16\n    |\n-LL |     impl PartialEq<(Foo, i32)> for Bar {\n-   |                     ^^^\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error[E0053]: method `eq` has an incompatible type for trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:10:30\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                -------------------------- the found opaque type\n+...\n+LL |         fn eq(&self, _other: &(Foo, i32)) -> bool {\n+   |                              ^^^^^^^^^^^\n+   |                              |\n+   |                              expected struct `a::Bar`, found opaque type\n+   |                              help: change the parameter type to match the trait: `&(a::Bar, i32)`\n    |\n-note: type alias impl trait defined here\n-  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:16:16\n+   = note: expected fn pointer `fn(&a::Bar, &(a::Bar, i32)) -> _`\n+              found fn pointer `fn(&a::Bar, &(a::Foo, i32)) -> _`\n+\n+error: unconstrained opaque type\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:18:16\n    |\n LL |     type Foo = impl PartialEq<(Foo, i32)>;\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `Foo` must be used in combination with a concrete type within the same module\n+\n+error[E0053]: method `eq` has an incompatible type for trait\n+  --> $DIR/recursive-type-alias-impl-trait-declaration-too-subtle.rs:24:30\n+   |\n+LL |     type Foo = impl PartialEq<(Foo, i32)>;\n+   |                -------------------------- the expected opaque type\n+...\n+LL |         fn eq(&self, _other: &(Bar, i32)) -> bool {\n+   |                              ^^^^^^^^^^^\n+   |                              |\n+   |                              expected opaque type, found struct `b::Bar`\n+   |                              help: change the parameter type to match the trait: `&(b::Foo, i32)`\n+   |\n+   = note: expected fn pointer `fn(&b::Bar, &(b::Foo, i32)) -> _`\n+              found fn pointer `fn(&b::Bar, &(b::Bar, i32)) -> _`\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "2462e703a71656053f59d5df6fbfefd3cadfc1eb", "filename": "src/test/ui/traits/alias/issue-83613.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -9,5 +9,4 @@ trait AnotherTrait {}\n impl<T: Send> AnotherTrait for T {}\n impl AnotherTrait for OpaqueType {}\n //~^ ERROR conflicting implementations of trait `AnotherTrait` for type `OpaqueType`\n-//~| ERROR cannot implement trait on type alias impl trait\n fn main() {}"}, {"sha": "a78294da6c140766c4650b8a9aabe8bf3fc2c0cf", "filename": "src/test/ui/traits/alias/issue-83613.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fissue-83613.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -6,18 +6,6 @@ LL | impl<T: Send> AnotherTrait for T {}\n LL | impl AnotherTrait for OpaqueType {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `OpaqueType`\n \n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-83613.rs:10:23\n-   |\n-LL | impl AnotherTrait for OpaqueType {}\n-   |                       ^^^^^^^^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-83613.rs:4:19\n-   |\n-LL | type OpaqueType = impl OpaqueTrait;\n-   |                   ^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0119`."}, {"sha": "077a31494a972fe4517a0cb9cae4a54774538f4e", "filename": "src/test/ui/type-alias-impl-trait/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -12,6 +12,6 @@ fn use_alias<T>(val: T) -> AliasOfForeignType<T> {\n }\n \n impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-//~^ ERROR cannot implement trait on type alias impl trait\n+//~^ ERROR only traits defined in the current crate can be implemented for arbitrary types\n \n fn main() {}"}, {"sha": "c923eb08ab312fa5d5cb112b834d1b0dee596624", "filename": "src/test/ui/type-alias-impl-trait/coherence.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,14 +1,14 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/coherence.rs:14:41\n+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n+  --> $DIR/coherence.rs:14:1\n    |\n LL | impl<T> foreign_crate::ForeignTrait for AliasOfForeignType<T> {}\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---------------------\n+   | |                                       |\n+   | |                                       `AliasOfForeignType<T>` is not defined in the current crate\n+   | impl doesn't use only types from inside the current crate\n    |\n-note: type alias impl trait defined here\n-  --> $DIR/coherence.rs:9:30\n-   |\n-LL | type AliasOfForeignType<T> = impl LocalTrait;\n-   |                              ^^^^^^^^^^^^^^^\n+   = note: define and implement a trait or new type instead\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0117`."}, {"sha": "5c9ad9498b6de056920e30dad9fc782d5cfb2de9", "filename": "src/test/ui/type-alias-impl-trait/coherence_generalization.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence_generalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence_generalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcoherence_generalization.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+trait Trait {}\n+type Opaque<T> = impl Sized;\n+fn foo<T>() -> Opaque<T> {\n+    ()\n+}\n+\n+impl<T, V> Trait for (T, V, V, u32) {}\n+impl<U, V> Trait for (Opaque<U>, V, i32, V) {}\n+\n+fn main() {}"}, {"sha": "0efbd1c2bd5fd4cb4700a04957722f6d82bab782", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_generic_tait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_generic_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_generic_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_generic_tait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+trait Foo {\n+    type Assoc;\n+}\n+\n+impl Foo for i32 {\n+    type Assoc = u32;\n+}\n+type ImplTrait = impl Sized;\n+fn constrain() -> ImplTrait {\n+    1u64\n+}\n+impl Foo for i64 {\n+    type Assoc = ImplTrait;\n+}\n+\n+trait Bar<T> {}\n+\n+impl<T: Foo> Bar<<T as Foo>::Assoc> for T {}\n+\n+fn main() {}"}, {"sha": "3f1a9d12b44f91f1a5f8fdf41aafbd64f5f1da5b", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_same_tait.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,33 @@\n+#![feature(type_alias_impl_trait)]\n+\n+trait Foo {}\n+impl Foo for () {}\n+impl Foo for i32 {}\n+\n+type Bar<T: Foo> = impl std::fmt::Debug;\n+fn defining_use<T: Foo>() -> Bar<T> {\n+    42\n+}\n+\n+trait Bop {}\n+\n+impl Bop for Bar<()> {}\n+\n+// If the hidden type is the same, this is effectively a second impl for the same type.\n+impl Bop for Bar<i32> {}\n+//~^ ERROR conflicting implementations\n+\n+type Barr = impl std::fmt::Debug;\n+fn defining_use2() -> Barr {\n+    42\n+}\n+\n+// Even completely different opaque types must conflict.\n+impl Bop for Barr {}\n+//~^ ERROR conflicting implementations\n+\n+// And obviously the hidden type must conflict, too.\n+impl Bop for i32 {}\n+//~^ ERROR conflicting implementations\n+\n+fn main() {}"}, {"sha": "aaf75cc3db97c48316aff9408b4ad11a53214318", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_same_tait.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_same_tait.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,30 @@\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:17:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for Bar<i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:26:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for Barr {}\n+   | ^^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error[E0119]: conflicting implementations of trait `Bop` for type `Bar<()>`\n+  --> $DIR/impl_trait_for_same_tait.rs:30:1\n+   |\n+LL | impl Bop for Bar<()> {}\n+   | -------------------- first implementation here\n+...\n+LL | impl Bop for i32 {}\n+   | ^^^^^^^^^^^^^^^^ conflicting implementation for `Bar<()>`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "9f32c5d888b5f40efa983dc4ed6f7fde064f27c5", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,21 @@\n+// compile-flags: --crate-type=lib\n+// check-pass\n+\n+#![feature(type_alias_impl_trait)]\n+type Alias = impl Sized;\n+\n+fn constrain() -> Alias {\n+    1i32\n+}\n+\n+trait HideIt {\n+    type Assoc;\n+}\n+\n+impl HideIt for () {\n+    type Assoc = Alias;\n+}\n+\n+pub trait Yay {}\n+\n+impl Yay for <() as HideIt>::Assoc {}"}, {"sha": "8ec20acef4de6df8d6dd4d34e7d089c58b341d5f", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,19 @@\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+type Foo = impl Debug;\n+pub trait Yay { }\n+impl Yay for Foo { }\n+\n+fn foo() {\n+    is_yay::<u32>();   //~ ERROR: the trait bound `u32: Yay` is not satisfied\n+    is_debug::<u32>(); // OK\n+    is_yay::<Foo>();   // OK\n+    is_debug::<Foo>(); // OK\n+}\n+\n+fn is_yay<T: Yay>() { }\n+fn is_debug<T: Debug>() { }\n+\n+fn main() {}"}, {"sha": "1c83105a18affe735ab0032e4488304f04848119", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `u32: Yay` is not satisfied\n+  --> $DIR/impl_trait_for_tait_bound.rs:10:14\n+   |\n+LL |     is_yay::<u32>();\n+   |              ^^^ the trait `Yay` is not implemented for `u32`\n+   |\n+   = help: the trait `Yay` is implemented for `Foo`\n+note: required by a bound in `is_yay`\n+  --> $DIR/impl_trait_for_tait_bound.rs:16:14\n+   |\n+LL | fn is_yay<T: Yay>() { }\n+   |              ^^^ required by this bound in `is_yay`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a4b8c2d190db93c9d5c67f48a94f059b818c0797", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,16 @@\n+#![feature(type_alias_impl_trait)]\n+\n+use std::fmt::Debug;\n+\n+type Foo = impl Debug;\n+\n+pub trait Yay { }\n+impl Yay for u32 { }\n+\n+fn foo() {\n+    is_yay::<Foo>(); //~ ERROR: the trait bound `Foo: Yay` is not satisfied\n+}\n+\n+fn is_yay<T: Yay>() { }\n+\n+fn main() {}"}, {"sha": "a6440f02c27d856b6e022de13ca933b15f9c0071", "filename": "src/test/ui/type-alias-impl-trait/impl_trait_for_tait_bound2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fimpl_trait_for_tait_bound2.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -0,0 +1,16 @@\n+error[E0277]: the trait bound `Foo: Yay` is not satisfied\n+  --> $DIR/impl_trait_for_tait_bound2.rs:11:14\n+   |\n+LL |     is_yay::<Foo>();\n+   |              ^^^ the trait `Yay` is not implemented for `Foo`\n+   |\n+   = help: the trait `Yay` is implemented for `u32`\n+note: required by a bound in `is_yay`\n+  --> $DIR/impl_trait_for_tait_bound2.rs:14:14\n+   |\n+LL | fn is_yay<T: Yay>() { }\n+   |              ^^^ required by this bound in `is_yay`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9a9b2269f802eebf488667a03a464fcbc032ec23", "filename": "src/test/ui/type-alias-impl-trait/issue-65384.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -8,7 +8,7 @@ impl MyTrait for () {}\n type Bar = impl MyTrait;\n \n impl MyTrait for Bar {}\n-//~^ ERROR: cannot implement trait on type alias impl trait\n+//~^ ERROR: conflicting implementations of trait `MyTrait` for type `()`\n \n fn bazr() -> Bar { }\n "}, {"sha": "f6692ae320733d679e5562c84c1efc0827de7813", "filename": "src/test/ui/type-alias-impl-trait/issue-65384.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65384.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,14 +1,12 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-65384.rs:10:18\n+error[E0119]: conflicting implementations of trait `MyTrait` for type `()`\n+  --> $DIR/issue-65384.rs:10:1\n    |\n+LL | impl MyTrait for () {}\n+   | ------------------- first implementation here\n+...\n LL | impl MyTrait for Bar {}\n-   |                  ^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-65384.rs:8:12\n-   |\n-LL | type Bar = impl MyTrait;\n-   |            ^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `()`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "b97e444c6d0e0d0824f38998a9ff9bdc107418fb", "filename": "src/test/ui/type-alias-impl-trait/issue-76202-trait-impl-for-tait.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,6 +1,8 @@\n // Regression test for issue #76202\n // Tests that we don't ICE when we have a trait impl on a TAIT.\n \n+// check-pass\n+\n #![feature(type_alias_impl_trait)]\n \n trait Dummy {}\n@@ -14,7 +16,12 @@ trait Test {\n }\n \n impl Test for F {\n-    //~^ ERROR cannot implement trait\n+    fn test(self) {}\n+}\n+\n+// Ok because `i32` does not implement `Dummy`,\n+// so it can't possibly be the hidden type of `F`.\n+impl Test for i32 {\n     fn test(self) {}\n }\n "}, {"sha": "2d4a6854a920be74ffc2add35ade869546709f08", "filename": "src/test/ui/type-alias-impl-trait/issue-76202-trait-impl-for-tait.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/604d52108e9272d75618ab6a7b5eb006857fce52/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/604d52108e9272d75618ab6a7b5eb006857fce52/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-76202-trait-impl-for-tait.stderr?ref=604d52108e9272d75618ab6a7b5eb006857fce52", "patch": "@@ -1,14 +0,0 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-76202-trait-impl-for-tait.rs:16:15\n-   |\n-LL | impl Test for F {\n-   |               ^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-76202-trait-impl-for-tait.rs:9:10\n-   |\n-LL | type F = impl Dummy;\n-   |          ^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "2ba4befea2a3930fc4b37fa3141e364c2a363c25", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-trait-impl-for-tait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,6 +1,8 @@\n // Regression test for issues #84660 and #86411: both are variations on #76202.\n // Tests that we don't ICE when we have an opaque type appearing anywhere in an impl header.\n \n+// check-pass\n+\n #![feature(type_alias_impl_trait)]\n \n trait Foo {}\n@@ -12,7 +14,7 @@ trait TraitArg<T> {\n     fn f();\n }\n \n-impl TraitArg<Bar> for () { //~ ERROR cannot implement trait\n+impl TraitArg<Bar> for () {\n     fn f() {\n         println!(\"ho\");\n     }"}, {"sha": "bb70d07be59bb0da395cd94836186ebc06d5e379", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-trait-impl-for-tait.stderr", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/604d52108e9272d75618ab6a7b5eb006857fce52/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/604d52108e9272d75618ab6a7b5eb006857fce52/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-trait-impl-for-tait.stderr?ref=604d52108e9272d75618ab6a7b5eb006857fce52", "patch": "@@ -1,14 +0,0 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-84660-trait-impl-for-tait.rs:15:15\n-   |\n-LL | impl TraitArg<Bar> for () {\n-   |               ^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-84660-trait-impl-for-tait.rs:8:12\n-   |\n-LL | type Bar = impl Foo;\n-   |            ^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "48d4b0c96ff0a0602e97efe2a622c44d741caa0d", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-unsoundness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -13,14 +13,14 @@ trait Trait<T, In> {\n     fn convert(i: In) -> Self::Out;\n }\n \n-impl<In, Out> Trait<Bar, In> for Out { //~ ERROR cannot implement trait\n+impl<In, Out> Trait<Bar, In> for Out {\n     type Out = Out;\n     fn convert(_i: In) -> Self::Out {\n         unreachable!();\n     }\n }\n \n-impl<In, Out> Trait<(), In> for Out {\n+impl<In, Out> Trait<(), In> for Out { //~ ERROR conflicting implementations of trait `Trait<Bar, _>`\n     type Out = In;\n     fn convert(i: In) -> Self::Out {\n         i"}, {"sha": "6a75e1bd2c0fa879eed9bbed7a2079d6c961acf3", "filename": "src/test/ui/type-alias-impl-trait/issue-84660-unsoundness.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-84660-unsoundness.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,14 +1,12 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/issue-84660-unsoundness.rs:16:21\n+error[E0119]: conflicting implementations of trait `Trait<Bar, _>`\n+  --> $DIR/issue-84660-unsoundness.rs:23:1\n    |\n LL | impl<In, Out> Trait<Bar, In> for Out {\n-   |                     ^^^\n-   |\n-note: type alias impl trait defined here\n-  --> $DIR/issue-84660-unsoundness.rs:8:12\n-   |\n-LL | type Bar = impl Foo;\n-   |            ^^^^^^^^\n+   | ------------------------------------ first implementation here\n+...\n+LL | impl<In, Out> Trait<(), In> for Out {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0119`."}, {"sha": "b0ebdd1bfab7d9e4108579346fe821c5d8758056", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -4,11 +4,11 @@\n use std::fmt::Debug;\n \n type FooX = impl Debug;\n+//~^ ERROR unconstrained opaque type\n \n trait Foo<A> { }\n \n impl Foo<FooX> for () { }\n-//~^ cannot implement trait on type alias impl trait\n \n fn foo() -> impl Foo<FooX> {\n     ()"}, {"sha": "b1d947a9ccf4ec62423b7119c21b4cd7ee1f120f", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference3.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference3.stderr?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -1,14 +1,10 @@\n-error: cannot implement trait on type alias impl trait\n-  --> $DIR/nested-tait-inference3.rs:10:10\n-   |\n-LL | impl Foo<FooX> for () { }\n-   |          ^^^^\n-   |\n-note: type alias impl trait defined here\n+error: unconstrained opaque type\n   --> $DIR/nested-tait-inference3.rs:6:13\n    |\n LL | type FooX = impl Debug;\n    |             ^^^^^^^^^^\n+   |\n+   = note: `FooX` must be used in combination with a concrete type within the same module\n \n error: aborting due to previous error\n "}, {"sha": "d183e28f667c01178d9f156deb173ea80f13d9fe", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53eab246db86d0b2a0e664196dcd434746724e8b/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=53eab246db86d0b2a0e664196dcd434746724e8b", "patch": "@@ -37,6 +37,7 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: Option<\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Coerce(_) => panic!(\"coerce predicate on function: {predicate:#?}\"),\n+                ty::PredicateKind::Ambiguous => panic!(\"ambiguous predicate on function: {predicate:#?}\"),\n             }\n         }\n         match predicates.parent {"}]}