{"sha": "efebe45cc0f3265ee8bb6396952e93a2004128c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZWJlNDVjYzBmMzI2NWVlOGJiNjM5Njk1MmU5M2EyMDA0MTI4Yzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-28T20:16:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-28T20:16:08Z"}, "message": "Auto merge of #25856 - bluss:binary-heap-hole, r=Gankro\n\ncollections: Make BinaryHeap panic safe in sift_up / sift_down\r\n\r\nUse a struct called Hole that keeps track of an invalid location\r\nin the vector and fills the hole on drop.\r\n\r\nI include a run-pass test that the current BinaryHeap fails, and the new\r\none passes.\r\n\r\nNOTE: The BinaryHeap will still be inconsistent after a comparison fails. It will\r\nnot have the heap property. What we fix is just that elements will be valid\r\nvalues.\r\n\r\nThis is actually a performance win -- the new code does not bother to write in `zeroed()`\r\nvalues in the holes, it just leaves them as they were.\r\n\r\nNet result is something like a 5% decrease in runtime for `BinaryHeap::from_vec`. This\r\ncan be further improved by using unchecked indexing (I confirmed it makes a difference,\r\nnot a surprise with the non-sequential access going on), but let's leave that for another PR.\r\nSafety first :wink: \r\n\r\nFixes #25842", "tree": {"sha": "daee7feda139b3e58cf99f51b59cc4cb23f6958b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daee7feda139b3e58cf99f51b59cc4cb23f6958b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efebe45cc0f3265ee8bb6396952e93a2004128c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efebe45cc0f3265ee8bb6396952e93a2004128c8", "html_url": "https://github.com/rust-lang/rust/commit/efebe45cc0f3265ee8bb6396952e93a2004128c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efebe45cc0f3265ee8bb6396952e93a2004128c8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "621a10e7f32d790c39a0b4528369cf7959dd7d34", "url": "https://api.github.com/repos/rust-lang/rust/commits/621a10e7f32d790c39a0b4528369cf7959dd7d34", "html_url": "https://github.com/rust-lang/rust/commit/621a10e7f32d790c39a0b4528369cf7959dd7d34"}, {"sha": "5249cbb7fa31ea2e6e8d77b49bfda386215b1ce7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5249cbb7fa31ea2e6e8d77b49bfda386215b1ce7", "html_url": "https://github.com/rust-lang/rust/commit/5249cbb7fa31ea2e6e8d77b49bfda386215b1ce7"}], "stats": {"total": 221, "additions": 196, "deletions": 25}, "files": [{"sha": "00e4002f82f4f296bd5ec30b321baf068d4db10f", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 88, "deletions": 25, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/efebe45cc0f3265ee8bb6396952e93a2004128c8/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efebe45cc0f3265ee8bb6396952e93a2004128c8/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=efebe45cc0f3265ee8bb6396952e93a2004128c8", "patch": "@@ -153,7 +153,7 @@\n use core::prelude::*;\n \n use core::iter::{FromIterator};\n-use core::mem::{zeroed, replace, swap};\n+use core::mem::swap;\n use core::ptr;\n \n use slice;\n@@ -484,46 +484,42 @@ impl<T: Ord> BinaryHeap<T> {\n \n     // The implementations of sift_up and sift_down use unsafe blocks in\n     // order to move an element out of the vector (leaving behind a\n-    // zeroed element), shift along the others and move it back into the\n-    // vector over the junk element. This reduces the constant factor\n-    // compared to using swaps, which involves twice as many moves.\n-    fn sift_up(&mut self, start: usize, mut pos: usize) {\n+    // hole), shift along the others and move the removed element back into the\n+    // vector at the final location of the hole.\n+    // The `Hole` type is used to represent this, and make sure\n+    // the hole is filled back at the end of its scope, even on panic.\n+    // Using a hole reduces the constant factor compared to using swaps,\n+    // which involves twice as many moves.\n+    fn sift_up(&mut self, start: usize, pos: usize) {\n         unsafe {\n-            let new = replace(&mut self.data[pos], zeroed());\n+            // Take out the value at `pos` and create a hole.\n+            let mut hole = Hole::new(&mut self.data, pos);\n \n-            while pos > start {\n-                let parent = (pos - 1) >> 1;\n-\n-                if new <= self.data[parent] { break; }\n-\n-                let x = replace(&mut self.data[parent], zeroed());\n-                ptr::write(&mut self.data[pos], x);\n-                pos = parent;\n+            while hole.pos() > start {\n+                let parent = (hole.pos() - 1) / 2;\n+                if hole.removed() <= hole.get(parent) { break }\n+                hole.move_to(parent);\n             }\n-            ptr::write(&mut self.data[pos], new);\n         }\n     }\n \n     fn sift_down_range(&mut self, mut pos: usize, end: usize) {\n+        let start = pos;\n         unsafe {\n-            let start = pos;\n-            let new = replace(&mut self.data[pos], zeroed());\n-\n+            let mut hole = Hole::new(&mut self.data, pos);\n             let mut child = 2 * pos + 1;\n             while child < end {\n                 let right = child + 1;\n-                if right < end && !(self.data[child] > self.data[right]) {\n+                if right < end && !(hole.get(child) > hole.get(right)) {\n                     child = right;\n                 }\n-                let x = replace(&mut self.data[child], zeroed());\n-                ptr::write(&mut self.data[pos], x);\n-                pos = child;\n-                child = 2 * pos + 1;\n+                hole.move_to(child);\n+                child = 2 * hole.pos() + 1;\n             }\n \n-            ptr::write(&mut self.data[pos], new);\n-            self.sift_up(start, pos);\n+            pos = hole.pos;\n         }\n+        self.sift_up(start, pos);\n     }\n \n     fn sift_down(&mut self, pos: usize) {\n@@ -554,6 +550,73 @@ impl<T: Ord> BinaryHeap<T> {\n     pub fn clear(&mut self) { self.drain(); }\n }\n \n+/// Hole represents a hole in a slice i.e. an index without valid value\n+/// (because it was moved from or duplicated).\n+/// In drop, `Hole` will restore the slice by filling the hole\n+/// position with the value that was originally removed.\n+struct Hole<'a, T: 'a> {\n+    data: &'a mut [T],\n+    /// `elt` is always `Some` from new until drop.\n+    elt: Option<T>,\n+    pos: usize,\n+}\n+\n+impl<'a, T> Hole<'a, T> {\n+    /// Create a new Hole at index `pos`.\n+    fn new(data: &'a mut [T], pos: usize) -> Self {\n+        unsafe {\n+            let elt = ptr::read(&data[pos]);\n+            Hole {\n+                data: data,\n+                elt: Some(elt),\n+                pos: pos,\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn pos(&self) -> usize { self.pos }\n+\n+    /// Return a reference to the element removed\n+    #[inline(always)]\n+    fn removed(&self) -> &T {\n+        self.elt.as_ref().unwrap()\n+    }\n+\n+    /// Return a reference to the element at `index`.\n+    ///\n+    /// Panics if the index is out of bounds.\n+    ///\n+    /// Unsafe because index must not equal pos.\n+    #[inline(always)]\n+    unsafe fn get(&self, index: usize) -> &T {\n+        debug_assert!(index != self.pos);\n+        &self.data[index]\n+    }\n+\n+    /// Move hole to new location\n+    ///\n+    /// Unsafe because index must not equal pos.\n+    #[inline(always)]\n+    unsafe fn move_to(&mut self, index: usize) {\n+        debug_assert!(index != self.pos);\n+        let index_ptr: *const _ = &self.data[index];\n+        let hole_ptr = &mut self.data[self.pos];\n+        ptr::copy_nonoverlapping(index_ptr, hole_ptr, 1);\n+        self.pos = index;\n+    }\n+}\n+\n+impl<'a, T> Drop for Hole<'a, T> {\n+    fn drop(&mut self) {\n+        // fill the hole again\n+        unsafe {\n+            let pos = self.pos;\n+            ptr::write(&mut self.data[pos], self.elt.take().unwrap());\n+        }\n+    }\n+}\n+\n /// `BinaryHeap` iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter <'a, T: 'a> {"}, {"sha": "4888a8b84fc42a55eccea9d032d82604d1994fc3", "filename": "src/test/run-pass/binary-heap-panic-safe.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/efebe45cc0f3265ee8bb6396952e93a2004128c8/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efebe45cc0f3265ee8bb6396952e93a2004128c8/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinary-heap-panic-safe.rs?ref=efebe45cc0f3265ee8bb6396952e93a2004128c8", "patch": "@@ -0,0 +1,108 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(std_misc, collections, catch_panic, rand)]\n+\n+use std::__rand::{thread_rng, Rng};\n+use std::thread;\n+\n+use std::collections::BinaryHeap;\n+use std::cmp;\n+use std::sync::Arc;\n+use std::sync::Mutex;\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n+\n+static DROP_COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+// old binaryheap failed this test\n+//\n+// Integrity means that all elements are present after a comparison panics,\n+// even if the order may not be correct.\n+//\n+// Destructors must be called exactly once per element.\n+fn test_integrity() {\n+    #[derive(Eq, PartialEq, Ord, Clone, Debug)]\n+    struct PanicOrd<T>(T, bool);\n+\n+    impl<T> Drop for PanicOrd<T> {\n+        fn drop(&mut self) {\n+            // update global drop count\n+            DROP_COUNTER.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    impl<T: PartialOrd> PartialOrd for PanicOrd<T> {\n+        fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n+            if self.1 || other.1 {\n+                panic!(\"Panicking comparison\");\n+            }\n+            self.0.partial_cmp(&other.0)\n+        }\n+    }\n+    let mut rng = thread_rng();\n+    const DATASZ: usize = 32;\n+    const NTEST: usize = 10;\n+\n+    // don't use 0 in the data -- we want to catch the zeroed-out case.\n+    let data = (1..DATASZ + 1).collect::<Vec<_>>();\n+\n+    // since it's a fuzzy test, run several tries.\n+    for _ in 0..NTEST {\n+        for i in 1..DATASZ + 1 {\n+            DROP_COUNTER.store(0, Ordering::SeqCst);\n+\n+            let mut panic_ords: Vec<_> = data.iter()\n+                                             .filter(|&&x| x != i)\n+                                             .map(|&x| PanicOrd(x, false))\n+                                             .collect();\n+            let panic_item = PanicOrd(i, true);\n+\n+            // heapify the sane items\n+            rng.shuffle(&mut panic_ords);\n+            let heap = Arc::new(Mutex::new(BinaryHeap::from_vec(panic_ords)));\n+            let inner_data;\n+\n+            {\n+                let heap_ref = heap.clone();\n+\n+\n+                // push the panicking item to the heap and catch the panic\n+                let thread_result = thread::catch_panic(move || {\n+                    heap.lock().unwrap().push(panic_item);\n+                });\n+                assert!(thread_result.is_err());\n+\n+                // Assert no elements were dropped\n+                let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+                //assert!(drops == 0, \"Must not drop items. drops={}\", drops);\n+\n+                {\n+                    // now fetch the binary heap's data vector\n+                    let mutex_guard = match heap_ref.lock() {\n+                        Ok(x) => x,\n+                        Err(poison) => poison.into_inner(),\n+                    };\n+                    inner_data = mutex_guard.clone().into_vec();\n+                }\n+            }\n+            let drops = DROP_COUNTER.load(Ordering::SeqCst);\n+            assert_eq!(drops, DATASZ);\n+\n+            let mut data_sorted = inner_data.into_iter().map(|p| p.0).collect::<Vec<_>>();\n+            data_sorted.sort();\n+            assert_eq!(data_sorted, data);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test_integrity();\n+}\n+"}]}