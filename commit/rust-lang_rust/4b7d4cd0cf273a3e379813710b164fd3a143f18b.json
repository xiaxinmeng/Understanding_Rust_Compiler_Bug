{"sha": "4b7d4cd0cf273a3e379813710b164fd3a143f18b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiN2Q0Y2QwY2YyNzNhM2UzNzk4MTM3MTBiMTY0ZmQzYTE0M2YxOGI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-28T22:41:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-28T22:41:15Z"}, "message": "De-export str. Part of #3583.", "tree": {"sha": "26116b4dac8cc5cfc90b2bede89f5b9e54ed8434", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26116b4dac8cc5cfc90b2bede89f5b9e54ed8434"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b7d4cd0cf273a3e379813710b164fd3a143f18b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b7d4cd0cf273a3e379813710b164fd3a143f18b", "html_url": "https://github.com/rust-lang/rust/commit/4b7d4cd0cf273a3e379813710b164fd3a143f18b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b7d4cd0cf273a3e379813710b164fd3a143f18b/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e0a43c93275603f38912198714dd99dd9095b8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0a43c93275603f38912198714dd99dd9095b8b", "html_url": "https://github.com/rust-lang/rust/commit/9e0a43c93275603f38912198714dd99dd9095b8b"}], "stats": {"total": 375, "additions": 124, "deletions": 251}, "files": [{"sha": "ad04af1dad747d7530b8a0afedb3267c5f7f85c1", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4b7d4cd0cf273a3e379813710b164fd3a143f18b/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/4b7d4cd0cf273a3e379813710b164fd3a143f18b/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=4b7d4cd0cf273a3e379813710b164fd3a143f18b", "patch": "@@ -169,7 +169,6 @@ mod char;\n mod float;\n mod f32;\n mod f64;\n-#[legacy_exports]\n mod str;\n #[legacy_exports]\n mod ptr;"}, {"sha": "8929e57cfb1190ec6af2f1b4856679be671aaa13", "filename": "src/libcore/str.rs", "status": "modified", "additions": 124, "deletions": 250, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/4b7d4cd0cf273a3e379813710b164fd3a143f18b/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b7d4cd0cf273a3e379813710b164fd3a143f18b/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4b7d4cd0cf273a3e379813710b164fd3a143f18b", "patch": "@@ -15,115 +15,6 @@ use libc::size_t;\n use io::WriterUtil;\n use to_str::ToStr;\n \n-export\n-   // Creating a string\n-   from_bytes,\n-   from_byte,\n-   from_slice,\n-   from_char,\n-   from_chars,\n-   append,\n-   concat,\n-   connect,\n-\n-   // Reinterpretation\n-   as_bytes,\n-   as_bytes_slice,\n-   as_buf,\n-   as_c_str,\n-\n-   // Adding things to and removing things from a string\n-   push_str_no_overallocate,\n-   push_str,\n-   push_char,\n-   pop_char,\n-   shift_char,\n-   view_shift_char,\n-   unshift_char,\n-   trim_left,\n-   trim_right,\n-   trim,\n-   trim_left_chars,\n-   trim_right_chars,\n-   trim_chars,\n-\n-   // Transforming strings\n-   to_bytes,\n-   byte_slice,\n-   chars,\n-   substr,\n-   slice,\n-   view,\n-   split, splitn, split_nonempty,\n-   split_char, splitn_char, split_char_nonempty,\n-   split_str, split_str_nonempty,\n-   lines,\n-   lines_any,\n-   words,\n-   to_lower,\n-   to_upper,\n-   replace,\n-\n-   // Comparing strings\n-   eq,\n-   eq_slice,\n-   le,\n-   hash,\n-\n-   // Iterating through strings\n-   all, any,\n-   all_between, any_between,\n-   map,\n-   each, eachi,\n-   each_char, each_chari,\n-   bytes_each,\n-   chars_each,\n-   split_char_each,\n-   splitn_char_each,\n-   words_each,\n-   lines_each,\n-\n-   // Searching\n-   find, find_from, find_between,\n-   rfind, rfind_from, rfind_between,\n-   find_char, find_char_from, find_char_between,\n-   rfind_char, rfind_char_from, rfind_char_between,\n-   find_str, find_str_from, find_str_between,\n-   contains, contains_char,\n-   starts_with,\n-   ends_with,\n-\n-   // String properties\n-   is_ascii,\n-   is_empty,\n-   is_not_empty,\n-   is_whitespace,\n-   len,\n-   char_len,\n-\n-   // Misc\n-   is_utf8,\n-   is_utf16,\n-   to_utf16,\n-   from_utf16,\n-   utf16_chars,\n-   count_chars, count_bytes,\n-   utf8_char_width,\n-   char_range_at,\n-   is_char_boundary,\n-   char_at,\n-   reserve,\n-   reserve_at_least,\n-   capacity,\n-   escape_default,\n-   escape_unicode,\n-\n-   raw,\n-   extensions,\n-   StrSlice,\n-   UniqueStr,\n-   traits;\n-\n /*\n Section: Creating a string\n */\n@@ -135,13 +26,13 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_bytes(vv: &[const u8]) -> ~str {\n+pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n     assert is_utf8(vv);\n     return unsafe { raw::from_bytes(vv) };\n }\n \n /// Copy a slice into a new unique str\n-pure fn from_slice(s: &str) -> ~str {\n+pub pure fn from_slice(s: &str) -> ~str {\n     unsafe { raw::slice_bytes(s, 0, len(s)) }\n }\n \n@@ -152,13 +43,13 @@ pure fn from_slice(s: &str) -> ~str {\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_byte(b: u8) -> ~str {\n+pub pure fn from_byte(b: u8) -> ~str {\n     assert b < 128u8;\n     unsafe { ::cast::transmute(~[b, 0u8]) }\n }\n \n /// Appends a character at the end of a string\n-fn push_char(s: &const ~str, ch: char) {\n+pub fn push_char(s: &const ~str, ch: char) {\n     unsafe {\n         let code = ch as uint;\n         let nb = if code < max_one_b { 1u }\n@@ -229,14 +120,14 @@ fn push_char(s: &const ~str, ch: char) {\n }\n \n /// Convert a char to a string\n-pure fn from_char(ch: char) -> ~str {\n+pub pure fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n     unsafe { push_char(&mut buf, ch); }\n     move buf\n }\n \n /// Convert a vector of chars to a string\n-pure fn from_chars(chs: &[char]) -> ~str {\n+pub pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, chs.len());\n@@ -249,7 +140,7 @@ pure fn from_chars(chs: &[char]) -> ~str {\n \n /// Appends a string slice to the back of a string, without overallocating\n #[inline(always)]\n-fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n+pub fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -266,7 +157,7 @@ fn push_str_no_overallocate(lhs: &const ~str, rhs: &str) {\n }\n /// Appends a string slice to the back of a string\n #[inline(always)]\n-fn push_str(lhs: &const ~str, rhs: &str) {\n+pub fn push_str(lhs: &const ~str, rhs: &str) {\n     unsafe {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n@@ -284,7 +175,7 @@ fn push_str(lhs: &const ~str, rhs: &str) {\n \n /// Concatenate two strings together\n #[inline(always)]\n-pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n+pub pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n     let mut v <- lhs;\n     unsafe {\n         push_str_no_overallocate(&mut v, rhs);\n@@ -294,7 +185,7 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n \n \n /// Concatenate a vector of strings\n-pure fn concat(v: &[~str]) -> ~str {\n+pub pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n         unsafe { push_str(&mut s, *ss) };\n@@ -303,7 +194,7 @@ pure fn concat(v: &[~str]) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pure fn connect(v: &[~str], sep: &str) -> ~str {\n+pub pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n@@ -323,7 +214,7 @@ Section: Adding to and removing from a string\n  *\n  * If the string does not contain any characters\n  */\n-fn pop_char(s: &const ~str) -> char {\n+pub fn pop_char(s: &const ~str) -> char {\n     let end = len(*s);\n     assert end > 0u;\n     let {ch, prev} = char_range_at_reverse(*s, end);\n@@ -338,7 +229,7 @@ fn pop_char(s: &const ~str) -> char {\n  *\n  * If the string does not contain any characters\n  */\n-fn shift_char(s: &mut ~str) -> char {\n+pub fn shift_char(s: &mut ~str) -> char {\n     let {ch, next} = char_range_at(*s, 0u);\n     *s = unsafe { raw::slice_bytes(*s, next, len(*s)) };\n     return ch;\n@@ -354,14 +245,14 @@ fn shift_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n #[inline]\n-fn view_shift_char(s: &a/str) -> (char, &a/str) {\n+pub fn view_shift_char(s: &a/str) -> (char, &a/str) {\n     let {ch, next} = char_range_at(s, 0u);\n     let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n \n /// Prepend a char to a string\n-fn unshift_char(s: &mut ~str, ch: char) {\n+pub fn unshift_char(s: &mut ~str, ch: char) {\n     *s = from_char(ch) + *s;\n }\n \n@@ -374,7 +265,7 @@ fn unshift_char(s: &mut ~str, ch: char) {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     if chars_to_trim.is_empty() { return from_slice(s); }\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n@@ -392,7 +283,7 @@ pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     if chars_to_trim.is_empty() { return str::from_slice(s); }\n \n     match rfind(s, |c| !chars_to_trim.contains(&c)) {\n@@ -413,20 +304,20 @@ pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n  * * chars_to_trim - A vector of chars\n  *\n  */\n-pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n+pub pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n     trim_left_chars(trim_right_chars(s, chars_to_trim), chars_to_trim)\n }\n \n /// Returns a string with leading whitespace removed\n-pure fn trim_left(s: &str) -> ~str {\n+pub pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n       Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n-pure fn trim_right(s: &str) -> ~str {\n+pub pure fn trim_right(s: &str) -> ~str {\n     match rfind(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n       Some(last) => {\n@@ -437,7 +328,7 @@ pure fn trim_right(s: &str) -> ~str {\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pure fn trim(s: &str) -> ~str { trim_left(trim_right(s)) }\n+pub pure fn trim(s: &str) -> ~str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -448,22 +339,22 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n+pub pure fn to_bytes(s: &str) -> ~[u8] unsafe {\n     let mut v: ~[u8] = ::cast::transmute(from_slice(s));\n     vec::raw::set_len(&mut v, len(s));\n     move v\n }\n \n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n-pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n+pub pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n     do as_buf(s) |p,n| {\n         unsafe { vec::raw::form_slice(p, n-1u, f) }\n     }\n }\n \n /// Convert a string to a vector of characters\n-pure fn chars(s: &str) -> ~[char] {\n+pub pure fn chars(s: &str) -> ~[char] {\n     let mut buf = ~[], i = 0;\n     let len = len(s);\n     while i < len {\n@@ -480,7 +371,7 @@ pure fn chars(s: &str) -> ~[char] {\n  * Returns a string containing `n` characters starting at byte offset\n  * `begin`.\n  */\n-pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n+pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n     slice(s, begin, begin + count_bytes(s, begin, n))\n }\n \n@@ -490,7 +381,7 @@ pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or\n  * beyond the last character of the string\n  */\n-pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n+pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe { raw::slice_bytes(s, begin, end) }\n@@ -502,14 +393,14 @@ pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n+pub pure fn view(s: &a/str, begin: uint, end: uint) -> &a/str {\n     assert is_char_boundary(s, begin);\n     assert is_char_boundary(s, end);\n     unsafe { raw::view_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n-pure fn split_char(s: &str, sep: char) -> ~[~str] {\n+pub pure fn split_char(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), true)\n }\n \n@@ -519,12 +410,12 @@ pure fn split_char(s: &str, sep: char) -> ~[~str] {\n  *\n  * The byte must be a valid UTF-8/ASCII byte\n  */\n-pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n+pub pure fn splitn_char(s: &str, sep: char, count: uint) -> ~[~str] {\n     split_char_inner(s, sep, count, true)\n }\n \n /// Like `split_char`, but omits empty strings from the returned vector\n-pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n+pub pure fn split_char_nonempty(s: &str, sep: char) -> ~[~str] {\n     split_char_inner(s, sep, len(s), false)\n }\n \n@@ -555,20 +446,20 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n \n \n /// Splits a string into substrings using a character function\n-pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), true)\n }\n \n /**\n  * Splits a string into substrings using a character function, cutting at\n  * most `count` times.\n  */\n-pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n+pub pure fn splitn(s: &str, sepfn: fn(char) -> bool, count: uint) -> ~[~str] {\n     split_inner(s, sepfn, count, true)\n }\n \n /// Like `split`, but omits empty strings from the returned vector\n-pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n+pub pure fn split_nonempty(s: &str, sepfn: fn(char) -> bool) -> ~[~str] {\n     split_inner(s, sepfn, len(s), false)\n }\n \n@@ -639,15 +530,15 @@ pure fn iter_between_matches(s: &a/str, sep: &b/str, f: fn(uint, uint)) {\n  * assert [\"\", \"XXX\", \"YYY\", \"\"] == split_str(\".XXX.YYY.\", \".\")\n  * ~~~\n  */\n-pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n+pub pure fn split_str(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         unsafe { result.push(raw::slice_bytes(s, from, to)); }\n     }\n     move result\n }\n \n-pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n+pub pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n@@ -660,13 +551,13 @@ pure fn split_str_nonempty(s: &a/str, sep: &b/str) -> ~[~str] {\n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  */\n-pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n+pub pure fn lines(s: &str) -> ~[~str] { split_char(s, '\\n') }\n \n /**\n  * Splits a string into a vector of the substrings separated by LF ('\\n')\n  * and/or CR LF (\"\\r\\n\")\n  */\n-pure fn lines_any(s: &str) -> ~[~str] {\n+pub pure fn lines_any(s: &str) -> ~[~str] {\n     vec::map(lines(s), |s| {\n         let l = len(*s);\n         let mut cp = copy *s;\n@@ -678,19 +569,19 @@ pure fn lines_any(s: &str) -> ~[~str] {\n }\n \n /// Splits a string into a vector of the substrings separated by whitespace\n-pure fn words(s: &str) -> ~[~str] {\n+pub pure fn words(s: &str) -> ~[~str] {\n     split_nonempty(s, |c| char::is_whitespace(c))\n }\n \n /// Convert a string to lowercase. ASCII only\n-pure fn to_lower(s: &str) -> ~str {\n+pub pure fn to_lower(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::tolower(c as libc::c_char)) as char}\n     )\n }\n \n /// Convert a string to uppercase. ASCII only\n-pure fn to_upper(s: &str) -> ~str {\n+pub pure fn to_upper(s: &str) -> ~str {\n     map(s,\n         |c| unsafe{(libc::toupper(c as libc::c_char)) as char}\n     )\n@@ -709,7 +600,7 @@ pure fn to_upper(s: &str) -> ~str {\n  *\n  * The original string with all occurances of `from` replaced with `to`\n  */\n-pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n+pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first {\n@@ -729,7 +620,7 @@ Section: Comparing strings\n /// Bytewise slice equality\n #[cfg(notest)]\n #[lang=\"str_eq\"]\n-pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub pure fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -745,7 +636,7 @@ pure fn eq_slice(a: &str, b: &str) -> bool {\n }\n \n #[cfg(test)]\n-pure fn eq_slice(a: &str, b: &str) -> bool {\n+pub pure fn eq_slice(a: &str, b: &str) -> bool {\n     do as_buf(a) |ap, alen| {\n         do as_buf(b) |bp, blen| {\n             if (alen != blen) { false }\n@@ -763,12 +654,12 @@ pure fn eq_slice(a: &str, b: &str) -> bool {\n /// Bytewise string equality\n #[cfg(notest)]\n #[lang=\"uniq_str_eq\"]\n-pure fn eq(a: &~str, b: &~str) -> bool {\n+pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n #[cfg(test)]\n-pure fn eq(a: &~str, b: &~str) -> bool {\n+pub pure fn eq(a: &~str, b: &~str) -> bool {\n     eq_slice(*a, *b)\n }\n \n@@ -789,7 +680,7 @@ pure fn lt(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise less than or equal\n-pure fn le(a: &str, b: &str) -> bool {\n+pub pure fn le(a: &str, b: &str) -> bool {\n     !lt(b, a)\n }\n \n@@ -871,20 +762,20 @@ Section: Iterating through strings\n  * Return true if a predicate matches all characters or if the string\n  * contains no characters\n  */\n-pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n+pub pure fn all(s: &str, it: fn(char) -> bool) -> bool {\n     all_between(s, 0u, len(s), it)\n }\n \n /**\n  * Return true if a predicate matches any character (and false if it\n  * matches none or there are no characters)\n  */\n-pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n+pub pure fn any(ss: &str, pred: fn(char) -> bool) -> bool {\n     !all(ss, |cc| !pred(cc))\n }\n \n /// Apply a function to each character\n-pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n+pub pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     unsafe {\n         reserve(&mut result, len(ss));\n@@ -896,7 +787,7 @@ pure fn map(ss: &str, ff: fn(char) -> char) -> ~str {\n }\n \n /// Iterate over the bytes in a string\n-pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n+pub pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n     let mut pos = 0u;\n     let len = len(ss);\n \n@@ -908,13 +799,13 @@ pure fn bytes_each(ss: &str, it: fn(u8) -> bool) {\n \n /// Iterate over the bytes in a string\n #[inline(always)]\n-pure fn each(s: &str, it: fn(u8) -> bool) {\n+pub pure fn each(s: &str, it: fn(u8) -> bool) {\n     eachi(s, |_i, b| it(b) )\n }\n \n /// Iterate over the bytes in a string, with indices\n #[inline(always)]\n-pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n+pub pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n     let mut i = 0u, l = len(s);\n     while (i < l) {\n         if !it(i, s[i]) { break; }\n@@ -924,13 +815,13 @@ pure fn eachi(s: &str, it: fn(uint, u8) -> bool) {\n \n /// Iterates over the chars in a string\n #[inline(always)]\n-pure fn each_char(s: &str, it: fn(char) -> bool) {\n+pub pure fn each_char(s: &str, it: fn(char) -> bool) {\n     each_chari(s, |_i, c| it(c))\n }\n \n /// Iterates over the chars in a string, with indices\n #[inline(always)]\n-pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n+pub pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n     let mut pos = 0u, ch_pos = 0u;\n     let len = len(s);\n     while pos < len {\n@@ -942,7 +833,7 @@ pure fn each_chari(s: &str, it: fn(uint, char) -> bool) {\n }\n \n /// Iterate over the characters in a string\n-pure fn chars_each(s: &str, it: fn(char) -> bool) {\n+pub pure fn chars_each(s: &str, it: fn(char) -> bool) {\n     let mut pos = 0u;\n     let len = len(s);\n     while (pos < len) {\n@@ -953,28 +844,28 @@ pure fn chars_each(s: &str, it: fn(char) -> bool) {\n }\n \n /// Apply a function to each substring after splitting by character\n-pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n+pub pure fn split_char_each(ss: &str, cc: char, ff: fn(v: &str) -> bool) {\n     vec::each(split_char(ss, cc), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each substring after splitting by character, up to\n  * `count` times\n  */\n-pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n+pub pure fn splitn_char_each(ss: &str, sep: char, count: uint,\n                          ff: fn(v: &str) -> bool) {\n     vec::each(splitn_char(ss, sep, count), |s| ff(*s))\n }\n \n /// Apply a function to each word\n-pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn words_each(ss: &str, ff: fn(v: &str) -> bool) {\n     vec::each(words(ss), |s| ff(*s))\n }\n \n /**\n  * Apply a function to each line (by '\\n')\n  */\n-pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n+pub pure fn lines_each(ss: &str, ff: fn(v: &str) -> bool) {\n     vec::each(lines(ss), |s| ff(*s))\n }\n \n@@ -995,7 +886,7 @@ Section: Searching\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find_char(s: &str, c: char) -> Option<uint> {\n+pub pure fn find_char(s: &str, c: char) -> Option<uint> {\n     find_char_between(s, c, 0u, len(s))\n }\n \n@@ -1019,7 +910,7 @@ pure fn find_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     find_char_between(s, c, start, len(s))\n }\n \n@@ -1044,7 +935,7 @@ pure fn find_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n+pub pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         assert start <= end;\n@@ -1074,7 +965,7 @@ pure fn find_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n+pub pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n     rfind_char_between(s, c, len(s), 0u)\n }\n \n@@ -1098,7 +989,7 @@ pure fn rfind_char(s: &str, c: char) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be\n  * the index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n+pub pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n     rfind_char_between(s, c, start, 0u)\n }\n \n@@ -1123,7 +1014,7 @@ pure fn rfind_char_from(s: &str, c: char, start: uint) -> Option<uint> {\n  * or equal to `len(s)`. `start` must be the index of a character boundary,\n  * as defined by `is_char_boundary`.\n  */\n-pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n+pub pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n     -> Option<uint> {\n     if c < 128u as char {\n         assert start >= end;\n@@ -1154,7 +1045,7 @@ pure fn rfind_char_between(s: &str, c: char, start: uint, end: uint)\n  * An `option` containing the byte index of the first matching character\n  * or `none` if there is no match\n  */\n-pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n     find_between(s, 0u, len(s), f)\n }\n \n@@ -1178,7 +1069,7 @@ pure fn find(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)`. `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_from(s: &str, start: uint, f: fn(char)\n+pub pure fn find_from(s: &str, start: uint, f: fn(char)\n     -> bool) -> Option<uint> {\n     find_between(s, start, len(s), f)\n }\n@@ -1205,7 +1096,7 @@ pure fn find_from(s: &str, start: uint, f: fn(char)\n  * or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`.\n  */\n-pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n+pub pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n     assert start <= end;\n     assert end <= len(s);\n@@ -1233,7 +1124,7 @@ pure fn find_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n  * An option containing the byte index of the last matching character\n  * or `none` if there is no match\n  */\n-pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n+pub pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n     rfind_between(s, len(s), 0u, f)\n }\n \n@@ -1257,7 +1148,7 @@ pure fn rfind(s: &str, f: fn(char) -> bool) -> Option<uint> {\n  * `start` must be less than or equal to `len(s)', `start` must be the\n  * index of a character boundary, as defined by `is_char_boundary`\n  */\n-pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n+pub pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n     rfind_between(s, start, 0u, f)\n }\n@@ -1284,7 +1175,7 @@ pure fn rfind_from(s: &str, start: uint, f: fn(char) -> bool)\n  * than or equal to `len(s)`. `start` must be the index of a character\n  * boundary, as defined by `is_char_boundary`\n  */\n-pure fn rfind_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n+pub pure fn rfind_between(s: &str, start: uint, end: uint, f: fn(char) -> bool)\n     -> Option<uint> {\n     assert start >= end;\n     assert start <= len(s);\n@@ -1318,7 +1209,7 @@ pure fn match_at(haystack: &a/str, needle: &b/str, at: uint) -> bool {\n  * An `option` containing the byte index of the first matching substring\n  * or `none` if there is no match\n  */\n-pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n+pub pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n     find_str_between(haystack, needle, 0u, len(haystack))\n }\n \n@@ -1341,7 +1232,7 @@ pure fn find_str(haystack: &a/str, needle: &b/str) -> Option<uint> {\n  *\n  * `start` must be less than or equal to `len(s)`\n  */\n-pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n+pub pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n   -> Option<uint> {\n     find_str_between(haystack, needle, start, len(haystack))\n }\n@@ -1366,7 +1257,7 @@ pure fn find_str_from(haystack: &a/str, needle: &b/str, start: uint)\n  * `start` must be less than or equal to `end` and `end` must be less than\n  * or equal to `len(s)`.\n  */\n-pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n+pub pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n                          end:uint)\n   -> Option<uint> {\n     // See Issue #1932 for why this is a naive search\n@@ -1392,7 +1283,7 @@ pure fn find_str_between(haystack: &a/str, needle: &b/str, start: uint,\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n     find_str(haystack, needle).is_some()\n }\n \n@@ -1404,7 +1295,7 @@ pure fn contains(haystack: &a/str, needle: &b/str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The char to look for\n  */\n-pure fn contains_char(haystack: &str, needle: char) -> bool {\n+pub pure fn contains_char(haystack: &str, needle: char) -> bool {\n     find_char(haystack, needle).is_some()\n }\n \n@@ -1416,7 +1307,7 @@ pure fn contains_char(haystack: &str, needle: char) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1431,7 +1322,7 @@ pure fn starts_with(haystack: &a/str, needle: &b/str) -> bool {\n  * * haystack - The string to look in\n  * * needle - The string to look for\n  */\n-pure fn ends_with(haystack: &a/str, needle: &b/str) -> bool {\n+pub pure fn ends_with(haystack: &a/str, needle: &b/str) -> bool {\n     let haystack_len = len(haystack), needle_len = len(needle);\n     if needle_len == 0u { true }\n     else if needle_len > haystack_len { false }\n@@ -1443,24 +1334,24 @@ Section: String properties\n */\n \n /// Determines if a string contains only ASCII characters\n-pure fn is_ascii(s: &str) -> bool {\n+pub pure fn is_ascii(s: &str) -> bool {\n     let mut i: uint = len(s);\n     while i > 0u { i -= 1u; if !u8::is_ascii(s[i]) { return false; } }\n     return true;\n }\n \n /// Returns true if the string has length 0\n-pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n+pub pure fn is_empty(s: &str) -> bool { len(s) == 0u }\n \n /// Returns true if the string has length greater than 0\n-pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n+pub pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n \n /**\n  * Returns true if the string contains only whitespace\n  *\n  * Whitespace characters are determined by `char::is_whitespace`\n  */\n-pure fn is_whitespace(s: &str) -> bool {\n+pub pure fn is_whitespace(s: &str) -> bool {\n     return all(s, char::is_whitespace);\n }\n \n@@ -1474,19 +1365,19 @@ fn is_alphanumeric(s: &str) -> bool {\n }\n \n /// Returns the string length/size in bytes not counting the null terminator\n-pure fn len(s: &str) -> uint {\n+pub pure fn len(s: &str) -> uint {\n     do as_buf(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n-pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n+pub pure fn char_len(s: &str) -> uint { count_chars(s, 0u, len(s)) }\n \n /*\n Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pure fn is_utf8(v: &[const u8]) -> bool {\n+pub pure fn is_utf8(v: &[const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1504,7 +1395,7 @@ pure fn is_utf8(v: &[const u8]) -> bool {\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n-pure fn is_utf16(v: &[u16]) -> bool {\n+pub pure fn is_utf16(v: &[u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1525,7 +1416,7 @@ pure fn is_utf16(v: &[u16]) -> bool {\n }\n \n /// Converts to a vector of `u16` encoded as UTF-16\n-pure fn to_utf16(s: &str) -> ~[u16] {\n+pub pure fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n     for chars_each(s) |cch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n@@ -1547,7 +1438,7 @@ pure fn to_utf16(s: &str) -> ~[u16] {\n     move u\n }\n \n-pure fn utf16_chars(v: &[u16], f: fn(char)) {\n+pub pure fn utf16_chars(v: &[u16], f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1572,7 +1463,7 @@ pure fn utf16_chars(v: &[u16], f: fn(char)) {\n }\n \n \n-pure fn from_utf16(v: &[u16]) -> ~str {\n+pub pure fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unsafe {\n         reserve(&mut buf, vec::len(v));\n@@ -1595,7 +1486,7 @@ pure fn from_utf16(v: &[u16]) -> ~str {\n  *\n  * The number of Unicode characters in `s` between the given indices.\n  */\n-pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n+pub pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n     assert is_char_boundary(s, start);\n     assert is_char_boundary(s, end);\n     let mut i = start, len = 0u;\n@@ -1608,7 +1499,7 @@ pure fn count_chars(s: &str, start: uint, end: uint) -> uint {\n }\n \n /// Counts the number of bytes taken by the `n` in `s` starting from `start`.\n-pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n+pub pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n     assert is_char_boundary(s, start);\n     let mut end = start, cnt = n;\n     let l = len(s);\n@@ -1622,7 +1513,7 @@ pure fn count_bytes(s: &b/str, start: uint, n: uint) -> uint {\n }\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n-pure fn utf8_char_width(b: u8) -> uint {\n+pub pure fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n     if byte < 128u { return 1u; }\n     // Not a valid start byte\n@@ -1638,7 +1529,7 @@ pure fn utf8_char_width(b: u8) -> uint {\n  * Returns false if the index points into the middle of a multi-byte\n  * character sequence.\n  */\n-pure fn is_char_boundary(s: &str, index: uint) -> bool {\n+pub pure fn is_char_boundary(s: &str, index: uint) -> bool {\n     if index == len(s) { return true; }\n     let b = s[index];\n     return b < 128u8 || b >= 192u8;\n@@ -1693,7 +1584,7 @@ pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * If `i` is greater than or equal to the length of the string.\n  * If `i` is not the index of the beginning of a valid UTF-8 character.\n  */\n-pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n+pub pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -1716,7 +1607,7 @@ pure fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n }\n \n /// Pluck a character out of a string\n-pure fn char_at(s: &str, i: uint) -> char { return char_range_at(s, i).ch; }\n+pub pure fn char_at(s: &str, i: uint) -> char { return char_range_at(s, i).ch; }\n \n /**\n  * Given a byte position and a str, return the previous char and its position\n@@ -1762,7 +1653,7 @@ pure fn char_range_at_reverse(ss: &str, start: uint)\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-pure fn all_between(s: &str, start: uint, end: uint,\n+pub pure fn all_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     assert is_char_boundary(s, start);\n     let mut i = start;\n@@ -1795,7 +1686,7 @@ pure fn all_between(s: &str, start: uint, end: uint,\n  *\n  * `true` if `it` returns `true` for any character\n  */\n-pure fn any_between(s: &str, start: uint, end: uint,\n+pub pure fn any_between(s: &str, start: uint, end: uint,\n                     it: fn(char) -> bool) -> bool {\n     !all_between(s, start, end, |c| !it(c))\n }\n@@ -1827,7 +1718,7 @@ const tag_six_b: uint = 252u;\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pure fn as_bytes<T>(s: &const ~str, f: fn((&~[u8])) -> T) -> T {\n+pub pure fn as_bytes<T>(s: &const ~str, f: fn((&~[u8])) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n         f(&*v)\n@@ -1839,7 +1730,7 @@ pure fn as_bytes<T>(s: &const ~str, f: fn((&~[u8])) -> T) -> T {\n  *\n  * The byte slice does not include the null terminator.\n  */\n-pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n+pub pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n     unsafe {\n         let (ptr, len): (*u8, uint) = ::cast::reinterpret_cast(&s);\n         let outgoing_tuple: (*u8, uint) = (ptr, len - 1);\n@@ -1862,7 +1753,7 @@ pure fn as_bytes_slice(s: &a/str) -> &a/[u8] {\n  * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n+pub pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n     do as_buf(s) |buf, len| {\n         // NB: len includes the trailing null.\n         assert len > 0;\n@@ -1884,7 +1775,7 @@ pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n+pub pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::cast::reinterpret_cast(&ptr::addr_of(s));\n         let (buf,len) = *v;\n@@ -1908,7 +1799,7 @@ pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve(s: &const ~str, n: uint) {\n+pub fn reserve(s: &const ~str, n: uint) {\n     unsafe {\n         let v: *mut ~[u8] = cast::transmute(copy s);\n         vec::reserve(&mut *v, n + 1);\n@@ -1935,15 +1826,15 @@ fn reserve(s: &const ~str, n: uint) {\n  * * s - A string\n  * * n - The number of bytes to reserve space for\n  */\n-fn reserve_at_least(s: &const ~str, n: uint) {\n+pub fn reserve_at_least(s: &const ~str, n: uint) {\n     reserve(s, uint::next_power_of_two(n + 1u) - 1u)\n }\n \n /**\n  * Returns the number of single-byte characters the string can hold without\n  * reallocating\n  */\n-pure fn capacity(s: &const ~str) -> uint {\n+pub pure fn capacity(s: &const ~str) -> uint {\n     do as_bytes(s) |buf| {\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;\n@@ -1952,7 +1843,7 @@ pure fn capacity(s: &const ~str) -> uint {\n }\n \n /// Escape each char in `s` with char::escape_default.\n-pure fn escape_default(s: &str) -> ~str {\n+pub pure fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -1964,7 +1855,7 @@ pure fn escape_default(s: &str) -> ~str {\n }\n \n /// Escape each char in `s` with char::escape_unicode.\n-pure fn escape_unicode(s: &str) -> ~str {\n+pub pure fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     unsafe {\n         reserve_at_least(&mut out, str::len(s));\n@@ -1976,24 +1867,10 @@ pure fn escape_unicode(s: &str) -> ~str {\n }\n \n /// Unsafe operations\n-mod raw {\n-    #[legacy_exports];\n-   export\n-      from_buf,\n-      from_buf_len,\n-      from_c_str,\n-      from_c_str_len,\n-      from_bytes,\n-      buf_as_slice,\n-      slice_bytes,\n-      view_bytes,\n-      push_byte,\n-      pop_byte,\n-      shift_byte,\n-      set_len;\n+pub mod raw {\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n-    unsafe fn from_buf(buf: *u8) -> ~str {\n+    pub unsafe fn from_buf(buf: *u8) -> ~str {\n         let mut curr = buf, i = 0u;\n         while *curr != 0u8 {\n             i += 1u;\n@@ -2003,7 +1880,7 @@ mod raw {\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n+    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         vec::as_mut_buf(v, |vbuf, _len| {\n             ptr::memcpy(vbuf, buf as *u8, len)\n@@ -2016,27 +1893,27 @@ mod raw {\n     }\n \n     /// Create a Rust string from a null-terminated C string\n-    unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n+    pub unsafe fn from_c_str(c_str: *libc::c_char) -> ~str {\n         from_buf(::cast::reinterpret_cast(&c_str))\n     }\n \n     /// Create a Rust string from a `*c_char` buffer of the given length\n-    unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n+    pub unsafe fn from_c_str_len(c_str: *libc::c_char, len: uint) -> ~str {\n         from_buf_len(::cast::reinterpret_cast(&c_str), len)\n     }\n \n     /// Converts a vector of bytes to a string.\n-    unsafe fn from_bytes(v: &[const u8]) -> ~str {\n+    pub pub unsafe fn from_bytes(v: &[const u8]) -> ~str {\n         do vec::as_const_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }\n \n     /// Converts a byte to a string.\n-    unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n+    pub unsafe fn from_byte(u: u8) -> ~str { raw::from_bytes([u]) }\n \n     /// Form a slice from a *u8 buffer of the given length without copying.\n-    unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n+    pub unsafe fn buf_as_slice<T>(buf: *u8, len: uint,\n                               f: fn(v: &str) -> T) -> T {\n         let v = (buf, len + 1);\n         assert is_utf8(::cast::reinterpret_cast(&v));\n@@ -2053,7 +1930,7 @@ mod raw {\n      * If begin is greater than end.\n      * If end is greater than the length of the string.\n      */\n-    unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n+    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n             assert (begin <= end);\n             assert (end <= n);\n@@ -2083,7 +1960,7 @@ mod raw {\n      * If end is greater than the length of the string.\n      */\n     #[inline]\n-    unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n              assert (begin <= end);\n              assert (end <= n);\n@@ -2094,7 +1971,7 @@ mod raw {\n     }\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n-    unsafe fn push_byte(s: &const ~str, b: u8) {\n+    pub unsafe fn push_byte(s: &const ~str, b: u8) {\n         reserve_at_least(s, s.len() + 1);\n         do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n@@ -2110,7 +1987,7 @@ mod raw {\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    unsafe fn pop_byte(s: &const ~str) -> u8 {\n+    pub unsafe fn pop_byte(s: &const ~str) -> u8 {\n         let len = len(*s);\n         assert (len > 0u);\n         let b = s[len - 1u];\n@@ -2119,7 +1996,7 @@ mod raw {\n     }\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-    unsafe fn shift_byte(s: &mut ~str) -> u8 {\n+    pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert (len > 0u);\n         let b = s[0];\n@@ -2128,7 +2005,7 @@ mod raw {\n     }\n \n     /// Sets the length of the string and adds the null terminator\n-    unsafe fn set_len(v: &const ~str, new_len: uint) {\n+    pub unsafe fn set_len(v: &const ~str, new_len: uint) {\n         let v: **vec::raw::VecRepr = cast::transmute(copy v);\n         let repr: *vec::raw::VecRepr = *v;\n         (*repr).unboxed.fill = new_len + 1u;\n@@ -2149,7 +2026,7 @@ mod raw {\n \n }\n \n-trait UniqueStr {\n+pub trait UniqueStr {\n     fn trim() -> self;\n     fn trim_left() -> self;\n     fn trim_right() -> self;\n@@ -2169,8 +2046,7 @@ impl ~str: UniqueStr {\n }\n \n #[cfg(notest)]\n-mod traits {\n-    #[legacy_exports];\n+pub mod traits {\n     impl ~str : Add<&str,~str> {\n         #[inline(always)]\n         pure fn add(rhs: & &str) -> ~str {\n@@ -2180,10 +2056,9 @@ mod traits {\n }\n \n #[cfg(test)]\n-mod traits {\n-    #[legacy_exports];}\n+pub mod traits {}\n \n-trait StrSlice {\n+pub trait StrSlice {\n     fn all(it: fn(char) -> bool) -> bool;\n     fn any(it: fn(char) -> bool) -> bool;\n     fn contains(needle: &a/str) -> bool;\n@@ -2326,7 +2201,6 @@ impl &str: StrSlice {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     use libc::c_char;\n "}]}