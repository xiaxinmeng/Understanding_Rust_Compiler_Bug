{"sha": "9f60e7c306e5052136318806bdd44fc4433f5632", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNjBlN2MzMDZlNTA1MjEzNjMxODgwNmJkZDQ0ZmM0NDMzZjU2MzI=", "commit": {"author": {"name": "William Ting", "email": "io@williamting.com", "date": "2014-01-12T02:25:19Z"}, "committer": {"name": "William Ting", "email": "io@williamting.com", "date": "2014-01-28T20:52:36Z"}, "message": "Update extract-tests.py to use same test directives as rustdoc.\n\nCloses #11362.", "tree": {"sha": "19d2bb7214130faa8b0fc07e7a48242359995c15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19d2bb7214130faa8b0fc07e7a48242359995c15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f60e7c306e5052136318806bdd44fc4433f5632", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f60e7c306e5052136318806bdd44fc4433f5632", "html_url": "https://github.com/rust-lang/rust/commit/9f60e7c306e5052136318806bdd44fc4433f5632", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f60e7c306e5052136318806bdd44fc4433f5632/comments", "author": {"login": "wting", "id": 622170, "node_id": "MDQ6VXNlcjYyMjE3MA==", "avatar_url": "https://avatars.githubusercontent.com/u/622170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wting", "html_url": "https://github.com/wting", "followers_url": "https://api.github.com/users/wting/followers", "following_url": "https://api.github.com/users/wting/following{/other_user}", "gists_url": "https://api.github.com/users/wting/gists{/gist_id}", "starred_url": "https://api.github.com/users/wting/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wting/subscriptions", "organizations_url": "https://api.github.com/users/wting/orgs", "repos_url": "https://api.github.com/users/wting/repos", "events_url": "https://api.github.com/users/wting/events{/privacy}", "received_events_url": "https://api.github.com/users/wting/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wting", "id": 622170, "node_id": "MDQ6VXNlcjYyMjE3MA==", "avatar_url": "https://avatars.githubusercontent.com/u/622170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wting", "html_url": "https://github.com/wting", "followers_url": "https://api.github.com/users/wting/followers", "following_url": "https://api.github.com/users/wting/following{/other_user}", "gists_url": "https://api.github.com/users/wting/gists{/gist_id}", "starred_url": "https://api.github.com/users/wting/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wting/subscriptions", "organizations_url": "https://api.github.com/users/wting/orgs", "repos_url": "https://api.github.com/users/wting/repos", "events_url": "https://api.github.com/users/wting/events{/privacy}", "received_events_url": "https://api.github.com/users/wting/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3d10f43833f065ec0e635ce6cdb2332f4ee5049", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d10f43833f065ec0e635ce6cdb2332f4ee5049", "html_url": "https://github.com/rust-lang/rust/commit/b3d10f43833f065ec0e635ce6cdb2332f4ee5049"}], "stats": {"total": 551, "additions": 338, "deletions": 213}, "files": [{"sha": "2d0cc16d189dc1bd1412459d17a20365c02e796f", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -351,7 +351,7 @@ Vincent Belliard <vincent@famillebelliard.fr>\n Vivek Galatage <vivekgalatage@gmail.com>\n Volker Mische <volker.mische@gmail.com>\n Wade Mealing <wmealing@gmail.com>\n-William Ting <william.h.ting@gmail.com>\n+William Ting <io@williamting.com>\n Yasuhiro Fujii <y-fujii@mimosa-pudica.net>\n Young-il Choi <duddlf.choi@samsung.com>\n Youngmin Yoo <youngmin.yoo@samsung.com>"}, {"sha": "a92980d5e703d35965030567b90167eae2c70d2c", "filename": "doc/complement-cheatsheet.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcomplement-cheatsheet.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -48,7 +48,7 @@ let y: i64 = x.unwrap();\n \n Use [`File::open`](http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html#method.open) to create a [`File`](http://static.rust-lang.org/doc/master/std/io/fs/struct.File.html) struct, which implements the [`Reader`](http://static.rust-lang.org/doc/master/std/io/trait.Reader.html) trait.\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n use std::path::Path;\n use std::io::fs::File;\n \n@@ -168,7 +168,7 @@ let _ = close(Door::<Open>(~\"front\"));\n \n Attempting to close a closed door is prevented statically:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n let _ = close(Door::<Closed>(~\"front\")); // error: mismatched types: expected `main::Door<main::Open>` but found `main::Door<main::Closed>`\n ~~~\n \n@@ -196,7 +196,7 @@ Window* createWindow(int width, int height);\n \n You can use a zero-element `enum` ([phantom type](#how-do-i-express-phantom-types)) to represent the opaque object handle. The FFI would look like this:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n enum Window {}\n extern \"C\" {\n     fn createWindow(width: c_int, height: c_int) -> *Window;"}, {"sha": "d4cc3d8ffbe9abe2e7de89266559750bfe38d3d1", "filename": "doc/guide-conditions.md", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-conditions.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -45,7 +45,6 @@ An example program that does this task reads like this:\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n #     use std::io::File;\n@@ -243,7 +242,6 @@ and trapping its exit status using `task::try`:\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n use std::io::{BufferedReader, File};\n use std::task;\n # mod BufferedReader {\n@@ -347,7 +345,6 @@ but similarly clear as the version that used `fail!` in the logic where the erro\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n #     use std::io::File;\n@@ -416,7 +413,6 @@ and replaces bad input lines with the pair `(-1,-1)`:\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n #     use std::io::File;\n@@ -491,7 +487,6 @@ Changing the condition's return type from `(int,int)` to `Option<(int,int)>` wil\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n #     use std::io::File;\n@@ -576,8 +571,7 @@ This can be encoded in the handler API by introducing a helper type: `enum Malfo\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n-use std::io::File;\n+use std::io::{BufferedReader, File};\n # mod BufferedReader {\n #     use std::io::File;\n #     use std::io::MemReader;\n@@ -700,7 +694,6 @@ a second condition and a helper function will suffice:\n \n ~~~~\n # #[allow(unused_imports)];\n-# extern mod extra;\n use std::io::{BufferedReader, File};\n # mod BufferedReader {\n #     use std::io::File;"}, {"sha": "1c79be1eb824777f83b979b34b454a1f36012297", "filename": "doc/guide-container.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-container.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -270,7 +270,7 @@ Containers can provide conversion from iterators through `collect` by\n implementing the `FromIterator` trait. For example, the implementation for\n vectors is as follows:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n impl<A> FromIterator<A> for ~[A] {\n     pub fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> ~[A] {\n         let (lower, _) = iterator.size_hint();\n@@ -288,7 +288,7 @@ impl<A> FromIterator<A> for ~[A] {\n The `Iterator` trait provides a `size_hint` default method, returning a lower\n bound and optionally on upper bound on the length of the iterator:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n ~~~\n "}, {"sha": "c892c06902a35ce7ffdbce4bde37d0578c7677a6", "filename": "doc/guide-ffi.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-ffi.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -11,7 +11,7 @@ snappy includes a C interface (documented in\n The following is a minimal example of calling a foreign function which will\n compile if snappy is installed:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n use std::libc::size_t;\n \n #[link(name = \"snappy\")]\n@@ -43,7 +43,7 @@ keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n use std::libc::{c_int, size_t};\n \n #[link(name = \"snappy\")]\n@@ -76,7 +76,7 @@ vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n     unsafe {\n         snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n@@ -96,7 +96,7 @@ required capacity to hold the compressed output. The vector can then be passed t\n `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n the true length after compression for setting the length.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n pub fn compress(src: &[u8]) -> ~[u8] {\n     unsafe {\n         let srclen = src.len() as size_t;\n@@ -116,7 +116,7 @@ pub fn compress(src: &[u8]) -> ~[u8] {\n Decompression is similar, because snappy stores the uncompressed size as part of the compression\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n pub fn uncompress(src: &[u8]) -> Option<~[u8]> {\n     unsafe {\n         let srclen = src.len() as size_t;\n@@ -263,7 +263,7 @@ to the C library and afterwards be invoked from there.\n A basic example is:\n \n Rust code:\n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n extern fn callback(a:i32) {\n     println!(\"I'm called from C with value {0}\", a);\n }\n@@ -283,7 +283,7 @@ fn main() {\n ~~~~\n \n C code:\n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n \n@@ -314,7 +314,7 @@ the notification. This will allow the callback to unsafely access the\n referenced Rust object.\n \n Rust code:\n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n \n struct RustObject {\n     a: i32,\n@@ -346,7 +346,7 @@ fn main() {\n ~~~~\n \n C code:\n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n typedef void (*rust_callback)(int32_t);\n void* cb_target;\n rust_callback cb;\n@@ -440,7 +440,7 @@ the `link_args` attribute. This attribute is applied to `extern` blocks and\n specifies raw flags which need to get passed to the linker when producing an\n artifact. An example usage would be:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n #[link_args = \"-foo -bar -baz\"]\n extern {}\n ~~~\n@@ -476,7 +476,7 @@ Foreign APIs often export a global variable which could do something like track\n global state. In order to access these variables, you declare them in `extern`\n blocks with the `static` keyword:\n \n-~~~{.xfail-test}\n+~~~{.ignore}\n use std::libc;\n \n #[link(name = \"readline\")]\n@@ -494,7 +494,7 @@ Alternatively, you may need to alter global state provided by a foreign\n interface. To do this, statics can be declared with `mut` so rust can mutate\n them.\n \n-~~~{.xfail-test}\n+~~~{.ignore}\n use std::libc;\n use std::ptr;\n "}, {"sha": "d31b0eed8492a8548f07dc4ce3e3e0cd141d7bf7", "filename": "doc/guide-lifetimes.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-lifetimes.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -299,7 +299,7 @@ _as soon as its owning reference changes or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n fn example3() -> int {\n     let mut x = ~X {f: 3};\n     let y = &x.f;\n@@ -346,7 +346,7 @@ modify the previous example to introduce additional owned pointers\n and structs, and the compiler will still be able to detect possible\n mutations:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n fn example3() -> int {\n     struct R { g: int }\n     struct S { f: ~R }\n@@ -524,7 +524,7 @@ the compiler accepts the function `get_x()`.\n To emphasize this point, let\u2019s look at a variation on the example, this\n time one that does not compile:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n struct Point {x: f64, y: f64}\n fn get_x_sh(p: @Point) -> &f64 {\n     &p.x // Error reported here"}, {"sha": "3365fd479ca8e357ec0655d874f8b231d04aa8ee", "filename": "doc/guide-pointers.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -21,7 +21,7 @@ fn succ(x: &int) -> int { *x + 1 }\n \n So I wrote this code to try it out:\n \n-~~~rust{.xfail-test}\n+~~~rust{.ignore}\n fn main() {\n     let number = 5;\n     let succ_number = succ(number);\n@@ -261,7 +261,7 @@ program is very large and complicated.\n \n For example, let's say you're using an owned pointer, and you want to do this:\n \n-~~~rust{.xfail-test}\n+~~~rust{.ignore}\n struct Point {\n     x: int,\n     y: int,\n@@ -369,7 +369,7 @@ This theory is called 'region pointers,' and involve a concept called\n 'lifetimes'. Here's the simple explanation: would you expect this code to\n compile?\n \n-~~~rust{.xfail-test}\n+~~~rust{.ignore}\n fn main() {\n     println!(\"{}\", x);\n     let x = 5;\n@@ -398,7 +398,7 @@ Here, we're borrowing a pointer to `x` inside of the `if`. The compiler, however\n is able to determine that that pointer will go out of scope without `x` being\n mutated, and therefore, lets us pass. This wouldn't work:\n \n-~~~rust{.xfail-test}\n+~~~rust{.ignore}\n fn main() {\n     let mut x = ~5;\n     if *x < 10 {"}, {"sha": "d9a80b9385303b461e3d8389785c1f72087d8b4b", "filename": "doc/guide-tasks.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-tasks.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -190,7 +190,7 @@ senders cannot use a single `Chan`, and multiple receivers cannot use a single\n `Port`.  What if our example needed to compute multiple results across a number\n of tasks? The following program is ill-typed:\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n # use std::task::{spawn};\n # fn some_expensive_computation() -> int { 42 }\n let (port, chan) = Chan::new();\n@@ -413,7 +413,7 @@ pattern-match on a result to check whether it's an `Ok` result with an `int`\n field (representing a successful result) or an `Err` result (representing\n termination with an error).\n \n-~~~{.xfail-test .linked-failure}\n+~~~{.ignore .linked-failure}\n # use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n@@ -463,7 +463,7 @@ that repeatedly receives a `uint` message, converts it to a string, and sends\n the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n-~~~{.xfail-test .linked-failure}\n+~~~{.ignore .linked-failure}\n # use extra::comm::DuplexStream;\n # use std::uint;\n fn stringifier(channel: &DuplexStream<~str, uint>) {\n@@ -486,7 +486,7 @@ response itself is simply the stringified version of the received value,\n \n Here is the code for the parent task:\n \n-~~~{.xfail-test .linked-failure}\n+~~~{.ignore .linked-failure}\n # use std::task::spawn;\n # use std::uint;\n # use extra::comm::DuplexStream;"}, {"sha": "0089e4a81a3f2f793e33232dd7aacd64ecaed33a", "filename": "doc/po/ja/complement-cheatsheet.md.po", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fcomplement-cheatsheet.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -112,7 +112,7 @@ msgstr \"## \u6f14\u7b97\u5b50\"\n #: doc/complement-cheatsheet.md:54\n #, fuzzy\n #| msgid \"~~~~ use std::task::spawn;\"\n-msgid \"~~~ {.xfail-test} use std::path::Path; use std::io::fs::File;\"\n+msgid \"~~~ {.ignore} use std::path::Path; use std::io::fs::File;\"\n msgstr \"\"\n \"~~~~\\n\"\n \"use std::task::spawn;\""}, {"sha": "af1b566a0f4e7ffde9779291667eddc48d6ccf7b", "filename": "doc/po/ja/guide-ffi.md.po", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-ffi.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-ffi.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-ffi.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -34,7 +34,7 @@ msgstr \"[\u4ed6\u8a00\u8a9e\u9593\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9 (foreign function inferface)][ffi]\n #: doc/guide-ffi.md:16\n #, fuzzy\n #| msgid \"~~~~ use std::task::spawn;\"\n-msgid \"~~~~ {.xfail-test} use std::libc::size_t;\"\n+msgid \"~~~~ {.ignore} use std::libc::size_t;\"\n msgstr \"\"\n \"~~~~\\n\"\n \"use std::task::spawn;\"\n@@ -43,7 +43,7 @@ msgstr \"\"\n #: doc/guide-ffi.md:48\n #, fuzzy\n #| msgid \"~~~~ use std::task::spawn;\"\n-msgid \"~~~~ {.xfail-test} use std::libc::{c_int, size_t};\"\n+msgid \"~~~~ {.ignore} use std::libc::{c_int, size_t};\"\n msgstr \"\"\n \"~~~~\\n\"\n \"use std::task::spawn;\"\n@@ -67,7 +67,7 @@ msgstr \"\"\n #: doc/guide-ffi.md:344\n #, fuzzy\n #| msgid \"~~~~ use std::task::spawn;\"\n-msgid \"~~~{.xfail-test} use std::libc;\"\n+msgid \"~~~{.ignore} use std::libc;\"\n msgstr \"\"\n \"~~~~\\n\"\n \"use std::task::spawn;\"\n@@ -76,7 +76,7 @@ msgstr \"\"\n #: doc/guide-ffi.md:363\n #, fuzzy\n #| msgid \"~~~~ use std::task::spawn;\"\n-msgid \"~~~{.xfail-test} use std::libc; use std::ptr;\"\n+msgid \"~~~{.ignore} use std::libc; use std::ptr;\"\n msgstr \"\"\n \"~~~~\\n\"\n \"use std::task::spawn;\""}, {"sha": "ef7c51f52cf0f98961d750fa77888a58af7d12c4", "filename": "doc/po/ja/guide-lifetimes.md.po", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-lifetimes.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-lifetimes.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-lifetimes.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -63,7 +63,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/guide-lifetimes.md:48\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"~~~\\n\"\n \"# struct Point {x: f64, y: f64}\\n\"\n@@ -72,7 +72,7 @@ msgid \"\"\n \"let owned_box    : ~Point = ~Point {x: 7.0, y: 9.0};\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -123,7 +123,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/guide-lifetimes.md:82\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"~~~\\n\"\n \"# struct Point {x: f64, y: f64}\\n\"\n@@ -135,7 +135,7 @@ msgid \"\"\n \"compute_distance(managed_box, owned_box);\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\""}, {"sha": "e270babac8515052079c3eaf71c8ca3682ee05cc", "filename": "doc/po/ja/guide-pointers.md.po", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-pointers.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-pointers.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-pointers.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -46,23 +46,23 @@ msgstr \"\"\n #. type: Plain text\n #: doc/guide-pointers.md:115\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let p0 = Point { x: 5, y: 10};\\n\"\n \"    let p1 = transform(p0);\\n\"\n \"    println!(\\\"{:?}\\\", p1);\\n\"\n \"}\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n \n #. type: Plain text\n #: doc/guide-pointers.md:129\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"~~~rust\\n\"\n \"# struct Point {\\n\"\n@@ -74,29 +74,29 @@ msgid \"\"\n \"    Point { x: p.x + 1, y: p.y + 1}\\n\"\n \"}\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n \n #. type: Plain text\n #: doc/guide-pointers.md:145\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn transform(p: Point) -> Point {\\n\"\n \"    Point { x: p.x + 1, y: p.y + 1}\\n\"\n \"}\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n \n #. type: Plain text\n #: doc/guide-pointers.md:152\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let p0 = Point { x: 5, y: 10};\\n\"\n@@ -105,7 +105,7 @@ msgid \"\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -133,7 +133,7 @@ msgstr \"# \u30c7\u30fc\u30bf\u69cb\u9020\"\n #. type: Plain text\n #: doc/guide-pointers.md:229\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let a = Point { x: 10, y: 20 };\\n\"\n@@ -143,15 +143,15 @@ msgid \"\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n \n #. type: Plain text\n #: doc/guide-pointers.md:246\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let a = ~Point { x: 10, y: 20 };\\n\"\n@@ -161,7 +161,7 @@ msgid \"\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -176,7 +176,7 @@ msgstr \"## \u30de\u30cd\u30fc\u30b8\u30c9\u30dc\u30c3\u30af\u30b9\"\n #. type: Plain text\n #: doc/guide-pointers.md:277\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let a = ~Point { x: 10, y: 20 };\\n\"\n@@ -186,15 +186,15 @@ msgid \"\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n \n #. type: Plain text\n #: doc/guide-pointers.md:308\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let a = @Point { x: 10, y: 20 };\\n\"\n@@ -204,7 +204,7 @@ msgid \"\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -227,30 +227,30 @@ msgstr \"\"\n #. type: Plain text\n #: doc/guide-pointers.md:352\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    let origin = @Point { x: 0.0, y: 0.0 };\\n\"\n \"    let p1     = ~Point { x: 5.0, y: 3.0 };\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n \n #. type: Plain text\n #: doc/guide-pointers.md:378\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n-\"~~~rust{.xfail-test}\\n\"\n+\"~~~rust{.ignore}\\n\"\n \"fn main() {\\n\"\n \"    println!(\\\"{}\\\", x);\\n\"\n \"    let x = 5;\\n\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\""}, {"sha": "04ac982d420c2114bd50be3ca43b25f29d387a20", "filename": "doc/po/ja/guide-rustpkg.md.po", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Fguide-rustpkg.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -40,14 +40,14 @@ msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n #. type: Plain text\n #: doc/guide-rustpkg.md:22\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    hello::world();\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -77,14 +77,14 @@ msgstr \"# \u30a4\u30f3\u30c8\u30ed\u30c0\u30af\u30b7\u30e7\u30f3\"\n #. type: Plain text\n #: doc/guide-rustpkg.md:149\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"pub fn world() {\\n\"\n \"    println!(\\\"Hello, world.\\\");\\n\"\n \"}\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\""}, {"sha": "c43d7ed5c8b27a30d02c7c5df7d88c124094f127", "filename": "doc/po/ja/rust.md.po", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frust.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -164,7 +164,7 @@ msgstr \"## \u4ed6\u306e\u30af\u30ec\u30fc\u30c8\u306e\u5229\u7528\"\n #: doc/rust.md:788\n #, fuzzy\n #| msgid \"~~~~ {.ignore} let foo = 10;\"\n-msgid \"~~~~ {.xfail-test} extern mod pcre;\"\n+msgid \"~~~~ {.ignore} extern mod pcre;\"\n msgstr \"\"\n \"~~~~ {.ignore}\\n\"\n \"let foo = 10;\"\n@@ -413,19 +413,19 @@ msgstr \"\"\n #: doc/rust.md:1395\n #, fuzzy\n #| msgid \"\"\n-#| \"~~~ {.xfail-test} use std::f64::consts::pi; # trait Shape { fn \"\n+#| \"~~~ {.ignore} use std::f64::consts::pi; # trait Shape { fn \"\n #| \"area(&self) -> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } \"\n #| \"# struct Point { x: f64, y: f64 } # struct CircleStruct { center: Point, \"\n #| \"radius: f64 } # impl Circle for CircleStruct { fn radius(&self) -> f64 \"\n #| \"{ (self.area() / pi).sqrt() } } # impl Shape for CircleStruct { fn \"\n #| \"area(&self) -> f64 { pi * square(self.radius) } }\"\n msgid \"\"\n-\"~~~~ {.xfail-test} # trait Shape { fn area(&self) -> f64; } # trait Circle : \"\n+\"~~~~ {.ignore} # trait Shape { fn area(&self) -> f64; } # trait Circle : \"\n \"Shape { fn radius(&self) -> f64; } # impl Shape for int { fn area(&self) -> \"\n \"f64 { 0.0 } } # impl Circle for int { fn radius(&self) -> f64 { 0.0 } } # \"\n \"let mycircle = 0;\"\n msgstr \"\"\n-\"~~~ {.xfail-test}\\n\"\n+\"~~~ {.ignore}\\n\"\n \"use std::f64::consts::pi;\\n\"\n \"# trait Shape { fn area(&self) -> f64; }\\n\"\n \"# trait Circle : Shape { fn radius(&self) -> f64; }\\n\"\n@@ -613,7 +613,7 @@ msgstr \"## \u69cb\u6587\u62e1\u5f35\"\n #: doc/rust.md:2400\n #, fuzzy\n #| msgid \"~~~~ use std::task::spawn;\"\n-msgid \"~~~~ {.xfail-test} # use std::task; # do task::spawn {\"\n+msgid \"~~~~ {.ignore} # use std::task; # do task::spawn {\"\n msgstr \"\"\n \"~~~~\\n\"\n \"use std::task::spawn;\"\n@@ -928,14 +928,14 @@ msgstr \"# \u30af\u30ed\u30fc\u30b8\u30e3\"\n #. type: Plain text\n #: doc/rust.md:3299\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"fn main() {\\n\"\n \"   print(@10 as @Printable);\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\""}, {"sha": "ddbef4c93cca573942cec5ac033edd54041ac889", "filename": "doc/po/ja/tutorial.md.po", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial.md.po?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -422,15 +422,15 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:136\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"~~~~\\n\"\n \"fn main() {\\n\"\n \"    println!(\\\"hello?\\\");\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -1390,10 +1390,10 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:604\n msgid \"\"\n-\"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point \"\n+\"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point \"\n \"{ x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -2213,7 +2213,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:1372\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"~~~\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n@@ -2222,7 +2222,7 @@ msgid \"\"\n \"let owned_box    : ~Point = ~Point { x: 7.0, y: 9.0 };\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -2265,7 +2265,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:1404\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n+#| msgid \"~~~~ {.ignore} # struct Point { x: f64, y: f64 } let mut mypoint = Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgid \"\"\n \"~~~\\n\"\n \"# struct Point{ x: f64, y: f64 };\\n\"\n@@ -2277,7 +2277,7 @@ msgid \"\"\n \"compute_distance(managed_box, owned_box);\\n\"\n \"~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"# struct Point { x: f64, y: f64 }\\n\"\n \"let mut mypoint = Point { x: 1.0, y: 1.0 };\\n\"\n \"let origin = Point { x: 0.0, y: 0.0 };\"\n@@ -3442,14 +3442,14 @@ msgstr \"\"\n #: doc/tutorial.md:2067\n #, no-wrap\n msgid \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// This does not compile\\n\"\n \"fn head_bad<T>(v: &[T]) -> T {\\n\"\n \"    v[0] // error: copying a non-copyable value\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// \u3053\u306e\u30b3\u30fc\u30c9\u306f\u30b3\u30f3\u30d1\u30a4\u30eb\u3067\u304d\u306a\u3044\\n\"\n \"fn head_bad<T>(v: &[T]) -> T {\\n\"\n \"    v[0] // error: copying a non-copyable value\\n\"\n@@ -3622,15 +3622,15 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:2148\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"~~~~\\n\"\n \"trait Printable {\\n\"\n \"    fn print(&self);\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -4077,7 +4077,7 @@ msgstr \"`Circle` \u30c8\u30ec\u30a4\u30c8\u306e\u5b9f\u88c5\u306f\u3001 `Shape` \u3092\u5b9f\u88c5\u3057\u305f\u578b\u306b\u3064\u3044\n #. type: Plain text\n #: doc/tutorial.md:2488\n #, fuzzy, no-wrap\n-#| msgid \"~~~ {.xfail-test} use std::f64::consts::pi; # trait Shape { fn area(&self) -> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct Point { x: f64, y: f64 } # struct CircleStruct { center: Point, radius: f64 } # impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / pi).sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self.radius) } }\"\n+#| msgid \"~~~ {.ignore} use std::f64::consts::pi; # trait Shape { fn area(&self) -> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct Point { x: f64, y: f64 } # struct CircleStruct { center: Point, radius: f64 } # impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / pi).sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self.radius) } }\"\n msgid \"\"\n \"~~~~\\n\"\n \"use std::f64::consts::PI;\\n\"\n@@ -4094,7 +4094,7 @@ msgid \"\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~ {.xfail-test}\\n\"\n+\"~~~ {.ignore}\\n\"\n \"use std::f64::consts::pi;\\n\"\n \"# trait Shape { fn area(&self) -> f64; }\\n\"\n \"# trait Circle : Shape { fn radius(&self) -> f64; }\\n\"\n@@ -4153,21 +4153,21 @@ msgstr \"\"\n #: doc/tutorial.md:2517\n #, fuzzy\n #| msgid \"\"\n-#| \"~~~ {.xfail-test} use std::f64::consts::pi; # trait Shape { fn \"\n+#| \"~~~ {.ignore} use std::f64::consts::pi; # trait Shape { fn \"\n #| \"area(&self) -> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } \"\n #| \"# struct Point { x: f64, y: f64 } # struct CircleStruct { center: Point, \"\n #| \"radius: f64 } # impl Circle for CircleStruct { fn radius(&self) -> f64 \"\n #| \"{ (self.area() / pi).sqrt() } } # impl Shape for CircleStruct { fn \"\n #| \"area(&self) -> f64 { pi * square(self.radius) } }\"\n msgid \"\"\n-\"~~~ {.xfail-test} use std::f64::consts::PI; # trait Shape { fn area(&self) -\"\n+\"~~~ {.ignore} use std::f64::consts::PI; # trait Shape { fn area(&self) -\"\n \"> f64; } # trait Circle : Shape { fn radius(&self) -> f64; } # struct Point \"\n \"{ x: f64, y: f64 } # struct CircleStruct { center: Point, radius: f64 } # \"\n \"impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / PI).\"\n \"sqrt() } } # impl Shape for CircleStruct { fn area(&self) -> f64 { PI * \"\n \"square(self.radius) } }\"\n msgstr \"\"\n-\"~~~ {.xfail-test}\\n\"\n+\"~~~ {.ignore}\\n\"\n \"use std::f64::consts::pi;\\n\"\n \"# trait Shape { fn area(&self) -> f64; }\\n\"\n \"# trait Circle : Shape { fn radius(&self) -> f64; }\\n\"\n@@ -4265,7 +4265,7 @@ msgstr \"## \u30af\u30ec\u30fc\u30c8\"\n #. type: Plain text\n #: doc/tutorial.md:2567\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"~~~~\\n\"\n \"// main.rs\\n\"\n@@ -4274,7 +4274,7 @@ msgid \"\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -4305,14 +4305,14 @@ msgstr \"## \u6a19\u6e96\u30e9\u30a4\u30d6\u30e9\u30ea\"\n #. type: Plain text\n #: doc/tutorial.md:2600\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    println!(\\\"Hello farm!\\\");\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -4328,12 +4328,12 @@ msgstr \"## \u30de\u30cd\u30fc\u30b8\u30c9\u30af\u30ed\u30fc\u30b8\u30e3\"\n #. type: Plain text\n #: doc/tutorial.md:2620\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    println!(\\\"Hello chicken!\\\");\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -4374,15 +4374,15 @@ msgstr \"# \u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u30af\u30ec\u30fc\u30c8\"\n #. type: Plain text\n #: doc/tutorial.md:2732\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    println!(\\\"Hello farm!\\\");\\n\"\n \"    ::farm::cow();\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -4400,12 +4400,12 @@ msgstr \"\"\n #. type: Plain text\n #: doc/tutorial.md:2929\n #, fuzzy, no-wrap\n-#| msgid \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n+#| msgid \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n \"fn main() {\\n\"\n \"    println!(\\\"Hello farm!\\\");\\n\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\"\n@@ -4438,14 +4438,14 @@ msgstr \"\"\n #: doc/tutorial.md:3144\n #, fuzzy\n #| msgid \"\"\n-#| \"~~~~ {.xfail-test} extern mod farm; extern mod my_farm (name = \\\"farm\\\", \"\n+#| \"~~~~ {.ignore} extern mod farm; extern mod my_farm (name = \\\"farm\\\", \"\n #| \"vers = \\\"2.5\\\"); extern mod my_auxiliary_farm (name = \\\"farm\\\", author = \"\n #| \"\\\"mjh\\\"); ~~~~\"\n msgid \"\"\n-\"~~~~ {.xfail-test} extern mod farm; extern mod farm = \\\"farm#2.5\\\"; extern \"\n+\"~~~~ {.ignore} extern mod farm; extern mod farm = \\\"farm#2.5\\\"; extern \"\n \"mod my_farm = \\\"farm\\\"; ~~~~\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"extern mod farm;\\n\"\n \"extern mod my_farm (name = \\\"farm\\\", vers = \\\"2.5\\\");\\n\"\n \"extern mod my_auxiliary_farm (name = \\\"farm\\\", author = \\\"mjh\\\");\\n\"\n@@ -4507,13 +4507,13 @@ msgstr \"\"\n #: doc/tutorial.md:3185\n #, fuzzy\n #| msgid \"\"\n-#| \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\"\n+#| \"~~~~ {.ignore} // main.rs extern mod world; fn main() { println(~\"\n #| \"\\\"hello \\\" + world::explore()); } ~~~~\"\n msgid \"\"\n-\"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println!(\\\"hello \"\n+\"~~~~ {.ignore} // main.rs extern mod world; fn main() { println!(\\\"hello \"\n \"{}\\\", world::explore()); } ~~~~\"\n msgstr \"\"\n-\"~~~~ {.xfail-test}\\n\"\n+\"~~~~ {.ignore}\\n\"\n \"// main.rs\\n\"\n \"extern mod world;\\n\"\n \"fn main() { println(~\\\"hello \\\" + world::explore()); }\\n\""}, {"sha": "f933cac51f6d2d3b0fec47d55ba41a49cf9e074e", "filename": "doc/rust.md", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -727,7 +727,7 @@ name as the module, plus the `.rs` extension.\n When a nested submodule is loaded from an external file,\n it is loaded from a subdirectory path that mirrors the module hierarchy.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n // Load the `vec` module from `vec.rs`\n mod vec;\n \n@@ -740,7 +740,7 @@ mod task {\n The directories and files used for loading external file modules can be influenced\n with the `path` attribute.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[path = \"task_files\"]\n mod task {\n     // Load the `local_data` module from `task_files/tls.rs`\n@@ -784,7 +784,7 @@ assumed, equal to the `ident` given in the `extern_mod_decl`.\n \n Four examples of `extern mod` declarations:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n extern mod pcre;\n \n extern mod extra; // equivalent to: extern mod extra = \"extra\";\n@@ -939,7 +939,7 @@ appear in its signature. Each type parameter must be explicitly\n declared, in an angle-bracket-enclosed, comma-separated list following\n the function name.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n fn iter<T>(seq: &[T], f: |T|) {\n     for elt in seq.iter() { f(elt); }\n }\n@@ -1389,7 +1389,7 @@ fn radius_times_area<T: Circle>(c: T) -> f64 {\n \n Likewise, supertrait methods may also be called on trait objects.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # impl Shape for int { fn area(&self) -> f64 { 0.0 } }\n@@ -1491,7 +1491,7 @@ By default external blocks assume that the library they are calling\n uses the standard C \"cdecl\" ABI.  Other ABIs may be specified using\n an `abi` string, as shown here:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n // Interface to the Windows API\n extern \"stdcall\" { }\n ~~~~\n@@ -1500,7 +1500,7 @@ The `link` attribute allows the name of the library to be specified. When\n specified the compiler will attempt to link against the native library of the\n specified name.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[link(name = \"crypto\")]\n extern { }\n ~~~~\n@@ -1704,7 +1704,7 @@ within. Attributes that are not terminated by a semi-colon apply to the next ent\n \n An example of attributes:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n // General metadata applied to the enclosing module or crate.\n #[license = \"BSD\"];\n \n@@ -1768,7 +1768,7 @@ For any lint check `C`:\n The lint checks supported by the compiler can be found via `rustc -W help`,\n along with their default settings.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n mod m1 {\n     // Missing documentation is ignored here\n     #[allow(missing_doc)]\n@@ -1787,7 +1787,7 @@ mod m1 {\n This example shows how one can use `allow` and `warn` to toggle\n a particular check on and off.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[warn(missing_doc)]\n mod m2{\n     #[allow(missing_doc)]\n@@ -1809,7 +1809,7 @@ mod m2{\n This example shows how one can use `forbid` to disallow uses\n of `allow` for that lint check.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[forbid(missing_doc)]\n mod m3 {\n     // Attempting to toggle warning signals an error here\n@@ -1827,7 +1827,7 @@ The definitions of these operations have to be easy for the compiler to find.\n The `lang` attribute makes it possible to declare these operations.\n For example, the `str` module in the Rust standard library defines the string equality function:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[lang=\"str_eq\"]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     // details elided\n@@ -2007,7 +2007,7 @@ by default. Items with not marked with a stability are considered to\n be unstable for the purposes of the lint. One can give an optional\n string that will be displayed when the lint flags the use of an item.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[warn(unstable)];\n \n #[deprecated=\"replaced by `best`\"]\n@@ -2046,7 +2046,7 @@ considered a full-fleged language feature.\n \n For this reason, rust recognizes a special crate-level attribute of the form:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n #[feature(feature1, feature2, feature3)]\n ~~~~\n \n@@ -2403,7 +2403,7 @@ Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n task in a _failing state_.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n # use std::task;\n # do task::spawn {\n "}, {"sha": "6112a713bbfc93ad1359dd068fc555553313da1d", "filename": "doc/tutorial.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -607,7 +607,7 @@ With a value (say, `mypoint`) of such a type in a mutable location, you can do\n `mypoint.y += 1.0`. But in an immutable location, such an assignment to a\n struct without inherited mutability would result in a type error.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n # struct Point { x: f64, y: f64 }\n let mut mypoint = Point { x: 1.0, y: 1.0 };\n let origin = Point { x: 0.0, y: 0.0 };\n@@ -948,7 +948,7 @@ An `enum` is a natural fit for describing a linked list, because it can express\n a `List` type as being *either* the end of the list (`Nil`) or another node\n (`Cons`). The full definition of the `Cons` variant will require some thought.\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n enum List {\n     Cons(...), // an incomplete definition of the next element in a List\n     Nil        // the end of a List\n@@ -958,7 +958,7 @@ enum List {\n The obvious approach is to define `Cons` as containing an element in the list\n along with the next `List` node. However, this will generate a compiler error.\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n // error: illegal recursive enum type; wrap the inner value in a box to make it representable\n enum List {\n     Cons(u32, List), // an element (`u32`) and the next node in the list\n@@ -1092,7 +1092,7 @@ let z = x; // no new memory allocated, x can no longer be used\n The `clone` method is provided by the `Clone` trait, and can be derived for\n our `List` type. Traits will be explained in detail later.\n \n-~~~{.xfail-test}\n+~~~{.ignore}\n #[deriving(Clone)]\n enum List {\n     Cons(u32, ~List),\n@@ -1144,15 +1144,15 @@ ownership of a list to be passed in rather than just mutating it in-place.\n \n The obvious signature for a `List` equality comparison is the following:\n \n-~~~{.xfail-test}\n+~~~{.ignore}\n fn eq(xs: List, ys: List) -> bool { ... }\n ~~~\n \n However, this will cause both lists to be moved into the function. Ownership\n isn't required to compare the lists, so the function should take *references*\n (&T) instead.\n \n-~~~{.xfail-test}\n+~~~{.ignore}\n fn eq(xs: &List, ys: &List) -> bool { ... }\n ~~~\n \n@@ -1949,7 +1949,7 @@ Implementations may also define standalone (sometimes called \"static\")\n methods. The absence of a `self` parameter distinguishes such methods.\n These methods are the preferred way to define constructor functions.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n impl Circle {\n     fn area(&self) -> f64 { ... }\n     fn new(area: f64) -> Circle { ... }\n@@ -2073,7 +2073,7 @@ can we copy values of type `T` inside that function?\n In Rust, we can't,\n and if we try to run the following code the compiler will complain.\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n // This does not compile\n fn head_bad<T>(v: &[T]) -> T {\n     v[0] // error: copying a non-copyable value\n@@ -2521,7 +2521,7 @@ fn radius_times_area<T: Circle>(c: T) -> f64 {\n \n Likewise, supertrait methods may also be called on trait objects.\n \n-~~~ {.xfail-test}\n+~~~ {.ignore}\n use std::f64::consts::PI;\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n@@ -2624,7 +2624,7 @@ which contains a function `hay`.\n We've now defined a nice module hierarchy. But how do we access the items in it from our `main` function?\n One way to do it is to simply fully qualifying it:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n mod farm {\n     fn chicken() { println!(\"cluck cluck\"); }\n     // ...\n@@ -3152,7 +3152,7 @@ You can also specify package ID information in a `extern mod` statement.  For\n example, these `extern mod` statements would both accept and select the\n crate define above:\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n extern mod farm;\n extern mod farm = \"farm#2.5\";\n extern mod my_farm = \"farm\";\n@@ -3193,7 +3193,7 @@ pub fn explore() -> &'static str { \"world\" }\n # fn main() {}\n ~~~~\n \n-~~~~ {.xfail-test}\n+~~~~ {.ignore}\n // main.rs\n extern mod world;\n fn main() { println!(\"hello {}\", world::explore()); }"}, {"sha": "bbc57b7eb73d86c34c832d65a3affcc9efd38e6c", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 207, "deletions": 75, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/9f60e7c306e5052136318806bdd44fc4433f5632/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/9f60e7c306e5052136318806bdd44fc4433f5632/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=9f60e7c306e5052136318806bdd44fc4433f5632", "patch": "@@ -1,77 +1,209 @@\n # xfail-license\n+# -*- coding: utf-8 -*-\n+\"\"\"\n+Script for extracting compilable fragments from markdown documentation. See\n+prep.js for a description of the format recognized by this tool. Expects\n+a directory fragments/ to exist under the current directory, and writes the\n+fragments in there as individual .rs files.\n+\"\"\"\n+from __future__ import print_function\n+from codecs import open\n+from collections import deque\n+from itertools import imap\n+import os\n+import re\n+import sys\n \n-# Script for extracting compilable fragments from markdown\n-# documentation. See prep.js for a description of the format\n-# recognized by this tool. Expects a directory fragments/ to exist\n-# under the current directory, and writes the fragments in there as\n-# individual .rs files.\n-\n-import sys, re\n-\n-if len(sys.argv) < 3:\n-    print(\"Please provide an input filename\")\n-    sys.exit(1)\n-\n-filename = sys.argv[1]\n-dest = sys.argv[2]\n-f = open(filename)\n-lines = f.readlines()\n-f.close()\n-\n-cur = 0\n-line = \"\"\n-chapter = \"\"\n-chapter_n = 0\n-\n-while cur < len(lines):\n-    line = lines[cur]\n-    cur += 1\n-    chap = re.match(\"# (.*)\", line)\n-    if chap:\n-        chapter = re.sub(r\"\\W\", \"_\", chap.group(1)).lower()\n-        chapter_n = 1\n-    elif re.match(\"~~~\", line):\n-        # Parse the tags that open a code block in the pandoc format:\n-        # ~~~ {.tag1 .tag2}\n-        tags = re.findall(\"\\.([\\w-]*)\", line)\n-        block = \"\"\n-        ignore = \"notrust\" in tags or \"ignore\" in tags\n-        # Some tags used by the language ref that indicate not rust\n-        ignore |= \"ebnf\" in tags\n-        ignore |= \"abnf\" in tags\n-        ignore |= \"keyword\" in tags\n-        ignore |= \"field\" in tags\n-        ignore |= \"precedence\" in tags\n-        xfail = \"xfail-test\" in tags\n-        while cur < len(lines):\n-            line = lines[cur]\n-            cur += 1\n-            if re.match(\"~~~\", line):\n-                break\n-            else:\n-                # Lines beginning with '# ' are turned into valid code\n-                line = re.sub(\"^# \", \"\", line)\n-                # Allow ellipses in code snippets\n-                line = re.sub(\"\\.\\.\\.\", \"\", line)\n-                block += line\n-        if not ignore:\n-            if not re.search(r\"\\bfn main\\b\", block):\n-                block = \"fn main() {\\n\" + block + \"\\n}\\n\"\n-            if not re.search(r\"\\bextern mod extra\\b\", block):\n-                block = \"extern mod extra;\\n\" + block\n-            block = \"\"\"#[ deny(warnings) ];\n-#[ allow(unused_variable) ];\\n\n-#[ allow(dead_assignment) ];\\n\n-#[ allow(unused_mut) ];\\n\n-#[ allow(attribute_usage) ];\\n\n-#[ allow(dead_code) ];\\n\n-#[ feature(macro_rules, globs, struct_variant, managed_boxes) ];\\n\n-\"\"\" + block\n-            if xfail:\n-                block = \"// xfail-test\\n\" + block\n-            filename = (dest + \"/\" + str(chapter)\n-                        + \"_\" + str(chapter_n) + \".rs\")\n-            chapter_n += 1\n-            f = open(filename, 'w')\n-            f.write(block)\n-            f.close()\n+# regexes\n+CHAPTER_NAME_REGEX = re.compile(r'# (.*)')\n+CODE_BLOCK_DELIM_REGEX = re.compile(r'~~~')\n+COMMENT_REGEX = re.compile(r'^# ')\n+COMPILER_DIRECTIVE_REGEX = re.compile(r'\\#\\[(.*)\\];')\n+ELLIPSES_REGEX = re.compile(r'\\.\\.\\.')\n+EXTERN_MOD_REGEX = re.compile(r'\\bextern mod extra\\b')\n+MAIN_FUNCTION_REGEX = re.compile(r'\\bfn main\\b')\n+TAGS_REGEX = re.compile(r'\\.([\\w-]*)')\n+\n+# tags to ignore\n+IGNORE_TAGS = \\\n+        frozenset([\"abnf\", \"ebnf\", \"field\", \"keyword\", \"notrust\", \"precedence\"])\n+\n+# header for code snippet files\n+OUTPUT_BLOCK_HEADER = '\\n'.join((\n+    \"#[ deny(warnings) ];\",\n+    \"#[ allow(unused_variable) ];\",\n+    \"#[ allow(dead_assignment) ];\",\n+    \"#[ allow(unused_mut) ];\",\n+    \"#[ allow(attribute_usage) ];\",\n+    \"#[ allow(dead_code) ];\",\n+    \"#[ feature(macro_rules, globs, struct_variant, managed_boxes) ];\\n\",))\n+\n+\n+def add_extern_mod(block):\n+    if not has_extern_mod(block):\n+        # add `extern mod extra;` after compiler directives\n+        directives = []\n+        while len(block) and is_compiler_directive(block[0]):\n+            directives.append(block.popleft())\n+\n+        block.appendleft(\"\\nextern mod extra;\\n\\n\")\n+        block.extendleft(reversed(directives))\n+\n+    return block\n+\n+\n+def add_main_function(block):\n+    if not has_main_function(block):\n+        prepend_spaces = lambda x: '    ' + x\n+        block = deque(imap(prepend_spaces, block))\n+        block.appendleft(\"\\nfn main() {\\n\")\n+        block.append(\"\\n}\\n\")\n+    return block\n+\n+\n+def extract_code_fragments(dest_dir, lines):\n+    \"\"\"\n+    Extracts all the code fragments from a file that do not have ignored tags\n+    writing them to the following file:\n+\n+        [dest dir]/[chapter name]_[chapter_index].rs\n+    \"\"\"\n+    chapter_name = None\n+    chapter_index = 0\n+\n+    for line in lines:\n+        if is_chapter_title(line):\n+            chapter_name = get_chapter_name(line)\n+            chapter_index = 1\n+            continue\n+\n+        if not is_code_block_delim(line):\n+            continue\n+\n+        assert chapter_name, \"Chapter name missing for code block.\"\n+        tags = get_tags(line)\n+        block = get_code_block(lines)\n+\n+        if tags & IGNORE_TAGS:\n+            continue\n+\n+        block = add_extern_mod(add_main_function(block))\n+        block.appendleft(OUTPUT_BLOCK_HEADER)\n+\n+        if \"ignore\" in tags:\n+            block.appendleft(\"//xfail-test\\n\")\n+        elif \"should_fail\" in tags:\n+            block.appendleft(\"//should-fail\\n\")\n+\n+        output_filename = os.path.join(\n+                dest_dir,\n+                chapter_name + '_' + str(chapter_index) + '.rs')\n+\n+        write_file(output_filename, block)\n+        chapter_index += 1\n+\n+\n+def has_extern_mod(block):\n+    \"\"\"Checks if a code block has the line `extern mod extra`.\"\"\"\n+    find_extern_mod = lambda x: re.search(EXTERN_MOD_REGEX, x)\n+    return any(imap(find_extern_mod, block))\n+\n+\n+def has_main_function(block):\n+    \"\"\"Checks if a code block has a main function.\"\"\"\n+    find_main_fn = lambda x: re.search(MAIN_FUNCTION_REGEX, x)\n+    return any(imap(find_main_fn, block))\n+\n+\n+def is_chapter_title(line):\n+    return re.match(CHAPTER_NAME_REGEX, line)\n+\n+\n+def is_code_block_delim(line):\n+    return re.match(CODE_BLOCK_DELIM_REGEX, line)\n+\n+\n+def is_compiler_directive(line):\n+    return re.match(COMPILER_DIRECTIVE_REGEX, line)\n+\n+\n+def get_chapter_name(line):\n+    \"\"\"Get the chapter name from a `# Containers` line.\"\"\"\n+    return re.sub(\n+            r'\\W',\n+            '_',\n+            re.match(CHAPTER_NAME_REGEX, line).group(1)).lower()\n+\n+\n+def get_code_block(lines):\n+    \"\"\"\n+    Get a code block surrounded by ~~~, for example:\n+\n+        1: ~~~ { .tag }\n+        2: let u: ~[u32] = ~[0, 1, 2];\n+        3: let v: &[u32] = &[0, 1, 2, 3];\n+        4: let w: [u32, .. 5] = [0, 1, 2, 3, 4];\n+        5:\n+        6: println!(\"u: {}, v: {}, w: {}\", u.len(), v.len(), w.len());\n+        7: ~~~\n+\n+    Returns lines 2-6. Assumes line 1 has been consumed by the caller.\n+    \"\"\"\n+    strip_comments = lambda x: re.sub(COMMENT_REGEX, '', x)\n+    strip_ellipses = lambda x: re.sub(ELLIPSES_REGEX, '', x)\n+\n+    result = deque()\n+\n+    for line in lines:\n+        if is_code_block_delim(line):\n+            break\n+        result.append(strip_comments(strip_ellipses(line)))\n+    return result\n+\n+\n+def get_lines(filename):\n+    with open(filename) as f:\n+        for line in f:\n+            yield line\n+\n+\n+def get_tags(line):\n+    \"\"\"\n+    Retrieves all tags from the line format:\n+        ~~~ { .tag1 .tag2 .tag3 }\n+    \"\"\"\n+    return set(re.findall(TAGS_REGEX, line))\n+\n+\n+def write_file(filename, lines):\n+    with open(filename, 'w', encoding='utf-8') as f:\n+        for line in lines:\n+            f.write(unicode(line, encoding='utf-8', errors='replace'))\n+\n+\n+def main(argv=None):\n+    if not argv:\n+        argv = sys.argv\n+\n+    if len(sys.argv) < 2:\n+        sys.stderr.write(\"Please provide an input filename.\")\n+        sys.exit(1)\n+    elif len(sys.argv) < 3:\n+        sys.stderr.write(\"Please provide a destination directory.\")\n+        sys.exit(1)\n+\n+    input_file = sys.argv[1]\n+    dest_dir = sys.argv[2]\n+\n+    if not os.path.exists(input_file):\n+        sys.stderr.write(\"Input file does not exist.\")\n+        sys.exit(1)\n+\n+    if not os.path.exists(dest_dir):\n+        os.mkdir(dest_dir)\n+\n+    extract_code_fragments(dest_dir, get_lines(input_file))\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())"}]}