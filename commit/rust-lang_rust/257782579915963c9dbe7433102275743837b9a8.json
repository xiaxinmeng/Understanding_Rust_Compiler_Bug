{"sha": "257782579915963c9dbe7433102275743837b9a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1Nzc4MjU3OTkxNTk2M2M5ZGJlNzQzMzEwMjI3NTc0MzgzN2I5YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-03T15:32:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-03T15:32:38Z"}, "message": "Auto merge of #85292 - wesleywiser:enum_debuginfo, r=michaelwoerister\n\nImprove debugging experience for enums on windows-msvc\n\nThis PR makes significant improvements over the status quo of debugging enums on the windows-msvc platform with either WinDbg or Visual Studio in three ways:\n\n1. Improves the debugger experience for directly tagged enums.\n2. Fixes a bug which caused the debugger to sometimes show the wrong debug info for niche layout enums. For example, `Option<&u32>` could sometimes use the debug info for `Option<&f64>` instead leading to nonsensical variable values in the debugger.\n3. Significantly improves the debugger experience for niche-layout enums.\n\nLet's look at a few examples:\n\n```rust\npub enum CStyleEnum {\n    Base = 2,\n    Exponent = 16,\n}\n\npub enum NicheLayoutEnum {\n    Tag1,\n    Data { my_data: CStyleEnum },\n    Tag2,\n    Tag3,\n    Tag4,\n}\n\npub enum OtherEnum<T> {\n    Case1(T),\n    Case2(T),\n}\n\nfn main() {\n    let a = Some(CStyleEnum::Base);\n    let b = Option::<CStyleEnum>::None;\n    let c = NicheLayoutEnum::Tag1;\n    let d = NicheLayoutEnum::Data { my_data: CStyleEnum::Exponent };\n    let e = NicheLayoutEnum::Tag2;\n    let f = Some(&1u32);\n    let g = Option::<&'static u32>::None;\n    let h = Some(&2u64);\n    let i = Option::<&'static u64>::None;\n    let j = Some(12u32);\n    let k = Option::<u32>::None;\n    let l = Some(12.34f64);\n    let m = Option::<f64>::None;\n    let n = CStyleEnum::Base;\n    let o = CStyleEnum::Exponent;\n    let p = Some(\"IAMA optional string!\".to_string());\n    let q = OtherEnum::Case1(42u32);\n}\n```\n\nThis is what WinDbg Preview shows using the latest rustc nightly:\n\n![image](https://user-images.githubusercontent.com/831192/118285353-57c10780-b49f-11eb-97aa-db3abfc09508.png)\n\nMost of the variables don't show a meaningful value expect for a few cases that we have targeted natvis definitions covering. Even worse, drilling into many of these variables shows information that can be difficult to interpret without an understanding of the layout of Rust types:\n\n![image](https://user-images.githubusercontent.com/831192/118285609-a1a9ed80-b49f-11eb-9c29-b14576984647.png)\n\nWith the changes in this PR, we're able to write two natvis definitions that cover all enum cases generally. After building with these changes, WinDbg now shows this instead:\n\n![image](https://user-images.githubusercontent.com/831192/118287730-be472500-b4a1-11eb-8cad-8f6a91c7516b.png)\n\nDrilling into the same variables, we can see much more useful information:\n\n![image](https://user-images.githubusercontent.com/831192/118287888-e20a6b00-b4a1-11eb-927f-32cf33a31c16.png)\n\nFixes #84670\nFixes #84671", "tree": {"sha": "470c6649501f2b098606ac263898798436d0d1cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/470c6649501f2b098606ac263898798436d0d1cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/257782579915963c9dbe7433102275743837b9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/257782579915963c9dbe7433102275743837b9a8", "html_url": "https://github.com/rust-lang/rust/commit/257782579915963c9dbe7433102275743837b9a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/257782579915963c9dbe7433102275743837b9a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "835150e70288535bc57bb624792229b9dc94991d", "url": "https://api.github.com/repos/rust-lang/rust/commits/835150e70288535bc57bb624792229b9dc94991d", "html_url": "https://github.com/rust-lang/rust/commit/835150e70288535bc57bb624792229b9dc94991d"}, {"sha": "94c45ef1089bfd9fa4304cf67dedce4788883051", "url": "https://api.github.com/repos/rust-lang/rust/commits/94c45ef1089bfd9fa4304cf67dedce4788883051", "html_url": "https://github.com/rust-lang/rust/commit/94c45ef1089bfd9fa4304cf67dedce4788883051"}], "stats": {"total": 518, "additions": 376, "deletions": 142}, "files": [{"sha": "1e70664e64d707dbc3aa9af04669b0c416a68c88", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 149, "deletions": 102, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -1457,7 +1457,6 @@ struct EnumMemberDescriptionFactory<'ll, 'tcx> {\n     enum_type: Ty<'tcx>,\n     layout: TyAndLayout<'tcx>,\n     tag_type_metadata: Option<&'ll DIType>,\n-    containing_scope: &'ll DIScope,\n     common_members: Vec<Option<&'ll DIType>>,\n     span: Span,\n }\n@@ -1486,13 +1485,9 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n             _ => bug!(),\n         };\n \n-        // This will always find the metadata in the type map.\n         let fallback = use_enum_fallback(cx);\n-        let self_metadata = if fallback {\n-            self.containing_scope\n-        } else {\n-            type_metadata(cx, self.enum_type, self.span)\n-        };\n+        // This will always find the metadata in the type map.\n+        let self_metadata = type_metadata(cx, self.enum_type, self.span);\n \n         match self.layout.variants {\n             Variants::Single { index } => {\n@@ -1507,7 +1502,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                     cx,\n                     self.layout,\n                     variant_info,\n-                    NoTag,\n+                    None,\n                     self_metadata,\n                     self.span,\n                 );\n@@ -1539,13 +1534,26 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 ..\n             } => {\n                 let tag_info = if fallback {\n-                    RegularTag {\n+                    // For MSVC, we generate a union of structs for each variant with an explicit\n+                    // discriminant field roughly equivalent to the following C:\n+                    // ```c\n+                    // union enum$<{name}> {\n+                    //   struct {variant 0 name} {\n+                    //     tag$ variant$;\n+                    //     <variant 0 fields>\n+                    //   } variant0;\n+                    //   <other variant structs>\n+                    // }\n+                    // ```\n+                    // The natvis in `intrinsic.nativs` then matches on `this.variant0.variant$` to\n+                    // determine which variant is active and then displays it.\n+                    Some(DirectTag {\n                         tag_field: Field::from(tag_field),\n                         tag_type_metadata: self.tag_type_metadata.unwrap(),\n-                    }\n+                    })\n                 } else {\n                     // This doesn't matter in this case.\n-                    NoTag\n+                    None\n                 };\n                 variants\n                     .iter_enumerated()\n@@ -1574,7 +1582,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n \n                         MemberDescription {\n                             name: if fallback {\n-                                String::new()\n+                                format!(\"variant{}\", i.as_u32())\n                             } else {\n                                 variant_info.variant_name()\n                             },\n@@ -1599,77 +1607,135 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                 ref variants,\n                 tag_field,\n             } => {\n+                let calculate_niche_value = |i: VariantIdx| {\n+                    if i == dataful_variant {\n+                        None\n+                    } else {\n+                        let value = (i.as_u32() as u128)\n+                            .wrapping_sub(niche_variants.start().as_u32() as u128)\n+                            .wrapping_add(niche_start);\n+                        let value = tag.value.size(cx).truncate(value);\n+                        // NOTE(eddyb) do *NOT* remove this assert, until\n+                        // we pass the full 128-bit value to LLVM, otherwise\n+                        // truncation will be silent and remain undetected.\n+                        assert_eq!(value as u64 as u128, value);\n+                        Some(value as u64)\n+                    }\n+                };\n+\n+                // For MSVC, we will generate a union of two fields, one for the dataful variant\n+                // and one that just points to the discriminant. We also create an enum that\n+                // contains tag values for the non-dataful variants and make the discriminant field\n+                // that type. We then use natvis to render the enum type correctly in Windbg/VS.\n+                // This will generate debuginfo roughly equivalent to the following C:\n+                // ```c\n+                // union enum$<{name}, {min niche}, {max niche}, {dataful variant name}> {\n+                //   struct <dataful variant name> {\n+                //     <fields in dataful variant>\n+                //   } dataful_variant;\n+                //   enum Discriminant$ {\n+                //     <non-dataful variants>\n+                //   } discriminant;\n+                // }\n+                // ```\n+                // The natvis in `intrinsic.natvis` matches on the type name `enum$<*, *, *, *>`\n+                // and evaluates `this.discriminant`. If the value is between the min niche and max\n+                // niche, then the enum is in the dataful variant and `this.dataful_variant` is\n+                // rendered. Otherwise, the enum is in one of the non-dataful variants. In that\n+                // case, we just need to render the name of the `this.discriminant` enum.\n                 if fallback {\n-                    let variant = self.layout.for_variant(cx, dataful_variant);\n-                    // Create a description of the non-null variant.\n-                    let (variant_type_metadata, member_description_factory) = describe_enum_variant(\n+                    let dataful_variant_layout = self.layout.for_variant(cx, dataful_variant);\n+\n+                    let mut discr_enum_ty = tag.value.to_ty(cx.tcx);\n+                    // If the niche is the NULL value of a reference, then `discr_enum_ty` will be a RawPtr.\n+                    // CodeView doesn't know what to do with enums whose base type is a pointer so we fix this up\n+                    // to just be `usize`.\n+                    if let ty::RawPtr(_) = discr_enum_ty.kind() {\n+                        discr_enum_ty = cx.tcx.types.usize;\n+                    }\n+\n+                    let tags: Vec<_> = variants\n+                        .iter_enumerated()\n+                        .filter_map(|(variant_idx, _)| {\n+                            calculate_niche_value(variant_idx).map(|tag| {\n+                                let variant = variant_info_for(variant_idx);\n+                                let name = variant.variant_name();\n+\n+                                Some(unsafe {\n+                                    llvm::LLVMRustDIBuilderCreateEnumerator(\n+                                        DIB(cx),\n+                                        name.as_ptr().cast(),\n+                                        name.len(),\n+                                        tag as i64,\n+                                        !discr_enum_ty.is_signed(),\n+                                    )\n+                                })\n+                            })\n+                        })\n+                        .collect();\n+\n+                    let discr_enum = unsafe {\n+                        llvm::LLVMRustDIBuilderCreateEnumerationType(\n+                            DIB(cx),\n+                            self_metadata,\n+                            \"Discriminant$\".as_ptr().cast(),\n+                            \"Discriminant$\".len(),\n+                            unknown_file_metadata(cx),\n+                            UNKNOWN_LINE_NUMBER,\n+                            tag.value.size(cx).bits(),\n+                            tag.value.align(cx).abi.bits() as u32,\n+                            create_DIArray(DIB(cx), &tags),\n+                            type_metadata(cx, discr_enum_ty, self.span),\n+                            true,\n+                        )\n+                    };\n+\n+                    let variant_info = variant_info_for(dataful_variant);\n+                    let (variant_type_metadata, member_desc_factory) = describe_enum_variant(\n                         cx,\n-                        variant,\n-                        variant_info_for(dataful_variant),\n-                        OptimizedTag,\n-                        self.containing_scope,\n+                        dataful_variant_layout,\n+                        variant_info,\n+                        Some(NicheTag),\n+                        self_metadata,\n                         self.span,\n                     );\n \n-                    let variant_member_descriptions =\n-                        member_description_factory.create_member_descriptions(cx);\n+                    let member_descriptions = member_desc_factory.create_member_descriptions(cx);\n \n                     set_members_of_composite_type(\n                         cx,\n                         self.enum_type,\n                         variant_type_metadata,\n-                        variant_member_descriptions,\n+                        member_descriptions,\n                         Some(&self.common_members),\n                     );\n \n-                    // Encode the information about the null variant in the union\n-                    // member's name.\n-                    let mut name = String::from(\"RUST$ENCODED$ENUM$\");\n-                    // Right now it's not even going to work for `niche_start > 0`,\n-                    // and for multiple niche variants it only supports the first.\n-                    fn compute_field_path<'a, 'tcx>(\n-                        cx: &CodegenCx<'a, 'tcx>,\n-                        name: &mut String,\n-                        layout: TyAndLayout<'tcx>,\n-                        offset: Size,\n-                        size: Size,\n-                    ) {\n-                        for i in 0..layout.fields.count() {\n-                            let field_offset = layout.fields.offset(i);\n-                            if field_offset > offset {\n-                                continue;\n-                            }\n-                            let inner_offset = offset - field_offset;\n-                            let field = layout.field(cx, i);\n-                            if inner_offset + size <= field.size {\n-                                write!(name, \"{}$\", i).unwrap();\n-                                compute_field_path(cx, name, field, inner_offset, size);\n-                            }\n-                        }\n-                    }\n-                    compute_field_path(\n-                        cx,\n-                        &mut name,\n-                        self.layout,\n-                        self.layout.fields.offset(tag_field),\n-                        self.layout.field(cx, tag_field).size,\n-                    );\n-                    let variant_info = variant_info_for(*niche_variants.start());\n-                    variant_info.map_struct_name(|variant_name| {\n-                        name.push_str(variant_name);\n-                    });\n-\n-                    // Create the (singleton) list of descriptions of union members.\n-                    vec![MemberDescription {\n-                        name,\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::ZERO,\n-                        size: variant.size,\n-                        align: variant.align.abi,\n-                        flags: DIFlags::FlagZero,\n-                        discriminant: None,\n-                        source_info: variant_info.source_info(cx),\n-                    }]\n+                    let (size, align) =\n+                        cx.size_and_align_of(dataful_variant_layout.field(cx, tag_field).ty);\n+\n+                    vec![\n+                        MemberDescription {\n+                            // Name the dataful variant so that we can identify it for natvis\n+                            name: \"dataful_variant\".to_string(),\n+                            type_metadata: variant_type_metadata,\n+                            offset: Size::ZERO,\n+                            size: self.layout.size,\n+                            align: self.layout.align.abi,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                            source_info: variant_info.source_info(cx),\n+                        },\n+                        MemberDescription {\n+                            name: \"discriminant\".into(),\n+                            type_metadata: discr_enum,\n+                            offset: dataful_variant_layout.fields.offset(tag_field),\n+                            size,\n+                            align,\n+                            flags: DIFlags::FlagZero,\n+                            discriminant: None,\n+                            source_info: None,\n+                        },\n+                    ]\n                 } else {\n                     variants\n                         .iter_enumerated()\n@@ -1681,7 +1747,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                     cx,\n                                     variant,\n                                     variant_info,\n-                                    OptimizedTag,\n+                                    Some(NicheTag),\n                                     self_metadata,\n                                     self.span,\n                                 );\n@@ -1697,19 +1763,7 @@ impl EnumMemberDescriptionFactory<'ll, 'tcx> {\n                                 Some(&self.common_members),\n                             );\n \n-                            let niche_value = if i == dataful_variant {\n-                                None\n-                            } else {\n-                                let value = (i.as_u32() as u128)\n-                                    .wrapping_sub(niche_variants.start().as_u32() as u128)\n-                                    .wrapping_add(niche_start);\n-                                let value = tag.value.size(cx).truncate(value);\n-                                // NOTE(eddyb) do *NOT* remove this assert, until\n-                                // we pass the full 128-bit value to LLVM, otherwise\n-                                // truncation will be silent and remain undetected.\n-                                assert_eq!(value as u64 as u128, value);\n-                                Some(value as u64)\n-                            };\n+                            let niche_value = calculate_niche_value(i);\n \n                             MemberDescription {\n                                 name: variant_info.variant_name(),\n@@ -1771,14 +1825,10 @@ impl VariantMemberDescriptionFactory<'ll, 'tcx> {\n     }\n }\n \n-// FIXME: terminology here should be aligned with `abi::TagEncoding`.\n-// `OptimizedTag` is `TagEncoding::Niche`, `RegularTag` is `TagEncoding::Direct`.\n-// `NoTag` should be removed; users should use `Option<EnumTagInfo>` instead.\n #[derive(Copy, Clone)]\n enum EnumTagInfo<'ll> {\n-    RegularTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n-    OptimizedTag,\n-    NoTag,\n+    DirectTag { tag_field: Field, tag_type_metadata: &'ll DIType },\n+    NicheTag,\n }\n \n #[derive(Copy, Clone)]\n@@ -1859,7 +1909,7 @@ fn describe_enum_variant(\n     cx: &CodegenCx<'ll, 'tcx>,\n     layout: layout::TyAndLayout<'tcx>,\n     variant: VariantInfo<'_, 'tcx>,\n-    discriminant_info: EnumTagInfo<'ll>,\n+    discriminant_info: Option<EnumTagInfo<'ll>>,\n     containing_scope: &'ll DIScope,\n     span: Span,\n ) -> (&'ll DICompositeType, MemberDescriptionFactory<'ll, 'tcx>) {\n@@ -1882,12 +1932,11 @@ fn describe_enum_variant(\n     let (offsets, args) = if use_enum_fallback(cx) {\n         // If this is not a univariant enum, there is also the discriminant field.\n         let (discr_offset, discr_arg) = match discriminant_info {\n-            RegularTag { tag_field, .. } => {\n+            Some(DirectTag { tag_field, .. }) => {\n                 // We have the layout of an enum variant, we need the layout of the outer enum\n                 let enum_layout = cx.layout_of(layout.ty);\n                 let offset = enum_layout.fields.offset(tag_field.as_usize());\n-                let args =\n-                    (\"RUST$ENUM$DISR\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n+                let args = (\"variant$\".to_owned(), enum_layout.field(cx, tag_field.as_usize()).ty);\n                 (Some(offset), Some(args))\n             }\n             _ => (None, None),\n@@ -1918,7 +1967,7 @@ fn describe_enum_variant(\n         offsets,\n         args,\n         tag_type_metadata: match discriminant_info {\n-            RegularTag { tag_type_metadata, .. } => Some(tag_type_metadata),\n+            Some(DirectTag { tag_type_metadata, .. }) => Some(tag_type_metadata),\n             _ => None,\n         },\n         span,\n@@ -2048,9 +2097,9 @@ fn prepare_enum_metadata(\n \n     if use_enum_fallback(cx) {\n         let discriminant_type_metadata = match layout.variants {\n-            Variants::Single { .. }\n-            | Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, .. } => None,\n-            Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n+            Variants::Single { .. } => None,\n+            Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, ref tag, .. }\n+            | Variants::Multiple { tag_encoding: TagEncoding::Direct, ref tag, .. } => {\n                 Some(discriminant_type_metadata(tag.value))\n             }\n         };\n@@ -2062,7 +2111,7 @@ fn prepare_enum_metadata(\n             unsafe {\n                 llvm::LLVMRustDIBuilderCreateUnionType(\n                     DIB(cx),\n-                    containing_scope,\n+                    None,\n                     enum_name.as_ptr().cast(),\n                     enum_name.len(),\n                     file_metadata,\n@@ -2088,7 +2137,6 @@ fn prepare_enum_metadata(\n                 enum_type,\n                 layout,\n                 tag_type_metadata: discriminant_type_metadata,\n-                containing_scope,\n                 common_members: vec![],\n                 span,\n             }),\n@@ -2241,7 +2289,6 @@ fn prepare_enum_metadata(\n             enum_type,\n             layout,\n             tag_type_metadata: None,\n-            containing_scope,\n             common_members: outer_fields,\n             span,\n         }),\n@@ -2437,7 +2484,7 @@ fn create_union_stub(\n \n         llvm::LLVMRustDIBuilderCreateUnionType(\n             DIB(cx),\n-            containing_scope,\n+            Some(containing_scope),\n             union_type_name.as_ptr().cast(),\n             union_type_name.len(),\n             unknown_file_metadata(cx),"}, {"sha": "54ef1a284689af60084f14f7a6894c6591c5b91f", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -2038,7 +2038,7 @@ extern \"C\" {\n \n     pub fn LLVMRustDIBuilderCreateUnionType(\n         Builder: &DIBuilder<'a>,\n-        Scope: &'a DIScope,\n+        Scope: Option<&'a DIScope>,\n         Name: *const c_char,\n         NameLen: size_t,\n         File: &'a DIFile,"}, {"sha": "7b4b0821c4be8017c75e66434cc2bed946e6bd03", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -3,7 +3,8 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, subst::SubstsRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty, TyCtxt};\n+use rustc_target::abi::{TagEncoding, Variants};\n \n use std::fmt::Write;\n \n@@ -45,8 +46,12 @@ pub fn push_debuginfo_type_name<'tcx>(\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            push_item_name(tcx, def.did, qualified, output);\n-            push_type_params(tcx, substs, output, visited);\n+            if def.is_enum() && cpp_like_names {\n+                msvc_enum_fallback(tcx, t, def, substs, output, visited);\n+            } else {\n+                push_item_name(tcx, def.did, qualified, output);\n+                push_type_params(tcx, substs, output, visited);\n+            }\n         }\n         ty::Tuple(component_types) => {\n             if cpp_like_names {\n@@ -233,6 +238,54 @@ pub fn push_debuginfo_type_name<'tcx>(\n         }\n     }\n \n+    /// MSVC names enums differently than other platforms so that the debugging visualization\n+    // format (natvis) is able to understand enums and render the active variant correctly in the\n+    // debugger. For more information, look in `src/etc/natvis/intrinsic.natvis` and\n+    // `EnumMemberDescriptionFactor::create_member_descriptions`.\n+    fn msvc_enum_fallback(\n+        tcx: TyCtxt<'tcx>,\n+        ty: Ty<'tcx>,\n+        def: &AdtDef,\n+        substs: SubstsRef<'tcx>,\n+        output: &mut String,\n+        visited: &mut FxHashSet<Ty<'tcx>>,\n+    ) {\n+        let layout = tcx.layout_of(tcx.param_env(def.did).and(ty)).expect(\"layout error\");\n+\n+        if let Variants::Multiple {\n+            tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n+            tag,\n+            variants,\n+            ..\n+        } = &layout.variants\n+        {\n+            let dataful_variant_layout = &variants[*dataful_variant];\n+\n+            // calculate the range of values for the dataful variant\n+            let dataful_discriminant_range =\n+                &dataful_variant_layout.largest_niche.as_ref().unwrap().scalar.valid_range;\n+\n+            let min = dataful_discriminant_range.start();\n+            let min = tag.value.size(&tcx).truncate(*min);\n+\n+            let max = dataful_discriminant_range.end();\n+            let max = tag.value.size(&tcx).truncate(*max);\n+\n+            output.push_str(\"enum$<\");\n+            push_item_name(tcx, def.did, true, output);\n+            push_type_params(tcx, substs, output, visited);\n+\n+            let dataful_variant_name = def.variants[*dataful_variant].ident.as_str();\n+\n+            output.push_str(&format!(\", {}, {}, {}>\", min, max, dataful_variant_name));\n+        } else {\n+            output.push_str(\"enum$<\");\n+            push_item_name(tcx, def.did, true, output);\n+            push_type_params(tcx, substs, output, visited);\n+            output.push('>');\n+        }\n+    }\n+\n     fn push_item_name(tcx: TyCtxt<'tcx>, def_id: DefId, qualified: bool, output: &mut String) {\n         if qualified {\n             output.push_str(&tcx.crate_name(def_id.krate).as_str());"}, {"sha": "89280149a035140cd8943ab18a8664040d97aaeb", "filename": "src/etc/natvis/intrinsic.natvis", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fintrinsic.natvis?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -149,4 +149,57 @@\n       <Synthetic Name=\"[...]\"><DisplayString>...</DisplayString></Synthetic>\n     </Expand>\n   </Type>\n+  <Type Name=\"enum$&lt;*&gt;\">\n+    <Intrinsic Name=\"tag\" Expression=\"variant0.variant$\" />\n+    <DisplayString Condition=\"tag() == 0\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 1\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 2\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 3\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 4\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 5\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 6\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 7\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 8\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 9\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 10\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 11\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 12\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 13\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 14\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <DisplayString Condition=\"tag() == 15\" Optional=\"true\">{tag(),en}</DisplayString>\n+\n+    <Expand>\n+      <ExpandedItem Condition=\"tag() == 0\">variant0</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 1\" Optional=\"true\">variant1</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 2\" Optional=\"true\">variant2</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 3\" Optional=\"true\">variant3</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 4\" Optional=\"true\">variant4</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 5\" Optional=\"true\">variant5</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 6\" Optional=\"true\">variant6</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 7\" Optional=\"true\">variant7</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 8\" Optional=\"true\">variant8</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 9\" Optional=\"true\">variant9</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 10\" Optional=\"true\">variant10</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 11\" Optional=\"true\">variant11</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 12\" Optional=\"true\">variant12</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 13\" Optional=\"true\">variant13</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 14\" Optional=\"true\">variant14</ExpandedItem>\n+      <ExpandedItem Condition=\"tag() == 15\" Optional=\"true\">variant15</ExpandedItem>\n+    </Expand>\n+  </Type>\n+\n+  <!-- $T1 is the name of the enum, $T2 is the low value of the dataful variant tag,\n+       $T3 is the high value of the dataful variant tag, $T4 is the name of the dataful variant -->\n+  <Type Name=\"enum$&lt;*, *, *, *&gt;\">\n+    <Intrinsic Name=\"tag\" Expression=\"discriminant\" />\n+    <Intrinsic Name=\"is_dataful\" Expression=\"tag() &gt;= $T2 &amp;&amp; tag() &lt;= $T3\" />\n+    <DisplayString Condition=\"is_dataful()\">{\"$T4\",sb}({dataful_variant})</DisplayString>\n+    <DisplayString Condition=\"!is_dataful()\">{discriminant,en}</DisplayString>\n+    <Expand>\n+      <ExpandedItem Condition=\"is_dataful()\">dataful_variant</ExpandedItem>\n+      <Synthetic Condition=\"is_dataful()\" Name=\"[variant]\">\n+        <DisplayString>{\"$T4\",sb}</DisplayString>\n+      </Synthetic>\n+    </Expand>\n+  </Type>\n </AutoVisualizer>"}, {"sha": "17667770520ce0e4442fce1f661dda04a0694403", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -14,14 +14,6 @@\n     </Expand>\n   </Type>\n \n-  <Type Name=\"core::option::Option&lt;*&gt;\">\n-    <DisplayString Condition=\"RUST$ENUM$DISR == 0x0\">None</DisplayString>\n-    <DisplayString Condition=\"RUST$ENUM$DISR == 0x1\">Some({__0})</DisplayString>\n-    <Expand>\n-      <Item Name=\"[value]\" ExcludeView=\"simple\" Condition=\"RUST$ENUM$DISR == 1\">__0</Item>\n-    </Expand>\n-  </Type>\n-\n   <Type Name=\"core::option::Option&lt;*&gt;\" Priority=\"MediumLow\">\n     <DisplayString Condition=\"*(void**)this == nullptr\">None</DisplayString>\n     <DisplayString>Some({($T1 *)this})</DisplayString>\n@@ -30,15 +22,6 @@\n     </Expand>\n   </Type>\n \n-  <Type Name=\"core::result::Result&lt;*&gt;\">\n-    <DisplayString Condition=\"RUST$ENUM$DISR == 0x0\">Ok({__0})</DisplayString>\n-    <DisplayString Condition=\"RUST$ENUM$DISR == 0x1\">Err({(*($T2*) &amp;__0)})</DisplayString>\n-    <Expand>\n-      <Item Name=\"[value]\" Condition=\"RUST$ENUM$DISR == 0x0\">__0</Item>\n-      <Item Name=\"[value]\" Condition=\"RUST$ENUM$DISR == 0x1\">(*($T2*) &amp;__0)</Item>\n-    </Expand>\n-  </Type>\n-\n   <Type Name=\"core::ptr::non_null::NonNull&lt;*&gt;\">\n     <DisplayString>{(void*) pointer}</DisplayString>\n     <Expand>"}, {"sha": "e410180bfff6fa837640c4411e42b69a5aa0b170", "filename": "src/test/codegen/async-fn-debug-msvc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fasync-fn-debug-msvc.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -17,33 +17,33 @@ async fn async_fn_test() {\n // FIXME: No way to reliably check the filename.\n \n // CHECK-DAG:  [[ASYNC_FN:!.*]] = !DINamespace(name: \"async_fn_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator-0\", scope: [[ASYNC_FN]]\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator-0\"\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 11,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant1\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 15,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant2\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 15,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant3\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 12,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant4\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 14,\n // CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[ASYNC_FN]],\n+// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"RUST$ENUM$DISR\", scope: [[S1]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant$\", scope: [[S1]],\n // CHECK-SAME: flags: DIFlagArtificial\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n // CHECK-NOT:  flags: DIFlagArtificial"}, {"sha": "7edb07d224c3646865aaa169f27c6b11a0a06826", "filename": "src/test/codegen/generator-debug-msvc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fgenerator-debug-msvc.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -21,33 +21,33 @@ fn generator_test() -> impl Generator<Yield = i32, Return = ()> {\n // FIXME: No way to reliably check the filename.\n \n // CHECK-DAG:  [[GEN_FN:!.*]] = !DINamespace(name: \"generator_test\"\n-// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator-0\", scope: [[GEN_FN]]\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK-DAG:  [[GEN:!.*]] = !DICompositeType(tag: DW_TAG_union_type, name: \"generator-0\"\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant0\", scope: [[GEN]],\n // For brevity, we only check the struct name and members of the last variant.\n // CHECK-SAME: file: [[FILE:![0-9]*]], line: 14,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant1\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 18,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant2\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 18,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant3\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 15,\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, scope: [[GEN]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant4\", scope: [[GEN]],\n // CHECK-SAME: file: [[FILE]], line: 17,\n // CHECK-SAME: baseType: [[VARIANT:![0-9]*]]\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN_FN]],\n+// CHECK:      [[S1:!.*]] = !DICompositeType(tag: DW_TAG_structure_type, name: \"Suspend1\", scope: [[GEN]],\n // CHECK-NOT:  flags: DIFlagArtificial\n // CHECK-SAME: )\n-// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"RUST$ENUM$DISR\", scope: [[S1]],\n+// CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"variant$\", scope: [[S1]],\n // CHECK-SAME: flags: DIFlagArtificial\n // CHECK:      {{!.*}} = !DIDerivedType(tag: DW_TAG_member, name: \"s\", scope: [[S1]]\n // CHECK-NOT:  flags: DIFlagArtificial"}, {"sha": "550cc66f3899c01407419469880ccffc6c7a34ff", "filename": "src/test/debuginfo/msvc-pretty-enums.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -0,0 +1,97 @@\n+// only-cdb\n+// ignore-tidy-linelength\n+// compile-flags:-g\n+\n+// cdb-command: g\n+\n+// Note: The natvis used to visualize niche-layout enums don't work correctly in cdb\n+//       so the best we can do is to make sure we are generating the right debuginfo\n+\n+// cdb-command: dx -r2 a,!\n+// cdb-check:a,!              [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum>>, 2, 16, Some>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum>>, 2, 16, Some>::Some]\n+// cdb-check:        [+0x000] __0              : Low (0x2) [Type: msvc_pretty_enums::CStyleEnum]\n+// cdb-check:    [+0x000] discriminant     : 0x2 [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum>>, 2, 16, Some>::Discriminant$]\n+\n+// cdb-command: dx -r2 b,!\n+// cdb-check:b,!              [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum>>, 2, 16, Some>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum>>, 2, 16, Some>::Some]\n+// cdb-check:        [+0x000] __0              : 0x11 [Type: msvc_pretty_enums::CStyleEnum]\n+// cdb-check:    [+0x000] discriminant     : None (0x11) [Type: enum$<core::option::Option<enum$<msvc_pretty_enums::CStyleEnum>>, 2, 16, Some>::Discriminant$]\n+\n+// cdb-command: dx -r2 c,!\n+// cdb-check:c,!              [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>::Data]\n+// cdb-check:        [+0x000] my_data          : 0x11 [Type: msvc_pretty_enums::CStyleEnum]\n+// cdb-check:    [+0x000] discriminant     : Tag1 (0x11) [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>::Discriminant$]\n+\n+// cdb-command: dx -r2 d,!\n+// cdb-check:d,!              [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>::Data]\n+// cdb-check:        [+0x000] my_data          : High (0x10) [Type: msvc_pretty_enums::CStyleEnum]\n+// cdb-check:    [+0x000] discriminant     : 0x10 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>::Discriminant$]\n+\n+// cdb-command: dx -r2 e,!\n+// cdb-check:e,!              [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>::Data]\n+// cdb-check:        [+0x000] my_data          : 0x13 [Type: msvc_pretty_enums::CStyleEnum]\n+// cdb-check:    [+0x000] discriminant     : Tag2 (0x13) [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>::Discriminant$]\n+\n+// cdb-command: dx -r2 f,!\n+// cdb-check:f,!              [Type: enum$<core::option::Option<u32*>, 1, [...], Some>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<core::option::Option<u32*>, 1, [...], Some>::Some]\n+// cdb-check:        [+0x000] __0              : 0x[...] : 0x1 [Type: unsigned int *]\n+// cdb-check:    [+0x000] discriminant     : 0x[...] [Type: enum$<core::option::Option<u32*>, 1, [...], Some>::Discriminant$]\n+\n+// cdb-command: dx -r2 g,!\n+// cdb-check:g,!              [Type: enum$<core::option::Option<u32*>, 1, [...], Some>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<core::option::Option<u32*>, 1, [...], Some>::Some]\n+// cdb-check:        [+0x000] __0              : 0x0 [Type: unsigned int *]\n+// cdb-check:    [+0x000] discriminant     : None (0x0) [Type: enum$<core::option::Option<u32*>, 1, [...], Some>::Discriminant$]\n+\n+// cdb-command: dx h\n+// cdb-check:h                : Some [Type: enum$<core::option::Option<u32>>]\n+// cdb-check:    [+0x000] variant$         : Some (0x1) [Type: core::option::Option]\n+// cdb-check:    [+0x004] __0              : 0xc [Type: unsigned int]\n+\n+// cdb-command: dx i\n+// cdb-check:i                : None [Type: enum$<core::option::Option<u32>>]\n+// cdb-check:    [+0x000] variant$         : None (0x0) [Type: core::option::Option]\n+\n+// cdb-command: dx j\n+// cdb-check:j                : High (0x10) [Type: msvc_pretty_enums::CStyleEnum]\n+\n+// cdb-command: dx -r2 k,!\n+// cdb-check:k,!              [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n+// cdb-check:    [+0x000] dataful_variant  [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>::Some]\n+// cdb-check:        [+0x000] __0              [Type: alloc::string::String]\n+// cdb-check:    [+0x000] discriminant     : 0x[...] [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>::Discriminant$]\n+\n+pub enum CStyleEnum {\n+    Low = 2,\n+    High = 16,\n+}\n+\n+pub enum NicheLayoutEnum {\n+    Tag1,\n+    Data { my_data: CStyleEnum },\n+    Tag2,\n+}\n+\n+fn main() {\n+    let a = Some(CStyleEnum::Low);\n+    let b = Option::<CStyleEnum>::None;\n+    let c = NicheLayoutEnum::Tag1;\n+    let d = NicheLayoutEnum::Data { my_data: CStyleEnum::High };\n+    let e = NicheLayoutEnum::Tag2;\n+    let f = Some(&1u32);\n+    let g = Option::<&'static u32>::None;\n+    let h = Some(12u32);\n+    let i = Option::<u32>::None;\n+    let j = CStyleEnum::High;\n+    let k = Some(\"IAMA optional string!\".to_string());\n+\n+    zzz(); // #break\n+}\n+\n+fn zzz() { () }"}, {"sha": "68e73b5f38da98024d6e5ce863e5e71d56b9dde1", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/257782579915963c9dbe7433102275743837b9a8/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=257782579915963c9dbe7433102275743837b9a8", "patch": "@@ -1,6 +1,7 @@\n // ignore-freebsd: gdb package too new\n // only-cdb // \"Temporarily\" ignored on GDB/LLDB due to debuginfo tests being disabled, see PR 47155\n // ignore-android: FIXME(#10381)\n+// ignore-tidy-linelength\n // compile-flags:-g\n // min-gdb-version: 7.7\n // min-lldb-version: 310\n@@ -111,11 +112,11 @@\n // NOTE: OsString doesn't have a .natvis entry yet.\n \n // cdb-command: dx some\n-// cdb-check:some             : Some(8) [Type: [...]::Option<i16>]\n+// cdb-check:some             : Some [Type: enum$<core::option::Option<i16>>]\n // cdb-command: dx none\n-// cdb-check:none             : None [Type: [...]::Option<i64>]\n+// cdb-check:none             : None [Type: enum$<core::option::Option<i64>>]\n // cdb-command: dx some_string\n-// cdb-check:some_string      : Some(\"IAMA optional string!\") [[...]::Option<[...]::String>]\n+// cdb-check:some_string      [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n \n #![allow(unused_variables)]\n use std::ffi::OsString;"}]}