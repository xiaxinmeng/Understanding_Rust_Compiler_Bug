{"sha": "dfd98ebd3e862d6fe23519fc6605d03a1c146914", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmZDk4ZWJkM2U4NjJkNmZlMjM1MTlmYzY2MDVkMDNhMWMxNDY5MTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-20T00:41:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-20T00:41:49Z"}, "message": "Auto merge of #37289 - GuillaumeGomez:rollup, r=GuillaumeGomez\n\nRollup of 7 pull requests\n\n- Successful merges: #37165, #37187, #37241, #37283, #37285, #37287, #37288\n- Failed merges:", "tree": {"sha": "c55534ab1c084f6aa36529c6b28c316c4f79e35f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c55534ab1c084f6aa36529c6b28c316c4f79e35f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfd98ebd3e862d6fe23519fc6605d03a1c146914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfd98ebd3e862d6fe23519fc6605d03a1c146914", "html_url": "https://github.com/rust-lang/rust/commit/dfd98ebd3e862d6fe23519fc6605d03a1c146914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfd98ebd3e862d6fe23519fc6605d03a1c146914/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d337f345ca8b3bb4aac988ace1c0676abc5310a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d337f345ca8b3bb4aac988ace1c0676abc5310a0", "html_url": "https://github.com/rust-lang/rust/commit/d337f345ca8b3bb4aac988ace1c0676abc5310a0"}, {"sha": "dd3a014ed9e61ba9d2f86e00ef299edf285e276c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd3a014ed9e61ba9d2f86e00ef299edf285e276c", "html_url": "https://github.com/rust-lang/rust/commit/dd3a014ed9e61ba9d2f86e00ef299edf285e276c"}], "stats": {"total": 442, "additions": 190, "deletions": 252}, "files": [{"sha": "3bdf1b7b7f2291aff05b316900e934c042332130", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -380,9 +380,9 @@ the `tests` directory.\n \n # The `tests` directory\n \n-Each file in `tests/*.rs` directory is treated as individual crate.\n-So, to write an integration test, let's make a `tests` directory, and\n-put a `tests/integration_test.rs` file inside, with this as its contents:\n+Each file in `tests/*.rs` directory is treated as an individual crate.\n+To write an integration test, let's make a `tests` directory and\n+put a `tests/integration_test.rs` file inside with this as its contents:\n \n ```rust,ignore\n extern crate adder;"}, {"sha": "8f9c35783379133e98a31bc58c9d1c086d0e936e", "filename": "src/libcollections/borrow.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibcollections%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibcollections%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fborrow.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -86,16 +86,29 @@ impl<T> ToOwned for T where T: Clone {\n /// ```\n /// use std::borrow::Cow;\n ///\n-/// # #[allow(dead_code)]\n /// fn abs_all(input: &mut Cow<[i32]>) {\n ///     for i in 0..input.len() {\n ///         let v = input[i];\n ///         if v < 0 {\n-///             // clones into a vector the first time (if not already owned)\n+///             // Clones into a vector if not already owned.\n ///             input.to_mut()[i] = -v;\n ///         }\n ///     }\n /// }\n+///\n+/// // No clone occurs because `input` doesn't need to be mutated.\n+/// let slice = [0, 1, 2];\n+/// let mut input = Cow::from(&slice[..]);\n+/// abs_all(&mut input);\n+///\n+/// // Clone occurs because `input` needs to be mutated.\n+/// let slice = [-1, 0, 1];\n+/// let mut input = Cow::from(&slice[..]);\n+/// abs_all(&mut input);\n+///\n+/// // No clone occurs because `input` is already owned.\n+/// let mut input = Cow::from(vec![-1, 0, 1]);\n+/// abs_all(&mut input);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Cow<'a, B: ?Sized + 'a>"}, {"sha": "828f9f32baac8d3446b066ed01f7e20dbc20ed49", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -61,9 +61,8 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n                   -> Ty<'tcx> where\n         F: FnOnce(u32) -> ty::InferTy,\n     {\n-        match opt_ty {\n-            Some(ty) => { return ty.fold_with(self); }\n-            None => { }\n+        if let Some(ty) = opt_ty {\n+            return ty.fold_with(self);\n         }\n \n         match self.freshen_map.entry(key) {"}, {"sha": "30b735b9c24e359c9561a2e5f0b19ce4b8a01841", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 13, "deletions": 24, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -478,12 +478,9 @@ impl RegionMaps {\n         //! Returns the scope when temp created by expr_id will be cleaned up\n \n         // check for a designated rvalue scope\n-        match self.rvalue_scopes.borrow().get(&expr_id) {\n-            Some(&s) => {\n-                debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n-                return Some(s);\n-            }\n-            None => { }\n+        if let Some(&s) = self.rvalue_scopes.borrow().get(&expr_id) {\n+            debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n+            return Some(s);\n         }\n \n         let scope_map : &[CodeExtent] = &self.scope_map.borrow();\n@@ -928,19 +925,15 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     //\n     // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n-    match local.init {\n-        Some(ref expr) => {\n-            record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n+    if let Some(ref expr) = local.init {\n+        record_rvalue_scope_if_borrow_expr(visitor, &expr, blk_scope);\n \n-            let is_borrow =\n-                if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n+        let is_borrow =\n+            if let Some(ref ty) = local.ty { is_borrowed_ty(&ty) } else { false };\n \n-            if is_binding_pat(&local.pat) || is_borrow {\n-                record_rvalue_scope(visitor, &expr, blk_scope);\n-            }\n+        if is_binding_pat(&local.pat) || is_borrow {\n+            record_rvalue_scope(visitor, &expr, blk_scope);\n         }\n-\n-        None => { }\n     }\n \n     intravisit::walk_local(visitor, local);\n@@ -1023,16 +1016,12 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n             hir::ExprBlock(ref block) => {\n-                match block.expr {\n-                    Some(ref subexpr) => {\n-                        record_rvalue_scope_if_borrow_expr(\n-                            visitor, &subexpr, blk_id);\n-                    }\n-                    None => { }\n+                if let Some(ref subexpr) = block.expr {\n+                    record_rvalue_scope_if_borrow_expr(\n+                        visitor, &subexpr, blk_id);\n                 }\n             }\n-            _ => {\n-            }\n+            _ => {}\n         }\n     }\n "}, {"sha": "27554c0d2a44db50522b7e4f52ec384a2bed98a3", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -1405,9 +1405,8 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// cache hit, so it's actually a good thing).\n     fn try_start(&mut self, key: ty::ProjectionTy<'tcx>)\n                  -> Result<(), ProjectionCacheEntry<'tcx>> {\n-        match self.map.get(&key) {\n-            Some(entry) => return Err(entry.clone()),\n-            None => { }\n+        if let Some(entry) = self.map.get(&key) {\n+            return Err(entry.clone());\n         }\n \n         self.map.insert(key, ProjectionCacheEntry::InProgress);"}, {"sha": "f4747b5b108a171b3388cb880b22c6d2035178e0", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -788,14 +788,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                stack);\n         assert!(!stack.obligation.predicate.has_escaping_regions());\n \n-        match self.check_candidate_cache(&cache_fresh_trait_pred) {\n-            Some(c) => {\n-                debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n-                       cache_fresh_trait_pred,\n-                       c);\n-                return c;\n-            }\n-            None => { }\n+        if let Some(c) = self.check_candidate_cache(&cache_fresh_trait_pred) {\n+            debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n+                   cache_fresh_trait_pred,\n+                   c);\n+            return c;\n         }\n \n         // If no match, compute result and insert into cache."}, {"sha": "b2032e6a1bf9fcb843680971de24ff7f9e8dd3ab", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 51, "deletions": 61, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -135,15 +135,12 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n-        match opt_loan_path(&cmt) {\n-            Some(lp) => {\n-                let moved_value_use_kind = match loan_cause {\n-                    euv::ClosureCapture(_) => MovedInCapture,\n-                    _ => MovedInUse,\n-                };\n-                self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n-            }\n-            None => { }\n+        if let Some(lp) = opt_loan_path(&cmt) {\n+            let moved_value_use_kind = match loan_cause {\n+                euv::ClosureCapture(_) => MovedInCapture,\n+                _ => MovedInUse,\n+            };\n+            self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n         self.check_for_conflicting_loans(borrow_id);\n@@ -158,33 +155,29 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"mutate(assignment_id={}, assignee_cmt={:?})\",\n                assignment_id, assignee_cmt);\n \n-        match opt_loan_path(&assignee_cmt) {\n-            Some(lp) => {\n-                match mode {\n-                    MutateMode::Init | MutateMode::JustWrite => {\n-                        // In a case like `path = 1`, then path does not\n-                        // have to be *FULLY* initialized, but we still\n-                        // must be careful lest it contains derefs of\n-                        // pointers.\n-                        self.check_if_assigned_path_is_moved(assignee_cmt.id,\n-                                                             assignment_span,\n-                                                             MovedInUse,\n-                                                             &lp);\n-                    }\n-                    MutateMode::WriteAndRead => {\n-                        // In a case like `path += 1`, then path must be\n-                        // fully initialized, since we will read it before\n-                        // we write it.\n-                        self.check_if_path_is_moved(assignee_cmt.id,\n-                                                    assignment_span,\n-                                                    MovedInUse,\n-                                                    &lp);\n-                    }\n+        if let Some(lp) = opt_loan_path(&assignee_cmt) {\n+            match mode {\n+                MutateMode::Init | MutateMode::JustWrite => {\n+                    // In a case like `path = 1`, then path does not\n+                    // have to be *FULLY* initialized, but we still\n+                    // must be careful lest it contains derefs of\n+                    // pointers.\n+                    self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                                                         assignment_span,\n+                                                         MovedInUse,\n+                                                         &lp);\n+                }\n+                MutateMode::WriteAndRead => {\n+                    // In a case like `path += 1`, then path must be\n+                    // fully initialized, since we will read it before\n+                    // we write it.\n+                    self.check_if_path_is_moved(assignee_cmt.id,\n+                                                assignment_span,\n+                                                MovedInUse,\n+                                                &lp);\n                 }\n             }\n-            None => { }\n         }\n-\n         self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n     }\n \n@@ -601,39 +594,36 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                       span: Span,\n                       cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n-        match opt_loan_path(&cmt) {\n-            Some(lp) => {\n-                let moved_value_use_kind = match mode {\n-                    euv::Copy => {\n-                        self.check_for_copy_of_frozen_path(id, span, &lp);\n-                        MovedInUse\n-                    }\n-                    euv::Move(_) => {\n-                        match self.move_data.kind_of_move_of_path(id, &lp) {\n-                            None => {\n-                                // Sometimes moves don't have a move kind;\n-                                // this either means that the original move\n-                                // was from something illegal to move,\n-                                // or was moved from referent of an unsafe\n-                                // pointer or something like that.\n+        if let Some(lp) = opt_loan_path(&cmt) {\n+            let moved_value_use_kind = match mode {\n+                euv::Copy => {\n+                    self.check_for_copy_of_frozen_path(id, span, &lp);\n+                    MovedInUse\n+                }\n+                euv::Move(_) => {\n+                    match self.move_data.kind_of_move_of_path(id, &lp) {\n+                        None => {\n+                            // Sometimes moves don't have a move kind;\n+                            // this either means that the original move\n+                            // was from something illegal to move,\n+                            // or was moved from referent of an unsafe\n+                            // pointer or something like that.\n+                            MovedInUse\n+                        }\n+                        Some(move_kind) => {\n+                            self.check_for_move_of_borrowed_path(id, span,\n+                                                                 &lp, move_kind);\n+                            if move_kind == move_data::Captured {\n+                                MovedInCapture\n+                            } else {\n                                 MovedInUse\n                             }\n-                            Some(move_kind) => {\n-                                self.check_for_move_of_borrowed_path(id, span,\n-                                                                     &lp, move_kind);\n-                                if move_kind == move_data::Captured {\n-                                    MovedInCapture\n-                                } else {\n-                                    MovedInUse\n-                                }\n-                            }\n                         }\n                     }\n-                };\n+                }\n+            };\n \n-                self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n-            }\n-            None => { }\n+            self.check_if_path_is_moved(id, span, moved_value_use_kind, &lp);\n         }\n     }\n "}, {"sha": "ab675db21503e2893e3144cb736c1055acc08cb1", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -57,9 +57,9 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n                     // (*)\n                     // (*) dominators for `pred` have been calculated\n                     new_idom = intersect_opt(&post_order_rank,\n-                                                  &immediate_dominators,\n-                                                  new_idom,\n-                                                  Some(pred));\n+                                             &immediate_dominators,\n+                                             new_idom,\n+                                             Some(pred));\n                 }\n             }\n \n@@ -77,10 +77,10 @@ pub fn dominators_given_rpo<G: ControlFlowGraph>(graph: &G,\n }\n \n fn intersect_opt<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n-                                      immediate_dominators: &IndexVec<Node, Option<Node>>,\n-                                      node1: Option<Node>,\n-                                      node2: Option<Node>)\n-                                      -> Option<Node> {\n+                            immediate_dominators: &IndexVec<Node, Option<Node>>,\n+                            node1: Option<Node>,\n+                            node2: Option<Node>)\n+                            -> Option<Node> {\n     match (node1, node2) {\n         (None, None) => None,\n         (Some(n), None) | (None, Some(n)) => Some(n),\n@@ -89,10 +89,10 @@ fn intersect_opt<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n }\n \n fn intersect<Node: Idx>(post_order_rank: &IndexVec<Node, usize>,\n-                                  immediate_dominators: &IndexVec<Node, Option<Node>>,\n-                                  mut node1: Node,\n-                                  mut node2: Node)\n-                                  -> Node {\n+                        immediate_dominators: &IndexVec<Node, Option<Node>>,\n+                        mut node1: Node,\n+                        mut node2: Node)\n+                        -> Node {\n     while node1 != node2 {\n         while post_order_rank[node1] < post_order_rank[node2] {\n             node1 = immediate_dominators[node1].unwrap();\n@@ -142,9 +142,9 @@ impl<Node: Idx> Dominators<Node> {\n                 \"node {:?} is not reachable\",\n                 node2);\n         intersect::<Node>(&self.post_order_rank,\n-                  &self.immediate_dominators,\n-                  node1,\n-                  node2)\n+                          &self.immediate_dominators,\n+                          node1,\n+                          node2)\n     }\n \n     pub fn mutual_dominator<I>(&self, iter: I) -> Option<Node>"}, {"sha": "0af878cac2df1d23f0706aab4b0693aa22293b39", "filename": "src/librustc_data_structures/control_flow_graph/dominators/test.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Ftest.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -14,12 +14,7 @@ use super::*;\n \n #[test]\n fn diamond() {\n-    let graph = TestGraph::new(0, &[\n-        (0, 1),\n-        (0, 2),\n-        (1, 3),\n-        (2, 3),\n-    ]);\n+    let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n \n     let dominators = dominators(&graph);\n     let immediate_dominators = dominators.all_immediate_dominators();\n@@ -32,17 +27,9 @@ fn diamond() {\n #[test]\n fn paper() {\n     // example from the paper:\n-    let graph = TestGraph::new(6, &[\n-        (6, 5),\n-        (6, 4),\n-        (5, 1),\n-        (4, 2),\n-        (4, 3),\n-        (1, 2),\n-        (2, 3),\n-        (3, 2),\n-        (2, 1),\n-    ]);\n+    let graph = TestGraph::new(6,\n+                               &[(6, 5), (6, 4), (5, 1), (4, 2), (4, 3), (1, 2), (2, 3), (3, 2),\n+                                 (2, 1)]);\n \n     let dominators = dominators(&graph);\n     let immediate_dominators = dominators.all_immediate_dominators();\n@@ -54,4 +41,3 @@ fn paper() {\n     assert_eq!(immediate_dominators[5], Some(6));\n     assert_eq!(immediate_dominators[6], Some(6));\n }\n-"}, {"sha": "dca45602f17c45b58223353d2d83984c7012d78e", "filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -15,12 +15,7 @@ use super::*;\n \n #[test]\n fn diamond_post_order() {\n-    let graph = TestGraph::new(0, &[\n-        (0, 1),\n-        (0, 2),\n-        (1, 3),\n-        (2, 3),\n-    ]);\n+    let graph = TestGraph::new(0, &[(0, 1), (0, 2), (1, 3), (2, 3)]);\n \n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n@@ -33,16 +28,8 @@ fn rev_post_order_inner_loop() {\n     //      ^     ^    v      |\n     //      |     6 <- 4      |\n     //      +-----------------+\n-    let graph = TestGraph::new(0, &[\n-        (0, 1),\n-        (1, 2),\n-        (2, 3),\n-        (3, 5),\n-        (3, 1),\n-        (2, 4),\n-        (4, 6),\n-        (6, 2),\n-    ]);\n+    let graph = TestGraph::new(0,\n+                               &[(0, 1), (1, 2), (2, 3), (3, 5), (3, 1), (2, 4), (4, 6), (6, 2)]);\n \n     let rev_graph = TransposedGraph::new(&graph);\n \n@@ -52,4 +39,3 @@ fn rev_post_order_inner_loop() {\n     let result = post_order_from_to(&rev_graph, 3, Some(1));\n     assert_eq!(result, vec![4, 6, 2, 3]);\n }\n-"}, {"sha": "eb6839df6274f258fea86f8191cdccb685e0f638", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -36,10 +36,10 @@ pub trait ControlFlowGraph\n \n pub trait GraphPredecessors<'graph> {\n     type Item;\n-    type Iter: Iterator<Item=Self::Item>;\n+    type Iter: Iterator<Item = Self::Item>;\n }\n \n pub trait GraphSuccessors<'graph> {\n     type Item;\n-    type Iter: Iterator<Item=Self::Item>;\n-}\n\\ No newline at end of file\n+    type Iter: Iterator<Item = Self::Item>;\n+}"}, {"sha": "24210ebb95d3d14f97724a1cf197014ee9c43244", "filename": "src/librustc_data_structures/control_flow_graph/reachable/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -19,8 +19,7 @@ use super::super::indexed_vec::{IndexVec, Idx};\n #[cfg(test)]\n mod test;\n \n-pub fn reachable<G: ControlFlowGraph>(graph: &G)\n-                                      -> Reachability<G::Node> {\n+pub fn reachable<G: ControlFlowGraph>(graph: &G) -> Reachability<G::Node> {\n     let reverse_post_order = reverse_post_order(graph, graph.start_node());\n     reachable_given_rpo(graph, &reverse_post_order)\n }\n@@ -53,12 +52,10 @@ pub struct Reachability<Node: Idx> {\n impl<Node: Idx> Reachability<Node> {\n     fn new<G: ControlFlowGraph>(graph: &G) -> Self {\n         let num_nodes = graph.num_nodes();\n-        Reachability {\n-            bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes),\n-        }\n+        Reachability { bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes) }\n     }\n \n-    pub fn can_reach(&self, source: Node, target: Node)-> bool {\n+    pub fn can_reach(&self, source: Node, target: Node) -> bool {\n         let bit: usize = target.index();\n         self.bits[source].contains(bit)\n     }"}, {"sha": "ef45deeaafc78f30268c29af743f4509de58125a", "filename": "src/librustc_data_structures/control_flow_graph/reachable/test.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -17,15 +17,7 @@ fn test1() {\n     // 0 -> 1 -> 2 -> 3\n     //      ^    v\n     //      6 <- 4 -> 5\n-    let graph = TestGraph::new(0, &[\n-        (0, 1),\n-        (1, 2),\n-        (2, 3),\n-        (2, 4),\n-        (4, 5),\n-        (4, 6),\n-        (6, 1),\n-    ]);\n+    let graph = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (6, 1)]);\n     let reachable = reachable(&graph);\n     assert!((0..6).all(|i| reachable.can_reach(0, i)));\n     assert!((1..6).all(|i| reachable.can_reach(1, i)));\n@@ -43,15 +35,9 @@ fn test2() {\n     // 30 -> 31 -> 32 -> 33\n     //       ^      v\n     //       36 <- 34 -> 35\n-    let graph = TestGraph::new(30, &[\n-        (30, 31),\n-        (31, 32),\n-        (32, 33),\n-        (32, 34),\n-        (34, 35),\n-        (34, 36),\n-        (36, 31),\n-    ]);\n+    let graph = TestGraph::new(30,\n+                               &[(30, 31), (31, 32), (32, 33), (32, 34), (34, 35), (34, 36),\n+                                 (36, 31)]);\n     let reachable = reachable(&graph);\n     assert!((30..36).all(|i| reachable.can_reach(30, i)));\n     assert!((31..36).all(|i| reachable.can_reach(31, i)));"}, {"sha": "3b8b01f2ff43b5820daee85e5230dedf9d51085a", "filename": "src/librustc_data_structures/control_flow_graph/reference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freference.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -21,13 +21,13 @@ impl<'graph, G: ControlFlowGraph> ControlFlowGraph for &'graph G {\n         (**self).start_node()\n     }\n \n-    fn predecessors<'iter>(&'iter self, node: Self::Node)\n-                            -> <Self as GraphPredecessors<'iter>>::Iter {\n+    fn predecessors<'iter>(&'iter self,\n+                           node: Self::Node)\n+                           -> <Self as GraphPredecessors<'iter>>::Iter {\n         (**self).predecessors(node)\n     }\n \n-    fn successors<'iter>(&'iter self, node: Self::Node)\n-                          -> <Self as GraphSuccessors<'iter>>::Iter {\n+    fn successors<'iter>(&'iter self, node: Self::Node) -> <Self as GraphSuccessors<'iter>>::Iter {\n         (**self).successors(node)\n     }\n }"}, {"sha": "d48a6e684ad8e8f8258c4a43cd91d68c3fc4ce95", "filename": "src/librustc_data_structures/control_flow_graph/test.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftest.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -28,7 +28,7 @@ impl TestGraph {\n             num_nodes: start_node + 1,\n             start_node: start_node,\n             successors: HashMap::new(),\n-            predecessors: HashMap::new()\n+            predecessors: HashMap::new(),\n         };\n         for &(source, target) in edges {\n             graph.num_nodes = max(graph.num_nodes, source + 1);\n@@ -55,13 +55,13 @@ impl ControlFlowGraph for TestGraph {\n         self.num_nodes\n     }\n \n-    fn predecessors<'graph>(&'graph self, node: usize)\n+    fn predecessors<'graph>(&'graph self,\n+                            node: usize)\n                             -> <Self as GraphPredecessors<'graph>>::Iter {\n-       self.predecessors[&node].iter().cloned()\n+        self.predecessors[&node].iter().cloned()\n     }\n \n-    fn successors<'graph>(&'graph self, node: usize)\n-                            -> <Self as GraphSuccessors<'graph>>::Iter {\n+    fn successors<'graph>(&'graph self, node: usize) -> <Self as GraphSuccessors<'graph>>::Iter {\n         self.successors[&node].iter().cloned()\n     }\n }\n@@ -75,4 +75,3 @@ impl<'graph> GraphSuccessors<'graph> for TestGraph {\n     type Item = usize;\n     type Iter = iter::Cloned<slice::Iter<'graph, usize>>;\n }\n-"}, {"sha": "a1a117edb94fce9cd41e00d413b69c611275d1e2", "filename": "src/librustc_data_structures/control_flow_graph/transpose.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -22,7 +22,10 @@ impl<G: ControlFlowGraph> TransposedGraph<G> {\n     }\n \n     pub fn with_start(base_graph: G, start_node: G::Node) -> Self {\n-        TransposedGraph { base_graph: base_graph, start_node: start_node }\n+        TransposedGraph {\n+            base_graph: base_graph,\n+            start_node: start_node,\n+        }\n     }\n }\n \n@@ -37,12 +40,14 @@ impl<G: ControlFlowGraph> ControlFlowGraph for TransposedGraph<G> {\n         self.start_node\n     }\n \n-    fn predecessors<'graph>(&'graph self, node: Self::Node)\n+    fn predecessors<'graph>(&'graph self,\n+                            node: Self::Node)\n                             -> <Self as GraphPredecessors<'graph>>::Iter {\n         self.base_graph.successors(node)\n     }\n \n-    fn successors<'graph>(&'graph self, node: Self::Node)\n+    fn successors<'graph>(&'graph self,\n+                          node: Self::Node)\n                           -> <Self as GraphSuccessors<'graph>>::Iter {\n         self.base_graph.predecessors(node)\n     }"}, {"sha": "0306066d6e784e47e3ee7602f72469c9b88c2153", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -23,7 +23,7 @@ pub struct SnapshotMap<K, V>\n }\n \n pub struct Snapshot {\n-    len: usize\n+    len: usize,\n }\n \n enum UndoLog<K, V> {\n@@ -39,7 +39,7 @@ impl<K, V> SnapshotMap<K, V>\n     pub fn new() -> Self {\n         SnapshotMap {\n             map: FnvHashMap(),\n-            undo_log: vec![]\n+            undo_log: vec![],\n         }\n     }\n \n@@ -68,9 +68,7 @@ impl<K, V> SnapshotMap<K, V>\n                 }\n                 true\n             }\n-            None => {\n-                false\n-            }\n+            None => false,\n         }\n     }\n \n@@ -88,7 +86,7 @@ impl<K, V> SnapshotMap<K, V>\n         assert!(snapshot.len < self.undo_log.len());\n         assert!(match self.undo_log[snapshot.len] {\n             UndoLog::OpenSnapshot => true,\n-            _ => false\n+            _ => false,\n         });\n     }\n \n@@ -110,7 +108,7 @@ impl<K, V> SnapshotMap<K, V>\n                     panic!(\"cannot rollback an uncommitted snapshot\");\n                 }\n \n-                UndoLog::CommittedSnapshot => { }\n+                UndoLog::CommittedSnapshot => {}\n \n                 UndoLog::Inserted(key) => {\n                     self.map.remove(&key);\n@@ -123,7 +121,10 @@ impl<K, V> SnapshotMap<K, V>\n         }\n \n         let v = self.undo_log.pop().unwrap();\n-        assert!(match v { UndoLog::OpenSnapshot => true, _ => false });\n+        assert!(match v {\n+            UndoLog::OpenSnapshot => true,\n+            _ => false,\n+        });\n         assert!(self.undo_log.len() == snapshot.len);\n     }\n }"}, {"sha": "1f4d09a92247eb9765d218a192b5d9dc7b54024c", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -27,7 +27,7 @@ mod tests;\n ///\n /// Clients are expected to provide implementations of this trait; you\n /// can see some examples in the `test` module.\n-pub trait UnifyKey : Copy + Clone + Debug + PartialEq {\n+pub trait UnifyKey: Copy + Clone + Debug + PartialEq {\n     type Value: Clone + PartialEq + Debug;\n \n     fn index(&self) -> u32;\n@@ -115,11 +115,7 @@ impl<K: UnifyKey> VarValue<K> {\n     }\n \n     fn if_not_self(&self, key: K, self_key: K) -> Option<K> {\n-        if key == self_key {\n-            None\n-        } else {\n-            Some(key)\n-        }\n+        if key == self_key { None } else { Some(key) }\n     }\n }\n \n@@ -236,7 +232,8 @@ impl<K: UnifyKey> UnificationTable<K> {\n                      new_rank: u32,\n                      old_root: VarValue<K>,\n                      new_root: VarValue<K>,\n-                     new_value: K::Value) -> K {\n+                     new_value: K::Value)\n+                     -> K {\n         let old_root_key = old_root.key();\n         let new_root_key = new_root.key();\n         self.set(old_root_key, old_root.redirect(new_root_key));\n@@ -306,7 +303,8 @@ impl<'tcx, K, V> UnificationTable<K>\n         let combined = {\n             match (&node_a.value, &node_b.value) {\n                 (&None, &None) => None,\n-                (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(v.clone()),\n+                (&Some(ref v), &None) |\n+                (&None, &Some(ref v)) => Some(v.clone()),\n                 (&Some(ref v1), &Some(ref v2)) => {\n                     if *v1 != *v2 {\n                         return Err((v1.clone(), v2.clone()));"}, {"sha": "37cac7c526555c85deca767f740e753c25f1f348", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -302,9 +302,8 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     };\n \n     // Check if we already trans'd this shim.\n-    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n-        Some(&llval) => { return llval; }\n-        None => { }\n+    if let Some(&llval) = ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n+        return llval;\n     }\n \n     debug!(\"trans_fn_pointer_shim(bare_fn_ty={:?})\","}, {"sha": "1e687f5ff6e3a51bc29e304e3d3838349a7c7291", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -119,9 +119,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n     // Check the cache.\n-    match ccx.vtables().borrow().get(&trait_ref) {\n-        Some(&val) => { return val }\n-        None => { }\n+    if let Some(&val) = ccx.vtables().borrow().get(&trait_ref) {\n+        return val;\n     }\n \n     // Not in the cache. Build it."}, {"sha": "4fbb31cf0a534d3bfaeafc021700ea990020c1a3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -1629,9 +1629,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n \n         let cache = self.ast_ty_to_ty_cache();\n-        match cache.borrow().get(&ast_ty.id) {\n-            Some(ty) => { return ty; }\n-            None => { }\n+        if let Some(ty) = cache.borrow().get(&ast_ty.id) {\n+            return ty;\n         }\n \n         let result_ty = match ast_ty.node {"}, {"sha": "703c6ade40a26a9da5f99faef391fbd027ffde1d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -742,17 +742,14 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n       hir::ItemImpl(.., ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n           let impl_def_id = ccx.tcx.map.local_def_id(it.id);\n-          match ccx.tcx.impl_trait_ref(impl_def_id) {\n-              Some(impl_trait_ref) => {\n-                  check_impl_items_against_trait(ccx,\n-                                                 it.span,\n-                                                 impl_def_id,\n-                                                 &impl_trait_ref,\n-                                                 impl_items);\n-                  let trait_def_id = impl_trait_ref.def_id;\n-                  check_on_unimplemented(ccx, trait_def_id, it);\n-              }\n-              None => { }\n+          if let Some(impl_trait_ref) = ccx.tcx.impl_trait_ref(impl_def_id) {\n+              check_impl_items_against_trait(ccx,\n+                                             it.span,\n+                                             impl_def_id,\n+                                             &impl_trait_ref,\n+                                             impl_items);\n+              let trait_def_id = impl_trait_ref.def_id;\n+              check_on_unimplemented(ccx, trait_def_id, it);\n           }\n       }\n       hir::ItemTrait(..) => {\n@@ -1812,9 +1809,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                  f: F) where\n         F: FnOnce(&ty::ItemSubsts<'tcx>),\n     {\n-        match self.tables.borrow().item_substs.get(&id) {\n-            Some(s) => { f(s) }\n-            None => { }\n+        if let Some(s) = self.tables.borrow().item_substs.get(&id) {\n+            f(s);\n         }\n     }\n "}, {"sha": "40b19b01cd901cfda65786bfeeb0d04e8f3f463c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -156,13 +156,10 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     {\n         {\n             let mut stack = self.stack.borrow_mut();\n-            match stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n-                None => { }\n-                Some((i, _)) => {\n-                    let cycle = &stack[i..];\n-                    self.report_cycle(span, cycle);\n-                    return Err(ErrorReported);\n-                }\n+            if let Some((i, _)) = stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n+                let cycle = &stack[i..];\n+                self.report_cycle(span, cycle);\n+                return Err(ErrorReported);\n             }\n             stack.push(request);\n         }"}, {"sha": "ca9452ffe3eca04e43b10f8e6e2a44d30d5779cf", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -15,22 +15,28 @@ use cmp;\n use io::{self, SeekFrom, Error, ErrorKind};\n \n /// A `Cursor` wraps another type and provides it with a\n-/// [`Seek`](trait.Seek.html) implementation.\n+/// [`Seek`] implementation.\n ///\n-/// Cursors are typically used with in-memory buffers to allow them to\n-/// implement `Read` and/or `Write`, allowing these buffers to be used\n+/// `Cursor`s are typically used with in-memory buffers to allow them to\n+/// implement [`Read`] and/or [`Write`], allowing these buffers to be used\n /// anywhere you might use a reader or writer that does actual I/O.\n ///\n /// The standard library implements some I/O traits on various types which\n-/// are commonly used as a buffer, like `Cursor<Vec<u8>>` and `Cursor<&[u8]>`.\n+/// are commonly used as a buffer, like `Cursor<`[`Vec`]`<u8>>` and\n+/// `Cursor<`[`&[u8]`]`>`.\n ///\n /// # Examples\n ///\n-/// We may want to write bytes to a [`File`][file] in our production\n+/// We may want to write bytes to a [`File`] in our production\n /// code, but use an in-memory buffer in our tests. We can do this with\n /// `Cursor`:\n ///\n-/// [file]: ../fs/struct.File.html\n+/// [`Seek`]: trait.Seek.html\n+/// [`Read`]: ../../std/io/trait.Read.html\n+/// [`Write`]: ../../std/io/trait.Write.html\n+/// [`Vec`]: ../../std/vec/struct.Vec.html\n+/// [`&[u8]`]: ../../std/primitive.slice.html\n+/// [`File`]: ../fs/struct.File.html\n ///\n /// ```no_run\n /// use std::io::prelude::*;"}, {"sha": "c7248fe68fafd39c2ef283c0099b44336f19a633", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfd98ebd3e862d6fe23519fc6605d03a1c146914/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dfd98ebd3e862d6fe23519fc6605d03a1c146914", "patch": "@@ -2449,13 +2449,10 @@ impl<'a> State<'a> {\n                     |s, ty| s.print_type(&ty)));\n                 try!(word(&mut self.s, \")\"));\n \n-                match data.output {\n-                    None => { }\n-                    Some(ref ty) => {\n-                        try!(self.space_if_not_bol());\n-                        try!(self.word_space(\"->\"));\n-                        try!(self.print_type(&ty));\n-                    }\n+                if let Some(ref ty) = data.output {\n+                    try!(self.space_if_not_bol());\n+                    try!(self.word_space(\"->\"));\n+                    try!(self.print_type(&ty));\n                 }\n             }\n         }"}]}