{"sha": "e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YTQ4ODIxYzBkMzBjY2Q2YjdlYTg4YmUyNGVlZDFiY2JhNWY0OGE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-15T13:00:20Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T16:35:26Z"}, "message": "rustc_const_eval: always demand typeck_tables for evaluating constants.", "tree": {"sha": "82387e47712464862cadd6749f6c8556d59df63b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82387e47712464862cadd6749f6c8556d59df63b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "html_url": "https://github.com/rust-lang/rust/commit/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c832e6f3272fd01e22a6370e7745e305fe13a4c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c832e6f3272fd01e22a6370e7745e305fe13a4c9", "html_url": "https://github.com/rust-lang/rust/commit/c832e6f3272fd01e22a6370e7745e305fe13a4c9"}], "stats": {"total": 1926, "additions": 705, "deletions": 1221}, "files": [{"sha": "b1b1b849437d1464339bce0655d6d716bf447173", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -390,44 +390,6 @@ RFC. It is, however, [currently unimplemented][iss15872].\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n-E0109: r##\"\n-You tried to give a type parameter to a type which doesn't need it. Erroneous\n-code example:\n-\n-```compile_fail,E0109\n-type X = u32<i32>; // error: type parameters are not allowed on this type\n-```\n-\n-Please check that you used the correct type and recheck its definition. Perhaps\n-it doesn't need the type parameter.\n-\n-Example:\n-\n-```\n-type X = u32; // this compiles\n-```\n-\n-Note that type parameters for enum-variant constructors go after the variant,\n-not after the enum (Option::None::<u32>, not Option::<u32>::None).\n-\"##,\n-\n-E0110: r##\"\n-You tried to give a lifetime parameter to a type which doesn't need it.\n-Erroneous code example:\n-\n-```compile_fail,E0110\n-type X = u32<'static>; // error: lifetime parameters are not allowed on\n-                       //        this type\n-```\n-\n-Please check that the correct type was used and recheck its definition; perhaps\n-it doesn't need the lifetime parameter. Example:\n-\n-```\n-type X = u32; // ok!\n-```\n-\"##,\n-\n E0133: r##\"\n Unsafe code was used outside of an unsafe function or block.\n \n@@ -627,41 +589,6 @@ attributes:\n See also https://doc.rust-lang.org/book/no-stdlib.html\n \"##,\n \n-E0229: r##\"\n-An associated type binding was done outside of the type parameter declaration\n-and `where` clause. Erroneous code example:\n-\n-```compile_fail,E0229\n-pub trait Foo {\n-    type A;\n-    fn boo(&self) -> <Self as Foo>::A;\n-}\n-\n-struct Bar;\n-\n-impl Foo for isize {\n-    type A = usize;\n-    fn boo(&self) -> usize { 42 }\n-}\n-\n-fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n-// error: associated type bindings are not allowed here\n-```\n-\n-To solve this error, please move the type bindings in the type parameter\n-declaration:\n-\n-```ignore\n-fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n-```\n-\n-Or in the `where` clause:\n-\n-```ignore\n-fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n-```\n-\"##,\n-\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used."}, {"sha": "c4fccdcb9eb6220ce01c6727797aa487ca098e88", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -76,7 +76,6 @@ pub mod infer;\n pub mod lint;\n \n pub mod middle {\n-    pub mod astconv_util;\n     pub mod expr_use_visitor;\n     pub mod const_val;\n     pub mod cstore;"}, {"sha": "3418034b069d606c7b4f084b0fa6ce5035d6bb17", "filename": "src/librustc/middle/astconv_util.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * This module contains a simple utility routine\n- * used by both `typeck` and `const_eval`.\n- * Almost certainly this could (and should) be refactored out of existence.\n- */\n-\n-use hir;\n-use hir::def::Def;\n-use ty::{Ty, TyCtxt};\n-\n-use syntax_pos::Span;\n-\n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn prohibit_type_params(self, segments: &[hir::PathSegment]) {\n-        for segment in segments {\n-            for typ in segment.parameters.types() {\n-                struct_span_err!(self.sess, typ.span, E0109,\n-                                 \"type parameters are not allowed on this type\")\n-                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n-                    .emit();\n-                break;\n-            }\n-            for lifetime in segment.parameters.lifetimes() {\n-                struct_span_err!(self.sess, lifetime.span, E0110,\n-                                 \"lifetime parameters are not allowed on this type\")\n-                    .span_label(lifetime.span,\n-                                &format!(\"lifetime parameter not allowed on this type\"))\n-                    .emit();\n-                break;\n-            }\n-            for binding in segment.parameters.bindings() {\n-                self.prohibit_projection(binding.span);\n-                break;\n-            }\n-        }\n-    }\n-\n-    pub fn prohibit_projection(self, span: Span)\n-    {\n-        let mut err = struct_span_err!(self.sess, span, E0229,\n-                                       \"associated type bindings are not allowed here\");\n-        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n-    }\n-\n-    pub fn prim_ty_to_ty(self,\n-                         segments: &[hir::PathSegment],\n-                         nty: hir::PrimTy)\n-                         -> Ty<'tcx> {\n-        self.prohibit_type_params(segments);\n-        match nty {\n-            hir::TyBool => self.types.bool,\n-            hir::TyChar => self.types.char,\n-            hir::TyInt(it) => self.mk_mach_int(it),\n-            hir::TyUint(uit) => self.mk_mach_uint(uit),\n-            hir::TyFloat(ft) => self.mk_mach_float(ft),\n-            hir::TyStr => self.mk_str()\n-        }\n-    }\n-\n-    /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n-    /// to it.\n-    pub fn ast_ty_to_prim_ty(self, ast_ty: &hir::Ty) -> Option<Ty<'tcx>> {\n-        if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n-            if let Def::PrimTy(nty) = path.def {\n-                Some(self.prim_ty_to_ty(&path.segments, nty))\n-            } else {\n-                None\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-}"}, {"sha": "d81f89827d93814de111839dc33661c97fc282cf", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -12,28 +12,30 @@ use syntax::symbol::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n use hir::def_id::DefId;\n+use ty::subst::Substs;\n use rustc_const_math::*;\n+\n use self::ConstVal::*;\n pub use rustc_const_math::ConstInt;\n \n use std::collections::BTreeMap;\n \n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n-pub enum ConstVal {\n+pub enum ConstVal<'tcx> {\n     Float(ConstFloat),\n     Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n     Bool(bool),\n-    Function(DefId),\n-    Struct(BTreeMap<ast::Name, ConstVal>),\n-    Tuple(Vec<ConstVal>),\n-    Array(Vec<ConstVal>),\n-    Repeat(Box<ConstVal>, u64),\n+    Function(DefId, &'tcx Substs<'tcx>),\n+    Struct(BTreeMap<ast::Name, ConstVal<'tcx>>),\n+    Tuple(Vec<ConstVal<'tcx>>),\n+    Array(Vec<ConstVal<'tcx>>),\n+    Repeat(Box<ConstVal<'tcx>>, u64),\n     Char(char),\n }\n \n-impl ConstVal {\n+impl<'tcx> ConstVal<'tcx> {\n     pub fn description(&self) -> &'static str {\n         match *self {\n             Float(f) => f.description(),\n@@ -43,7 +45,7 @@ impl ConstVal {\n             Bool(_) => \"boolean\",\n             Struct(_) => \"struct\",\n             Tuple(_) => \"tuple\",\n-            Function(_) => \"function definition\",\n+            Function(..) => \"function definition\",\n             Array(..) => \"array\",\n             Repeat(..) => \"repeat\",\n             Char(..) => \"char\",\n@@ -53,8 +55,7 @@ impl ConstVal {\n     pub fn to_const_int(&self) -> Option<ConstInt> {\n         match *self {\n             ConstVal::Integral(i) => Some(i),\n-            ConstVal::Bool(true) => Some(ConstInt::Infer(1)),\n-            ConstVal::Bool(false) => Some(ConstInt::Infer(0)),\n+            ConstVal::Bool(b) => Some(ConstInt::U8(b as u8)),\n             ConstVal::Char(ch) => Some(ConstInt::U32(ch as u32)),\n             _ => None\n         }"}, {"sha": "40ebc97a78a6ce2f743a20f4c9e70061f79db5c4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -542,7 +542,7 @@ impl<'tcx> Terminator<'tcx> {\n impl<'tcx> TerminatorKind<'tcx> {\n     pub fn if_<'a, 'gcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>, cond: Operand<'tcx>,\n                          t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n-        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::Infer(0)];\n+        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::U8(0)];\n         TerminatorKind::SwitchInt {\n             discr: cond,\n             switch_ty: tcx.types.bool,\n@@ -1224,7 +1224,7 @@ pub enum Literal<'tcx> {\n         substs: &'tcx Substs<'tcx>,\n     },\n     Value {\n-        value: ConstVal,\n+        value: ConstVal<'tcx>,\n     },\n     Promoted {\n         // Index into the `promoted` vector of `Mir`.\n@@ -1271,7 +1271,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n             write!(fmt, \"b\\\"{}\\\"\", escaped)\n         }\n         Bool(b) => write!(fmt, \"{:?}\", b),\n-        Function(def_id) => write!(fmt, \"{}\", item_path_str(def_id)),\n+        Function(def_id, _) => write!(fmt, \"{}\", item_path_str(def_id)),\n         Struct(_) | Tuple(_) | Array(_) | Repeat(..) =>\n             bug!(\"ConstVal `{:?}` should not be in MIR\", const_val),\n         Char(c) => write!(fmt, \"{:?}\", c),"}, {"sha": "6961e0da362a5f7835ca0decce0e93c9c603fe9e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -244,6 +244,10 @@ pub struct TypeckTables<'tcx> {\n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n     pub used_trait_imports: DefIdSet,\n+\n+    /// If any errors occurred while type-checking this body,\n+    /// this field will be set to `true`.\n+    pub tainted_by_errors: bool,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -262,6 +266,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             cast_kinds: NodeMap(),\n             lints: lint::LintTable::new(),\n             used_trait_imports: DefIdSet(),\n+            tainted_by_errors: false,\n         }\n     }\n "}, {"sha": "e7895ca799012530852c0c49be85c9a95466f3bd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -20,7 +20,6 @@ use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n-use rustc_const_math::ConstInt;\n \n use std::cmp;\n use std::fmt;\n@@ -1183,11 +1182,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                                                             i64::min_value(),\n                                                             true);\n                     for discr in def.discriminants(tcx) {\n-                        let x = match discr.erase_type() {\n-                            ConstInt::InferSigned(i) => i as i64,\n-                            ConstInt::Infer(i) => i as u64 as i64,\n-                            _ => bug!()\n-                        };\n+                        let x = discr.to_u128_unchecked() as i64;\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }"}, {"sha": "b79ab2a26fdc9c5da60e64c0edd32e8a60382e9a", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -381,7 +381,7 @@ define_maps! { <'tcx>\n \n     /// Results of evaluating monomorphic constants embedded in\n     /// other items, such as enum variant explicit discriminants.\n-    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal, ()>\n+    pub monomorphic_const_eval: MonomorphicConstEval(DefId) -> Result<ConstVal<'tcx>, ()>\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {"}, {"sha": "49c25d25c604fb8c893dbecc6d1b5e50e4fe92b0", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -47,6 +47,35 @@ type Disr = ConstInt;\n  }\n \n \n+macro_rules! typed_literal {\n+    ($tcx:expr, $ty:expr, $lit:expr) => {\n+        match $ty {\n+            SignedInt(ast::IntTy::I8)    => ConstInt::I8($lit),\n+            SignedInt(ast::IntTy::I16)   => ConstInt::I16($lit),\n+            SignedInt(ast::IntTy::I32)   => ConstInt::I32($lit),\n+            SignedInt(ast::IntTy::I64)   => ConstInt::I64($lit),\n+            SignedInt(ast::IntTy::I128)   => ConstInt::I128($lit),\n+            SignedInt(ast::IntTy::Is) => match $tcx.sess.target.int_type {\n+                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16($lit)),\n+                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32($lit)),\n+                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64($lit)),\n+                _ => bug!(),\n+            },\n+            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8($lit),\n+            UnsignedInt(ast::UintTy::U16) => ConstInt::U16($lit),\n+            UnsignedInt(ast::UintTy::U32) => ConstInt::U32($lit),\n+            UnsignedInt(ast::UintTy::U64) => ConstInt::U64($lit),\n+            UnsignedInt(ast::UintTy::U128) => ConstInt::U128($lit),\n+            UnsignedInt(ast::UintTy::Us) => match $tcx.sess.target.uint_type {\n+                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16($lit)),\n+                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32($lit)),\n+                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64($lit)),\n+                _ => bug!(),\n+            },\n+        }\n+    }\n+}\n+\n impl IntTypeExt for attr::IntType {\n     fn to_ty<'a, 'gcx, 'tcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match *self {\n@@ -66,30 +95,7 @@ impl IntTypeExt for attr::IntType {\n     }\n \n     fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n-            SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n-            SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n-            SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n-            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n-            SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n-                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n-                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n-                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n-                _ => bug!(),\n-            },\n-            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n-            UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n-            UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n-            UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n-            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n-            UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n-                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n-                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n-                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n-                _ => bug!(),\n-            },\n-        }\n+        typed_literal!(tcx, *self, 0)\n     }\n \n     fn assert_ty_matches(&self, val: Disr) {\n@@ -114,7 +120,7 @@ impl IntTypeExt for attr::IntType {\n                            -> Option<Disr> {\n         if let Some(val) = val {\n             self.assert_ty_matches(val);\n-            (val + ConstInt::Infer(1)).ok()\n+            (val + typed_literal!(tcx, *self, 1)).ok()\n         } else {\n             Some(self.initial_discriminant(tcx))\n         }"}, {"sha": "53a7e87292818d773a7af3dfcd859d0b8467adcd", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -221,21 +221,21 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum Constructor {\n+pub enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g. struct patterns and fixed-length arrays.\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(ConstVal),\n+    ConstantValue(ConstVal<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n-    ConstantRange(ConstVal, ConstVal, RangeEnd),\n+    ConstantRange(ConstVal<'tcx>, ConstVal<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n     Slice(usize),\n }\n \n-impl<'tcx> Constructor {\n+impl<'tcx> Constructor<'tcx> {\n     fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> usize {\n         match self {\n             &Variant(vid) => adt.variant_index_with_id(vid),\n@@ -289,7 +289,7 @@ impl<'tcx> Witness<'tcx> {\n     fn push_wild_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a, 'tcx>,\n-        ctor: &Constructor,\n+        ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>)\n         -> Self\n     {\n@@ -321,7 +321,7 @@ impl<'tcx> Witness<'tcx> {\n     fn apply_constructor<'a>(\n         mut self,\n         cx: &MatchCheckCtxt<'a,'tcx>,\n-        ctor: &Constructor,\n+        ctor: &Constructor<'tcx>,\n         ty: Ty<'tcx>)\n         -> Self\n     {\n@@ -399,7 +399,8 @@ impl<'tcx> Witness<'tcx> {\n /// We make sure to omit constructors that are statically impossible. eg for\n /// Option<!> we do not include Some(_) in the returned list of constructors.\n fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                                  pcx: PatternContext<'tcx>) -> Vec<Constructor>\n+                                  pcx: PatternContext<'tcx>)\n+                                  -> Vec<Constructor<'tcx>>\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n     match pcx.ty.sty {\n@@ -664,7 +665,7 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     v: &[&'p Pattern<'tcx>],\n-    ctor: Constructor,\n+    ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n     witness: WitnessPreference) -> Usefulness<'tcx>\n {\n@@ -702,10 +703,10 @@ fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n /// Returns None in case of a catch-all, which can't be specialized.\n-fn pat_constructors(_cx: &mut MatchCheckCtxt,\n-                    pat: &Pattern,\n-                    pcx: PatternContext)\n-                    -> Option<Vec<Constructor>>\n+fn pat_constructors<'tcx>(_cx: &mut MatchCheckCtxt,\n+                          pat: &Pattern<'tcx>,\n+                          pcx: PatternContext)\n+                          -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n         PatternKind::Binding { .. } | PatternKind::Wild =>"}, {"sha": "e2b9f174ff0c200a6e174347d0e85cf5c7239fff", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                               \"statics cannot be referenced in patterns\");\n                 }\n                 PatternError::ConstEval(err) => {\n-                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\").emit();\n+                    report_const_eval_err(self.tcx, &err, pat_span, \"pattern\");\n                 }\n             }\n         }"}, {"sha": "9937cbbf8e10c3929293c99e1cf1bdb7d3d3d4b9", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -576,22 +576,6 @@ integer type:\n https://doc.rust-lang.org/reference.html#ffi-attributes\n \"##,\n \n-\n-E0306: r##\"\n-In an array type `[T; N]`, `N` is the number of elements in the array. This\n-must be an unsigned integer. Erroneous code example:\n-\n-```compile_fail,E0306\n-const X: [i32; true] = [0]; // error: expected `usize` for array length,\n-                            //        found boolean\n-```\n-\n-Working example:\n-\n-```\n-const X: [i32; 1] = [0];\n-```\n-\"##,\n }\n \n "}, {"sha": "284991a11b1b907f00affbd08edd8358096e8552", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 224, "deletions": 469, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -11,7 +11,6 @@\n use rustc::middle::const_val::ConstVal::*;\n use rustc::middle::const_val::ConstVal;\n use self::ErrKind::*;\n-use self::EvalHint::*;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -20,15 +19,14 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::subst::Substs;\n+use rustc::ty::subst::{Substs, Subst};\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::DefIdMap;\n \n use graphviz::IntoCow;\n use syntax::ast;\n use rustc::hir::{self, Expr};\n-use syntax::attr::IntType;\n use syntax_pos::Span;\n \n use std::borrow::Cow;\n@@ -37,18 +35,24 @@ use std::cmp::Ordering;\n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n \n+macro_rules! signal {\n+    ($e:expr, $exn:expr) => {\n+        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n+    }\n+}\n+\n macro_rules! math {\n     ($e:expr, $op:expr) => {\n         match $op {\n             Ok(val) => val,\n-            Err(e) => signal!($e, Math(e)),\n+            Err(e) => signal!($e, ErrKind::from(e)),\n         }\n     }\n }\n \n fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                   variant_def: DefId)\n-                                  -> Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>)> {\n+                                  -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)> {\n     if let Some(variant_node_id) = tcx.hir.as_local_node_id(variant_def) {\n         let enum_node_id = tcx.hir.get_parent(variant_node_id);\n         if let Some(hir_map::NodeItem(it)) = tcx.hir.find(enum_node_id) {\n@@ -58,7 +62,7 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         return variant.node.disr_expr.map(|e| {\n                             let def_id = tcx.hir.body_owner_def_id(e);\n                             (&tcx.hir.body(e).value,\n-                             tcx.maps.typeck_tables.borrow().get(&def_id).cloned())\n+                             tcx.item_tables(def_id))\n                         });\n                     }\n                 }\n@@ -75,55 +79,41 @@ fn lookup_variant_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// This generally happens in late/trans const evaluation.\n pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n-                                        substs: Option<&'tcx Substs<'tcx>>)\n+                                        substs: &'tcx Substs<'tcx>)\n                                         -> Option<(&'tcx Expr,\n-                                                   Option<&'a ty::TypeckTables<'tcx>>,\n-                                                   Option<ty::Ty<'tcx>>)> {\n+                                                   &'a ty::TypeckTables<'tcx>)> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         match tcx.hir.find(node_id) {\n             None => None,\n             Some(hir_map::NodeItem(&hir::Item {\n-                node: hir::ItemConst(ref ty, body), ..\n+                node: hir::ItemConst(_, body), ..\n             })) |\n             Some(hir_map::NodeImplItem(&hir::ImplItem {\n-                node: hir::ImplItemKind::Const(ref ty, body), ..\n+                node: hir::ImplItemKind::Const(_, body), ..\n             })) => {\n                 Some((&tcx.hir.body(body).value,\n-                      tcx.maps.typeck_tables.borrow().get(&def_id).cloned(),\n-                      tcx.ast_ty_to_prim_ty(ty)))\n+                      tcx.item_tables(def_id)))\n             }\n             Some(hir_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::TraitItemKind::Const(ref ty, default) => {\n-                    if let Some(substs) = substs {\n-                        // If we have a trait item and the substitutions for it,\n-                        // `resolve_trait_associated_const` will select an impl\n-                        // or the default.\n-                        let trait_id = tcx.hir.get_parent(node_id);\n-                        let trait_id = tcx.hir.local_def_id(trait_id);\n-                        let default_value = default.map(|body| {\n-                            (&tcx.hir.body(body).value,\n-                             tcx.maps.typeck_tables.borrow().get(&def_id).cloned(),\n-                             tcx.ast_ty_to_prim_ty(ty))\n-                        });\n-                        resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n-                    } else {\n-                        // Technically, without knowing anything about the\n-                        // expression that generates the obligation, we could\n-                        // still return the default if there is one. However,\n-                        // it's safer to return `None` than to return some value\n-                        // that may differ from what you would get from\n-                        // correctly selecting an impl.\n-                        None\n-                    }\n+                hir::TraitItemKind::Const(_, default) => {\n+                    // If we have a trait item and the substitutions for it,\n+                    // `resolve_trait_associated_const` will select an impl\n+                    // or the default.\n+                    let trait_id = tcx.hir.get_parent(node_id);\n+                    let trait_id = tcx.hir.local_def_id(trait_id);\n+                    let default_value = default.map(|body| {\n+                        (&tcx.hir.body(body).value,\n+                            tcx.item_tables(def_id))\n+                    });\n+                    resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n                 }\n                 _ => None\n             },\n             Some(_) => None\n         }\n     } else {\n-        let expr_tables_ty = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-            (&body.value, Some(tcx.item_tables(def_id)),\n-             Some(tcx.item_type(def_id)))\n+        let expr_and_tables = tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n+            (&body.value, tcx.item_tables(def_id))\n         });\n         match tcx.sess.cstore.describe_def(def_id) {\n             Some(Def::AssociatedConst(_)) => {\n@@ -133,46 +123,42 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // trait-associated const if the caller gives us the\n                 // substitutions for the reference to it.\n                 if let Some(trait_id) = trait_id {\n-                    if let Some(substs) = substs {\n-                        resolve_trait_associated_const(tcx, def_id, expr_tables_ty,\n-                                                       trait_id, substs)\n-                    } else {\n-                        None\n-                    }\n+                    resolve_trait_associated_const(tcx, def_id, expr_and_tables,\n+                                                   trait_id, substs)\n                 } else {\n-                    expr_tables_ty\n+                    expr_and_tables\n                 }\n             },\n-            Some(Def::Const(..)) => expr_tables_ty,\n+            Some(Def::Const(..)) => expr_and_tables,\n             _ => None\n         }\n     }\n }\n \n fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                   -> Option<(&'tcx hir::Body, Option<&'a ty::TypeckTables<'tcx>>)>\n+                                   -> Option<(&'tcx hir::Body, &'a ty::TypeckTables<'tcx>)>\n {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         FnLikeNode::from_node(tcx.hir.get(node_id)).and_then(|fn_like| {\n             if fn_like.constness() == hir::Constness::Const {\n                 Some((tcx.hir.body(fn_like.body()),\n-                      tcx.maps.typeck_tables.borrow().get(&def_id).cloned()))\n+                      tcx.item_tables(def_id)))\n             } else {\n                 None\n             }\n         })\n     } else {\n         if tcx.sess.cstore.is_const_fn(def_id) {\n             tcx.sess.cstore.maybe_get_item_body(tcx, def_id).map(|body| {\n-                (body, Some(tcx.item_tables(def_id)))\n+                (body, tcx.item_tables(def_id))\n             })\n         } else {\n             None\n         }\n     }\n }\n \n-pub fn report_const_eval_err<'a, 'tcx>(\n+fn build_const_eval_err<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err: &ConstEvalErr,\n     primary_span: Span,\n@@ -189,14 +175,26 @@ pub fn report_const_eval_err<'a, 'tcx>(\n     diag\n }\n \n+pub fn report_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+{\n+    if let TypeckError = err.kind {\n+        return;\n+    }\n+    build_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+}\n+\n pub fn fatal_const_eval_err<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err: &ConstEvalErr,\n     primary_span: Span,\n     primary_kind: &str)\n     -> !\n {\n-    report_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+    report_const_eval_err(tcx, err, primary_span, primary_kind);\n     tcx.sess.abort_if_errors();\n     unreachable!()\n }\n@@ -222,88 +220,75 @@ pub fn note_const_eval_err<'a, 'tcx>(\n \n pub struct ConstContext<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: Option<&'a ty::TypeckTables<'tcx>>,\n-    fn_args: Option<DefIdMap<ConstVal>>\n+    tables: &'a ty::TypeckTables<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n+    fn_args: Option<DefIdMap<ConstVal<'tcx>>>\n }\n \n impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, body: hir::BodyId) -> Self {\n         let def_id = tcx.hir.body_owner_def_id(body);\n-        ConstContext {\n-            tcx: tcx,\n-            tables: tcx.maps.typeck_tables.borrow().get(&def_id).cloned(),\n-            fn_args: None\n-        }\n+        ConstContext::with_tables(tcx, tcx.item_tables(def_id))\n     }\n \n     pub fn with_tables(tcx: TyCtxt<'a, 'tcx, 'tcx>, tables: &'a ty::TypeckTables<'tcx>) -> Self {\n         ConstContext {\n             tcx: tcx,\n-            tables: Some(tables),\n+            tables: tables,\n+            substs: tcx.intern_substs(&[]),\n             fn_args: None\n         }\n     }\n \n     /// Evaluate a constant expression in a context where the expression isn't\n-    /// guaranteed to be evaluatable. `ty_hint` is usually ExprTypeChecked,\n-    /// but a few places need to evaluate constants during type-checking, like\n-    /// computing the length of an array. (See also the FIXME above EvalHint.)\n-    pub fn eval(&self, e: &Expr, ty_hint: EvalHint<'tcx>) -> EvalResult {\n-        eval_const_expr_partial(self, e, ty_hint)\n+    /// guaranteed to be evaluatable.\n+    pub fn eval(&self, e: &Expr) -> EvalResult<'tcx> {\n+        if self.tables.tainted_by_errors {\n+            signal!(e, TypeckError);\n+        }\n+        eval_const_expr_partial(self, e)\n     }\n }\n \n #[derive(Clone, Debug)]\n-pub struct ConstEvalErr {\n+pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub kind: ErrKind,\n+    pub kind: ErrKind<'tcx>,\n }\n \n #[derive(Clone, Debug)]\n-pub enum ErrKind {\n+pub enum ErrKind<'tcx> {\n     CannotCast,\n-    CannotCastTo(&'static str),\n-    InvalidOpForInts(hir::BinOp_),\n-    InvalidOpForBools(hir::BinOp_),\n-    InvalidOpForFloats(hir::BinOp_),\n-    InvalidOpForIntUint(hir::BinOp_),\n-    InvalidOpForUintInt(hir::BinOp_),\n-    NegateOn(ConstVal),\n-    NotOn(ConstVal),\n-    CallOn(ConstVal),\n-\n     MissingStructField,\n+    NegateOn(ConstVal<'tcx>),\n+    NotOn(ConstVal<'tcx>),\n+    CallOn(ConstVal<'tcx>),\n+\n     NonConstPath,\n     UnimplementedConstVal(&'static str),\n-    UnresolvedPath,\n     ExpectedConstTuple,\n     ExpectedConstStruct,\n-    TupleIndexOutOfBounds,\n     IndexedNonVec,\n-    IndexNegative,\n-    IndexNotInt,\n+    IndexNotUsize,\n     IndexOutOfBounds { len: u64, index: u64 },\n-    RepeatCountNotNatural,\n-    RepeatCountNotInt,\n \n     MiscBinaryOp,\n     MiscCatchAll,\n \n     IndexOpFeatureGated,\n     Math(ConstMathErr),\n \n-    IntermediateUnsignedNegative,\n-    /// Expected, Got\n-    TypeMismatch(String, ConstInt),\n+    ErroneousReferencedConstant(Box<ConstEvalErr<'tcx>>),\n \n-    BadType(ConstVal),\n-    ErroneousReferencedConstant(Box<ConstEvalErr>),\n-    CharCast(ConstInt),\n+    TypeckError\n }\n \n-impl From<ConstMathErr> for ErrKind {\n-    fn from(err: ConstMathErr) -> ErrKind {\n-        Math(err)\n+impl<'tcx> From<ConstMathErr> for ErrKind<'tcx> {\n+    fn from(err: ConstMathErr) -> ErrKind<'tcx> {\n+        match err {\n+            ConstMathErr::UnsignedNegation => TypeckError,\n+            _ => Math(err)\n+        }\n     }\n }\n \n@@ -321,7 +306,7 @@ impl<'a> ConstEvalErrDescription<'a> {\n     }\n }\n \n-impl ConstEvalErr {\n+impl<'tcx> ConstEvalErr<'tcx> {\n     pub fn description(&self) -> ConstEvalErrDescription {\n         use self::ErrKind::*;\n         use self::ConstEvalErrDescription::*;\n@@ -335,12 +320,6 @@ impl ConstEvalErr {\n \n         match self.kind {\n             CannotCast => simple!(\"can't cast this type\"),\n-            CannotCastTo(s) => simple!(\"can't cast this type to {}\", s),\n-            InvalidOpForInts(_) =>  simple!(\"can't do this op on integrals\"),\n-            InvalidOpForBools(_) =>  simple!(\"can't do this op on bools\"),\n-            InvalidOpForFloats(_) => simple!(\"can't do this op on floats\"),\n-            InvalidOpForIntUint(..) => simple!(\"can't do this op on an isize and usize\"),\n-            InvalidOpForUintInt(..) => simple!(\"can't do this op on a usize and isize\"),\n             NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n             NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n             CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n@@ -349,111 +328,42 @@ impl ConstEvalErr {\n             NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n                 simple!(\"unimplemented constant expression: {}\", what),\n-            UnresolvedPath => simple!(\"unresolved path in constant expression\"),\n             ExpectedConstTuple => simple!(\"expected constant tuple\"),\n             ExpectedConstStruct => simple!(\"expected constant struct\"),\n-            TupleIndexOutOfBounds => simple!(\"tuple index out of bounds\"),\n             IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n-            IndexNegative => simple!(\"indices must be non-negative integers\"),\n-            IndexNotInt => simple!(\"indices must be integers\"),\n+            IndexNotUsize => simple!(\"indices must be of type `usize`\"),\n             IndexOutOfBounds { len, index } => {\n                 simple!(\"index out of bounds: the len is {} but the index is {}\",\n                         len, index)\n             }\n-            RepeatCountNotNatural => simple!(\"repeat count must be a natural number\"),\n-            RepeatCountNotInt => simple!(\"repeat count must be integers\"),\n \n             MiscBinaryOp => simple!(\"bad operands for binary\"),\n             MiscCatchAll => simple!(\"unsupported constant expr\"),\n             IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n             Math(ref err) => Simple(err.description().into_cow()),\n \n-            IntermediateUnsignedNegative => simple!(\n-                \"during the computation of an unsigned a negative \\\n-                 number was encountered. This is most likely a bug in\\\n-                 the constant evaluator\"),\n-\n-            TypeMismatch(ref expected, ref got) => {\n-                simple!(\"expected {}, found {}\", expected, got.description())\n-            },\n-            BadType(ref i) => simple!(\"value of wrong type: {:?}\", i),\n             ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n-            CharCast(ref got) => {\n-                simple!(\"only `u8` can be cast as `char`, not `{}`\", got.description())\n-            },\n-        }\n-    }\n-}\n-\n-pub type EvalResult = Result<ConstVal, ConstEvalErr>;\n-pub type CastResult = Result<ConstVal, ErrKind>;\n-\n-// FIXME: Long-term, this enum should go away: trying to evaluate\n-// an expression which hasn't been type-checked is a recipe for\n-// disaster.  That said, it's not clear how to fix ast_ty_to_ty\n-// to avoid the ordering issue.\n-\n-/// Hint to determine how to evaluate constant expressions which\n-/// might not be type-checked.\n-#[derive(Copy, Clone, Debug)]\n-pub enum EvalHint<'tcx> {\n-    /// We have a type-checked expression.\n-    ExprTypeChecked,\n-    /// We have an expression which hasn't been type-checked, but we have\n-    /// an idea of what the type will be because of the context. For example,\n-    /// the length of an array is always `usize`. (This is referred to as\n-    /// a hint because it isn't guaranteed to be consistent with what\n-    /// type-checking would compute.)\n-    UncheckedExprHint(Ty<'tcx>),\n-    /// We have an expression which has not yet been type-checked, and\n-    /// and we have no clue what the type will be.\n-    UncheckedExprNoHint,\n-}\n \n-impl<'tcx> EvalHint<'tcx> {\n-    fn erase_hint(&self) -> EvalHint<'tcx> {\n-        match *self {\n-            ExprTypeChecked => ExprTypeChecked,\n-            UncheckedExprHint(_) | UncheckedExprNoHint => UncheckedExprNoHint,\n-        }\n-    }\n-    fn checked_or(&self, ty: Ty<'tcx>) -> EvalHint<'tcx> {\n-        match *self {\n-            ExprTypeChecked => ExprTypeChecked,\n-            _ => UncheckedExprHint(ty),\n+            TypeckError => simple!(\"type-checking failed\"),\n         }\n     }\n }\n \n-macro_rules! signal {\n-    ($e:expr, $exn:expr) => {\n-        return Err(ConstEvalErr { span: $e.span, kind: $exn })\n-    }\n-}\n+pub type EvalResult<'tcx> = Result<ConstVal<'tcx>, ConstEvalErr<'tcx>>;\n+pub type CastResult<'tcx> = Result<ConstVal<'tcx>, ErrKind<'tcx>>;\n \n fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n-                                     e: &Expr,\n-                                     ty_hint: EvalHint<'tcx>) -> EvalResult {\n+                                     e: &Expr) -> EvalResult<'tcx> {\n     let tcx = cx.tcx;\n-    // Try to compute the type of the expression based on the EvalHint.\n-    // (See also the definition of EvalHint, and the FIXME above EvalHint.)\n-    let ety = match ty_hint {\n-        ExprTypeChecked => {\n-            // After type-checking, expr_ty is guaranteed to succeed.\n-            cx.tables.map(|tables| tables.expr_ty(e))\n-        }\n-        UncheckedExprHint(ty) => {\n-            // Use the type hint; it's not guaranteed to be right, but it's\n-            // usually good enough.\n-            Some(ty)\n-        }\n-        UncheckedExprNoHint => {\n-            // This expression might not be type-checked, and we have no hint.\n-            // Try to query the context for a type anyway; we might get lucky\n-            // (for example, if the expression was imported from another crate).\n-            cx.tables.and_then(|tables| tables.expr_ty_opt(e))\n-        }\n+    let ety = cx.tables.expr_ty(e);\n+\n+    // Avoid applying substitutions if they're empty, that'd ICE.\n+    let ety = if cx.substs.is_empty() {\n+        ety\n+    } else {\n+        ety.subst(tcx, cx.substs)\n     };\n+\n     let result = match e.node {\n       hir::ExprUnary(hir::UnNeg, ref inner) => {\n         // unary neg literals already got their sign during creation\n@@ -465,28 +375,28 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             const I32_OVERFLOW: u128 = i32::min_value() as u32 as u128;\n             const I64_OVERFLOW: u128 = i64::min_value() as u64 as u128;\n             const I128_OVERFLOW: u128 = i128::min_value() as u128;\n-            match (&lit.node, ety.map(|t| &t.sty)) {\n-                (&LitKind::Int(I8_OVERFLOW, _), Some(&ty::TyInt(IntTy::I8))) |\n+            match (&lit.node, &ety.sty) {\n+                (&LitKind::Int(I8_OVERFLOW, _), &ty::TyInt(IntTy::I8)) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n                     return Ok(Integral(I8(i8::min_value())))\n                 },\n-                (&LitKind::Int(I16_OVERFLOW, _), Some(&ty::TyInt(IntTy::I16))) |\n+                (&LitKind::Int(I16_OVERFLOW, _), &ty::TyInt(IntTy::I16)) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n                     return Ok(Integral(I16(i16::min_value())))\n                 },\n-                (&LitKind::Int(I32_OVERFLOW, _), Some(&ty::TyInt(IntTy::I32))) |\n+                (&LitKind::Int(I32_OVERFLOW, _), &ty::TyInt(IntTy::I32)) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n                     return Ok(Integral(I32(i32::min_value())))\n                 },\n-                (&LitKind::Int(I64_OVERFLOW, _), Some(&ty::TyInt(IntTy::I64))) |\n+                (&LitKind::Int(I64_OVERFLOW, _), &ty::TyInt(IntTy::I64)) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n                     return Ok(Integral(I64(i64::min_value())))\n                 },\n-                (&LitKind::Int(I128_OVERFLOW, _), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(I128_OVERFLOW, _), &ty::TyInt(IntTy::I128)) |\n                 (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n                     return Ok(Integral(I128(i128::min_value())))\n                 },\n-                (&LitKind::Int(n, _), Some(&ty::TyInt(IntTy::Is))) |\n+                (&LitKind::Int(n, _), &ty::TyInt(IntTy::Is)) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n@@ -498,37 +408,32 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                         IntTy::I64 => if n == I64_OVERFLOW {\n                             return Ok(Integral(Isize(Is64(i64::min_value()))));\n                         },\n-                        _ => bug!(),\n+                        _ => span_bug!(e.span, \"typeck error\")\n                     }\n                 },\n                 _ => {},\n             }\n         }\n-        match cx.eval(inner, ty_hint)? {\n+        match cx.eval(inner)? {\n           Float(f) => Float(-f),\n           Integral(i) => Integral(math!(e, -i)),\n           const_val => signal!(e, NegateOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnNot, ref inner) => {\n-        match cx.eval(inner, ty_hint)? {\n+        match cx.eval(inner)? {\n           Integral(i) => Integral(math!(e, !i)),\n           Bool(b) => Bool(!b),\n           const_val => signal!(e, NotOn(const_val)),\n         }\n       }\n       hir::ExprUnary(hir::UnDeref, _) => signal!(e, UnimplementedConstVal(\"deref operation\")),\n       hir::ExprBinary(op, ref a, ref b) => {\n-        let b_ty = match op.node {\n-            hir::BiShl | hir::BiShr => ty_hint.erase_hint(),\n-            _ => ty_hint\n-        };\n         // technically, if we don't have type hints, but integral eval\n         // gives us a type through a type-suffix, cast or const def type\n         // we need to re-eval the other value of the BinOp if it was\n         // not inferred\n-        match (cx.eval(a, ty_hint)?,\n-               cx.eval(b, b_ty)?) {\n+        match (cx.eval(a)?, cx.eval(b)?) {\n           (Float(a), Float(b)) => {\n             use std::cmp::Ordering::*;\n             match op.node {\n@@ -543,7 +448,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n               hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n               hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => signal!(e, InvalidOpForFloats(op.node)),\n+              _ => span_bug!(e.span, \"typeck error\"),\n             }\n           }\n           (Integral(a), Integral(b)) => {\n@@ -565,7 +470,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n               hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n               hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n-              _ => signal!(e, InvalidOpForInts(op.node)),\n+              _ => span_bug!(e.span, \"typeck error\"),\n             }\n           }\n           (Bool(a), Bool(b)) => {\n@@ -581,90 +486,57 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n               hir::BiLe => a <= b,\n               hir::BiGe => a >= b,\n               hir::BiGt => a > b,\n-              _ => signal!(e, InvalidOpForBools(op.node)),\n+              _ => span_bug!(e.span, \"typeck error\"),\n              })\n           }\n \n           _ => signal!(e, MiscBinaryOp),\n         }\n       }\n-      hir::ExprCast(ref base, ref target_ty) => {\n-        let ety = tcx.ast_ty_to_prim_ty(&target_ty).or(ety)\n-                .unwrap_or_else(|| {\n-                    tcx.sess.span_fatal(target_ty.span,\n-                                        \"target type not found for const cast\")\n-                });\n-\n-        let base_hint = if let ExprTypeChecked = ty_hint {\n-            ExprTypeChecked\n-        } else {\n-            match cx.tables.and_then(|tables| tables.expr_ty_opt(&base)) {\n-                Some(t) => UncheckedExprHint(t),\n-                None => ty_hint\n-            }\n-        };\n-\n-        let val = match cx.eval(base, base_hint) {\n-            Ok(val) => val,\n-            Err(ConstEvalErr { kind: ErroneousReferencedConstant(\n-                box ConstEvalErr { kind: TypeMismatch(_, val), .. }), .. }) |\n-            Err(ConstEvalErr { kind: TypeMismatch(_, val), .. }) => {\n-                // Something like `5i8 as usize` doesn't need a type hint for the base\n-                // instead take the type hint from the inner value\n-                let hint = match val.int_type() {\n-                    Some(IntType::UnsignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_uint(ty)),\n-                    Some(IntType::SignedInt(ty)) => ty_hint.checked_or(tcx.mk_mach_int(ty)),\n-                    // we had a type hint, so we can't have an unknown type\n-                    None => bug!(),\n-                };\n-                cx.eval(base, hint)?\n-            },\n-            Err(e) => return Err(e),\n-        };\n-        match cast_const(tcx, val, ety) {\n+      hir::ExprCast(ref base, _) => {\n+        match cast_const(tcx, cx.eval(base)?, ety) {\n             Ok(val) => val,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-          let def = cx.tables.map(|tables| tables.qpath_def(qpath, e.id)).unwrap_or_else(|| {\n-            // There are no tables so we can only handle already-resolved HIR.\n-            match *qpath {\n-                hir::QPath::Resolved(_, ref path) => path.def,\n-                hir::QPath::TypeRelative(..) => Def::Err\n-            }\n-          });\n-          match def {\n+        let substs = cx.tables.node_id_item_substs(e.id)\n+            .unwrap_or_else(|| tcx.intern_substs(&[]));\n+\n+        // Avoid applying substitutions if they're empty, that'd ICE.\n+        let substs = if cx.substs.is_empty() {\n+            substs\n+        } else {\n+            substs.subst(tcx, cx.substs)\n+        };\n+\n+          match cx.tables.qpath_def(qpath, e.id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n-                  let substs = if let ExprTypeChecked = ty_hint {\n-                      Some(cx.tables.and_then(|tables| tables.node_id_item_substs(e.id))\n-                        .unwrap_or_else(|| tcx.intern_substs(&[])))\n-                  } else {\n-                      None\n-                  };\n-                  if let Some((expr, tables, ty)) = lookup_const_by_id(tcx, def_id, substs) {\n-                      let item_hint = match ty {\n-                          Some(ty) => ty_hint.checked_or(ty),\n-                          None => ty_hint,\n-                      };\n-                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n-                      match cx.eval(expr, item_hint) {\n+                  if let Some((expr, tables)) = lookup_const_by_id(tcx, def_id, substs) {\n+                      let cx = ConstContext::with_tables(tcx, tables);\n+                      match cx.eval(expr) {\n                           Ok(val) => val,\n+                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                              signal!(e, TypeckError);\n+                          }\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n                               signal!(e, ErroneousReferencedConstant(box err))\n                           },\n                       }\n                   } else {\n-                      signal!(e, NonConstPath);\n+                      signal!(e, TypeckError);\n                   }\n               },\n               Def::VariantCtor(variant_def, ..) => {\n                   if let Some((expr, tables)) = lookup_variant_by_id(tcx, variant_def) {\n-                      let cx = ConstContext { tcx: tcx, tables: tables, fn_args: None };\n-                      match cx.eval(expr, ty_hint) {\n+                      let cx = ConstContext::with_tables(tcx, tables);\n+                      match cx.eval(expr) {\n                           Ok(val) => val,\n+                          Err(ConstEvalErr { kind: TypeckError, .. }) => {\n+                              signal!(e, TypeckError);\n+                          }\n                           Err(err) => {\n                               debug!(\"bad reference: {:?}, {:?}\", err.description(), err.span);\n                               signal!(e, ErroneousReferencedConstant(box err))\n@@ -685,16 +557,14 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n                       signal!(e, NonConstPath);\n                   }\n               },\n-              Def::Method(id) | Def::Fn(id) => Function(id),\n-              Def::Err => signal!(e, UnresolvedPath),\n+              Def::Method(id) | Def::Fn(id) => Function(id, substs),\n+              Def::Err => span_bug!(e.span, \"typeck error\"),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n-          let sub_ty_hint = ty_hint.erase_hint();\n-          let callee_val = cx.eval(callee, sub_ty_hint)?;\n-          let did = match callee_val {\n-              Function(did) => did,\n+          let (did, substs) = match cx.eval(callee)? {\n+              Function(did, substs) => (did, substs),\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n@@ -711,8 +581,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n \n           let mut call_args = DefIdMap();\n           for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n-              let arg_hint = ty_hint.erase_hint();\n-              let arg_val = cx.eval(arg_expr, arg_hint)?;\n+              let arg_val = cx.eval(arg_expr)?;\n               debug!(\"const call arg: {:?}\", arg);\n               if let Some(def_id) = arg {\n                 assert!(call_args.insert(def_id, arg_val).is_none());\n@@ -722,42 +591,38 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n           let callee_cx = ConstContext {\n             tcx: tcx,\n             tables: tables,\n+            substs: substs,\n             fn_args: Some(call_args)\n           };\n-          callee_cx.eval(&body.value, ty_hint)?\n+          callee_cx.eval(&body.value)?\n       },\n       hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety) {\n           Ok(val) => val,\n           Err(err) => signal!(e, err),\n       },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n-            Some(ref expr) => cx.eval(expr, ty_hint)?,\n-            None => signal!(e, UnimplementedConstVal(\"empty block\")),\n+            Some(ref expr) => cx.eval(expr)?,\n+            None => Tuple(vec![]),\n         }\n       }\n-      hir::ExprType(ref e, _) => cx.eval(e, ty_hint)?,\n+      hir::ExprType(ref e, _) => cx.eval(e)?,\n       hir::ExprTup(ref fields) => {\n-        let field_hint = ty_hint.erase_hint();\n-        Tuple(fields.iter().map(|e| cx.eval(e, field_hint)).collect::<Result<_, _>>()?)\n+        Tuple(fields.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n       }\n       hir::ExprStruct(_, ref fields, _) => {\n-        let field_hint = ty_hint.erase_hint();\n         Struct(fields.iter().map(|f| {\n-            cx.eval(&f.expr, field_hint).map(|v| (f.name.node, v))\n+            cx.eval(&f.expr).map(|v| (f.name.node, v))\n         }).collect::<Result<_, _>>()?)\n       }\n       hir::ExprIndex(ref arr, ref idx) => {\n         if !tcx.sess.features.borrow().const_indexing {\n             signal!(e, IndexOpFeatureGated);\n         }\n-        let arr_hint = ty_hint.erase_hint();\n-        let arr = cx.eval(arr, arr_hint)?;\n-        let idx_hint = ty_hint.checked_or(tcx.types.usize);\n-        let idx = match cx.eval(idx, idx_hint)? {\n+        let arr = cx.eval(arr)?;\n+        let idx = match cx.eval(idx)? {\n             Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-            Integral(_) => bug!(),\n-            _ => signal!(idx, IndexNotInt),\n+            _ => signal!(idx, IndexNotUsize),\n         };\n         assert_eq!(idx as usize as u64, idx);\n         match arr {\n@@ -787,45 +652,25 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprArray(ref v) => {\n-        let elem_hint = ty_hint.erase_hint();\n-        Array(v.iter().map(|e| cx.eval(e, elem_hint)).collect::<Result<_, _>>()?)\n+        Array(v.iter().map(|e| cx.eval(e)).collect::<Result<_, _>>()?)\n       }\n-      hir::ExprRepeat(ref elem, count) => {\n-          let elem_hint = ty_hint.erase_hint();\n-          let len_hint = ty_hint.checked_or(tcx.types.usize);\n-          let n = if let Some(ty) = ety {\n-            // For cross-crate constants, we have the type already,\n-            // but not the body for `count`, so use the type.\n-            match ty.sty {\n-                ty::TyArray(_, n) => n as u64,\n-                _ => bug!()\n-            }\n-          } else {\n-            let n = &tcx.hir.body(count).value;\n-            match ConstContext::new(tcx, count).eval(n, len_hint)? {\n-                Integral(Usize(i)) => i.as_u64(tcx.sess.target.uint_type),\n-                Integral(_) => signal!(e, RepeatCountNotNatural),\n-                _ => signal!(e, RepeatCountNotInt),\n-            }\n+      hir::ExprRepeat(ref elem, _) => {\n+          let n = match ety.sty {\n+            ty::TyArray(_, n) => n as u64,\n+            _ => span_bug!(e.span, \"typeck error\")\n           };\n-          Repeat(Box::new(cx.eval(elem, elem_hint)?), n)\n+          Repeat(Box::new(cx.eval(elem)?), n)\n       },\n       hir::ExprTupField(ref base, index) => {\n-        let base_hint = ty_hint.erase_hint();\n-        let c = cx.eval(base, base_hint)?;\n+        let c = cx.eval(base)?;\n         if let Tuple(ref fields) = c {\n-            if let Some(elem) = fields.get(index.node) {\n-                elem.clone()\n-            } else {\n-                signal!(e, TupleIndexOutOfBounds);\n-            }\n+            fields[index.node].clone()\n         } else {\n             signal!(base, ExpectedConstTuple);\n         }\n       }\n       hir::ExprField(ref base, field_name) => {\n-        let base_hint = ty_hint.erase_hint();\n-        let c = cx.eval(base, base_hint)?;\n+        let c = cx.eval(base)?;\n         if let Struct(ref fields) = c {\n             if let Some(f) = fields.get(&field_name.node) {\n                 f.clone()\n@@ -840,82 +685,16 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n       _ => signal!(e, MiscCatchAll)\n     };\n \n-    match (ety.map(|t| &t.sty), result) {\n-        (Some(ref ty_hint), Integral(i)) => match infer(i, tcx, ty_hint) {\n-            Ok(inferred) => Ok(Integral(inferred)),\n-            Err(err) => signal!(e, err),\n-        },\n-        (_, result) => Ok(result),\n-    }\n-}\n-\n-fn infer<'a, 'tcx>(i: ConstInt,\n-                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                   ty_hint: &ty::TypeVariants<'tcx>)\n-                   -> Result<ConstInt, ErrKind> {\n-    use syntax::ast::*;\n-\n-    match (ty_hint, i) {\n-        (&ty::TyInt(IntTy::I8), result @ I8(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I32), result @ I32(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I64), result @ I64(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::I128), result @ I128(_)) => Ok(result),\n-        (&ty::TyInt(IntTy::Is), result @ Isize(_)) => Ok(result),\n-\n-        (&ty::TyUint(UintTy::U8), result @ U8(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U16), result @ U16(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U32), result @ U32(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::U128), result @ U128(_)) => Ok(result),\n-        (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n-\n-        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i128 as i8)),\n-        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i128 as i16)),\n-        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i128 as i32)),\n-        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i128 as i64)),\n-        (&ty::TyInt(IntTy::I128), Infer(i)) => Ok(I128(i as i128)),\n-        (&ty::TyInt(IntTy::Is), Infer(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i as i128, tcx.sess.target.int_type)))\n-        },\n-\n-        (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n-        (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n-        (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n-        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i as i64)),\n-        (&ty::TyInt(IntTy::I128), InferSigned(i)) => Ok(I128(i)),\n-        (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i, tcx.sess.target.int_type)))\n-        },\n-\n-        (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n-        (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n-        (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n-        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i as u64)),\n-        (&ty::TyUint(UintTy::U128), Infer(i)) => Ok(U128(i)),\n-        (&ty::TyUint(UintTy::Us), Infer(i)) => {\n-            Ok(Usize(ConstUsize::new_truncating(i, tcx.sess.target.uint_type)))\n-        },\n-        (&ty::TyUint(_), InferSigned(_)) => Err(IntermediateUnsignedNegative),\n-\n-        (&ty::TyInt(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n-        (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n-\n-        (&ty::TyAdt(adt, _), i) if adt.is_enum() => {\n-            let int_ty = adt.repr.discr_type();\n-            infer(i, tcx, &int_ty.to_ty(tcx).sty)\n-        },\n-        (_, i) => Err(BadType(ConstVal::Integral(i))),\n-    }\n+    Ok(result)\n }\n \n fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     trait_item_id: DefId,\n-    default_value: Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>, Option<ty::Ty<'tcx>>)>,\n+    default_value: Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>,\n     trait_id: DefId,\n     rcvr_substs: &'tcx Substs<'tcx>\n-) -> Option<(&'tcx Expr, Option<&'a ty::TypeckTables<'tcx>>, Option<ty::Ty<'tcx>>)>\n+) -> Option<(&'tcx Expr, &'a ty::TypeckTables<'tcx>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n@@ -950,7 +729,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n                     .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n-                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n+                    Some(ic) => lookup_const_by_id(tcx, ic.def_id, Substs::empty()),\n                     None => default_value,\n                 }\n             }\n@@ -961,7 +740,10 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n     })\n }\n \n-fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n+fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                            val: ConstInt,\n+                            ty: Ty<'tcx>)\n+                            -> CastResult<'tcx> {\n     let v = val.to_u128_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n@@ -982,66 +764,58 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => match val.erase_type() {\n-            Infer(u) => Ok(Float(F64(u as f64))),\n-            InferSigned(i) => Ok(Float(F64(i as f64))),\n-            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n-        },\n-        ty::TyFloat(ast::FloatTy::F32) => match val.erase_type() {\n-            Infer(u) => Ok(Float(F32(u as f32))),\n-            InferSigned(i) => Ok(Float(F32(i as f32))),\n-            _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n-        },\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(val.to_f64()))),\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(val.to_f32()))),\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n-        ty::TyChar => match infer(val, tcx, &ty::TyUint(ast::UintTy::U8)) {\n-            Ok(U8(u)) => Ok(Char(u as char)),\n-            // can only occur before typeck, typeck blocks `T as char` for `T` != `u8`\n-            _ => Err(CharCast(val)),\n+        ty::TyChar => match val {\n+            U8(u) => Ok(Char(u as char)),\n+            _ => bug!(),\n         },\n-        _ => Err(CannotCast),\n+        _ => bug!(),\n     }\n }\n \n fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               val: ConstFloat,\n-                              ty: ty::Ty) -> CastResult {\n+                              ty: Ty<'tcx>) -> CastResult<'tcx> {\n     match ty.sty {\n         ty::TyInt(_) | ty::TyUint(_) => {\n             let i = match val {\n-                F32(f) if f >= 0.0 => Infer(f as u128),\n-                FInfer { f64: f, .. } |\n-                F64(f) if f >= 0.0 => Infer(f as u128),\n+                F32(f) if f >= 0.0 => U128(f as u128),\n+                F64(f) if f >= 0.0 => U128(f as u128),\n \n-                F32(f) => InferSigned(f as i128),\n-                FInfer { f64: f, .. } |\n-                F64(f) => InferSigned(f as i128)\n+                F32(f) => I128(f as i128),\n+                F64(f) => I128(f as i128)\n             };\n \n-            if let (InferSigned(_), &ty::TyUint(_)) = (i, &ty.sty) {\n+            if let (I128(_), &ty::TyUint(_)) = (i, &ty.sty) {\n                 return Err(CannotCast);\n             }\n \n             cast_const_int(tcx, i, ty)\n         }\n         ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(match val {\n             F32(f) => f as f64,\n-            FInfer { f64: f, .. } | F64(f) => f\n+            F64(f) => f\n         }))),\n         ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(match val {\n             F64(f) => f as f32,\n-            FInfer { f32: f, .. } | F32(f) => f\n+            F32(f) => f\n         }))),\n         _ => Err(CannotCast),\n     }\n }\n \n-fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n+fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                        val: ConstVal<'tcx>,\n+                        ty: Ty<'tcx>)\n+                        -> CastResult<'tcx> {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, Infer(b as u128), ty),\n+        Bool(b) => cast_const_int(tcx, U8(b as u8), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, Infer(c as u128), ty),\n-        Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n+        Char(c) => cast_const_int(tcx, U32(c as u32), ty),\n+        Function(..) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n                 Err(ErrKind::UnimplementedConstVal(\"casting a bytestr to a raw ptr\"))\n@@ -1069,66 +843,56 @@ fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty)\n \n fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty_hint: Option<Ty<'tcx>>)\n-                          -> Result<ConstVal, ErrKind> {\n+                          mut ty: Ty<'tcx>)\n+                          -> Result<ConstVal<'tcx>, ErrKind<'tcx>> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n+\n+    if let ty::TyAdt(adt, _) = ty.sty {\n+        if adt.is_enum() {\n+            ty = adt.repr.discr_type().to_ty(tcx)\n+        }\n+    }\n+\n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n-        LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n-        },\n-\n-        // FIXME: this should become u128.\n-        LitKind::Int(n, Unsuffixed) => {\n-            match ty_hint.map(|t| &t.sty) {\n-                Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n-                },\n-                Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n as u128), tcx, &ty::TyUint(uty)).map(Integral)\n-                },\n-                None => Ok(Integral(Infer(n as u128))),\n-                Some(&ty::TyAdt(adt, _)) => {\n-                    let int_ty = adt.repr.discr_type();\n-                    infer(Infer(n as u128), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n-                },\n-                Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n+        LitKind::Int(n, hint) => {\n+            match (&ty.sty, hint) {\n+                (&ty::TyInt(ity), _) |\n+                (_, Signed(ity)) => {\n+                    Ok(Integral(ConstInt::new_signed_truncating(n as i128,\n+                        ity, tcx.sess.target.int_type)))\n+                }\n+                (&ty::TyUint(uty), _) |\n+                (_, Unsigned(uty)) => {\n+                    Ok(Integral(ConstInt::new_unsigned_truncating(n as u128,\n+                        uty, tcx.sess.target.uint_type)))\n+                }\n+                _ => bug!()\n             }\n-        },\n-        LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n as u128), tcx, &ty::TyUint(ity)).map(Integral)\n-        },\n-\n+        }\n         LitKind::Float(n, fty) => {\n-            parse_float(&n.as_str(), Some(fty)).map(Float)\n+            parse_float(&n.as_str(), fty).map(Float)\n         }\n         LitKind::FloatUnsuffixed(n) => {\n-            let fty_hint = match ty_hint.map(|t| &t.sty) {\n-                Some(&ty::TyFloat(fty)) => Some(fty),\n-                _ => None\n+            let fty = match ty.sty {\n+                ty::TyFloat(fty) => fty,\n+                _ => bug!()\n             };\n-            parse_float(&n.as_str(), fty_hint).map(Float)\n+            parse_float(&n.as_str(), fty).map(Float)\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),\n     }\n }\n \n-fn parse_float(num: &str, fty_hint: Option<ast::FloatTy>)\n-               -> Result<ConstFloat, ErrKind> {\n-    let val = match fty_hint {\n-        Some(ast::FloatTy::F32) => num.parse::<f32>().map(F32),\n-        Some(ast::FloatTy::F64) => num.parse::<f64>().map(F64),\n-        None => {\n-            num.parse::<f32>().and_then(|f32| {\n-                num.parse::<f64>().map(|f64| {\n-                    FInfer { f32: f32, f64: f64 }\n-                })\n-            })\n-        }\n+fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n+                     -> Result<ConstFloat, ErrKind<'tcx>> {\n+    let val = match fty {\n+        ast::FloatTy::F32 => num.parse::<f32>().map(F32),\n+        ast::FloatTy::F64 => num.parse::<f64>().map(F64)\n     };\n     val.map_err(|_| {\n         // FIXME(#31407) this is only necessary because float parsing is buggy\n@@ -1168,17 +932,17 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n                              a: &Expr,\n                              b: &Expr) -> Result<Ordering, ErrorReported> {\n         let tcx = self.tcx;\n-        let a = match self.eval(a, ExprTypeChecked) {\n+        let a = match self.eval(a) {\n             Ok(a) => a,\n             Err(e) => {\n-                report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+                report_const_eval_err(tcx, &e, a.span, \"expression\");\n                 return Err(ErrorReported);\n             }\n         };\n-        let b = match self.eval(b, ExprTypeChecked) {\n+        let b = match self.eval(b) {\n             Ok(b) => b,\n             Err(e) => {\n-                report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+                report_const_eval_err(tcx, &e, b.span, \"expression\");\n                 return Err(ErrorReported);\n             }\n         };\n@@ -1193,26 +957,17 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              reason: &str)\n                              -> Result<usize, ErrorReported>\n {\n-    let hint = UncheckedExprHint(tcx.types.usize);\n     let count_expr = &tcx.hir.body(count).value;\n-    match ConstContext::new(tcx, count).eval(count_expr, hint) {\n+    match ConstContext::new(tcx, count).eval(count_expr) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n             Ok(val as usize)\n         },\n-        Ok(const_val) => {\n-            struct_span_err!(tcx.sess, count_expr.span, E0306,\n-                             \"expected `usize` for {}, found {}\",\n-                             reason,\n-                             const_val.description())\n-                .span_label(count_expr.span, &format!(\"expected `usize`\"))\n-                .emit();\n-\n-            Err(ErrorReported)\n-        }\n+        Ok(_) |\n+        Err(ConstEvalErr { kind: TypeckError, .. }) => Err(ErrorReported),\n         Err(err) => {\n-            let mut diag = report_const_eval_err(\n+            let mut diag = build_const_eval_err(\n                 tcx, &err, count_expr.span, reason);\n \n             if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {"}, {"sha": "4434a901f9412512f29ed52bcf674f7a15d0b106", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -21,6 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n \n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "72a47c0028162a39d6e9d894cdbdf1380c52bf4f", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -27,9 +27,9 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n-pub enum PatternError {\n+pub enum PatternError<'tcx> {\n     StaticInPattern(Span),\n-    ConstEval(eval::ConstEvalErr),\n+    ConstEval(eval::ConstEvalErr<'tcx>),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -84,12 +84,12 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: ConstVal,\n+        value: ConstVal<'tcx>,\n     },\n \n     Range {\n-        lo: ConstVal,\n-        hi: ConstVal,\n+        lo: ConstVal<'tcx>,\n+        hi: ConstVal<'tcx>,\n         end: RangeEnd,\n     },\n \n@@ -118,7 +118,7 @@ fn print_const_val(value: &ConstVal, f: &mut fmt::Formatter) -> fmt::Result {\n         ConstVal::Char(c) => write!(f, \"{:?}\", c),\n         ConstVal::Struct(_) |\n         ConstVal::Tuple(_) |\n-        ConstVal::Function(_) |\n+        ConstVal::Function(..) |\n         ConstVal::Array(..) |\n         ConstVal::Repeat(..) => bug!(\"{:?} not printable in a pattern\", value)\n     }\n@@ -265,7 +265,7 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n pub struct PatternContext<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub tables: &'a ty::TypeckTables<'gcx>,\n-    pub errors: Vec<PatternError>,\n+    pub errors: Vec<PatternError<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> Pattern<'tcx> {\n@@ -582,11 +582,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 let tcx = self.tcx.global_tcx();\n                 let substs = self.tables.node_id_item_substs(id)\n                     .unwrap_or_else(|| tcx.intern_substs(&[]));\n-                match eval::lookup_const_by_id(tcx, def_id, Some(substs)) {\n-                    Some((const_expr, const_tables, _const_ty)) => {\n+                match eval::lookup_const_by_id(tcx, def_id, substs) {\n+                    Some((const_expr, const_tables)) => {\n                         // Enter the inlined constant's tables temporarily.\n                         let old_tables = self.tables;\n-                        self.tables = const_tables.expect(\"missing tables after typeck\");\n+                        self.tables = const_tables;\n                         let pat = self.lower_const_expr(const_expr, pat_id, span);\n                         self.tables = old_tables;\n                         return pat;\n@@ -609,7 +609,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n     fn lower_lit(&mut self, expr: &hir::Expr) -> PatternKind<'tcx> {\n         let const_cx = eval::ConstContext::with_tables(self.tcx.global_tcx(), self.tables);\n-        match const_cx.eval(expr, eval::EvalHint::ExprTypeChecked) {\n+        match const_cx.eval(expr) {\n             Ok(value) => {\n                 PatternKind::Constant { value: value }\n             }\n@@ -796,7 +796,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal, Region,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal<'tcx>, Region,\n     Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n }"}, {"sha": "f557edffbda462053b3a8bfcfb737d407a291bd7", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 7, "deletions": 40, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -17,21 +17,14 @@ use super::err::*;\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum ConstFloat {\n     F32(f32),\n-    F64(f64),\n-\n-    // When the type isn't known, we have to operate on both possibilities.\n-    FInfer {\n-        f32: f32,\n-        f64: f64\n-    }\n+    F64(f64)\n }\n pub use self::ConstFloat::*;\n \n impl ConstFloat {\n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n         match *self {\n-            FInfer {..} => \"float\",\n             F32(_) => \"f32\",\n             F64(_) => \"f64\",\n         }\n@@ -41,17 +34,13 @@ impl ConstFloat {\n         match *self {\n             F32(f) => f.is_nan(),\n             F64(f) => f.is_nan(),\n-            FInfer { f32, f64 } => f32.is_nan() || f64.is_nan()\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n         match (self, rhs) {\n-            (F64(a), F64(b)) |\n-            (F64(a), FInfer { f64: b, .. }) |\n-            (FInfer { f64: a, .. }, F64(b)) |\n-            (FInfer { f64: a, .. }, FInfer { f64: b, .. })  => {\n+            (F64(a), F64(b))  => {\n                 // This is pretty bad but it is the existing behavior.\n                 Ok(if a == b {\n                     Ordering::Equal\n@@ -62,9 +51,7 @@ impl ConstFloat {\n                 })\n             }\n \n-            (F32(a), F32(b)) |\n-            (F32(a), FInfer { f32: b, .. }) |\n-            (FInfer { f32: a, .. }, F32(b)) => {\n+            (F32(a), F32(b)) => {\n                 Ok(if a == b {\n                     Ordering::Equal\n                 } else if a < b {\n@@ -86,10 +73,7 @@ impl ConstFloat {\n impl PartialEq for ConstFloat {\n     fn eq(&self, other: &Self) -> bool {\n         match (*self, *other) {\n-            (F64(a), F64(b)) |\n-            (F64(a), FInfer { f64: b, .. }) |\n-            (FInfer { f64: a, .. }, F64(b)) |\n-            (FInfer { f64: a, .. }, FInfer { f64: b, .. }) => {\n+            (F64(a), F64(b)) => {\n                 unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)}\n             }\n             (F32(a), F32(b)) => {\n@@ -105,7 +89,7 @@ impl Eq for ConstFloat {}\n impl hash::Hash for ConstFloat {\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         match *self {\n-            F64(a) | FInfer { f64: a, .. } => {\n+            F64(a) => {\n                 unsafe { transmute::<_,u64>(a) }.hash(state)\n             }\n             F32(a) => {\n@@ -118,7 +102,6 @@ impl hash::Hash for ConstFloat {\n impl ::std::fmt::Display for ConstFloat {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n         match *self {\n-            FInfer { f64, .. } => write!(fmt, \"{}\", f64),\n             F32(f) => write!(fmt, \"{}f32\", f),\n             F64(f) => write!(fmt, \"{}f64\", f),\n         }\n@@ -131,20 +114,8 @@ macro_rules! derive_binop {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n                 match (self, rhs) {\n-                    (F32(a), F32(b)) |\n-                    (F32(a), FInfer { f32: b, .. }) |\n-                    (FInfer { f32: a, .. }, F32(b)) => Ok(F32(a.$func(b))),\n-\n-                    (F64(a), F64(b)) |\n-                    (FInfer { f64: a, .. }, F64(b)) |\n-                    (F64(a), FInfer { f64: b, .. }) => Ok(F64(a.$func(b))),\n-\n-                    (FInfer { f32: a32, f64: a64 },\n-                     FInfer { f32: b32, f64: b64 }) => Ok(FInfer {\n-                        f32: a32.$func(b32),\n-                        f64: a64.$func(b64)\n-                    }),\n-\n+                    (F32(a), F32(b)) => Ok(F32(a.$func(b))),\n+                    (F64(a), F64(b)) => Ok(F64(a.$func(b))),\n                     _ => Err(UnequalTypes(Op::$op)),\n                 }\n             }\n@@ -164,10 +135,6 @@ impl ::std::ops::Neg for ConstFloat {\n         match self {\n             F32(f) => F32(-f),\n             F64(f) => F64(-f),\n-            FInfer { f32, f64 } => FInfer {\n-                f32: -f32,\n-                f64: -f64\n-            }\n         }\n     }\n }"}, {"sha": "d97276da9bf34b9315d7a410f403fe34a558a076", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 97, "deletions": 143, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -30,8 +30,6 @@ pub enum ConstInt {\n     U64(u64),\n     U128(u128),\n     Usize(ConstUsize),\n-    Infer(u128),\n-    InferSigned(i128),\n }\n pub use self::ConstInt::*;\n \n@@ -92,7 +90,7 @@ impl ConstInt {\n         }\n     }\n \n-    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// Creates a new signed ConstInt with matching type while also checking that overflow does\n     /// not happen.\n     pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n         match ty {\n@@ -107,103 +105,33 @@ impl ConstInt {\n         }\n     }\n \n-    /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n-    /// the other value. If both values have no type, don't do anything\n-    pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {\n-        let inferred = match (self, other) {\n-            (InferSigned(_), InferSigned(_))\n-            | (Infer(_), Infer(_)) => self, // no inference possible\n-            // kindof wrong, you could have had values > I64MAX during computation of a\n-            (Infer(a @ 0...ubounds::I64MAX), InferSigned(_)) => InferSigned(a as i128),\n-            (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n-            (_, InferSigned(_))\n-            | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n-\n-            (Infer(a @ 0...ubounds::I8MAX), I8(_)) => I8(a as i64 as i8),\n-            (Infer(a @ 0...ubounds::I16MAX), I16(_)) => I16(a as i64 as i16),\n-            (Infer(a @ 0...ubounds::I32MAX), I32(_)) => I32(a as i64 as i32),\n-            (Infer(a @ 0...ubounds::I64MAX), I64(_)) => I64(a as i64),\n-            (Infer(a @ 0...ubounds::I128MAX), I128(_)) => I128(a as i128),\n-            (Infer(a @ 0...ubounds::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n-            (Infer(a @ 0...ubounds::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n-            (Infer(a @ 0...ubounds::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n-            (Infer(a @ 0...ubounds::U8MAX), U8(_)) => U8(a as u8),\n-            (Infer(a @ 0...ubounds::U16MAX), U16(_)) => U16(a as u16),\n-            (Infer(a @ 0...ubounds::U32MAX), U32(_)) => U32(a as u32),\n-            (Infer(a @ 0...ubounds::U64MAX), U64(_)) => U64(a as u64),\n-            (Infer(a @ 0...ubounds::U128MAX), U128(_)) => U128(a as u128),\n-            (Infer(a @ 0...ubounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (Infer(a @ 0...ubounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (Infer(a @ 0...ubounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n-\n-            (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n-\n-            (InferSigned(a @ ibounds::I8MIN...ibounds::I8MAX), I8(_)) => I8(a as i8),\n-            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), I16(_)) => I16(a as i16),\n-            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), I32(_)) => I32(a as i32),\n-            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), I64(_)) => I64(a as i64),\n-            (InferSigned(a @ ibounds::I128MIN...ibounds::I128MAX), I128(_)) => I128(a as i128),\n-            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), Isize(Is16(_))) => {\n-                Isize(Is16(a as i16))\n-            },\n-            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), Isize(Is32(_))) => {\n-                Isize(Is32(a as i32))\n-            },\n-            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), Isize(Is64(_))) => {\n-                Isize(Is64(a as i64))\n-            },\n-            (InferSigned(a @ 0...ibounds::U8MAX), U8(_)) => U8(a as u8),\n-            (InferSigned(a @ 0...ibounds::U16MAX), U16(_)) => U16(a as u16),\n-            (InferSigned(a @ 0...ibounds::U32MAX), U32(_)) => U32(a as u32),\n-            (InferSigned(a @ 0...ibounds::U64MAX), U64(_)) => U64(a as u64),\n-            (InferSigned(a @ 0...ibounds::I128MAX), U128(_)) => U128(a as u128),\n-            (InferSigned(a @ 0...ibounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (InferSigned(a @ 0...ibounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (InferSigned(a @ 0...ibounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n-            (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n-            _ => self, // already known types\n-        };\n-        Ok((inferred, other))\n+    /// Creates a new unsigned ConstInt with matching type.\n+    pub fn new_unsigned_truncating(val: u128, ty: UintTy, usize_ty: UintTy) -> ConstInt {\n+        match ty {\n+            UintTy::U8 => U8(val as u8),\n+            UintTy::U16 => U16(val as u16),\n+            UintTy::U32 => U32(val as u32),\n+            UintTy::U64 => U64(val as u64),\n+            UintTy::Us => Usize(ConstUsize::new_truncating(val, usize_ty)),\n+            UintTy::U128 => U128(val)\n+        }\n     }\n \n-    /// Turn this value into an `Infer` or an `InferSigned`\n-    pub fn erase_type(self) -> Self {\n-        match self {\n-            Infer(i) => Infer(i),\n-            InferSigned(i) if i < 0 => InferSigned(i),\n-            I8(i) if i < 0 => InferSigned(i as i128),\n-            I16(i) if i < 0 => InferSigned(i as i128),\n-            I32(i) if i < 0 => InferSigned(i as i128),\n-            I64(i) if i < 0 => InferSigned(i as i128),\n-            I128(i) if i < 0 => InferSigned(i as i128),\n-            Isize(Is16(i)) if i < 0 => InferSigned(i as i128),\n-            Isize(Is32(i)) if i < 0 => InferSigned(i as i128),\n-            Isize(Is64(i)) if i < 0 => InferSigned(i as i128),\n-            InferSigned(i) => Infer(i as u128),\n-            I8(i) => Infer(i as u128),\n-            I16(i) => Infer(i as u128),\n-            I32(i) => Infer(i as u128),\n-            I64(i) => Infer(i as u128),\n-            I128(i) => Infer(i as u128),\n-            Isize(Is16(i)) => Infer(i as u128),\n-            Isize(Is32(i)) => Infer(i as u128),\n-            Isize(Is64(i)) => Infer(i as u128),\n-            U8(i) => Infer(i as u128),\n-            U16(i) => Infer(i as u128),\n-            U32(i) => Infer(i as u128),\n-            U64(i) => Infer(i as u128),\n-            U128(i) => Infer(i as u128),\n-            Usize(Us16(i)) => Infer(i as u128),\n-            Usize(Us32(i)) => Infer(i as u128),\n-            Usize(Us64(i)) => Infer(i as u128),\n+    /// Creates a new signed ConstInt with matching type.\n+    pub fn new_signed_truncating(val: i128, ty: IntTy, isize_ty: IntTy) -> ConstInt {\n+        match ty {\n+            IntTy::I8 => I8(val as i8),\n+            IntTy::I16 => I16(val as i16),\n+            IntTy::I32 => I32(val as i32),\n+            IntTy::I64 => I64(val as i64),\n+            IntTy::Is => Isize(ConstIsize::new_truncating(val, isize_ty)),\n+            IntTy::I128 => I128(val)\n         }\n     }\n \n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n         match *self {\n-            Infer(_) => \"not yet inferred integral\",\n-            InferSigned(_) => \"not yet inferred signed integral\",\n             I8(_) => \"i8\",\n             I16(_) => \"i16\",\n             I32(_) => \"i32\",\n@@ -222,10 +150,23 @@ impl ConstInt {\n     /// Erases the type and returns a u128.\n     /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n     pub fn to_u128_unchecked(self) -> u128 {\n-        match self.erase_type() {\n-            ConstInt::Infer(i) => i,\n-            ConstInt::InferSigned(i) => i as u128,\n-            _ => unreachable!(),\n+        match self {\n+            I8(i) => i as i128 as u128,\n+            I16(i) => i as i128 as u128,\n+            I32(i) => i as i128 as u128,\n+            I64(i) => i as i128 as u128,\n+            I128(i) => i as i128 as u128,\n+            Isize(Is16(i)) => i as i128 as u128,\n+            Isize(Is32(i)) => i as i128 as u128,\n+            Isize(Is64(i)) => i as i128 as u128,\n+            U8(i) => i as u128,\n+            U16(i) => i as u128,\n+            U32(i) => i as u128,\n+            U64(i) => i as u128,\n+            U128(i) => i as u128,\n+            Usize(Us16(i)) => i as u128,\n+            Usize(Us32(i)) => i as u128,\n+            Usize(Us64(i)) => i as u128,\n         }\n     }\n \n@@ -250,8 +191,6 @@ impl ConstInt {\n     /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n     pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n-            Infer(v) => Some(v),\n-            InferSigned(v) if v >= 0 => Some(v as u128),\n             I8(v) if v >= 0 => Some(v as u128),\n             I16(v) if v >= 0 => Some(v as u128),\n             I32(v) if v >= 0 => Some(v as u128),\n@@ -272,6 +211,48 @@ impl ConstInt {\n         }\n     }\n \n+    pub fn to_f32(self) -> f32 {\n+        match self {\n+            I8(i) => i as f32,\n+            I16(i) => i as f32,\n+            I32(i) => i as f32,\n+            I64(i) => i as f32,\n+            I128(i) => i as f32,\n+            Isize(Is16(i)) => i as f32,\n+            Isize(Is32(i)) => i as f32,\n+            Isize(Is64(i)) => i as f32,\n+            U8(i) => i as f32,\n+            U16(i) => i as f32,\n+            U32(i) => i as f32,\n+            U64(i) => i as f32,\n+            U128(i) => i as f32,\n+            Usize(Us16(i)) => i as f32,\n+            Usize(Us32(i)) => i as f32,\n+            Usize(Us64(i)) => i as f32,\n+        }\n+    }\n+\n+    pub fn to_f64(self) -> f64 {\n+        match self {\n+            I8(i) => i as f64,\n+            I16(i) => i as f64,\n+            I32(i) => i as f64,\n+            I64(i) => i as f64,\n+            I128(i) => i as f64,\n+            Isize(Is16(i)) => i as f64,\n+            Isize(Is32(i)) => i as f64,\n+            Isize(Is64(i)) => i as f64,\n+            U8(i) => i as f64,\n+            U16(i) => i as f64,\n+            U32(i) => i as f64,\n+            U64(i) => i as f64,\n+            U128(i) => i as f64,\n+            Usize(Us16(i)) => i as f64,\n+            Usize(Us32(i)) => i as f64,\n+            Usize(Us64(i)) => i as f64,\n+        }\n+    }\n+\n     pub fn is_negative(&self) -> bool {\n         match *self {\n             I8(v) => v < 0,\n@@ -282,14 +263,13 @@ impl ConstInt {\n             Isize(Is16(v)) => v < 0,\n             Isize(Is32(v)) => v < 0,\n             Isize(Is64(v)) => v < 0,\n-            InferSigned(v) => v < 0,\n             _ => false,\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<::std::cmp::Ordering, ConstMathErr> {\n-        match self.infer(rhs)? {\n+        match (self, rhs) {\n             (I8(a), I8(b)) => Ok(a.cmp(&b)),\n             (I16(a), I16(b)) => Ok(a.cmp(&b)),\n             (I32(a), I32(b)) => Ok(a.cmp(&b)),\n@@ -306,8 +286,6 @@ impl ConstInt {\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n-            (Infer(a), Infer(b)) => Ok(a.cmp(&b)),\n-            (InferSigned(a), InferSigned(b)) => Ok(a.cmp(&b)),\n             _ => Err(CmpBetweenUnequalTypes),\n         }\n     }\n@@ -334,25 +312,23 @@ impl ConstInt {\n             ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n-            ConstInt::Infer(_) | ConstInt::InferSigned(_) => panic!(\"no type info for const int\"),\n         }\n     }\n \n-    pub fn int_type(self) -> Option<IntType> {\n+    pub fn int_type(self) -> IntType {\n         match self {\n-            ConstInt::I8(_) => Some(IntType::SignedInt(IntTy::I8)),\n-            ConstInt::I16(_) => Some(IntType::SignedInt(IntTy::I16)),\n-            ConstInt::I32(_) => Some(IntType::SignedInt(IntTy::I32)),\n-            ConstInt::I64(_) => Some(IntType::SignedInt(IntTy::I64)),\n-            ConstInt::I128(_) => Some(IntType::SignedInt(IntTy::I128)),\n-            ConstInt::Isize(_) => Some(IntType::SignedInt(IntTy::Is)),\n-            ConstInt::U8(_) => Some(IntType::UnsignedInt(UintTy::U8)),\n-            ConstInt::U16(_) => Some(IntType::UnsignedInt(UintTy::U16)),\n-            ConstInt::U32(_) => Some(IntType::UnsignedInt(UintTy::U32)),\n-            ConstInt::U64(_) => Some(IntType::UnsignedInt(UintTy::U64)),\n-            ConstInt::U128(_) => Some(IntType::UnsignedInt(UintTy::U128)),\n-            ConstInt::Usize(_) => Some(IntType::UnsignedInt(UintTy::Us)),\n-            _ => None,\n+            ConstInt::I8(_) => IntType::SignedInt(IntTy::I8),\n+            ConstInt::I16(_) => IntType::SignedInt(IntTy::I16),\n+            ConstInt::I32(_) => IntType::SignedInt(IntTy::I32),\n+            ConstInt::I64(_) => IntType::SignedInt(IntTy::I64),\n+            ConstInt::I128(_) => IntType::SignedInt(IntTy::I128),\n+            ConstInt::Isize(_) => IntType::SignedInt(IntTy::Is),\n+            ConstInt::U8(_) => IntType::UnsignedInt(UintTy::U8),\n+            ConstInt::U16(_) => IntType::UnsignedInt(UintTy::U16),\n+            ConstInt::U32(_) => IntType::UnsignedInt(UintTy::U32),\n+            ConstInt::U64(_) => IntType::UnsignedInt(UintTy::U64),\n+            ConstInt::U128(_) => IntType::UnsignedInt(UintTy::U128),\n+            ConstInt::Usize(_) => IntType::UnsignedInt(UintTy::Us),\n         }\n     }\n }\n@@ -372,8 +348,6 @@ impl ::std::cmp::Ord for ConstInt {\n impl ::std::fmt::Display for ConstInt {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n         match *self {\n-            Infer(i) => write!(fmt, \"{}\", i),\n-            InferSigned(i) => write!(fmt, \"{}\", i),\n             I8(i) => write!(fmt, \"{}i8\", i),\n             I16(i) => write!(fmt, \"{}i16\", i),\n             I32(i) => write!(fmt, \"{}i32\", i),\n@@ -409,7 +383,7 @@ macro_rules! impl_binop {\n         impl ::std::ops::$op for ConstInt {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match self.infer(rhs)? {\n+                match (self, rhs) {\n                     (I8(a), I8(b)) => a.$checked_func(b).map(I8),\n                     (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n                     (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n@@ -426,8 +400,6 @@ macro_rules! impl_binop {\n                     (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n                     (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n                     (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n-                    (Infer(a), Infer(b)) => a.$checked_func(b).map(Infer),\n-                    (InferSigned(a), InferSigned(b)) => a.$checked_func(b).map(InferSigned),\n                     _ => return Err(UnequalTypes(Op::$op)),\n                 }.ok_or(Overflow(Op::$op))\n             }\n@@ -440,7 +412,7 @@ macro_rules! derive_binop {\n         impl ::std::ops::$op for ConstInt {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match self.infer(rhs)? {\n+                match (self, rhs) {\n                     (I8(a), I8(b)) => Ok(I8(a.$func(b))),\n                     (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n                     (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n@@ -457,8 +429,6 @@ macro_rules! derive_binop {\n                     (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n                     (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n                     (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n-                    (Infer(a), Infer(b)) => Ok(Infer(a.$func(b))),\n-                    (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a.$func(b))),\n                     _ => Err(UnequalTypes(Op::$op)),\n                 }\n             }\n@@ -490,7 +460,6 @@ fn check_division(\n         (Isize(_), Isize(Is16(0))) => Err(zerr),\n         (Isize(_), Isize(Is32(0))) => Err(zerr),\n         (Isize(_), Isize(Is64(0))) => Err(zerr),\n-        (InferSigned(_), InferSigned(0)) => Err(zerr),\n \n         (U8(_), U8(0)) => Err(zerr),\n         (U16(_), U16(0)) => Err(zerr),\n@@ -500,7 +469,6 @@ fn check_division(\n         (Usize(_), Usize(Us16(0))) => Err(zerr),\n         (Usize(_), Usize(Us32(0))) => Err(zerr),\n         (Usize(_), Usize(Us64(0))) => Err(zerr),\n-        (Infer(_), Infer(0)) => Err(zerr),\n \n         (I8(::std::i8::MIN), I8(-1)) => Err(Overflow(op)),\n         (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n@@ -510,7 +478,6 @@ fn check_division(\n         (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n         (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n         (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-        (InferSigned(I128_MIN), InferSigned(-1)) => Err(Overflow(op)),\n \n         _ => Ok(()),\n     }\n@@ -519,7 +486,7 @@ fn check_division(\n impl ::std::ops::Div for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn div(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = self.infer(rhs)?;\n+        let (lhs, rhs) = (self, rhs);\n         check_division(lhs, rhs, Op::Div, DivisionByZero)?;\n         match (lhs, rhs) {\n             (I8(a), I8(b)) => Ok(I8(a/b)),\n@@ -530,7 +497,6 @@ impl ::std::ops::Div for ConstInt {\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n-            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a/b)),\n \n             (U8(a), U8(b)) => Ok(U8(a/b)),\n             (U16(a), U16(b)) => Ok(U16(a/b)),\n@@ -540,7 +506,6 @@ impl ::std::ops::Div for ConstInt {\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n-            (Infer(a), Infer(b)) => Ok(Infer(a/b)),\n \n             _ => Err(UnequalTypes(Op::Div)),\n         }\n@@ -550,7 +515,7 @@ impl ::std::ops::Div for ConstInt {\n impl ::std::ops::Rem for ConstInt {\n     type Output = Result<Self, ConstMathErr>;\n     fn rem(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-        let (lhs, rhs) = self.infer(rhs)?;\n+        let (lhs, rhs) = (self, rhs);\n         // should INT_MIN%-1 be zero or an error?\n         check_division(lhs, rhs, Op::Rem, RemainderByZero)?;\n         match (lhs, rhs) {\n@@ -562,7 +527,6 @@ impl ::std::ops::Rem for ConstInt {\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n-            (InferSigned(a), InferSigned(b)) => Ok(InferSigned(a%b)),\n \n             (U8(a), U8(b)) => Ok(U8(a%b)),\n             (U16(a), U16(b)) => Ok(U16(a%b)),\n@@ -572,7 +536,6 @@ impl ::std::ops::Rem for ConstInt {\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n-            (Infer(a), Infer(b)) => Ok(Infer(a%b)),\n \n             _ => Err(UnequalTypes(Op::Rem)),\n         }\n@@ -600,8 +563,6 @@ impl ::std::ops::Shl<ConstInt> for ConstInt {\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n-            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shl(b), Op::Shl))),\n-            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shl(b), Op::Shl))),\n         }\n     }\n }\n@@ -627,8 +588,6 @@ impl ::std::ops::Shr<ConstInt> for ConstInt {\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n-            Infer(a) => Ok(Infer(overflowing!(a.overflowing_shr(b), Op::Shr))),\n-            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_shr(b), Op::Shr))),\n         }\n     }\n }\n@@ -648,9 +607,6 @@ impl ::std::ops::Neg for ConstInt {\n             a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n             a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n             U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n-            Infer(a @ 0...ubounds::I128MAX) => Ok(InferSigned(-(a as i128))),\n-            Infer(_) => Err(Overflow(Op::Neg)),\n-            InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n         }\n     }\n }\n@@ -675,8 +631,6 @@ impl ::std::ops::Not for ConstInt {\n             Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n             Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n             Usize(Us64(a)) => Ok(Usize(Us64(!a))),\n-            Infer(a) => Ok(Infer(!a)),\n-            InferSigned(a) => Ok(InferSigned(!a)),\n         }\n     }\n }"}, {"sha": "b7833a5440321221eb934a00ef08fd675550cfcc", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -21,7 +21,7 @@\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n-\n+#![deny(warnings)]\n \n #![feature(rustc_private)]\n #![feature(staged_api)]"}, {"sha": "529afe0215e53672eebee1ea1538e3c9c87719ae", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -17,7 +17,6 @@ use rustc::ty::layout::{Layout, Primitive};\n use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass};\n@@ -109,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             }\n                         } else {\n                             let const_cx = ConstContext::with_tables(cx.tcx, cx.tables);\n-                            match const_cx.eval(&r, ExprTypeChecked) {\n+                            match const_cx.eval(&r) {\n                                 Ok(ConstVal::Integral(i)) => {\n                                     i.is_negative() ||\n                                     i.to_u64()"}, {"sha": "26d907523a886ac046b1f5feaad29db424cd8f71", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -230,9 +230,9 @@ pub enum EntryKind<'tcx> {\n     Type,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>, ReprOptions),\n-    Union(Lazy<VariantData>, ReprOptions),\n+    Variant(Lazy<VariantData<'tcx>>),\n+    Struct(Lazy<VariantData<'tcx>>, ReprOptions),\n+    Union(Lazy<VariantData<'tcx>>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n@@ -263,10 +263,10 @@ pub struct FnData {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-pub struct VariantData {\n+pub struct VariantData<'tcx> {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n-    pub evaluated_discr: Option<ConstVal>,\n+    pub evaluated_discr: Option<ConstVal<'tcx>>,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item."}, {"sha": "6b6acb054b1b0200cb16f887a267815b28d1dff6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -309,13 +309,13 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n-        options: Vec<ConstVal>,\n-        indices: FxHashMap<ConstVal, usize>,\n+        options: Vec<ConstVal<'tcx>>,\n+        indices: FxHashMap<ConstVal<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: ConstVal,\n+        value: ConstVal<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "f4fdf8ade900a0ba7951491a80889477d00ca4f5", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -112,8 +112,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      test_lvalue: &Lvalue<'tcx>,\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n-                                     options: &mut Vec<ConstVal>,\n-                                     indices: &mut FxHashMap<ConstVal, usize>)\n+                                     options: &mut Vec<ConstVal<'tcx>>,\n+                                     indices: &mut FxHashMap<ConstVal<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {"}, {"sha": "41374a0012327a4e78cb7d49e1b9682b682c2890", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -223,6 +223,17 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     builder.finish(vec![], ty)\n }\n \n+pub fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n+                                       body_id: hir::BodyId)\n+                                       -> Mir<'tcx> {\n+    let span = hir.tcx().hir.span(hir.tcx().hir.body_owner(body_id));\n+    let ty = hir.tcx().types.err;\n+    let mut builder = Builder::new(hir, span, 0, ty);\n+    let source_info = builder.source_info(span);\n+    builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n+    builder.finish(vec![], ty)\n+}\n+\n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,"}, {"sha": "f2b89309e4ab15a709f8ba49f5f20280c9b61149", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -17,7 +17,7 @@ use hair::cx::to_ref::ToRef;\n use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n+use rustc_const_eval::{ConstContext, fatal_const_eval_err};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -594,7 +594,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRepeat(ref v, count) => {\n             let tcx = cx.tcx.global_tcx();\n             let c = &cx.tcx.hir.body(count).value;\n-            let count = match ConstContext::new(tcx, count).eval(c, EvalHint::ExprTypeChecked) {\n+            let count = match ConstContext::new(tcx, count).eval(c) {\n                 Ok(ConstVal::Integral(ConstInt::Usize(u))) => u,\n                 Ok(other) => bug!(\"constant evaluation of repeat count yielded {:?}\", other),\n                 Err(s) => fatal_const_eval_err(tcx, &s, c.span, \"expression\")"}, {"sha": "c555ce1ab9c425de7e8c749a8c1a67826f6af472", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -18,7 +18,7 @@ use hair::*;\n use rustc::mir::transform::MirSource;\n \n use rustc::middle::const_val::ConstVal;\n-use rustc_const_eval::{ConstContext, EvalHint, fatal_const_eval_err};\n+use rustc_const_eval::{ConstContext, fatal_const_eval_err};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n     pub fn const_eval_literal(&mut self, e: &hir::Expr) -> Literal<'tcx> {\n         let tcx = self.tcx.global_tcx();\n-        match ConstContext::with_tables(tcx, self.tables()).eval(e, EvalHint::ExprTypeChecked) {\n+        match ConstContext::with_tables(tcx, self.tables()).eval(e) {\n             Ok(value) => Literal::Value { value: value },\n             Err(s) => fatal_const_eval_err(tcx, &s, e.span, \"expression\")\n         }"}, {"sha": "e0eb09fbf5d6f06e399b50d34216198f85bf16a8", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -98,7 +98,9 @@ fn build_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     let src = MirSource::from_node(tcx, id);\n     tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n         let cx = Cx::new(&infcx, src);\n-        let mut mir = if let MirSource::Fn(id) = src {\n+        let mut mir = if cx.tables().tainted_by_errors {\n+            build::construct_error(cx, body_id)\n+        } else if let MirSource::Fn(id) = src {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n             let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();"}, {"sha": "930a13e36bdcaebf3ba853882381c975c3e91ff4", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -28,9 +28,8 @@ use rustc::dep_graph::DepNode;\n use rustc::ty::cast::CastKind;\n use rustc_const_eval::{ConstEvalErr, ConstContext};\n use rustc_const_eval::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll, Math};\n-use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath, BadType};\n-use rustc_const_eval::ErrKind::UnresolvedPath;\n-use rustc_const_eval::EvalHint::ExprTypeChecked;\n+use rustc_const_eval::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};\n+use rustc_const_eval::ErrKind::{TypeckError};\n use rustc_const_math::{ConstMathErr, Op};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n@@ -66,12 +65,12 @@ struct CheckCrateVisitor<'a, 'tcx: 'a> {\n impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     fn check_const_eval(&self, expr: &'gcx hir::Expr) {\n         let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n-        if let Err(err) = const_cx.eval(expr, ExprTypeChecked) {\n+        if let Err(err) = const_cx.eval(expr) {\n             match err.kind {\n                 UnimplementedConstVal(_) => {}\n                 IndexOpFeatureGated => {}\n                 ErroneousReferencedConstant(_) => {}\n-                BadType(_) => {}\n+                TypeckError => {}\n                 _ => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            expr.id,\n@@ -240,18 +239,17 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n         if self.in_fn && self.promotable {\n             let const_cx = ConstContext::with_tables(self.tcx, self.tables);\n-            match const_cx.eval(ex, ExprTypeChecked) {\n+            match const_cx.eval(ex) {\n                 Ok(_) => {}\n                 Err(ConstEvalErr { kind: UnimplementedConstVal(_), .. }) |\n                 Err(ConstEvalErr { kind: MiscCatchAll, .. }) |\n                 Err(ConstEvalErr { kind: MiscBinaryOp, .. }) |\n                 Err(ConstEvalErr { kind: NonConstPath, .. }) |\n-                Err(ConstEvalErr { kind: UnresolvedPath, .. }) |\n                 Err(ConstEvalErr { kind: ErroneousReferencedConstant(_), .. }) |\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shr)), .. }) |\n                 Err(ConstEvalErr { kind: Math(ConstMathErr::Overflow(Op::Shl)), .. }) |\n                 Err(ConstEvalErr { kind: IndexOpFeatureGated, .. }) => {}\n-                Err(ConstEvalErr { kind: BadType(_), .. }) => {}\n+                Err(ConstEvalErr { kind: TypeckError, .. }) => {}\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR,\n                                            ex.id,"}, {"sha": "011f7748f2c98764ae4f86cba39d0afcb68001e3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -213,11 +213,11 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n     g\n }\n \n-pub fn trans_static(ccx: &CrateContext,\n-                    m: hir::Mutability,\n-                    id: ast::NodeId,\n-                    attrs: &[ast::Attribute])\n-                    -> Result<ValueRef, ConstEvalErr> {\n+pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                              m: hir::Mutability,\n+                              id: ast::NodeId,\n+                              attrs: &[ast::Attribute])\n+                              -> Result<ValueRef, ConstEvalErr<'tcx>> {\n     unsafe {\n         let def_id = ccx.tcx().hir.local_def_id(id);\n         let g = get_static(ccx, def_id);"}, {"sha": "3cad2bc1d842369e9a9000412fbd272f5e581f69", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if switch_ty == bcx.tcx().types.bool {\n                     let lltrue = llblock(self, targets[0]);\n                     let llfalse = llblock(self, targets[1]);\n-                    if let [ConstInt::Infer(0)] = values[..] {\n+                    if let [ConstInt::U8(0)] = values[..] {\n                         bcx.cond_br(discr.immediate(), llfalse, lltrue);\n                     } else {\n                         bcx.cond_br(discr.immediate(), lltrue, llfalse);"}, {"sha": "771a5b7f366a118d7ebea8d150507f1086e2a92b", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -83,7 +83,6 @@ impl<'tcx> Const<'tcx> {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n             },\n-            Infer(_) | InferSigned(_) => bug!(\"MIR must not use `{:?}`\", ci),\n         };\n         Const { llval: llval, ty: ty }\n     }\n@@ -97,14 +96,13 @@ impl<'tcx> Const<'tcx> {\n         let val = match cv {\n             ConstVal::Float(F32(v)) => C_floating_f64(v as f64, llty),\n             ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n-            ConstVal::Float(FInfer {..}) => bug!(\"MIR must not use `{:?}`\", cv),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) |\n-            ConstVal::Function(_) => {\n+            ConstVal::Function(..) => {\n                 bug!(\"MIR must not use `{:?}` (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n@@ -249,7 +247,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  instance: Instance<'tcx>,\n                  args: IndexVec<mir::Local, Const<'tcx>>)\n-                 -> Result<Const<'tcx>, ConstEvalErr> {\n+                 -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let instance = instance.resolve_const(ccx.shared());\n         let mir = ccx.tcx().item_mir(instance.def);\n         MirConstContext::new(ccx, &mir, instance.substs, args).trans()\n@@ -263,7 +261,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                          value)\n     }\n \n-    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr> {\n+    fn trans(&mut self) -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n         let mut bb = mir::START_BLOCK;\n \n@@ -325,7 +323,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         };\n \n                         let err = ConstEvalErr{ span: span, kind: err };\n-                        report_const_eval_err(tcx, &err, span, \"expression\").emit();\n+                        report_const_eval_err(tcx, &err, span, \"expression\");\n                         failure = Err(err);\n                     }\n                     target\n@@ -373,7 +371,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn const_lvalue(&self, lvalue: &mir::Lvalue<'tcx>, span: Span)\n-                    -> Result<ConstLvalue<'tcx>, ConstEvalErr> {\n+                    -> Result<ConstLvalue<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n@@ -468,7 +466,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     }\n \n     fn const_operand(&self, operand: &mir::Operand<'tcx>, span: Span)\n-                     -> Result<Const<'tcx>, ConstEvalErr> {\n+                     -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         debug!(\"const_operand({:?} @ {:?})\", operand, span);\n         let result = match *operand {\n             mir::Operand::Consume(ref lvalue) => {\n@@ -523,7 +521,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n     fn const_rvalue(&self, rvalue: &mir::Rvalue<'tcx>,\n                     dest_ty: Ty<'tcx>, span: Span)\n-                    -> Result<Const<'tcx>, ConstEvalErr> {\n+                    -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let tcx = self.ccx.tcx();\n         debug!(\"const_rvalue({:?}: {:?} @ {:?})\", rvalue, dest_ty, span);\n         let val = match *rvalue {\n@@ -961,8 +959,11 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n }\n \n \n-pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n-                                -> Result<ValueRef, ConstEvalErr> {\n+pub fn trans_static_initializer<'a, 'tcx>(\n+    ccx: &CrateContext<'a, 'tcx>,\n+    def_id: DefId)\n+    -> Result<ValueRef, ConstEvalErr<'tcx>>\n+{\n     let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, IndexVec::new()).map(|c| c.llval)\n }"}, {"sha": "577fe31eab02abff192e3125157610e9a95d5352", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 49, "deletions": 11, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -189,7 +189,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                             &item_segment.parameters,\n                                             None);\n \n-        assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n \n         substs\n     }\n@@ -446,7 +446,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                  trait_def_id,\n                                                  self_ty,\n                                                  trait_segment);\n-        assoc_bindings.first().map(|b| self.tcx().prohibit_projection(b.span));\n+        assoc_bindings.first().map(|b| self.prohibit_projection(b.span));\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n@@ -844,7 +844,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n-        tcx.prohibit_type_params(slice::ref_slice(item_segment));\n+        self.prohibit_type_params(slice::ref_slice(item_segment));\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n@@ -917,7 +917,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n         let tcx = self.tcx();\n \n-        tcx.prohibit_type_params(slice::ref_slice(item_segment));\n+        self.prohibit_type_params(slice::ref_slice(item_segment));\n \n         let self_ty = if let Some(ty) = opt_self_ty {\n             ty\n@@ -942,6 +942,36 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         self.projected_ty(span, trait_ref, item_segment.name)\n     }\n \n+    pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n+        for segment in segments {\n+            for typ in segment.parameters.types() {\n+                struct_span_err!(self.tcx().sess, typ.span, E0109,\n+                                 \"type parameters are not allowed on this type\")\n+                    .span_label(typ.span, &format!(\"type parameter not allowed\"))\n+                    .emit();\n+                break;\n+            }\n+            for lifetime in segment.parameters.lifetimes() {\n+                struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n+                                 \"lifetime parameters are not allowed on this type\")\n+                    .span_label(lifetime.span,\n+                                &format!(\"lifetime parameter not allowed on this type\"))\n+                    .emit();\n+                break;\n+            }\n+            for binding in segment.parameters.bindings() {\n+                self.prohibit_projection(binding.span);\n+                break;\n+            }\n+        }\n+    }\n+\n+    pub fn prohibit_projection(&self, span: Span) {\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n+                                       \"associated type bindings are not allowed here\");\n+        err.span_label(span, &format!(\"associate type not allowed here\")).emit();\n+    }\n+\n     // Check a type Path and convert it to a Ty.\n     pub fn def_to_ty(&self,\n                      opt_self_ty: Option<Ty<'tcx>>,\n@@ -957,21 +987,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         match path.def {\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.prohibit_type_params(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span,\n                                     tcx.parent_def_id(did).unwrap(),\n                                     path.segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(&path.segments);\n+                self.prohibit_type_params(&path.segments);\n \n                 let node_id = tcx.hir.as_local_node_id(did).unwrap();\n                 let item_id = tcx.hir.get_parent_node(node_id);\n@@ -984,7 +1014,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(&path.segments);\n+                self.prohibit_type_params(&path.segments);\n \n                 let ty = ty::queries::ty::get(tcx, span, def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n@@ -996,11 +1026,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(&path.segments);\n+                self.prohibit_type_params(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n+                self.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(span,\n                                  opt_self_ty,\n@@ -1010,7 +1040,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             Def::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prim_ty_to_ty(&path.segments, prim_ty)\n+                self.prohibit_type_params(&path.segments);\n+                match prim_ty {\n+                    hir::TyBool => tcx.types.bool,\n+                    hir::TyChar => tcx.types.char,\n+                    hir::TyInt(it) => tcx.mk_mach_int(it),\n+                    hir::TyUint(uit) => tcx.mk_mach_uint(uit),\n+                    hir::TyFloat(ft) => tcx.mk_mach_float(ft),\n+                    hir::TyStr => tcx.mk_str()\n+                }\n             }\n             Def::Err => {\n                 self.set_tainted_by_errors();"}, {"sha": "0337727dcba9ad372e2426e7843b4bd0c942dfe2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -432,10 +432,6 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     body_id: ast::NodeId,\n \n-    // This flag is set to true if, during the writeback phase, we encounter\n-    // a type error in this function.\n-    writeback_errors: Cell<bool>,\n-\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n     // have been reported, we will skip regionck and other work that\n@@ -1493,7 +1489,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         FnCtxt {\n             ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n             body_id: body_id,\n-            writeback_errors: Cell::new(false),\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_ty: rty,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal,\n@@ -1609,6 +1604,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n+            self.set_tainted_by_errors();\n         }\n \n         // FIXME(canndrew): This is_never should probably be an is_uninhabited\n@@ -4326,7 +4322,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // errors if type parameters are provided in an inappropriate place.\n         let poly_segments = type_segment.is_some() as usize +\n                             fn_segment.is_some() as usize;\n-        self.tcx.prohibit_type_params(&segments[..segments.len() - poly_segments]);\n+        AstConv::prohibit_type_params(self, &segments[..segments.len() - poly_segments]);\n \n         match def {\n             Def::Local(def_id) | Def::Upvar(def_id, ..) => {"}, {"sha": "1382ab34ca52048b7ba419a5800913f12649b214", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -20,7 +20,6 @@ use rustc::ty::fold::{TypeFolder,TypeFoldable};\n use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::{DefIdMap, DefIdSet};\n \n-use std::cell::Cell;\n use std::mem;\n \n use syntax::ast;\n@@ -35,8 +34,6 @@ use rustc::hir;\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body)\n                                      -> &'gcx ty::TypeckTables<'gcx> {\n-        assert_eq!(self.writeback_errors.get(), false);\n-\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n@@ -59,6 +56,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"used_trait_imports({:?}) = {:?}\", item_def_id, used_trait_imports);\n         wbcx.tables.used_trait_imports = used_trait_imports;\n \n+        wbcx.tables.tainted_by_errors = self.is_tainted_by_errors();\n+\n         self.tcx.alloc_tables(wbcx.tables)\n     }\n }\n@@ -195,19 +194,11 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.visit_node_id(ResolvingExpr(s.span), s.node.id());\n         intravisit::walk_stmt(self, s);\n     }\n \n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.fix_scalar_builtin_expr(e);\n \n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n@@ -227,29 +218,16 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.visit_node_id(ResolvingExpr(b.span), b.id);\n         intravisit::walk_block(self, b);\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         self.visit_node_id(ResolvingPattern(p.span), p.id);\n-\n         intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n         self.write_ty_to_tables(l.id, var_ty);\n@@ -259,10 +237,6 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_upvar_borrow_map(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return;\n-        }\n-\n         for (upvar_id, upvar_capture) in self.fcx.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n@@ -281,10 +255,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_closures(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n             self.tables.closure_tys.insert(id, closure_ty);\n@@ -296,27 +266,15 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_cast_types(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n         self.tables.cast_kinds.extend(\n             self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n     }\n \n     fn visit_lints(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n         self.fcx.tables.borrow_mut().lints.transfer(&mut self.tables.lints);\n     }\n \n     fn visit_anon_types(&mut self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n         let gcx = self.tcx().global_tcx();\n         for (&node_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n             let reason = ResolvingAnonTy(node_id);\n@@ -542,7 +500,6 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    writeback_errors: &'cx Cell<bool>,\n     reason: ResolveReason,\n }\n \n@@ -551,22 +508,19 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n            reason: ResolveReason)\n            -> Resolver<'cx, 'gcx, 'tcx>\n     {\n-        Resolver::from_infcx(fcx, &fcx.writeback_errors, reason)\n+        Resolver::from_infcx(fcx, reason)\n     }\n \n     fn from_infcx(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-                  writeback_errors: &'cx Cell<bool>,\n                   reason: ResolveReason)\n                   -> Resolver<'cx, 'gcx, 'tcx>\n     {\n         Resolver { infcx: infcx,\n                    tcx: infcx.tcx,\n-                   writeback_errors: writeback_errors,\n                    reason: reason }\n     }\n \n     fn report_error(&self, e: FixupError) {\n-        self.writeback_errors.set(true);\n         if !self.tcx.sess.has_errors() {\n             match self.reason {\n                 ResolvingExpr(span) => {"}, {"sha": "7f413a0dfc3aba59ce1a3e27f7ed6e75e0f23112", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -59,7 +59,6 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use middle::resolve_lifetime as rl;\n-use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n use rustc::ty::{ToPredicate, ReprOptions};\n@@ -75,7 +74,7 @@ use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n \n-use syntax::{abi, ast, attr};\n+use syntax::{abi, ast};\n use syntax::codemap::Spanned;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -596,6 +595,17 @@ fn convert_variant_ctor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.item_predicates(def_id);\n }\n \n+fn evaluate_disr_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                body: hir::BodyId)\n+                                -> Result<ConstVal<'tcx>, ()> {\n+    let e = &tcx.hir.body(body).value;\n+    ConstContext::new(tcx, body).eval(e).map_err(|err| {\n+        // enum variant evaluation happens before the global constant check\n+        // so we need to report the real error\n+        report_const_eval_err(tcx, &err, e.span, \"enum discriminant\");\n+    })\n+}\n+\n fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId,\n                                         variants: &[hir::Variant]) {\n@@ -610,7 +620,7 @@ fn convert_enum_variant_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         prev_discr = Some(if let Some(e) = variant.node.disr_expr {\n             let expr_did = tcx.hir.local_def_id(e.node_id);\n             let result = tcx.maps.monomorphic_const_eval.memoize(expr_did, || {\n-                evaluate_disr_expr(tcx, repr_type, e).map(ConstVal::Integral)\n+                evaluate_disr_expr(tcx, e)\n             });\n \n             match result {\n@@ -738,60 +748,6 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tcx.alloc_adt_def(def_id, kind, variants, repr)\n }\n \n-fn evaluate_disr_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                repr_ty: attr::IntType,\n-                                body: hir::BodyId)\n-                      -> Result<ConstInt, ()> {\n-    let e = &tcx.hir.body(body).value;\n-    debug!(\"disr expr, checking {}\", tcx.hir.node_to_pretty_string(e.id));\n-\n-    let ty_hint = repr_ty.to_ty(tcx);\n-    let print_err = |cv: ConstVal| {\n-        struct_span_err!(tcx.sess, e.span, E0079, \"mismatched types\")\n-            .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n-            .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n-            .emit();\n-    };\n-\n-    let hint = UncheckedExprHint(ty_hint);\n-    match ConstContext::new(tcx, body).eval(e, hint) {\n-        Ok(ConstVal::Integral(i)) => {\n-            // FIXME: eval should return an error if the hint does not match the type of the body.\n-            // i.e. eventually the match below would not exist.\n-            match (repr_ty, i) {\n-                (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n-                (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n-                (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n-                (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n-                (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n-                (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n-                (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n-                (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n-                (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n-                (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n-                (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n-                (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Ok(i),\n-                (_, i) => {\n-                    print_err(ConstVal::Integral(i));\n-                    Err(())\n-                },\n-            }\n-        },\n-        Ok(cv) => {\n-            print_err(cv);\n-            Err(())\n-        },\n-        // enum variant evaluation happens before the global constant check\n-        // so we need to report the real error\n-        Err(err) => {\n-            let mut diag = report_const_eval_err(\n-                tcx, &err, e.span, \"enum discriminant\");\n-            diag.emit();\n-            Err(())\n-        }\n-    }\n-}\n-\n /// Ensures that the super-predicates of the trait with def-id\n /// trait_def_id are converted and stored. This also ensures that\n /// the transitive super-predicates are converted;"}, {"sha": "644e323a8dbf2ce1d6d86cacf4912693d697c228", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -1039,45 +1039,6 @@ struct Good(u32, u32, u32);\n ```\n \"##,\n \n-E0079: r##\"\n-Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an integer\n-literal and is therefore invalid.\n-\n-For example, in the following code:\n-\n-```compile_fail,E0079\n-enum Foo {\n-    Q = \"32\",\n-}\n-```\n-\n-We try to set the representation to a string.\n-\n-There's no general fix for this; if you can work with an integer then just set\n-it to one:\n-\n-```\n-enum Foo {\n-    Q = 32,\n-}\n-```\n-\n-However if you actually wanted a mapping between variants and non-integer\n-objects, it may be preferable to use a method with a match instead:\n-\n-```\n-enum Foo { Q }\n-impl Foo {\n-    fn get_str(&self) -> &'static str {\n-        match *self {\n-            Foo::Q => \"32\",\n-        }\n-    }\n-}\n-```\n-\"##,\n-\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -1427,6 +1388,44 @@ struct Baz<'a> {\n ```\n \"##,\n \n+E0109: r##\"\n+You tried to give a type parameter to a type which doesn't need it. Erroneous\n+code example:\n+\n+```compile_fail,E0109\n+type X = u32<i32>; // error: type parameters are not allowed on this type\n+```\n+\n+Please check that you used the correct type and recheck its definition. Perhaps\n+it doesn't need the type parameter.\n+\n+Example:\n+\n+```\n+type X = u32; // this compiles\n+```\n+\n+Note that type parameters for enum-variant constructors go after the variant,\n+not after the enum (Option::None::<u32>, not Option::<u32>::None).\n+\"##,\n+\n+E0110: r##\"\n+You tried to give a lifetime parameter to a type which doesn't need it.\n+Erroneous code example:\n+\n+```compile_fail,E0110\n+type X = u32<'static>; // error: lifetime parameters are not allowed on\n+                       //        this type\n+```\n+\n+Please check that the correct type was used and recheck its definition; perhaps\n+it doesn't need the lifetime parameter. Example:\n+\n+```\n+type X = u32; // ok!\n+```\n+\"##,\n+\n E0116: r##\"\n You can only define an inherent implementation for a type in the same crate\n where the type was defined. For example, an `impl` block as below is not allowed\n@@ -2649,6 +2648,41 @@ fn main() {\n ```\n \"##,\n \n+E0229: r##\"\n+An associated type binding was done outside of the type parameter declaration\n+and `where` clause. Erroneous code example:\n+\n+```compile_fail,E0229\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for isize {\n+    type A = usize;\n+    fn boo(&self) -> usize { 42 }\n+}\n+\n+fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n+// error: associated type bindings are not allowed here\n+```\n+\n+To solve this error, please move the type bindings in the type parameter\n+declaration:\n+\n+```ignore\n+fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n+```\n+\n+Or in the `where` clause:\n+\n+```ignore\n+fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n+```\n+\"##,\n+\n E0230: r##\"\n The trait has more type parameters specified than appear in its definition.\n "}, {"sha": "9ffaef7472b7830d4c5b259589c4109cd66350ff", "filename": "src/test/compile-fail/E0306.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2FE0306.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c832e6f3272fd01e22a6370e7745e305fe13a4c9/src%2Ftest%2Fcompile-fail%2FE0306.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0306.rs?ref=c832e6f3272fd01e22a6370e7745e305fe13a4c9", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-const A: [u32; \"hello\"] = [];\n-//~^ ERROR expected `usize` for array length, found string literal [E0306]\n-//~| NOTE expected `usize`\n-\n-const B: [u32; true] = [];\n-//~^ ERROR expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n-\n-const C: [u32; 0.0] = [];\n-//~^ ERROR expected `usize` for array length, found float [E0306]\n-//~| NOTE expected `usize`\n-\n-fn main() {\n-}"}, {"sha": "7f77ae2ec1f10ec4b954b29e780527dead31b99b", "filename": "src/test/compile-fail/associated-const-array-len.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -14,7 +14,8 @@ trait Foo {\n     const ID: usize;\n }\n \n-const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0080\n+const X: [i32; <i32 as Foo>::ID] = [0, 1, 2];\n+//~^ ERROR the trait bound `i32: Foo` is not satisfied\n \n fn main() {\n     assert_eq!(1, X);"}, {"sha": "7fd9605ef2cdc6323b7177cd822272e9e1e748a0", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -27,8 +27,6 @@ impl Foo for Def {\n pub fn test<A: Foo, B: Foo>() {\n     let _array = [4; <A as Foo>::Y];\n     //~^ ERROR cannot use an outer type parameter in this context [E0402]\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "71c7a3965ec3c8c5af96d6211de60b14cf3ca692", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -27,8 +27,6 @@ impl Foo for Def {\n pub fn test<A: Foo, B: Foo>() {\n     let _array: [u32; <A as Foo>::Y];\n     //~^ ERROR cannot use an outer type parameter in this context [E0402]\n-    //~| ERROR constant evaluation error [E0080]\n-    //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "108b7948dfcc20c981cc9ba88abebca27c909d5b", "filename": "src/test/compile-fail/const-array-oob.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -12,8 +12,8 @@\n \n #![feature(const_indexing)]\n \n-const FOO: [u32; 3] = [1, 2, 3];\n-const BAR: u32 = FOO[5]; // no error, because the error below occurs before regular const eval\n+const FOO: [usize; 3] = [1, 2, 3];\n+const BAR: usize = FOO[5]; // no error, because the error below occurs before regular const eval\n \n const BLUB: [u32; FOO[4]] = [5, 6];\n //~^ ERROR constant evaluation error [E0080]"}, {"sha": "02072e9a1a1f6ab5e298a281e6aa16564dc84786", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -20,8 +20,9 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n-    //~^ ERROR constant evaluation error [E0080]\n+    //~^ ERROR mismatched types\n     //~| expected i8, found u8\n+    //~| ERROR the trait bound `i8: std::ops::Add<u8>` is not satisfied\n     = [0; (i8::MAX as usize) + 1];\n \n \n@@ -32,8 +33,7 @@ const A_CHAR_USIZE\n \n const A_BAD_CHAR_USIZE\n     : [u32; 5i8 as char as usize]\n-    //~^ ERROR constant evaluation error\n-    //~| only `u8` can be cast as `char`, not `i8`\n+    //~^ ERROR only `u8` can be cast as `char`, not `i8`\n     = [0; 5];\n \n fn main() {}"}, {"sha": "16f89606b01e6da87a20f6781b2c5bfa6991c2d7", "filename": "src/test/compile-fail/const-eval-span.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -14,12 +14,13 @@\n struct S(i32);\n \n const CONSTANT: S = S(0);\n-//~^ ERROR E0080\n-//~| unimplemented constant expression: tuple struct constructors\n \n enum E {\n     V = CONSTANT,\n-    //~^ NOTE: for enum discriminant here\n+    //~^ ERROR mismatched types\n+    //~| expected isize, found struct `S`\n+    //~| NOTE expected type `isize`\n+    //~|         found type `S`\n }\n \n fn main() {}"}, {"sha": "29bc665a22e7bbe5ed3c4b071ae847d2a3719f5e", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 49, "deletions": 30, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -8,52 +8,71 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const X: usize = 42 && 39; //~ ERROR E0080\n-                           //~| can't do this op on integrals\n-const ARR: [i32; X] = [99; 34]; //~ NOTE: for array length here\n+const X: usize = 42 && 39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR: [i32; X] = [99; 34];\n \n-const X1: usize = 42 || 39; //~ ERROR E0080\n-                            //~| can't do this op on integrals\n-const ARR1: [i32; X1] = [99; 47]; //~ NOTE: for array length here\n+const X1: usize = 42 || 39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR1: [i32; X1] = [99; 47];\n \n-const X2: usize = -42 || -39; //~ ERROR E0080\n-                              //~| unary negation of unsigned integer\n-const ARR2: [i32; X2] = [99; 18446744073709551607]; //~ NOTE: for array length here\n+const X2: usize = -42 || -39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR2: [i32; X2] = [99; 18446744073709551607];\n \n-const X3: usize = -42 && -39; //~ ERROR E0080\n-                              //~| unary negation of unsigned integer\n-const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n+const X3: usize = -42 && -39;\n+//~^ ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected bool, found integral variable\n+//~| ERROR mismatched types\n+//~| expected usize, found bool\n+const ARR3: [i32; X3] = [99; 6];\n \n const Y: usize = 42.0 == 42.0;\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n const ARRR: [i32; Y] = [99; 1];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n \n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR1: [i32; Y1] = [99; 1];\n \n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR2: [i32; Y2] = [99; 1];\n \n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR3: [i32; Y3] = [99; 0];\n \n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR4: [i32; Y4] = [99; 0];\n \n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0];\n-//~^ ERROR: expected `usize` for array length, found boolean [E0306]\n-//~| NOTE expected `usize`\n-\n+//~^ ERROR mismatched types\n+//~| expected usize, found bool\n+const ARRR5: [i32; Y5] = [99; 0];\n \n fn main() {\n     let _ = ARR;"}, {"sha": "b42c440f87d74e3678dfc6bf79c8d32a5e5ee7d8", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -11,8 +11,8 @@\n // Test spans of errors\n \n const TUP: (usize,) = 5usize << 64;\n-//~^ ERROR E0080\n-//~| attempt to shift left with overflow\n+//~^ ERROR mismatched types\n+//~| expected tuple, found usize\n const ARR: [i32; TUP.0] = [];\n \n fn main() {"}, {"sha": "62e54c3f23773ab1f42bec31aee796eb13aaf10a", "filename": "src/test/compile-fail/discrim-ill-typed.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -25,7 +25,7 @@ fn f_i8() {\n         Ok = i8::MAX - 1,\n         Ok2,\n         OhNo = 0_u8,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i8, found u8\n     }\n \n@@ -38,7 +38,7 @@ fn f_u8() {\n         Ok = u8::MAX - 1,\n         Ok2,\n         OhNo = 0_i8,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u8, found i8\n     }\n \n@@ -51,7 +51,7 @@ fn f_i16() {\n         Ok = i16::MAX - 1,\n         Ok2,\n         OhNo = 0_u16,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i16, found u16\n     }\n \n@@ -64,7 +64,7 @@ fn f_u16() {\n         Ok = u16::MAX - 1,\n         Ok2,\n         OhNo = 0_i16,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u16, found i16\n     }\n \n@@ -77,7 +77,7 @@ fn f_i32() {\n         Ok = i32::MAX - 1,\n         Ok2,\n         OhNo = 0_u32,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i32, found u32\n     }\n \n@@ -90,7 +90,7 @@ fn f_u32() {\n         Ok = u32::MAX - 1,\n         Ok2,\n         OhNo = 0_i32,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u32, found i32\n     }\n \n@@ -103,7 +103,7 @@ fn f_i64() {\n         Ok = i64::MAX - 1,\n         Ok2,\n         OhNo = 0_u64,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected i64, found u64\n     }\n \n@@ -116,7 +116,7 @@ fn f_u64() {\n         Ok = u64::MAX - 1,\n         Ok2,\n         OhNo = 0_i64,\n-        //~^ ERROR E0080\n+        //~^ ERROR mismatched types\n         //~| expected u64, found i64\n     }\n "}, {"sha": "393a67be57fe6b73daec83ae71929d4d7c310b8a", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -13,32 +13,32 @@\n enum Eu8 {\n     Au8 = 23,\n     Bu8 = 223,\n-    Cu8 = -23, //~ ERROR E0080\n-               //~| unary negation of unsigned integer\n+    Cu8 = -23,\n+    //~^ ERROR cannot apply unary operator `-` to type `u8`\n }\n \n #[repr(u16)]\n enum Eu16 {\n     Au16 = 23,\n     Bu16 = 55555,\n-    Cu16 = -22333, //~ ERROR E0080\n-                   //~| unary negation of unsigned integer\n+    Cu16 = -22333,\n+    //~^ ERROR cannot apply unary operator `-` to type `u16`\n }\n \n #[repr(u32)]\n enum Eu32 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR E0080\n-                           //~| unary negation of unsigned integer\n+    Cu32 = -2_000_000_000,\n+    //~^ ERROR cannot apply unary operator `-` to type `u32`\n }\n \n #[repr(u64)]\n enum Eu64 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR E0080\n-                           //~| unary negation of unsigned integer\n+    Cu32 = -2_000_000_000,\n+    //~^ ERROR cannot apply unary operator `-` to type `u64`\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "ab839e7630de907904093b4f3ac54e70285a7f0b", "filename": "src/test/compile-fail/invalid-path-in-const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -10,6 +10,5 @@\n \n fn main() {\n     fn f(a: [u8; u32::DOESNOTEXIST]) {}\n-    //~^ ERROR constant evaluation error\n-    //~| unresolved path in constant expression\n+    //~^ ERROR no associated item named `DOESNOTEXIST` found for type `u32`\n }"}, {"sha": "c78e1f7f5309505689b74c03c6d0f70e9f1b800c", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -12,12 +12,10 @@ enum Delicious {\n     Pie      = 0x1,\n     Apple    = 0x2,\n     ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n-    //~^ ERROR constant evaluation error\n-    //~| unresolved path in constant expression\n+    //~^ ERROR no associated item named `PIE` found for type `Delicious`\n }\n \n const FOO: [u32; u8::MIN as usize] = [];\n-//~^ ERROR constant evaluation error\n-//~| unresolved path in constant expression\n+//~^ ERROR no associated item named `MIN` found for type `u8`\n \n fn main() {}"}, {"sha": "95f6526f11559e835f37a126c6a20e17d7a297d2", "filename": "src/test/compile-fail/issue-23217.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -10,8 +10,7 @@\n \n pub enum SomeEnum {\n     B = SomeEnum::A,\n-    //~^ ERROR constant evaluation error\n-    //~| unresolved path in constant expression\n+    //~^ ERROR no associated item named `A` found for type `SomeEnum`\n }\n \n fn main() {}"}, {"sha": "b8571d2e85e2c8bfae4f42a6238a5e7a37aa337c", "filename": "src/test/compile-fail/issue-28586.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -11,6 +11,7 @@\n // Regression test for issue #28586\n \n pub trait Foo {}\n-impl Foo for [u8; usize::BYTES] {} //~ ERROR E0080\n+impl Foo for [u8; usize::BYTES] {}\n+//~^ ERROR no associated item named `BYTES` found for type `usize`\n \n fn main() { }"}, {"sha": "aac8b89e882b3b7f6adcec6367a7f13e25190e90", "filename": "src/test/compile-fail/issue-31910.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-31910.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-31910.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31910.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -11,7 +11,9 @@\n #![feature(associated_consts)]\n \n enum Enum<T: Trait> {\n-    X = Trait::Number, //~ ERROR constant evaluation error\n+    X = Trait::Number,\n+    //~^ ERROR mismatched types\n+    //~| expected isize, found i32\n }\n \n trait Trait {"}, {"sha": "78af11a0b5813ebc0a032382c6def694fd87b387", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -15,9 +15,7 @@ fn main() {\n     enum Stuff {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n-        //~^^ ERROR constant evaluation error\n-        //~| unresolved path in constant expression\n     }\n \n-    println!(\"{}\", Stuff::Bar);\n+    println!(\"{:?}\", Stuff::Bar);\n }"}, {"sha": "bc492806b96c18dd04dfaf4b4b38e2941e50ce3f", "filename": "src/test/compile-fail/issue-39559.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-39559.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -23,9 +23,13 @@ impl Dim for Dim3 {\n pub struct Vector<T, D: Dim> {\n     entries: [T; D::dim()]\n     //~^ ERROR cannot use an outer type parameter in this context\n-    //~| ERROR constant evaluation error\n }\n \n fn main() {\n-    let array: [usize; Dim3::dim()] = [0; Dim3::dim()];\n+    let array: [usize; Dim3::dim()]\n+    //~^ ERROR constant evaluation error\n+    //~| non-constant path in constant expression\n+        = [0; Dim3::dim()];\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n }"}, {"sha": "f8424ea64ef9e29794a76aa621eb0e974e34b075", "filename": "src/test/compile-fail/issue-8761.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -10,10 +10,10 @@\n \n enum Foo {\n     A = 1i64,\n-    //~^ ERROR constant evaluation error\n+    //~^ ERROR mismatched types\n     //~| expected isize, found i64\n     B = 2u8\n-    //~^ ERROR constant evaluation error\n+    //~^ ERROR mismatched types\n     //~| expected isize, found u8\n }\n "}, {"sha": "52cd4e8a3ed95122a8683b43c3944fde46f82e2b", "filename": "src/test/compile-fail/non-constant-expr-for-fixed-len-vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-fixed-len-vec.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -14,6 +14,5 @@ fn main() {\n     fn bar(n: isize) {\n         let _x: [isize; n];\n         //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n-        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "1eda5087784029be6f3aa30a76c95c035b6fa942", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -15,7 +15,5 @@ fn main() {\n         let _x = [0; n];\n         //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n         //~| NOTE non-constant used with constant\n-        //~| NOTE unresolved path in constant expression\n-        //~| ERROR constant evaluation error [E0080]\n     }\n }"}, {"sha": "6e80a9174676a1247515fae79095f52fc17a9899", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -17,7 +17,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyBranches.initial-before.mir\n // bb0: {\n-//     switchInt(const false) -> [0: bb2, otherwise: bb1];\n+//     switchInt(const false) -> [0u8: bb2, otherwise: bb1];\n // }\n // END rustc.node4.SimplifyBranches.initial-before.mir\n // START rustc.node4.SimplifyBranches.initial-after.mir"}, {"sha": "6f02f2783818e281ddb446ac48e2e0cec6ab0345", "filename": "src/test/run-pass/issue-25145.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Frun-pass%2Fissue-25145.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Frun-pass%2Fissue-25145.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25145.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -17,7 +17,7 @@ impl S {\n }\n \n static STUFF: [u8; S::N] = [0; S::N];\n-//~^ ERROR constant evaluation error\n-//~| unresolved path in constant expression\n \n-fn main() {}\n+fn main() {\n+    assert_eq!(STUFF, [0; 3]);\n+}", "previous_filename": "src/test/compile-fail/issue-25145.rs"}, {"sha": "7da50670d1dee225f9dfc76c2149c1657a903146", "filename": "src/test/run-pass/issue-39548.rs", "status": "renamed", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Frun-pass%2Fissue-39548.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Frun-pass%2Fissue-39548.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39548.rs?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Foo {\n-    Q = \"32\" //~ ERROR E0079\n-    //~^ expected 'isize' type\n-}\n+type Array = [(); ((1 < 2) == false) as usize];\n \n fn main() {\n+    let _: Array = [];\n }", "previous_filename": "src/test/compile-fail/E0079.rs"}, {"sha": "c7c42bcf239405088ebea527aaae1baa55e460cb", "filename": "src/test/ui/resolve/levenshtein.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Flevenshtein.stderr?ref=e7a48821c0d30ccd6b7ea88be24eed1bcba5f48a", "patch": "@@ -46,11 +46,5 @@ error[E0425]: cannot find value `second` in module `m`\n 32 |     let b: m::first = m::second; // Misspelled item in module.\n    |                       ^^^^^^^^^ did you mean `m::Second`?\n \n-error[E0080]: constant evaluation error\n-  --> $DIR/levenshtein.rs:30:20\n-   |\n-30 |     let v = [0u32; MAXITEM]; // Misspelled constant name.\n-   |                    ^^^^^^^ unresolved path in constant expression\n-\n-error: aborting due to previous error\n+error: aborting due to 8 previous errors\n "}]}