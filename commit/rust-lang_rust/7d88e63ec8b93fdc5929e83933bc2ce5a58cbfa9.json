{"sha": "7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkODhlNjNlYzhiOTNmZGM1OTI5ZTgzOTMzYmMyY2U1YTU4Y2JmYTk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-01T22:01:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-01T22:01:46Z"}, "message": "Switch private linkage to local, re-indent trans.rs.", "tree": {"sha": "642e18ddd6e7191e39bd385a91ea7f72938089b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/642e18ddd6e7191e39bd385a91ea7f72938089b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "html_url": "https://github.com/rust-lang/rust/commit/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a8b0be1cbb7b6386e82e329a80c7d09bcb75617", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a8b0be1cbb7b6386e82e329a80c7d09bcb75617", "html_url": "https://github.com/rust-lang/rust/commit/3a8b0be1cbb7b6386e82e329a80c7d09bcb75617"}], "stats": {"total": 140, "additions": 70, "deletions": 70}, "files": [{"sha": "6a61a74fe9242068d9c954549e31ab885e245e03", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7d88e63ec8b93fdc5929e83933bc2ce5a58cbfa9", "patch": "@@ -161,7 +161,7 @@ fn sep() -> str {\n }\n \n fn extend_path(@crate_ctxt cx, str name) -> @crate_ctxt {\n-  ret @rec(path = cx.path + vec(name) with *cx);\n+    ret @rec(path = cx.path + vec(name) with *cx);\n }\n \n fn path_name(vec[str] path) -> str {\n@@ -529,7 +529,7 @@ fn type_of(@crate_ctxt cx, @ty.t t) -> TypeRef {\n }\n \n fn type_of_explicit_args(@crate_ctxt cx,\n-                     vec[ty.arg] inputs) -> vec[TypeRef] {\n+                         vec[ty.arg] inputs) -> vec[TypeRef] {\n     let vec[TypeRef] atys = vec();\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n@@ -765,7 +765,7 @@ fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n }\n \n fn type_of_ty_params_opt_and_ty(@crate_ctxt ccx, ty.ty_params_opt_and_ty tpt)\n-        -> TypeRef {\n+    -> TypeRef {\n     alt (tpt._1.struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n             auto ty_params = option.get[vec[ast.def_id]](tpt._0);\n@@ -859,7 +859,7 @@ fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n                                 _str.buf(cx.names.next(\"str\")));\n     llvm.LLVMSetInitializer(g, sc);\n     llvm.LLVMSetGlobalConstant(g, True);\n-    llvm.LLVMSetLinkage(g, lib.llvm.LLVMPrivateLinkage\n+    llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n                         as llvm.Linkage);\n     ret g;\n }\n@@ -876,7 +876,7 @@ fn C_str(@crate_ctxt cx, str s) -> ValueRef {\n                                 _str.buf(cx.names.next(\"str\")));\n     llvm.LLVMSetInitializer(g, box);\n     llvm.LLVMSetGlobalConstant(g, True);\n-    llvm.LLVMSetLinkage(g, lib.llvm.LLVMPrivateLinkage\n+    llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n                         as llvm.Linkage);\n     ret llvm.LLVMConstPointerCast(g, T_ptr(T_str()));\n }\n@@ -913,10 +913,10 @@ fn decl_fastcall_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n     ret decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n }\n \n-fn decl_private_fastcall_fn(ModuleRef llmod,\n-                            str name, TypeRef llty) -> ValueRef {\n+fn decl_internal_fastcall_fn(ModuleRef llmod,\n+                             str name, TypeRef llty) -> ValueRef {\n     auto llfn = decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n-    llvm.LLVMSetLinkage(llfn, lib.llvm.LLVMPrivateLinkage as llvm.Linkage);\n+    llvm.LLVMSetLinkage(llfn, lib.llvm.LLVMInternalLinkage as llvm.Linkage);\n     ret llfn;\n }\n \n@@ -963,7 +963,7 @@ fn get_extern_const(&hashmap[str, ValueRef] externs,\n }\n \n fn get_simple_extern_fn(&hashmap[str, ValueRef] externs,\n-                     ModuleRef llmod, str name, int n_args) -> ValueRef {\n+                        ModuleRef llmod, str name, int n_args) -> ValueRef {\n     auto inputs = _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n     auto t = T_fn(inputs, output);\n@@ -1361,7 +1361,7 @@ fn GEP_tag(@block_ctxt cx,\n            &ast.def_id variant_id,\n            vec[@ty.t] ty_substs,\n            int ix)\n-        -> result {\n+    -> result {\n     auto ty_params = tag_ty_params(cx.fcx.ccx, tag_id);\n     auto variant = tag_variant_with_id(cx.fcx.ccx, tag_id, variant_id);\n \n@@ -1410,7 +1410,7 @@ fn GEP_tag(@block_ctxt cx,\n \n \n fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n-        -> result {\n+    -> result {\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_int(0);\n     auto rslt = trans_upcall(cx, \"upcall_malloc\", vec(llsize, tydesc));\n@@ -1596,14 +1596,14 @@ fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n \n     llvm.LLVMSetInitializer(gvar, tydesc);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n-    llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMPrivateLinkage\n+    llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMInternalLinkage\n                         as llvm.Linkage);\n \n     auto info = rec(\n-        tydesc=gvar,\n-        take_glue=take_glue,\n-        drop_glue=drop_glue\n-    );\n+                    tydesc=gvar,\n+                    take_glue=take_glue,\n+                    drop_glue=drop_glue\n+                    );\n \n     cx.tydescs.insert(t, @info);\n }\n@@ -1627,7 +1627,7 @@ fn declare_generic_glue(@crate_ctxt cx, @ty.t t, str name) -> ValueRef {\n     auto gcx = @rec(path=vec(\"glue\", name) with *cx);\n     auto fn_name = mangle_name_by_type(gcx, t);\n     fn_name = sanitize(fn_name);\n-    auto llfn = decl_private_fastcall_fn(cx.llmod, fn_name, llfnty);\n+    auto llfn = decl_internal_fastcall_fn(cx.llmod, fn_name, llfnty);\n     ret llfn;\n }\n \n@@ -2098,17 +2098,17 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                 auto v = vec(C_int(0), C_int(j as int));\n \n                                 auto rslt = GEP_tag(variant_cx, llunion_a_ptr,\n-                                    tid, variant.id, tps, j);\n+                                                    tid, variant.id, tps, j);\n                                 auto llfldp_a = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n                                 rslt = GEP_tag(variant_cx, llunion_b_ptr, tid,\n-                                    variant.id, tps, j);\n+                                               variant.id, tps, j);\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n                                 auto ty_subst = ty.substitute_ty_params(\n-                                    ty_params, tps, a.ty);\n+                                                                        ty_params, tps, a.ty);\n \n                                 auto llfld_a =\n                                     load_scalar_or_boxed(variant_cx,\n@@ -2330,8 +2330,8 @@ fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n }\n \n fn take_ty(@block_ctxt cx,\n-                    ValueRef v,\n-                    @ty.t t) -> result {\n+           ValueRef v,\n+           @ty.t t) -> result {\n     if (!ty.type_is_scalar(t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue_off);\n     }\n@@ -3163,11 +3163,11 @@ fn trans_for(@block_ctxt cx,\n // Searches through a block for all references to locals or upvars in this\n // frame and returns the list of definition IDs thus found.\n fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n-        -> vec[ast.def_id] {\n+    -> vec[ast.def_id] {\n     type env = @rec(\n-        mutable vec[ast.def_id] refs,\n-        hashmap[ast.def_id,()] decls\n-    );\n+                    mutable vec[ast.def_id] refs,\n+                    hashmap[ast.def_id,()] decls\n+                    );\n \n     fn fold_expr_path(&env e, &common.span sp, &ast.path p,\n                       &option.t[ast.def] d, ast.ann a) -> @ast.expr {\n@@ -3182,18 +3182,18 @@ fn collect_upvars(@block_ctxt cx, &ast.block bloc, &ast.def_id initial_decl)\n     }\n \n     fn fold_decl_local(&env e, &common.span sp, @ast.local local)\n-            -> @ast.decl {\n+        -> @ast.decl {\n         e.decls.insert(local.id, ());\n         ret @fold.respan[ast.decl_](sp, ast.decl_local(local));\n     }\n \n     auto fep = fold_expr_path;\n     auto fdl = fold_decl_local;\n     auto fld = @rec(\n-        fold_expr_path=fep,\n-        fold_decl_local=fdl\n-        with *fold.new_identity_fold[env]()\n-    );\n+                    fold_expr_path=fep,\n+                    fold_decl_local=fdl\n+                    with *fold.new_identity_fold[env]()\n+                    );\n \n     let vec[ast.def_id] refs = vec();\n     let hashmap[ast.def_id,()] decls = new_def_hash[()]();\n@@ -3319,8 +3319,8 @@ fn trans_for_each(@block_ctxt cx,\n                                           vec(rec(mode=ast.val, ty=decl_ty)),\n                                           plain_ty(ty.ty_nil), 0u);\n \n-    let ValueRef lliterbody = decl_private_fastcall_fn(cx.fcx.ccx.llmod,\n-                                                       s, iter_body_llty);\n+    let ValueRef lliterbody = decl_internal_fastcall_fn(cx.fcx.ccx.llmod,\n+                                                        s, iter_body_llty);\n \n     // FIXME: handle ty params properly.\n     let vec[ast.ty_param] ty_params = vec();\n@@ -3332,7 +3332,7 @@ fn trans_for_each(@block_ctxt cx,\n     // Populate the upvars from the environment.\n     auto llremoteenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n     auto llremotebindingsptrptr = bcx.build.GEP(llremoteenvptr,\n-        vec(C_int(0), C_int(abi.box_rc_field_body), C_int(2)));\n+                                                vec(C_int(0), C_int(abi.box_rc_field_body), C_int(2)));\n     auto llremotebindingsptr = bcx.build.Load(llremotebindingsptrptr);\n \n     auto i = 0u;\n@@ -3377,7 +3377,7 @@ fn trans_for_each(@block_ctxt cx,\n             auto env_cell = cx.build.GEP(pair, vec(C_int(0),\n                                                    C_int(abi.fn_field_box)));\n             auto llenvblobptr = cx.build.PointerCast(llenvptr,\n-                T_opaque_closure_ptr(cx.fcx.ccx.tn));\n+                                                     T_opaque_closure_ptr(cx.fcx.ccx.tn));\n             cx.build.Store(llenvblobptr, env_cell);\n \n             // log \"lliterbody: \" + val_str(cx.fcx.ccx.tn, lliterbody);\n@@ -3448,7 +3448,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n         case (ast.pat_tag(?id, ?subpats, ?vdef_opt, ?ann)) {\n             auto lltagptr = cx.build.PointerCast(llval,\n-                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+                                                 T_opaque_tag_ptr(cx.fcx.ccx.tn));\n \n             auto lldiscrimptr = cx.build.GEP(lltagptr,\n                                              vec(C_int(0), C_int(0)));\n@@ -3479,7 +3479,7 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n \n             if (_vec.len[@ast.pat](subpats) > 0u) {\n                 auto llblobptr = matched_cx.build.GEP(lltagptr,\n-                    vec(C_int(0), C_int(1)));\n+                                                      vec(C_int(0), C_int(1)));\n                 auto i = 0;\n                 for (@ast.pat subpat in subpats) {\n                     auto rslt = GEP_tag(matched_cx, llblobptr, vdef._0,\n@@ -3529,7 +3529,7 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n             auto vdef = option.get[ast.variant_def](vdef_opt);\n \n             auto lltagptr = cx.build.PointerCast(llval,\n-                T_opaque_tag_ptr(cx.fcx.ccx.tn));\n+                                                 T_opaque_tag_ptr(cx.fcx.ccx.tn));\n             auto llblobptr = cx.build.GEP(lltagptr, vec(C_int(0), C_int(1)));\n \n             auto ty_param_substs = node_ann_ty_params(ann);\n@@ -3625,7 +3625,7 @@ fn lval_generic_fn(@block_ctxt cx,\n                    ty.ty_params_and_ty tpt,\n                    ast.def_id fn_id,\n                    &ast.ann ann)\n-        -> lval_result {\n+    -> lval_result {\n     auto lv;\n     if (cx.fcx.ccx.sess.get_targ_crate_num() == fn_id._0) {\n         // Internal reference.\n@@ -3704,12 +3704,12 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_fn(?did)) {\n                     auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, did);\n+                                                           cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n                     auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, did);\n+                                                           cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n@@ -3746,10 +3746,10 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                             lltagty = type_of(cx.fcx.ccx, tag_ty);\n                         }\n                         auto lltagptr = alloc_result.bcx.build.PointerCast(\n-                            lltagblob, T_ptr(lltagty));\n+                                                                           lltagblob, T_ptr(lltagty));\n \n                         auto lldiscrimptr = alloc_result.bcx.build.GEP(\n-                            lltagptr, vec(C_int(0), C_int(0)));\n+                                                                       lltagptr, vec(C_int(0), C_int(0)));\n                         alloc_result.bcx.build.Store(lldiscrim, lldiscrimptr);\n \n                         ret lval_val(alloc_result.bcx, lltagptr);\n@@ -3762,7 +3762,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                 }\n                 case (ast.def_native_fn(?did)) {\n                     auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n-                        cx.fcx.ccx.type_cache, did);\n+                                                           cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (_) {\n@@ -3898,7 +3898,7 @@ fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n         } else if (ty.type_is_native(t)) {\n             e_res.val = e_res.bcx.build.IntToPtr(e_res.val, lldsttype);\n         } else if (llvm.LLVMGetIntTypeWidth(lldsttype) >\n-            llvm.LLVMGetIntTypeWidth(llsrctype)) {\n+                   llvm.LLVMGetIntTypeWidth(llsrctype)) {\n             if (ty.type_is_signed(t)) {\n                 // Widening signed cast.\n                 e_res.val =\n@@ -3934,7 +3934,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n \n     let str s = mangle_name_by_seq(cx, \"thunk\");\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx, incoming_fty));\n-    let ValueRef llthunk = decl_private_fastcall_fn(cx.llmod, s, llthunk_ty);\n+    let ValueRef llthunk = decl_internal_fastcall_fn(cx.llmod, s, llthunk_ty);\n \n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n@@ -4435,11 +4435,11 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n     auto llretslot = args_res._2;\n \n     /*\n-    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n+      log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n \n-    for (ValueRef arg in llargs) {\n-        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n-    }\n+      for (ValueRef arg in llargs) {\n+      log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n+      }\n     */\n \n     bcx.build.FastCall(faddr, llargs);\n@@ -4499,11 +4499,11 @@ fn trans_call_self(@block_ctxt cx, @ast.expr f,\n     auto llretslot = args_res._2;\n \n     /*\n-    log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n+      log \"calling: \" + val_str(cx.fcx.ccx.tn, faddr);\n \n-    for (ValueRef arg in llargs) {\n-        log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n-    }\n+      for (ValueRef arg in llargs) {\n+      log \"arg: \" + val_str(cx.fcx.ccx.tn, arg);\n+      }\n     */\n \n     bcx.build.FastCall(faddr, llargs);\n@@ -5152,7 +5152,7 @@ fn trans_recv(@block_ctxt cx, @ast.expr lhs, @ast.expr rhs,\n \n     // FIXME: calculate copy init-ness in typestate.\n     ret recv_val(bcx, data.res.val, rhs, unit_ty, DROP_EXISTING);\n- }\n+}\n \n fn recv_val(@block_ctxt cx, ValueRef lhs, @ast.expr rhs,\n             @ty.t unit_ty, copy_action action) -> result {\n@@ -5629,14 +5629,14 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, ValueRef llself) {\n     box_ptr = bcx.build.PointerCast(box_ptr, llobj_box_ty);\n \n     auto obj_typarams = bcx.build.GEP(box_ptr,\n-                                     vec(C_int(0),\n-                                         C_int(abi.box_rc_field_body),\n-                                         C_int(abi.obj_body_elt_typarams)));\n+                                      vec(C_int(0),\n+                                          C_int(abi.box_rc_field_body),\n+                                          C_int(abi.obj_body_elt_typarams)));\n \n     // The object fields immediately follow the type parameters, so we skip\n     // over them to get the pointer.\n     auto obj_fields = bcx.build.Add(vp2i(bcx, obj_typarams),\n-        llsize_of(llvm.LLVMGetElementType(val_ty(obj_typarams))));\n+                                    llsize_of(llvm.LLVMGetElementType(val_ty(obj_typarams))));\n \n     // If we can (i.e. the type is statically sized), then cast the resulting\n     // fields pointer to the appropriate LLVM type. If not, just leave it as\n@@ -5735,7 +5735,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n \n         let @crate_ctxt mcx = extend_path(cx, m.node.ident);\n         let str s = mangle_name_by_seq(mcx, \"method\");\n-        let ValueRef llfn = decl_private_fastcall_fn(cx.llmod, s, llfnty);\n+        let ValueRef llfn = decl_internal_fastcall_fn(cx.llmod, s, llfnty);\n         cx.item_ids.insert(m.node.id, llfn);\n         cx.item_symbols.insert(m.node.id, s);\n \n@@ -5749,7 +5749,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n                                    _str.buf(vtbl_name));\n     llvm.LLVMSetInitializer(gvar, vtbl);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n-    llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMPrivateLinkage\n+    llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMInternalLinkage\n                         as llvm.Linkage);\n     ret gvar;\n }\n@@ -5938,12 +5938,12 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         auto llargptr = bcx.build.PointerCast(fcx.llargs.get(va.id),\n-            val_ty(lldestptr));\n+                                              val_ty(lldestptr));\n \n         auto arg_ty = arg_tys.(i).ty;\n         auto llargval;\n         if (ty.type_is_structural(arg_ty) ||\n-                ty.type_has_dynamic_size(arg_ty)) {\n+            ty.type_has_dynamic_size(arg_ty)) {\n             llargval = llargptr;\n         } else {\n             llargval = bcx.build.Load(llargptr);\n@@ -6054,7 +6054,7 @@ fn decl_fn_and_pair(@crate_ctxt cx,\n \n     // Declare the function itself.\n     let str s = mangle_name_by_seq(cx, flav);\n-    let ValueRef llfn = decl_private_fastcall_fn(cx.llmod, s, llfty);\n+    let ValueRef llfn = decl_internal_fastcall_fn(cx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n     let str ps = mangle_name_by_type(cx, node_ann_type(cx, ann));\n@@ -6098,7 +6098,7 @@ fn native_fn_ty_param_count(@crate_ctxt cx, &ast.def_id id) -> uint {\n }\n \n fn native_fn_wrapper_type(@crate_ctxt cx, uint ty_param_count, &ast.ann ann)\n-        -> TypeRef {\n+    -> TypeRef {\n     auto x = node_ann_type(cx, ann);\n     alt (x.struct) {\n         case (ty.ty_native_fn(?abi, ?args, ?out)) {\n@@ -6117,8 +6117,8 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n     // Declare the wrapper.\n     auto wrapper_type = native_fn_wrapper_type(cx, num_ty_param, ann);\n     let str s = mangle_name_by_seq(cx, \"wrapper\");\n-    let ValueRef wrapper_fn = decl_private_fastcall_fn(cx.llmod, s,\n-                                                       wrapper_type);\n+    let ValueRef wrapper_fn = decl_internal_fastcall_fn(cx.llmod, s,\n+                                                        wrapper_type);\n \n     // Declare the global constant pair that points to it.\n     auto wrapper_pair_type = T_fn_pair(cx.tn, wrapper_type);\n@@ -6248,7 +6248,7 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n             auto typ = node_ann_type(cx, ann);\n             auto g = llvm.LLVMAddGlobal(cx.llmod, type_of(cx, typ),\n                                         _str.buf(cx.names.next(name)));\n-            llvm.LLVMSetLinkage(g, lib.llvm.LLVMPrivateLinkage\n+            llvm.LLVMSetLinkage(g, lib.llvm.LLVMInternalLinkage\n                                 as llvm.Linkage);\n             cx.items.insert(cid, i);\n             cx.consts.insert(cid, g);\n@@ -6378,7 +6378,7 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n                 // to figure out what name they get first!\n                 llvm.LLVMSetInitializer(discrim_gvar, discrim_val);\n                 llvm.LLVMSetGlobalConstant(discrim_gvar, True);\n-                llvm.LLVMSetLinkage(discrim_gvar, lib.llvm.LLVMPrivateLinkage\n+                llvm.LLVMSetLinkage(discrim_gvar, lib.llvm.LLVMInternalLinkage\n                                     as llvm.Linkage);\n \n                 cx.discrims.insert(variant.node.id, discrim_gvar);\n@@ -6873,7 +6873,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n     put_vec_fill(copy_src_cx, llnew_vec,\n                  copy_src_cx.build.Add(vec_fill(copy_src_cx,\n                                                 llnew_vec),\n-                                        n_bytes));\n+                                       n_bytes));\n \n     // Write new_vec back through the alias we were given.\n     copy_src_cx.build.Store(llnew_vec, lldst_vec_ptr);"}]}