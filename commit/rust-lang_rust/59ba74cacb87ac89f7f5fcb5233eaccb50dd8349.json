{"sha": "59ba74cacb87ac89f7f5fcb5233eaccb50dd8349", "node_id": "C_kwDOAAsO6NoAKDU5YmE3NGNhY2I4N2FjODlmN2Y1ZmNiNTIzM2VhY2NiNTBkZDgzNDk", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-12-16T18:12:59Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-01-14T19:04:11Z"}, "message": "rustdoc: simplify JS search routine by not messing with lev distance\n\nSince the sorting function accounts for an `index` field, there's not much\nreason to also be applying changes to the levenshtein distance. Instead,\nwe can just not treat `lev` as a filter if there's already a non-sentinel\nvalue for `index`.\n\nThis change gives slightly more weight to the index and path part, as\nsearch criteria, than it used to. This changes some of the test cases,\nbut not in any obviously-\"worse\" way, and, in particular, substring matches\nare a bigger deal than levenshtein distances (we're assuming that a typo\nis less likely than someone just not typing the entire name).\n\nBased on\nhttps://github.com/rust-lang/rust/pull/103710#issuecomment-1296894296", "tree": {"sha": "984fd0b11fea32d0232d95c46d802770cfd34112", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/984fd0b11fea32d0232d95c46d802770cfd34112"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59ba74cacb87ac89f7f5fcb5233eaccb50dd8349", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59ba74cacb87ac89f7f5fcb5233eaccb50dd8349", "html_url": "https://github.com/rust-lang/rust/commit/59ba74cacb87ac89f7f5fcb5233eaccb50dd8349", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59ba74cacb87ac89f7f5fcb5233eaccb50dd8349/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b51adf6ffa1ae2286ea436eb48cbaa8771886e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b51adf6ffa1ae2286ea436eb48cbaa8771886e6", "html_url": "https://github.com/rust-lang/rust/commit/4b51adf6ffa1ae2286ea436eb48cbaa8771886e6"}], "stats": {"total": 114, "additions": 64, "deletions": 50}, "files": [{"sha": "88592fa0c84c1453fbda216b9f3d92eddb0ab307", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/59ba74cacb87ac89f7f5fcb5233eaccb50dd8349/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/59ba74cacb87ac89f7f5fcb5233eaccb50dd8349/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=59ba74cacb87ac89f7f5fcb5233eaccb50dd8349", "patch": "@@ -781,7 +781,29 @@ function initSearch(rawSearchIndex) {\n                     return a - b;\n                 }\n \n-                // Sort by non levenshtein results and then levenshtein results by the distance\n+                // sort by index of keyword in item name (no literal occurrence goes later)\n+                a = (aaa.index < 0);\n+                b = (bbb.index < 0);\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n+                // Sort by distance in the path part, if specified\n+                // (less changes required to match means higher rankings)\n+                a = aaa.path_lev;\n+                b = bbb.path_lev;\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n+                // (later literal occurrence, if any, goes later)\n+                a = aaa.index;\n+                b = bbb.index;\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n+                // Sort by distance in the name part, the last part of the path\n                 // (less changes required to match means higher rankings)\n                 a = (aaa.lev);\n                 b = (bbb.lev);\n@@ -810,19 +832,6 @@ function initSearch(rawSearchIndex) {\n                     return (a > b ? +1 : -1);\n                 }\n \n-                // sort by index of keyword in item name (no literal occurrence goes later)\n-                a = (aaa.index < 0);\n-                b = (bbb.index < 0);\n-                if (a !== b) {\n-                    return a - b;\n-                }\n-                // (later literal occurrence, if any, goes later)\n-                a = aaa.index;\n-                b = bbb.index;\n-                if (a !== b) {\n-                    return a - b;\n-                }\n-\n                 // special precedence for primitive and keyword pages\n                 if ((aaa.item.ty === TY_PRIMITIVE && bbb.item.ty !== TY_KEYWORD) ||\n                     (aaa.item.ty === TY_KEYWORD && bbb.item.ty !== TY_PRIMITIVE)) {\n@@ -1230,15 +1239,19 @@ function initSearch(rawSearchIndex) {\n          * * `id` is the index in both `searchWords` and `searchIndex` arrays for this element.\n          * * `index` is an `integer`` used to sort by the position of the word in the item's name.\n          * * `lev` is the main metric used to sort the search results.\n+         * * `path_lev` is zero if a single-component search query is used, otherwise it's the\n+         *   distance computed for everything other than the last path component.\n          *\n          * @param {Results} results\n          * @param {string} fullId\n          * @param {integer} id\n          * @param {integer} index\n          * @param {integer} lev\n+         * @param {integer} path_lev\n          */\n-        function addIntoResults(results, fullId, id, index, lev) {\n-            if (lev === 0 || (!parsedQuery.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n+        function addIntoResults(results, fullId, id, index, lev, path_lev) {\n+            const inBounds = lev <= MAX_LEV_DISTANCE || index !== -1;\n+            if (lev === 0 || (!parsedQuery.literalSearch && inBounds)) {\n                 if (results[fullId] !== undefined) {\n                     const result = results[fullId];\n                     if (result.dontValidate || result.lev <= lev) {\n@@ -1250,6 +1263,7 @@ function initSearch(rawSearchIndex) {\n                     index: index,\n                     dontValidate: parsedQuery.literalSearch,\n                     lev: lev,\n+                    path_lev: path_lev,\n                 };\n             }\n         }\n@@ -1280,68 +1294,68 @@ function initSearch(rawSearchIndex) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n-            let lev, lev_add = 0, index = -1;\n+            let lev, index = -1, path_lev = 0;\n             const fullId = row.id;\n+            const searchWord = searchWords[pos];\n \n             const in_args = findArg(row, elem, parsedQuery.typeFilter);\n             const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n \n-            addIntoResults(results_in_args, fullId, pos, index, in_args);\n-            addIntoResults(results_returned, fullId, pos, index, returned);\n+            // path_lev is 0 because no parent path information is currently stored\n+            // in the search index\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0);\n+            addIntoResults(results_returned, fullId, pos, -1, returned, 0);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n             }\n-            const searchWord = searchWords[pos];\n \n-            if (parsedQuery.literalSearch) {\n-                if (searchWord === elem.name) {\n-                    addIntoResults(results_others, fullId, pos, -1, 0);\n-                }\n-                return;\n+            const row_index = row.normalizedName.indexOf(elem.pathLast);\n+            const word_index = searchWord.indexOf(elem.pathLast);\n+\n+            // lower indexes are \"better\" matches\n+            // rank based on the \"best\" match\n+            if (row_index === -1) {\n+                index = word_index;\n+            } else if (word_index === -1) {\n+                index = row_index;\n+            } else if (word_index < row_index) {\n+                index = word_index;\n+            } else {\n+                index = row_index;\n             }\n \n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n                 if (row.type !== null) {\n                     lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n-                    addIntoResults(results_others, fullId, pos, index, lev);\n+                    // path_lev is 0 because we know it's empty\n+                    addIntoResults(results_others, fullId, pos, index, lev, 0);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                lev = checkPath(elem.pathWithoutLast, row);\n-                if (lev > MAX_LEV_DISTANCE || (parsedQuery.literalSearch && lev !== 0)) {\n+                path_lev = checkPath(elem.pathWithoutLast, row);\n+                if (path_lev > MAX_LEV_DISTANCE) {\n                     return;\n-                } else if (lev > 0) {\n-                    lev_add = lev / 10;\n                 }\n             }\n \n-            if (searchWord.indexOf(elem.pathLast) > -1 ||\n-                row.normalizedName.indexOf(elem.pathLast) > -1\n-            ) {\n-                index = row.normalizedName.indexOf(elem.pathLast);\n-            }\n-            lev = levenshtein(searchWord, elem.pathLast);\n-            if (lev > 0 && elem.pathLast.length > 2 && searchWord.indexOf(elem.pathLast) > -1) {\n-                if (elem.pathLast.length < 6) {\n-                    lev = 1;\n-                } else {\n-                    lev = 0;\n+            if (parsedQuery.literalSearch) {\n+                if (searchWord === elem.name) {\n+                    addIntoResults(results_others, fullId, pos, index, 0, path_lev);\n                 }\n-            }\n-            lev += lev_add;\n-            if (lev > MAX_LEV_DISTANCE) {\n                 return;\n-            } else if (index !== -1 && elem.fullPath.length < 2) {\n-                lev -= 1;\n             }\n-            if (lev < 0) {\n-                lev = 0;\n+\n+            lev = levenshtein(searchWord, elem.pathLast);\n+\n+            if (index === -1 && lev + path_lev > MAX_LEV_DISTANCE) {\n+                return;\n             }\n-            addIntoResults(results_others, fullId, pos, index, lev);\n+\n+            addIntoResults(results_others, fullId, pos, index, lev, path_lev);\n         }\n \n         /**\n@@ -1386,7 +1400,7 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n             const lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, row.id, pos, 0, lev);\n+            addIntoResults(results, row.id, pos, 0, lev, 0);\n         }\n \n         function innerRunQuery() {"}]}