{"sha": "c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4M2ZhNWQ5MWMzYjE2NDU5YWI3Yjg3YzQ4ZWQxOGJkMDU5YTIzYWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-15T10:32:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-02-15T10:32:33Z"}, "message": "Auto merge of #48105 - Mark-Simulacrum:exclude-paths, r=alexcrichton\n\nImplement excluding a build-step via --exclude\n\nFirst step to fixing https://github.com/rust-lang/rust/issues/47911. This doesn't change any CI configuration, but implements what I believe necessary to make that feasible in rustbuild.\n\nIn theory this should be sufficient to allow someone to open a PR against .travis.yml and appveyor.yml which splits the Windows 32-bit tests and maybe the OS X tests into multiple builders (depending on what our cost-concerns are) to reduce runtimes.\n\nr? @alexcrichton\ncc @kennytm", "tree": {"sha": "a0484bdd542c32b50bd3669a15ff06f0b3261d75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0484bdd542c32b50bd3669a15ff06f0b3261d75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "html_url": "https://github.com/rust-lang/rust/commit/c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90759befe0234b20ecf81edbbff353b85419d7e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/90759befe0234b20ecf81edbbff353b85419d7e9", "html_url": "https://github.com/rust-lang/rust/commit/90759befe0234b20ecf81edbbff353b85419d7e9"}, {"sha": "a64575c3bd81f6f169eff22a4884984c9c5b36c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64575c3bd81f6f169eff22a4884984c9c5b36c0", "html_url": "https://github.com/rust-lang/rust/commit/a64575c3bd81f6f169eff22a4884984c9c5b36c0"}], "stats": {"total": 771, "additions": 444, "deletions": 327}, "files": [{"sha": "001ae7246fdf29be49f80dcbfd8768dee8b12082", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 99, "deletions": 23, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -95,7 +95,7 @@ pub struct RunConfig<'a> {\n     pub builder: &'a Builder<'a>,\n     pub host: Interned<String>,\n     pub target: Interned<String>,\n-    pub path: Option<&'a Path>,\n+    pub path: PathBuf,\n }\n \n struct StepDescription {\n@@ -105,6 +105,32 @@ struct StepDescription {\n     only_build: bool,\n     should_run: fn(ShouldRun) -> ShouldRun,\n     make_run: fn(RunConfig),\n+    name: &'static str,\n+}\n+\n+#[derive(Debug, Clone, PartialOrd, Ord, PartialEq, Eq)]\n+struct PathSet {\n+    set: BTreeSet<PathBuf>,\n+}\n+\n+impl PathSet {\n+    fn empty() -> PathSet {\n+        PathSet { set: BTreeSet::new() }\n+    }\n+\n+    fn one<P: Into<PathBuf>>(path: P) -> PathSet {\n+        let mut set = BTreeSet::new();\n+        set.insert(path.into());\n+        PathSet { set }\n+    }\n+\n+    fn has(&self, needle: &Path) -> bool {\n+        self.set.iter().any(|p| p.ends_with(needle))\n+    }\n+\n+    fn path(&self, builder: &Builder) -> PathBuf {\n+        self.set.iter().next().unwrap_or(&builder.build.src).to_path_buf()\n+    }\n }\n \n impl StepDescription {\n@@ -116,10 +142,18 @@ impl StepDescription {\n             only_build: S::ONLY_BUILD,\n             should_run: S::should_run,\n             make_run: S::make_run,\n+            name: unsafe { ::std::intrinsics::type_name::<S>() },\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder, path: Option<&Path>) {\n+    fn maybe_run(&self, builder: &Builder, pathset: &PathSet) {\n+        if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n+            eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n+            return;\n+        } else if !builder.config.exclude.is_empty() {\n+            eprintln!(\"{:?} not skipped for {:?} -- not in {:?}\", pathset,\n+                self.name, builder.config.exclude);\n+        }\n         let build = builder.build;\n         let hosts = if self.only_build_targets || self.only_build {\n             build.build_triple()\n@@ -144,7 +178,7 @@ impl StepDescription {\n             for target in targets {\n                 let run = RunConfig {\n                     builder,\n-                    path,\n+                    path: pathset.path(builder),\n                     host: *host,\n                     target: *target,\n                 };\n@@ -157,19 +191,28 @@ impl StepDescription {\n         let should_runs = v.iter().map(|desc| {\n             (desc.should_run)(ShouldRun::new(builder))\n         }).collect::<Vec<_>>();\n+\n+        // sanity checks on rules\n+        for (desc, should_run) in v.iter().zip(&should_runs) {\n+            assert!(!should_run.paths.is_empty(),\n+                \"{:?} should have at least one pathset\", desc.name);\n+        }\n+\n         if paths.is_empty() {\n             for (desc, should_run) in v.iter().zip(should_runs) {\n                 if desc.default && should_run.is_really_default {\n-                    desc.maybe_run(builder, None);\n+                    for pathset in &should_run.paths {\n+                        desc.maybe_run(builder, pathset);\n+                    }\n                 }\n             }\n         } else {\n             for path in paths {\n                 let mut attempted_run = false;\n                 for (desc, should_run) in v.iter().zip(&should_runs) {\n-                    if should_run.run(path) {\n+                    if let Some(pathset) = should_run.pathset_for_path(path) {\n                         attempted_run = true;\n-                        desc.maybe_run(builder, Some(path));\n+                        desc.maybe_run(builder, pathset);\n                     }\n                 }\n \n@@ -185,7 +228,7 @@ impl StepDescription {\n pub struct ShouldRun<'a> {\n     pub builder: &'a Builder<'a>,\n     // use a BTreeSet to maintain sort order\n-    paths: BTreeSet<PathBuf>,\n+    paths: BTreeSet<PathSet>,\n \n     // If this is a default rule, this is an additional constraint placed on\n     // it's run. Generally something like compiler docs being enabled.\n@@ -206,25 +249,46 @@ impl<'a> ShouldRun<'a> {\n         self\n     }\n \n+    // Unlike `krate` this will create just one pathset. As such, it probably shouldn't actually\n+    // ever be used, but as we transition to having all rules properly handle passing krate(...) by\n+    // actually doing something different for every crate passed.\n+    pub fn all_krates(mut self, name: &str) -> Self {\n+        let mut set = BTreeSet::new();\n+        for krate in self.builder.in_tree_crates(name) {\n+            set.insert(PathBuf::from(&krate.path));\n+        }\n+        self.paths.insert(PathSet { set });\n+        self\n+    }\n+\n     pub fn krate(mut self, name: &str) -> Self {\n-        for (_, krate_path) in self.builder.crates(name) {\n-            self.paths.insert(PathBuf::from(krate_path));\n+        for krate in self.builder.in_tree_crates(name) {\n+            self.paths.insert(PathSet::one(&krate.path));\n         }\n         self\n     }\n \n-    pub fn path(mut self, path: &str) -> Self {\n-        self.paths.insert(PathBuf::from(path));\n+    // single, non-aliased path\n+    pub fn path(self, path: &str) -> Self {\n+        self.paths(&[path])\n+    }\n+\n+    // multiple aliases for the same job\n+    pub fn paths(mut self, paths: &[&str]) -> Self {\n+        self.paths.insert(PathSet {\n+            set: paths.iter().map(PathBuf::from).collect(),\n+        });\n         self\n     }\n \n     // allows being more explicit about why should_run in Step returns the value passed to it\n-    pub fn never(self) -> ShouldRun<'a> {\n+    pub fn never(mut self) -> ShouldRun<'a> {\n+        self.paths.insert(PathSet::empty());\n         self\n     }\n \n-    fn run(&self, path: &Path) -> bool {\n-        self.paths.iter().any(|p| path.ends_with(p))\n+    fn pathset_for_path(&self, path: &Path) -> Option<&PathSet> {\n+        self.paths.iter().find(|pathset| pathset.has(path))\n     }\n }\n \n@@ -254,19 +318,23 @@ impl<'a> Builder<'a> {\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri),\n             Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n-            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::DefaultCompiletest,\n-                test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n-                test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n-                test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n-                test::RustdocJS, test::RustdocTheme),\n+            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::Ui, test::RunPass,\n+                test::CompileFail, test::ParseFail, test::RunFail, test::RunPassValgrind,\n+                test::MirOpt, test::Codegen, test::CodegenUnits, test::Incremental, test::Debuginfo,\n+                test::UiFullDeps, test::RunPassFullDeps, test::RunFailFullDeps,\n+                test::CompileFailFullDeps, test::IncrementalFullDeps, test::Rustdoc, test::Pretty,\n+                test::RunPassPretty, test::RunFailPretty, test::RunPassValgrindPretty,\n+                test::RunPassFullDepsPretty, test::RunFailFullDepsPretty, test::RunMake,\n+                test::Crate, test::CrateLibrustc, test::Rustdoc, test::Linkcheck, test::Cargotest,\n+                test::Cargo, test::Rls, test::Docs, test::ErrorIndex, test::Distcheck,\n+                test::Rustfmt, test::Miri, test::Clippy, test::RustdocJS, test::RustdocTheme),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n                 doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n             Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n                 dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign,\n-                dist::DontDistWithMiriEnabled),\n+                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign),\n             Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n                 install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n         }\n@@ -297,8 +365,10 @@ impl<'a> Builder<'a> {\n             should_run = (desc.should_run)(should_run);\n         }\n         let mut help = String::from(\"Available paths:\\n\");\n-        for path in should_run.paths {\n-            help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+        for pathset in should_run.paths {\n+            for path in pathset.set {\n+                help.push_str(format!(\"    ./x.py {} {}\\n\", subcommand, path.display()).as_str());\n+            }\n         }\n         Some(help)\n     }\n@@ -323,6 +393,12 @@ impl<'a> Builder<'a> {\n             stack: RefCell::new(Vec::new()),\n         };\n \n+        if kind == Kind::Dist {\n+            assert!(!build.config.test_miri, \"Do not distribute with miri enabled.\\n\\\n+                The distributed libraries would include all MIR (increasing binary size).\n+                The distributed MIR would include validation statements.\");\n+        }\n+\n         StepDescription::run(&Builder::get_step_descriptions(builder.kind), &builder, paths);\n     }\n "}, {"sha": "767ee4016c6f1d6df08505e8f323b6f9a61a167c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -26,7 +26,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -67,7 +67,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -114,7 +114,7 @@ impl Step for Test {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {"}, {"sha": "2dcc0e0e7cd9f0110a583a93ad1450cb7ca3d08a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -48,7 +48,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libstd\").krate(\"std\")\n+        run.all_krates(\"std\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -320,7 +320,7 @@ impl Step for Test {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/libtest\").krate(\"test\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -436,7 +436,7 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc\").krate(\"rustc-main\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -593,7 +593,7 @@ impl Step for CodegenBackend {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustc_trans\")\n+        run.all_krates(\"rustc_trans\")\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -828,7 +828,7 @@ impl Step for Assemble {\n     type Output = Compiler;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/rustc\")\n+        run.all_krates(\"rustc-main\")\n     }\n \n     /// Prepare a new compiler from the artifacts in `stage`"}, {"sha": "812ca6d64fb6a792545749b84857175a6c36db92", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -56,6 +56,7 @@ pub struct Config {\n     pub sanitizers: bool,\n     pub profiler: bool,\n     pub ignore_git: bool,\n+    pub exclude: Vec<PathBuf>,\n \n     pub run_host_only: bool,\n \n@@ -311,6 +312,7 @@ impl Config {\n         let flags = Flags::parse(&args);\n         let file = flags.config.clone();\n         let mut config = Config::default();\n+        config.exclude = flags.exclude;\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;"}, {"sha": "e7aed7eb4fead3de97f477fc3339542e0a9f7d59", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -1233,31 +1233,6 @@ impl Step for Rustfmt {\n     }\n }\n \n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct DontDistWithMiriEnabled;\n-\n-impl Step for DontDistWithMiriEnabled {\n-    type Output = PathBuf;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        let build_miri = run.builder.build.config.test_miri;\n-        run.default_condition(build_miri)\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        run.builder.ensure(DontDistWithMiriEnabled);\n-    }\n-\n-    fn run(self, _: &Builder) -> PathBuf {\n-        panic!(\"Do not distribute with miri enabled.\\n\\\n-                The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\");\n-    }\n-}\n-\n-\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Extended {\n     stage: u32,"}, {"sha": "55d9723527e6db26ac617f8fe77ea9acbcfc1fcf", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -429,7 +429,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         let builder = run.builder;\n-        run.krate(\"std\").default_condition(builder.build.config.docs)\n+        run.all_krates(\"std\").default_condition(builder.build.config.docs)\n     }\n \n     fn make_run(run: RunConfig) {"}, {"sha": "8a38fedc6136d736d4f86e88848e151998a03f19", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -42,6 +42,7 @@ pub struct Flags {\n     pub jobs: Option<u32>,\n     pub cmd: Subcommand,\n     pub incremental: bool,\n+    pub exclude: Vec<PathBuf>,\n }\n \n pub enum Subcommand {\n@@ -109,6 +110,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n         opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n         opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n+        opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n         opts.optopt(\"\", \"keep-stage\", \"stage to keep without recompiling\", \"N\");\n@@ -273,7 +275,12 @@ Arguments:\n         };\n         // Get any optional paths which occur after the subcommand\n         let cwd = t!(env::current_dir());\n-        let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n+        let src = matches.opt_str(\"src\").map(PathBuf::from)\n+            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n+            .unwrap_or(cwd.clone());\n+        let paths = matches.free[1..].iter().map(|p| {\n+            cwd.join(p).strip_prefix(&src).expect(\"paths passed to be inside checkout\").into()\n+        }).collect::<Vec<PathBuf>>();\n \n         let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n@@ -358,11 +365,6 @@ Arguments:\n             stage = Some(1);\n         }\n \n-        let cwd = t!(env::current_dir());\n-        let src = matches.opt_str(\"src\").map(PathBuf::from)\n-            .or_else(|| env::var_os(\"SRC\").map(PathBuf::from))\n-            .unwrap_or(cwd);\n-\n         Flags {\n             verbose: matches.opt_count(\"verbose\"),\n             stage,\n@@ -374,10 +376,14 @@ Arguments:\n             target: split(matches.opt_strs(\"target\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             config: cfg_file,\n-            src,\n             jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd,\n             incremental: matches.opt_present(\"incremental\"),\n+            exclude: split(matches.opt_strs(\"exclude\"))\n+                .into_iter().map(|p| {\n+                    cwd.join(p).strip_prefix(&src).expect(\"paths to be inside checkout\").into()\n+                }).collect::<Vec<_>>(),\n+            src,\n         }\n     }\n }"}, {"sha": "afd740ce5484549f32ee7735514162726f3ed671", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -113,9 +113,8 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(warnings)]\n-#![allow(stable_features)]\n-#![feature(associated_consts)]\n+//#![deny(warnings)]\n+#![feature(core_intrinsics)]\n \n #[macro_use]\n extern crate build_helper;\n@@ -267,6 +266,18 @@ struct Crate {\n     bench_step: String,\n }\n \n+impl Crate {\n+    fn is_local(&self, build: &Build) -> bool {\n+        self.path.starts_with(&build.config.src) &&\n+        !self.path.to_string_lossy().ends_with(\"_shim\")\n+    }\n+\n+    fn local_path(&self, build: &Build) -> PathBuf {\n+        assert!(self.is_local(build));\n+        self.path.strip_prefix(&build.config.src).unwrap().into()\n+    }\n+}\n+\n /// The various \"modes\" of invoking Cargo.\n ///\n /// These entries currently correspond to the various output directories of the\n@@ -949,22 +960,18 @@ impl Build {\n         }\n     }\n \n-    /// Get a list of crates from a root crate.\n-    ///\n-    /// Returns Vec<(crate, path to crate, is_root_crate)>\n-    fn crates(&self, root: &str) -> Vec<(Interned<String>, &Path)> {\n-        let interned = INTERNER.intern_string(root.to_owned());\n+    fn in_tree_crates(&self, root: &str) -> Vec<&Crate> {\n         let mut ret = Vec::new();\n-        let mut list = vec![interned];\n+        let mut list = vec![INTERNER.intern_str(root)];\n         let mut visited = HashSet::new();\n         while let Some(krate) = list.pop() {\n             let krate = &self.crates[&krate];\n-            // If we can't strip prefix, then out-of-tree path\n-            let path = krate.path.strip_prefix(&self.src).unwrap_or(&krate.path);\n-            ret.push((krate.name, path));\n-            for dep in &krate.deps {\n-                if visited.insert(dep) && dep != \"build_helper\" {\n-                    list.push(*dep);\n+            if krate.is_local(self) {\n+                ret.push(krate);\n+                for dep in &krate.deps {\n+                    if visited.insert(dep) && dep != \"build_helper\" {\n+                        list.push(*dep);\n+                    }\n                 }\n             }\n         }"}, {"sha": "3c91cf3ecc7b5312f51d7a9997b3e656c017290f", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -51,9 +51,7 @@ impl Step for Llvm {\n     }\n \n     fn make_run(run: RunConfig) {\n-        let emscripten = run.path.map(|p| {\n-            p.ends_with(\"llvm-emscripten\")\n-        }).unwrap_or(false);\n+        let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n             emscripten,"}, {"sha": "64ede4f4ecc885f071969a6f516db5eb63a6a10d", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 298, "deletions": 245, "changes": 543, "blob_url": "https://github.com/rust-lang/rust/blob/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c83fa5d91c3b16459ab7b87c48ed18bd059a23af/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=c83fa5d91c3b16459ab7b87c48ed18bd059a23af", "patch": "@@ -13,7 +13,6 @@\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n-use std::collections::HashSet;\n use std::env;\n use std::ffi::OsString;\n use std::iter;\n@@ -26,6 +25,7 @@ use std::io::Read;\n use build_helper::{self, output};\n \n use builder::{Kind, RunConfig, ShouldRun, Builder, Compiler, Step};\n+use Crate as CargoCrate;\n use cache::{INTERNER, Interned};\n use compile;\n use dist;\n@@ -550,181 +550,214 @@ fn testdir(build: &Build, host: Interned<String>) -> PathBuf {\n     build.out.join(host).join(\"test\")\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct Test {\n-    path: &'static str,\n-    mode: &'static str,\n-    suite: &'static str,\n+macro_rules! default_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: false });\n+    }\n }\n \n-static DEFAULT_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui\", mode: \"ui\", suite: \"ui\" },\n-    Test { path: \"src/test/run-pass\", mode: \"run-pass\", suite: \"run-pass\" },\n-    Test { path: \"src/test/compile-fail\", mode: \"compile-fail\", suite: \"compile-fail\" },\n-    Test { path: \"src/test/parse-fail\", mode: \"parse-fail\", suite: \"parse-fail\" },\n-    Test { path: \"src/test/run-fail\", mode: \"run-fail\", suite: \"run-fail\" },\n-    Test {\n-        path: \"src/test/run-pass-valgrind\",\n-        mode: \"run-pass-valgrind\",\n-        suite: \"run-pass-valgrind\"\n-    },\n-    Test { path: \"src/test/mir-opt\", mode: \"mir-opt\", suite: \"mir-opt\" },\n-    Test { path: \"src/test/codegen\", mode: \"codegen\", suite: \"codegen\" },\n-    Test { path: \"src/test/codegen-units\", mode: \"codegen-units\", suite: \"codegen-units\" },\n-    Test { path: \"src/test/incremental\", mode: \"incremental\", suite: \"incremental\" },\n-\n-    // What this runs varies depending on the native platform being apple\n-    Test { path: \"src/test/debuginfo\", mode: \"debuginfo-XXX\", suite: \"debuginfo\" },\n-];\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct DefaultCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n+macro_rules! host_test {\n+    ($name:ident { path: $path:expr, mode: $mode:expr, suite: $suite:expr }) => {\n+        test!($name { path: $path, mode: $mode, suite: $suite, default: true, host: true });\n+    }\n }\n \n-impl Step for DefaultCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in DEFAULT_COMPILETESTS {\n-            run = run.path(test.path);\n+macro_rules! test {\n+    ($name:ident {\n+        path: $path:expr,\n+        mode: $mode:expr,\n+        suite: $suite:expr,\n+        default: $default:expr,\n+        host: $host:expr\n+    }) => {\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub struct $name {\n+            pub compiler: Compiler,\n+            pub target: Interned<String>,\n         }\n-        run\n-    }\n \n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n+        impl Step for $name {\n+            type Output = ();\n+            const DEFAULT: bool = $default;\n+            const ONLY_HOSTS: bool = $host;\n \n-        let test = run.path.map(|path| {\n-            DEFAULT_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(DefaultCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in DEFAULT_COMPILETESTS {\n-                run.builder.ensure(DefaultCompiletest {\n-                    compiler,\n-                    target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n-                });\n+            fn should_run(run: ShouldRun) -> ShouldRun {\n+                run.path($path)\n             }\n-        }\n-    }\n-\n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n-    }\n-}\n-\n-// Also default, but host-only.\n-static HOST_COMPILETESTS: &[Test] = &[\n-    Test { path: \"src/test/ui-fulldeps\", mode: \"ui\", suite: \"ui-fulldeps\" },\n-    Test { path: \"src/test/run-pass-fulldeps\", mode: \"run-pass\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps\", mode: \"run-fail\", suite: \"run-fail-fulldeps\" },\n-    Test {\n-        path: \"src/test/compile-fail-fulldeps\",\n-        mode: \"compile-fail\",\n-        suite: \"compile-fail-fulldeps\",\n-    },\n-    Test {\n-        path: \"src/test/incremental-fulldeps\",\n-        mode: \"incremental\",\n-        suite: \"incremental-fulldeps\",\n-    },\n-    Test { path: \"src/test/rustdoc\", mode: \"rustdoc\", suite: \"rustdoc\" },\n-\n-    Test { path: \"src/test/pretty\", mode: \"pretty\", suite: \"pretty\" },\n-    Test { path: \"src/test/run-pass/pretty\", mode: \"pretty\", suite: \"run-pass\" },\n-    Test { path: \"src/test/run-fail/pretty\", mode: \"pretty\", suite: \"run-fail\" },\n-    Test { path: \"src/test/run-pass-valgrind/pretty\", mode: \"pretty\", suite: \"run-pass-valgrind\" },\n-    Test { path: \"src/test/run-pass-fulldeps/pretty\", mode: \"pretty\", suite: \"run-pass-fulldeps\" },\n-    Test { path: \"src/test/run-fail-fulldeps/pretty\", mode: \"pretty\", suite: \"run-fail-fulldeps\" },\n-    Test { path: \"src/test/run-make\", mode: \"run-make\", suite: \"run-make\" },\n-];\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct HostCompiletest {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: &'static str,\n-    suite: &'static str,\n-}\n+            fn make_run(run: RunConfig) {\n+                let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n-impl Step for HostCompiletest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n-        for test in HOST_COMPILETESTS {\n-            run = run.path(test.path);\n-        }\n-        run\n-    }\n-\n-    fn make_run(run: RunConfig) {\n-        let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n-\n-        let test = run.path.map(|path| {\n-            HOST_COMPILETESTS.iter().find(|&&test| {\n-                path.ends_with(test.path)\n-            }).unwrap_or_else(|| {\n-                panic!(\"make_run in compile test to receive test path, received {:?}\", path);\n-            })\n-        });\n-\n-        if let Some(test) = test {\n-            run.builder.ensure(HostCompiletest {\n-                compiler,\n-                target: run.target,\n-                mode: test.mode,\n-                suite: test.suite,\n-            });\n-        } else {\n-            for test in HOST_COMPILETESTS {\n-                if test.mode == \"pretty\" {\n-                    continue;\n-                }\n-                run.builder.ensure(HostCompiletest {\n+                run.builder.ensure($name {\n                     compiler,\n                     target: run.target,\n-                    mode: test.mode,\n-                    suite: test.suite\n                 });\n             }\n-        }\n-    }\n \n-    fn run(self, builder: &Builder) {\n-        builder.ensure(Compiletest {\n-            compiler: self.compiler,\n-            target: self.target,\n-            mode: self.mode,\n-            suite: self.suite,\n-        })\n+            fn run(self, builder: &Builder) {\n+                builder.ensure(Compiletest {\n+                    compiler: self.compiler,\n+                    target: self.target,\n+                    mode: $mode,\n+                    suite: $suite,\n+                })\n+            }\n+        }\n     }\n }\n \n+default_test!(Ui {\n+    path: \"src/test/ui\",\n+    mode: \"ui\",\n+    suite: \"ui\"\n+});\n+\n+default_test!(RunPass {\n+    path: \"src/test/run-pass\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass\"\n+});\n+\n+default_test!(CompileFail {\n+    path: \"src/test/compile-fail\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail\"\n+});\n+\n+default_test!(ParseFail {\n+    path: \"src/test/parse-fail\",\n+    mode: \"parse-fail\",\n+    suite: \"parse-fail\"\n+});\n+\n+default_test!(RunFail {\n+    path: \"src/test/run-fail\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail\"\n+});\n+\n+default_test!(RunPassValgrind {\n+    path: \"src/test/run-pass-valgrind\",\n+    mode: \"run-pass-valgrind\",\n+    suite: \"run-pass-valgrind\"\n+});\n+\n+default_test!(MirOpt {\n+    path: \"src/test/mir-opt\",\n+    mode: \"mir-opt\",\n+    suite: \"mir-opt\"\n+});\n+\n+default_test!(Codegen {\n+    path: \"src/test/codegen\",\n+    mode: \"codegen\",\n+    suite: \"codegen\"\n+});\n+\n+default_test!(CodegenUnits {\n+    path: \"src/test/codegen-units\",\n+    mode: \"codegen-units\",\n+    suite: \"codegen-units\"\n+});\n+\n+default_test!(Incremental {\n+    path: \"src/test/incremental\",\n+    mode: \"incremental\",\n+    suite: \"incremental\"\n+});\n+\n+default_test!(Debuginfo {\n+    path: \"src/test/debuginfo\",\n+    // What this runs varies depending on the native platform being apple\n+    mode: \"debuginfo-XXX\",\n+    suite: \"debuginfo\"\n+});\n+\n+host_test!(UiFullDeps {\n+    path: \"src/test/ui-fulldeps\",\n+    mode: \"ui\",\n+    suite: \"ui-fulldeps\"\n+});\n+\n+host_test!(RunPassFullDeps {\n+    path: \"src/test/run-pass-fulldeps\",\n+    mode: \"run-pass\",\n+    suite: \"run-pass-fulldeps\"\n+});\n+\n+host_test!(RunFailFullDeps {\n+    path: \"src/test/run-fail-fulldeps\",\n+    mode: \"run-fail\",\n+    suite: \"run-fail-fulldeps\"\n+});\n+\n+host_test!(CompileFailFullDeps {\n+    path: \"src/test/compile-fail-fulldeps\",\n+    mode: \"compile-fail\",\n+    suite: \"compile-fail-fulldeps\"\n+});\n+\n+host_test!(IncrementalFullDeps {\n+    path: \"src/test/incremental-fulldeps\",\n+    mode: \"incremental\",\n+    suite: \"incremental-fulldeps\"\n+});\n+\n+host_test!(Rustdoc {\n+    path: \"src/test/rustdoc\",\n+    mode: \"rustdoc\",\n+    suite: \"rustdoc\"\n+});\n+\n+test!(Pretty {\n+    path: \"src/test/pretty\",\n+    mode: \"pretty\",\n+    suite: \"pretty\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassPretty {\n+    path: \"src/test/run-pass/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailPretty {\n+    path: \"src/test/run-fail/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassValgrindPretty {\n+    path: \"src/test/run-pass-valgrind/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-valgrind\",\n+    default: false,\n+    host: true\n+});\n+test!(RunPassFullDepsPretty {\n+    path: \"src/test/run-pass-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-pass-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+test!(RunFailFullDepsPretty {\n+    path: \"src/test/run-fail-fulldeps/pretty\",\n+    mode: \"pretty\",\n+    suite: \"run-fail-fulldeps\",\n+    default: false,\n+    host: true\n+});\n+\n+host_test!(RunMake {\n+    path: \"src/test/run-make\",\n+    mode: \"run-make\",\n+    suite: \"run-make\"\n+});\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n@@ -902,7 +935,7 @@ impl Step for Compiletest {\n             }\n         }\n         if suite == \"run-make\" && !build.config.llvm_enabled {\n-            println!(\"Ignoring run-make test suite as they generally don't work without LLVM\");\n+            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n             return;\n         }\n \n@@ -1099,7 +1132,7 @@ pub struct CrateLibrustc {\n     compiler: Compiler,\n     target: Interned<String>,\n     test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+    krate: Interned<String>,\n }\n \n impl Step for CrateLibrustc {\n@@ -1115,35 +1148,26 @@ impl Step for CrateLibrustc {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let make = |name: Option<Interned<String>>| {\n-            let test_kind = if builder.kind == Kind::Test {\n-                TestKind::Test\n-            } else if builder.kind == Kind::Bench {\n-                TestKind::Bench\n-            } else {\n-                panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n-            };\n-\n-            builder.ensure(CrateLibrustc {\n-                compiler,\n-                target: run.target,\n-                test_kind,\n-                krate: name,\n-            });\n-        };\n+        for krate in builder.in_tree_crates(\"rustc-main\") {\n+            if run.path.ends_with(&krate.path) {\n+                let test_kind = if builder.kind == Kind::Test {\n+                    TestKind::Test\n+                } else if builder.kind == Kind::Bench {\n+                    TestKind::Bench\n+                } else {\n+                    panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+                };\n \n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"rustc-main\") {\n-                if path.ends_with(krate_path) {\n-                    make(Some(name));\n-                }\n+                builder.ensure(CrateLibrustc {\n+                    compiler,\n+                    target: run.target,\n+                    test_kind,\n+                    krate: krate.name,\n+                });\n             }\n-        } else {\n-            make(None);\n         }\n     }\n \n-\n     fn run(self, builder: &Builder) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n@@ -1155,28 +1179,96 @@ impl Step for CrateLibrustc {\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateNotDefault {\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    test_kind: TestKind,\n+    krate: &'static str,\n+}\n+\n+impl Step for CrateNotDefault {\n+    type Output = ();\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/liballoc_jemalloc\")\n+            .path(\"src/librustc_asan\")\n+            .path(\"src/librustc_lsan\")\n+            .path(\"src/librustc_msan\")\n+            .path(\"src/librustc_tsan\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        let builder = run.builder;\n+        let compiler = builder.compiler(builder.top_stage, run.host);\n+\n+        let test_kind = if builder.kind == Kind::Test {\n+            TestKind::Test\n+        } else if builder.kind == Kind::Bench {\n+            TestKind::Bench\n+        } else {\n+            panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n+        };\n+\n+        builder.ensure(CrateNotDefault {\n+            compiler,\n+            target: run.target,\n+            test_kind,\n+            krate: match run.path {\n+                _ if run.path.ends_with(\"src/liballoc_jemalloc\") => \"alloc_jemalloc\",\n+                _ if run.path.ends_with(\"src/librustc_asan\") => \"rustc_asan\",\n+                _ if run.path.ends_with(\"src/librustc_lsan\") => \"rustc_lsan\",\n+                _ if run.path.ends_with(\"src/librustc_msan\") => \"rustc_msan\",\n+                _ if run.path.ends_with(\"src/librustc_tsan\") => \"rustc_tsan\",\n+                _ => panic!(\"unexpected path {:?}\", run.path),\n+            },\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        builder.ensure(Crate {\n+            compiler: self.compiler,\n+            target: self.target,\n+            mode: Mode::Libstd,\n+            test_kind: self.test_kind,\n+            krate: INTERNER.intern_str(self.krate),\n+        });\n+    }\n+}\n+\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Crate {\n     compiler: Compiler,\n     target: Interned<String>,\n     mode: Mode,\n     test_kind: TestKind,\n-    krate: Option<Interned<String>>,\n+    krate: Interned<String>,\n }\n \n impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.krate(\"std\").krate(\"test\")\n+    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run = run.krate(\"test\");\n+        for krate in run.builder.in_tree_crates(\"std\") {\n+            if krate.is_local(&run.builder) &&\n+                !krate.name.contains(\"jemalloc\") &&\n+                !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) &&\n+                krate.name != \"dlmalloc\" {\n+                run = run.path(krate.local_path(&builder).to_str().unwrap());\n+            }\n+        }\n+        run\n     }\n \n     fn make_run(run: RunConfig) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n-        let make = |mode: Mode, name: Option<Interned<String>>| {\n+        let make = |mode: Mode, krate: &CargoCrate| {\n             let test_kind = if builder.kind == Kind::Test {\n                 TestKind::Test\n             } else if builder.kind == Kind::Bench {\n@@ -1190,29 +1282,24 @@ impl Step for Crate {\n                 target: run.target,\n                 mode,\n                 test_kind,\n-                krate: name,\n+                krate: krate.name,\n             });\n         };\n \n-        if let Some(path) = run.path {\n-            for (name, krate_path) in builder.crates(\"std\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libstd, Some(name));\n-                }\n+        for krate in builder.in_tree_crates(\"std\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Libstd, krate);\n             }\n-            for (name, krate_path) in builder.crates(\"test\") {\n-                if path.ends_with(krate_path) {\n-                    make(Mode::Libtest, Some(name));\n-                }\n+        }\n+        for krate in builder.in_tree_crates(\"test\") {\n+            if run.path.ends_with(&krate.local_path(&builder)) {\n+                make(Mode::Libtest, krate);\n             }\n-        } else {\n-            make(Mode::Libstd, None);\n-            make(Mode::Libtest, None);\n         }\n     }\n \n-    /// Run all unit tests plus documentation tests for an entire crate DAG defined\n-    /// by a `Cargo.toml`\n+    /// Run all unit tests plus documentation tests for a given crate defined\n+    /// by a `Cargo.toml` (single manifest)\n     ///\n     /// This is what runs tests for crates like the standard library, compiler, etc.\n     /// It essentially is the driver for running `cargo test`.\n@@ -1241,27 +1328,23 @@ impl Step for Crate {\n         };\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n-        let (name, root) = match mode {\n+        match mode {\n             Mode::Libstd => {\n                 compile::std_cargo(build, &compiler, target, &mut cargo);\n-                (\"libstd\", \"std\")\n             }\n             Mode::Libtest => {\n                 compile::test_cargo(build, &compiler, target, &mut cargo);\n-                (\"libtest\", \"test\")\n             }\n             Mode::Librustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(build, &mut cargo);\n-                (\"librustc\", \"rustc-main\")\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n-        let root = INTERNER.intern_string(String::from(root));\n         let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, name)\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n         });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n                 &compiler.host, target);\n \n         // Build up the base `cargo test` command.\n@@ -1273,37 +1356,7 @@ impl Step for Crate {\n             cargo.arg(\"--no-fail-fast\");\n         }\n \n-        match krate {\n-            Some(krate) => {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n-            None => {\n-                let mut visited = HashSet::new();\n-                let mut next = vec![root];\n-                while let Some(name) = next.pop() {\n-                    // Right now jemalloc and the sanitizer crates are\n-                    // target-specific crate in the sense that it's not present\n-                    // on all platforms. Custom skip it here for now, but if we\n-                    // add more this probably wants to get more generalized.\n-                    //\n-                    // Also skip `build_helper` as it's not compiled normally\n-                    // for target during the bootstrap and it's just meant to be\n-                    // a helper crate, not tested. If it leaks through then it\n-                    // ends up messing with various mtime calculations and such.\n-                    if !name.contains(\"jemalloc\") &&\n-                       *name != *\"build_helper\" &&\n-                       !(name.starts_with(\"rustc_\") && name.ends_with(\"san\")) &&\n-                       name != \"dlmalloc\" {\n-                        cargo.arg(\"-p\").arg(&format!(\"{}:0.0.0\", name));\n-                    }\n-                    for dep in build.crates[&name].deps.iter() {\n-                        if visited.insert(dep) {\n-                            next.push(*dep);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+        cargo.arg(\"-p\").arg(krate);\n \n         // The tests are going to run with the *target* libraries, so we need to\n         // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n@@ -1355,18 +1408,18 @@ impl Step for Crate {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Rustdoc {\n+pub struct CrateRustdoc {\n     host: Interned<String>,\n     test_kind: TestKind,\n }\n \n-impl Step for Rustdoc {\n+impl Step for CrateRustdoc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n-        run.path(\"src/librustdoc\").path(\"src/tools/rustdoc\")\n+        run.paths(&[\"src/librustdoc\", \"src/tools/rustdoc\"])\n     }\n \n     fn make_run(run: RunConfig) {\n@@ -1380,7 +1433,7 @@ impl Step for Rustdoc {\n             panic!(\"unexpected builder.kind in crate: {:?}\", builder.kind);\n         };\n \n-        builder.ensure(Rustdoc {\n+        builder.ensure(CrateRustdoc {\n             host: run.host,\n             test_kind,\n         });"}]}