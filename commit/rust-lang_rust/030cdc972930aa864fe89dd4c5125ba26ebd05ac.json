{"sha": "030cdc972930aa864fe89dd4c5125ba26ebd05ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMGNkYzk3MjkzMGFhODY0ZmU4OWRkNGM1MTI1YmEyNmViZDA1YWM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-01-20T02:56:48Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: remove obsolete hacks from ppaux, relating to normalization under HRTB.", "tree": {"sha": "02bac91a761457f2b989c1cad9acb443b4068a4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02bac91a761457f2b989c1cad9acb443b4068a4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/030cdc972930aa864fe89dd4c5125ba26ebd05ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/030cdc972930aa864fe89dd4c5125ba26ebd05ac", "html_url": "https://github.com/rust-lang/rust/commit/030cdc972930aa864fe89dd4c5125ba26ebd05ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/030cdc972930aa864fe89dd4c5125ba26ebd05ac/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf", "html_url": "https://github.com/rust-lang/rust/commit/fb53bb9e2b67887916a9815428ff5b8bac4c1ebf"}], "stats": {"total": 246, "additions": 142, "deletions": 104}, "files": [{"sha": "d1632e1e9bb545a8bdce70f006601b9c41a482b8", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=030cdc972930aa864fe89dd4c5125ba26ebd05ac", "patch": "@@ -1,6 +1,6 @@\n use crate::hir::map::DefPathData;\n use crate::hir::def_id::{CrateNum, DefId};\n-use crate::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::subst::{Subst, SubstsRef};\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -16,19 +16,6 @@ pub use self::pretty::*;\n // FIXME(eddyb) this module uses `pub(crate)` for things used only\n // from `ppaux` - when that is removed, they can be re-privatized.\n \n-struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n-impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match *r {\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n-                self.0.insert(name);\n-            },\n-            _ => {},\n-        }\n-        r.super_visit_with(self)\n-    }\n-}\n-\n #[derive(Default)]\n pub(crate) struct PrintConfig {\n     used_region_names: Option<FxHashSet<InternedString>>,\n@@ -67,14 +54,6 @@ impl<'a, 'gcx, 'tcx, P> PrintCx<'a, 'gcx, 'tcx, P> {\n     pub(crate) fn with_tls_tcx<R>(printer: P, f: impl FnOnce(PrintCx<'_, '_, '_, P>) -> R) -> R {\n         ty::tls::with(|tcx| PrintCx::with(tcx, printer, f))\n     }\n-    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n-    where T: TypeFoldable<'tcx>\n-    {\n-        let mut collector = LateBoundRegionNameCollector(Default::default());\n-        value.visit_with(&mut collector);\n-        self.config.used_region_names = Some(collector.0);\n-        self.config.region_index = 0;\n-    }\n }\n \n pub trait Print<'tcx, P> {\n@@ -322,3 +301,27 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n         ty::Float(_) => None,\n     }\n }\n+\n+impl<P: Printer> Print<'tcx, P> for ty::RegionKind {\n+    type Output = P::Region;\n+    type Error = P::Error;\n+    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+        cx.print_region(self)\n+    }\n+}\n+\n+impl<P: Printer> Print<'tcx, P> for ty::Region<'_> {\n+    type Output = P::Region;\n+    type Error = P::Error;\n+    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+        cx.print_region(self)\n+    }\n+}\n+\n+impl<P: Printer> Print<'tcx, P> for Ty<'tcx> {\n+    type Output = P::Type;\n+    type Error = P::Error;\n+    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+        cx.print_type(self)\n+    }\n+}"}, {"sha": "7488b074471ff320287ff4a572410dacbc21f126", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=030cdc972930aa864fe89dd4c5125ba26ebd05ac", "patch": "@@ -205,6 +205,15 @@ pub trait PrettyPrinter:\n         self.print_def_path(def_id, substs, iter::empty())\n     }\n \n+    fn in_binder<T>(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        value.skip_binder().print(self)\n+    }\n+\n     /// Print `<...>` around what `f` prints.\n     fn generic_delimiters<'gcx, 'tcx>(\n         self: PrintCx<'_, 'gcx, 'tcx, Self>,\n@@ -784,6 +793,15 @@ impl<F: fmt::Write> PrettyPrinter for FmtPrinter<F> {\n         Ok(printer)\n     }\n \n+    fn in_binder<T>(\n+        self: PrintCx<'_, '_, 'tcx, Self>,\n+        value: &ty::Binder<T>,\n+    ) -> Result<Self, Self::Error>\n+        where T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>\n+    {\n+        self.pretty_in_binder(value)\n+    }\n+\n     fn generic_delimiters<'gcx, 'tcx>(\n         mut self: PrintCx<'_, 'gcx, 'tcx, Self>,\n         f: impl FnOnce(PrintCx<'_, 'gcx, 'tcx, Self>) -> Result<Self, Self::Error>,\n@@ -1125,7 +1143,7 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n                 p!(write(\" \"), print(witness), write(\"]\"))\n             },\n             ty::GeneratorWitness(types) => {\n-                nest!(|cx| cx.pretty_in_binder(&types))\n+                nest!(|cx| cx.in_binder(&types))\n             }\n             ty::Closure(did, substs) => {\n                 let upvar_tys = substs.upvar_tys(did, self.tcx);\n@@ -1257,9 +1275,6 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n             })\n         };\n \n-        // NOTE(eddyb) this must be below `start_or_continue`'s definition\n-        // as that also has a `define_scoped_cx` and that kind of shadowing\n-        // is disallowed (name resolution thinks `scoped_cx!` is ambiguous).\n         define_scoped_cx!(self);\n \n         let old_region_index = self.config.region_index;\n@@ -1302,10 +1317,43 @@ impl<'gcx, 'tcx, P: PrettyPrinter> PrintCx<'_, 'gcx, 'tcx, P> {\n         result\n     }\n \n+    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n+    where T: TypeFoldable<'tcx>\n+    {\n+\n+        struct LateBoundRegionNameCollector(FxHashSet<InternedString>);\n+        impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n+            fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+                match *r {\n+                    ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                        self.0.insert(name);\n+                    },\n+                    _ => {},\n+                }\n+                r.super_visit_with(self)\n+            }\n+        }\n+\n+        let mut collector = LateBoundRegionNameCollector(Default::default());\n+        value.visit_with(&mut collector);\n+        self.config.used_region_names = Some(collector.0);\n+        self.config.region_index = 0;\n+    }\n+\n     fn is_name_used(&self, name: &InternedString) -> bool {\n         match self.config.used_region_names {\n             Some(ref names) => names.contains(name),\n             None => false,\n         }\n     }\n }\n+\n+impl<T, P: PrettyPrinter> Print<'tcx, P> for ty::Binder<T>\n+    where T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>\n+{\n+    type Output = P;\n+    type Error = P::Error;\n+    fn print(&self, cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n+        cx.in_binder(self)\n+    }\n+}"}, {"sha": "dfb7e64d98bcb5a1a58ac3332b2a787803902643", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=030cdc972930aa864fe89dd4c5125ba26ebd05ac", "patch": "@@ -775,28 +775,6 @@ BraceStructLiftImpl! {\n     }\n }\n \n-// FIXME(eddyb) this is like what some of the macros above generate,\n-// except that macros *also* generate a foldable impl, which we don't\n-// want (with it we'd risk bypassing `fold_region` / `fold_const`).\n-impl<'tcx> Lift<'tcx> for ty::RegionKind {\n-    type Lifted = ty::RegionKind;\n-    fn lift_to_tcx<'b, 'gcx>(&self, _: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        Some(self.clone())\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::LazyConst<'a> {\n-    type Lifted = ty::LazyConst<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::LazyConst::Evaluated(v) => Some(ty::LazyConst::Evaluated(tcx.lift(v)?)),\n-            ty::LazyConst::Unevaluated(def_id, substs) => {\n-                Some(ty::LazyConst::Unevaluated(*def_id, tcx.lift(substs)?))\n-            }\n-        }\n-    }\n-}\n-\n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for ty::Const<'a> {\n         type Lifted = ty::Const<'tcx>;"}, {"sha": "f8d0c8f661c77c393d71ba182c70e3f6d3118ecc", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 65, "deletions": 56, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/030cdc972930aa864fe89dd4c5125ba26ebd05ac/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=030cdc972930aa864fe89dd4c5125ba26ebd05ac", "patch": "@@ -1,7 +1,7 @@\n use crate::hir;\n use crate::hir::def::Namespace;\n use crate::ty::subst::{Kind, UnpackedKind};\n-use crate::ty::{self, ParamConst, Ty};\n+use crate::ty::{self, ParamConst, Ty, TyCtxt};\n use crate::ty::print::{FmtPrinter, PrettyPrinter, PrintCx, Print};\n use crate::mir::interpret::ConstValue;\n \n@@ -10,13 +10,60 @@ use std::iter;\n \n use rustc_target::spec::abi::Abi;\n \n+pub trait LiftAndPrintToFmt<'tcx> {\n+    fn lift_and_print_to_fmt(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result;\n+}\n+\n+impl<T> LiftAndPrintToFmt<'tcx> for T\n+    where T: ty::Lift<'tcx>,\n+          for<'a, 'b> <T as ty::Lift<'tcx>>::Lifted:\n+            Print<'tcx, FmtPrinter<&'a mut fmt::Formatter<'b>>, Error = fmt::Error>\n+{\n+    fn lift_and_print_to_fmt(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            cx.tcx.lift(self).expect(\"could not lift for printing\").print(cx)?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n+// HACK(eddyb) this is separate because `ty::RegionKind` doesn't need lifting.\n+impl LiftAndPrintToFmt<'tcx> for ty::RegionKind {\n+    fn lift_and_print_to_fmt(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        f: &mut fmt::Formatter<'_>,\n+    ) -> fmt::Result {\n+        PrintCx::with(tcx, FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n+            self.print(cx)?;\n+            Ok(())\n+        })\n+    }\n+}\n+\n macro_rules! define_print {\n-    ([$($target:ty),+] $vars:tt $def:tt) => {\n-        $(define_print!($target, $vars $def);)+\n+    (<$($T:ident),*> $target:ty) => {\n+        impl<$($T),*> fmt::Display for $target\n+            where Self: for<'a> LiftAndPrintToFmt<'a>\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                ty::tls::with(|tcx| self.lift_and_print_to_fmt(tcx, f))\n+            }\n+        }\n     };\n \n-    ($target:ty, ($self:ident, $cx:ident) { display $disp:block }) => {\n-        impl<P: PrettyPrinter> Print<'tcx, P> for $target {\n+    (<$($T:ident),*> $target:ty, ($self:ident, $cx:ident) { display $disp:block }) => {\n+        impl<$($T,)* P: PrettyPrinter> Print<'tcx, P> for $target\n+            where $($T: Print<'tcx, P, Output = P, Error = P::Error>),*\n+        {\n             type Output = P;\n             type Error = fmt::Error;\n             fn print(&$self, $cx: PrintCx<'_, '_, 'tcx, P>) -> Result<Self::Output, Self::Error> {\n@@ -29,14 +76,15 @@ macro_rules! define_print {\n             }\n         }\n \n-        impl fmt::Display for $target {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                PrintCx::with_tls_tcx(FmtPrinter::new(f, Namespace::TypeNS), |cx| {\n-                    cx.tcx.lift(self).expect(\"could not lift for printing\").print(cx)?;\n-                    Ok(())\n-                })\n-            }\n-        }\n+        define_print!(<$($T),*> $target);\n+    };\n+\n+    ($target:ty) => {\n+        define_print!(<> $target);\n+    };\n+\n+    ($target:ty, ($self:ident, $cx:ident) { display $disp:block }) => {\n+        define_print!(<> $target, ($self, $cx) { display $disp });\n     };\n }\n \n@@ -172,11 +220,7 @@ define_print! {\n }\n \n define_print! {\n-    ty::RegionKind, (self, cx) {\n-        display {\n-            return cx.print_region(self);\n-        }\n-    }\n+    ty::RegionKind\n }\n \n define_print! {\n@@ -215,34 +259,8 @@ define_print! {\n     }\n }\n \n-// The generic impl doesn't work yet because projections are not\n-// normalized under HRTB.\n-/*impl<T> fmt::Display for ty::Binder<T>\n-    where T: fmt::Display + for<'a> ty::Lift<'a>,\n-          for<'a> <T as ty::Lift<'a>>::Lifted: fmt::Display + TypeFoldable<'a>\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        PrintCx::with_tls_tcx(|cx| cx.pretty_in_binder(cx.tcx.lift(self)\n-            .expect(\"could not lift for printing\")))\n-    }\n-}*/\n-\n define_print! {\n-    [\n-        ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n-        ty::Binder<ty::TraitRef<'tcx>>,\n-        ty::Binder<ty::FnSig<'tcx>>,\n-        ty::Binder<ty::TraitPredicate<'tcx>>,\n-        ty::Binder<ty::SubtypePredicate<'tcx>>,\n-        ty::Binder<ty::ProjectionPredicate<'tcx>>,\n-        ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n-        ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n-    ]\n-    (self, cx) {\n-        display {\n-            nest!(|cx| cx.pretty_in_binder(self))\n-        }\n-    }\n+    <T> ty::Binder<T>\n }\n \n define_print! {\n@@ -254,11 +272,7 @@ define_print! {\n }\n \n define_print! {\n-    Ty<'tcx>, (self, cx) {\n-        display {\n-            return cx.print_type(self);\n-        }\n-    }\n+    Ty<'tcx>\n }\n \n define_print! {\n@@ -309,13 +323,8 @@ define_print! {\n     }\n }\n \n-// Similar problem to `Binder<T>`, can't define a generic impl.\n define_print! {\n-    [\n-        ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n-        ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n-    ]\n-    (self, cx) {\n+    <T, U> ty::OutlivesPredicate<T, U>, (self, cx) {\n         display {\n             p!(print(self.0), write(\" : \"), print(self.1))\n         }"}]}