{"sha": "3175409682e8c2e66b04ed25169a36ab716e71d9", "node_id": "C_kwDOAAsO6NoAKDMxNzU0MDk2ODJlOGMyZTY2YjA0ZWQyNTE2OWEzNmFiNzE2ZTcxZDk", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-22T17:16:07Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-09-25T23:05:52Z"}, "message": "Rework `Fields` internals.\n\nNow `Fields` is just a `Vec` of patterns, with some extra info on the\nside to reconstruct patterns when needed. This emphasizes that this\nextra info is not central to the algorithm.", "tree": {"sha": "20a0eba7b5127aec4921057080cbbcb0d0c94f38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20a0eba7b5127aec4921057080cbbcb0d0c94f38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3175409682e8c2e66b04ed25169a36ab716e71d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3175409682e8c2e66b04ed25169a36ab716e71d9", "html_url": "https://github.com/rust-lang/rust/commit/3175409682e8c2e66b04ed25169a36ab716e71d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3175409682e8c2e66b04ed25169a36ab716e71d9/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a0a25b38cb791b5145dcba53ac83f8dc76f197", "url": "https://api.github.com/repos/rust-lang/rust/commits/87a0a25b38cb791b5145dcba53ac83f8dc76f197", "html_url": "https://github.com/rust-lang/rust/commit/87a0a25b38cb791b5145dcba53ac83f8dc76f197"}], "stats": {"total": 439, "additions": 197, "deletions": 242}, "files": [{"sha": "bba39ca98aaf19bfbc4369743804ef348532d4fe", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 177, "deletions": 230, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/3175409682e8c2e66b04ed25169a36ab716e71d9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3175409682e8c2e66b04ed25169a36ab716e71d9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=3175409682e8c2e66b04ed25169a36ab716e71d9", "patch": "@@ -56,7 +56,7 @@ use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::mir::Field;\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n-use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Const, Ty, TyCtxt, VariantDef};\n use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n@@ -1073,120 +1073,103 @@ impl<'tcx> SplitWildcard<'tcx> {\n     }\n }\n \n-/// Some fields need to be explicitly hidden away in certain cases; see the comment above the\n-/// `Fields` struct. This struct represents such a potentially-hidden field.\n-#[derive(Debug, Copy, Clone)]\n-pub(super) enum FilteredField<'p, 'tcx> {\n-    Kept(&'p Pat<'tcx>),\n-    Hidden,\n-}\n-\n-impl<'p, 'tcx> FilteredField<'p, 'tcx> {\n-    fn kept(self) -> Option<&'p Pat<'tcx>> {\n-        match self {\n-            FilteredField::Kept(p) => Some(p),\n-            FilteredField::Hidden => None,\n-        }\n-    }\n-}\n-\n /// A value can be decomposed into a constructor applied to some fields. This struct represents\n /// those fields, generalized to allow patterns in each field. See also `Constructor`.\n-/// This is constructed from a constructor using [`Fields::wildcards()`].\n ///\n-/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n-/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n-/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n-/// so we avoid it when possible to preserve performance.\n+/// This is constructed for a constructor using [`Fields::wildcards()`]. The idea is that\n+/// [`Fields::wildcards()`] constructs a list of fields where all entries are wildcards, and then\n+/// given a pattern we fill some of the fields with its subpatterns.\n+/// In the following example `Fields::wildcards` returns `[_, _, _, _]`. Then in\n+/// `extract_pattern_arguments` we fill some of the entries, and the result is\n+/// `[Some(0), _, _, _]`.\n+/// ```rust\n+/// let x: [Option<u8>; 4] = foo();\n+/// match x {\n+///     [Some(0), ..] => {}\n+/// }\n+/// ```\n+///\n+/// Note that the number of fields of a constructor may not match the fields declared in the\n+/// original struct/variant. This happens if a private or `non_exhaustive` field is uninhabited,\n+/// because the code mustn't observe that it is uninhabited. In that case that field is not\n+/// included in `fields`. For that reason, when you have a `mir::Field` you must use\n+/// `index_with_declared_idx`.\n #[derive(Debug, Clone)]\n-pub(super) enum Fields<'p, 'tcx> {\n-    /// Lists of patterns that don't contain any filtered fields.\n-    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n-    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n-    /// have not measured if it really made a difference.\n-    Slice(&'p [Pat<'tcx>]),\n-    Vec(SmallVec<[&'p Pat<'tcx>; 2]>),\n-    /// Patterns where some of the fields need to be hidden. For all intents and purposes we only\n-    /// care about the non-hidden fields. We need to keep the real field index for those fields;\n-    /// we're morally storing a `Vec<(usize, &Pat)>` but what we do is more convenient.\n-    /// `len` counts the number of non-hidden fields\n-    Filtered {\n-        fields: SmallVec<[FilteredField<'p, 'tcx>; 2]>,\n-        len: usize,\n-    },\n+pub(super) struct Fields<'p, 'tcx> {\n+    fields: SmallVec<[&'p Pat<'tcx>; 2]>,\n }\n \n impl<'p, 'tcx> Fields<'p, 'tcx> {\n-    /// Internal use. Use `Fields::wildcards()` instead.\n-    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n-    fn from_single_pattern(pat: &'p Pat<'tcx>) -> Self {\n-        Fields::Slice(std::slice::from_ref(pat))\n+    fn empty() -> Self {\n+        Fields { fields: SmallVec::new() }\n+    }\n+\n+    fn from_iter(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        fields: impl IntoIterator<Item = Pat<'tcx>>,\n+    ) -> Self {\n+        let fields: &_ = cx.pattern_arena.alloc_from_iter(fields);\n+        Fields { fields: fields.iter().collect() }\n     }\n \n-    /// Convenience; internal use.\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         tys: impl IntoIterator<Item = Ty<'tcx>>,\n     ) -> Self {\n-        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n-        let pats = cx.pattern_arena.alloc_from_iter(wilds);\n-        Fields::Slice(pats)\n+        Fields::from_iter(cx, tys.into_iter().map(Pat::wildcard_from_ty))\n     }\n \n-    /// Creates a new list of wildcard fields for a given constructor.\n-    pub(super) fn wildcards(pcx: PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n-        let ty = pcx.ty;\n-        let cx = pcx.cx;\n-        let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n+    // In the cases of either a `#[non_exhaustive]` field list or a non-public field, we hide\n+    // uninhabited fields in order not to reveal the uninhabitedness of the whole variant.\n+    // This lists the fields we keep along with their types.\n+    fn list_variant_nonhidden_fields<'a>(\n+        cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        variant: &'a VariantDef,\n+    ) -> impl Iterator<Item = (Field, Ty<'tcx>)> + Captures<'a> + Captures<'p> {\n+        let (adt, substs) = match ty.kind() {\n+            ty::Adt(adt, substs) => (adt, substs),\n+            _ => bug!(),\n+        };\n+        // Whether we must not match the fields of this variant exhaustively.\n+        let is_non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+\n+        variant.fields.iter().enumerate().filter_map(move |(i, field)| {\n+            let ty = field.ty(cx.tcx, substs);\n+            let is_visible = adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n+            let is_uninhabited = cx.is_uninhabited(ty);\n \n+            if is_uninhabited && (!is_visible || is_non_exhaustive) {\n+                None\n+            } else {\n+                Some((Field::new(i), ty))\n+            }\n+        })\n+    }\n+\n+    /// Creates a new list of wildcard fields for a given constructor.\n+    pub(super) fn wildcards(\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        ty: Ty<'tcx>,\n+        constructor: &Constructor<'tcx>,\n+    ) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match ty.kind() {\n                 ty::Tuple(ref fs) => {\n                     Fields::wildcards_from_tys(cx, fs.into_iter().map(|ty| ty.expect_ty()))\n                 }\n-                ty::Ref(_, rty, _) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // Use T as the sub pattern type of Box<T>.\n-                        Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n+                        // FIXME(Nadrieril): This is to make box-patterns work even though `Box` is\n+                        // actually a struct with 2 private fields. Hacky.\n+                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n-                        // Whether we must not match the fields of this variant exhaustively.\n-                        let is_non_exhaustive =\n-                            variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n-                        let field_tys = variant.fields.iter().map(|field| field.ty(cx.tcx, substs));\n-                        // In the following cases, we don't need to filter out any fields. This is\n-                        // the vast majority of real cases, since uninhabited fields are uncommon.\n-                        let has_no_hidden_fields = (adt.is_enum() && !is_non_exhaustive)\n-                            || !field_tys.clone().any(|ty| cx.is_uninhabited(ty));\n-\n-                        if has_no_hidden_fields {\n-                            Fields::wildcards_from_tys(cx, field_tys)\n-                        } else {\n-                            let mut len = 0;\n-                            let fields = variant\n-                                .fields\n-                                .iter()\n-                                .map(|field| {\n-                                    let ty = field.ty(cx.tcx, substs);\n-                                    let is_visible = adt.is_enum()\n-                                        || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                                    let is_uninhabited = cx.is_uninhabited(ty);\n-\n-                                    // In the cases of either a `#[non_exhaustive]` field list\n-                                    // or a non-public field, we hide uninhabited fields in\n-                                    // order not to reveal the uninhabitedness of the whole\n-                                    // variant.\n-                                    if is_uninhabited && (!is_visible || is_non_exhaustive) {\n-                                        FilteredField::Hidden\n-                                    } else {\n-                                        len += 1;\n-                                        FilteredField::Kept(wildcard_from_ty(ty))\n-                                    }\n-                                })\n-                                .collect();\n-                            Fields::Filtered { fields, len }\n-                        }\n+                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                            .map(|(_, ty)| ty);\n+                        Fields::wildcards_from_tys(cx, tys)\n                     }\n                 }\n                 _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n@@ -1204,12 +1187,25 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             | NonExhaustive\n             | Opaque\n             | Missing { .. }\n-            | Wildcard => Fields::Slice(&[]),\n+            | Wildcard => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n     }\n \n+    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n+    /// construct `self`.\n+    pub(super) fn len(&self) -> usize {\n+        self.fields.len()\n+    }\n+\n+    /// Returns the list of patterns.\n+    pub(super) fn iter_patterns<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = &'p Pat<'tcx>> + Captures<'a> {\n+        self.fields.iter().copied()\n+    }\n+\n     /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n     /// must have as many elements as this constructor's arity.\n     ///\n@@ -1229,28 +1225,37 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     /// returns `Some(false)`\n     /// ```\n     pub(super) fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n-        let subpatterns_and_indices = self.patterns_and_indices();\n-        let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p).cloned();\n+        let mut subpatterns = self.iter_patterns().cloned();\n \n         let pat = match ctor {\n             Single | Variant(_) => match pcx.ty.kind() {\n-                ty::Adt(..) | ty::Tuple(..) => {\n-                    // We want the real indices here.\n-                    let subpatterns = subpatterns_and_indices\n-                        .iter()\n-                        .map(|&(field, p)| FieldPat { field, pattern: p.clone() })\n-                        .collect();\n-\n-                    if let ty::Adt(adt, substs) = pcx.ty.kind() {\n-                        if adt.is_enum() {\n-                            PatKind::Variant {\n-                                adt_def: adt,\n-                                substs,\n-                                variant_index: ctor.variant_index_for_adt(adt),\n-                                subpatterns,\n-                            }\n-                        } else {\n-                            PatKind::Leaf { subpatterns }\n+                ty::Tuple(..) => PatKind::Leaf {\n+                    subpatterns: subpatterns\n+                        .enumerate()\n+                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .collect(),\n+                },\n+                ty::Adt(adt_def, _) if adt_def.is_box() => {\n+                    // Without `box_patterns`, the only legal pattern of type `Box` is `_` (outside\n+                    // of `std`). So this branch is only reachable when the feature is enabled and\n+                    // the pattern is a box pattern.\n+                    PatKind::Deref { subpattern: subpatterns.next().unwrap() }\n+                }\n+                ty::Adt(adt, substs) => {\n+                    let variant_index = ctor.variant_index_for_adt(adt);\n+                    let variant = &adt.variants[variant_index];\n+                    let subpatterns =\n+                        Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n+                            .zip(subpatterns)\n+                            .map(|((field, _ty), pattern)| FieldPat { field, pattern })\n+                            .collect();\n+\n+                    if adt.is_enum() {\n+                        PatKind::Variant {\n+                            adt_def: adt,\n+                            substs,\n+                            variant_index: ctor.variant_index_for_adt(adt),\n+                            subpatterns,\n                         }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n@@ -1261,8 +1266,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 // literal pattern will never be reported as a non-exhaustiveness witness, so we\n                 // can ignore this issue.\n                 ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n-                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty),\n-                _ => PatKind::Wild,\n+                _ => bug!(\"unexpected ctor for type {:?} {:?}\", ctor, pcx.ty),\n             },\n             Slice(slice) => match slice.kind {\n                 FixedLen(_) => {\n@@ -1303,138 +1307,77 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n \n-    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n-    /// construct `self`.\n-    pub(super) fn len(&self) -> usize {\n-        match self {\n-            Fields::Slice(pats) => pats.len(),\n-            Fields::Vec(pats) => pats.len(),\n-            Fields::Filtered { len, .. } => *len,\n-        }\n-    }\n-\n-    /// Returns the list of patterns along with the corresponding field indices.\n-    fn patterns_and_indices(&self) -> SmallVec<[(Field, &'p Pat<'tcx>); 2]> {\n-        match self {\n-            Fields::Slice(pats) => {\n-                pats.iter().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n-            }\n-            Fields::Vec(pats) => {\n-                pats.iter().copied().enumerate().map(|(i, p)| (Field::new(i), p)).collect()\n-            }\n-            Fields::Filtered { fields, .. } => {\n-                // Indices must be relative to the full list of patterns\n-                fields\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, p)| Some((Field::new(i), p.kept()?)))\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    /// Returns the list of patterns.\n-    pub(super) fn into_patterns(self) -> SmallVec<[&'p Pat<'tcx>; 2]> {\n-        match self {\n-            Fields::Slice(pats) => pats.iter().collect(),\n-            Fields::Vec(pats) => pats,\n-            Fields::Filtered { fields, .. } => fields.iter().filter_map(|p| p.kept()).collect(),\n-        }\n-    }\n-\n-    /// Overrides some of the fields with the provided patterns. Exactly like\n-    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n-    fn replace_with_fieldpats(\n-        &self,\n-        new_pats: impl IntoIterator<Item = &'p FieldPat<'tcx>>,\n-    ) -> Self {\n-        self.replace_fields_indexed(\n-            new_pats.into_iter().map(|pat| (pat.field.index(), &pat.pattern)),\n-        )\n-    }\n-\n-    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n-    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n-    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n-    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n-    /// patterns for the same reason.\n-    fn replace_fields_indexed(\n-        &self,\n-        new_pats: impl IntoIterator<Item = (usize, &'p Pat<'tcx>)>,\n-    ) -> Self {\n-        let mut fields = self.clone();\n-        if let Fields::Slice(pats) = fields {\n-            fields = Fields::Vec(pats.iter().collect());\n-        }\n-\n-        match &mut fields {\n-            Fields::Vec(pats) => {\n-                for (i, pat) in new_pats {\n-                    if let Some(p) = pats.get_mut(i) {\n-                        *p = pat;\n-                    }\n-                }\n-            }\n-            Fields::Filtered { fields, .. } => {\n-                for (i, pat) in new_pats {\n-                    if let FilteredField::Kept(p) = &mut fields[i] {\n-                        *p = pat\n-                    }\n-                }\n-            }\n-            Fields::Slice(_) => unreachable!(),\n-        }\n-        fields\n-    }\n-\n     /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n     /// in `pats`.\n     pub(super) fn replace_fields(\n-        &self,\n+        self,\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n         pats: impl IntoIterator<Item = Pat<'tcx>>,\n     ) -> Self {\n-        let pats: &[_] = cx.pattern_arena.alloc_from_iter(pats);\n-\n-        match self {\n-            Fields::Filtered { fields, len } => {\n-                let mut pats = pats.iter();\n-                let mut fields = fields.clone();\n-                for f in &mut fields {\n-                    if let FilteredField::Kept(p) = f {\n-                        // We take one input pattern for each `Kept` field, in order.\n-                        *p = pats.next().unwrap();\n-                    }\n-                }\n-                Fields::Filtered { fields, len: *len }\n-            }\n-            _ => Fields::Slice(pats),\n-        }\n+        Self::from_iter(cx, pats)\n     }\n \n     /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n     /// that is compatible with the constructor used to build `self`.\n-    /// This is meant to be used on the result of `Fields::wildcards()`. The idea is that\n-    /// `wildcards` constructs a list of fields where all entries are wildcards, and the pattern\n-    /// provided to this function fills some of the fields with non-wildcards.\n-    /// In the following example `Fields::wildcards` would return `[_, _, _, _]`. If we call\n-    /// `replace_with_pattern_arguments` on it with the pattern, the result will be `[Some(0), _,\n-    /// _, _]`.\n-    /// ```rust\n-    /// let x: [Option<u8>; 4] = foo();\n-    /// match x {\n-    ///     [Some(0), ..] => {}\n-    /// }\n-    /// ```\n+    /// This is meant to be used on the result of `Fields::wildcards()`. See the comment above\n+    /// `Fields` for details\n     /// This is guaranteed to preserve the number of patterns in `self`.\n-    pub(super) fn replace_with_pattern_arguments(&self, pat: &'p Pat<'tcx>) -> Self {\n+    pub(super) fn extract_pattern_arguments(\n+        mut self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pat: &'p Pat<'tcx>,\n+    ) -> Self {\n         match pat.kind.as_ref() {\n             PatKind::Deref { subpattern } => {\n                 assert_eq!(self.len(), 1);\n-                Fields::from_single_pattern(subpattern)\n+                self.fields[0] = subpattern;\n             }\n             PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n-                self.replace_with_fieldpats(subpatterns)\n+                match pat.ty.kind() {\n+                    ty::Adt(adt, _) if adt.is_box() => {\n+                        // FIXME(Nadrieril): A `Box` can in theory be matched either with `Box(_,\n+                        // _)` or a box pattern. As a hack to avoid an ICE with the former, we\n+                        // ignore other fields than the first one. This will trigger an error later\n+                        // anyway.\n+                        // See https://github.com/rust-lang/rust/issues/82772 ,\n+                        // explanation: https://github.com/rust-lang/rust/pull/82789#issuecomment-796921977\n+                        // The problem is that we can't know from the type whether we'll match\n+                        // normally or through box-patterns. We'll have to figure out a proper\n+                        // solution when we introduce generalized deref patterns. Also need to\n+                        // prevent mixing of those two options.\n+                        assert_eq!(self.len(), 1);\n+                        let pat = subpatterns.into_iter().find(|pat| pat.field.index() == 0);\n+                        if let Some(pat) = pat {\n+                            self.fields[0] = &pat.pattern;\n+                        }\n+                    }\n+                    ty::Adt(adt, _) => {\n+                        let variant_index = match pat.kind.as_ref() {\n+                            PatKind::Leaf { .. } => VariantIdx::new(0),\n+                            PatKind::Variant { variant_index, .. } => *variant_index,\n+                            _ => bug!(),\n+                        };\n+                        let variant = &adt.variants[variant_index];\n+                        // For each field in the variant, we store the relevant index into `self.fields` if any.\n+                        let mut field_id_to_id: Vec<Option<usize>> =\n+                            (0..variant.fields.len()).map(|_| None).collect();\n+                        for (i, (field, _ty)) in\n+                            Fields::list_variant_nonhidden_fields(cx, pat.ty, variant).enumerate()\n+                        {\n+                            field_id_to_id[field.index()] = Some(i);\n+                        }\n+                        for pat in subpatterns {\n+                            if let Some(i) = field_id_to_id[pat.field.index()] {\n+                                self.fields[i] = &pat.pattern;\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        for pat in subpatterns {\n+                            self.fields[pat.field.index()] = &pat.pattern;\n+                        }\n+                    }\n+                }\n             }\n             PatKind::Array { prefix, suffix, .. } | PatKind::Slice { prefix, suffix, .. } => {\n                 // Number of subpatterns for the constructor\n@@ -1445,9 +1388,13 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 let prefix = prefix.iter().enumerate();\n                 let suffix =\n                     suffix.iter().enumerate().map(|(i, p)| (ctor_arity - suffix.len() + i, p));\n-                self.replace_fields_indexed(prefix.chain(suffix))\n+\n+                for (i, pat) in prefix.chain(suffix) {\n+                    self.fields[i] = pat\n+                }\n             }\n-            _ => self.clone(),\n-        }\n+            _ => {}\n+        };\n+        self\n     }\n }"}, {"sha": "b518be0141dc43a153926aa290955a87eeb3831a", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3175409682e8c2e66b04ed25169a36ab716e71d9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3175409682e8c2e66b04ed25169a36ab716e71d9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=3175409682e8c2e66b04ed25169a36ab716e71d9", "patch": "@@ -467,11 +467,18 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// fields filled with wild patterns.\n     ///\n     /// This is roughly the inverse of `Constructor::apply`.\n-    fn pop_head_constructor(&self, ctor_wild_subpatterns: &Fields<'p, 'tcx>) -> PatStack<'p, 'tcx> {\n+    fn pop_head_constructor(\n+        &self,\n+        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields =\n-            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head()).into_patterns();\n+        let mut new_fields: SmallVec<[_; 2]> = ctor_wild_subpatterns\n+            .clone()\n+            .extract_pattern_arguments(cx, self.head())\n+            .iter_patterns()\n+            .collect();\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -559,7 +566,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n             if ctor.is_covered_by(pcx, row.head_ctor(pcx.cx)) {\n-                let new_row = row.pop_head_constructor(ctor_wild_subpatterns);\n+                let new_row = row.pop_head_constructor(pcx.cx, ctor_wild_subpatterns);\n                 matrix.push(new_row);\n             }\n         }\n@@ -923,7 +930,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                         // Here we don't want the user to try to list all variants, we want them to add\n                         // a wildcard, so we only suggest that.\n                         vec![\n-                            Fields::wildcards(pcx, &Constructor::NonExhaustive)\n+                            Fields::wildcards(pcx.cx, pcx.ty, &Constructor::NonExhaustive)\n                                 .apply(pcx, &Constructor::NonExhaustive),\n                         ]\n                     } else {\n@@ -936,7 +943,8 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n                         split_wildcard\n                             .iter_missing(pcx)\n                             .map(|missing_ctor| {\n-                                Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                                Fields::wildcards(pcx.cx, pcx.ty, missing_ctor)\n+                                    .apply(pcx, missing_ctor)\n                             })\n                             .collect()\n                     };\n@@ -1036,7 +1044,7 @@ impl<'tcx> Witness<'tcx> {\n             let len = self.0.len();\n             let arity = ctor_wild_subpatterns.len();\n             let pats = self.0.drain((len - arity)..).rev();\n-            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+            ctor_wild_subpatterns.clone().replace_fields(pcx.cx, pats).apply(pcx, ctor)\n         };\n \n         self.0.push(pat);\n@@ -1172,10 +1180,10 @@ fn is_useful<'p, 'tcx>(\n         for ctor in split_ctors {\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n-            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n+            let ctor_wild_subpatterns = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n             let spec_matrix =\n                 start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n-            let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n+            let v = v.pop_head_constructor(pcx.cx, &ctor_wild_subpatterns);\n             let usefulness =\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             let usefulness =\n@@ -1207,7 +1215,7 @@ fn is_useful<'p, 'tcx>(\n                         // to our lint\n                         .filter(|c| !c.is_non_exhaustive())\n                         .map(|missing_ctor| {\n-                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                            Fields::wildcards(pcx.cx, pcx.ty, missing_ctor).apply(pcx, missing_ctor)\n                         })\n                         .collect::<Vec<_>>()\n                 };"}, {"sha": "48ed14915084a5d607ae44e57b8a0cedcc4a6d3b", "filename": "src/test/ui/pattern/usefulness/issue-3601.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3175409682e8c2e66b04ed25169a36ab716e71d9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3175409682e8c2e66b04ed25169a36ab716e71d9/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fissue-3601.stderr?ref=3175409682e8c2e66b04ed25169a36ab716e71d9", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `Box(_, _)` not covered\n+error[E0004]: non-exhaustive patterns: `box _` not covered\n   --> $DIR/issue-3601.rs:30:44\n    |\n LL |         box NodeKind::Element(ed) => match ed.kind {\n-   |                                            ^^^^^^^ pattern `Box(_, _)` not covered\n+   |                                            ^^^^^^^ pattern `box _` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `Box<ElementKind>`"}]}