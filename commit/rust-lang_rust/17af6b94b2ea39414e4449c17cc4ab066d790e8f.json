{"sha": "17af6b94b2ea39414e4449c17cc4ab066d790e8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YWY2Yjk0YjJlYTM5NDE0ZTQ0NDljMTdjYzRhYjA2NmQ3OTBlOGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-14T02:56:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-14T02:56:53Z"}, "message": "Auto merge of #36743 - SimonSapin:dedup-by, r=alexcrichton\n\nAdd Vec::dedup_by and Vec::dedup_by_key", "tree": {"sha": "3404cbcba80552c31b8104b7888941b497cab05c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3404cbcba80552c31b8104b7888941b497cab05c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17af6b94b2ea39414e4449c17cc4ab066d790e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17af6b94b2ea39414e4449c17cc4ab066d790e8f", "html_url": "https://github.com/rust-lang/rust/commit/17af6b94b2ea39414e4449c17cc4ab066d790e8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17af6b94b2ea39414e4449c17cc4ab066d790e8f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "098d22845933814a92497cbfaa8eb4a9a36b117f", "url": "https://api.github.com/repos/rust-lang/rust/commits/098d22845933814a92497cbfaa8eb4a9a36b117f", "html_url": "https://github.com/rust-lang/rust/commit/098d22845933814a92497cbfaa8eb4a9a36b117f"}, {"sha": "401f1c45db5343dc0189b4f89d4160bba24facfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/401f1c45db5343dc0189b4f89d4160bba24facfb", "html_url": "https://github.com/rust-lang/rust/commit/401f1c45db5343dc0189b4f89d4160bba24facfb"}], "stats": {"total": 306, "additions": 182, "deletions": 124}, "files": [{"sha": "2bb311cc5ae900f25aad671508c49cd49a4d8706", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 126, "deletions": 83, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=17af6b94b2ea39414e4449c17cc4ab066d790e8f", "patch": "@@ -781,6 +781,130 @@ impl<T> Vec<T> {\n         }\n     }\n \n+    /// Removes consecutive elements in the vector that resolve to the same key.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(dedup_by)]\n+    ///\n+    /// let mut vec = vec![10, 20, 21, 30, 20];\n+    ///\n+    /// vec.dedup_by_key(|i| *i / 10);\n+    ///\n+    /// assert_eq!(vec, [10, 20, 30, 20]);\n+    /// ```\n+    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    #[inline]\n+    pub fn dedup_by_key<F, K>(&mut self, mut key: F) where F: FnMut(&mut T) -> K, K: PartialEq {\n+        self.dedup_by(|a, b| key(a) == key(b))\n+    }\n+\n+    /// Removes consecutive elements in the vector that resolve to the same key.\n+    ///\n+    /// If the vector is sorted, this removes all duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(dedup_by)]\n+    /// use std::ascii::AsciiExt;\n+    ///\n+    /// let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n+    ///\n+    /// vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+    ///\n+    /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+    /// ```\n+    #[unstable(feature = \"dedup_by\", reason = \"recently added\", issue = \"37087\")]\n+    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+        unsafe {\n+            // Although we have a mutable reference to `self`, we cannot make\n+            // *arbitrary* changes. The `PartialEq` comparisons could panic, so we\n+            // must ensure that the vector is in a valid state at all time.\n+            //\n+            // The way that we handle this is by using swaps; we iterate\n+            // over all the elements, swapping as we go so that at the end\n+            // the elements we wish to keep are in the front, and those we\n+            // wish to reject are at the back. We can then truncate the\n+            // vector. This operation is still O(n).\n+            //\n+            // Example: We start in this state, where `r` represents \"next\n+            // read\" and `w` represents \"next_write`.\n+            //\n+            //           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //           w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate, so\n+            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+            // r and w, leaving us with:\n+            //\n+            //               r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this value is a duplicate,\n+            // so we increment `r` but leave everything else unchanged:\n+            //\n+            //                   r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //               w\n+            //\n+            // Comparing self[r] against self[w-1], this is not a duplicate,\n+            // so swap self[r] and self[w] and advance r and w:\n+            //\n+            //                       r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                   w\n+            //\n+            // Not a duplicate, repeat:\n+            //\n+            //                           r\n+            //     +---+---+---+---+---+---+\n+            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+            //     +---+---+---+---+---+---+\n+            //                       w\n+            //\n+            // Duplicate, advance r. End of vec. Truncate to w.\n+\n+            let ln = self.len();\n+            if ln <= 1 {\n+                return;\n+            }\n+\n+            // Avoid bounds checks by using raw pointers.\n+            let p = self.as_mut_ptr();\n+            let mut r: usize = 1;\n+            let mut w: usize = 1;\n+\n+            while r < ln {\n+                let p_r = p.offset(r as isize);\n+                let p_wm1 = p.offset((w - 1) as isize);\n+                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n+                    if r != w {\n+                        let p_w = p_wm1.offset(1);\n+                        mem::swap(&mut *p_r, &mut *p_w);\n+                    }\n+                    w += 1;\n+                }\n+                r += 1;\n+            }\n+\n+            self.truncate(w);\n+        }\n+    }\n+\n     /// Appends an element to the back of a collection.\n     ///\n     /// # Panics\n@@ -1155,90 +1279,9 @@ impl<T: PartialEq> Vec<T> {\n     /// assert_eq!(vec, [1, 2, 3, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn dedup(&mut self) {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `PartialEq` comparisons could panic, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln <= 1 {\n-                return;\n-            }\n-\n-            // Avoid bounds checks by using raw pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r: usize = 1;\n-            let mut w: usize = 1;\n-\n-            while r < ln {\n-                let p_r = p.offset(r as isize);\n-                let p_wm1 = p.offset((w - 1) as isize);\n-                if *p_r != *p_wm1 {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+        self.dedup_by(|a, b| a == b)\n     }\n }\n "}, {"sha": "88fb6540a9af4a723aa7351fd6333347e1033ee2", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=17af6b94b2ea39414e4449c17cc4ab066d790e8f", "patch": "@@ -16,6 +16,7 @@\n #![feature(collections)]\n #![feature(collections_bound)]\n #![feature(const_fn)]\n+#![feature(dedup_by)]\n #![feature(enumset)]\n #![feature(pattern)]\n #![feature(rand)]"}, {"sha": "130c16d7c150e7ff6e8a8f755a743fc86a6c2be5", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=17af6b94b2ea39414e4449c17cc4ab066d790e8f", "patch": "@@ -315,47 +315,6 @@ fn test_clear() {\n     // If the unsafe block didn't drop things properly, we blow up here.\n }\n \n-#[test]\n-fn test_dedup() {\n-    fn case(a: Vec<i32>, b: Vec<i32>) {\n-        let mut v = a;\n-        v.dedup();\n-        assert_eq!(v, b);\n-    }\n-    case(vec![], vec![]);\n-    case(vec![1], vec![1]);\n-    case(vec![1, 1], vec![1]);\n-    case(vec![1, 2, 3], vec![1, 2, 3]);\n-    case(vec![1, 1, 2, 3], vec![1, 2, 3]);\n-    case(vec![1, 2, 2, 3], vec![1, 2, 3]);\n-    case(vec![1, 2, 3, 3], vec![1, 2, 3]);\n-    case(vec![1, 1, 2, 2, 2, 3, 3], vec![1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_dedup_unique() {\n-    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n-    v0.dedup();\n-    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n-    v1.dedup();\n-    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n-    v2.dedup();\n-    // If the boxed pointers were leaked or otherwise misused, valgrind\n-    // and/or rt should raise errors.\n-}\n-\n-#[test]\n-fn test_dedup_shared() {\n-    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n-    v0.dedup();\n-    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n-    v1.dedup();\n-    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n-    v2.dedup();\n-    // If the pointers were leaked or otherwise misused, valgrind and/or\n-    // rt should raise errors.\n-}\n-\n #[test]\n fn test_retain() {\n     let mut v = vec![1, 2, 3, 4, 5];"}, {"sha": "8417be289eb9eaf5e44826ba4635a66ca9179e2e", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17af6b94b2ea39414e4449c17cc4ab066d790e8f/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=17af6b94b2ea39414e4449c17cc4ab066d790e8f", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ascii::AsciiExt;\n use std::borrow::Cow;\n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n@@ -213,6 +214,60 @@ fn test_retain() {\n     assert_eq!(vec, [2, 4]);\n }\n \n+#[test]\n+fn test_dedup() {\n+    fn case(a: Vec<i32>, b: Vec<i32>) {\n+        let mut v = a;\n+        v.dedup();\n+        assert_eq!(v, b);\n+    }\n+    case(vec![], vec![]);\n+    case(vec![1], vec![1]);\n+    case(vec![1, 1], vec![1]);\n+    case(vec![1, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 1, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 2, 2, 3], vec![1, 2, 3]);\n+    case(vec![1, 2, 3, 3], vec![1, 2, 3]);\n+    case(vec![1, 1, 2, 2, 2, 3, 3], vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_dedup_by_key() {\n+    fn case(a: Vec<i32>, b: Vec<i32>) {\n+        let mut v = a;\n+        v.dedup_by_key(|i| *i / 10);\n+        assert_eq!(v, b);\n+    }\n+    case(vec![], vec![]);\n+    case(vec![10], vec![10]);\n+    case(vec![10, 11], vec![10]);\n+    case(vec![10, 20, 30], vec![10, 20, 30]);\n+    case(vec![10, 11, 20, 30], vec![10, 20, 30]);\n+    case(vec![10, 20, 21, 30], vec![10, 20, 30]);\n+    case(vec![10, 20, 30, 31], vec![10, 20, 30]);\n+    case(vec![10, 11, 20, 21, 22, 30, 31], vec![10, 20, 30]);\n+}\n+\n+#[test]\n+fn test_dedup_by() {\n+    let mut vec = vec![\"foo\", \"bar\", \"Bar\", \"baz\", \"bar\"];\n+    vec.dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+\n+    assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n+}\n+\n+#[test]\n+fn test_dedup_unique() {\n+    let mut v0: Vec<Box<_>> = vec![box 1, box 1, box 2, box 3];\n+    v0.dedup();\n+    let mut v1: Vec<Box<_>> = vec![box 1, box 2, box 2, box 3];\n+    v1.dedup();\n+    let mut v2: Vec<Box<_>> = vec![box 1, box 2, box 3, box 3];\n+    v2.dedup();\n+    // If the boxed pointers were leaked or otherwise misused, valgrind\n+    // and/or rt should raise errors.\n+}\n+\n #[test]\n fn zero_sized_values() {\n     let mut v = Vec::new();"}]}