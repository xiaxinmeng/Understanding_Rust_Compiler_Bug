{"sha": "d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "node_id": "C_kwDOAAsO6NoAKGQ5YWQyNWVlNGJiZDkzNjRjNDk4OTU5Y2RjODJiNWZhNmM0MWU2M2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T06:42:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-20T06:42:05Z"}, "message": "Auto merge of #2548 - RalfJung:remove-tls-diagnostics-hack, r=RalfJung\n\navoid thread-local var indirection for non-halting diagnostics\n\nThis hack used to be necessary because Stacked Borrows did not have access to enough parts of the machine. But that got fixed a while ago, so now we can just emit diagnostics directly, which is a lot more reliable.\n\nNeeds https://github.com/rust-lang/rust/pull/101985\nFixes https://github.com/rust-lang/miri/issues/2538", "tree": {"sha": "ea6e8aef7a628d09959f5d54cb9b15cbb60976ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea6e8aef7a628d09959f5d54cb9b15cbb60976ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "html_url": "https://github.com/rust-lang/rust/commit/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9463c5b713350b37ebc26a01122ea16e002451", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9463c5b713350b37ebc26a01122ea16e002451", "html_url": "https://github.com/rust-lang/rust/commit/4b9463c5b713350b37ebc26a01122ea16e002451"}, {"sha": "7687b7e510d68ca4dfb9e6fa93d748c0450fa779", "url": "https://api.github.com/repos/rust-lang/rust/commits/7687b7e510d68ca4dfb9e6fa93d748c0450fa779", "html_url": "https://github.com/rust-lang/rust/commit/7687b7e510d68ca4dfb9e6fa93d748c0450fa779"}], "stats": {"total": 772, "additions": 362, "deletions": 410}, "files": [{"sha": "78b9a110aa7c73d5df529993f3b52d712be43e11", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -1 +1 @@\n-2019147c5642c08cdb9ad4cacd97dd1fa4ffa701\n+acb8934fd57b3c2740c4abac0a5728c2c9b1423b"}, {"sha": "2e54ddaaba1132e152be05595e21a18c38a28955", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -438,8 +438,8 @@ impl MemoryCellClocks {\n }\n \n /// Evaluation context extensions.\n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     /// Atomic variant of read_scalar_at_offset.\n     fn read_scalar_at_offset_atomic(\n         &self,\n@@ -940,8 +940,8 @@ impl VClockAlloc {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n-trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     /// Temporarily allow data-races to occur. This should only be used in\n     /// one of these cases:\n     /// - One of the appropriate `validate_atomic` functions will be called to\n@@ -950,7 +950,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// cannot be accessed by the interpreted program.\n     /// - Execution of the interpreted program execution has halted.\n     #[inline]\n-    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriEvalContext<'mir, 'tcx>) -> R) -> R {\n+    fn allow_data_races_ref<R>(&self, op: impl FnOnce(&MiriInterpCx<'mir, 'tcx>) -> R) -> R {\n         let this = self.eval_context_ref();\n         if let Some(data_race) = &this.machine.data_race {\n             let old = data_race.ongoing_action_data_race_free.replace(true);\n@@ -969,7 +969,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     #[inline]\n     fn allow_data_races_mut<R>(\n         &mut self,\n-        op: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> R,\n+        op: impl FnOnce(&mut MiriInterpCx<'mir, 'tcx>) -> R,\n     ) -> R {\n         let this = self.eval_context_mut();\n         if let Some(data_race) = &this.machine.data_race {"}, {"sha": "d301ced8511732a1c7092fb7a15c19a8ef0d691f", "filename": "src/concurrency/sync.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fsync.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -159,8 +159,8 @@ pub(crate) struct SynchronizationState {\n }\n \n // Private extension trait for local helper methods\n-impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Take a reader out of the queue waiting for the lock.\n     /// Returns `true` if some thread got the rwlock.\n     #[inline]\n@@ -208,8 +208,8 @@ trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n // cases, the function calls are infallible and it is the client's (shim\n // implementation's) responsibility to detect and deal with erroneous\n // situations.\n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     #[inline]\n     /// Create state for a new mutex.\n     fn mutex_create(&mut self) -> MutexId {\n@@ -222,7 +222,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// otherwise returns the value from the closure\n     fn mutex_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, MutexId>\n     where\n-        F: FnOnce(&mut MiriEvalContext<'mir, 'tcx>, MutexId) -> InterpResult<'tcx, Option<MutexId>>,\n+        F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, MutexId) -> InterpResult<'tcx, Option<MutexId>>,\n     {\n         let this = self.eval_context_mut();\n         let next_index = this.machine.threads.sync.mutexes.next_index();\n@@ -322,10 +322,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// otherwise returns the value from the closure\n     fn rwlock_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, RwLockId>\n     where\n-        F: FnOnce(\n-            &mut MiriEvalContext<'mir, 'tcx>,\n-            RwLockId,\n-        ) -> InterpResult<'tcx, Option<RwLockId>>,\n+        F: FnOnce(&mut MiriInterpCx<'mir, 'tcx>, RwLockId) -> InterpResult<'tcx, Option<RwLockId>>,\n     {\n         let this = self.eval_context_mut();\n         let next_index = this.machine.threads.sync.rwlocks.next_index();\n@@ -492,7 +489,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn condvar_get_or_create<F>(&mut self, existing: F) -> InterpResult<'tcx, CondvarId>\n     where\n         F: FnOnce(\n-            &mut MiriEvalContext<'mir, 'tcx>,\n+            &mut MiriInterpCx<'mir, 'tcx>,\n             CondvarId,\n         ) -> InterpResult<'tcx, Option<CondvarId>>,\n     {"}, {"sha": "f1a3d19fb4cbc6d09a84e2456d641bedd87fddcd", "filename": "src/concurrency/thread.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fthread.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -32,8 +32,9 @@ pub enum SchedulingAction {\n \n /// Timeout callbacks can be created by synchronization primitives to tell the\n /// scheduler that they should be called once some period of time passes.\n-type TimeoutCallback<'mir, 'tcx> =\n-    Box<dyn FnOnce(&mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx>;\n+type TimeoutCallback<'mir, 'tcx> = Box<\n+    dyn FnOnce(&mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>) -> InterpResult<'tcx> + 'tcx,\n+>;\n \n /// A thread identifier.\n #[derive(Clone, Copy, Debug, PartialOrd, Ord, PartialEq, Eq, Hash)]\n@@ -253,7 +254,7 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n }\n \n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n-    pub(crate) fn init(ecx: &mut MiriEvalContext<'mir, 'tcx>) {\n+    pub(crate) fn init(ecx: &mut MiriInterpCx<'mir, 'tcx>) {\n         if ecx.tcx.sess.target.os.as_ref() != \"windows\" {\n             // The main thread can *not* be joined on except on windows.\n             ecx.machine.threads.threads[ThreadId::new(0)].join_status = ThreadJoinStatus::Detached;\n@@ -628,8 +629,8 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n }\n \n // Public interface to thread management.\n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Get a thread-specific allocation id for the given thread-local static.\n     /// If needed, allocate a new one.\n     fn get_or_create_thread_local_alloc("}, {"sha": "bac403e9ec7b1f1d33d6d3164809fa0523f2bc60", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -456,9 +456,9 @@ impl StoreElement {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n-    crate::MiriEvalContextExt<'mir, 'tcx>\n+    crate::MiriInterpCxExt<'mir, 'tcx>\n {\n     // If weak memory emulation is enabled, check if this atomic op imperfectly overlaps with a previous\n     // atomic read or write. If it does, then we require it to be ordered (non-racy) with all previous atomic\n@@ -502,7 +502,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n         if let (\n             crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n-            crate::Evaluator { data_race: Some(global), threads, .. },\n+            crate::MiriMachine { data_race: Some(global), threads, .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n             if atomic == AtomicRwOrd::SeqCst {\n@@ -544,7 +544,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                     validate,\n                 )?;\n                 if global.track_outdated_loads && recency == LoadRecency::Outdated {\n-                    register_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n+                    this.emit_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n                 }\n \n                 return Ok(loaded);\n@@ -567,7 +567,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n         if let (\n             crate::AllocExtra { weak_memory: Some(alloc_buffers), .. },\n-            crate::Evaluator { data_race: Some(global), threads, .. },\n+            crate::MiriMachine { data_race: Some(global), threads, .. },\n         ) = this.get_alloc_extra_mut(alloc_id)?\n         {\n             if atomic == AtomicWriteOrd::SeqCst {"}, {"sha": "868c85c04a88d5d8367ff2435c98c432f7cef5e9", "filename": "src/diagnostics.rs", "status": "modified", "additions": 123, "deletions": 173, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -1,11 +1,9 @@\n-use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n \n use log::trace;\n \n-use rustc_middle::ty;\n-use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n+use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n@@ -89,15 +87,15 @@ enum DiagLevel {\n /// Attempts to prune a stacktrace to omit the Rust runtime, and returns a bool indicating if any\n /// frames were pruned. If the stacktrace does not have any local frames, we conclude that it must\n /// be pointing to a problem in the Rust runtime itself, and do not prune it at all.\n-fn prune_stacktrace<'mir, 'tcx>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+fn prune_stacktrace<'tcx>(\n     mut stacktrace: Vec<FrameInfo<'tcx>>,\n+    machine: &MiriMachine<'_, 'tcx>,\n ) -> (Vec<FrameInfo<'tcx>>, bool) {\n-    match ecx.machine.backtrace_style {\n+    match machine.backtrace_style {\n         BacktraceStyle::Off => {\n             // Remove all frames marked with `caller_location` -- that attribute indicates we\n             // usually want to point at the caller, not them.\n-            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(machine.tcx));\n             // Retain one frame so that we can print a span for the error itself\n             stacktrace.truncate(1);\n             (stacktrace, false)\n@@ -107,11 +105,12 @@ fn prune_stacktrace<'mir, 'tcx>(\n             // Only prune frames if there is at least one local frame. This check ensures that if\n             // we get a backtrace that never makes it to the user code because it has detected a\n             // bug in the Rust runtime, we don't prune away every frame.\n-            let has_local_frame = stacktrace.iter().any(|frame| ecx.machine.is_local(frame));\n+            let has_local_frame = stacktrace.iter().any(|frame| machine.is_local(frame));\n             if has_local_frame {\n                 // Remove all frames marked with `caller_location` -- that attribute indicates we\n                 // usually want to point at the caller, not them.\n-                stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+                stacktrace\n+                    .retain(|frame| !frame.instance.def.requires_caller_location(machine.tcx));\n \n                 // This is part of the logic that `std` uses to select the relevant part of a\n                 // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n@@ -121,7 +120,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n                     .into_iter()\n                     .take_while(|frame| {\n                         let def_id = frame.instance.def_id();\n-                        let path = ecx.tcx.tcx.def_path_str(def_id);\n+                        let path = machine.tcx.def_path_str(def_id);\n                         !path.contains(\"__rust_begin_short_backtrace\")\n                     })\n                     .collect::<Vec<_>>();\n@@ -132,7 +131,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n                 // This len check ensures that we don't somehow remove every frame, as doing so breaks\n                 // the primary error message.\n                 while stacktrace.len() > 1\n-                    && stacktrace.last().map_or(false, |frame| !ecx.machine.is_local(frame))\n+                    && stacktrace.last().map_or(false, |frame| !machine.is_local(frame))\n                 {\n                     stacktrace.pop();\n                 }\n@@ -146,7 +145,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n \n /// Emit a custom diagnostic without going through the miri-engine machinery\n pub fn report_error<'tcx, 'mir>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+    ecx: &InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n     e: InterpErrorInfo<'tcx>,\n ) -> Option<i64> {\n     use InterpError::*;\n@@ -256,17 +255,17 @@ pub fn report_error<'tcx, 'mir>(\n     };\n \n     let stacktrace = ecx.generate_stacktrace();\n-    let (stacktrace, was_pruned) = prune_stacktrace(ecx, stacktrace);\n+    let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine);\n     e.print_backtrace();\n     msg.insert(0, e.to_string());\n     report_msg(\n-        ecx,\n         DiagLevel::Error,\n         &if let Some(title) = title { format!(\"{}: {}\", title, msg[0]) } else { msg[0].clone() },\n         msg,\n         vec![],\n         helps,\n         &stacktrace,\n+        &ecx.machine,\n     );\n \n     // Include a note like `std` does when we omit frames from a backtrace\n@@ -306,17 +305,17 @@ pub fn report_error<'tcx, 'mir>(\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'mir, 'tcx>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+fn report_msg<'tcx>(\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,\n     notes: Vec<(Option<SpanData>, String)>,\n     helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n+    machine: &MiriMachine<'_, 'tcx>,\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n-    let sess = ecx.tcx.sess;\n+    let sess = machine.tcx.sess;\n     let mut err = match diag_level {\n         DiagLevel::Error => sess.struct_span_err(span, title).forget_guarantee(),\n         DiagLevel::Warning => sess.struct_span_warn(span, title),\n@@ -357,7 +356,7 @@ fn report_msg<'mir, 'tcx>(\n     }\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n-        let is_local = ecx.machine.is_local(frame_info);\n+        let is_local = machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n             err.span_note(frame_info.span, &frame_info.to_string());\n@@ -369,164 +368,115 @@ fn report_msg<'mir, 'tcx>(\n     err.emit();\n }\n \n-thread_local! {\n-    static DIAGNOSTICS: RefCell<Vec<NonHaltingDiagnostic>> = RefCell::new(Vec::new());\n-}\n-\n-/// Schedule a diagnostic for emitting. This function works even if you have no `InterpCx` available.\n-/// The diagnostic will be emitted after the current interpreter step is finished.\n-pub fn register_diagnostic(e: NonHaltingDiagnostic) {\n-    DIAGNOSTICS.with(|diagnostics| diagnostics.borrow_mut().push(e));\n-}\n-\n-/// Remember enough about the topmost frame so that we can restore the stack\n-/// after a step was taken.\n-pub struct TopFrameInfo<'tcx> {\n-    stack_size: usize,\n-    instance: Option<ty::Instance<'tcx>>,\n-    span: Span,\n-}\n-\n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn preprocess_diagnostics(&self) -> TopFrameInfo<'tcx> {\n-        // Ensure we have no lingering diagnostics.\n-        DIAGNOSTICS.with(|diagnostics| assert!(diagnostics.borrow().is_empty()));\n-\n-        let this = self.eval_context_ref();\n-        if this.active_thread_stack().is_empty() {\n-            // Diagnostics can happen even with the empty stack (e.g. deallocation of thread-local statics).\n-            return TopFrameInfo { stack_size: 0, instance: None, span: DUMMY_SP };\n-        }\n-        let frame = this.frame();\n+impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n+    pub fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n+        use NonHaltingDiagnostic::*;\n+\n+        let stacktrace =\n+            MiriInterpCx::generate_stacktrace_from_stack(self.threads.active_thread_stack());\n+        let (stacktrace, _was_pruned) = prune_stacktrace(stacktrace, self);\n+\n+        let (title, diag_level) = match e {\n+            RejectedIsolatedOp(_) => (\"operation rejected by isolation\", DiagLevel::Warning),\n+            Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n+            CreatedPointerTag(..)\n+            | PoppedPointerTag(..)\n+            | CreatedCallId(..)\n+            | CreatedAlloc(..)\n+            | FreedAlloc(..)\n+            | ProgressReport { .. }\n+            | WeakMemoryOutdatedLoad => (\"tracking was triggered\", DiagLevel::Note),\n+        };\n+\n+        let msg = match e {\n+            CreatedPointerTag(tag, None) => format!(\"created tag {tag:?}\"),\n+            CreatedPointerTag(tag, Some((alloc_id, range))) =>\n+                format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n+            PoppedPointerTag(item, tag) =>\n+                match tag {\n+                    None => format!(\"popped tracked tag for item {item:?} due to deallocation\",),\n+                    Some((tag, access)) => {\n+                        format!(\n+                            \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n+                        )\n+                    }\n+                },\n+            CreatedCallId(id) => format!(\"function call with id {id}\"),\n+            CreatedAlloc(AllocId(id), size, align, kind) =>\n+                format!(\n+                    \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n+                    size = size.bytes(),\n+                    align = align.bytes(),\n+                ),\n+            FreedAlloc(AllocId(id)) => format!(\"freed allocation with id {id}\"),\n+            RejectedIsolatedOp(ref op) =>\n+                format!(\"{op} was made to return an error due to isolation\"),\n+            ProgressReport { .. } =>\n+                format!(\"progress report: current operation being executed is here\"),\n+            Int2Ptr { .. } => format!(\"integer-to-pointer cast\"),\n+            WeakMemoryOutdatedLoad =>\n+                format!(\"weak memory emulation: outdated value returned from load\"),\n+        };\n+\n+        let notes = match e {\n+            ProgressReport { block_count } => {\n+                // It is important that each progress report is slightly different, since\n+                // identical diagnostics are being deduplicated.\n+                vec![(None, format!(\"so far, {block_count} basic blocks have been executed\"))]\n+            }\n+            _ => vec![],\n+        };\n+\n+        let helps = match e {\n+            Int2Ptr { details: true } =>\n+                vec![\n+                    (\n+                        None,\n+                        format!(\n+                            \"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\"which means that Miri might miss pointer bugs in this program.\"),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\"\n+                        ),\n+                    ),\n+                    (\n+                        None,\n+                        format!(\n+                            \"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\"\n+                        ),\n+                    ),\n+                ],\n+            _ => vec![],\n+        };\n \n-        TopFrameInfo {\n-            stack_size: this.active_thread_stack().len(),\n-            instance: Some(frame.instance),\n-            span: frame.current_span(),\n-        }\n+        report_msg(diag_level, title, vec![msg], notes, helps, &stacktrace, self);\n     }\n+}\n \n-    /// Emit all diagnostics that were registed with `register_diagnostics`\n-    fn process_diagnostics(&self, info: TopFrameInfo<'tcx>) {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n         let this = self.eval_context_ref();\n-        DIAGNOSTICS.with(|diagnostics| {\n-            let mut diagnostics = diagnostics.borrow_mut();\n-            if diagnostics.is_empty() {\n-                return;\n-            }\n-            // We need to fix up the stack trace, because the machine has already\n-            // stepped to the next statement.\n-            let mut stacktrace = this.generate_stacktrace();\n-            // Remove newly pushed frames.\n-            while stacktrace.len() > info.stack_size {\n-                stacktrace.remove(0);\n-            }\n-            // Add popped frame back.\n-            if stacktrace.len() < info.stack_size {\n-                assert!(\n-                    stacktrace.len() == info.stack_size - 1,\n-                    \"we should never pop more than one frame at once\"\n-                );\n-                let frame_info = FrameInfo {\n-                    instance: info.instance.unwrap(),\n-                    span: info.span,\n-                    lint_root: None,\n-                };\n-                stacktrace.insert(0, frame_info);\n-            } else if let Some(instance) = info.instance {\n-                // Adjust topmost frame.\n-                stacktrace[0].span = info.span;\n-                assert_eq!(\n-                    stacktrace[0].instance, instance,\n-                    \"we should not pop and push a frame in one step\"\n-                );\n-            }\n-\n-            let (stacktrace, _was_pruned) = prune_stacktrace(this, stacktrace);\n-\n-            // Show diagnostics.\n-            for e in diagnostics.drain(..) {\n-                use NonHaltingDiagnostic::*;\n-\n-                let (title, diag_level) = match e {\n-                    RejectedIsolatedOp(_) =>\n-                        (\"operation rejected by isolation\", DiagLevel::Warning),\n-                    Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n-                    CreatedPointerTag(..)\n-                    | PoppedPointerTag(..)\n-                    | CreatedCallId(..)\n-                    | CreatedAlloc(..)\n-                    | FreedAlloc(..)\n-                    | ProgressReport { .. }\n-                    | WeakMemoryOutdatedLoad =>\n-                        (\"tracking was triggered\", DiagLevel::Note),\n-                };\n-\n-                let msg = match e {\n-                    CreatedPointerTag(tag, None) =>\n-                        format!(\"created tag {tag:?}\"),\n-                    CreatedPointerTag(tag, Some((alloc_id, range))) =>\n-                        format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n-                    PoppedPointerTag(item, tag) =>\n-                        match tag {\n-                            None =>\n-                                format!(\n-                                    \"popped tracked tag for item {item:?} due to deallocation\",\n-                                ),\n-                            Some((tag, access)) => {\n-                                format!(\n-                                    \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n-                                )\n-                            }\n-                        },\n-                    CreatedCallId(id) =>\n-                        format!(\"function call with id {id}\"),\n-                    CreatedAlloc(AllocId(id), size, align, kind) =>\n-                        format!(\n-                            \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n-                            size = size.bytes(),\n-                            align = align.bytes(),\n-                        ),\n-                    FreedAlloc(AllocId(id)) =>\n-                        format!(\"freed allocation with id {id}\"),\n-                    RejectedIsolatedOp(ref op) =>\n-                        format!(\"{op} was made to return an error due to isolation\"),\n-                    ProgressReport { .. } =>\n-                        format!(\"progress report: current operation being executed is here\"),\n-                    Int2Ptr { .. } =>\n-                        format!(\"integer-to-pointer cast\"),\n-                    WeakMemoryOutdatedLoad =>\n-                        format!(\"weak memory emulation: outdated value returned from load\"),\n-                };\n-\n-                let notes = match e {\n-                    ProgressReport { block_count } => {\n-                        // It is important that each progress report is slightly different, since\n-                        // identical diagnostics are being deduplicated.\n-                        vec![\n-                            (None, format!(\"so far, {block_count} basic blocks have been executed\")),\n-                        ]\n-                    }\n-                    _ => vec![],\n-                };\n-\n-                let helps = match e {\n-                    Int2Ptr { details: true } =>\n-                        vec![\n-                            (None, format!(\"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\")),\n-                            (None, format!(\"which means that Miri might miss pointer bugs in this program.\")),\n-                            (None, format!(\"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\")),\n-                            (None, format!(\"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\")),\n-                            (None, format!(\"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\")),\n-                            (None, format!(\"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\")),\n-                        ],\n-                    _ => vec![],\n-                };\n-\n-                report_msg(this, diag_level, title, vec![msg], notes, helps, &stacktrace);\n-            }\n-        });\n+        this.machine.emit_diagnostic(e);\n     }\n \n     /// We had a panic in Miri itself, try to print something useful.\n@@ -538,13 +488,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_ref();\n         let stacktrace = this.generate_stacktrace();\n         report_msg(\n-            this,\n             DiagLevel::Note,\n             \"the place in the program where the ICE was triggered\",\n             vec![],\n             vec![],\n             vec![],\n             &stacktrace,\n+            &this.machine,\n         );\n     }\n }"}, {"sha": "22bbe4f816cce1c830109b3b27941d22ea2a8227", "filename": "src/eval.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -180,23 +180,19 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     entry_id: DefId,\n     entry_type: EntryFnType,\n     config: &MiriConfig,\n-) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>, MPlaceTy<'tcx, Provenance>)> {\n+) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>, MPlaceTy<'tcx, Provenance>)>\n+{\n     let param_env = ty::ParamEnv::reveal_all();\n     let layout_cx = LayoutCx { tcx, param_env };\n     let mut ecx = InterpCx::new(\n         tcx,\n         rustc_span::source_map::DUMMY_SP,\n         param_env,\n-        Evaluator::new(config, layout_cx),\n+        MiriMachine::new(config, layout_cx),\n     );\n \n-    // Capture the current interpreter stack state (which should be empty) so that we can emit\n-    // allocation-tracking and tag-tracking diagnostics for allocations which are part of the\n-    // early runtime setup.\n-    let info = ecx.preprocess_diagnostics();\n-\n     // Some parts of initialization require a full `InterpCx`.\n-    Evaluator::late_init(&mut ecx, config)?;\n+    MiriMachine::late_init(&mut ecx, config)?;\n \n     // Make sure we have MIR. We check MIR for some stable monomorphic function in libcore.\n     let sentinel = ecx.try_resolve_path(&[\"core\", \"ascii\", \"escape_default\"]);\n@@ -324,10 +320,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         }\n     }\n \n-    // Emit any diagnostics related to the setup process for the runtime, so that when the\n-    // interpreter loop starts there are no unprocessed diagnostics.\n-    ecx.process_diagnostics(info);\n-\n     Ok((ecx, ret_place))\n }\n \n@@ -356,7 +348,6 @@ pub fn eval_entry<'tcx>(\n     let res: thread::Result<InterpResult<'_, i64>> = panic::catch_unwind(AssertUnwindSafe(|| {\n         // Main loop.\n         loop {\n-            let info = ecx.preprocess_diagnostics();\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n@@ -374,7 +365,6 @@ pub fn eval_entry<'tcx>(\n                     break;\n                 }\n             }\n-            ecx.process_diagnostics(info);\n         }\n         let return_code = ecx.read_scalar(&ret_place.into())?.to_machine_isize(&ecx)?;\n         Ok(return_code)"}, {"sha": "0f0bfa355bdc71fde50b7ca01eb586297e947054", "filename": "src/helpers.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -21,7 +21,7 @@ use rand::RngCore;\n \n use crate::*;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n // This mapping should match `decode_error_kind` in\n // <https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/mod.rs>.\n@@ -96,7 +96,7 @@ fn try_resolve_did<'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> Option<DefId> {\n     )\n }\n \n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Gets an instance for a path; fails gracefully if the path does not exist.\n     fn try_resolve_path(&self, path: &[&str]) -> Option<ty::Instance<'tcx>> {\n         let did = try_resolve_did(self.eval_context_ref().tcx.tcx, path)?;\n@@ -391,19 +391,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         where\n             F: FnMut(&MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx>,\n         {\n-            ecx: &'ecx MiriEvalContext<'mir, 'tcx>,\n+            ecx: &'ecx MiriInterpCx<'mir, 'tcx>,\n             unsafe_cell_action: F,\n         }\n \n-        impl<'ecx, 'mir, 'tcx: 'mir, F> ValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n+        impl<'ecx, 'mir, 'tcx: 'mir, F> ValueVisitor<'mir, 'tcx, MiriMachine<'mir, 'tcx>>\n             for UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n         where\n             F: FnMut(&MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx>,\n         {\n             type V = MPlaceTy<'tcx, Provenance>;\n \n             #[inline(always)]\n-            fn ecx(&self) -> &MiriEvalContext<'mir, 'tcx> {\n+            fn ecx(&self) -> &MiriInterpCx<'mir, 'tcx> {\n                 self.ecx\n             }\n \n@@ -508,7 +508,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(())\n             }\n             RejectOpWith::Warning => {\n-                register_diagnostic(NonHaltingDiagnostic::RejectedIsolatedOp(op_name.to_string()));\n+                this.emit_diagnostic(NonHaltingDiagnostic::RejectedIsolatedOp(op_name.to_string()));\n                 Ok(())\n             }\n             RejectOpWith::NoWarning => Ok(()), // no warning\n@@ -883,9 +883,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n-    pub fn current_span(&self, tcx: TyCtxt<'tcx>) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { current_frame_idx: None, machine: self, tcx }\n+impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n+    pub fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n+        CurrentSpan { current_frame_idx: None, machine: self }\n     }\n }\n \n@@ -896,11 +896,14 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n #[derive(Clone)]\n pub struct CurrentSpan<'a, 'mir, 'tcx> {\n     current_frame_idx: Option<usize>,\n-    tcx: TyCtxt<'tcx>,\n-    machine: &'a Evaluator<'mir, 'tcx>,\n+    machine: &'a MiriMachine<'mir, 'tcx>,\n }\n \n impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n+    pub fn machine(&self) -> &'a MiriMachine<'mir, 'tcx> {\n+        self.machine\n+    }\n+\n     /// Get the current span, skipping non-local frames.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n     pub fn get(&mut self) -> Span {\n@@ -916,7 +919,7 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n         Self::frame_span(self.machine, idx.wrapping_sub(1))\n     }\n \n-    fn frame_span(machine: &Evaluator<'_, '_>, idx: usize) -> Span {\n+    fn frame_span(machine: &MiriMachine<'_, '_>, idx: usize) -> Span {\n         machine\n             .threads\n             .active_thread_stack()\n@@ -928,13 +931,13 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n     fn current_frame_idx(&mut self) -> usize {\n         *self\n             .current_frame_idx\n-            .get_or_insert_with(|| Self::compute_current_frame_index(self.tcx, self.machine))\n+            .get_or_insert_with(|| Self::compute_current_frame_index(self.machine))\n     }\n \n     // Find the position of the inner-most frame which is part of the crate being\n     // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n     #[inline(never)]\n-    fn compute_current_frame_index(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> usize {\n+    fn compute_current_frame_index(machine: &MiriMachine<'_, '_>) -> usize {\n         machine\n             .threads\n             .active_thread_stack()\n@@ -944,7 +947,7 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n             .find_map(|(idx, frame)| {\n                 let def_id = frame.instance.def_id();\n                 if (def_id.is_local() || machine.local_crates.contains(&def_id.krate))\n-                    && !frame.instance.def.requires_caller_location(tcx)\n+                    && !frame.instance.def.requires_caller_location(machine.tcx)\n                 {\n                     Some(idx)\n                 } else {"}, {"sha": "b9e5def8fa7cb9c00a345ce5bdc83aef14852cb8", "filename": "src/intptrcast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -59,7 +59,7 @@ impl GlobalStateInner {\n impl<'mir, 'tcx> GlobalStateInner {\n     // Returns the exposed `AllocId` that corresponds to the specified addr,\n     // or `None` if the addr is out of bounds\n-    fn alloc_id_from_addr(ecx: &MiriEvalContext<'mir, 'tcx>, addr: u64) -> Option<AllocId> {\n+    fn alloc_id_from_addr(ecx: &MiriInterpCx<'mir, 'tcx>, addr: u64) -> Option<AllocId> {\n         let global_state = ecx.machine.intptrcast.borrow();\n         assert!(global_state.provenance_mode != ProvenanceMode::Strict);\n \n@@ -97,7 +97,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     }\n \n     pub fn expose_ptr(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         alloc_id: AllocId,\n         sb: SbTag,\n     ) -> InterpResult<'tcx> {\n@@ -114,7 +114,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     }\n \n     pub fn ptr_from_addr_transmute(\n-        _ecx: &MiriEvalContext<'mir, 'tcx>,\n+        _ecx: &MiriInterpCx<'mir, 'tcx>,\n         addr: u64,\n     ) -> Pointer<Option<Provenance>> {\n         trace!(\"Transmuting {:#x} to a pointer\", addr);\n@@ -124,7 +124,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     }\n \n     pub fn ptr_from_addr_cast(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         trace!(\"Casting {:#x} to a pointer\", addr);\n@@ -142,7 +142,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     let first = past_warnings.is_empty();\n                     if past_warnings.insert(ecx.cur_span()) {\n                         // Newly inserted, so first time we see this span.\n-                        register_diagnostic(NonHaltingDiagnostic::Int2Ptr { details: first });\n+                        ecx.emit_diagnostic(NonHaltingDiagnostic::Int2Ptr { details: first });\n                     }\n                 });\n             }\n@@ -156,7 +156,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n         Ok(Pointer::new(Some(Provenance::Wildcard), Size::from_bytes(addr)))\n     }\n \n-    fn alloc_base_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n+    fn alloc_base_addr(ecx: &MiriInterpCx<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n         let mut global_state = ecx.machine.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n@@ -202,7 +202,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     }\n \n     /// Convert a relative (tcx) pointer to an absolute address.\n-    pub fn rel_ptr_to_addr(ecx: &MiriEvalContext<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n+    pub fn rel_ptr_to_addr(ecx: &MiriInterpCx<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n         let (alloc_id, offset) = ptr.into_parts(); // offset is relative (AllocId provenance)\n         let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n \n@@ -214,7 +214,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     /// When a pointer is used for a memory access, this computes where in which allocation the\n     /// access is going.\n     pub fn abs_ptr_to_rel(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         ptr: Pointer<Provenance>,\n     ) -> Option<(AllocId, Size)> {\n         let (tag, addr) = ptr.into_parts(); // addr is absolute (Tag provenance)"}, {"sha": "6006d6c89dbcab993e15237ea55890c7aa916349", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -94,17 +94,17 @@ pub use crate::concurrency::{\n     },\n };\n pub use crate::diagnostics::{\n-    register_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n-    NonHaltingDiagnostic, TerminationInfo,\n+    report_error, EvalContextExt as DiagnosticsEvalContextExt, NonHaltingDiagnostic,\n+    TerminationInfo,\n };\n pub use crate::eval::{\n     create_ecx, eval_entry, AlignmentCheck, BacktraceStyle, IsolatedOp, MiriConfig, RejectOpWith,\n };\n pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind,\n-    Provenance, ProvenanceExtra, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, FrameData, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind, Provenance,\n+    ProvenanceExtra, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;"}, {"sha": "8db546463c2a1b266f2269dfc30a20f13b7066c1", "filename": "src/machine.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -291,9 +291,17 @@ impl<'mir, 'tcx: 'mir> PrimitiveLayouts<'tcx> {\n }\n \n /// The machine itself.\n-pub struct Evaluator<'mir, 'tcx> {\n+pub struct MiriMachine<'mir, 'tcx> {\n+    // We carry a copy of the global `TyCtxt` for convenience, so methods taking just `&Evaluator` have `tcx` access.\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// Stacked Borrows global data.\n     pub stacked_borrows: Option<stacked_borrows::GlobalState>,\n+\n+    /// Data race detector global data.\n     pub data_race: Option<data_race::GlobalState>,\n+\n+    /// Ptr-int-cast module global data.\n     pub intptrcast: intptrcast::GlobalState,\n \n     /// Environment variables set by `setenv`.\n@@ -400,7 +408,7 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) since_gc: u32,\n }\n \n-impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n+impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n     pub(crate) fn new(config: &MiriConfig, layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Self {\n         let target_triple = &layout_cx.tcx.sess.opts.target_triple.to_string();\n         let local_crates = helpers::get_local_crates(layout_cx.tcx);\n@@ -418,7 +426,8 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             ))\n         });\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n-        Evaluator {\n+        MiriMachine {\n+            tcx: layout_cx.tcx,\n             stacked_borrows,\n             data_race,\n             intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n@@ -479,17 +488,17 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     }\n \n     pub(crate) fn late_init(\n-        this: &mut MiriEvalContext<'mir, 'tcx>,\n+        this: &mut MiriInterpCx<'mir, 'tcx>,\n         config: &MiriConfig,\n     ) -> InterpResult<'tcx> {\n         EnvVars::init(this, config)?;\n-        Evaluator::init_extern_statics(this)?;\n+        MiriMachine::init_extern_statics(this)?;\n         ThreadManager::init(this);\n         Ok(())\n     }\n \n     fn add_extern_static(\n-        this: &mut MiriEvalContext<'mir, 'tcx>,\n+        this: &mut MiriInterpCx<'mir, 'tcx>,\n         name: &str,\n         ptr: Pointer<Option<Provenance>>,\n     ) {\n@@ -499,7 +508,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     }\n \n     fn alloc_extern_static(\n-        this: &mut MiriEvalContext<'mir, 'tcx>,\n+        this: &mut MiriInterpCx<'mir, 'tcx>,\n         name: &str,\n         val: ImmTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n@@ -510,7 +519,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     }\n \n     /// Sets up the \"extern statics\" for this machine.\n-    fn init_extern_statics(this: &mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx> {\n+    fn init_extern_statics(this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n         match this.tcx.sess.target.os.as_ref() {\n             \"linux\" => {\n                 // \"environ\"\n@@ -576,26 +585,26 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n }\n \n /// A rustc InterpCx for Miri.\n-pub type MiriEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>;\n+pub type MiriInterpCx<'mir, 'tcx> = InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>;\n \n /// A little trait that's useful to be inherited by extension traits.\n-pub trait MiriEvalContextExt<'mir, 'tcx> {\n-    fn eval_context_ref<'a>(&'a self) -> &'a MiriEvalContext<'mir, 'tcx>;\n-    fn eval_context_mut<'a>(&'a mut self) -> &'a mut MiriEvalContext<'mir, 'tcx>;\n+pub trait MiriInterpCxExt<'mir, 'tcx> {\n+    fn eval_context_ref<'a>(&'a self) -> &'a MiriInterpCx<'mir, 'tcx>;\n+    fn eval_context_mut<'a>(&'a mut self) -> &'a mut MiriInterpCx<'mir, 'tcx>;\n }\n-impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {\n+impl<'mir, 'tcx> MiriInterpCxExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {\n     #[inline(always)]\n-    fn eval_context_ref(&self) -> &MiriEvalContext<'mir, 'tcx> {\n+    fn eval_context_ref(&self) -> &MiriInterpCx<'mir, 'tcx> {\n         self\n     }\n     #[inline(always)]\n-    fn eval_context_mut(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n+    fn eval_context_mut(&mut self) -> &mut MiriInterpCx<'mir, 'tcx> {\n         self\n     }\n }\n \n /// Machine hook implementations.\n-impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n+impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     type MemoryKind = MiriMemoryKind;\n     type ExtraFnVal = Dlsym;\n \n@@ -615,33 +624,33 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     const PANIC_ON_ALLOC_FAIL: bool = false;\n \n     #[inline(always)]\n-    fn enforce_alignment(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+    fn enforce_alignment(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.machine.check_alignment != AlignmentCheck::None\n     }\n \n     #[inline(always)]\n-    fn use_addr_for_alignment_check(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+    fn use_addr_for_alignment_check(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.machine.check_alignment == AlignmentCheck::Int\n     }\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+    fn enforce_validity(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.machine.validate\n     }\n \n     #[inline(always)]\n-    fn enforce_abi(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+    fn enforce_abi(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.machine.enforce_abi\n     }\n \n     #[inline(always)]\n-    fn checked_binop_checks_overflow(ecx: &MiriEvalContext<'mir, 'tcx>) -> bool {\n+    fn checked_binop_checks_overflow(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n         ecx.tcx.sess.overflow_checks()\n     }\n \n     #[inline(always)]\n     fn find_mir_or_eval_fn(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n         args: &[OpTy<'tcx, Provenance>],\n@@ -654,7 +663,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn call_extra_fn(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         fn_val: Dlsym,\n         abi: Abi,\n         args: &[OpTy<'tcx, Provenance>],\n@@ -667,7 +676,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn call_intrinsic(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Provenance>],\n         dest: &PlaceTy<'tcx, Provenance>,\n@@ -679,21 +688,21 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn assert_panic(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         msg: &mir::AssertMessage<'tcx>,\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         ecx.assert_panic(msg, unwind)\n     }\n \n     #[inline(always)]\n-    fn abort(_ecx: &mut MiriEvalContext<'mir, 'tcx>, msg: String) -> InterpResult<'tcx, !> {\n+    fn abort(_ecx: &mut MiriInterpCx<'mir, 'tcx>, msg: String) -> InterpResult<'tcx, !> {\n         throw_machine_stop!(TerminationInfo::Abort(msg))\n     }\n \n     #[inline(always)]\n     fn binary_ptr_op(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         bin_op: mir::BinOp,\n         left: &ImmTy<'tcx, Provenance>,\n         right: &ImmTy<'tcx, Provenance>,\n@@ -702,14 +711,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     fn thread_local_static_base_pointer(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         ecx.get_or_create_thread_local_alloc(def_id)\n     }\n \n     fn extern_static_base_pointer(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         let link_name = ecx.item_link_name(def_id);\n@@ -748,14 +757,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     fn adjust_allocation<'b>(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n     ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>> {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         if ecx.machine.tracked_alloc_ids.contains(&id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(\n+            ecx.emit_diagnostic(NonHaltingDiagnostic::CreatedAlloc(\n                 id,\n                 alloc.size(),\n                 alloc.align,\n@@ -770,7 +779,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 alloc.size(),\n                 stacked_borrows,\n                 kind,\n-                ecx.machine.current_span(*ecx.tcx),\n+                ecx.machine.current_span(),\n             )\n         });\n         let race_alloc = ecx.machine.data_race.as_ref().map(|data_race| {\n@@ -795,7 +804,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     }\n \n     fn adjust_alloc_base_pointer(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<Provenance> {\n         if cfg!(debug_assertions) {\n@@ -813,7 +822,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance)\n+            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n             SbTag::default()\n@@ -826,7 +835,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn ptr_from_addr_cast(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>> {\n         intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr)\n@@ -850,7 +859,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     /// Convert a pointer with provenance into an allocation-offset pair,\n     /// or a `None` with an absolute address if that conversion is not possible.\n     fn ptr_get_alloc(\n-        ecx: &MiriEvalContext<'mir, 'tcx>,\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n         ptr: Pointer<Self::Provenance>,\n     ) -> Option<(AllocId, Size, Self::ProvenanceExtra)> {\n         let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n@@ -866,7 +875,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_read(\n-        tcx: TyCtxt<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n         alloc_extra: &AllocExtra,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n@@ -886,7 +895,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(tcx),\n+                machine.current_span(),\n                 &machine.threads,\n             )?;\n         }\n@@ -898,7 +907,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_write(\n-        tcx: TyCtxt<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n@@ -918,7 +927,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(tcx),\n+                machine.current_span(),\n                 &machine.threads,\n             )?;\n         }\n@@ -930,14 +939,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     #[inline(always)]\n     fn before_memory_deallocation(\n-        tcx: TyCtxt<'tcx>,\n+        _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n         (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if machine.tracked_alloc_ids.contains(&alloc_id) {\n-            register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n+            machine.emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.deallocate(\n@@ -953,7 +962,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 prove_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n-                machine.current_span(tcx),\n+                machine.current_span(),\n                 &machine.threads,\n             )\n         } else {\n@@ -993,7 +1002,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n \n         let extra = FrameData {\n-            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame()),\n+            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.machine)),\n             catch_unwind: None,\n             timing,\n         };\n@@ -1018,7 +1027,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         // Possibly report our progress.\n         if let Some(report_progress) = ecx.machine.report_progress {\n             if ecx.machine.basic_block_count % u64::from(report_progress) == 0 {\n-                register_diagnostic(NonHaltingDiagnostic::ProgressReport {\n+                ecx.emit_diagnostic(NonHaltingDiagnostic::ProgressReport {\n                     block_count: ecx.machine.basic_block_count,\n                 });\n             }"}, {"sha": "a0ef7fcad16dcca5843aff2791d80848985621db", "filename": "src/operator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -14,7 +14,7 @@ pub trait EvalContextExt<'tcx> {\n     ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, Ty<'tcx>)>;\n }\n \n-impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n+impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriInterpCx<'mir, 'tcx> {\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "15987eee537fd72372cab58e2c654ab206631c9e", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -5,8 +5,8 @@ use rustc_middle::ty::{self, Instance};\n use rustc_span::{BytePos, Loc, Symbol};\n use rustc_target::{abi::Size, spec::abi::Abi};\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn handle_miri_backtrace_size(\n         &mut self,\n         abi: Abi,"}, {"sha": "8bf6d24f85f31a1407b765b1d34b4e8aacb5ac59", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -27,8 +27,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "638c18934bd67bf2dc0322923eb22ad386245d85", "filename": "src/shims/env.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -38,7 +38,7 @@ pub struct EnvVars<'tcx> {\n \n impl<'tcx> EnvVars<'tcx> {\n     pub(crate) fn init<'mir>(\n-        ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+        ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n         config: &MiriConfig,\n     ) -> InterpResult<'tcx> {\n         let target_os = ecx.tcx.sess.target.os.as_ref();\n@@ -74,7 +74,7 @@ impl<'tcx> EnvVars<'tcx> {\n     }\n \n     pub(crate) fn cleanup<'mir>(\n-        ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+        ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n     ) -> InterpResult<'tcx> {\n         // Deallocate individual env vars.\n         let env_vars = mem::take(&mut ecx.machine.env_vars.map);\n@@ -92,7 +92,7 @@ impl<'tcx> EnvVars<'tcx> {\n fn alloc_env_var_as_c_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n-    ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+    ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n@@ -103,16 +103,16 @@ fn alloc_env_var_as_c_str<'mir, 'tcx>(\n fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n-    ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+    ecx: &mut InterpCx<'mir, 'tcx, MiriMachine<'mir, 'tcx>>,\n ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n     ecx.alloc_os_str_as_wide_str(name_osstring.as_os_str(), MiriMemoryKind::Runtime.into())\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn getenv(\n         &mut self,\n         name_op: &OpTy<'tcx, Provenance>,"}, {"sha": "0813554e9d24e851a47bba681b9b654a686b2cb6", "filename": "src/shims/ffi_support.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fffi_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fffi_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fffi_support.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -7,9 +7,9 @@ use rustc_target::abi::HasDataLayout;\n \n use crate::*;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Extract the scalar value from the result of reading a scalar from the machine,\n     /// and convert it to a `CArg`.\n     fn scalar_to_carg("}, {"sha": "6d052083d370c88740bf3a16bc952b15644eeed7", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -38,8 +38,8 @@ pub enum EmulateByNameResult<'mir, 'tcx> {\n     NotSupported,\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Returns the minimum alignment for the target architecture for allocations of the given size.\n     fn min_align(&self, size: u64, kind: MiriMemoryKind) -> Align {\n         let this = self.eval_context_ref();\n@@ -334,7 +334,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn emulate_allocator(\n         &mut self,\n         symbol: Symbol,\n-        default: impl FnOnce(&mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx>,\n+        default: impl FnOnce(&mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "50f69bdca363197f4517bdf48742bc48fab025ac", "filename": "src/shims/intrinsics/atomic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fatomic.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -11,8 +11,8 @@ pub enum AtomicOp {\n     Min,\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Calls the atomic intrinsic `intrinsic`; the `atomic_` prefix has already been removed.\n     fn emulate_atomic_intrinsic(\n         &mut self,\n@@ -119,8 +119,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx> {}\n-trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn atomic_load(\n         &mut self,\n         args: &[OpTy<'tcx, Provenance>],"}, {"sha": "b85c799e2da66082002dd8ad70e3bf2190db962f", "filename": "src/shims/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fmod.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -18,8 +18,8 @@ use atomic::EvalContextExt as _;\n use helpers::check_arg_count;\n use simd::EvalContextExt as _;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "163d185f66f3a1f4fc54fc635bfb16d9642defbd", "filename": "src/shims/intrinsics/simd.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fsimd.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -6,8 +6,8 @@ use rustc_target::abi::{Endian, HasDataLayout, Size};\n use crate::*;\n use helpers::check_arg_count;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Calls the simd intrinsic `intrinsic`; the `simd_` prefix has already been removed.\n     fn emulate_simd_intrinsic(\n         &mut self,"}, {"sha": "93083b486bfbf742b3f6a713bd282455e06f9826", "filename": "src/shims/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -24,8 +24,8 @@ use rustc_target::spec::abi::Abi;\n use crate::*;\n use helpers::check_arg_count;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn find_mir_or_eval_fn(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "407dab970ad7dcdbcac28652f0aab4df58b96ae1", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -46,8 +46,8 @@ pub fn bytes_to_os_str<'a, 'tcx>(bytes: &'a [u8]) -> InterpResult<'tcx, &'a OsSt\n     Ok(OsStr::new(s))\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n     /// the Unix APIs usually handle.\n     fn read_os_str_from_c_str<'a>("}, {"sha": "2e8245acf4a68daf2a12e3a0a64e7e049b78f5c5", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -35,8 +35,8 @@ pub struct CatchUnwindData<'tcx> {\n     ret: mir::BasicBlock,\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Handles the special `miri_start_panic` intrinsic, which is called\n     /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n     fn handle_miri_start_panic("}, {"sha": "24fe52453939653720cf1286ae286f80829b85ef", "filename": "src/shims/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -8,8 +8,8 @@ pub fn system_time_to_duration<'tcx>(time: &SystemTime) -> InterpResult<'tcx, Du\n         .map_err(|_| err_unsup_format!(\"times before the Unix epoch are not supported\").into())\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn clock_gettime(\n         &mut self,\n         clk_id_op: &OpTy<'tcx, Provenance>,"}, {"sha": "d93d6a16a0736fe87883ef739895ddcd79e96dfb", "filename": "src/shims/tls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -241,8 +241,8 @@ impl<'tcx> TlsData<'tcx> {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Schedule TLS destructors for Windows.\n     /// On windows, TLS destructors are managed by std.\n     fn schedule_windows_tls_dtors(&mut self) -> InterpResult<'tcx> {\n@@ -346,8 +346,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Schedule an active thread's TLS destructor to run on the active thread.\n     /// Note that this function does not run the destructors itself, it just\n     /// schedules them one by one each time it is called and reenables the"}, {"sha": "4cb78d4dabdcfd910cf9af0d5102448db9551fba", "filename": "src/shims/unix/android/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fandroid%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fandroid%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fandroid%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -21,8 +21,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "756aed369f15b2c2042d9286f157c91fd6ed2085", "filename": "src/shims/unix/android/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fandroid%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fandroid%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fandroid%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -4,9 +4,9 @@ use rustc_target::spec::abi::Abi;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: Symbol,"}, {"sha": "8bc19d18f2b29858b0851ab1c819af10ffb5d0c8", "filename": "src/shims/unix/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -29,8 +29,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "153e5852dcc882524391fc2a8745e89880906a5d", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -13,8 +13,8 @@ use shims::unix::fs::EvalContextExt as _;\n use shims::unix::sync::EvalContextExt as _;\n use shims::unix::thread::EvalContextExt as _;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: Symbol,\n@@ -228,7 +228,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 // FIXME: Which of these are POSIX, and which are GNU/Linux?\n                 // At least the names seem to all also exist on macOS.\n-                let sysconfs: &[(&str, fn(&MiriEvalContext<'_, '_>) -> Scalar<Provenance>)] = &[\n+                let sysconfs: &[(&str, fn(&MiriInterpCx<'_, '_>) -> Scalar<Provenance>)] = &[\n                     (\"_SC_PAGESIZE\", |this| Scalar::from_int(PAGE_SIZE, this.pointer_size())),\n                     (\"_SC_NPROCESSORS_CONF\", |this| Scalar::from_int(NUM_CPUS, this.pointer_size())),\n                     (\"_SC_NPROCESSORS_ONLN\", |this| Scalar::from_int(NUM_CPUS, this.pointer_size())),"}, {"sha": "d759ffb8994b7e7bfb7c5d17e9bc54c1313a6ac6", "filename": "src/shims/unix/freebsd/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -14,8 +14,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "70798f98174533c4886b800a63157de32ce8b4a4", "filename": "src/shims/unix/freebsd/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -5,9 +5,9 @@ use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n use shims::unix::thread::EvalContextExt as _;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: Symbol,"}, {"sha": "edeb2001f93a00bd034ee809a9913e038e6a01ff", "filename": "src/shims/unix/fs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffs.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -304,8 +304,8 @@ impl FileHandler {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExtPrivate<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExtPrivate<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn macos_stat_write_buf(\n         &mut self,\n         metadata: FileMetadata,\n@@ -478,8 +478,8 @@ fn maybe_sync_file(\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn open(&mut self, args: &[OpTy<'tcx, Provenance>]) -> InterpResult<'tcx, i32> {\n         if args.len() < 2 {\n             throw_ub_format!(\n@@ -1892,7 +1892,7 @@ struct FileMetadata {\n \n impl FileMetadata {\n     fn from_path<'tcx, 'mir>(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         path: &Path,\n         follow_symlink: bool,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n@@ -1903,7 +1903,7 @@ impl FileMetadata {\n     }\n \n     fn from_fd<'tcx, 'mir>(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         fd: i32,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n@@ -1917,7 +1917,7 @@ impl FileMetadata {\n     }\n \n     fn from_meta<'tcx, 'mir>(\n-        ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+        ecx: &mut MiriInterpCx<'mir, 'tcx>,\n         metadata: Result<std::fs::Metadata, std::io::Error>,\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let metadata = match metadata {"}, {"sha": "a96c14c142b25a42ee0821f4ea1ca70bfeace650", "filename": "src/shims/unix/linux/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Flinux%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Flinux%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -18,8 +18,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "5d000f9d121d48a75e8b262ae325cd11648c0a67", "filename": "src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -8,8 +8,8 @@ use shims::unix::linux::sync::futex;\n use shims::unix::sync::EvalContextExt as _;\n use shims::unix::thread::EvalContextExt as _;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: Symbol,\n@@ -167,7 +167,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n // Shims the linux `getrandom` syscall.\n fn getrandom<'tcx>(\n-    this: &mut MiriEvalContext<'_, 'tcx>,\n+    this: &mut MiriInterpCx<'_, 'tcx>,\n     ptr: &OpTy<'tcx, Provenance>,\n     len: &OpTy<'tcx, Provenance>,\n     flags: &OpTy<'tcx, Provenance>,"}, {"sha": "5a6ce28d25c9f439873ab99eccd5552bf2b314a7", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -6,7 +6,7 @@ use std::time::SystemTime;\n /// Implementation of the SYS_futex syscall.\n /// `args` is the arguments *after* the syscall number.\n pub fn futex<'tcx>(\n-    this: &mut MiriEvalContext<'_, 'tcx>,\n+    this: &mut MiriInterpCx<'_, 'tcx>,\n     args: &[OpTy<'tcx, Provenance>],\n     dest: &PlaceTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx> {"}, {"sha": "18804b45efca91cc848434e40b95f4d5d4910e47", "filename": "src/shims/unix/macos/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -22,8 +22,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "38d791fba98a4debc99105ccf4ac83d00331121b", "filename": "src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -6,8 +6,8 @@ use shims::foreign_items::EmulateByNameResult;\n use shims::unix::fs::EvalContextExt as _;\n use shims::unix::thread::EvalContextExt as _;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: Symbol,"}, {"sha": "2e972a27ffebe428441334c6309f0a3b455355c8", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -20,14 +20,14 @@ use crate::*;\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: Scalar<Provenance>,\n ) -> InterpResult<'tcx, bool> {\n     Ok(kind == ecx.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?)\n }\n \n fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: Scalar<Provenance>,\n ) -> InterpResult<'tcx, bool> {\n     let kind = kind.to_i32()?;\n@@ -36,14 +36,14 @@ fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n }\n \n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n     kind: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n@@ -60,7 +60,7 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n@@ -73,7 +73,7 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n }\n \n fn mutex_set_kind<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n     kind: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n@@ -88,14 +88,14 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n }\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n     id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n@@ -109,7 +109,7 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n }\n \n fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, MutexId> {\n     let value_place = ecx.deref_operand_and_offset(mutex_op, 4, ecx.machine.layouts.u32)?;\n@@ -143,14 +143,14 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n // bytes 4-7: rwlock id as u32 or 0 if id is not assigned yet.\n \n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let value_place = ecx.deref_operand_and_offset(rwlock_op, 4, ecx.machine.layouts.u32)?;\n@@ -183,14 +183,14 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n // (e.g. CLOCK_REALTIME).\n \n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n     clock_id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n@@ -212,14 +212,14 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n // bytes 8-11: the clock id constant as i32\n \n fn cond_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n     id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n@@ -233,7 +233,7 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n }\n \n fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, CondvarId> {\n     let value_place = ecx.deref_operand_and_offset(cond_op, 4, ecx.machine.layouts.u32)?;\n@@ -260,14 +260,14 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n }\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n+    ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, Scalar<Provenance>> {\n     ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n     clock_id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n@@ -282,7 +282,7 @@ fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n /// Try to reacquire the mutex associated with the condition variable after we\n /// were signaled.\n fn reacquire_cond_mutex<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n@@ -299,7 +299,7 @@ fn reacquire_cond_mutex<'mir, 'tcx: 'mir>(\n /// Reacquire the conditional variable and remove the timeout callback if any\n /// was registered.\n fn post_cond_signal<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n@@ -313,7 +313,7 @@ fn post_cond_signal<'mir, 'tcx: 'mir>(\n /// Release the mutex associated with the condition variable because we are\n /// entering the waiting state.\n fn release_cond_mutex_and_block<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     active_thread: ThreadId,\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n@@ -328,8 +328,8 @@ fn release_cond_mutex_and_block<'mir, 'tcx: 'mir>(\n     Ok(())\n }\n \n-impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_mutexattr_init(\n         &mut self,\n         attr_op: &OpTy<'tcx, Provenance>,"}, {"sha": "59474d8d10ad7b058e207536356b8b5a3f623ab0", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -2,8 +2,8 @@ use crate::*;\n use rustc_middle::ty::layout::LayoutOf;\n use rustc_target::spec::abi::Abi;\n \n-impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_create(\n         &mut self,\n         thread: &OpTy<'tcx, Provenance>,"}, {"sha": "41b9473f81fef6dbdc01f2b07b75106afb044fb2", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -27,8 +27,8 @@ impl Dlsym {\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,"}, {"sha": "53ab97b255e56f8644e29827b05508a52a99d288", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -12,8 +12,8 @@ use shims::windows::thread::EvalContextExt as _;\n \n use smallvec::SmallVec;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn emulate_foreign_item_by_name(\n         &mut self,\n         link_name: Symbol,"}, {"sha": "5b22c4bd73584806cf28ff3ff93735c7d342bbcf", "filename": "src/shims/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fhandle.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -145,10 +145,10 @@ impl Handle {\n     }\n }\n \n-impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n #[allow(non_snake_case)]\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn invalid_handle(&mut self, function_name: &str) -> InterpResult<'tcx, !> {\n         throw_machine_stop!(TerminationInfo::Abort(format!(\n             \"invalid handle passed to `{function_name}`\""}, {"sha": "dc1052a824defa883266918b0cc893d35eedc2e1", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -4,7 +4,7 @@ use crate::*;\n // We use the first 4 bytes to store the RwLockId.\n \n fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     lock_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let value_place = ecx.deref_operand_and_offset(lock_op, 0, ecx.machine.layouts.u32)?;\n@@ -30,8 +30,8 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     })\n }\n \n-impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     #[allow(non_snake_case)]\n     fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "5ed0cb92f9e347acbb78a2259c392d131739c0d8", "filename": "src/shims/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fthread.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -4,10 +4,10 @@ use rustc_target::spec::abi::Abi;\n use crate::*;\n use shims::windows::handle::{EvalContextExt as _, Handle, PseudoHandle};\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n \n #[allow(non_snake_case)]\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn CreateThread(\n         &mut self,\n         security_op: &OpTy<'tcx, Provenance>,"}, {"sha": "0d76ed4e30878c1f24dd8ee686280f3778262e17", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -471,7 +471,9 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.current_span\n+            .machine()\n+            .emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "f7f4b1357f1069ce880d2a6e6966571dfdd015fa", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -178,11 +178,11 @@ impl GlobalStateInner {\n         id\n     }\n \n-    pub fn new_frame(&mut self) -> FrameExtra {\n+    pub fn new_frame(&mut self, machine: &MiriMachine<'_, '_>) -> FrameExtra {\n         let call_id = self.next_call_id;\n         trace!(\"new_frame: Assigning call ID {}\", call_id);\n         if self.tracked_call_ids.contains(&call_id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n+            machine.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n         }\n         self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n         FrameExtra { call_id, protected_tags: SmallVec::new() }\n@@ -199,11 +199,11 @@ impl GlobalStateInner {\n         }\n     }\n \n-    pub fn base_ptr_tag(&mut self, id: AllocId) -> SbTag {\n+    pub fn base_ptr_tag(&mut self, id: AllocId, machine: &MiriMachine<'_, '_>) -> SbTag {\n         self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n             let tag = self.new_ptr();\n             if self.tracked_pointer_tags.contains(&tag) {\n-                register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None));\n+                machine.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None));\n             }\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n             self.base_ptr_tags.try_insert(id, tag).unwrap();\n@@ -572,9 +572,10 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_ptr_tag(id), Permission::Unique),\n+            MemoryKind::Stack =>\n+                (extra.base_ptr_tag(id, current_span.machine()), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, current_span.machine()), Permission::SharedReadWrite),\n         };\n         Stacks::new(size, perm, base_tag, id, &mut current_span)\n     }\n@@ -651,10 +652,10 @@ impl Stacks {\n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n /// to grant for which references, and when to add protectors.\n impl<'mir: 'ecx, 'tcx: 'mir, 'ecx> EvalContextPrivExt<'mir, 'tcx, 'ecx>\n-    for crate::MiriEvalContext<'mir, 'tcx>\n+    for crate::MiriInterpCx<'mir, 'tcx>\n {\n }\n-trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Returns the `AllocId` the reborrow was done in, if some actual borrow stack manipulation\n     /// happened.\n     fn reborrow(\n@@ -669,12 +670,12 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n         let this = self.eval_context_mut();\n \n         // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n-        let log_creation = |this: &MiriEvalContext<'mir, 'tcx>,\n+        let log_creation = |this: &MiriInterpCx<'mir, 'tcx>,\n                             loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n          -> InterpResult<'tcx> {\n             let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n             if global.tracked_pointer_tags.contains(&new_tag) {\n-                register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n                     new_tag.0,\n                     loc.map(|(alloc_id, base_offset, _)| (alloc_id, alloc_range(base_offset, size))),\n                 ));\n@@ -688,7 +689,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n-                    let current_span = &mut this.machine.current_span(*this.tcx);\n+                    let current_span = &mut this.machine.current_span();\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -805,7 +806,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n                 // FIXME: can't share this with the current_span inside log_creation\n-                let mut current_span = this.machine.current_span(*this.tcx);\n+                let mut current_span = this.machine.current_span();\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -843,7 +844,6 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n         // Here we can avoid `borrow()` calls because we have mutable references.\n         // Note that this asserts that the allocation is mutable -- but since we are creating a\n         // mutable pointer, that seems reasonable.\n-        let tcx = *this.tcx;\n         let (alloc_extra, machine) = this.get_alloc_extra_mut(alloc_id)?;\n         let mut stacked_borrows = alloc_extra\n             .stacked_borrows\n@@ -854,7 +854,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         // FIXME: can't share this with the current_span inside log_creation\n-        let current_span = &mut machine.current_span(tcx);\n+        let current_span = &mut machine.current_span();\n         let dcx = DiagnosticCxBuilder::retag(\n             current_span,\n             &machine.threads,\n@@ -920,8 +920,8 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n     }\n }\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n@@ -957,7 +957,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // The actual visitor.\n         struct RetagVisitor<'ecx, 'mir, 'tcx> {\n-            ecx: &'ecx mut MiriEvalContext<'mir, 'tcx>,\n+            ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n             kind: RetagKind,\n             retag_cause: RetagCause,\n             retag_fields: bool,\n@@ -977,13 +977,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(())\n             }\n         }\n-        impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n+        impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, MiriMachine<'mir, 'tcx>>\n             for RetagVisitor<'ecx, 'mir, 'tcx>\n         {\n             type V = PlaceTy<'tcx, Provenance>;\n \n             #[inline(always)]\n-            fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n+            fn ecx(&mut self) -> &mut MiriInterpCx<'mir, 'tcx> {\n                 self.ecx\n             }\n "}, {"sha": "e20a86711478ae076cb1a261337320fc67b7c3e8", "filename": "src/tag_gc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Ftag_gc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c/src%2Ftag_gc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftag_gc.rs?ref=d9ad25ee4bbd9364c498959cdc82b5fa6c41e63c", "patch": "@@ -1,8 +1,8 @@\n use crate::*;\n use rustc_data_structures::fx::FxHashSet;\n \n-impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     fn garbage_collect_tags(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         // No reason to do anything at all if stacked borrows is off."}]}