{"sha": "2271b081ebdb10af25aca0206e53931eaed92d3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNzFiMDgxZWJkYjEwYWYyNWFjYTAyMDZlNTM5MzFlYWVkOTJkM2E=", "commit": {"author": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-08-20T07:34:08Z"}, "committer": {"name": "csmoe", "email": "csmoe@msn.com", "date": "2020-08-25T06:02:55Z"}, "message": "suggest await before method", "tree": {"sha": "2707b6d95db363759f6fd7f8a5e7182b134d3638", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2707b6d95db363759f6fd7f8a5e7182b134d3638"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2271b081ebdb10af25aca0206e53931eaed92d3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2271b081ebdb10af25aca0206e53931eaed92d3a", "html_url": "https://github.com/rust-lang/rust/commit/2271b081ebdb10af25aca0206e53931eaed92d3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2271b081ebdb10af25aca0206e53931eaed92d3a/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1de0dd9531bfae1db458c0d88830a5c09203a100", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de0dd9531bfae1db458c0d88830a5c09203a100", "html_url": "https://github.com/rust-lang/rust/commit/1de0dd9531bfae1db458c0d88830a5c09203a100"}], "stats": {"total": 114, "additions": 97, "deletions": 17}, "files": [{"sha": "0f2e4240c01dd198ae03aa89e2ac297f0bd31401", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=2271b081ebdb10af25aca0206e53931eaed92d3a", "patch": "@@ -31,7 +31,6 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n-use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::Ty;\n use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{AdtKind, Visibility};\n@@ -1517,22 +1516,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         def_id: DefId,\n-        substs: SubstsRef<'tcx>,\n     ) {\n         let param_env = self.tcx().param_env(def_id);\n         let future_trait = self.tcx.require_lang_item(lang_items::FutureTraitLangItem, None);\n-        let future_trait_ref = ty::TraitRef { def_id: future_trait, substs };\n         // Future::Output\n-        let future_projection = ty::ProjectionTy::from_ref_and_name(\n-            self.tcx,\n-            future_trait_ref,\n-            Ident::with_dummy_span(sym::Output),\n-        );\n+        let item_def_id =\n+            self.tcx.associated_items(future_trait).in_definition_order().next().unwrap().def_id;\n \n         let mut projection_ty = None;\n         for (predicate, _) in self.tcx.predicates_of(def_id).predicates {\n             if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n-                if future_projection.item_def_id == projection_predicate.projection_ty.item_def_id {\n+                if item_def_id == projection_predicate.projection_ty.item_def_id {\n                     projection_ty = Some(projection_predicate.projection_ty);\n                     break;\n                 }\n@@ -1600,8 +1594,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n-            ty::Opaque(def_id, subts) => {\n-                self.suggest_await_on_field_access(&mut err, field, base, expr, def_id, subts);\n+            ty::Opaque(def_id, _) => {\n+                self.suggest_await_on_field_access(&mut err, field, base, expr, def_id);\n             }\n             _ => {}\n         }"}, {"sha": "8451918568d7dd71d6ead99bfb755d4133cbe433", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2271b081ebdb10af25aca0206e53931eaed92d3a", "patch": "@@ -21,6 +21,7 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n+use rustc_trait_selection::traits::SelectionContext;\n \n use std::cmp::Ordering;\n \n@@ -392,6 +393,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             actual.prefix_string(),\n                             ty_str,\n                         );\n+                        if let Mode::MethodCall = mode {\n+                            if let SelfSource::MethodCall(call) = source {\n+                                self.suggest_await_before_method(\n+                                    &mut err, item_name, actual, call, span,\n+                                );\n+                            }\n+                        }\n                         if let Some(span) =\n                             tcx.sess.confused_type_with_std_module.borrow().get(&span)\n                         {\n@@ -854,6 +862,69 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_await_before_method(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        item_name: Ident,\n+        ty: Ty<'tcx>,\n+        call: &hir::Expr<'_>,\n+        span: Span,\n+    ) {\n+        if let ty::Opaque(def_id, _substs) = ty.kind {\n+            let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n+            // Future::Output\n+            let item_def_id = self\n+                .tcx\n+                .associated_items(future_trait)\n+                .in_definition_order()\n+                .next()\n+                .unwrap()\n+                .def_id;\n+\n+            let mut projection_ty = None;\n+            for (predicate, _) in self.tcx.predicates_of(def_id).predicates {\n+                if let ty::PredicateAtom::Projection(projection_predicate) =\n+                    predicate.skip_binders()\n+                {\n+                    if item_def_id == projection_predicate.projection_ty.item_def_id {\n+                        projection_ty = Some(projection_predicate.projection_ty);\n+                        break;\n+                    }\n+                }\n+            }\n+            let cause = self.misc(span);\n+            let mut selcx = SelectionContext::new(&self.infcx);\n+            let mut obligations = vec![];\n+            if let Some(projection_ty) = projection_ty {\n+                let normalized_ty = rustc_trait_selection::traits::normalize_projection_type(\n+                    &mut selcx,\n+                    self.param_env,\n+                    projection_ty,\n+                    cause,\n+                    0,\n+                    &mut obligations,\n+                );\n+                debug!(\n+                    \"suggest_await_before_method: normalized_ty={:?}, ty_kind={:?}\",\n+                    self.resolve_vars_if_possible(&normalized_ty),\n+                    normalized_ty.kind,\n+                );\n+                let method_exists = self.method_exists(item_name, normalized_ty, call.hir_id, true);\n+                debug!(\"suggest_await_before_method: is_method_exist={}\", method_exists);\n+                if let Ok(sp) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    if method_exists {\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider await before this method call\",\n+                            format!(\"await.{}\", sp),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_use_candidates(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}, {"sha": "743f19598283ac511c0bdeb126d7e67847457bee", "filename": "src/test/ui/async-await/issue-61076.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.rs?ref=2271b081ebdb10af25aca0206e53931eaed92d3a", "patch": "@@ -12,6 +12,10 @@ struct Struct {\n     a: i32\n }\n \n+impl Struct {\n+    fn method(&self) {}\n+}\n+\n impl Future for Struct {\n     type Output = Struct;\n     fn poll(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Self::Output> { Poll::Pending }\n@@ -55,6 +59,8 @@ async fn baz() -> Result<(), ()> {\n \n     let _: i32 = struct_().a; //~ ERROR no field `a`\n \n+    struct_().method(); //~ ERROR no method named\n+\n     Ok(())\n }\n "}, {"sha": "692117a06b06c6f27653e854a19e25b5b13964c8", "filename": "src/test/ui/async-await/issue-61076.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2271b081ebdb10af25aca0206e53931eaed92d3a/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61076.stderr?ref=2271b081ebdb10af25aca0206e53931eaed92d3a", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/issue-61076.rs:38:5\n+  --> $DIR/issue-61076.rs:42:5\n    |\n LL |     foo()?;\n    |     ^^^^^^\n@@ -11,7 +11,7 @@ LL |     foo()?;\n    = note: required by `std::ops::Try::into_result`\n \n error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n-  --> $DIR/issue-61076.rs:52:5\n+  --> $DIR/issue-61076.rs:56:5\n    |\n LL |     t?;\n    |     ^^\n@@ -23,22 +23,31 @@ LL |     t?;\n    = note: required by `std::ops::Try::into_result`\n \n error[E0609]: no field `0` on type `impl std::future::Future`\n-  --> $DIR/issue-61076.rs:54:26\n+  --> $DIR/issue-61076.rs:58:26\n    |\n LL |     let _: i32 = tuple().0;\n    |                  --------^\n    |                  |\n    |                  help: consider await before field access: `tuple().await.0`\n \n error[E0609]: no field `a` on type `impl std::future::Future`\n-  --> $DIR/issue-61076.rs:56:28\n+  --> $DIR/issue-61076.rs:60:28\n    |\n LL |     let _: i32 = struct_().a;\n    |                  ----------^\n    |                  |\n    |                  help: consider await before field access: `struct_().await.a`\n \n-error: aborting due to 4 previous errors\n+error[E0599]: no method named `method` found for opaque type `impl std::future::Future` in the current scope\n+  --> $DIR/issue-61076.rs:62:15\n+   |\n+LL |     struct_().method();\n+   |               ^^^^^^\n+   |               |\n+   |               method not found in `impl std::future::Future`\n+   |               help: consider await before this method call: `await.method`\n+\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0277, E0609.\n+Some errors have detailed explanations: E0277, E0599, E0609.\n For more information about an error, try `rustc --explain E0277`."}]}