{"sha": "108b0809e07cae270eb26638a9f354442796686e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwOGIwODA5ZTA3Y2FlMjcwZWIyNjYzOGE5ZjM1NDQ0Mjc5NjY4NmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-09-08T12:46:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-08T12:46:34Z"}, "message": "Merge #10180\n\n10180: Fix resolution for inherent array methods r=flodiebold a=yotamofek\n\nMy second attempt at fixing #9992 , previous attempt was here: #10017 , but the logic was broken.\r\n\r\nI know that this is not an ideal solution.... that would require, IIUC, a pretty big overhaul of the const generics handling in `rust-analyzer`. But, given that some of the array methods were/are being stabilized (e.g. https://github.com/rust-lang/rust/pull/87174 ), I think it'll be very beneficial to `rust-analyzer` users to have some preliminary support for them. (I know it's something I've been running into quite a lot lately :) )\r\n\r\nAs far as my limited understanding of this project's architecture goes, I think this isn't the worst hack in the world, and shouldn't be too much of a hassle to undo if/when const generics become better supported. If the maintainers deem this approach viable, I'll want to add some comments, emphasizing the purpose of this code, and that it should be removed at some point in the future.\n\nCo-authored-by: Yotam Ofek <yotam.ofek@gmail.com>", "tree": {"sha": "cb88ae943486835740fc5d100b8f59652335c14d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb88ae943486835740fc5d100b8f59652335c14d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/108b0809e07cae270eb26638a9f354442796686e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhOLCqCRBK7hj4Ov3rIwAAP+YIAAbFqP+6P6moGMBYG0/zBnY+\n9fF44XxcIDz5yVzAYuCntAxgJB53upYqYzA0Gw9E6dXj+fs0nyM+/62oCMTYt9bX\ny9bc5re8fb66sPt8aTrAkk3LO0RgC5PbX1VRjifKyX4TZG7EPYbFBWgbHBUqgRHu\njEPzE1TZXnthBwT/aF09ztLTdUzUrUhfWSDRkPxxZhE1/7QmicPBpxUNqq+fMzT4\nnb9LF0LHQVr/ahHDJax7NV/uKTtLTbwFipBWG/Ipu7TGdrNOnUy+l1SG8IdJrovv\nx6EThehlag1TJmf2p18f5eBhfdeHYNSpkVi0NHPSBDrQmCXtDe0Sxzjw1LUKbXc=\n=FFmG\n-----END PGP SIGNATURE-----\n", "payload": "tree cb88ae943486835740fc5d100b8f59652335c14d\nparent 3dae94bf2b3e496adb049da589c7efef272a39b8\nparent ebb891246c101ee5715f5ae392e3d8d3a7e95ba5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1631105194 +0000\ncommitter GitHub <noreply@github.com> 1631105194 +0000\n\nMerge #10180\n\n10180: Fix resolution for inherent array methods r=flodiebold a=yotamofek\n\nMy second attempt at fixing #9992 , previous attempt was here: #10017 , but the logic was broken.\r\n\r\nI know that this is not an ideal solution.... that would require, IIUC, a pretty big overhaul of the const generics handling in `rust-analyzer`. But, given that some of the array methods were/are being stabilized (e.g. https://github.com/rust-lang/rust/pull/87174 ), I think it'll be very beneficial to `rust-analyzer` users to have some preliminary support for them. (I know it's something I've been running into quite a lot lately :) )\r\n\r\nAs far as my limited understanding of this project's architecture goes, I think this isn't the worst hack in the world, and shouldn't be too much of a hassle to undo if/when const generics become better supported. If the maintainers deem this approach viable, I'll want to add some comments, emphasizing the purpose of this code, and that it should be removed at some point in the future.\n\nCo-authored-by: Yotam Ofek <yotam.ofek@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/108b0809e07cae270eb26638a9f354442796686e", "html_url": "https://github.com/rust-lang/rust/commit/108b0809e07cae270eb26638a9f354442796686e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/108b0809e07cae270eb26638a9f354442796686e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dae94bf2b3e496adb049da589c7efef272a39b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dae94bf2b3e496adb049da589c7efef272a39b8", "html_url": "https://github.com/rust-lang/rust/commit/3dae94bf2b3e496adb049da589c7efef272a39b8"}, {"sha": "ebb891246c101ee5715f5ae392e3d8d3a7e95ba5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb891246c101ee5715f5ae392e3d8d3a7e95ba5", "html_url": "https://github.com/rust-lang/rust/commit/ebb891246c101ee5715f5ae392e3d8d3a7e95ba5"}], "stats": {"total": 86, "additions": 84, "deletions": 2}, "files": [{"sha": "f12ced24cc4328db00fb07dfd2baec5dbf22f093", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/108b0809e07cae270eb26638a9f354442796686e/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b0809e07cae270eb26638a9f354442796686e/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=108b0809e07cae270eb26638a9f354442796686e", "patch": "@@ -16,6 +16,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     autoderef,\n+    consteval::{self, ConstExt},\n     db::HirDatabase,\n     from_foreign_def_id,\n     primitive::{self, FloatTy, IntTy, UintTy},\n@@ -708,6 +709,33 @@ fn iterate_trait_method_candidates(\n     false\n }\n \n+fn filter_inherent_impls_for_self_ty<'i>(\n+    impls: &'i InherentImpls,\n+    self_ty: &Ty,\n+) -> impl Iterator<Item = &'i ImplId> {\n+    // inherent methods on arrays are fingerprinted as [T; {unknown}], so we must also consider them when\n+    // resolving a method call on an array with a known len\n+    let array_impls = {\n+        if let TyKind::Array(parameters, array_len) = self_ty.kind(&Interner) {\n+            if !array_len.is_unknown() {\n+                let unknown_array_len_ty =\n+                    TyKind::Array(parameters.clone(), consteval::usize_const(None))\n+                        .intern(&Interner);\n+\n+                Some(impls.for_self_ty(&unknown_array_len_ty))\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+    .into_iter()\n+    .flatten();\n+\n+    impls.for_self_ty(self_ty).iter().chain(array_impls)\n+}\n+\n fn iterate_inherent_methods(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n@@ -725,7 +753,9 @@ fn iterate_inherent_methods(\n     for krate in def_crates {\n         let impls = db.inherent_impls_in_crate(krate);\n \n-        for &impl_def in impls.for_self_ty(&self_ty.value) {\n+        let impls_for_self_ty = filter_inherent_impls_for_self_ty(&impls, &self_ty.value);\n+\n+        for &impl_def in impls_for_self_ty {\n             for &item in db.impl_data(impl_def).items.iter() {\n                 if !is_valid_candidate(\n                     db,\n@@ -777,6 +807,28 @@ pub fn resolve_indexing_op(\n     None\n }\n \n+fn is_transformed_receiver_ty_equal(transformed_receiver_ty: &Ty, receiver_ty: &Ty) -> bool {\n+    if transformed_receiver_ty == receiver_ty {\n+        return true;\n+    }\n+\n+    // a transformed receiver may be considered equal (and a valid method call candidate) if it is an array\n+    // with an unknown (i.e. generic) length, and the receiver is an array with the same item type but a known len,\n+    // this allows inherent methods on arrays to be considered valid resolution candidates\n+    match (transformed_receiver_ty.kind(&Interner), receiver_ty.kind(&Interner)) {\n+        (\n+            TyKind::Array(transformed_array_ty, transformed_array_len),\n+            TyKind::Array(receiver_array_ty, receiver_array_len),\n+        ) if transformed_array_ty == receiver_array_ty\n+            && transformed_array_len.is_unknown()\n+            && !receiver_array_len.is_unknown() =>\n+        {\n+            true\n+        }\n+        _ => false,\n+    }\n+}\n+\n fn is_valid_candidate(\n     db: &dyn HirDatabase,\n     env: Arc<TraitEnvironment>,\n@@ -802,7 +854,8 @@ fn is_valid_candidate(\n                     Some(ty) => ty,\n                     None => return false,\n                 };\n-                if transformed_receiver_ty != receiver_ty.value {\n+\n+                if !is_transformed_receiver_ty_equal(&transformed_receiver_ty, &receiver_ty.value) {\n                     return false;\n                 }\n             }"}, {"sha": "306da6738b00b0dca8f804feae37b09bbc3637c3", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/108b0809e07cae270eb26638a9f354442796686e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/108b0809e07cae270eb26638a9f354442796686e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=108b0809e07cae270eb26638a9f354442796686e", "patch": "@@ -1283,6 +1283,35 @@ fn f() {\n     );\n }\n \n+#[test]\n+fn resolve_const_generic_array_methods() {\n+    check_types(\n+        r#\"\n+#[lang = \"array\"]\n+impl<T, const N: usize> [T; N] {\n+    pub fn map<F, U>(self, f: F) -> [U; N]\n+    where\n+        F: FnMut(T) -> U,\n+    { loop {} }\n+}\n+\n+#[lang = \"slice\"]\n+impl<T> [T] {\n+    pub fn map<F, U>(self, f: F) -> &[U]\n+    where\n+        F: FnMut(T) -> U,\n+    { loop {} }\n+}\n+\n+fn f() {\n+    let v = [1, 2].map::<_, usize>(|x| -> x * 2);\n+    v;\n+  //^ [usize; _]\n+}\n+    \"#,\n+    );\n+}\n+\n #[test]\n fn skip_array_during_method_dispatch() {\n     check_types("}]}