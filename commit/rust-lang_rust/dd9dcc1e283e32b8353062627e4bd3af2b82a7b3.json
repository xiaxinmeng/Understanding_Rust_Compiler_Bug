{"sha": "dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkOWRjYzFlMjgzZTMyYjgzNTMwNjI2MjdlNGJkM2FmMmI4MmE3YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T08:31:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-13T08:31:17Z"}, "message": "Auto merge of #25024 - nrc:mulit-decor, r=sfackler", "tree": {"sha": "2c83d8577b5716beba0dc38fbb8e723f2c811d5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c83d8577b5716beba0dc38fbb8e723f2c811d5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "html_url": "https://github.com/rust-lang/rust/commit/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa433875274ff4a7c4cab7d87c1284ba782ef643", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa433875274ff4a7c4cab7d87c1284ba782ef643", "html_url": "https://github.com/rust-lang/rust/commit/fa433875274ff4a7c4cab7d87c1284ba782ef643"}, {"sha": "c544e838de7a0f0c11c681aa0b29056bdee5cb55", "url": "https://api.github.com/repos/rust-lang/rust/commits/c544e838de7a0f0c11c681aa0b29056bdee5cb55", "html_url": "https://github.com/rust-lang/rust/commit/c544e838de7a0f0c11c681aa0b29056bdee5cb55"}], "stats": {"total": 753, "additions": 474, "deletions": 279}, "files": [{"sha": "04df464129541aeee9fd75253d187d3f36f931e9", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -14,8 +14,8 @@ use lint::{LintPassObject, LintId, Lint};\n use session::Session;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, Decorator, Modifier, MultiModifier, MacroRulesTT};\n-use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::base::{IdentTT, Decorator, Modifier, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{MacroExpanderFn, MacroRulesTT};\n use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -84,6 +84,7 @@ impl<'a> Registry<'a> {\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n+    #[allow(deprecated)]\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n         self.syntax_exts.push((name, match extension {\n             NormalTT(ext, _, allow_internal_unstable) => {\n@@ -93,6 +94,7 @@ impl<'a> Registry<'a> {\n                 IdentTT(ext, Some(self.krate_span), allow_internal_unstable)\n             }\n             Decorator(ext) => Decorator(ext),\n+            MultiDecorator(ext) => MultiDecorator(ext),\n             Modifier(ext) => Modifier(ext),\n             MultiModifier(ext) => MultiModifier(ext),\n             MacroRulesTT => {"}, {"sha": "2ecefef51045e85885f27f8f1a5dd9a1c276c269", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -30,6 +30,8 @@ use std::collections::HashMap;\n use std::rc::Rc;\n use std::default::Default;\n \n+#[unstable(feature = \"rustc_private\")]\n+#[deprecated(since = \"1.0.0\", reason = \"replaced by MultiItemDecorator\")]\n pub trait ItemDecorator {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n@@ -39,6 +41,9 @@ pub trait ItemDecorator {\n               push: &mut FnMut(P<ast::Item>));\n }\n \n+#[allow(deprecated)]\n+#[unstable(feature = \"rustc_private\")]\n+#[deprecated(since = \"1.0.0\", reason = \"replaced by MultiItemDecorator\")]\n impl<F> ItemDecorator for F\n     where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, &mut FnMut(P<ast::Item>))\n {\n@@ -52,6 +57,8 @@ impl<F> ItemDecorator for F\n     }\n }\n \n+#[unstable(feature = \"rustc_private\")]\n+#[deprecated(since = \"1.0.0\", reason = \"replaced by MultiItemModifier\")]\n pub trait ItemModifier {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n@@ -61,9 +68,13 @@ pub trait ItemModifier {\n               -> P<ast::Item>;\n }\n \n+#[allow(deprecated)]\n+#[unstable(feature = \"rustc_private\")]\n+#[deprecated(since = \"1.0.0\", reason = \"replaced by MultiItemModifier\")]\n impl<F> ItemModifier for F\n     where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, P<ast::Item>) -> P<ast::Item>\n {\n+\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               span: Span,\n@@ -112,6 +123,16 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn map_item_or<F, G>(self, mut f: F, mut or: G) -> Annotatable\n+        where F: FnMut(P<ast::Item>) -> P<ast::Item>,\n+              G: FnMut(Annotatable) -> Annotatable\n+    {\n+        match self {\n+            Annotatable::Item(i) => Annotatable::Item(f(i)),\n+            _ => or(self)\n+        }\n+    }\n+\n     pub fn expect_trait_item(self) -> P<ast::TraitItem> {\n         match self {\n             Annotatable::TraitItem(i) => i,\n@@ -127,6 +148,29 @@ impl Annotatable {\n     }\n }\n \n+// A more flexible ItemDecorator.\n+pub trait MultiItemDecorator {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt,\n+              sp: Span,\n+              meta_item: &ast::MetaItem,\n+              item: Annotatable,\n+              push: &mut FnMut(Annotatable));\n+}\n+\n+impl<F> MultiItemDecorator for F\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, Annotatable, &mut FnMut(Annotatable))\n+{\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt,\n+              sp: Span,\n+              meta_item: &ast::MetaItem,\n+              item: Annotatable,\n+              push: &mut FnMut(Annotatable)) {\n+        (*self)(ecx, sp, meta_item, item, push)\n+    }\n+}\n+\n // A more flexible ItemModifier (ItemModifier should go away, eventually, FIXME).\n // meta_item is the annotation, item is the item being modified, parent_item\n // is the impl or trait item is declared in if item is part of such a thing.\n@@ -397,12 +441,22 @@ impl MacResult for DummyResult {\n pub enum SyntaxExtension {\n     /// A syntax extension that is attached to an item and creates new items\n     /// based upon it.\n-    ///\n-    /// `#[derive(...)]` is an `ItemDecorator`.\n+    #[unstable(feature = \"rustc_private\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced by MultiDecorator\")]\n+    #[allow(deprecated)]\n     Decorator(Box<ItemDecorator + 'static>),\n \n+    /// A syntax extension that is attached to an item and creates new items\n+    /// based upon it.\n+    ///\n+    /// `#[derive(...)]` is a `MultiItemDecorator`.\n+    MultiDecorator(Box<MultiItemDecorator + 'static>),\n+\n     /// A syntax extension that is attached to an item and modifies it\n     /// in-place.\n+    #[unstable(feature = \"rustc_private\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"replaced by MultiModifier\")]\n+    #[allow(deprecated)]\n     Modifier(Box<ItemModifier + 'static>),\n \n     /// A syntax extension that is attached to an item and modifies it"}, {"sha": "0593de6db07a74545d3ac664cb7e3ba68b866323", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,27 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item};\n+use ast::MetaItem;\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-use ptr::P;\n \n pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n                                     span: Span,\n                                     _: &MetaItem,\n-                                    _: &Item,\n-                                    _: &mut FnMut(P<Item>))\n+                                    _: Annotatable,\n+                                    _: &mut FnMut(Annotatable))\n {\n     cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n }\n \n pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: &Item,\n-                            push: &mut FnMut(P<Item>))\n+                            item: Annotatable,\n+                            push: &mut FnMut(Annotatable))\n {\n     let path = Path::new(vec![\n         if cx.use_std { \"std\" } else { \"core\" },\n@@ -46,5 +45,5 @@ pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push);\n+    trait_def.expand(cx, mitem, &item, push);\n }"}, {"sha": "0d8fb471429377e3878a9fd52b038b0a5d9ae462", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n-                             item: &Item,\n-                             push: &mut FnMut(P<Item>))\n+                             item: Annotatable,\n+                             push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n@@ -47,7 +47,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n fn cs_clone("}, {"sha": "bd7c7d85a375f41bf6cec262201bbab88ac874af", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n-                          item: &Item,\n-                          push: &mut FnMut(P<Item>))\n+                          item: Annotatable,\n+                          push: &mut FnMut(Annotatable))\n {\n     fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n         cs_same_method(\n@@ -66,5 +66,5 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n         ),\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }"}, {"sha": "b4caf0ec26e277de9a25ec9abc371167446422b5", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -21,8 +21,8 @@ use ptr::P;\n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n-                           item: &Item,\n-                           push: &mut FnMut(P<Item>))\n+                           item: Annotatable,\n+                           push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n@@ -48,7 +48,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n "}, {"sha": "5d744334745d32e9c17bb6394a15df3d19b33623", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr, self};\n+use ast::{MetaItem, Expr, self};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   mitem: &MetaItem,\n-                                  item: &Item,\n-                                  push: &mut FnMut(P<Item>))\n+                                  item: Annotatable,\n+                                  push: &mut FnMut(Annotatable))\n {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n@@ -90,5 +90,5 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         ),\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }"}, {"sha": "3ef73f6556e3015e767e331807708bd1e6180a5e", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -11,9 +11,9 @@\n pub use self::OrderingOp::*;\n \n use ast;\n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -23,8 +23,8 @@ use ptr::P;\n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    span: Span,\n                                    mitem: &MetaItem,\n-                                   item: &Item,\n-                                   push: &mut FnMut(P<Item>))\n+                                   item: Annotatable,\n+                                   push: &mut FnMut(Annotatable))\n {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n@@ -80,7 +80,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n         ],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "75c9bc42ea2bfc6e261af3c138620bb9af5a6c35", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -11,9 +11,9 @@\n //! The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more.\n \n use ast;\n-use ast::{MetaItem, Item, Expr, MutMutable};\n+use ast::{MetaItem, Expr, MutMutable};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -24,26 +24,26 @@ use ptr::P;\n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n-                                       item: &Item,\n-                                       push: &mut FnMut(P<Item>))\n+                                       item: Annotatable,\n+                                       push: &mut FnMut(Annotatable))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>))\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>),\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable),\n                                  krate: &'static str)\n {\n     if !cx.use_std {\n@@ -87,7 +87,7 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "e9984c84e322fad9b5587f576819428b7b7919a7", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -20,8 +20,8 @@ use ptr::P;\n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n-                               item: &Item,\n-                               push: &mut FnMut(P<Item>))\n+                               item: Annotatable,\n+                               push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n@@ -46,7 +46,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n         ),\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "4430c58700af365be6da580d708e478814911f43", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -88,9 +88,9 @@\n //! }\n //! ```\n \n-use ast::{MetaItem, Item, Expr, ExprRet, MutMutable};\n+use ast::{MetaItem, Expr, ExprRet, MutMutable};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt,Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -100,26 +100,26 @@ use ptr::P;\n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n-                                       item: &Item,\n-                                       push: &mut FnMut(P<Item>))\n+                                       item: Annotatable,\n+                                       push: &mut FnMut(Annotatable))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>))\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: &Item,\n-                                 push: &mut FnMut(P<Item>),\n+                                 item: Annotatable,\n+                                 push: &mut FnMut(Annotatable),\n                                  krate: &'static str)\n {\n     if !cx.use_std {\n@@ -163,7 +163,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "1525f1a822bec5436160b91abb9f9f078383b179", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -197,7 +197,7 @@ use ast::{EnumDef, Expr, Ident, Generics, StructDef};\n use ast_util;\n use attr;\n use attr::AttrMetaMethods;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use codemap::{self, DUMMY_SP};\n use codemap::Span;\n@@ -380,41 +380,49 @@ impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   cx: &mut ExtCtxt,\n                   mitem: &ast::MetaItem,\n-                  item: &'a ast::Item,\n-                  push: &mut FnMut(P<ast::Item>))\n+                  item: &'a Annotatable,\n+                  push: &mut FnMut(Annotatable))\n     {\n-        let newitem = match item.node {\n-            ast::ItemStruct(ref struct_def, ref generics) => {\n-                self.expand_struct_def(cx,\n-                                       &**struct_def,\n-                                       item.ident,\n-                                       generics)\n-            }\n-            ast::ItemEnum(ref enum_def, ref generics) => {\n-                self.expand_enum_def(cx,\n-                                     enum_def,\n-                                     &item.attrs[..],\n-                                     item.ident,\n-                                     generics)\n+        match *item {\n+            Annotatable::Item(ref item) => {\n+                let newitem = match item.node {\n+                    ast::ItemStruct(ref struct_def, ref generics) => {\n+                        self.expand_struct_def(cx,\n+                                               &struct_def,\n+                                               item.ident,\n+                                               generics)\n+                    }\n+                    ast::ItemEnum(ref enum_def, ref generics) => {\n+                        self.expand_enum_def(cx,\n+                                             enum_def,\n+                                             &item.attrs,\n+                                             item.ident,\n+                                             generics)\n+                    }\n+                    _ => {\n+                        cx.span_err(mitem.span,\n+                                    \"`derive` may only be applied to structs and enums\");\n+                        return;\n+                    }\n+                };\n+                // Keep the lint attributes of the previous item to control how the\n+                // generated implementations are linted\n+                let mut attrs = newitem.attrs.clone();\n+                attrs.extend(item.attrs.iter().filter(|a| {\n+                    match &a.name()[..] {\n+                        \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n+                        _ => false,\n+                    }\n+                }).cloned());\n+                push(Annotatable::Item(P(ast::Item {\n+                    attrs: attrs,\n+                    ..(*newitem).clone()\n+                })))\n             }\n             _ => {\n                 cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");\n-                return;\n             }\n-        };\n-        // Keep the lint attributes of the previous item to control how the\n-        // generated implementations are linted\n-        let mut attrs = newitem.attrs.clone();\n-        attrs.extend(item.attrs.iter().filter(|a| {\n-            match &a.name()[..] {\n-                \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n-                _ => false,\n-            }\n-        }).cloned());\n-        push(P(ast::Item {\n-            attrs: attrs,\n-            ..(*newitem).clone()\n-        }))\n+        }\n     }\n \n     /// Given that we are deriving a trait `DerivedTrait` for a type like:"}, {"sha": "698e788d65f00d8827cea539f72d2cf453376877", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr, MutMutable};\n+use ast::{MetaItem, Expr, MutMutable};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -19,8 +19,8 @@ use ptr::P;\n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: &Item,\n-                            push: &mut FnMut(P<Item>))\n+                            item: Annotatable,\n+                            push: &mut FnMut(Annotatable))\n {\n \n     let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None,\n@@ -52,7 +52,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    hash_trait_def.expand(cx, mitem, item, push);\n+    hash_trait_def.expand(cx, mitem, &item, push);\n }\n \n fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "61848cca059ce3c0c02f7093933ad91872f71d45", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 43, "deletions": 38, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -13,14 +13,13 @@\n //! FIXME (#2810): hygiene. Search for \"__\" strings (in other files too). We also assume \"extra\" is\n //! the standard library, and \"std\" is the core library.\n \n-use ast::{Item, MetaItem, MetaWord};\n+use ast::{MetaItem, MetaWord};\n use attr::AttrMetaMethods;\n-use ext::base::{ExtCtxt, SyntaxEnv, Decorator, ItemDecorator, Modifier};\n+use ext::base::{ExtCtxt, SyntaxEnv, MultiDecorator, MultiItemDecorator, MultiModifier, Annotatable};\n use ext::build::AstBuilder;\n use feature_gate;\n use codemap::Span;\n use parse::token::{intern, intern_and_get_ident};\n-use ptr::P;\n \n macro_rules! pathvec {\n     ($($x:ident)::+) => (\n@@ -78,42 +77,48 @@ pub mod ord;\n pub mod generic;\n \n fn expand_derive(cx: &mut ExtCtxt,\n-                 _: Span,\n+                 span: Span,\n                  mitem: &MetaItem,\n-                 item: P<Item>) -> P<Item> {\n-    item.map(|mut item| {\n-        if mitem.value_str().is_some() {\n-            cx.span_err(mitem.span, \"unexpected value in `derive`\");\n-        }\n+                 annotatable: Annotatable)\n+                 -> Annotatable {\n+    annotatable.map_item_or(|item| {\n+        item.map(|mut item| {\n+            if mitem.value_str().is_some() {\n+                cx.span_err(mitem.span, \"unexpected value in `derive`\");\n+            }\n \n-        let traits = mitem.meta_item_list().unwrap_or(&[]);\n-        if traits.is_empty() {\n-            cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n-        }\n+            let traits = mitem.meta_item_list().unwrap_or(&[]);\n+            if traits.is_empty() {\n+                cx.span_warn(mitem.span, \"empty trait list in `derive`\");\n+            }\n \n-        for titem in traits.iter().rev() {\n-            let tname = match titem.node {\n-                MetaWord(ref tname) => tname,\n-                _ => {\n-                    cx.span_err(titem.span, \"malformed `derive` entry\");\n+            for titem in traits.iter().rev() {\n+                let tname = match titem.node {\n+                    MetaWord(ref tname) => tname,\n+                    _ => {\n+                        cx.span_err(titem.span, \"malformed `derive` entry\");\n+                        continue;\n+                    }\n+                };\n+\n+                if !(is_builtin_trait(tname) || cx.ecfg.enable_custom_derive()) {\n+                    feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                                   \"custom_derive\",\n+                                                   titem.span,\n+                                                   feature_gate::EXPLAIN_CUSTOM_DERIVE);\n                     continue;\n                 }\n-            };\n-\n-            if !(is_builtin_trait(tname) || cx.ecfg.enable_custom_derive()) {\n-                feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n-                                               \"custom_derive\",\n-                                               titem.span,\n-                                               feature_gate::EXPLAIN_CUSTOM_DERIVE);\n-                continue;\n-            }\n \n-            // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n-            item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n-                intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n-        }\n+                // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n+                item.attrs.push(cx.attribute(titem.span, cx.meta_word(titem.span,\n+                    intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n+            }\n \n-        item\n+            item\n+        })\n+    }, |a| {\n+        cx.span_err(span, \"`derive` can only be applied to items\");\n+        a\n     })\n }\n \n@@ -124,24 +129,24 @@ macro_rules! derive_traits {\n             $({\n                 struct DeriveExtension;\n \n-                impl ItemDecorator for DeriveExtension {\n+                impl MultiItemDecorator for DeriveExtension {\n                     fn expand(&self,\n                               ecx: &mut ExtCtxt,\n                               sp: Span,\n                               mitem: &MetaItem,\n-                              item: &Item,\n-                              push: &mut FnMut(P<Item>)) {\n+                              annotatable: Annotatable,\n+                              push: &mut FnMut(Annotatable)) {\n                         warn_if_deprecated(ecx, sp, $name);\n-                        $func(ecx, sp, mitem, item, push);\n+                        $func(ecx, sp, mitem, annotatable, push);\n                     }\n                 }\n \n                 env.insert(intern(concat!(\"derive_\", $name)),\n-                           Decorator(Box::new(DeriveExtension)));\n+                           MultiDecorator(Box::new(DeriveExtension)));\n             })+\n \n             env.insert(intern(\"derive\"),\n-                       Modifier(Box::new(expand_derive)));\n+                       MultiModifier(Box::new(expand_derive)));\n         }\n \n         fn is_builtin_trait(name: &str) -> bool {"}, {"sha": "4fe9aefa1a4dfe51a5080b51e47a7bb76a266379", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr};\n+use ast::{MetaItem, Expr};\n use ast;\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -21,8 +21,8 @@ use ptr::P;\n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n                                       mitem: &MetaItem,\n-                                      item: &Item,\n-                                      push: &mut FnMut(P<Item>))\n+                                      item: Annotatable,\n+                                      push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));\n@@ -67,7 +67,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "dc634df2073a48b031be43f86dda072d8f2473b5", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use ast;\n-use ast::{MetaItem, Item, Expr,};\n+use ast::{MetaItem, Expr,};\n use codemap::Span;\n-use ext::base::ExtCtxt;\n+use ext::base::{ExtCtxt, Annotatable};\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n@@ -21,8 +21,8 @@ use ptr::P;\n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: &Item,\n-                            push: &mut FnMut(P<Item>))\n+                            item: Annotatable,\n+                            push: &mut FnMut(Annotatable))\n {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(Box::new(Literal(path_std!(cx, core::fmt::Formatter))),\n@@ -49,7 +49,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n         ],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n /// We use the debug builders to do the heavy lifting here"}, {"sha": "d71557bd7372d6f37a608e2319cc4f664254a53a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 145, "deletions": 118, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -477,58 +477,6 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n         .into_iter().map(|i| i.expect_item()).collect()\n }\n \n-fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n-                         -> P<ast::Item> {\n-    // partition the attributes into ItemModifiers and others\n-    let (modifiers, other_attrs) = modifiers(&it.attrs, fld);\n-\n-    // update the attrs, leave everything else alone. Is this mutation really a good idea?\n-    it = P(ast::Item {\n-        attrs: other_attrs,\n-        ..(*it).clone()\n-    });\n-\n-    if modifiers.is_empty() {\n-        let it = expand_item_multi_modifier(Annotatable::Item(it), fld);\n-        return it.expect_item();\n-    }\n-\n-    for attr in &modifiers {\n-        let mname = attr.name();\n-\n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n-            Some(rc) => match *rc {\n-                Modifier(ref mac) => {\n-                    attr::mark_used(attr);\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n-                            span: None,\n-                            // attributes can do whatever they like,\n-                            // for now\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n-                    fld.cx.bt_pop();\n-                }\n-                _ => unreachable!()\n-            },\n-            _ => unreachable!()\n-        }\n-    }\n-\n-    // Expansion may have added new ItemModifiers.\n-    // It is possible, that an item modifier could expand to a multi-modifier or\n-    // vice versa. In this case we will expand all modifiers before multi-modifiers,\n-    // which might give an odd ordering. However, I think it is unlikely that the\n-    // two kinds will be mixed, and I old-style multi-modifiers should be deprecated\n-    // anyway.\n-    expand_item_modifiers(it, fld)\n-}\n-\n /// Expand item_underscore\n fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n     match item {\n@@ -1090,48 +1038,7 @@ fn expand_annotatable(a: Annotatable,\n \n     let mut decorator_items = SmallVector::zero();\n     let mut new_attrs = Vec::new();\n-    for attr in a.attrs() {\n-        let mname = attr.name();\n-\n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n-            Some(rc) => match *rc {\n-                Decorator(ref dec) => {\n-                    let it = match a {\n-                        Annotatable::Item(ref it) => it,\n-                        // ItemDecorators are only implemented for Items.\n-                        _ => break,\n-                    };\n-\n-                    attr::mark_used(attr);\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n-                            span: Some(attr.span),\n-                            // attributes can do whatever they like,\n-                            // for now.\n-                            allow_internal_unstable: true,\n-                        }\n-                    });\n-\n-                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n-                    // but that double-mut-borrows fld\n-                    let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n-                    dec.expand(fld.cx, attr.span, &*attr.node.value, &**it,\n-                               &mut |item| items.push(item));\n-                    decorator_items.extend(\n-                        items.into_iter()\n-                             .flat_map(|item| expand_item(item, fld).into_iter()));\n-\n-                    fld.cx.bt_pop();\n-                }\n-                _ => new_attrs.push((*attr).clone()),\n-            },\n-            _ => new_attrs.push((*attr).clone()),\n-        }\n-    }\n+    expand_decorators(a.clone(), fld, &mut decorator_items, &mut new_attrs);\n \n     let mut new_items: SmallVector<Annotatable> = match a {\n         Annotatable::Item(it) => match it.node {\n@@ -1185,38 +1092,105 @@ fn expand_annotatable(a: Annotatable,\n         }\n     };\n \n-    new_items.push_all(decorator_items.into_iter().map(|i| Annotatable::Item(i)).collect());\n+    new_items.push_all(decorator_items);\n     new_items\n }\n \n-// partition the attributes into ItemModifiers and others\n-fn modifiers(attrs: &Vec<ast::Attribute>,\n-             fld: &MacroExpander)\n-             -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n-    attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(&attr.name())) {\n-            Some(rc) => match *rc {\n-                Modifier(_) => true,\n-                _ => false\n-            },\n-            _ => false\n+// Partition a set of attributes into one kind of attribute, and other kinds.\n+macro_rules! partition {\n+    ($fn_name: ident, $variant: ident) => {\n+        #[allow(deprecated)] // The `allow` is needed because the `Modifier` variant might be used.\n+        fn $fn_name(attrs: &[ast::Attribute],\n+                    fld: &MacroExpander)\n+                     -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n+            attrs.iter().cloned().partition(|attr| {\n+                match fld.cx.syntax_env.find(&intern(&attr.name())) {\n+                    Some(rc) => match *rc {\n+                        $variant(..) => true,\n+                        _ => false\n+                    },\n+                    _ => false\n+                }\n+            })\n         }\n-    })\n+    }\n }\n \n-// partition the attributes into MultiModifiers and others\n-fn multi_modifiers(attrs: &[ast::Attribute],\n-                   fld: &MacroExpander)\n-                   -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n-    attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(&attr.name())) {\n+partition!(modifiers, Modifier);\n+partition!(multi_modifiers, MultiModifier);\n+\n+\n+#[allow(deprecated)] // The `allow` is needed because the `Decorator` variant is used.\n+fn expand_decorators(a: Annotatable,\n+                     fld: &mut MacroExpander,\n+                     decorator_items: &mut SmallVector<Annotatable>,\n+                     new_attrs: &mut Vec<ast::Attribute>)\n+{\n+    for attr in a.attrs() {\n+        let mname = attr.name();\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n             Some(rc) => match *rc {\n-                MultiModifier(_) => true,\n-                _ => false\n+                Decorator(ref dec) => {\n+                    attr::mark_used(&attr);\n+\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.to_string(),\n+                            format: MacroAttribute,\n+                            span: Some(attr.span),\n+                            // attributes can do whatever they like,\n+                            // for now.\n+                            allow_internal_unstable: true,\n+                        }\n+                    });\n+\n+                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<Annotatable> = SmallVector::zero();\n+                    dec.expand(fld.cx,\n+                               attr.span,\n+                               &attr.node.value,\n+                               &a.clone().expect_item(),\n+                               &mut |item| items.push(Annotatable::Item(item)));\n+                    decorator_items.extend(items.into_iter()\n+                        .flat_map(|ann| expand_annotatable(ann, fld).into_iter()));\n+\n+                    fld.cx.bt_pop();\n+                }\n+                MultiDecorator(ref dec) => {\n+                    attr::mark_used(&attr);\n+\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.to_string(),\n+                            format: MacroAttribute,\n+                            span: Some(attr.span),\n+                            // attributes can do whatever they like,\n+                            // for now.\n+                            allow_internal_unstable: true,\n+                        }\n+                    });\n+\n+                    // we'd ideally decorator_items.push_all(expand_annotatable(ann, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<Annotatable> = SmallVector::zero();\n+                    dec.expand(fld.cx,\n+                               attr.span,\n+                               &attr.node.value,\n+                               a.clone(),\n+                               &mut |ann| items.push(ann));\n+                    decorator_items.extend(items.into_iter()\n+                        .flat_map(|ann| expand_annotatable(ann, fld).into_iter()));\n+\n+                    fld.cx.bt_pop();\n+                }\n+                _ => new_attrs.push((*attr).clone()),\n             },\n-            _ => false\n+            _ => new_attrs.push((*attr).clone()),\n         }\n-    })\n+    }\n }\n \n fn expand_item_multi_modifier(mut it: Annotatable,\n@@ -1243,7 +1217,7 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n                         callee: NameAndSpan {\n                             name: mname.to_string(),\n                             format: MacroAttribute,\n-                            span: None,\n+                            span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now\n                             allow_internal_unstable: true,\n@@ -1262,6 +1236,59 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     expand_item_multi_modifier(it, fld)\n }\n \n+#[allow(deprecated)] // This is needed because the `ItemModifier` trait is used\n+fn expand_item_modifiers(mut it: P<ast::Item>,\n+                         fld: &mut MacroExpander)\n+                         -> P<ast::Item> {\n+    // partition the attributes into ItemModifiers and others\n+    let (modifiers, other_attrs) = modifiers(&it.attrs, fld);\n+\n+    // update the attrs, leave everything else alone. Is this mutation really a good idea?\n+    it = P(ast::Item {\n+        attrs: other_attrs,\n+        ..(*it).clone()\n+    });\n+\n+    if modifiers.is_empty() {\n+        let it = expand_item_multi_modifier(Annotatable::Item(it), fld);\n+        return it.expect_item();\n+    }\n+\n+    for attr in &modifiers {\n+        let mname = attr.name();\n+\n+        match fld.cx.syntax_env.find(&intern(&mname)) {\n+            Some(rc) => match *rc {\n+                Modifier(ref mac) => {\n+                    attr::mark_used(attr);\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.to_string(),\n+                            format: MacroAttribute,\n+                            span: Some(attr.span),\n+                            // attributes can do whatever they like,\n+                            // for now\n+                            allow_internal_unstable: true,\n+                        }\n+                    });\n+                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n+                    fld.cx.bt_pop();\n+                }\n+                _ => unreachable!()\n+            },\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    // Expansion may have added new ItemModifiers.\n+    // It is possible, that an item modifier could expand to a multi-modifier or\n+    // vice versa. In this case we will expand all modifiers before multi-modifiers,\n+    // which might give an odd ordering. However, I think it is unlikely that the\n+    // two kinds will be mixed, and old-style multi-modifiers are deprecated.\n+    expand_item_modifiers(it, fld)\n+}\n+\n fn expand_impl_item(ii: P<ast::ImplItem>, fld: &mut MacroExpander)\n                  -> SmallVector<P<ast::ImplItem>> {\n     match ii.node {"}, {"sha": "5a002dd790fee4c1cc3908225127ac036de2fc89", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -799,7 +799,6 @@ impl<'a> State<'a> {\n         word(&mut self.s, \";\")\n     }\n \n-\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> io::Result<()> {\n         try!(self.hardbreak_if_not_bol());"}, {"sha": "0edbeb2d02ca4ccdb917b30b22d151d9f3229a68", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -19,7 +19,7 @@ extern crate rustc;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::ext::base::{Decorator, ExtCtxt};\n+use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax::ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n@@ -31,14 +31,14 @@ use rustc::plugin::Registry;\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n         token::intern(\"derive_TotalSum\"),\n-        Decorator(box expand));\n+        MultiDecorator(box expand));\n }\n \n fn expand(cx: &mut ExtCtxt,\n           span: Span,\n           mitem: &ast::MetaItem,\n-          item: &ast::Item,\n-          push: &mut FnMut(P<ast::Item>)) {\n+          item: Annotatable,\n+          push: &mut FnMut(Annotatable)) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: vec![],\n@@ -70,5 +70,5 @@ fn expand(cx: &mut ExtCtxt,\n         ],\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }"}, {"sha": "92963b2812dd8ef49bfb9dc617207869e08e3667", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -20,7 +20,7 @@ extern crate rustc;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n-use syntax::ext::base::{Decorator, ExtCtxt};\n+use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax::ext::deriving::generic::{Substructure, Struct, EnumMatching};\n@@ -33,14 +33,14 @@ use rustc::plugin::Registry;\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n         token::intern(\"derive_TotalSum\"),\n-        Decorator(box expand));\n+        MultiDecorator(box expand));\n }\n \n fn expand(cx: &mut ExtCtxt,\n           span: Span,\n           mitem: &ast::MetaItem,\n-          item: &ast::Item,\n-          push: &mut FnMut(P<ast::Item>)) {\n+          item: Annotatable,\n+          push: &mut FnMut(Annotatable)) {\n     let trait_def = TraitDef {\n         span: span,\n         attributes: vec![],\n@@ -61,7 +61,7 @@ fn expand(cx: &mut ExtCtxt,\n         ],\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, &item, push)\n }\n \n // Mostly copied from syntax::ext::deriving::hash"}, {"sha": "53a6672d4888deb4cf5d6cbeb0ffd9206fc51bac", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -10,23 +10,20 @@\n \n // force-host\n \n-#![feature(plugin_registrar, quote)]\n-#![feature(box_syntax, rustc_private)]\n+#![feature(plugin_registrar, quote, rustc_private)]\n \n extern crate syntax;\n extern crate rustc;\n \n-use syntax::ast::{self, TokenTree, Item, MetaItem};\n+use syntax::ast::{self, TokenTree, Item, MetaItem, ImplItem, TraitItem};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n-use syntax::parse::token;\n-use syntax::parse;\n+use syntax::parse::{self, token};\n use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n #[macro_export]\n macro_rules! exported_macro { () => (2) }\n-\n macro_rules! unexported_macro { () => (3) }\n \n #[plugin_registrar]\n@@ -41,6 +38,10 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         token::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n+    reg.register_syntax_extension(\n+        token::intern(\"duplicate\"),\n+        // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n+        MultiDecorator(Box::new(expand_duplicate)));\n }\n \n fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n@@ -103,4 +104,49 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n     }\n }\n \n+// Create a duplicate of the annotatable, based on the MetaItem\n+fn expand_duplicate(cx: &mut ExtCtxt,\n+                    sp: Span,\n+                    mi: &MetaItem,\n+                    it: Annotatable,\n+                    push: &mut FnMut(Annotatable))\n+{\n+    let copy_name = match mi.node {\n+        ast::MetaItem_::MetaList(_, ref xs) => {\n+            if let ast::MetaItem_::MetaWord(ref w) = xs[0].node {\n+                token::str_to_ident(&w)\n+            } else {\n+                cx.span_err(mi.span, \"Expected word\");\n+                return;\n+            }\n+        }\n+        _ => {\n+            cx.span_err(mi.span, \"Expected list\");\n+            return;\n+        }\n+    };\n+\n+    // Duplicate the item but replace its ident by the MetaItem\n+    match it.clone() {\n+        Annotatable::Item(it) => {\n+            let mut new_it = (*it).clone();\n+            new_it.attrs.clear();\n+            new_it.ident = copy_name;\n+            push(Annotatable::Item(P(new_it)));\n+        }\n+        Annotatable::ImplItem(it) => {\n+            let mut new_it = (*it).clone();\n+            new_it.attrs.clear();\n+            new_it.ident = copy_name;\n+            push(Annotatable::ImplItem(P(new_it)));\n+        }\n+        Annotatable::TraitItem(tt) => {\n+            let mut new_it = (*tt).clone();\n+            new_it.attrs.clear();\n+            new_it.ident = copy_name;\n+            push(Annotatable::TraitItem(P(new_it)));\n+        }\n+    }\n+}\n+\n pub fn foo() {}"}, {"sha": "3c215b6ca48dd5a1e7a38397883977e914cbbbf5", "filename": "src/test/run-pass-fulldeps/macro-crate-multi-decorator.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd9dcc1e283e32b8353062627e4bd3af2b82a7b3/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-multi-decorator.rs?ref=dd9dcc1e283e32b8353062627e4bd3af2b82a7b3", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_test.rs\n+// ignore-stage1\n+\n+#![feature(plugin, custom_attribute)]\n+#![plugin(macro_crate_test)]\n+\n+#[macro_use]\n+#[no_link]\n+extern crate macro_crate_test;\n+\n+// The duplicate macro will create a copy of the item with the given identifier.\n+\n+#[duplicate(MyCopy)]\n+struct MyStruct {\n+    number: i32\n+}\n+\n+trait TestTrait {\n+    #[duplicate(TestType2)]\n+    type TestType;\n+\n+    #[duplicate(required_fn2)]\n+    fn required_fn(&self);\n+\n+    #[duplicate(provided_fn2)]\n+    fn provided_fn(&self) { }\n+}\n+\n+impl TestTrait for MyStruct {\n+    #[duplicate(TestType2)]\n+    type TestType = f64;\n+\n+    #[duplicate(required_fn2)]\n+    fn required_fn(&self) { }\n+}\n+\n+fn main() {\n+    let s = MyStruct { number: 42 };\n+    s.required_fn();\n+    s.required_fn2();\n+    s.provided_fn();\n+    s.provided_fn2();\n+\n+    let s = MyCopy { number: 42 };\n+}"}]}