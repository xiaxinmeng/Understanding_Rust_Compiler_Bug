{"sha": "180534f398b18aea5d7740153eab026074396013", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MDUzNGYzOThiMThhZWE1ZDc3NDAxNTNlYWIwMjYwNzQzOTYwMTM=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-28T08:17:52Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-09-05T04:28:52Z"}, "message": "Remove use of expr_ty from coercions code", "tree": {"sha": "5124e14e01a7a744d9e79a8634ecb0ec13f5765b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5124e14e01a7a744d9e79a8634ecb0ec13f5765b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/180534f398b18aea5d7740153eab026074396013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/180534f398b18aea5d7740153eab026074396013", "html_url": "https://github.com/rust-lang/rust/commit/180534f398b18aea5d7740153eab026074396013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/180534f398b18aea5d7740153eab026074396013/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd661481e79bb5701455b03d8d3b587309e56186", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd661481e79bb5701455b03d8d3b587309e56186", "html_url": "https://github.com/rust-lang/rust/commit/bd661481e79bb5701455b03d8d3b587309e56186"}], "stats": {"total": 63, "additions": 37, "deletions": 26}, "files": [{"sha": "42769a8636407cb912b34f309568612c141594f6", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=180534f398b18aea5d7740153eab026074396013", "patch": "@@ -419,11 +419,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             _ => result_ty\n         };\n+\n+        let mut arm_tys = Vec::new();\n         for (i, arm) in arms.iter().enumerate() {\n             if let Some(ref e) = arm.guard {\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n+            arm_tys.push(arm_ty);\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;\n@@ -453,10 +456,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })\n             } else if i == 0 {\n                 // Special-case the first arm, as it has no \"previous expressions\".\n-                self.try_coerce(&arm.body, coerce_first)\n+                self.try_coerce(&arm.body, arm_ty, coerce_first)\n             } else {\n-                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n-                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body)\n+                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body)\n+                                            .zip(arm_tys.iter().cloned());\n+                self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body, arm_ty)\n             };\n \n             result_ty = match result {"}, {"sha": "0c9da86563ab21af6f8be9965a4e3776852050f2", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=180534f398b18aea5d7740153eab026074396013", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             (None, Some(t_cast)) => {\n                 if let ty::TyFnDef(.., f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n-                    let res = fcx.try_coerce(self.expr, fcx.tcx.mk_fn_ptr(f));\n+                    let res = fcx.try_coerce(self.expr, self.expr_ty, fcx.tcx.mk_fn_ptr(f));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -471,7 +471,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n     }\n \n     fn try_coercion_cast(&self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        fcx.try_coerce(self.expr, self.cast_ty).is_ok()\n+        fcx.try_coerce(self.expr, self.expr_ty, self.cast_ty).is_ok()\n     }\n \n }"}, {"sha": "263a83389ea9d4fe35971c4b7718dd8ebebc7f29", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=180534f398b18aea5d7740153eab026074396013", "patch": "@@ -630,9 +630,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// The expressions *must not* have any pre-existing adjustments.\n     pub fn try_coerce(&self,\n                       expr: &hir::Expr,\n+                      expr_ty: Ty<'tcx>,\n                       target: Ty<'tcx>)\n                       -> RelateResult<'tcx, Ty<'tcx>> {\n-        let source = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+        let source = self.resolve_type_vars_with_obligations(expr_ty);\n         debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n         let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n@@ -658,14 +659,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            origin: TypeOrigin,\n                                            exprs: E,\n                                            prev_ty: Ty<'tcx>,\n-                                           new: &'b hir::Expr)\n+                                           new: &'b hir::Expr,\n+                                           new_ty: Ty<'tcx>)\n                                            -> RelateResult<'tcx, Ty<'tcx>>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=&'b hir::Expr> {\n+              I: IntoIterator<Item=(&'b hir::Expr, Ty<'tcx>)> {\n \n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n-        let new_ty = self.resolve_type_vars_with_obligations(self.expr_ty(new));\n+        let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n         debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n         let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n@@ -701,7 +703,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // Reify both sides and return the reified fn pointer type.\n-                for expr in exprs().into_iter().chain(Some(new)) {\n+                for (expr, _) in exprs().into_iter().chain(Some((new, new_ty))) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n                     self.write_adjustment(expr.id, AdjustReifyFnPointer);\n@@ -735,13 +737,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Then try to coerce the previous expressions to the type of the new one.\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n-        for expr in exprs() {\n+        for (expr, expr_ty) in exprs() {\n             let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n                 Some(&AdjustDerefRef(AutoDerefRef {\n                     autoderefs: 1,\n                     autoref: Some(AutoPtr(_, mutbl_adj)),\n                     unsize: None\n-                })) => match self.expr_ty(expr).sty {\n+                })) => match expr_ty.sty {\n                     ty::TyRef(_, mt_orig) => {\n                         // Reborrow that we can safely ignore.\n                         mutbl_adj == mt_orig.mutbl\n@@ -765,7 +767,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| apply(&mut coerce,\n+                                          &|| exprs().into_iter().map(|(e, _)| e),\n+                                          prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {\n@@ -783,7 +787,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Ok((ty, adjustment)) => {\n                 if !adjustment.is_identity() {\n-                    for expr in exprs() {\n+                    for (expr, _) in exprs() {\n                         let previous = self.tables.borrow().adjustments.get(&expr.id).cloned();\n                         if let Some(AdjustNeverToAny(_)) = previous {\n                             self.write_adjustment(expr.id, AdjustNeverToAny(ty));"}, {"sha": "d622bc7f751d763d8f232dc2d145c9993c977447", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=180534f398b18aea5d7740153eab026074396013", "patch": "@@ -53,11 +53,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n-    pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n+    pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n-        if let Err(e) = self.try_coerce(expr, expected) {\n+        if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let origin = TypeOrigin::Misc(expr.span);\n-            let expr_ty = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+            let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             self.report_mismatched_types(origin, expected, expr_ty, e);\n         }\n     }"}, {"sha": "b12833392135628eddd7b5e93c5a633f9a6c33ad", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/180534f398b18aea5d7740153eab026074396013/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=180534f398b18aea5d7740153eab026074396013", "patch": "@@ -2567,13 +2567,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         Expectation::rvalue_hint(self, ty)\n                     });\n \n-                    self.check_expr_with_expectation(&arg,\n-                        expected.unwrap_or(ExpectHasType(formal_ty)));\n+                    let checked_ty = self.check_expr_with_expectation(&arg,\n+                                            expected.unwrap_or(ExpectHasType(formal_ty)));\n                     // 2. Coerce to the most detailed type that could be coerced\n                     //    to, which is `expected_ty` if `rvalue_hint` returns an\n                     //    `ExpectHasType(expected_ty)`, or the `formal_ty` otherwise.\n                     let coerce_ty = expected.and_then(|e| e.only_has_type(self));\n-                    self.demand_coerce(&arg, coerce_ty.unwrap_or(formal_ty));\n+                    self.demand_coerce(&arg, checked_ty, coerce_ty.unwrap_or(formal_ty));\n \n                     // 3. Relate the expected type and the formal one,\n                     //    if the expected type was used for the coercion.\n@@ -2715,7 +2715,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     expr: &'gcx hir::Expr,\n                                     expected: Ty<'tcx>) -> Ty<'tcx> {\n         let ty = self.check_expr_with_hint(expr, expected);\n-        self.demand_coerce(expr, expected);\n+        self.demand_coerce(expr, ty, expected);\n         ty\n     }\n \n@@ -2861,8 +2861,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n             let result = if let Some(ref then) = then_blk.expr {\n-                let res = self.try_find_coercion_lub(origin, || Some(&**then),\n-                                                     then_ty, else_expr);\n+                let res = self.try_find_coercion_lub(origin, || Some((&**then, then_ty)),\n+                                                     then_ty, else_expr, else_ty);\n \n                 // In case we did perform an adjustment, we have to update\n                 // the type of the block, because old trans still uses it.\n@@ -3594,16 +3594,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut unified = self.next_ty_var();\n             let coerce_to = uty.unwrap_or(unified);\n \n+            let mut arg_tys = Vec::new();\n             for (i, e) in args.iter().enumerate() {\n                 let e_ty = self.check_expr_with_hint(e, coerce_to);\n+                arg_tys.push(e_ty);\n                 let origin = TypeOrigin::Misc(e.span);\n \n                 // Special-case the first element, as it has no \"previous expressions\".\n                 let result = if i == 0 {\n-                    self.try_coerce(e, coerce_to)\n+                    self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n-                    let prev_elems = || args[..i].iter().map(|e| &**e);\n-                    self.try_find_coercion_lub(origin, prev_elems, unified, e)\n+                    let prev_elems = || args[..i].iter().map(|e| &**e)\n+                                                 .zip(arg_tys.iter().cloned());\n+                    self.try_find_coercion_lub(origin, prev_elems, unified, e, e_ty)\n                 };\n \n                 match result {"}]}