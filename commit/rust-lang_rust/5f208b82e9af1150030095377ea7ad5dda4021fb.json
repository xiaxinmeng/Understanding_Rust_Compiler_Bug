{"sha": "5f208b82e9af1150030095377ea7ad5dda4021fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMjA4YjgyZTlhZjExNTAwMzAwOTUzNzdlYTdhZDVkZGE0MDIxZmI=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-10T05:06:38Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-07-21T07:22:21Z"}, "message": "Switched bitv to external iterators", "tree": {"sha": "0bd4d6ba6c323c4285d3b4a615fc72b8ec48bb1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bd4d6ba6c323c4285d3b4a615fc72b8ec48bb1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f208b82e9af1150030095377ea7ad5dda4021fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f208b82e9af1150030095377ea7ad5dda4021fb", "html_url": "https://github.com/rust-lang/rust/commit/5f208b82e9af1150030095377ea7ad5dda4021fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f208b82e9af1150030095377ea7ad5dda4021fb/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "url": "https://api.github.com/repos/rust-lang/rust/commits/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994", "html_url": "https://github.com/rust-lang/rust/commit/c325cb0a42c2b2c0b12eeb1ebf4cc22bca0fe994"}], "stats": {"total": 71, "additions": 54, "deletions": 17}, "files": [{"sha": "8ec72f3da3463a100607b58cb6d8b9a4673e60bc", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 54, "deletions": 17, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/5f208b82e9af1150030095377ea7ad5dda4021fb/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f208b82e9af1150030095377ea7ad5dda4021fb/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=5f208b82e9af1150030095377ea7ad5dda4021fb", "patch": "@@ -392,28 +392,23 @@ impl Bitv {\n       match self.rep {\n         Small(ref b) => b.is_true(self.nbits),\n         _ => {\n-          for self.each() |i| { if !i { return false; } }\n+          for self.iter().advance |i| { if !i { return false; } }\n           true\n         }\n       }\n     }\n \n     #[inline]\n-    pub fn each(&self, f: &fn(bool) -> bool) -> bool {\n-        let mut i = 0;\n-        while i < self.nbits {\n-            if !f(self.get(i)) { return false; }\n-            i += 1;\n-        }\n-        return true;\n+    pub fn iter<'a>(&'a self) -> BitvIterator<'a> {\n+        BitvIterator {bitv: self, next_idx: 0}\n     }\n \n     /// Returns true if all bits are 0\n     pub fn is_false(&self) -> bool {\n       match self.rep {\n         Small(ref b) => b.is_false(self.nbits),\n         Big(_) => {\n-          for self.each() |i| { if i { return false; } }\n+          for self.iter().advance |i| { if i { return false; } }\n           true\n         }\n       }\n@@ -477,7 +472,7 @@ impl Bitv {\n      */\n      pub fn to_str(&self) -> ~str {\n         let mut rs = ~\"\";\n-        for self.each() |i| {\n+        for self.iter().advance |i| {\n             if i {\n                 rs.push_char('1');\n             } else {\n@@ -580,6 +575,29 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     return true;\n }\n \n+/// An iterator for Bitv\n+pub struct BitvIterator<'self> {\n+    priv bitv: &'self Bitv,\n+    priv next_idx: uint\n+}\n+\n+impl<'self> Iterator<bool> for BitvIterator<'self> {\n+    fn next(&mut self) -> Option<bool> {\n+        if self.next_idx < self.bitv.nbits {\n+            let idx = self.next_idx;\n+            self.next_idx += 1;\n+            Some(self.bitv.get(idx))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        let rem = self.bitv.nbits - self.next_idx;\n+        (rem, Some(rem))\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding numerical elements.\n ///\n@@ -670,13 +688,8 @@ impl BitvSet {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n-    pub fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n-        for self.bitv.storage.iter().enumerate().advance |(i, &w)| {\n-            if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n-                return false;\n-            }\n-        }\n-        return true;\n+    pub fn iter<'a>(&'a self) -> BitvSetIterator<'a> {\n+        BitvSetIterator {set: self, next_idx: 0}\n     }\n }\n \n@@ -860,6 +873,30 @@ impl BitvSet {\n     }\n }\n \n+pub struct BitvSetIterator<'self> {\n+    priv set: &'self BitvSet,\n+    priv next_idx: uint\n+}\n+\n+impl<'self> Iterator<uint> for BitvSetIterator<'self> {\n+    fn next(&mut self) -> Option<uint> {\n+        while self.next_idx < self.set.capacity() {\n+            let idx = self.next_idx;\n+            self.next_idx += 1;\n+\n+            if self.set.contains(&idx) {\n+                return Some(idx);\n+            }\n+        }\n+\n+        return None;\n+    }\n+\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        (0, Some(self.set.capacity() - self.next_idx))\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use extra::test::BenchHarness;"}]}