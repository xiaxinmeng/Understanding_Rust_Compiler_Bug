{"sha": "3100de842b3cc33c9ad364f10c7f740ac760f564", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDBkZTg0MmIzY2MzM2M5YWQzNjRmMTBjN2Y3NDBhYzc2MGY1NjQ=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-05T09:48:52Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-13T10:24:55Z"}, "message": "Structured search replace now handles UFCS calls to trait methods", "tree": {"sha": "7713e2aea0b47ec8141fcefba101871137137c09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7713e2aea0b47ec8141fcefba101871137137c09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3100de842b3cc33c9ad364f10c7f740ac760f564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3100de842b3cc33c9ad364f10c7f740ac760f564", "html_url": "https://github.com/rust-lang/rust/commit/3100de842b3cc33c9ad364f10c7f740ac760f564", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3100de842b3cc33c9ad364f10c7f740ac760f564/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de1d93455f85747410efb69c28e0c1379e8e328a", "url": "https://api.github.com/repos/rust-lang/rust/commits/de1d93455f85747410efb69c28e0c1379e8e328a", "html_url": "https://github.com/rust-lang/rust/commit/de1d93455f85747410efb69c28e0c1379e8e328a"}], "stats": {"total": 129, "additions": 114, "deletions": 15}, "files": [{"sha": "6e0b92352843d37b4635183ca365c1db4187ab5e", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3100de842b3cc33c9ad364f10c7f740ac760f564/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100de842b3cc33c9ad364f10c7f740ac760f564/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=3100de842b3cc33c9ad364f10c7f740ac760f564", "patch": "@@ -3,7 +3,7 @@\n \n use crate::{\n     parsing::{Constraint, NodeKind, Placeholder},\n-    resolving::{ResolvedPattern, ResolvedRule},\n+    resolving::{ResolvedPattern, ResolvedRule, UfcsCallInfo},\n     SsrMatches,\n };\n use hir::Semantics;\n@@ -190,11 +190,12 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n             return Ok(());\n         }\n         // We allow a UFCS call to match a method call, provided they resolve to the same function.\n-        if let Some(pattern_function) = self.rule.pattern.ufcs_function_calls.get(pattern) {\n-            if let (Some(pattern), Some(code)) =\n-                (ast::CallExpr::cast(pattern.clone()), ast::MethodCallExpr::cast(code.clone()))\n-            {\n-                return self.attempt_match_ufcs(phase, &pattern, &code, *pattern_function);\n+        if let Some(pattern_ufcs) = self.rule.pattern.ufcs_function_calls.get(pattern) {\n+            if let Some(code) = ast::MethodCallExpr::cast(code.clone()) {\n+                return self.attempt_match_ufcs_to_method_call(phase, pattern_ufcs, &code);\n+            }\n+            if let Some(code) = ast::CallExpr::cast(code.clone()) {\n+                return self.attempt_match_ufcs_to_ufcs(phase, pattern_ufcs, &code);\n             }\n         }\n         if pattern.kind() != code.kind() {\n@@ -521,23 +522,28 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         Ok(())\n     }\n \n-    fn attempt_match_ufcs(\n+    fn attempt_match_ufcs_to_method_call(\n         &self,\n         phase: &mut Phase,\n-        pattern: &ast::CallExpr,\n+        pattern_ufcs: &UfcsCallInfo,\n         code: &ast::MethodCallExpr,\n-        pattern_function: hir::Function,\n     ) -> Result<(), MatchFailed> {\n         use ast::ArgListOwner;\n         let code_resolved_function = self\n             .sema\n             .resolve_method_call(code)\n             .ok_or_else(|| match_error!(\"Failed to resolve method call\"))?;\n-        if pattern_function != code_resolved_function {\n+        if pattern_ufcs.function != code_resolved_function {\n             fail_match!(\"Method call resolved to a different function\");\n         }\n+        if code_resolved_function.has_self_param(self.sema.db) {\n+            if let (Some(pattern_type), Some(expr)) = (&pattern_ufcs.qualifier_type, &code.expr()) {\n+                self.check_expr_type(pattern_type, expr)?;\n+            }\n+        }\n         // Check arguments.\n-        let mut pattern_args = pattern\n+        let mut pattern_args = pattern_ufcs\n+            .call_expr\n             .arg_list()\n             .ok_or_else(|| match_error!(\"Pattern function call has no args\"))?\n             .args();\n@@ -552,6 +558,45 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         }\n     }\n \n+    fn attempt_match_ufcs_to_ufcs(\n+        &self,\n+        phase: &mut Phase,\n+        pattern_ufcs: &UfcsCallInfo,\n+        code: &ast::CallExpr,\n+    ) -> Result<(), MatchFailed> {\n+        use ast::ArgListOwner;\n+        // Check that the first argument is the expected type.\n+        if let (Some(pattern_type), Some(expr)) = (\n+            &pattern_ufcs.qualifier_type,\n+            &code.arg_list().and_then(|code_args| code_args.args().next()),\n+        ) {\n+            self.check_expr_type(pattern_type, expr)?;\n+        }\n+        self.attempt_match_node_children(phase, pattern_ufcs.call_expr.syntax(), code.syntax())\n+    }\n+\n+    fn check_expr_type(\n+        &self,\n+        pattern_type: &hir::Type,\n+        expr: &ast::Expr,\n+    ) -> Result<(), MatchFailed> {\n+        use hir::HirDisplay;\n+        let code_type = self.sema.type_of_expr(&expr).ok_or_else(|| {\n+            match_error!(\"Failed to get receiver type for `{}`\", expr.syntax().text())\n+        })?;\n+        if !code_type\n+            .autoderef(self.sema.db)\n+            .any(|deref_code_type| *pattern_type == deref_code_type)\n+        {\n+            fail_match!(\n+                \"Pattern type `{}` didn't match code type `{}`\",\n+                pattern_type.display(self.sema.db),\n+                code_type.display(self.sema.db)\n+            );\n+        }\n+        Ok(())\n+    }\n+\n     fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n         only_ident(element.clone()).and_then(|ident| self.rule.get_placeholder(&ident))\n     }"}, {"sha": "bfc20705b4ee8ed6b89f45282ac2a444b99551e6", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3100de842b3cc33c9ad364f10c7f740ac760f564/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100de842b3cc33c9ad364f10c7f740ac760f564/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=3100de842b3cc33c9ad364f10c7f740ac760f564", "patch": "@@ -25,7 +25,7 @@ pub(crate) struct ResolvedPattern {\n     pub(crate) node: SyntaxNode,\n     // Paths in `node` that we've resolved.\n     pub(crate) resolved_paths: FxHashMap<SyntaxNode, ResolvedPath>,\n-    pub(crate) ufcs_function_calls: FxHashMap<SyntaxNode, hir::Function>,\n+    pub(crate) ufcs_function_calls: FxHashMap<SyntaxNode, UfcsCallInfo>,\n     pub(crate) contains_self: bool,\n }\n \n@@ -35,6 +35,12 @@ pub(crate) struct ResolvedPath {\n     pub(crate) depth: u32,\n }\n \n+pub(crate) struct UfcsCallInfo {\n+    pub(crate) call_expr: ast::CallExpr,\n+    pub(crate) function: hir::Function,\n+    pub(crate) qualifier_type: Option<hir::Type>,\n+}\n+\n impl ResolvedRule {\n     pub(crate) fn new(\n         rule: parsing::ParsedRule,\n@@ -70,18 +76,23 @@ struct Resolver<'a, 'db> {\n \n impl Resolver<'_, '_> {\n     fn resolve_pattern_tree(&self, pattern: SyntaxNode) -> Result<ResolvedPattern, SsrError> {\n+        use syntax::ast::AstNode;\n         use syntax::{SyntaxElement, T};\n         let mut resolved_paths = FxHashMap::default();\n         self.resolve(pattern.clone(), 0, &mut resolved_paths)?;\n         let ufcs_function_calls = resolved_paths\n             .iter()\n             .filter_map(|(path_node, resolved)| {\n                 if let Some(grandparent) = path_node.parent().and_then(|parent| parent.parent()) {\n-                    if grandparent.kind() == SyntaxKind::CALL_EXPR {\n+                    if let Some(call_expr) = ast::CallExpr::cast(grandparent.clone()) {\n                         if let hir::PathResolution::AssocItem(hir::AssocItem::Function(function)) =\n-                            &resolved.resolution\n+                            resolved.resolution\n                         {\n-                            return Some((grandparent, *function));\n+                            let qualifier_type = self.resolution_scope.qualifier_type(path_node);\n+                            return Some((\n+                                grandparent,\n+                                UfcsCallInfo { call_expr, function, qualifier_type },\n+                            ));\n                         }\n                     }\n                 }\n@@ -226,6 +237,20 @@ impl<'db> ResolutionScope<'db> {\n             None\n         }\n     }\n+\n+    fn qualifier_type(&self, path: &SyntaxNode) -> Option<hir::Type> {\n+        use syntax::ast::AstNode;\n+        if let Some(path) = ast::Path::cast(path.clone()) {\n+            if let Some(qualifier) = path.qualifier() {\n+                if let Some(resolved_qualifier) = self.resolve_path(&qualifier) {\n+                    if let hir::PathResolution::Def(hir::ModuleDef::Adt(adt)) = resolved_qualifier {\n+                        return Some(adt.ty(self.scope.db));\n+                    }\n+                }\n+            }\n+        }\n+        None\n+    }\n }\n \n fn is_self(path: &ast::Path) -> bool {"}, {"sha": "4bc09c1e47fc09cb41eaf3422d90f773ff54aeb7", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3100de842b3cc33c9ad364f10c7f740ac760f564/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3100de842b3cc33c9ad364f10c7f740ac760f564/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=3100de842b3cc33c9ad364f10c7f740ac760f564", "patch": "@@ -1143,3 +1143,32 @@ fn replace_self() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn match_trait_method_call() {\n+    // `Bar::foo` and `Bar2::foo` resolve to the same function. Make sure we only match if the type\n+    // matches what's in the pattern. Also checks that we handle autoderef.\n+    let code = r#\"\n+        pub struct Bar {}\n+        pub struct Bar2 {}\n+        pub trait Foo {\n+            fn foo(&self, _: i32) {}\n+        }\n+        impl Foo for Bar {}\n+        impl Foo for Bar2 {}\n+        fn main() {\n+            let v1 = Bar {};\n+            let v2 = Bar2 {};\n+            let v1_ref = &v1;\n+            let v2_ref = &v2;\n+            v1.foo(1);\n+            v2.foo(2);\n+            Bar::foo(&v1, 3);\n+            Bar2::foo(&v2, 4);\n+            v1_ref.foo(5);\n+            v2_ref.foo(6);\n+        }\n+        \"#;\n+    assert_matches(\"Bar::foo($a, $b)\", code, &[\"v1.foo(1)\", \"Bar::foo(&v1, 3)\", \"v1_ref.foo(5)\"]);\n+    assert_matches(\"Bar2::foo($a, $b)\", code, &[\"v2.foo(2)\", \"Bar2::foo(&v2, 4)\", \"v2_ref.foo(6)\"]);\n+}"}]}