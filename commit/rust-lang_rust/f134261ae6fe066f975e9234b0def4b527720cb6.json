{"sha": "f134261ae6fe066f975e9234b0def4b527720cb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMzQyNjFhZTZmZTA2NmY5NzVlOTIzNGIwZGVmNGI1Mjc3MjBjYjY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-21T09:32:26Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-21T09:32:26Z"}, "message": "Support Ruby-style block argument syntax\n\nIssue #1054", "tree": {"sha": "a48a977189fc6af3699403bf2322c54b6f4e4ac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a48a977189fc6af3699403bf2322c54b6f4e4ac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f134261ae6fe066f975e9234b0def4b527720cb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f134261ae6fe066f975e9234b0def4b527720cb6", "html_url": "https://github.com/rust-lang/rust/commit/f134261ae6fe066f975e9234b0def4b527720cb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f134261ae6fe066f975e9234b0def4b527720cb6/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff813f84a8d22c19b090637be838c1d40aab2e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff813f84a8d22c19b090637be838c1d40aab2e23", "html_url": "https://github.com/rust-lang/rust/commit/ff813f84a8d22c19b090637be838c1d40aab2e23"}], "stats": {"total": 33, "additions": 21, "deletions": 12}, "files": [{"sha": "6eade33ccd042c2f23fc6f77061ebb9313baedba", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f134261ae6fe066f975e9234b0def4b527720cb6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f134261ae6fe066f975e9234b0def4b527720cb6/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=f134261ae6fe066f975e9234b0def4b527720cb6", "patch": "@@ -781,6 +781,10 @@ fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: ast::mac_) -> @ast::expr {\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n+fn is_bar(t: token::token) -> bool {\n+    alt t { token::BINOP(token::OR.) | token::OROR. { true } _ { false } }\n+}\n+\n fn parse_bottom_expr(p: parser) -> @ast::expr {\n     let lo = p.get_lo_pos();\n     let hi = p.get_hi_pos();\n@@ -815,8 +819,7 @@ fn parse_bottom_expr(p: parser) -> @ast::expr {\n             hi = p.get_hi_pos();\n             expect(p, token::RBRACE);\n             ex = ast::expr_rec(fields, base);\n-        } else if p.peek() == token::BINOP(token::OR) ||\n-                      p.peek() == token::OROR {\n+        } else if is_bar(p.peek()) {\n             ret parse_fn_block_expr(p);\n         } else {\n             let blk = parse_block_tail(p, lo, ast::default_blk);\n@@ -1061,10 +1064,8 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n                 ret e;\n             } else {\n                 // Call expr.\n-\n-                let es =\n-                    parse_seq(token::LPAREN, token::RPAREN,\n-                              some(token::COMMA), parse_expr, p);\n+                let es = parse_seq(token::LPAREN, token::RPAREN,\n+                                   some(token::COMMA), parse_expr, p);\n                 hi = es.span.hi;\n                 let nd = ast::expr_call(e, es.node);\n                 e = mk_expr(p, lo, hi, nd);\n@@ -1088,6 +1089,19 @@ fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n               t { unexpected(p, t); }\n             }\n           }\n+          token::LBRACE. when is_bar(p.look_ahead(1u)) {\n+            p.bump();\n+            let blk = parse_fn_block_expr(p);\n+            alt e.node {\n+              ast::expr_call(f, args) {\n+                e = @{node: ast::expr_call(f, args + [blk]) with *e};\n+              }\n+              _ {\n+                e = mk_expr(p, lo, p.get_last_hi_pos(),\n+                            ast::expr_call(e, [blk]));\n+              }\n+            }\n+          }\n           _ { ret e; }\n         }\n     }\n@@ -1394,11 +1408,6 @@ fn parse_initializer(p: parser) -> option::t<ast::initializer> {\n         p.bump();\n         ret some({op: ast::init_move, expr: parse_expr(p)});\n       }\n-\n-\n-\n-\n-\n       // Now that the the channel is the first argument to receive,\n       // combining it with an initializer doesn't really make sense.\n       // case (token::RECV) {\n@@ -1792,7 +1801,7 @@ fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n     let inputs =\n         if p.peek() == token::OROR {\n-            p.bump();;\n+            p.bump();\n             []\n         } else {\n             parse_seq(token::BINOP(token::OR), token::BINOP(token::OR),"}]}