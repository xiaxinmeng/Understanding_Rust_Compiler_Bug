{"sha": "877ec946543cae6f2c86742e79bcb3182e8960df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3N2VjOTQ2NTQzY2FlNmYyYzg2NzQyZTc5YmNiMzE4MmU4OTYwZGY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-07-08T17:46:43Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-02T00:45:03Z"}, "message": "rustc_apfloat: introduce the base Float API.", "tree": {"sha": "e75aab1a7933823472864f734d897b66f56cc1a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e75aab1a7933823472864f734d897b66f56cc1a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/877ec946543cae6f2c86742e79bcb3182e8960df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/877ec946543cae6f2c86742e79bcb3182e8960df", "html_url": "https://github.com/rust-lang/rust/commit/877ec946543cae6f2c86742e79bcb3182e8960df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/877ec946543cae6f2c86742e79bcb3182e8960df/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd53dd5f9e21dce1fbc06b7f9f451d1009bdcfd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd53dd5f9e21dce1fbc06b7f9f451d1009bdcfd8", "html_url": "https://github.com/rust-lang/rust/commit/dd53dd5f9e21dce1fbc06b7f9f451d1009bdcfd8"}], "stats": {"total": 709, "additions": 709, "deletions": 0}, "files": [{"sha": "33531f104809850823f38ec865db933dfd9dedd0", "filename": "src/Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/877ec946543cae6f2c86742e79bcb3182e8960df/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/877ec946543cae6f2c86742e79bcb3182e8960df/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=877ec946543cae6f2c86742e79bcb3182e8960df", "patch": "@@ -1250,6 +1250,13 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_bitflags 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_asan\"\n version = \"0.0.0\"\n@@ -1307,6 +1314,7 @@ dependencies = [\n name = \"rustc_const_math\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_apfloat 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]"}, {"sha": "b8f8488e3027357cddebb3a33b9ce3219b141452", "filename": "src/librustc_apfloat/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/877ec946543cae6f2c86742e79bcb3182e8960df/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/877ec946543cae6f2c86742e79bcb3182e8960df/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=877ec946543cae6f2c86742e79bcb3182e8960df", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_apfloat\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "184f90c86decf8fb4961414608bcfd3d49c8949b", "filename": "src/librustc_apfloat/lib.rs", "status": "added", "additions": 689, "deletions": 0, "changes": 689, "blob_url": "https://github.com/rust-lang/rust/blob/877ec946543cae6f2c86742e79bcb3182e8960df/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/877ec946543cae6f2c86742e79bcb3182e8960df/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=877ec946543cae6f2c86742e79bcb3182e8960df", "patch": "@@ -0,0 +1,689 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Port of LLVM's APFloat software floating-point implementation from the\n+//! following C++ sources (please update commit hash when backporting):\n+//! https://github.com/llvm-mirror/llvm/tree/23efab2bbd424ed13495a420ad8641cb2c6c28f9\n+//! * `include/llvm/ADT/APFloat.h` -> `Float` and `FloatConvert` traits\n+//! * `lib/Support/APFloat.cpp` -> `ieee` and `ppc` modules\n+//! * `unittests/ADT/APFloatTest.cpp` -> `tests` directory\n+//!\n+//! The port contains no unsafe code, global state, or side-effects in general,\n+//! and the only allocations are in the conversion to/from decimal strings.\n+//!\n+//! Most of the API and the testcases are intact in some form or another,\n+//! with some ergonomic changes, such as idiomatic short names, returning\n+//! new values instead of mutating the receiver, and having separate method\n+//! variants that take a non-default rounding mode (with the suffix `_r`).\n+//! Comments have been preserved where possible, only slightly adapted.\n+//!\n+//! Instead of keeping a pointer to a configuration struct and inspecting it\n+//! dynamically on every operation, types (e.g. `ieee::Double`), traits\n+//! (e.g. `ieee::Semantics`) and associated constants are employed for\n+//! increased type safety and performance.\n+//!\n+//! On-heap bigints are replaced everywhere (except in decimal conversion),\n+//! with short arrays of `type Limb = u128` elements (instead of `u64`),\n+//! This allows fitting the largest supported significands in one integer\n+//! (`ieee::Quad` and `ppc::Fallback` use slightly less than 128 bits).\n+//! All of the functions in the `ieee::sig` module operate on slices.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_apfloat\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+#![forbid(unsafe_code)]\n+\n+#![feature(const_fn)]\n+#![feature(i128_type)]\n+\n+#[macro_use]\n+extern crate rustc_bitflags;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitOrAssign};\n+use std::str::FromStr;\n+\n+bitflags! {\n+    /// IEEE-754R 7: Default exception handling.\n+    ///\n+    /// UNDERFLOW or OVERFLOW are always returned or-ed with INEXACT.\n+    #[must_use]\n+    #[derive(Debug)]\n+    flags Status: u8 {\n+        const OK = 0x00,\n+        const INVALID_OP = 0x01,\n+        const DIV_BY_ZERO = 0x02,\n+        const OVERFLOW = 0x04,\n+        const UNDERFLOW = 0x08,\n+        const INEXACT = 0x10\n+    }\n+}\n+\n+impl BitOrAssign for Status {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub struct StatusAnd<T> {\n+    pub status: Status,\n+    pub value: T,\n+}\n+\n+impl Status {\n+    pub fn and<T>(self, value: T) -> StatusAnd<T> {\n+        StatusAnd {\n+            status: self,\n+            value,\n+        }\n+    }\n+}\n+\n+impl<T> StatusAnd<T> {\n+    fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n+        StatusAnd {\n+            status: self.status,\n+            value: f(self.value),\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! unpack {\n+    ($status:ident|=, $e:expr) => {\n+        match $e {\n+            $crate::StatusAnd { status, value } => {\n+                $status |= status;\n+                value\n+            }\n+        }\n+    };\n+    ($status:ident=, $e:expr) => {\n+        match $e {\n+            $crate::StatusAnd { status, value } => {\n+                $status = status;\n+                value\n+            }\n+        }\n+    }\n+}\n+\n+/// Category of internally-represented number.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Category {\n+    Infinity,\n+    NaN,\n+    Normal,\n+    Zero,\n+}\n+\n+/// IEEE-754R 4.3: Rounding-direction attributes.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Round {\n+    NearestTiesToEven,\n+    TowardPositive,\n+    TowardNegative,\n+    TowardZero,\n+    NearestTiesToAway,\n+}\n+\n+impl Neg for Round {\n+    type Output = Round;\n+    fn neg(self) -> Round {\n+        match self {\n+            Round::TowardPositive => Round::TowardNegative,\n+            Round::TowardNegative => Round::TowardPositive,\n+            Round::NearestTiesToEven | Round::TowardZero | Round::NearestTiesToAway => self,\n+        }\n+    }\n+}\n+\n+/// A signed type to represent a floating point number's unbiased exponent.\n+pub type ExpInt = i16;\n+\n+// \\c ilogb error results.\n+pub const IEK_INF: ExpInt = ExpInt::max_value();\n+pub const IEK_NAN: ExpInt = ExpInt::min_value();\n+pub const IEK_ZERO: ExpInt = ExpInt::min_value() + 1;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct ParseError(pub &'static str);\n+\n+/// A self-contained host- and target-independent arbitrary-precision\n+/// floating-point software implementation.\n+///\n+/// `apfloat` uses significand bignum integer arithmetic as provided by functions\n+/// in the `ieee::sig`.\n+///\n+/// Written for clarity rather than speed, in particular with a view to use in\n+/// the front-end of a cross compiler so that target arithmetic can be correctly\n+/// performed on the host. Performance should nonetheless be reasonable,\n+/// particularly for its intended use. It may be useful as a base\n+/// implementation for a run-time library during development of a faster\n+/// target-specific one.\n+///\n+/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n+/// implemented operations. Currently implemented operations are add, subtract,\n+/// multiply, divide, fused-multiply-add, conversion-to-float,\n+/// conversion-to-integer and conversion-from-integer. New rounding modes\n+/// (e.g. away from zero) can be added with three or four lines of code.\n+///\n+/// Four formats are built-in: IEEE single precision, double precision,\n+/// quadruple precision, and x87 80-bit extended double (when operating with\n+/// full extended precision). Adding a new format that obeys IEEE semantics\n+/// only requires adding two lines of code: a declaration and definition of the\n+/// format.\n+///\n+/// All operations return the status of that operation as an exception bit-mask,\n+/// so multiple operations can be done consecutively with their results or-ed\n+/// together. The returned status can be useful for compiler diagnostics; e.g.,\n+/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n+/// and compiler optimizers can determine what exceptions would be raised by\n+/// folding operations and optimize, or perhaps not optimize, accordingly.\n+///\n+/// At present, underflow tininess is detected after rounding; it should be\n+/// straight forward to add support for the before-rounding case too.\n+///\n+/// The library reads hexadecimal floating point numbers as per C99, and\n+/// correctly rounds if necessary according to the specified rounding mode.\n+/// Syntax is required to have been validated by the caller.\n+///\n+/// It also reads decimal floating point numbers and correctly rounds according\n+/// to the specified rounding mode.\n+///\n+/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n+/// signed exponent, and the significand as an array of integer limbs. After\n+/// normalization of a number of precision P the exponent is within the range of\n+/// the format, and if the number is not denormal the P-th bit of the\n+/// significand is set as an explicit integer bit. For denormals the most\n+/// significant bit is shifted right so that the exponent is maintained at the\n+/// format's minimum, so that the smallest denormal has just the least\n+/// significant bit of the significand set. The sign of zeros and infinities\n+/// is significant; the exponent and significand of such numbers is not stored,\n+/// but has a known implicit (deterministic) value: 0 for the significands, 0\n+/// for zero exponent, all 1 bits for infinity exponent. For NaNs the sign and\n+/// significand are deterministic, although not really meaningful, and preserved\n+/// in non-conversion operations. The exponent is implicitly all 1 bits.\n+///\n+/// `apfloat` does not provide any exception handling beyond default exception\n+/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n+/// by encoding Signaling NaNs with the first bit of its trailing significand as\n+/// 0.\n+///\n+/// Future work\n+/// ===========\n+///\n+/// Some features that may or may not be worth adding:\n+///\n+/// Optional ability to detect underflow tininess before rounding.\n+///\n+/// New formats: x87 in single and double precision mode (IEEE apart from\n+/// extended exponent range) (hard).\n+///\n+/// New operations: sqrt, nexttoward.\n+///\n+pub trait Float\n+    : Copy\n+    + Default\n+    + FromStr<Err = ParseError>\n+    + PartialOrd\n+    + fmt::Display\n+    + Neg<Output = Self>\n+    + AddAssign\n+    + SubAssign\n+    + MulAssign\n+    + DivAssign\n+    + RemAssign\n+    + Add<Output = StatusAnd<Self>>\n+    + Sub<Output = StatusAnd<Self>>\n+    + Mul<Output = StatusAnd<Self>>\n+    + Div<Output = StatusAnd<Self>>\n+    + Rem<Output = StatusAnd<Self>> {\n+    /// Total number of bits in the in-memory format.\n+    const BITS: usize;\n+\n+    /// Number of bits in the significand. This includes the integer bit.\n+    const PRECISION: usize;\n+\n+    /// The largest E such that 2^E is representable; this matches the\n+    /// definition of IEEE 754.\n+    const MAX_EXP: ExpInt;\n+\n+    /// The smallest E such that 2^E is a normalized number; this\n+    /// matches the definition of IEEE 754.\n+    const MIN_EXP: ExpInt;\n+\n+    /// Positive Zero.\n+    const ZERO: Self;\n+\n+    /// Positive Infinity.\n+    const INFINITY: Self;\n+\n+    /// NaN (Not a Number).\n+    // FIXME(eddyb) provide a default when qnan becomes const fn.\n+    const NAN: Self;\n+\n+    /// Factory for QNaN values.\n+    // FIXME(eddyb) should be const fn.\n+    fn qnan(payload: Option<u128>) -> Self;\n+\n+    /// Factory for SNaN values.\n+    // FIXME(eddyb) should be const fn.\n+    fn snan(payload: Option<u128>) -> Self;\n+\n+    /// Largest finite number.\n+    // FIXME(eddyb) should be const (but FloatPair::largest is nontrivial).\n+    fn largest() -> Self;\n+\n+    /// Smallest (by magnitude) finite number.\n+    /// Might be denormalized, which implies a relative loss of precision.\n+    const SMALLEST: Self;\n+\n+    /// Smallest (by magnitude) normalized finite number.\n+    // FIXME(eddyb) should be const (but FloatPair::smallest_normalized is nontrivial).\n+    fn smallest_normalized() -> Self;\n+\n+    // Arithmetic\n+\n+    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    fn sub_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.add_r(-rhs, round)\n+    }\n+    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self>;\n+    fn mul_add(self, multiplicand: Self, addend: Self) -> StatusAnd<Self> {\n+        self.mul_add_r(multiplicand, addend, Round::NearestTiesToEven)\n+    }\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    /// IEEE remainder.\n+    // This is not currently correct in all cases.\n+    fn ieee_rem(self, rhs: Self) -> StatusAnd<Self> {\n+        let mut v = self;\n+\n+        let status;\n+        v = unpack!(status=, v / rhs);\n+        if status == Status::DIV_BY_ZERO {\n+            return status.and(self);\n+        }\n+\n+        assert!(Self::PRECISION < 128);\n+\n+        let status;\n+        let x = unpack!(status=, v.to_i128_r(128, Round::NearestTiesToEven, &mut false));\n+        if status == Status::INVALID_OP {\n+            return status.and(self);\n+        }\n+\n+        let status;\n+        let mut v = unpack!(status=, Self::from_i128(x));\n+        assert_eq!(status, Status::OK); // should always work\n+\n+        let status;\n+        v = unpack!(status=, v * rhs);\n+        assert_eq!(status - Status::INEXACT, Status::OK); // should not overflow or underflow\n+\n+        let status;\n+        v = unpack!(status=, self - v);\n+        assert_eq!(status - Status::INEXACT, Status::OK); // likewise\n+\n+        if v.is_zero() {\n+            status.and(v.copy_sign(self)) // IEEE754 requires this\n+        } else {\n+            status.and(v)\n+        }\n+    }\n+    /// C fmod, or llvm frem.\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self>;\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self>;\n+\n+    /// IEEE-754R 2008 5.3.1: nextUp.\n+    fn next_up(self) -> StatusAnd<Self>;\n+\n+    /// IEEE-754R 2008 5.3.1: nextDown.\n+    ///\n+    /// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with\n+    /// appropriate sign switching before/after the computation.\n+    fn next_down(self) -> StatusAnd<Self> {\n+        (-self).next_up().map(|r| -r)\n+    }\n+\n+    fn abs(self) -> Self {\n+        if self.is_negative() { -self } else { self }\n+    }\n+    fn copy_sign(self, rhs: Self) -> Self {\n+        if self.is_negative() != rhs.is_negative() {\n+            -self\n+        } else {\n+            self\n+        }\n+    }\n+\n+    // Conversions\n+    fn from_bits(input: u128) -> Self;\n+    fn from_i128_r(input: i128, round: Round) -> StatusAnd<Self> {\n+        if input < 0 {\n+            Self::from_u128_r(-input as u128, -round).map(|r| -r)\n+        } else {\n+            Self::from_u128_r(input as u128, round)\n+        }\n+    }\n+    fn from_i128(input: i128) -> StatusAnd<Self> {\n+        Self::from_i128_r(input, Round::NearestTiesToEven)\n+    }\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self>;\n+    fn from_u128(input: u128) -> StatusAnd<Self> {\n+        Self::from_u128_r(input, Round::NearestTiesToEven)\n+    }\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError>;\n+    fn to_bits(self) -> u128;\n+\n+    /// Convert a floating point number to an integer according to the\n+    /// rounding mode. In case of an invalid operation exception,\n+    /// deterministic values are returned, namely zero for NaNs and the\n+    /// minimal or maximal value respectively for underflow or overflow.\n+    /// If the rounded value is in range but the floating point number is\n+    /// not the exact integer, the C standard doesn't require an inexact\n+    /// exception to be raised. IEEE-854 does require it so we do that.\n+    ///\n+    /// Note that for conversions to integer type the C standard requires\n+    /// round-to-zero to always be used.\n+    ///\n+    /// The *is_exact output tells whether the result is exact, in the sense\n+    /// that converting it back to the original floating point type produces\n+    /// the original value. This is almost equivalent to result==Status::OK,\n+    /// except for negative zeroes.\n+    fn to_i128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<i128> {\n+        let status;\n+        if self.is_negative() {\n+            if self.is_zero() {\n+                // Negative zero can't be represented as an int.\n+                *is_exact = false;\n+            }\n+            let r = unpack!(status=, (-self).to_u128_r(width, -round, is_exact));\n+\n+            // Check for values that don't fit in the signed integer.\n+            if r > (1 << (width - 1)) {\n+                // Return the most negative integer for the given width.\n+                *is_exact = false;\n+                Status::INVALID_OP.and(-1 << (width - 1))\n+            } else {\n+                status.and(r.wrapping_neg() as i128)\n+            }\n+        } else {\n+            // Positive case is simpler, can pretend it's a smaller unsigned\n+            // integer, and `to_u128` will take care of all the edge cases.\n+            self.to_u128_r(width - 1, round, is_exact).map(\n+                |r| r as i128,\n+            )\n+        }\n+    }\n+    fn to_i128(self, width: usize) -> StatusAnd<i128> {\n+        self.to_i128_r(width, Round::TowardZero, &mut true)\n+    }\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128>;\n+    fn to_u128(self, width: usize) -> StatusAnd<u128> {\n+        self.to_u128_r(width, Round::TowardZero, &mut true)\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering;\n+\n+    /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n+    fn bitwise_eq(self, rhs: Self) -> bool;\n+\n+    // IEEE-754R 5.7.2 General operations.\n+\n+    /// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n+    /// both are not NaN. If either argument is a NaN, returns the other argument.\n+    fn min(self, other: Self) -> Self {\n+        if self.is_nan() {\n+            other\n+        } else if other.is_nan() {\n+            self\n+        } else if other.partial_cmp(&self) == Some(Ordering::Less) {\n+            other\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n+    /// both are not NaN. If either argument is a NaN, returns the other argument.\n+    fn max(self, other: Self) -> Self {\n+        if self.is_nan() {\n+            other\n+        } else if other.is_nan() {\n+            self\n+        } else if self.partial_cmp(&other) == Some(Ordering::Less) {\n+            other\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n+    /// negative.\n+    ///\n+    /// This applies to zeros and NaNs as well.\n+    fn is_negative(self) -> bool;\n+\n+    /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n+    ///\n+    /// This implies that the current value of the float is not zero, subnormal,\n+    /// infinite, or NaN following the definition of normality from IEEE-754R.\n+    fn is_normal(self) -> bool {\n+        !self.is_denormal() && self.is_finite_non_zero()\n+    }\n+\n+    /// Returns true if and only if the current value is zero, subnormal, or\n+    /// normal.\n+    ///\n+    /// This means that the value is not infinite or NaN.\n+    fn is_finite(self) -> bool {\n+        !self.is_nan() && !self.is_infinite()\n+    }\n+\n+    /// Returns true if and only if the float is plus or minus zero.\n+    fn is_zero(self) -> bool {\n+        self.category() == Category::Zero\n+    }\n+\n+    /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n+    /// denormal.\n+    fn is_denormal(self) -> bool;\n+\n+    /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n+    fn is_infinite(self) -> bool {\n+        self.category() == Category::Infinity\n+    }\n+\n+    /// Returns true if and only if the float is a quiet or signaling NaN.\n+    fn is_nan(self) -> bool {\n+        self.category() == Category::NaN\n+    }\n+\n+    /// Returns true if and only if the float is a signaling NaN.\n+    fn is_signaling(self) -> bool;\n+\n+    // Simple Queries\n+\n+    fn category(self) -> Category;\n+    fn is_non_zero(self) -> bool {\n+        !self.is_zero()\n+    }\n+    fn is_finite_non_zero(self) -> bool {\n+        self.is_finite() && !self.is_zero()\n+    }\n+    fn is_pos_zero(self) -> bool {\n+        self.is_zero() && !self.is_negative()\n+    }\n+    fn is_neg_zero(self) -> bool {\n+        self.is_zero() && self.is_negative()\n+    }\n+\n+    /// Returns true if and only if the number has the smallest possible non-zero\n+    /// magnitude in the current semantics.\n+    fn is_smallest(self) -> bool {\n+        Self::SMALLEST.copy_sign(self).bitwise_eq(self)\n+    }\n+\n+    /// Returns true if and only if the number has the largest possible finite\n+    /// magnitude in the current semantics.\n+    fn is_largest(self) -> bool {\n+        Self::largest().copy_sign(self).bitwise_eq(self)\n+    }\n+\n+    /// Returns true if and only if the number is an exact integer.\n+    fn is_integer(self) -> bool {\n+        // This could be made more efficient; I'm going for obviously correct.\n+        if !self.is_finite() {\n+            return false;\n+        }\n+        self.round_to_integral(Round::TowardZero).value.bitwise_eq(\n+            self,\n+        )\n+    }\n+\n+    /// If this value has an exact multiplicative inverse, return it.\n+    fn get_exact_inverse(self) -> Option<Self>;\n+\n+    /// Returns the exponent of the internal representation of the Float.\n+    ///\n+    /// Because the radix of Float is 2, this is equivalent to floor(log2(x)).\n+    /// For special Float values, this returns special error codes:\n+    ///\n+    ///   NaN -> \\c IEK_NAN\n+    ///   0   -> \\c IEK_ZERO\n+    ///   Inf -> \\c IEK_INF\n+    ///\n+    fn ilogb(self) -> ExpInt;\n+\n+    /// Returns: self * 2^exp for integral exponents.\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self;\n+    fn scalbn(self, exp: ExpInt) -> Self {\n+        self.scalbn_r(exp, Round::NearestTiesToEven)\n+    }\n+\n+    /// Equivalent of C standard library function.\n+    ///\n+    /// While the C standard says exp is an unspecified value for infinity and nan,\n+    /// this returns INT_MAX for infinities, and INT_MIN for NaNs (see `ilogb`).\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self;\n+    fn frexp(self, exp: &mut ExpInt) -> Self {\n+        self.frexp_r(exp, Round::NearestTiesToEven)\n+    }\n+}\n+\n+pub trait FloatConvert<T: Float>: Float {\n+    /// Convert a value of one floating point type to another.\n+    /// The return value corresponds to the IEEE754 exceptions. *loses_info\n+    /// records whether the transformation lost information, i.e. whether\n+    /// converting the result back to the original type will produce the\n+    /// original value (this is almost the same as return value==Status::OK,\n+    /// but there are edge cases where this is not so).\n+    fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<T>;\n+    fn convert(self, loses_info: &mut bool) -> StatusAnd<T> {\n+        self.convert_r(Round::NearestTiesToEven, loses_info)\n+    }\n+}\n+\n+#[allow(unused)]\n+macro_rules! float_common_impls {\n+    ($ty:ident<$t:tt>) => {\n+        impl<$t> Default for $ty<$t> where Self: Float {\n+            fn default() -> Self {\n+                Self::ZERO\n+            }\n+        }\n+\n+        impl<$t> ::std::str::FromStr for $ty<$t> where Self: Float {\n+            type Err = ParseError;\n+            fn from_str(s: &str) -> Result<Self, ParseError> {\n+                Self::from_str_r(s, Round::NearestTiesToEven).map(|x| x.value)\n+            }\n+        }\n+\n+        // Rounding ties to the nearest even, by default.\n+\n+        impl<$t> ::std::ops::Add for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn add(self, rhs: Self) -> StatusAnd<Self> {\n+                self.add_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Sub for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn sub(self, rhs: Self) -> StatusAnd<Self> {\n+                self.sub_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Mul for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn mul(self, rhs: Self) -> StatusAnd<Self> {\n+                self.mul_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Div for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn div(self, rhs: Self) -> StatusAnd<Self> {\n+                self.div_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Rem for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn rem(self, rhs: Self) -> StatusAnd<Self> {\n+                self.c_fmod(rhs)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::AddAssign for $ty<$t> where Self: Float {\n+            fn add_assign(&mut self, rhs: Self) {\n+                *self = (*self + rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::SubAssign for $ty<$t> where Self: Float {\n+            fn sub_assign(&mut self, rhs: Self) {\n+                *self = (*self - rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::MulAssign for $ty<$t> where Self: Float {\n+            fn mul_assign(&mut self, rhs: Self) {\n+                *self = (*self * rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::DivAssign for $ty<$t> where Self: Float {\n+            fn div_assign(&mut self, rhs: Self) {\n+                *self = (*self / rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::RemAssign for $ty<$t> where Self: Float {\n+            fn rem_assign(&mut self, rhs: Self) {\n+                *self = (*self % rhs).value;\n+            }\n+        }\n+    }\n+}"}, {"sha": "41310ede3e085a0928288779615792ea79dd8055", "filename": "src/librustc_const_math/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/877ec946543cae6f2c86742e79bcb3182e8960df/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/877ec946543cae6f2c86742e79bcb3182e8960df/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=877ec946543cae6f2c86742e79bcb3182e8960df", "patch": "@@ -9,5 +9,6 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}]}