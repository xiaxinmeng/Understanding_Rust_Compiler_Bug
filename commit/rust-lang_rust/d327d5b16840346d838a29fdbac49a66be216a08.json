{"sha": "d327d5b16840346d838a29fdbac49a66be216a08", "node_id": "C_kwDOAAsO6NoAKGQzMjdkNWIxNjg0MDM0NmQ4MzhhMjlmZGJhYzQ5YTY2YmUyMTZhMDg", "commit": {"author": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2023-04-30T12:43:59Z"}, "committer": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2023-05-05T11:06:47Z"}, "message": "Improve internal representation of check-cfg\n\nThis is done to simplify to relationship between names() and values()\nbut also make thing clearer (having an Any to represent that any values\nare allowed) but also to allow the (none) + values expected cases that\nwasn't possible before.", "tree": {"sha": "3a95babdc860ad30ce04e370fee3befd178c6c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a95babdc860ad30ce04e370fee3befd178c6c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d327d5b16840346d838a29fdbac49a66be216a08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d327d5b16840346d838a29fdbac49a66be216a08", "html_url": "https://github.com/rust-lang/rust/commit/d327d5b16840346d838a29fdbac49a66be216a08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d327d5b16840346d838a29fdbac49a66be216a08/comments", "author": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6f4b73ebfc26859a3a6b70b3790ab55d285440", "html_url": "https://github.com/rust-lang/rust/commit/ad6f4b73ebfc26859a3a6b70b3790ab55d285440"}], "stats": {"total": 326, "additions": 173, "deletions": 153}, "files": [{"sha": "70426d86075202a9fed3628af9c9bbe4f4206d6a", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=d327d5b16840346d838a29fdbac49a66be216a08", "patch": "@@ -5,6 +5,7 @@ use rustc_ast::{Attribute, LitKind, MetaItem, MetaItemKind, MetaItemLit, NestedM\n use rustc_ast_pretty::pprust;\n use rustc_feature::{find_gated_cfg, is_builtin_attr_name, Features, GatedCfg};\n use rustc_macros::HashStable_Generic;\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::builtin::UNEXPECTED_CFGS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n@@ -581,8 +582,20 @@ pub fn cfg_matches(\n ) -> bool {\n     eval_condition(cfg, sess, features, &mut |cfg| {\n         try_gate_cfg(cfg.name, cfg.span, sess, features);\n-        if let Some(names_valid) = &sess.check_config.names_valid {\n-            if !names_valid.contains(&cfg.name) {\n+        match sess.check_config.expecteds.get(&cfg.name) {\n+            Some(ExpectedValues::Some(values)) if !values.contains(&cfg.value) => {\n+                sess.buffer_lint_with_diagnostic(\n+                    UNEXPECTED_CFGS,\n+                    cfg.span,\n+                    lint_node_id,\n+                    \"unexpected `cfg` condition value\",\n+                    BuiltinLintDiagnostics::UnexpectedCfg(\n+                        (cfg.name, cfg.name_span),\n+                        cfg.value_span.map(|vs| (cfg.value.unwrap(), vs)),\n+                    ),\n+                );\n+            }\n+            None if sess.check_config.exhaustive_names => {\n                 sess.buffer_lint_with_diagnostic(\n                     UNEXPECTED_CFGS,\n                     cfg.span,\n@@ -591,22 +604,7 @@ pub fn cfg_matches(\n                     BuiltinLintDiagnostics::UnexpectedCfg((cfg.name, cfg.name_span), None),\n                 );\n             }\n-        }\n-        if let Some(value) = cfg.value {\n-            if let Some(values) = &sess.check_config.values_valid.get(&cfg.name) {\n-                if !values.contains(&value) {\n-                    sess.buffer_lint_with_diagnostic(\n-                        UNEXPECTED_CFGS,\n-                        cfg.span,\n-                        lint_node_id,\n-                        \"unexpected `cfg` condition value\",\n-                        BuiltinLintDiagnostics::UnexpectedCfg(\n-                            (cfg.name, cfg.name_span),\n-                            cfg.value_span.map(|vs| (value, vs)),\n-                        ),\n-                    );\n-                }\n-            }\n+            _ => { /* not unexpected */ }\n         }\n         sess.config.contains(&(cfg.name, cfg.value))\n     })"}, {"sha": "9d9f4ee13f402dc9c6374b8ca20cbd6b65e86204", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=d327d5b16840346d838a29fdbac49a66be216a08", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_lint::LintStore;\n-use rustc_middle::ty;\n+use rustc_middle::{bug, ty};\n use rustc_parse::maybe_new_parser_from_source_str;\n use rustc_query_impl::QueryCtxt;\n use rustc_query_system::query::print_query_stack;\n@@ -154,12 +154,14 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                     Ok(meta_item) if parser.token == token::Eof => {\n                         if let Some(args) = meta_item.meta_item_list() {\n                             if meta_item.has_name(sym::names) {\n-                                let names_valid =\n-                                    check_cfg.names_valid.get_or_insert_with(|| FxHashSet::default());\n+                                check_cfg.exhaustive_names = true;\n                                 for arg in args {\n                                     if arg.is_word() && arg.ident().is_some() {\n                                         let ident = arg.ident().expect(\"multi-segment cfg key\");\n-                                        names_valid.insert(ident.name.to_string());\n+                                        check_cfg\n+                                            .expecteds\n+                                            .entry(ident.name.to_string())\n+                                            .or_insert(ExpectedValues::Any);\n                                     } else {\n                                         error!(\"`names()` arguments must be simple identifiers\");\n                                     }\n@@ -168,8 +170,8 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                 if let Some((name, values)) = args.split_first() {\n                                     if name.is_word() && name.ident().is_some() {\n                                         let ident = name.ident().expect(\"multi-segment cfg key\");\n-                                        let ident_values = check_cfg\n-                                            .values_valid\n+                                        let expected_values = check_cfg\n+                                            .expecteds\n                                             .entry(ident.name.to_string())\n                                             .or_insert_with(|| {\n                                                 ExpectedValues::Some(FxHashSet::default())\n@@ -183,20 +185,24 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                             if let Some(LitKind::Str(s, _)) =\n                                                 val.lit().map(|lit| &lit.kind)\n                                             {\n-                                                ident_values.insert(s.to_string());\n+                                                expected_values.insert(Some(s.to_string()));\n                                             } else {\n                                                 error!(\n                                                     \"`values()` arguments must be string literals\"\n                                                 );\n                                             }\n                                         }\n+\n+                                        if values.is_empty() {\n+                                            expected_values.insert(None);\n+                                        }\n                                     } else {\n                                         error!(\n                                             \"`values()` first argument must be a simple identifier\"\n                                         );\n                                     }\n                                 } else if args.is_empty() {\n-                                    check_cfg.well_known_values = true;\n+                                    check_cfg.exhaustive_values = true;\n                                 } else {\n                                     expected_error();\n                                 }\n@@ -220,9 +226,6 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n             }\n         }\n \n-        if let Some(names_valid) = &mut check_cfg.names_valid {\n-            names_valid.extend(check_cfg.values_valid.keys().cloned());\n-        }\n         check_cfg\n     })\n }"}, {"sha": "010526988506d2c721f36d6993586e687d6dbb65", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=d327d5b16840346d838a29fdbac49a66be216a08", "patch": "@@ -63,6 +63,7 @@ use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n+use rustc_session::config::ExpectedValues;\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n@@ -3306,16 +3307,15 @@ impl EarlyLintPass for UnexpectedCfgs {\n         let cfg = &cx.sess().parse_sess.config;\n         let check_cfg = &cx.sess().parse_sess.check_config;\n         for &(name, value) in cfg {\n-            if let Some(names_valid) = &check_cfg.names_valid && !names_valid.contains(&name){\n-                cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName {\n-                    name,\n-                });\n-            }\n-            if let Some(value) = value && let Some(values) = check_cfg.values_valid.get(&name) && !values.contains(&value) {\n-                cx.emit_lint(\n-                    UNEXPECTED_CFGS,\n-                    BuiltinUnexpectedCliConfigValue { name, value },\n-                );\n+            match check_cfg.expecteds.get(&name) {\n+                Some(ExpectedValues::Some(values)) if !values.contains(&value) => {\n+                    let value = value.unwrap_or(kw::Empty);\n+                    cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigValue { name, value });\n+                }\n+                None if check_cfg.exhaustive_names => {\n+                    cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName { name });\n+                }\n+                _ => { /* expected */ }\n             }\n         }\n     }"}, {"sha": "f53a7bb0c19db6ad77a42257b31972cfdf2be5e6", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=d327d5b16840346d838a29fdbac49a66be216a08", "patch": "@@ -769,21 +769,23 @@ pub trait LintContext: Sized {\n                     db.note(\"see the asm section of Rust By Example <https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html#labels> for more information\");\n                 },\n                 BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), None) => {\n-                    let Some(names_valid) = &sess.parse_sess.check_config.names_valid else {\n-                        bug!(\"it shouldn't be possible to have a diagnostic on a name if name checking is not enabled\");\n-                    };\n-                    let possibilities: Vec<Symbol> = names_valid.iter().map(|s| *s).collect();\n+                    let possibilities: Vec<Symbol> = sess.parse_sess.check_config.expecteds.keys().map(|s| *s).collect();\n \n                     // Suggest the most probable if we found one\n                     if let Some(best_match) = find_best_match_for_name(&possibilities, name, None) {\n                         db.span_suggestion(name_span, \"did you mean\", best_match, Applicability::MaybeIncorrect);\n                     }\n                 },\n                 BuiltinLintDiagnostics::UnexpectedCfg((name, name_span), Some((value, value_span))) => {\n-                    let Some(values) = &sess.parse_sess.check_config.values_valid.get(&name) else {\n+                    let Some(rustc_session::config::ExpectedValues::Some(values)) = &sess.parse_sess.check_config.expecteds.get(&name) else {\n                         bug!(\"it shouldn't be possible to have a diagnostic on a value whose name is not in values\");\n                     };\n-                    let possibilities: Vec<Symbol> = values.iter().map(|&s| s).collect();\n+                    let mut have_none_possibility = false;\n+                    let possibilities: Vec<Symbol> = values.iter()\n+                        .inspect(|a| have_none_possibility |= a.is_none())\n+                        .copied()\n+                        .filter_map(std::convert::identity)\n+                        .collect();\n \n                     // Show the full list if all possible values for a given name, but don't do it\n                     // for names as the possibilities could be very long"}, {"sha": "e731fde6c3c6d0eb7435c649a6c37e2c563573cb", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 125, "deletions": 108, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d327d5b16840346d838a29fdbac49a66be216a08/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=d327d5b16840346d838a29fdbac49a66be216a08", "patch": "@@ -1056,37 +1056,76 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> CrateConfig\n \n /// The parsed `--check-cfg` options\n pub struct CheckCfg<T = String> {\n-    /// The set of all `names()`, if None no name checking is performed\n-    pub names_valid: Option<FxHashSet<T>>,\n+    /// Is well known names activated\n+    pub exhaustive_names: bool,\n     /// Is well known values activated\n-    pub well_known_values: bool,\n-    /// The set of all `values()`\n-    pub values_valid: FxHashMap<T, FxHashSet<T>>,\n+    pub exhaustive_values: bool,\n+    /// All the expected values for a config name\n+    pub expecteds: FxHashMap<T, ExpectedValues<T>>,\n }\n \n impl<T> Default for CheckCfg<T> {\n     fn default() -> Self {\n         CheckCfg {\n-            names_valid: Default::default(),\n-            values_valid: Default::default(),\n-            well_known_values: false,\n+            exhaustive_names: false,\n+            exhaustive_values: false,\n+            expecteds: FxHashMap::default(),\n         }\n     }\n }\n \n impl<T> CheckCfg<T> {\n-    fn map_data<O: Eq + Hash>(&self, f: impl Fn(&T) -> O) -> CheckCfg<O> {\n+    fn map_data<O: Eq + Hash>(self, f: impl Fn(T) -> O) -> CheckCfg<O> {\n         CheckCfg {\n-            names_valid: self\n-                .names_valid\n-                .as_ref()\n-                .map(|names_valid| names_valid.iter().map(|a| f(a)).collect()),\n-            values_valid: self\n-                .values_valid\n-                .iter()\n-                .map(|(a, b)| (f(a), b.iter().map(|b| f(b)).collect()))\n+            exhaustive_names: self.exhaustive_names,\n+            exhaustive_values: self.exhaustive_values,\n+            expecteds: self\n+                .expecteds\n+                .into_iter()\n+                .map(|(name, values)| {\n+                    (\n+                        f(name),\n+                        match values {\n+                            ExpectedValues::Some(values) => ExpectedValues::Some(\n+                                values.into_iter().map(|b| b.map(|b| f(b))).collect(),\n+                            ),\n+                            ExpectedValues::Any => ExpectedValues::Any,\n+                        },\n+                    )\n+                })\n                 .collect(),\n-            well_known_values: self.well_known_values,\n+        }\n+    }\n+}\n+\n+pub enum ExpectedValues<T> {\n+    Some(FxHashSet<Option<T>>),\n+    Any,\n+}\n+\n+impl<T: Eq + Hash> ExpectedValues<T> {\n+    fn insert(&mut self, value: T) -> bool {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.insert(Some(value)),\n+            ExpectedValues::Any => false,\n+        }\n+    }\n+}\n+\n+impl<T: Eq + Hash> Extend<T> for ExpectedValues<T> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.extend(iter.into_iter().map(Some)),\n+            ExpectedValues::Any => {}\n+        }\n+    }\n+}\n+\n+impl<'a, T: Eq + Hash + Copy + 'a> Extend<&'a T> for ExpectedValues<T> {\n+    fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n+        match self {\n+            ExpectedValues::Some(expecteds) => expecteds.extend(iter.into_iter().map(|a| Some(*a))),\n+            ExpectedValues::Any => {}\n         }\n     }\n }\n@@ -1095,58 +1134,27 @@ impl<T> CheckCfg<T> {\n /// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n /// but the symbol interner is not yet set up then, so we must convert it later.\n pub fn to_crate_check_config(cfg: CheckCfg) -> CrateCheckConfig {\n-    cfg.map_data(|s| Symbol::intern(s))\n+    cfg.map_data(|s| Symbol::intern(&s))\n }\n \n impl CrateCheckConfig {\n-    /// Fills a `CrateCheckConfig` with well-known configuration names.\n-    fn fill_well_known_names(&mut self) {\n-        // NOTE: This should be kept in sync with `default_configuration` and\n-        // `fill_well_known_values`\n-        const WELL_KNOWN_NAMES: &[Symbol] = &[\n-            // rustc\n-            sym::unix,\n-            sym::windows,\n-            sym::target_os,\n-            sym::target_family,\n-            sym::target_arch,\n-            sym::target_endian,\n-            sym::target_pointer_width,\n-            sym::target_env,\n-            sym::target_abi,\n-            sym::target_vendor,\n-            sym::target_thread_local,\n-            sym::target_has_atomic_load_store,\n-            sym::target_has_atomic,\n-            sym::target_has_atomic_equal_alignment,\n-            sym::target_feature,\n-            sym::panic,\n-            sym::sanitize,\n-            sym::debug_assertions,\n-            sym::proc_macro,\n-            sym::test,\n-            sym::feature,\n-            // rustdoc\n-            sym::doc,\n-            sym::doctest,\n-            // miri\n-            sym::miri,\n-        ];\n-\n-        // We only insert well-known names if `names()` was activated\n-        if let Some(names_valid) = &mut self.names_valid {\n-            names_valid.extend(WELL_KNOWN_NAMES);\n-        }\n-    }\n-\n-    /// Fills a `CrateCheckConfig` with well-known configuration values.\n-    fn fill_well_known_values(&mut self, current_target: &Target) {\n-        if !self.well_known_values {\n+    pub fn fill_well_known(&mut self, current_target: &Target) {\n+        if !self.exhaustive_values && !self.exhaustive_names {\n             return;\n         }\n \n-        // NOTE: This should be kept in sync with `default_configuration` and\n-        // `fill_well_known_names`\n+        let no_values = || {\n+            let mut values = FxHashSet::default();\n+            values.insert(None);\n+            ExpectedValues::Some(values)\n+        };\n+\n+        let empty_values = || {\n+            let values = FxHashSet::default();\n+            ExpectedValues::Some(values)\n+        };\n+\n+        // NOTE: This should be kept in sync with `default_configuration`\n \n         let panic_values = &PanicStrategy::all();\n \n@@ -1166,6 +1174,9 @@ impl CrateCheckConfig {\n         // Unknown possible values:\n         //  - `feature`\n         //  - `target_feature`\n+        for name in [sym::feature, sym::target_feature] {\n+            self.expecteds.entry(name).or_insert(ExpectedValues::Any);\n+        }\n \n         // No-values\n         for name in [\n@@ -1179,20 +1190,23 @@ impl CrateCheckConfig {\n             sym::debug_assertions,\n             sym::target_thread_local,\n         ] {\n-            self.values_valid.entry(name).or_default();\n+            self.expecteds.entry(name).or_insert_with(no_values);\n         }\n \n         // Pre-defined values\n-        self.values_valid.entry(sym::panic).or_default().extend(panic_values);\n-        self.values_valid.entry(sym::sanitize).or_default().extend(sanitize_values);\n-        self.values_valid.entry(sym::target_has_atomic).or_default().extend(atomic_values);\n-        self.values_valid\n+        self.expecteds.entry(sym::panic).or_insert_with(empty_values).extend(panic_values);\n+        self.expecteds.entry(sym::sanitize).or_insert_with(empty_values).extend(sanitize_values);\n+        self.expecteds\n+            .entry(sym::target_has_atomic)\n+            .or_insert_with(no_values)\n+            .extend(atomic_values);\n+        self.expecteds\n             .entry(sym::target_has_atomic_load_store)\n-            .or_default()\n+            .or_insert_with(no_values)\n             .extend(atomic_values);\n-        self.values_valid\n+        self.expecteds\n             .entry(sym::target_has_atomic_equal_alignment)\n-            .or_default()\n+            .or_insert_with(no_values)\n             .extend(atomic_values);\n \n         // Target specific values\n@@ -1210,47 +1224,50 @@ impl CrateCheckConfig {\n \n             // Initialize (if not already initialized)\n             for &e in VALUES {\n-                self.values_valid.entry(e).or_default();\n+                let entry = self.expecteds.entry(e);\n+                if !self.exhaustive_values {\n+                    entry.or_insert(ExpectedValues::Any);\n+                } else {\n+                    entry.or_insert_with(empty_values);\n+                }\n             }\n \n-            // Get all values map at once otherwise it would be costly.\n-            // (8 values * 220 targets ~= 1760 times, at the time of writing this comment).\n-            let [\n-                values_target_os,\n-                values_target_family,\n-                values_target_arch,\n-                values_target_endian,\n-                values_target_env,\n-                values_target_abi,\n-                values_target_vendor,\n-                values_target_pointer_width,\n-            ] = self\n-                .values_valid\n-                .get_many_mut(VALUES)\n-                .expect(\"unable to get all the check-cfg values buckets\");\n-\n-            for target in TARGETS\n-                .iter()\n-                .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n-                .chain(iter::once(current_target.clone()))\n-            {\n-                values_target_os.insert(Symbol::intern(&target.options.os));\n-                values_target_family\n-                    .extend(target.options.families.iter().map(|family| Symbol::intern(family)));\n-                values_target_arch.insert(Symbol::intern(&target.arch));\n-                values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n-                values_target_env.insert(Symbol::intern(&target.options.env));\n-                values_target_abi.insert(Symbol::intern(&target.options.abi));\n-                values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n-                values_target_pointer_width.insert(sym::integer(target.pointer_width));\n+            if self.exhaustive_values {\n+                // Get all values map at once otherwise it would be costly.\n+                // (8 values * 220 targets ~= 1760 times, at the time of writing this comment).\n+                let [\n+                    values_target_os,\n+                    values_target_family,\n+                    values_target_arch,\n+                    values_target_endian,\n+                    values_target_env,\n+                    values_target_abi,\n+                    values_target_vendor,\n+                    values_target_pointer_width,\n+                ] = self\n+                    .expecteds\n+                    .get_many_mut(VALUES)\n+                    .expect(\"unable to get all the check-cfg values buckets\");\n+\n+                for target in TARGETS\n+                    .iter()\n+                    .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n+                    .chain(iter::once(current_target.clone()))\n+                {\n+                    values_target_os.insert(Symbol::intern(&target.options.os));\n+                    values_target_family.extend(\n+                        target.options.families.iter().map(|family| Symbol::intern(family)),\n+                    );\n+                    values_target_arch.insert(Symbol::intern(&target.arch));\n+                    values_target_endian.insert(Symbol::intern(target.options.endian.as_str()));\n+                    values_target_env.insert(Symbol::intern(&target.options.env));\n+                    values_target_abi.insert(Symbol::intern(&target.options.abi));\n+                    values_target_vendor.insert(Symbol::intern(&target.options.vendor));\n+                    values_target_pointer_width.insert(sym::integer(target.pointer_width));\n+                }\n             }\n         }\n     }\n-\n-    pub fn fill_well_known(&mut self, current_target: &Target) {\n-        self.fill_well_known_names();\n-        self.fill_well_known_values(current_target);\n-    }\n }\n \n pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateConfig {"}]}