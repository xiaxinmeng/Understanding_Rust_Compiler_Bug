{"sha": "890b39381f587169c0684831ff04f9d8602ea95a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MGIzOTM4MWY1ODcxNjljMDY4NDgzMWZmMDRmOWQ4NjAyZWE5NWE=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-03-31T15:19:29Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2020-03-31T17:45:05Z"}, "message": "Use Place directly, it's Copy even more use cases", "tree": {"sha": "5a250f64bbcfe4078d145b398ed4c79a529cc7ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a250f64bbcfe4078d145b398ed4c79a529cc7ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/890b39381f587169c0684831ff04f9d8602ea95a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAl6DgaMACgkQgTGiTgx5\n769XuxAAkNDtvRNtrvBqkjISFcaAUD0B/W4LXUB04hKoNmRVp2Nk9GI89hUC+PPp\n/08SBmZAnDgOKF+DRKtV8pnQlR22FO739jlJF+SU+2kQWX9xBmkkOc4E73bR+ccd\n83F8Ij3093HEj4L+pg4Jy1dKlALrw8KXz/GPTuIyBnmQoy1yuza+z6TwpjT5Cdix\nyHW3NXp1wLvPbgxNoD/DHLObJyX+4FHt058J5ELXE3WmTr1xN1IvkeF3XQwp1qKh\nIQdDLrHet9bwStoQJxxFGVUiOnO6orA1ZEXRps1CUHlEpdHNh5dw29DvkKdC3Pq7\nDbbNE2SMoWkubiIDX1PAp/HGwMZCo1bG0ew12JSpc9VnsHivzpZ3bZZwkNbFusoS\nSzqAyA9aNj0JDq1NwJjtI7Y79hBtqmfYQ3sfXcFYSDQs/9dwHVRt5Gd0qMNhOsu/\nUOULdbsmbfVxs6fULeR8V8vWrGRtKEWpF5QQO5RclCun5ne1ldk/dAuTXnmQKrvW\n/R+LmZ45xf3fE2jp3tmjDDYbSq8W7vDqGS/S6AQZCmZ55rkQGUsJ821qWsGFd2Jy\nh4VJX5ASiqp9OdtX0RsM3/bIo0atO51Co03J5KSSYdQ6Z5RPfURliAYeBXN7I5eb\nv0OuSR4HohNWUzNsT5aShQPWYCYuEbg+kHTBvWitmM76H1tH2hY=\n=6c+O\n-----END PGP SIGNATURE-----", "payload": "tree 5a250f64bbcfe4078d145b398ed4c79a529cc7ab\nparent 25528c1e2826f895b6b6485f93de0477d79af8ea\nauthor Santiago Pastorino <spastorino@gmail.com> 1585667969 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1585676705 -0300\n\nUse Place directly, it's Copy even more use cases\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/890b39381f587169c0684831ff04f9d8602ea95a", "html_url": "https://github.com/rust-lang/rust/commit/890b39381f587169c0684831ff04f9d8602ea95a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/890b39381f587169c0684831ff04f9d8602ea95a/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25528c1e2826f895b6b6485f93de0477d79af8ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/25528c1e2826f895b6b6485f93de0477d79af8ea", "html_url": "https://github.com/rust-lang/rust/commit/25528c1e2826f895b6b6485f93de0477d79af8ea"}], "stats": {"total": 239, "additions": 120, "deletions": 119}, "files": [{"sha": "9df5760563129802b790870965b86e89c353529a", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -396,8 +396,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n                 self.suggest_split_at_mut_if_applicable(\n                     &mut err,\n-                    &place,\n-                    &issued_borrow.borrowed_place,\n+                    place,\n+                    issued_borrow.borrowed_place,\n                 );\n                 err\n             }\n@@ -410,7 +410,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             (BorrowKind::Mut { .. }, BorrowKind::Shallow)\n             | (BorrowKind::Unique, BorrowKind::Shallow) => {\n                 if let Some(immutable_section_description) =\n-                    self.classify_immutable_section(&issued_borrow.assigned_place)\n+                    self.classify_immutable_section(issued_borrow.assigned_place)\n                 {\n                     let mut err = self.cannot_mutate_in_immutable_section(\n                         span,\n@@ -546,8 +546,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn suggest_split_at_mut_if_applicable(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        place: &Place<'tcx>,\n-        borrowed_place: &Place<'tcx>,\n+        place: Place<'tcx>,\n+        borrowed_place: Place<'tcx>,\n     ) {\n         if let ([ProjectionElem::Index(_)], [ProjectionElem::Index(_)]) =\n             (&place.projection[..], &borrowed_place.projection[..])\n@@ -1382,7 +1382,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n         let descr_place = self.describe_any_place(place.as_ref());\n         if loan.kind == BorrowKind::Shallow {\n-            if let Some(section) = self.classify_immutable_section(&loan.assigned_place) {\n+            if let Some(section) = self.classify_immutable_section(loan.assigned_place) {\n                 let mut err = self.cannot_mutate_in_immutable_section(\n                     span,\n                     loan_span,\n@@ -1534,17 +1534,17 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     /// Describe the reason for the fake borrow that was assigned to `place`.\n-    fn classify_immutable_section(&self, place: &Place<'tcx>) -> Option<&'static str> {\n+    fn classify_immutable_section(&self, place: Place<'tcx>) -> Option<&'static str> {\n         use rustc_middle::mir::visit::Visitor;\n-        struct FakeReadCauseFinder<'a, 'tcx> {\n-            place: &'a Place<'tcx>,\n+        struct FakeReadCauseFinder<'tcx> {\n+            place: Place<'tcx>,\n             cause: Option<FakeReadCause>,\n         }\n-        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'_, 'tcx> {\n+        impl<'tcx> Visitor<'tcx> for FakeReadCauseFinder<'tcx> {\n             fn visit_statement(&mut self, statement: &Statement<'tcx>, _: Location) {\n                 match statement {\n-                    Statement { kind: StatementKind::FakeRead(cause, box ref place), .. }\n-                        if *place == *self.place =>\n+                    Statement { kind: StatementKind::FakeRead(cause, box place), .. }\n+                        if *place == self.place =>\n                     {\n                         self.cause = Some(*cause);\n                     }"}, {"sha": "d32533b6ce9a1a35ac98414e83a7c8c0f8892e05", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // whether or not the right-hand side is a place expression\n                         if let LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                             VarBindingForm {\n-                                opt_match_place: Some((ref opt_match_place, match_span)),\n+                                opt_match_place: Some((opt_match_place, match_span)),\n                                 binding_mode: _,\n                                 opt_ty_info: _,\n                                 pat_span: _,\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                                 grouped_errors,\n                                 kind,\n                                 original_path,\n-                                move_from,\n+                                *move_from,\n                                 local,\n                                 opt_match_place,\n                                 match_span,\n@@ -143,16 +143,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         grouped_errors: &mut Vec<GroupedMoveError<'tcx>>,\n         kind: IllegalMoveOriginKind<'tcx>,\n         original_path: Place<'tcx>,\n-        move_from: &Place<'tcx>,\n+        move_from: Place<'tcx>,\n         bind_to: Local,\n-        match_place: &Option<Place<'tcx>>,\n+        match_place: Option<Place<'tcx>>,\n         match_span: Span,\n         statement_span: Span,\n     ) {\n         debug!(\"append_binding_error(match_place={:?}, match_span={:?})\", match_place, match_span);\n \n         let from_simple_let = match_place.is_none();\n-        let match_place = match_place.as_ref().unwrap_or(move_from);\n+        let match_place = match_place.unwrap_or(move_from);\n \n         match self.move_data.rev_lookup.find(match_place.as_ref()) {\n             // Error with the match place\n@@ -178,7 +178,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 };\n                 grouped_errors.push(GroupedMoveError::MovesFromPlace {\n                     span,\n-                    move_from: *match_place,\n+                    move_from,\n                     original_path,\n                     kind,\n                     binds_to,\n@@ -223,14 +223,14 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             let (span, use_spans, original_path, kind): (\n                 Span,\n                 Option<UseSpans>,\n-                &Place<'tcx>,\n+                Place<'tcx>,\n                 &IllegalMoveOriginKind<'_>,\n             ) = match error {\n-                GroupedMoveError::MovesFromPlace { span, ref original_path, ref kind, .. }\n-                | GroupedMoveError::MovesFromValue { span, ref original_path, ref kind, .. } => {\n+                GroupedMoveError::MovesFromPlace { span, original_path, ref kind, .. }\n+                | GroupedMoveError::MovesFromValue { span, original_path, ref kind, .. } => {\n                     (span, None, original_path, kind)\n                 }\n-                GroupedMoveError::OtherIllegalMove { use_spans, ref original_path, ref kind } => {\n+                GroupedMoveError::OtherIllegalMove { use_spans, original_path, ref kind } => {\n                     (use_spans.args_or_use(), Some(use_spans), original_path, kind)\n                 }\n             };\n@@ -247,7 +247,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => self\n                         .report_cannot_move_from_borrowed_content(\n                             original_path,\n-                            target_place,\n+                            *target_place,\n                             span,\n                             use_spans,\n                         ),\n@@ -268,7 +268,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn report_cannot_move_from_static(\n         &mut self,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n         span: Span,\n     ) -> DiagnosticBuilder<'a> {\n         let description = if place.projection.len() == 1 {\n@@ -288,8 +288,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn report_cannot_move_from_borrowed_content(\n         &mut self,\n-        move_place: &Place<'tcx>,\n-        deref_target_place: &Place<'tcx>,\n+        move_place: Place<'tcx>,\n+        deref_target_place: Place<'tcx>,\n         span: Span,\n         use_spans: Option<UseSpans>,\n     ) -> DiagnosticBuilder<'a> {"}, {"sha": "273878ea275c3d9b9ca543a99b5fc0af6a7548f6", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -160,13 +160,13 @@ where\n \n         match rvalue {\n             mir::Rvalue::AddressOf(mt, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, borrowed_place) {\n+                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, *borrowed_place) {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n \n             mir::Rvalue::Ref(_, kind, borrowed_place) => {\n-                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, borrowed_place) {\n+                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, *borrowed_place) {\n                     self.trans.gen(borrowed_place.local);\n                 }\n             }\n@@ -230,33 +230,33 @@ impl MutBorrow<'mir, 'tcx> {\n     /// below. See [rust-lang/unsafe-code-guidelines#134].\n     ///\n     /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n-    fn shared_borrow_allows_mutation(&self, place: &Place<'tcx>) -> bool {\n+    fn shared_borrow_allows_mutation(&self, place: Place<'tcx>) -> bool {\n         !place.ty(self.body, self.tcx).ty.is_freeze(self.tcx, self.param_env, DUMMY_SP)\n     }\n }\n \n pub trait BorrowAnalysisKind<'tcx> {\n     const ANALYSIS_NAME: &'static str;\n \n-    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool;\n-    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool;\n+    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool;\n+    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool;\n }\n \n impl BorrowAnalysisKind<'tcx> for AnyBorrow {\n     const ANALYSIS_NAME: &'static str = \"maybe_borrowed_locals\";\n \n-    fn in_ref(&self, _: mir::BorrowKind, _: &Place<'_>) -> bool {\n+    fn in_ref(&self, _: mir::BorrowKind, _: Place<'_>) -> bool {\n         true\n     }\n-    fn in_address_of(&self, _: Mutability, _: &Place<'_>) -> bool {\n+    fn in_address_of(&self, _: Mutability, _: Place<'_>) -> bool {\n         true\n     }\n }\n \n impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n     const ANALYSIS_NAME: &'static str = \"maybe_mut_borrowed_locals\";\n \n-    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool {\n+    fn in_ref(&self, kind: mir::BorrowKind, place: Place<'tcx>) -> bool {\n         match kind {\n             mir::BorrowKind::Mut { .. } => true,\n             mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n@@ -265,7 +265,7 @@ impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n         }\n     }\n \n-    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool {\n+    fn in_address_of(&self, mt: Mutability, place: Place<'tcx>) -> bool {\n         match mt {\n             Mutability::Mut => true,\n             Mutability::Not => self.shared_borrow_allows_mutation(place),"}, {"sha": "fabe575c28904e2715eda7492a6fc1da924e1abf", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -94,7 +94,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     /// problematic for borrowck.\n     ///\n     /// Maybe we should have separate \"borrowck\" and \"moveck\" modes.\n-    fn move_path_for(&mut self, place: &Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n+    fn move_path_for(&mut self, place: Place<'tcx>) -> Result<MovePathIndex, MoveError<'tcx>> {\n         debug!(\"lookup({:?})\", place);\n         let mut base = self.builder.data.rev_lookup.locals[place.local];\n \n@@ -195,7 +195,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         })\n     }\n \n-    fn create_move_path(&mut self, place: &Place<'tcx>) {\n+    fn create_move_path(&mut self, place: Place<'tcx>) {\n         // This is an non-moving access (such as an overwrite or\n         // drop), so this not being a valid move path is OK.\n         let _ = self.move_path_for(place);\n@@ -279,22 +279,22 @@ struct Gatherer<'b, 'a, 'tcx> {\n \n impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_statement(&mut self, stmt: &Statement<'tcx>) {\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rval)) => {\n-                self.create_move_path(place);\n+        match &stmt.kind {\n+            StatementKind::Assign(box (place, rval)) => {\n+                self.create_move_path(*place);\n                 if let RvalueInitializationState::Shallow = rval.initialization_state() {\n                     // Box starts out uninitialized - need to create a separate\n                     // move-path for the interior so it will be separate from\n                     // the exterior.\n-                    self.create_move_path(&self.builder.tcx.mk_place_deref(place.clone()));\n+                    self.create_move_path(self.builder.tcx.mk_place_deref(place.clone()));\n                     self.gather_init(place.as_ref(), InitKind::Shallow);\n                 } else {\n                     self.gather_init(place.as_ref(), InitKind::Deep);\n                 }\n                 self.gather_rvalue(rval);\n             }\n-            StatementKind::FakeRead(_, ref place) => {\n-                self.create_move_path(place);\n+            StatementKind::FakeRead(_, place) => {\n+                self.create_move_path(**place);\n             }\n             StatementKind::LlvmInlineAsm(ref asm) => {\n                 for (output, kind) in asm.outputs.iter().zip(&asm.asm.outputs) {\n@@ -308,7 +308,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n-                self.gather_move(&Place::from(local));\n+                self.gather_move(Place::from(*local));\n             }\n             StatementKind::SetDiscriminant { .. } => {\n                 span_bug!(\n@@ -369,7 +369,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             | TerminatorKind::Unreachable => {}\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Place::return_place());\n+                self.gather_move(Place::return_place());\n             }\n \n             TerminatorKind::Assert { ref cond, .. } => {\n@@ -380,16 +380,16 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 self.gather_operand(discr);\n             }\n \n-            TerminatorKind::Yield { ref value, resume_arg: ref place, .. } => {\n+            TerminatorKind::Yield { ref value, resume_arg: place, .. } => {\n                 self.gather_operand(value);\n                 self.create_move_path(place);\n                 self.gather_init(place.as_ref(), InitKind::Deep);\n             }\n \n-            TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n+            TerminatorKind::Drop { location, target: _, unwind: _ } => {\n                 self.gather_move(location);\n             }\n-            TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n+            TerminatorKind::DropAndReplace { location, ref value, .. } => {\n                 self.create_move_path(location);\n                 self.gather_operand(value);\n                 self.gather_init(location.as_ref(), InitKind::Deep);\n@@ -405,7 +405,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n                 for arg in args {\n                     self.gather_operand(arg);\n                 }\n-                if let Some((ref destination, _bb)) = *destination {\n+                if let Some((destination, _bb)) = *destination {\n                     self.create_move_path(destination);\n                     self.gather_init(destination.as_ref(), InitKind::NonPanicPathOnly);\n                 }\n@@ -416,14 +416,14 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n     fn gather_operand(&mut self, operand: &Operand<'tcx>) {\n         match *operand {\n             Operand::Constant(..) | Operand::Copy(..) => {} // not-a-move\n-            Operand::Move(ref place) => {\n+            Operand::Move(place) => {\n                 // a move\n                 self.gather_move(place);\n             }\n         }\n     }\n \n-    fn gather_move(&mut self, place: &Place<'tcx>) {\n+    fn gather_move(&mut self, place: Place<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", self.loc, place);\n \n         if let [ref base @ .., ProjectionElem::Subslice { from, to, from_end: false }] =\n@@ -434,7 +434,7 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             // are disjoint, which is expected by drop elaboration.\n             let base_place =\n                 Place { local: place.local, projection: self.builder.tcx.intern_place_elems(base) };\n-            let base_path = match self.move_path_for(&base_place) {\n+            let base_path = match self.move_path_for(base_place) {\n                 Ok(path) => path,\n                 Err(MoveError::UnionMove { path }) => {\n                     self.record_move(place, path);\n@@ -467,13 +467,13 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n             match self.move_path_for(place) {\n                 Ok(path) | Err(MoveError::UnionMove { path }) => self.record_move(place, path),\n                 Err(error @ MoveError::IllegalMove { .. }) => {\n-                    self.builder.errors.push((*place, error));\n+                    self.builder.errors.push((place, error));\n                 }\n             };\n         }\n     }\n \n-    fn record_move(&mut self, place: &Place<'tcx>, path: MovePathIndex) {\n+    fn record_move(&mut self, place: Place<'tcx>, path: MovePathIndex) {\n         let move_out = self.builder.data.moves.push(MoveOut { path, source: self.loc });\n         debug!(\n             \"gather_move({:?}, {:?}): adding move {:?} of {:?}\","}, {"sha": "7191198b6c0eeab89c857a0f681fbae4e75f327d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -464,7 +464,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // avoid allocations.\n     pub fn eval_place_to_op(\n         &self,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         let base_op = match place.local {\n@@ -498,7 +498,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         use rustc_middle::mir::Operand::*;\n         let op = match *mir_op {\n             // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(ref place) | Move(ref place) => self.eval_place_to_op(place, layout)?,\n+            Copy(place) | Move(place) => self.eval_place_to_op(place, layout)?,\n \n             Constant(ref constant) => {\n                 let val ="}, {"sha": "5c4915d54b0378e1ec48cfd20445ddd3e94b74e2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -635,7 +635,7 @@ where\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n         &mut self,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         let mut place_ty = match place.local {\n             mir::RETURN_PLACE => {"}, {"sha": "961b0f4d189f8140dda07a1f7e4cab555f07acd6", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -87,23 +87,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.tcx.span = stmt.source_info.span;\n         self.memory.tcx.span = stmt.source_info.span;\n \n-        match stmt.kind {\n-            Assign(box (ref place, ref rvalue)) => self.eval_rvalue_into_place(rvalue, place)?,\n+        match &stmt.kind {\n+            Assign(box (place, rvalue)) => self.eval_rvalue_into_place(rvalue, *place)?,\n \n-            SetDiscriminant { ref place, variant_index } => {\n-                let dest = self.eval_place(place)?;\n-                self.write_discriminant_index(variant_index, dest)?;\n+            SetDiscriminant { place, variant_index } => {\n+                let dest = self.eval_place(**place)?;\n+                self.write_discriminant_index(*variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.storage_live(local)?;\n+                let old_val = self.storage_live(*local)?;\n                 self.deallocate_local(old_val)?;\n             }\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.storage_dead(local);\n+                let old_val = self.storage_dead(*local);\n                 self.deallocate_local(old_val)?;\n             }\n \n@@ -112,9 +112,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             FakeRead(..) => {}\n \n             // Stacked Borrows.\n-            Retag(kind, ref place) => {\n-                let dest = self.eval_place(place)?;\n-                M::retag(self, kind, dest)?;\n+            Retag(kind, place) => {\n+                let dest = self.eval_place(**place)?;\n+                M::retag(self, *kind, dest)?;\n             }\n \n             // Statements we do not track.\n@@ -138,7 +138,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn eval_rvalue_into_place(\n         &mut self,\n         rvalue: &mir::Rvalue<'tcx>,\n-        place: &mir::Place<'tcx>,\n+        place: mir::Place<'tcx>,\n     ) -> InterpResult<'tcx> {\n         let dest = self.eval_place(place)?;\n \n@@ -224,15 +224,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n             }\n \n-            Len(ref place) => {\n+            Len(place) => {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n                 let len = mplace.len(self)?;\n                 self.write_scalar(Scalar::from_machine_usize(len, self), dest)?;\n             }\n \n-            AddressOf(_, ref place) | Ref(_, _, ref place) => {\n+            AddressOf(_, place) | Ref(_, _, place) => {\n                 let src = self.eval_place(place)?;\n                 let place = self.force_allocation(src)?;\n                 if place.layout.size.bytes() > 0 {\n@@ -261,7 +261,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.cast(src, kind, dest)?;\n             }\n \n-            Discriminant(ref place) => {\n+            Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(op)?.0;\n                 let size = dest.layout.size;"}, {"sha": "0c2aa28d8118d3bcb310004cfceab595f38f9d4d", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -51,7 +51,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.go_to_block(target_block);\n             }\n \n-            Call { ref func, ref args, ref destination, ref cleanup, .. } => {\n+            Call { ref func, ref args, destination, ref cleanup, .. } => {\n                 let func = self.eval_operand(func, None)?;\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n@@ -68,7 +68,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let args = self.eval_operands(args)?;\n                 let ret = match destination {\n-                    Some((dest, ret)) => Some((self.eval_place(dest)?, *ret)),\n+                    Some((dest, ret)) => Some((self.eval_place(dest)?, ret)),\n                     None => None,\n                 };\n                 self.eval_fn_call(\n@@ -81,7 +81,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 )?;\n             }\n \n-            Drop { ref location, target, unwind } => {\n+            Drop { location, target, unwind } => {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n                 let ty = place.layout.ty;\n@@ -328,7 +328,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n                     for local in body.args_iter() {\n-                        let dest = self.eval_place(&mir::Place::from(local))?;\n+                        let dest = self.eval_place(mir::Place::from(local))?;\n                         if Some(local) == body.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n@@ -346,7 +346,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                     // Don't forget to check the return type!\n                     if let Some((caller_ret, _)) = ret {\n-                        let callee_ret = self.eval_place(&mir::Place::return_place())?;\n+                        let callee_ret = self.eval_place(mir::Place::return_place())?;\n                         if !Self::check_argument_compat(\n                             rust_abi,\n                             caller_ret.layout,"}, {"sha": "7c46855dfd63c0b70715d2fbb8c26612c353dcc1", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -68,7 +68,7 @@ fn add_moves_for_packed_drops_patch<'tcx>(\n         let terminator = data.terminator();\n \n         match terminator.kind {\n-            TerminatorKind::Drop { ref location, .. }\n+            TerminatorKind::Drop { location, .. }\n                 if util::is_disaligned(tcx, body, param_env, location) =>\n             {\n                 add_move_for_packed_drop(tcx, body, &mut patch, terminator, loc, data.is_cleanup);"}, {"sha": "3ce9b875e16cc2861bb81c4c242ee3749833ca1b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -191,7 +191,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             let proj_base = &place.projection[..i];\n \n             if context.is_borrow() {\n-                if util::is_disaligned(self.tcx, self.body, self.param_env, place) {\n+                if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                     let source_info = self.source_info;\n                     let lint_root = self.body.source_scopes[source_info.scope]\n                         .local_data"}, {"sha": "3ee97bf8d56cf546c8c9dd3d373d480d9aaab755", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -471,15 +471,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn eval_place(&mut self, place: &Place<'tcx>) -> Option<OpTy<'tcx>> {\n+    fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n         self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n-            Operand::Move(ref place) | Operand::Copy(ref place) => self.eval_place(place),\n+            Operand::Move(place) | Operand::Copy(place) => self.eval_place(place),\n         }\n     }\n \n@@ -575,7 +575,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         rvalue: &Rvalue<'tcx>,\n         place_layout: TyAndLayout<'tcx>,\n         source_info: SourceInfo,\n-        place: &Place<'tcx>,\n+        place: Place<'tcx>,\n     ) -> Option<()> {\n         // #66397: Don't try to eval into large places as that can cause an OOM\n         if place_layout.size >= Size::from_bytes(MAX_ALLOC_LIMIT) {\n@@ -828,7 +828,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (ref place, ref mut rval)) = statement.kind {\n+        if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n             let place_ty: Ty<'tcx> = place.ty(&self.local_decls, self.tcx).ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(local) = place.as_local() {"}, {"sha": "a25b554b345eb0d6ed0b8c454f5eeb6c28cbbe6c", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -97,9 +97,8 @@ impl<'tcx> MirPass<'tcx> for CopyPropagation {\n                             if let Some(local) = place.as_local() {\n                                 if local == dest_local {\n                                     let maybe_action = match operand {\n-                                        Operand::Copy(ref src_place)\n-                                        | Operand::Move(ref src_place) => {\n-                                            Action::local_copy(&body, &def_use_analysis, src_place)\n+                                        Operand::Copy(src_place) | Operand::Move(src_place) => {\n+                                            Action::local_copy(&body, &def_use_analysis, *src_place)\n                                         }\n                                         Operand::Constant(ref src_constant) => {\n                                             Action::constant(src_constant)\n@@ -195,7 +194,7 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(\n         body: &Body<'tcx>,\n         def_use_analysis: &DefUseAnalysis,\n-        src_place: &Place<'tcx>,\n+        src_place: Place<'tcx>,\n     ) -> Option<Action<'tcx>> {\n         // The source must be a local.\n         let src_local = if let Some(local) = src_place.as_local() {"}, {"sha": "157dada831a2e2610b5d304988c00241cd8fcb5c", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -450,7 +450,7 @@ impl Inliner<'tcx> {\n                 // Place could result in two different locations if `f`\n                 // writes to `i`. To prevent this we need to create a temporary\n                 // borrow of the place and pass the destination as `*temp` instead.\n-                fn dest_needs_borrow(place: &Place<'_>) -> bool {\n+                fn dest_needs_borrow(place: Place<'_>) -> bool {\n                     for elem in place.projection.iter() {\n                         match elem {\n                             ProjectionElem::Deref | ProjectionElem::Index(_) => return true,\n@@ -461,7 +461,7 @@ impl Inliner<'tcx> {\n                     false\n                 }\n \n-                let dest = if dest_needs_borrow(&destination.0) {\n+                let dest = if dest_needs_borrow(destination.0) {\n                     debug!(\"creating temp for return destination\");\n                     let dest = Rvalue::Ref(\n                         self.tcx.lifetimes.re_erased,"}, {"sha": "c5b366ef5725179b91f59d3c89a7b54cd2f987fa", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -150,7 +150,7 @@ fn check_rvalue(\n         Rvalue::Len(place)\n         | Rvalue::Discriminant(place)\n         | Rvalue::Ref(_, _, place)\n-        | Rvalue::AddressOf(_, place) => check_place(tcx, place, span, def_id, body),\n+        | Rvalue::AddressOf(_, place) => check_place(tcx, *place, span, def_id, body),\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n@@ -215,7 +215,7 @@ fn check_statement(\n     let span = statement.source_info.span;\n     match &statement.kind {\n         StatementKind::Assign(box (place, rval)) => {\n-            check_place(tcx, place, span, def_id, body)?;\n+            check_place(tcx, *place, span, def_id, body)?;\n             check_rvalue(tcx, body, def_id, rval, span)\n         }\n \n@@ -225,10 +225,12 @@ fn check_statement(\n             Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n         }\n \n-        StatementKind::FakeRead(_, place) => check_place(tcx, place, span, def_id, body),\n+        StatementKind::FakeRead(_, place) => check_place(tcx, **place, span, def_id, body),\n \n         // just an assignment\n-        StatementKind::SetDiscriminant { place, .. } => check_place(tcx, place, span, def_id, body),\n+        StatementKind::SetDiscriminant { place, .. } => {\n+            check_place(tcx, **place, span, def_id, body)\n+        }\n \n         StatementKind::LlvmInlineAsm { .. } => {\n             Err((span, \"cannot use inline assembly in const fn\".into()))\n@@ -251,7 +253,7 @@ fn check_operand(\n     body: &Body<'tcx>,\n ) -> McfResult {\n     match operand {\n-        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, place, span, def_id, body),\n+        Operand::Move(place) | Operand::Copy(place) => check_place(tcx, *place, span, def_id, body),\n         Operand::Constant(c) => match c.check_static_ptr(tcx) {\n             Some(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n             None => Ok(()),\n@@ -261,7 +263,7 @@ fn check_operand(\n \n fn check_place(\n     tcx: TyCtxt<'tcx>,\n-    place: &Place<'tcx>,\n+    place: Place<'tcx>,\n     span: Span,\n     def_id: DefId,\n     body: &Body<'tcx>,\n@@ -330,9 +332,9 @@ fn check_terminator(\n         | TerminatorKind::Return\n         | TerminatorKind::Resume => Ok(()),\n \n-        TerminatorKind::Drop { location, .. } => check_place(tcx, location, span, def_id, body),\n+        TerminatorKind::Drop { location, .. } => check_place(tcx, *location, span, def_id, body),\n         TerminatorKind::DropAndReplace { location, value, .. } => {\n-            check_place(tcx, location, span, def_id, body)?;\n+            check_place(tcx, *location, span, def_id, body)?;\n             check_operand(tcx, value, span, def_id, body)\n         }\n "}, {"sha": "7cdd929c7a033d2faffee0093dcc77a9a9423cbd", "filename": "src/librustc_mir/transform/simplify_try.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_try.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -89,7 +89,7 @@ fn match_get_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local\n         StatementKind::Assign(box (place_into, rvalue_from)) => match rvalue_from {\n             Rvalue::Use(Operand::Copy(pf)) | Rvalue::Use(Operand::Move(pf)) => {\n                 let local_into = place_into.as_local()?;\n-                let (local_from, vf) = match_variant_field_place(&pf)?;\n+                let (local_from, vf) = match_variant_field_place(*pf)?;\n                 Some((local_into, local_from, vf))\n             }\n             _ => None,\n@@ -107,7 +107,7 @@ fn match_set_variant_field<'tcx>(stmt: &Statement<'tcx>) -> Option<(Local, Local\n         StatementKind::Assign(box (place_from, rvalue_into)) => match rvalue_into {\n             Rvalue::Use(Operand::Move(place_into)) => {\n                 let local_into = place_into.as_local()?;\n-                let (local_from, vf) = match_variant_field_place(&place_from)?;\n+                let (local_from, vf) = match_variant_field_place(*place_from)?;\n                 Some((local_into, local_from, vf))\n             }\n             _ => None,\n@@ -137,7 +137,7 @@ struct VarField<'tcx> {\n }\n \n /// Match on `((_LOCAL as Variant).FIELD: TY)`.\n-fn match_variant_field_place<'tcx>(place: &Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n+fn match_variant_field_place<'tcx>(place: Place<'tcx>) -> Option<(Local, VarField<'tcx>)> {\n     match place.as_ref() {\n         PlaceRef {\n             local,"}, {"sha": "202e5e27f1d9431be4df5a8646bd51a693c48cd4", "filename": "src/librustc_mir/util/alignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Futil%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Futil%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Falignment.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -8,7 +8,7 @@ pub fn is_disaligned<'tcx, L>(\n     tcx: TyCtxt<'tcx>,\n     local_decls: &L,\n     param_env: ty::ParamEnv<'tcx>,\n-    place: &Place<'tcx>,\n+    place: Place<'tcx>,\n ) -> bool\n where\n     L: HasLocalDecls<'tcx>,\n@@ -34,7 +34,7 @@ where\n     }\n }\n \n-fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: &Place<'tcx>) -> bool\n+fn is_within_packed<'tcx, L>(tcx: TyCtxt<'tcx>, local_decls: &L, place: Place<'tcx>) -> bool\n where\n     L: HasLocalDecls<'tcx>,\n {"}, {"sha": "f6d67abcef041c25fdf3101f371cacb0a424bd49", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/890b39381f587169c0684831ff04f9d8602ea95a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=890b39381f587169c0684831ff04f9d8602ea95a", "patch": "@@ -526,7 +526,7 @@ where\n         let discr = Place::from(self.new_temp(discr_ty));\n         let discr_rv = Rvalue::Discriminant(self.place);\n         let switch_block = BasicBlockData {\n-            statements: vec![self.assign(&discr, discr_rv)],\n+            statements: vec![self.assign(discr, discr_rv)],\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n@@ -557,7 +557,7 @@ where\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n-                &Place::from(ref_place),\n+                Place::from(ref_place),\n                 Rvalue::Ref(\n                     tcx.lifetimes.re_erased,\n                     BorrowKind::Mut { allow_two_phase_borrow: false },\n@@ -604,7 +604,7 @@ where\n         &mut self,\n         succ: BasicBlock,\n         cur: Local,\n-        length_or_end: &Place<'tcx>,\n+        length_or_end: Place<'tcx>,\n         ety: Ty<'tcx>,\n         unwind: Unwind,\n         ptr_based: bool,\n@@ -614,7 +614,7 @@ where\n         let tcx = self.tcx();\n \n         let ptr_ty = tcx.mk_ptr(ty::TypeAndMut { ty: ety, mutbl: hir::Mutability::Mut });\n-        let ptr = &Place::from(self.new_temp(ptr_ty));\n+        let ptr = Place::from(self.new_temp(ptr_ty));\n         let can_go = Place::from(self.new_temp(tcx.types.bool));\n \n         let one = self.constant_usize(1);\n@@ -628,7 +628,7 @@ where\n         };\n \n         let drop_block = BasicBlockData {\n-            statements: vec![self.assign(ptr, ptr_next), self.assign(&Place::from(cur), cur_next)],\n+            statements: vec![self.assign(ptr, ptr_next), self.assign(Place::from(cur), cur_next)],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n@@ -640,8 +640,8 @@ where\n \n         let loop_block = BasicBlockData {\n             statements: vec![self.assign(\n-                &can_go,\n-                Rvalue::BinaryOp(BinOp::Eq, copy(Place::from(cur)), copy(*length_or_end)),\n+                can_go,\n+                Rvalue::BinaryOp(BinOp::Eq, copy(Place::from(cur)), copy(length_or_end)),\n             )],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -700,9 +700,9 @@ where\n             }\n         }\n \n-        let move_ = |place: &Place<'tcx>| Operand::Move(*place);\n-        let elem_size = &Place::from(self.new_temp(tcx.types.usize));\n-        let len = &Place::from(self.new_temp(tcx.types.usize));\n+        let move_ = |place: Place<'tcx>| Operand::Move(place);\n+        let elem_size = Place::from(self.new_temp(tcx.types.usize));\n+        let len = Place::from(self.new_temp(tcx.types.usize));\n \n         static USIZE_SWITCH_ZERO: &[u128] = &[0];\n \n@@ -745,10 +745,10 @@ where\n         let length_or_end = if ptr_based { Place::from(self.new_temp(iter_ty)) } else { length };\n \n         let unwind = self.unwind.map(|unwind| {\n-            self.drop_loop(unwind, cur, &length_or_end, ety, Unwind::InCleanup, ptr_based)\n+            self.drop_loop(unwind, cur, length_or_end, ety, Unwind::InCleanup, ptr_based)\n         });\n \n-        let loop_block = self.drop_loop(self.succ, cur, &length_or_end, ety, unwind, ptr_based);\n+        let loop_block = self.drop_loop(self.succ, cur, length_or_end, ety, unwind, ptr_based);\n \n         let cur = Place::from(cur);\n         let drop_block_stmts = if ptr_based {\n@@ -758,17 +758,17 @@ where\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             vec![\n-                self.assign(&tmp, Rvalue::AddressOf(Mutability::Mut, self.place)),\n-                self.assign(&cur, Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty)),\n+                self.assign(tmp, Rvalue::AddressOf(Mutability::Mut, self.place)),\n+                self.assign(cur, Rvalue::Cast(CastKind::Misc, Operand::Move(tmp), iter_ty)),\n                 self.assign(\n-                    &length_or_end,\n+                    length_or_end,\n                     Rvalue::BinaryOp(BinOp::Offset, Operand::Copy(cur), Operand::Move(length)),\n                 ),\n             ]\n         } else {\n             // cur = 0 (length already pushed)\n             let zero = self.constant_usize(0);\n-            vec![self.assign(&cur, Rvalue::Use(zero))]\n+            vec![self.assign(cur, Rvalue::Use(zero))]\n         };\n         let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n             statements: drop_block_stmts,\n@@ -989,7 +989,7 @@ where\n         })\n     }\n \n-    fn assign(&self, lhs: &Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n-        Statement { source_info: self.source_info, kind: StatementKind::Assign(box (*lhs, rhs)) }\n+    fn assign(&self, lhs: Place<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n+        Statement { source_info: self.source_info, kind: StatementKind::Assign(box (lhs, rhs)) }\n     }\n }"}]}