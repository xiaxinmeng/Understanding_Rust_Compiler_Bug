{"sha": "ade79d760905ab589851ca9e9ab3bb583e4da7c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZTc5ZDc2MDkwNWFiNTg5ODUxY2E5ZTlhYjNiYjU4M2U0ZGE3YzQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-19T09:47:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:30:52Z"}, "message": "rustc_trans: simplify vtable and symbol handling.", "tree": {"sha": "f036ef161f4518d18e956efbabba4c452cbab865", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f036ef161f4518d18e956efbabba4c452cbab865"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ade79d760905ab589851ca9e9ab3bb583e4da7c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ade79d760905ab589851ca9e9ab3bb583e4da7c4", "html_url": "https://github.com/rust-lang/rust/commit/ade79d760905ab589851ca9e9ab3bb583e4da7c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ade79d760905ab589851ca9e9ab3bb583e4da7c4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "521d3ea19323c4c3ba18effbfee58c10b2aaf28b", "url": "https://api.github.com/repos/rust-lang/rust/commits/521d3ea19323c4c3ba18effbfee58c10b2aaf28b", "html_url": "https://github.com/rust-lang/rust/commit/521d3ea19323c4c3ba18effbfee58c10b2aaf28b"}], "stats": {"total": 554, "additions": 199, "deletions": 355}, "files": [{"sha": "7ba10d9c0a58e1140d35de18d2148993014a5191", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -40,7 +40,7 @@ pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};\n pub use self::select::{MethodMatchedData}; // intentionally don't export variants\n pub use self::specialize::{OverlapError, specialization_graph, specializes, translate_substs};\n-pub use self::specialize::{SpecializesCache};\n+pub use self::specialize::{SpecializesCache, find_method};\n pub use self::util::elaborate_predicates;\n pub use self::util::supertraits;\n pub use self::util::Supertraits;\n@@ -527,6 +527,88 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     Ok(resolved_value)\n }\n \n+/// Normalizes the predicates and checks whether they hold.  If this\n+/// returns false, then either normalize encountered an error or one\n+/// of the predicates did not hold. Used when creating vtables to\n+/// check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                               predicates: Vec<ty::Predicate<'tcx>>)\n+                                               -> bool\n+{\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n+           predicates);\n+\n+    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let cause = ObligationCause::dummy();\n+        let Normalized { value: predicates, obligations } =\n+            normalize(&mut selcx, cause.clone(), &predicates);\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+        for predicate in predicates {\n+            let obligation = Obligation::new(cause.clone(), predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+\n+        fulfill_cx.select_all_or_error(&infcx).is_ok()\n+    })\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+#[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n+pub fn get_vtable_methods<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>)\n+    -> impl Iterator<Item=Option<(DefId, &'tcx Substs<'tcx>)>> + 'a\n+{\n+    debug!(\"get_vtable_methods({:?})\", trait_ref);\n+\n+    supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+        tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n+\n+        let trait_item_def_ids = tcx.impl_or_trait_items(trait_ref.def_id());\n+        let trait_methods = (0..trait_item_def_ids.len()).filter_map(move |i| {\n+            match tcx.impl_or_trait_item(trait_item_def_ids[i]) {\n+                ty::MethodTraitItem(m) => Some(m),\n+                _ => None\n+            }\n+        });\n+\n+        // Now list each method's DefId and Substs (for within its trait).\n+        // If the method can never be called from this object, produce None.\n+        trait_methods.map(move |trait_method| {\n+            debug!(\"get_vtable_methods: trait_method={:?}\", trait_method);\n+\n+            // Some methods cannot be called on an object; skip those.\n+            if !tcx.is_vtable_safe_method(trait_ref.def_id(), &trait_method) {\n+                debug!(\"get_vtable_methods: not vtable safe\");\n+                return None;\n+            }\n+\n+            // the method may have some early-bound lifetimes, add\n+            // regions for those\n+            let substs = Substs::for_item(tcx, trait_method.def_id,\n+                                            |_, _| tcx.mk_region(ty::ReErased),\n+                                            |def, _| trait_ref.substs().type_for_def(def));\n+\n+            // It's possible that the method relies on where clauses that\n+            // do not hold for this particular set of type parameters.\n+            // Note that this method could then never be called, so we\n+            // do not want to try and trans it, in that case (see #23435).\n+            let predicates = trait_method.predicates.instantiate_own(tcx, substs);\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                debug!(\"get_vtable_methods: predicates do not hold\");\n+                return None;\n+            }\n+\n+            Some((trait_method.def_id, substs))\n+        })\n+    })\n+}\n+\n impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                trait_ref: O)"}, {"sha": "e37425901c8c8f2dd74ae0d89cc9ce127692f9e3", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -26,9 +26,11 @@ use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause, Normalized};\n-use ty::{self, TyCtxt};\n+use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n \n+use syntax::ast;\n+\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -103,6 +105,41 @@ pub fn translate_substs<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     source_substs.rebase_onto(infcx.tcx, source_impl, target_substs)\n }\n \n+/// Given a selected impl described by `impl_data`, returns the\n+/// definition and substitions for the method with the name `name`,\n+/// and trait method substitutions `substs`, in that impl, a less\n+/// specialized impl, or the trait default, whichever applies.\n+pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             name: ast::Name,\n+                             substs: &'tcx Substs<'tcx>,\n+                             impl_data: &super::VtableImplData<'tcx, ()>)\n+                             -> (DefId, &'tcx Substs<'tcx>)\n+{\n+    assert!(!substs.needs_infer());\n+\n+    let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n+    let trait_def = tcx.lookup_trait_def(trait_def_id);\n+\n+    match trait_def.ancestors(impl_data.impl_def_id).fn_defs(tcx, name).next() {\n+        Some(node_item) => {\n+            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n+                let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n+                let substs = translate_substs(&infcx, impl_data.impl_def_id,\n+                                              substs, node_item.node);\n+                tcx.lift(&substs).unwrap_or_else(|| {\n+                    bug!(\"find_method: translate_substs \\\n+                          returned {:?} which contains inference types/regions\",\n+                         substs);\n+                })\n+            });\n+            (node_item.item.def_id, substs)\n+        }\n+        None => {\n+            bug!(\"method {:?} not found in {:?}\", name, impl_data.impl_def_id)\n+        }\n+    }\n+}\n+\n /// Is impl1 a specialization of impl2?\n ///\n /// Specialization is determined by the sets of types to which the impls apply;"}, {"sha": "0a668db06908090b8a7689380bdf37ffc5da243b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -97,7 +97,7 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::{CrateContext, SharedCrateContext, gensym_name};\n+use common::SharedCrateContext;\n use monomorphize::Instance;\n use util::sha2::{Digest, Sha256};\n \n@@ -152,16 +152,17 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut hash_state = scx.symbol_hasher().borrow_mut();\n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n         hash_state.reset();\n+        let mut hasher = Sha256Hasher(&mut hash_state);\n \n-        let mut hasher = ty::util::TypeIdHasher::new(tcx, Sha256Hasher(&mut hash_state));\n         // the main symbol name is not necessarily unique; hash in the\n         // compiler's internal def-path, guaranteeing each symbol has a\n         // truly unique path\n-        hasher.hash(def_path.to_string(tcx));\n+        def_path.deterministic_hash_to(tcx, &mut hasher);\n \n         // Include the main item-type. Note that, in this case, the\n         // assertions about `needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n+        let mut hasher = ty::util::TypeIdHasher::new(tcx, hasher);\n         assert!(!item_type.has_erasable_regions());\n         hasher.visit_ty(item_type);\n \n@@ -172,18 +173,15 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             substs.visit_with(&mut hasher);\n         }\n     });\n-    fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n-        let output = symbol_hasher.result_bytes();\n-        // 64 bits should be enough to avoid collisions.\n-        output[.. 8].to_hex()\n-    }\n \n-    format!(\"h{}\", truncated_hash_result(&mut hash_state))\n+    // 64 bits should be enough to avoid collisions.\n+    let output = hash_state.result_bytes();\n+    format!(\"h{}\", output[..8].to_hex())\n }\n \n impl<'a, 'tcx> Instance<'tcx> {\n     pub fn symbol_name(self, scx: &SharedCrateContext<'a, 'tcx>) -> String {\n-        let Instance { def: def_id, ref substs } = self;\n+        let Instance { def: def_id, substs } = self;\n \n         debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n                def_id, substs);\n@@ -278,7 +276,7 @@ impl<'a, 'tcx> Instance<'tcx> {\n             scx.tcx().push_item_path(&mut buffer, def_id);\n         });\n \n-        mangle(buffer.names.into_iter(), Some(&hash[..]))\n+        mangle(buffer.names.into_iter(), &hash)\n     }\n }\n \n@@ -307,23 +305,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n     let path = [token::intern_and_get_ident(prefix)];\n-    mangle(path.iter().cloned(), Some(&hash[..]))\n-}\n-\n-/// Only symbols that are invisible outside their compilation unit should use a\n-/// name generated by this function.\n-pub fn internal_name_from_type_and_suffix<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                                    t: Ty<'tcx>,\n-                                                    suffix: &str)\n-                                                    -> String {\n-    let path = [token::intern(&t.to_string()).as_str(),\n-                gensym_name(suffix).as_str()];\n-    let def_path = DefPath {\n-        data: vec![],\n-        krate: LOCAL_CRATE,\n-    };\n-    let hash = get_symbol_hash(ccx.shared(), &def_path, t, None);\n-    mangle(path.iter().cloned(), Some(&hash[..]))\n+    mangle(path.iter().cloned(), &hash)\n }\n \n // Name sanitation. LLVM will happily accept identifiers with weird names, but\n@@ -376,7 +358,7 @@ pub fn sanitize(s: &str) -> String {\n     return result;\n }\n \n-pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -> String {\n+fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: &str) -> String {\n     // Follow C++ namespace-mangling style, see\n     // http://en.wikipedia.org/wiki/Name_mangling for more info.\n     //\n@@ -403,9 +385,7 @@ pub fn mangle<PI: Iterator<Item=InternedString>>(path: PI, hash: Option<&str>) -\n         push(&mut n, &data);\n     }\n \n-    if let Some(s) = hash {\n-        push(&mut n, s)\n-    }\n+    push(&mut n, hash);\n \n     n.push('E'); // End name-sequence.\n     n"}, {"sha": "8822287a0e754a6e66a8e53edb33aa1ee37dd61c", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -17,7 +17,6 @@\n pub use self::CalleeData::*;\n \n use arena::TypedArena;\n-use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -133,34 +132,36 @@ impl<'tcx> Callee<'tcx> {\n         let trait_ref = tcx.normalize_associated_type(&ty::Binder(trait_ref));\n         match common::fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref) {\n             traits::VtableImpl(vtable_impl) => {\n-                let impl_did = vtable_impl.impl_def_id;\n-                let mname = tcx.item_name(def_id);\n-                // create a concatenated set of substitutions which includes\n-                // those from the impl and those from the method:\n-                let mth = meth::get_impl_method(tcx, substs, impl_did, vtable_impl.substs, mname);\n+                let name = tcx.item_name(def_id);\n+                let (def_id, substs) = traits::find_method(tcx, name, substs, &vtable_impl);\n \n                 // Translate the function, bypassing Callee::def.\n                 // That is because default methods have the same ID as the\n                 // trait method used to look up the impl method that ended\n                 // up here, so calling Callee::def would infinitely recurse.\n-                let (llfn, ty) = get_fn(ccx, mth.method.def_id, mth.substs);\n+                let (llfn, ty) = get_fn(ccx, def_id, substs);\n                 Callee::ptr(llfn, ty)\n             }\n             traits::VtableClosure(vtable_closure) => {\n                 // The substitutions should have no type parameters remaining\n                 // after passing through fulfill_obligation\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+                let instance = Instance::new(def_id, substs);\n                 let llfn = closure::trans_closure_method(ccx,\n                                                          vtable_closure.closure_def_id,\n                                                          vtable_closure.substs,\n+                                                         instance,\n                                                          trait_closure_kind);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n             }\n             traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n+                let instance = Instance::new(def_id, substs);\n+                let llfn = trans_fn_pointer_shim(ccx, instance,\n+                                                 trait_closure_kind,\n+                                                 vtable_fn_pointer.fn_ty);\n \n                 let method_ty = def_ty(ccx.shared(), def_id, substs);\n                 Callee::ptr(llfn, method_ty)\n@@ -217,9 +218,7 @@ impl<'tcx> Callee<'tcx> {\n     pub fn reify<'a>(self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         match self.data {\n             Fn(llfn) => llfn,\n-            Virtual(idx) => {\n-                meth::trans_object_shim(ccx, self.ty, idx)\n-            }\n+            Virtual(_) => meth::trans_object_shim(ccx, self),\n             NamedTupleConstructor(disr) => match self.ty.sty {\n                 ty::TyFnDef(def_id, substs, _) => {\n                     let instance = Instance::new(def_id, substs);\n@@ -264,8 +263,9 @@ fn def_ty<'a, 'tcx>(shared: &SharedCrateContext<'a, 'tcx>,\n /// ```\n ///\n /// but for the bare function type given.\n-pub fn trans_fn_pointer_shim<'a, 'tcx>(\n+fn trans_fn_pointer_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n+    method_instance: Instance<'tcx>,\n     closure_kind: ty::ClosureKind,\n     bare_fn_ty: Ty<'tcx>)\n     -> ValueRef\n@@ -345,10 +345,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     debug!(\"tuple_fn_ty: {:?}\", tuple_fn_ty);\n \n     //\n-    let function_name =\n-        symbol_names::internal_name_from_type_and_suffix(ccx,\n-                                                         bare_fn_ty,\n-                                                         \"fn_pointer_shim\");\n+    let function_name = method_instance.symbol_name(ccx.shared());\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //"}, {"sha": "c0692e8085fc25ddb0b44b6a870f4b0e6ec9d430", "filename": "src/librustc_trans/closure.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fclosure.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use arena::TypedArena;\n-use back::symbol_names;\n use llvm::{self, ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use abi::{Abi, FnType};\n@@ -152,6 +151,7 @@ pub fn trans_closure_body_via_mir<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                                       closure_def_id: DefId,\n                                       substs: ty::ClosureSubsts<'tcx>,\n+                                      method_instance: Instance<'tcx>,\n                                       trait_closure_kind: ty::ClosureKind)\n                                       -> ValueRef\n {\n@@ -199,7 +199,7 @@ pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n             //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n             //\n             // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n+            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, method_instance, llfn)\n         }\n         _ => {\n             bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n@@ -213,6 +213,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n     closure_def_id: DefId,\n     substs: ty::ClosureSubsts<'tcx>,\n+    method_instance: Instance<'tcx>,\n     llreffn: ValueRef)\n     -> ValueRef\n {\n@@ -255,8 +256,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     }));\n \n     // Create the by-value helper.\n-    let function_name =\n-        symbol_names::internal_name_from_type_and_suffix(ccx, llonce_fn_ty, \"once_shim\");\n+    let function_name = method_instance.symbol_name(ccx.shared());\n     let lloncefn = declare::declare_fn(ccx, &function_name, llonce_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n "}, {"sha": "2849b384e1bd211fccd4b52344083f9bb8ea5c85", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 25, "deletions": 57, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -210,9 +210,8 @@ use errors;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n-use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n+use common::{fulfill_obligation, type_is_sized};\n use glue::{self, DropGlueKind};\n-use meth;\n use monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n@@ -899,17 +898,8 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     match vtbl {\n-        traits::VtableImpl(traits::VtableImplData {\n-            impl_def_id: impl_did,\n-            substs: impl_substs,\n-            nested: _ }) =>\n-        {\n-            let impl_method = meth::get_impl_method(tcx,\n-                                                    rcvr_substs,\n-                                                    impl_did,\n-                                                    impl_substs,\n-                                                    trait_method.name);\n-            Some((impl_method.method.def_id, &impl_method.substs))\n+        traits::VtableImpl(impl_data) => {\n+            Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n         }\n         // If we have a closure or a function pointer, we will also encounter\n         // the concrete closure/function somewhere else (during closure or fn\n@@ -1043,43 +1033,19 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n \n     if let ty::TyTrait(ref trait_ty) = trait_ty.sty {\n         let poly_trait_ref = trait_ty.principal.with_self_ty(scx.tcx(), impl_ty);\n+        let param_substs = Substs::empty(scx.tcx());\n \n         // Walk all methods of the trait, including those of its supertraits\n-        for trait_ref in traits::supertraits(scx.tcx(), poly_trait_ref) {\n-            let vtable = fulfill_obligation(scx, DUMMY_SP, trait_ref);\n-            match vtable {\n-                traits::VtableImpl(\n-                    traits::VtableImplData {\n-                        impl_def_id,\n-                        substs,\n-                        nested: _ }) => {\n-                    let items = meth::get_vtable_methods(scx.tcx(), impl_def_id, substs)\n-                        .into_iter()\n-                        // filter out None values\n-                        .filter_map(|opt_impl_method| opt_impl_method)\n-                        // create translation items\n-                        .filter_map(|impl_method| {\n-                            if can_have_local_instance(scx.tcx(), impl_method.method.def_id) {\n-                                Some(create_fn_trans_item(scx,\n-                                    impl_method.method.def_id,\n-                                    impl_method.substs,\n-                                    Substs::empty(scx.tcx())))\n-                            } else {\n-                                None\n-                            }\n-                        });\n-\n-                    output.extend(items);\n-                }\n-                _ => { /* */ }\n-            }\n-        }\n+        let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n+        let methods = methods.filter_map(|method| method)\n+            .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs, param_substs))\n+            .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+            .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n+        output.extend(methods);\n \n         // Also add the destructor\n         let dg_type = glue::get_drop_glue_type(scx.tcx(), impl_ty);\n-        if glue::type_needs_drop(scx.tcx(), dg_type) {\n-            output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n-        }\n+        output.push(TransItem::DropGlue(DropGlueKind::Ty(dg_type)));\n     }\n }\n \n@@ -1239,25 +1205,27 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                     let impl_substs = Substs::for_item(tcx, impl_def_id,\n                                                        |_, _| tcx.mk_region(ty::ReErased),\n                                                        |_, _| tcx.types.err);\n-                    let mth = meth::get_impl_method(tcx,\n-                                                    callee_substs,\n-                                                    impl_def_id,\n-                                                    impl_substs,\n-                                                    method.name);\n-\n-                    assert!(mth.is_provided);\n-\n-                    let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                    if !normalize_and_test_predicates(tcx, predicates) {\n+                    let impl_data = traits::VtableImplData {\n+                        impl_def_id: impl_def_id,\n+                        substs: impl_substs,\n+                        nested: vec![]\n+                    };\n+                    let (def_id, substs) = traits::find_method(tcx,\n+                                                               method.name,\n+                                                               callee_substs,\n+                                                               &impl_data);\n+\n+                    let predicates = tcx.lookup_predicates(def_id).predicates\n+                                        .subst(tcx, substs);\n+                    if !traits::normalize_and_test_predicates(tcx, predicates) {\n                         continue;\n                     }\n \n                     if can_have_local_instance(tcx, method.def_id) {\n-                        let empty_substs = tcx.erase_regions(&mth.substs);\n                         let item = create_fn_trans_item(scx,\n                                                         method.def_id,\n                                                         callee_substs,\n-                                                        empty_substs);\n+                                                        tcx.erase_regions(&substs));\n                         output.push(item);\n                     }\n                 }"}, {"sha": "db1a541919036087616d1329873093d873d1f2f4", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -150,15 +150,6 @@ pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n     llsize_of_alloc(ccx, llty) == 0\n }\n \n-/// Generates a unique symbol based off the name given. This is used to create\n-/// unique symbols for things like closures.\n-pub fn gensym_name(name: &str) -> ast::Name {\n-    let num = token::gensym(name).0;\n-    // use one colon which will get translated to a period by the mangler, and\n-    // we're guaranteed that `num` is globally unique for this crate.\n-    token::gensym(&format!(\"{}:{}\", name, num))\n-}\n-\n /*\n * A note on nomenclature of linking: \"extern\", \"foreign\", and \"upcall\".\n *\n@@ -1002,35 +993,6 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     })\n }\n \n-/// Normalizes the predicates and checks whether they hold.  If this\n-/// returns false, then either normalize encountered an error or one\n-/// of the predicates did not hold. Used when creating vtables to\n-/// check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                               predicates: Vec<ty::Predicate<'tcx>>)\n-                                               -> bool\n-{\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\",\n-           predicates);\n-\n-    tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let cause = traits::ObligationCause::dummy();\n-        let traits::Normalized { value: predicates, obligations } =\n-            traits::normalize(&mut selcx, cause.clone(), &predicates);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-        for predicate in predicates {\n-            let obligation = traits::Obligation::new(cause.clone(), predicate);\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-\n-        fulfill_cx.select_all_or_error(&infcx).is_ok()\n-    })\n-}\n-\n pub fn langcall(tcx: TyCtxt,\n                 span: Option<Span>,\n                 msg: &str,"}, {"sha": "e8dcaf71f2dd2fc9d053ca6934aa9b6fc9dcee5b", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 24, "deletions": 206, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ade79d760905ab589851ca9e9ab3bb583e4da7c4/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=ade79d760905ab589851ca9e9ab3bb583e4da7c4", "patch": "@@ -8,33 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::rc::Rc;\n-\n use attributes;\n use arena::TypedArena;\n-use back::symbol_names;\n use llvm::{ValueRef, get_params};\n-use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::{Subst, Substs};\n-use rustc::traits::{self, Reveal};\n+use rustc::traits;\n use abi::FnType;\n use base::*;\n use build::*;\n-use callee::{Callee, Virtual, trans_fn_pointer_shim};\n-use closure;\n+use callee::Callee;\n use common::*;\n use consts;\n use debuginfo::DebugLoc;\n use declare;\n use glue;\n use machine;\n+use monomorphize::Instance;\n use type_::Type;\n use type_of::*;\n use value::Value;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-\n-use syntax::ast::Name;\n-use syntax_pos::DUMMY_SP;\n+use rustc::ty;\n \n // drop_glue pointer, size, align.\n const VTABLE_OFFSET: usize = 3;\n@@ -73,23 +65,26 @@ pub fn get_virtual_method<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// In fact, all virtual calls can be thought of as normal trait calls\n /// that go through this shim function.\n pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n-                                   method_ty: Ty<'tcx>,\n-                                   vtable_index: usize)\n+                                   callee: Callee<'tcx>)\n                                    -> ValueRef {\n     let _icx = push_ctxt(\"trans_object_shim\");\n     let tcx = ccx.tcx();\n \n-    debug!(\"trans_object_shim(vtable_index={}, method_ty={:?})\",\n-           vtable_index,\n-           method_ty);\n+    debug!(\"trans_object_shim({:?})\", callee);\n+\n+    let (sig, abi, function_name) = match callee.ty.sty {\n+        ty::TyFnDef(def_id, substs, f) => {\n+            let instance = Instance::new(def_id, substs);\n+            (&f.sig, f.abi, instance.symbol_name(ccx.shared()))\n+        }\n+        _ => bug!()\n+    };\n \n-    let sig = tcx.erase_late_bound_regions(&method_ty.fn_sig());\n+    let sig = tcx.erase_late_bound_regions(sig);\n     let sig = tcx.normalize_associated_type(&sig);\n-    let fn_ty = FnType::new(ccx, method_ty.fn_abi(), &sig, &[]);\n+    let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let function_name =\n-        symbol_names::internal_name_from_type_and_suffix(ccx, method_ty, \"object_shim\");\n-    let llfn = declare::define_internal_fn(ccx, &function_name, method_ty);\n+    let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -98,16 +93,7 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let mut bcx = fcx.init(false);\n \n     let dest = fcx.llretslotptr.get();\n-\n-    debug!(\"trans_object_shim: method_offset_in_vtable={}\",\n-           vtable_index);\n-\n     let llargs = get_params(fcx.llfn);\n-\n-    let callee = Callee {\n-        data: Virtual(vtable_index),\n-        ty: method_ty\n-    };\n     bcx = callee.call(bcx, DebugLoc::None,\n                       &llargs[fcx.fn_ty.ret.is_indirect() as usize..], dest).bcx;\n \n@@ -140,72 +126,23 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     // Not in the cache. Build it.\n-    let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n-        let vtable = fulfill_obligation(ccx.shared(), DUMMY_SP, trait_ref.clone());\n-        match vtable {\n-            // Should default trait error here?\n-            traits::VtableDefaultImpl(_) |\n-            traits::VtableBuiltin(_) => {\n-                Vec::new().into_iter()\n-            }\n-            traits::VtableImpl(\n-                traits::VtableImplData {\n-                    impl_def_id: id,\n-                    substs,\n-                    nested: _ }) => {\n-                let nullptr = C_null(Type::nil(ccx).ptr_to());\n-                get_vtable_methods(tcx, id, substs)\n-                    .into_iter()\n-                    .map(|opt_mth| opt_mth.map_or(nullptr, |mth| {\n-                        Callee::def(ccx, mth.method.def_id, &mth.substs).reify(ccx)\n-                    }))\n-                    .collect::<Vec<_>>()\n-                    .into_iter()\n-            }\n-            traits::VtableClosure(\n-                traits::VtableClosureData {\n-                    closure_def_id,\n-                    substs,\n-                    nested: _ }) => {\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n-                let llfn = closure::trans_closure_method(ccx,\n-                                                         closure_def_id,\n-                                                         substs,\n-                                                         trait_closure_kind);\n-                vec![llfn].into_iter()\n-            }\n-            traits::VtableFnPointer(\n-                traits::VtableFnPointerData {\n-                    fn_ty: bare_fn_ty,\n-                    nested: _ }) => {\n-                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n-                vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n-            }\n-            traits::VtableObject(ref data) => {\n-                // this would imply that the Self type being erased is\n-                // an object type; this cannot happen because we\n-                // cannot cast an unsized type into a trait object\n-                bug!(\"cannot get vtable for an object type: {:?}\",\n-                     data);\n-            }\n-            traits::VtableParam(..) => {\n-                bug!(\"resolved vtable for {:?} to bad vtable {:?} in trans\",\n-                     trait_ref,\n-                     vtable);\n-            }\n-        }\n+    let nullptr = C_null(Type::nil(ccx).ptr_to());\n+    let methods = traits::get_vtable_methods(tcx, trait_ref).map(|opt_mth| {\n+        opt_mth.map_or(nullptr, |(def_id, substs)| {\n+            Callee::def(ccx, def_id, substs).reify(ccx)\n+        })\n     });\n \n     let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n     let align = align_of(ccx, trait_ref.self_ty());\n \n-    let components: Vec<_> = vec![\n+    let components: Vec<_> = [\n         // Generate a destructor for the vtable.\n         glue::get_drop_glue(ccx, trait_ref.self_ty()),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n-    ].into_iter().chain(methods).collect();\n+    ].iter().cloned().chain(methods).collect();\n \n     let vtable_const = C_struct(ccx, &components, false);\n     let align = machine::llalign_of_pref(ccx, val_ty(vtable_const));\n@@ -214,122 +151,3 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable\n }\n-\n-pub fn get_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                    impl_id: DefId,\n-                                    substs: &'tcx Substs<'tcx>)\n-                                    -> Vec<Option<ImplMethod<'tcx>>>\n-{\n-    debug!(\"get_vtable_methods(impl_id={:?}, substs={:?}\", impl_id, substs);\n-\n-    let trait_id = match tcx.impl_trait_ref(impl_id) {\n-        Some(t_id) => t_id.def_id,\n-        None       => bug!(\"make_impl_vtable: don't know how to \\\n-                            make a vtable for a type impl!\")\n-    };\n-\n-    tcx.populate_implementations_for_trait_if_necessary(trait_id);\n-\n-    let trait_item_def_ids = tcx.impl_or_trait_items(trait_id);\n-    trait_item_def_ids\n-        .iter()\n-\n-        // Filter out non-method items.\n-        .filter_map(|&item_def_id| {\n-            match tcx.impl_or_trait_item(item_def_id) {\n-                ty::MethodTraitItem(m) => Some(m),\n-                _ => None\n-            }\n-        })\n-\n-        // Now produce pointers for each remaining method. If the\n-        // method could never be called from this object, just supply\n-        // null.\n-        .map(|trait_method_type| {\n-            debug!(\"get_vtable_methods: trait_method_def_id={:?}\",\n-                   trait_method_type.def_id);\n-\n-            let name = trait_method_type.name;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !tcx.is_vtable_safe_method(trait_id, &trait_method_type) {\n-                debug!(\"get_vtable_methods: not vtable safe\");\n-                return None;\n-            }\n-\n-            debug!(\"get_vtable_methods: trait_method_type={:?}\",\n-                   trait_method_type);\n-\n-            // the method may have some early-bound lifetimes, add\n-            // regions for those\n-            let method_substs = Substs::for_item(tcx, trait_method_type.def_id,\n-                                                 |_, _| tcx.mk_region(ty::ReErased),\n-                                                 |_, _| tcx.types.err);\n-\n-            // The substitutions we have are on the impl, so we grab\n-            // the method type from the impl to substitute into.\n-            let mth = get_impl_method(tcx, method_substs, impl_id, substs, name);\n-\n-            debug!(\"get_vtable_methods: mth={:?}\", mth);\n-\n-            // If this is a default method, it's possible that it\n-            // relies on where clauses that do not hold for this\n-            // particular set of type parameters. Note that this\n-            // method could then never be called, so we do not want to\n-            // try and trans it, in that case. Issue #23435.\n-            if mth.is_provided {\n-                let predicates = mth.method.predicates.predicates.subst(tcx, &mth.substs);\n-                if !normalize_and_test_predicates(tcx, predicates) {\n-                    debug!(\"get_vtable_methods: predicates do not hold\");\n-                    return None;\n-                }\n-            }\n-\n-            Some(mth)\n-        })\n-        .collect()\n-}\n-\n-#[derive(Debug)]\n-pub struct ImplMethod<'tcx> {\n-    pub method: Rc<ty::Method<'tcx>>,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub is_provided: bool\n-}\n-\n-/// Locates the applicable definition of a method, given its name.\n-pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                 substs: &'tcx Substs<'tcx>,\n-                                 impl_def_id: DefId,\n-                                 impl_substs: &'tcx Substs<'tcx>,\n-                                 name: Name)\n-                                 -> ImplMethod<'tcx>\n-{\n-    assert!(!substs.needs_infer());\n-\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-    let trait_def = tcx.lookup_trait_def(trait_def_id);\n-\n-    match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n-        Some(node_item) => {\n-            let substs = tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n-                let substs = substs.rebase_onto(tcx, trait_def_id, impl_substs);\n-                let substs = traits::translate_substs(&infcx, impl_def_id,\n-                                                      substs, node_item.node);\n-                tcx.lift(&substs).unwrap_or_else(|| {\n-                    bug!(\"trans::meth::get_impl_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs);\n-                })\n-            });\n-            ImplMethod {\n-                method: node_item.item,\n-                substs: substs,\n-                is_provided: node_item.node.is_from_trait(),\n-            }\n-        }\n-        None => {\n-            bug!(\"method {:?} not found in {:?}\", name, impl_def_id)\n-        }\n-    }\n-}"}]}