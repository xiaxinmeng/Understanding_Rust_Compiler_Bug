{"sha": "a501e6699ed979ef0540949211fc28256336a3f3", "node_id": "C_kwDOAAsO6NoAKGE1MDFlNjY5OWVkOTc5ZWYwNTQwOTQ5MjExZmMyODI1NjMzNmEzZjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T23:15:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-16T23:15:20Z"}, "message": "Auto merge of #103125 - matthiaskrgr:rollup-82xttcl, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #103087 (Documentation BTreeMap::append's behavior for already existing keys)\n - #103089 (Mark derived StructuralEq as automatically derived.)\n - #103102 (Clarify the possible return values of `len_utf16`)\n - #103109 (PhantomData: inline a macro that is used only once)\n - #103120 (rustdoc: Do not expect `doc(primitive)` modules to always exist)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "a876bc7366a5e4ee6029ced4131ef49699c57f4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a876bc7366a5e4ee6029ced4131ef49699c57f4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a501e6699ed979ef0540949211fc28256336a3f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a501e6699ed979ef0540949211fc28256336a3f3", "html_url": "https://github.com/rust-lang/rust/commit/a501e6699ed979ef0540949211fc28256336a3f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a501e6699ed979ef0540949211fc28256336a3f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8b5caee04116c7383eb1c6470fcf15c437a60d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b5caee04116c7383eb1c6470fcf15c437a60d4", "html_url": "https://github.com/rust-lang/rust/commit/b8b5caee04116c7383eb1c6470fcf15c437a60d4"}, {"sha": "db30a2578155472212fa81fd870c2b0506c7ecf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/db30a2578155472212fa81fd870c2b0506c7ecf0", "html_url": "https://github.com/rust-lang/rust/commit/db30a2578155472212fa81fd870c2b0506c7ecf0"}], "stats": {"total": 253, "additions": 156, "deletions": 97}, "files": [{"sha": "ee346047a0bc0c2fb54b7ef50bedd1f9e8ac2a01", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -131,23 +131,27 @@ fn inject_impl_of_structural_trait(\n     // Create generics param list for where clauses and impl headers\n     let mut generics = generics.clone();\n \n+    let ctxt = span.ctxt();\n+\n     // Create the type of `self`.\n     //\n     // in addition, remove defaults from generic params (impls cannot have them).\n     let self_params: Vec<_> = generics\n         .params\n         .iter_mut()\n         .map(|param| match &mut param.kind {\n-            ast::GenericParamKind::Lifetime => {\n-                ast::GenericArg::Lifetime(cx.lifetime(span, param.ident))\n-            }\n+            ast::GenericParamKind::Lifetime => ast::GenericArg::Lifetime(\n+                cx.lifetime(param.ident.span.with_ctxt(ctxt), param.ident),\n+            ),\n             ast::GenericParamKind::Type { default } => {\n                 *default = None;\n-                ast::GenericArg::Type(cx.ty_ident(span, param.ident))\n+                ast::GenericArg::Type(cx.ty_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n             }\n             ast::GenericParamKind::Const { ty: _, kw_span: _, default } => {\n                 *default = None;\n-                ast::GenericArg::Const(cx.const_ident(span, param.ident))\n+                ast::GenericArg::Const(\n+                    cx.const_ident(param.ident.span.with_ctxt(ctxt), param.ident),\n+                )\n             }\n         })\n         .collect();\n@@ -174,6 +178,8 @@ fn inject_impl_of_structural_trait(\n             })\n             .cloned(),\n     );\n+    // Mark as `automatically_derived` to avoid some silly lints.\n+    attrs.push(cx.attribute(cx.meta_word(span, sym::automatically_derived)));\n \n     let newitem = cx.item(\n         span,"}, {"sha": "c4c75e46a2a3b687574c14327e129332c54f40c0", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -1093,6 +1093,9 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n \n     /// Moves all elements from `other` into `self`, leaving `other` empty.\n     ///\n+    /// If a key from `other` is already present in `self`, the respective\n+    /// value from `self` will be overwritten with the respective value from `other`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1101,10 +1104,10 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     /// let mut a = BTreeMap::new();\n     /// a.insert(1, \"a\");\n     /// a.insert(2, \"b\");\n-    /// a.insert(3, \"c\");\n+    /// a.insert(3, \"c\"); // Note: Key (3) also present in b.\n     ///\n     /// let mut b = BTreeMap::new();\n-    /// b.insert(3, \"d\");\n+    /// b.insert(3, \"d\"); // Note: Key (3) also present in a.\n     /// b.insert(4, \"e\");\n     /// b.insert(5, \"f\");\n     ///\n@@ -1115,7 +1118,7 @@ impl<K, V, A: Allocator + Clone> BTreeMap<K, V, A> {\n     ///\n     /// assert_eq!(a[&1], \"a\");\n     /// assert_eq!(a[&2], \"b\");\n-    /// assert_eq!(a[&3], \"d\");\n+    /// assert_eq!(a[&3], \"d\"); // Note: \"c\" has been overwritten.\n     /// assert_eq!(a[&4], \"e\");\n     /// assert_eq!(a[&5], \"f\");\n     /// ```"}, {"sha": "bb83599369c135787e85bf92fb9c0330f20d4fed", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -597,9 +597,14 @@ impl char {\n     /// Returns the number of 16-bit code units this `char` would need if\n     /// encoded in UTF-16.\n     ///\n+    /// That number of code units is always either 1 or 2, for unicode scalar values in\n+    /// the [basic multilingual plane] or [supplementary planes] respectively.\n+    ///\n     /// See the documentation for [`len_utf8()`] for more explanation of this\n     /// concept. This function is a mirror, but for UTF-16 instead of UTF-8.\n     ///\n+    /// [basic multilingual plane]: http://www.unicode.org/glossary/#basic_multilingual_plane\n+    /// [supplementary planes]: http://www.unicode.org/glossary/#supplementary_planes\n     /// [`len_utf8()`]: #method.len_utf8\n     ///\n     /// # Examples"}, {"sha": "c43c4fff6ae776228fc1f277f6e50978db2c6b9a", "filename": "library/core/src/marker.rs", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/library%2Fcore%2Fsrc%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/library%2Fcore%2Fsrc%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmarker.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -483,64 +483,6 @@ impl<T: ?Sized> !Sync for *const T {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> !Sync for *mut T {}\n \n-macro_rules! impls {\n-    ($t: ident) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> Hash for $t<T> {\n-            #[inline]\n-            fn hash<H: Hasher>(&self, _: &mut H) {}\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> cmp::PartialEq for $t<T> {\n-            fn eq(&self, _other: &$t<T>) -> bool {\n-                true\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> cmp::Eq for $t<T> {}\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> cmp::PartialOrd for $t<T> {\n-            fn partial_cmp(&self, _other: &$t<T>) -> Option<cmp::Ordering> {\n-                Option::Some(cmp::Ordering::Equal)\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> cmp::Ord for $t<T> {\n-            fn cmp(&self, _other: &$t<T>) -> cmp::Ordering {\n-                cmp::Ordering::Equal\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> Copy for $t<T> {}\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<T: ?Sized> Clone for $t<T> {\n-            fn clone(&self) -> Self {\n-                Self\n-            }\n-        }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-        impl<T: ?Sized> const Default for $t<T> {\n-            fn default() -> Self {\n-                Self\n-            }\n-        }\n-\n-        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n-        impl<T: ?Sized> StructuralPartialEq for $t<T> {}\n-\n-        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n-        impl<T: ?Sized> StructuralEq for $t<T> {}\n-    };\n-}\n-\n /// Zero-sized type used to mark things that \"act like\" they own a `T`.\n ///\n /// Adding a `PhantomData<T>` field to your type tells the compiler that your\n@@ -678,7 +620,59 @@ macro_rules! impls {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T: ?Sized>;\n \n-impls! { PhantomData }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Hash for PhantomData<T> {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, _: &mut H) {}\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> cmp::PartialEq for PhantomData<T> {\n+    fn eq(&self, _other: &PhantomData<T>) -> bool {\n+        true\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> cmp::Eq for PhantomData<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> cmp::PartialOrd for PhantomData<T> {\n+    fn partial_cmp(&self, _other: &PhantomData<T>) -> Option<cmp::Ordering> {\n+        Option::Some(cmp::Ordering::Equal)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> cmp::Ord for PhantomData<T> {\n+    fn cmp(&self, _other: &PhantomData<T>) -> cmp::Ordering {\n+        cmp::Ordering::Equal\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Copy for PhantomData<T> {}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized> Clone for PhantomData<T> {\n+    fn clone(&self) -> Self {\n+        Self\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n+impl<T: ?Sized> const Default for PhantomData<T> {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+impl<T: ?Sized> StructuralPartialEq for PhantomData<T> {}\n+\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+impl<T: ?Sized> StructuralEq for PhantomData<T> {}\n \n mod impls {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "3513c13d522f1e06bf245ac2eee9b2ad37fdb8a4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -80,10 +80,10 @@ impl Res {\n         }\n     }\n \n-    fn def_id(self, tcx: TyCtxt<'_>) -> DefId {\n+    fn def_id(self, tcx: TyCtxt<'_>) -> Option<DefId> {\n         match self {\n-            Res::Def(_, id) => id,\n-            Res::Primitive(prim) => *PrimitiveType::primitive_locations(tcx).get(&prim).unwrap(),\n+            Res::Def(_, id) => Some(id),\n+            Res::Primitive(prim) => PrimitiveType::primitive_locations(tcx).get(&prim).copied(),\n         }\n     }\n \n@@ -1127,10 +1127,10 @@ impl LinkCollector<'_, '_> {\n                     }\n                 }\n \n-                Some(ItemLink {\n+                res.def_id(self.cx.tcx).map(|page_id| ItemLink {\n                     link: ori_link.link.clone(),\n                     link_text: link_text.clone(),\n-                    page_id: res.def_id(self.cx.tcx),\n+                    page_id,\n                     fragment,\n                 })\n             }"}, {"sha": "50dc26d768cd2e3c8e70535f224979efb05f89b8", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -48,7 +48,6 @@ pub(crate) fn early_resolve_intra_doc_links(\n     link_resolver.resolve_doc_links_local(&krate.attrs);\n     link_resolver.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n     visit::walk_crate(&mut link_resolver, krate);\n-    link_resolver.process_extern_impls();\n \n     // FIXME: somehow rustdoc is still missing crates even though we loaded all\n     // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n@@ -58,6 +57,8 @@ pub(crate) fn early_resolve_intra_doc_links(\n         link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, parent_scope);\n     }\n \n+    link_resolver.process_extern_impls();\n+\n     ResolverCaches {\n         markdown_links: Some(link_resolver.markdown_links),\n         doc_link_resolutions: link_resolver.doc_link_resolutions,"}, {"sha": "e5eba1d8d48b41884039aaf2bfcee5a5b69acac3", "filename": "src/test/rustdoc/intra-doc/no-doc-primitive.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/src%2Ftest%2Frustdoc%2Fintra-doc%2Fno-doc-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/src%2Ftest%2Frustdoc%2Fintra-doc%2Fno-doc-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fno-doc-primitive.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -0,0 +1,15 @@\n+// Crate tree without a `doc(primitive)` module for primitive type linked to by a doc link.\n+\n+#![deny(rustdoc::broken_intra_doc_links)]\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+#![rustc_coherence_is_core]\n+#![crate_type = \"rlib\"]\n+\n+// @has no_doc_primitive/index.html\n+//! A [`char`] and its [`char::len_utf8`].\n+impl char {\n+    pub fn len_utf8(self) -> usize {\n+        42\n+    }\n+}"}, {"sha": "258ef8ba91dffed8c70ed88d69b77c2e80478571", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -46,13 +46,15 @@ impl ::core::default::Default for Empty {\n impl ::core::hash::Hash for Empty {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n-impl ::core::marker::StructuralPartialEq for Empty {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Empty { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Empty {\n     #[inline]\n     fn eq(&self, other: &Empty) -> bool { true }\n }\n-impl ::core::marker::StructuralEq for Empty {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Empty { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Empty {\n     #[inline]\n@@ -115,15 +117,17 @@ impl ::core::hash::Hash for Point {\n         ::core::hash::Hash::hash(&self.y, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Point {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Point { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Point {\n     #[inline]\n     fn eq(&self, other: &Point) -> bool {\n         self.x == other.x && self.y == other.y\n     }\n }\n-impl ::core::marker::StructuralEq for Point {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Point { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Point {\n     #[inline]\n@@ -225,7 +229,8 @@ impl ::core::hash::Hash for Big {\n         ::core::hash::Hash::hash(&self.b8, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Big {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Big { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Big {\n     #[inline]\n@@ -236,7 +241,8 @@ impl ::core::cmp::PartialEq for Big {\n             self.b8 == other.b8\n     }\n }\n-impl ::core::marker::StructuralEq for Big {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Big { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Big {\n     #[inline]\n@@ -345,13 +351,15 @@ impl ::core::hash::Hash for Unsized {\n         ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Unsized {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Unsized { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Unsized {\n     #[inline]\n     fn eq(&self, other: &Unsized) -> bool { self.0 == other.0 }\n }\n-impl ::core::marker::StructuralEq for Unsized {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Unsized { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Unsized {\n     #[inline]\n@@ -410,13 +418,15 @@ impl ::core::hash::Hash for PackedCopy {\n         ::core::hash::Hash::hash(&{ self.0 }, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for PackedCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for PackedCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedCopy {\n     #[inline]\n     fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n }\n-impl ::core::marker::StructuralEq for PackedCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for PackedCopy { }\n #[automatically_derived]\n impl ::core::cmp::Eq for PackedCopy {\n     #[inline]\n@@ -479,7 +489,8 @@ impl ::core::hash::Hash for PackedNonCopy {\n         ::core::hash::Hash::hash(__self_0_0, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for PackedNonCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n@@ -489,7 +500,8 @@ impl ::core::cmp::PartialEq for PackedNonCopy {\n         *__self_0_0 == *__self_1_0\n     }\n }\n-impl ::core::marker::StructuralEq for PackedNonCopy {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for PackedNonCopy { }\n #[automatically_derived]\n impl ::core::cmp::Eq for PackedNonCopy {\n     #[inline]\n@@ -540,15 +552,17 @@ impl ::core::hash::Hash for Enum0 {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Enum0 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Enum0 { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Enum0 {\n     #[inline]\n     fn eq(&self, other: &Enum0) -> bool {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n-impl ::core::marker::StructuralEq for Enum0 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Enum0 { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Enum0 {\n     #[inline]\n@@ -607,7 +621,8 @@ impl ::core::hash::Hash for Enum1 {\n         }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Enum1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Enum1 { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Enum1 {\n     #[inline]\n@@ -618,7 +633,8 @@ impl ::core::cmp::PartialEq for Enum1 {\n         }\n     }\n }\n-impl ::core::marker::StructuralEq for Enum1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Enum1 { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Enum1 {\n     #[inline]\n@@ -676,13 +692,15 @@ impl ::core::default::Default for Fieldless1 {\n impl ::core::hash::Hash for Fieldless1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n-impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Fieldless1 { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Fieldless1 {\n     #[inline]\n     fn eq(&self, other: &Fieldless1) -> bool { true }\n }\n-impl ::core::marker::StructuralEq for Fieldless1 {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Fieldless1 { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Fieldless1 {\n     #[inline]\n@@ -743,7 +761,8 @@ impl ::core::hash::Hash for Fieldless {\n         ::core::hash::Hash::hash(&__self_tag, state)\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Fieldless {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Fieldless { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n@@ -753,7 +772,8 @@ impl ::core::cmp::PartialEq for Fieldless {\n         __self_tag == __arg1_tag\n     }\n }\n-impl ::core::marker::StructuralEq for Fieldless {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Fieldless { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Fieldless {\n     #[inline]\n@@ -838,7 +858,8 @@ impl ::core::hash::Hash for Mixed {\n         }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Mixed {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Mixed { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n@@ -856,7 +877,8 @@ impl ::core::cmp::PartialEq for Mixed {\n             }\n     }\n }\n-impl ::core::marker::StructuralEq for Mixed {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Mixed { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Mixed {\n     #[inline]\n@@ -963,7 +985,8 @@ impl ::core::hash::Hash for Fielded {\n         }\n     }\n }\n-impl ::core::marker::StructuralPartialEq for Fielded {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralPartialEq for Fielded { }\n #[automatically_derived]\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n@@ -982,7 +1005,8 @@ impl ::core::cmp::PartialEq for Fielded {\n             }\n     }\n }\n-impl ::core::marker::StructuralEq for Fielded {}\n+#[automatically_derived]\n+impl ::core::marker::StructuralEq for Fielded { }\n #[automatically_derived]\n impl ::core::cmp::Eq for Fielded {\n     #[inline]"}, {"sha": "e5bdfc55dd670d318928ee4a7768d9b188455b81", "filename": "src/test/ui/single-use-lifetime/derive-eq.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a501e6699ed979ef0540949211fc28256336a3f3/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fderive-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a501e6699ed979ef0540949211fc28256336a3f3/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fderive-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-use-lifetime%2Fderive-eq.rs?ref=a501e6699ed979ef0540949211fc28256336a3f3", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+\n+#![deny(single_use_lifetimes)]\n+\n+#[derive(PartialEq, Eq)]\n+struct Foo<'a, T> {\n+    /// a reference to the underlying secret data that will be derefed\n+    pub data: &'a mut T,\n+}\n+\n+fn main() {}"}]}