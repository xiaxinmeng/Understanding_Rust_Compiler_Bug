{"sha": "ce0a6043f55ed20b827f55174da99aa517e916e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlMGE2MDQzZjU1ZWQyMGI4MjdmNTUxNzRkYTk5YWE1MTdlOTE2ZTE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2018-03-13T16:12:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-13T16:12:52Z"}, "message": "Merge pull request #2524 from rust-lang-nursery/update_dependencies\n\nUpdate dependencies", "tree": {"sha": "cb65380f3a4035ebbbd47bfe61f742b8a0ce42a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb65380f3a4035ebbbd47bfe61f742b8a0ce42a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce0a6043f55ed20b827f55174da99aa517e916e1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJap/iECRBK7hj4Ov3rIwAAdHIIACedSOmnNVL1ZoT9xzQjnSKb\nXXuJWkpugBSj83Chnv3jcTf4G8iErJqGrmAfAsXwgsuEJcsekGZuvAxa6nEUN0LT\nvylH4iay6glbMRXKvYJIZnFIXnhAYYtV08tcGDci+AxIaq55+mU01Ce8Emyb/crk\n8lxEXhxo7NdN1fW7AIO+xQw9RhftHdjKUxxJx8CpjF0F7SxVUARGpUakBR6fXrvo\nmvkDBc6BTvUIxJBIzyaBJSVXQul7xeMN+4lMc9hQzCkhNxTMknmeqybW1RVW3eXY\ne0zD7YoKKraWHMCQYml+SttzkbxvEQY6TX9UdPiGNlmHs86B7jyoX3EuX3CnIA8=\n=vkVb\n-----END PGP SIGNATURE-----\n", "payload": "tree cb65380f3a4035ebbbd47bfe61f742b8a0ce42a7\nparent 5296c523079b8e5fefe5e4bdec26cf88892b0873\nparent 21f387d27810edd4ec135cc307dccc6d8e55d48b\nauthor llogiq <bogusandre@gmail.com> 1520957572 +0000\ncommitter GitHub <noreply@github.com> 1520957572 +0000\n\nMerge pull request #2524 from rust-lang-nursery/update_dependencies\n\nUpdate dependencies"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0a6043f55ed20b827f55174da99aa517e916e1", "html_url": "https://github.com/rust-lang/rust/commit/ce0a6043f55ed20b827f55174da99aa517e916e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce0a6043f55ed20b827f55174da99aa517e916e1/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5296c523079b8e5fefe5e4bdec26cf88892b0873", "url": "https://api.github.com/repos/rust-lang/rust/commits/5296c523079b8e5fefe5e4bdec26cf88892b0873", "html_url": "https://github.com/rust-lang/rust/commit/5296c523079b8e5fefe5e4bdec26cf88892b0873"}, {"sha": "21f387d27810edd4ec135cc307dccc6d8e55d48b", "url": "https://api.github.com/repos/rust-lang/rust/commits/21f387d27810edd4ec135cc307dccc6d8e55d48b", "html_url": "https://github.com/rust-lang/rust/commit/21f387d27810edd4ec135cc307dccc6d8e55d48b"}], "stats": {"total": 201, "additions": 123, "deletions": 78}, "files": [{"sha": "6f472c418d22ea3a771d3c3c520480f3292a4acf", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -16,6 +16,7 @@ out\n Cargo.lock\n /target\n /clippy_lints/target\n+/clippy_workspace_tests/target\n \n # Generated by dogfood\n /target_recur/"}, {"sha": "a256be6085b0037636c413cbd217029d7742659f", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -39,8 +39,9 @@ path = \"src/driver.rs\"\n # begin automatic update\n clippy_lints = { version = \"0.0.187\", path = \"clippy_lints\" }\n # end automatic update\n-cargo_metadata = \"0.2\"\n+cargo_metadata = \"0.5\"\n regex = \"0.2\"\n+semver = \"0.9\"\n \n [dev-dependencies]\n compiletest_rs = \"0.3.7\""}, {"sha": "f8c93c9d7edb0755354e8fb916aad229025d9771", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -16,18 +16,18 @@ license = \"MPL-2.0\"\n keywords = [\"clippy\", \"lint\", \"plugin\"]\n \n [dependencies]\n-itertools = \"0.6.0\"\n+itertools = \"0.7\"\n lazy_static = \"1.0\"\n matches = \"0.1.2\"\n quine-mc_cluskey = \"0.2.2\"\n-regex-syntax = \"0.4.0\"\n-semver = \"0.6.0\"\n+regex-syntax = \"0.5.0\"\n+semver = \"0.9.0\"\n serde = \"1.0\"\n serde_derive = \"1.0\"\n toml = \"0.4\"\n unicode-normalization = \"0.1\"\n-pulldown-cmark = \"0.0.15\"\n-url = \"1.5.0\"\n+pulldown-cmark = \"0.1\"\n+url = \"1.7.0\"\n if_chain = \"0.1\"\n \n [features]"}, {"sha": "f2c08944f5011aa81454d20be91fb2394582fd1b", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -6,7 +6,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use rustc::ty::subst::Substs;\n use std::collections::HashSet;\n-use std::error::Error;\n use syntax::ast::{LitKind, NodeId, StrStyle};\n use syntax::codemap::{BytePos, Span};\n use syntax::symbol::InternedString;\n@@ -134,16 +133,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-#[allow(cast_possible_truncation)]\n-fn str_span(base: Span, s: &str, c: usize) -> Span {\n-    let mut si = s.char_indices().skip(c);\n-\n-    match (si.next(), si.next()) {\n-        (Some((l, _)), Some((h, _))) => {\n-            Span::new(base.lo() + BytePos(l as u32), base.lo() + BytePos(h as u32), base.ctxt())\n-        },\n-        _ => base,\n-    }\n+fn str_span(base: Span, c: regex_syntax::ast::Span, offset: usize) -> Span {\n+    let offset = offset as u32;\n+    let end = base.lo() + BytePos(c.end.offset as u32 + offset);\n+    let start = base.lo() + BytePos(c.start.offset as u32 + offset);\n+    assert!(start <= end);\n+    Span::new(start, end, base.ctxt())\n }\n \n fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<InternedString> {\n@@ -159,24 +154,30 @@ fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<Inte\n     }\n }\n \n-fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n-    use regex_syntax::Expr;\n-\n-    match *s {\n-        Expr::Empty | Expr::StartText | Expr::EndText => Some(\"the regex is unlikely to be useful as it is\"),\n-        Expr::Literal { .. } => Some(\"consider using `str::contains`\"),\n-        Expr::Concat(ref exprs) => match exprs.len() {\n-            2 => match (&exprs[0], &exprs[1]) {\n-                (&Expr::StartText, &Expr::EndText) => Some(\"consider using `str::is_empty`\"),\n-                (&Expr::StartText, &Expr::Literal { .. }) => Some(\"consider using `str::starts_with`\"),\n-                (&Expr::Literal { .. }, &Expr::EndText) => Some(\"consider using `str::ends_with`\"),\n-                _ => None,\n-            },\n-            3 => if let (&Expr::StartText, &Expr::Literal { .. }, &Expr::EndText) = (&exprs[0], &exprs[1], &exprs[2]) {\n-                Some(\"consider using `==` on `str`s\")\n-            } else {\n-                None\n-            },\n+fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n+    use regex_syntax::hir::HirKind::*;\n+    use regex_syntax::hir::Anchor::*;\n+\n+    let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| match *e.kind() {\n+        Literal(_) => true,\n+        _ => false,\n+    });\n+\n+    match *s.kind() {\n+        Empty |\n+        Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),\n+        Literal(_) => Some(\"consider using `str::contains`\"),\n+        Alternation(ref exprs) => if exprs.iter().all(|e| e.kind().is_empty()) {\n+            Some(\"the regex is unlikely to be useful as it is\")\n+        } else {\n+            None\n+        },\n+        Concat(ref exprs) => match (exprs[0].kind(), exprs[exprs.len() - 1].kind()) {\n+            (&Anchor(StartText), &Anchor(EndText)) if exprs[1..(exprs.len() - 1)].is_empty() => Some(\"consider using `str::is_empty`\"),\n+            (&Anchor(StartText), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => Some(\"consider using `==` on `str`s\"),\n+            (&Anchor(StartText), &Literal(_)) if is_literal(&exprs[1..]) => Some(\"consider using `str::starts_with`\"),\n+            (&Literal(_), &Anchor(EndText)) if is_literal(&exprs[1..(exprs.len() - 1)]) => Some(\"consider using `str::ends_with`\"),\n+            _ if is_literal(exprs) => Some(\"consider using `str::contains`\"),\n             _ => None,\n         },\n         _ => None,\n@@ -196,49 +197,81 @@ fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool)\n }\n \n fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n-    let builder = regex_syntax::ExprBuilder::new().unicode(utf8);\n+    let mut parser = regex_syntax::ParserBuilder::new().unicode(utf8).build();\n \n     if let ExprLit(ref lit) = expr.node {\n         if let LitKind::Str(ref r, style) = lit.node {\n             let r = &r.as_str();\n-            let offset = if let StrStyle::Raw(n) = style { 1 + n } else { 0 };\n-            match builder.parse(r) {\n+            let offset = if let StrStyle::Raw(n) = style { 2 + n } else { 1 };\n+            match parser.parse(r) {\n                 Ok(r) => if let Some(repl) = is_trivial_regex(&r) {\n                     span_help_and_lint(\n                         cx,\n                         TRIVIAL_REGEX,\n                         expr.span,\n                         \"trivial regex\",\n-                        &format!(\"consider using {}\", repl),\n+                        repl,\n+                    );\n+                },\n+                Err(regex_syntax::Error::Parse(e)) => {\n+                    span_lint(\n+                        cx,\n+                        INVALID_REGEX,\n+                        str_span(expr.span, *e.span(), offset),\n+                        &format!(\"regex syntax error: {}\", e.kind()),\n+                    );\n+                },\n+                Err(regex_syntax::Error::Translate(e)) => {\n+                    span_lint(\n+                        cx,\n+                        INVALID_REGEX,\n+                        str_span(expr.span, *e.span(), offset),\n+                        &format!(\"regex syntax error: {}\", e.kind()),\n                     );\n                 },\n                 Err(e) => {\n                     span_lint(\n                         cx,\n                         INVALID_REGEX,\n-                        str_span(expr.span, r, e.position() + offset),\n-                        &format!(\"regex syntax error: {}\", e.description()),\n+                        expr.span,\n+                        &format!(\"regex syntax error: {}\", e),\n                     );\n                 },\n             }\n         }\n     } else if let Some(r) = const_str(cx, expr) {\n-        match builder.parse(&r) {\n+        match parser.parse(&r) {\n             Ok(r) => if let Some(repl) = is_trivial_regex(&r) {\n                 span_help_and_lint(\n                     cx,\n                     TRIVIAL_REGEX,\n                     expr.span,\n                     \"trivial regex\",\n-                    &format!(\"consider using {}\", repl),\n+                    repl,\n+                );\n+            },\n+            Err(regex_syntax::Error::Parse(e)) => {\n+                span_lint(\n+                    cx,\n+                    INVALID_REGEX,\n+                    expr.span,\n+                    &format!(\"regex syntax error on position {}: {}\", e.span().start.offset, e.kind()),\n+                );\n+            },\n+            Err(regex_syntax::Error::Translate(e)) => {\n+                span_lint(\n+                    cx,\n+                    INVALID_REGEX,\n+                    expr.span,\n+                    &format!(\"regex syntax error on position {}: {}\", e.span().start.offset, e.kind()),\n                 );\n             },\n             Err(e) => {\n                 span_lint(\n                     cx,\n                     INVALID_REGEX,\n                     expr.span,\n-                    &format!(\"regex syntax error on position {}: {}\", e.position(), e.description()),\n+                    &format!(\"regex syntax error: {}\", e),\n                 );\n             },\n         }"}, {"sha": "ab2b3b9a4a0306fd8b466cfb736285f6aa5c6c36", "filename": "src/main.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -9,7 +9,7 @@ use std::io::{self, Write};\n \n extern crate cargo_metadata;\n \n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n \n const CARGO_CLIPPY_HELP: &str = r#\"Checks a package to catch common mistakes and improve your Rust code.\n \n@@ -61,17 +61,19 @@ pub fn main() {\n \n     let manifest_path_arg = std::env::args()\n         .skip(2)\n-        .find(|val| val.starts_with(\"--manifest-path=\"));\n+        .find(|val| val.starts_with(\"--manifest-path=\"))\n+        .map(|val| val[\"--manifest-path=\".len()..].to_owned());\n \n     let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n         metadata\n     } else {\n+        println!(\"{:?}\", cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)));\n         let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));\n         process::exit(101);\n     };\n \n     let manifest_path = manifest_path_arg.map(|arg| {\n-        Path::new(&arg[\"--manifest-path=\".len()..])\n+        PathBuf::from(arg)\n             .canonicalize()\n             .expect(\"manifest path could not be canonicalized\")\n     });"}, {"sha": "5e059084da81b2ce15284452e619e719e5a9ef9c", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -68,7 +68,7 @@ fn run_mode(dir: &'static str, mode: &'static str) {\n fn prepare_env() {\n     set_var(\"CLIPPY_DISABLE_DOCS_LINKS\", \"true\");\n     set_var(\"CLIPPY_TESTS\", \"true\");\n-    set_var(\"RUST_BACKTRACE\", \"0\");\n+    //set_var(\"RUST_BACKTRACE\", \"0\");\n }\n \n #[test]"}, {"sha": "45b2b7a228018b4295d67896eefa43084ce45aa6", "filename": "tests/ui/regex.stderr", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/tests%2Fui%2Fregex.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/tests%2Fui%2Fregex.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fregex.stderr?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -1,60 +1,67 @@\n-error: regex syntax error: empty alternate\n+error: trivial regex\n   --> $DIR/regex.rs:16:45\n    |\n 16 |     let pipe_in_wrong_position = Regex::new(\"|\");\n    |                                             ^^^\n    |\n-   = note: `-D invalid-regex` implied by `-D warnings`\n+   = note: `-D trivial-regex` implied by `-D warnings`\n+   = help: the regex is unlikely to be useful as it is\n \n-error: regex syntax error: empty alternate\n+error: trivial regex\n   --> $DIR/regex.rs:17:60\n    |\n 17 |     let pipe_in_wrong_position_builder = RegexBuilder::new(\"|\");\n    |                                                            ^^^\n+   |\n+   = help: the regex is unlikely to be useful as it is\n \n-error: regex syntax error: invalid character class range\n-  --> $DIR/regex.rs:18:40\n+error: regex syntax error: invalid character class range, the start must be <= the end\n+  --> $DIR/regex.rs:18:42\n    |\n 18 |     let wrong_char_ranice = Regex::new(\"[z-a]\");\n-   |                                        ^^^^^^^\n+   |                                          ^^^\n+   |\n+   = note: `-D invalid-regex` implied by `-D warnings`\n \n-error: regex syntax error: invalid character class range\n-  --> $DIR/regex.rs:19:35\n+error: regex syntax error: invalid character class range, the start must be <= the end\n+  --> $DIR/regex.rs:19:37\n    |\n 19 |     let some_unicode = Regex::new(\"[\u00e9-\u00e8]\");\n-   |                                   ^^^^^^^\n+   |                                     ^^^\n \n-error: regex syntax error on position 0: unclosed parenthesis\n+error: regex syntax error on position 0: unclosed group\n   --> $DIR/regex.rs:21:33\n    |\n 21 |     let some_regex = Regex::new(OPENING_PAREN);\n    |                                 ^^^^^^^^^^^^^\n \n-error: regex syntax error: empty alternate\n+error: trivial regex\n   --> $DIR/regex.rs:23:53\n    |\n 23 |     let binary_pipe_in_wrong_position = BRegex::new(\"|\");\n    |                                                     ^^^\n+   |\n+   = help: the regex is unlikely to be useful as it is\n \n-error: regex syntax error on position 0: unclosed parenthesis\n+error: regex syntax error on position 0: unclosed group\n   --> $DIR/regex.rs:24:41\n    |\n 24 |     let some_binary_regex = BRegex::new(OPENING_PAREN);\n    |                                         ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed parenthesis\n+error: regex syntax error on position 0: unclosed group\n   --> $DIR/regex.rs:25:56\n    |\n 25 |     let some_binary_regex_builder = BRegexBuilder::new(OPENING_PAREN);\n    |                                                        ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed parenthesis\n+error: regex syntax error on position 0: unclosed group\n   --> $DIR/regex.rs:40:9\n    |\n 40 |         OPENING_PAREN,\n    |         ^^^^^^^^^^^^^\n \n-error: regex syntax error on position 0: unclosed parenthesis\n+error: regex syntax error on position 0: unclosed group\n   --> $DIR/regex.rs:44:9\n    |\n 44 |         OPENING_PAREN,\n@@ -64,102 +71,101 @@ error: regex syntax error: unrecognized escape sequence\n   --> $DIR/regex.rs:48:45\n    |\n 48 |     let raw_string_error = Regex::new(r\"[...//...]\");\n-   |                                             ^\n+   |                                             ^^\n \n error: regex syntax error: unrecognized escape sequence\n   --> $DIR/regex.rs:49:46\n    |\n 49 |     let raw_string_error = Regex::new(r#\"[...//...]\"#);\n-   |                                              ^\n+   |                                              ^^\n \n error: trivial regex\n   --> $DIR/regex.rs:53:33\n    |\n 53 |     let trivial_eq = Regex::new(\"^foobar$\");\n    |                                 ^^^^^^^^^^\n    |\n-   = note: `-D trivial-regex` implied by `-D warnings`\n-   = help: consider using consider using `==` on `str`s\n+   = help: consider using `==` on `str`s\n \n error: trivial regex\n   --> $DIR/regex.rs:55:48\n    |\n 55 |     let trivial_eq_builder = RegexBuilder::new(\"^foobar$\");\n    |                                                ^^^^^^^^^^\n    |\n-   = help: consider using consider using `==` on `str`s\n+   = help: consider using `==` on `str`s\n \n error: trivial regex\n   --> $DIR/regex.rs:57:42\n    |\n 57 |     let trivial_starts_with = Regex::new(\"^foobar\");\n    |                                          ^^^^^^^^^\n    |\n-   = help: consider using consider using `str::starts_with`\n+   = help: consider using `str::starts_with`\n \n error: trivial regex\n   --> $DIR/regex.rs:59:40\n    |\n 59 |     let trivial_ends_with = Regex::new(\"foobar$\");\n    |                                        ^^^^^^^^^\n    |\n-   = help: consider using consider using `str::ends_with`\n+   = help: consider using `str::ends_with`\n \n error: trivial regex\n   --> $DIR/regex.rs:61:39\n    |\n 61 |     let trivial_contains = Regex::new(\"foobar\");\n    |                                       ^^^^^^^^\n    |\n-   = help: consider using consider using `str::contains`\n+   = help: consider using `str::contains`\n \n error: trivial regex\n   --> $DIR/regex.rs:63:39\n    |\n 63 |     let trivial_contains = Regex::new(NOT_A_REAL_REGEX);\n    |                                       ^^^^^^^^^^^^^^^^\n    |\n-   = help: consider using consider using `str::contains`\n+   = help: consider using `str::contains`\n \n error: trivial regex\n   --> $DIR/regex.rs:65:40\n    |\n 65 |     let trivial_backslash = Regex::new(\"a/.b\");\n    |                                        ^^^^^^^\n    |\n-   = help: consider using consider using `str::contains`\n+   = help: consider using `str::contains`\n \n error: trivial regex\n   --> $DIR/regex.rs:68:36\n    |\n 68 |     let trivial_empty = Regex::new(\"\");\n    |                                    ^^\n    |\n-   = help: consider using the regex is unlikely to be useful as it is\n+   = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n   --> $DIR/regex.rs:70:36\n    |\n 70 |     let trivial_empty = Regex::new(\"^\");\n    |                                    ^^^\n    |\n-   = help: consider using the regex is unlikely to be useful as it is\n+   = help: the regex is unlikely to be useful as it is\n \n error: trivial regex\n   --> $DIR/regex.rs:72:36\n    |\n 72 |     let trivial_empty = Regex::new(\"^$\");\n    |                                    ^^^^\n    |\n-   = help: consider using consider using `str::is_empty`\n+   = help: consider using `str::is_empty`\n \n error: trivial regex\n   --> $DIR/regex.rs:74:44\n    |\n 74 |     let binary_trivial_empty = BRegex::new(\"^$\");\n    |                                            ^^^^\n    |\n-   = help: consider using consider using `str::is_empty`\n+   = help: consider using `str::is_empty`\n \n error: aborting due to 23 previous errors\n "}, {"sha": "6fe82ac792e7f584917bdb454dadbcbcef8e5529", "filename": "tests/versioncheck.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce0a6043f55ed20b827f55174da99aa517e916e1/tests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce0a6043f55ed20b827f55174da99aa517e916e1/tests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fversioncheck.rs?ref=ce0a6043f55ed20b827f55174da99aa517e916e1", "patch": "@@ -1,4 +1,6 @@\n extern crate cargo_metadata;\n+extern crate semver;\n+use semver::VersionReq;\n \n #[test]\n fn check_that_clippy_lints_has_the_same_version_as_clippy() {\n@@ -8,7 +10,7 @@ fn check_that_clippy_lints_has_the_same_version_as_clippy() {\n     assert_eq!(clippy_lints_meta.packages[0].version, clippy_meta.packages[0].version);\n     for package in &clippy_meta.packages[0].dependencies {\n         if package.name == \"clippy_lints\" {\n-            assert_eq!(clippy_lints_meta.packages[0].version, package.req[1..]);\n+            assert_eq!(VersionReq::parse(&clippy_lints_meta.packages[0].version).unwrap(), package.req);\n             return;\n         }\n     }"}]}