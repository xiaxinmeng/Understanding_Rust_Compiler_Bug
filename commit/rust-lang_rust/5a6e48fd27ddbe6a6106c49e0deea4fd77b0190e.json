{"sha": "5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNmU0OGZkMjdkZGJlNmE2MTA2YzQ5ZTBkZWVhNGZkNzdiMDE5MGU=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2017-06-04T22:35:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-04T22:35:25Z"}, "message": "Merge pull request #1808 from messense/feature/try-fix-nightly\n\nTry to fix compilation error on rustc 1.19.0-nightly 4ed2edaaf", "tree": {"sha": "2ebbcc60f31c8243e18008fd4c9fe0848d5bddb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ebbcc60f31c8243e18008fd4c9fe0848d5bddb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "html_url": "https://github.com/rust-lang/rust/commit/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "892cc2833c63a4c3ed2df82c99d200f6fb9f11c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/892cc2833c63a4c3ed2df82c99d200f6fb9f11c2", "html_url": "https://github.com/rust-lang/rust/commit/892cc2833c63a4c3ed2df82c99d200f6fb9f11c2"}, {"sha": "5b4e7b56df62b60025d6c04fa52bc85ccfe5135e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4e7b56df62b60025d6c04fa52bc85ccfe5135e", "html_url": "https://github.com/rust-lang/rust/commit/5b4e7b56df62b60025d6c04fa52bc85ccfe5135e"}], "stats": {"total": 300, "additions": 152, "deletions": 148}, "files": [{"sha": "e66e0019782545531173b9012bd0cc9f8bf5342c", "filename": "CHANGELOG.md", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -1,25 +1,28 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n-## 0.0.136 - 2017-05-26\n+## 0.0.137 \u2014 2017-06-05\n+* Update to *rustc 1.19.0-nightly (6684d176c 2017-06-03)*\n+\n+## 0.0.136 \u2014 2017\u201405\u201426\n * Update to *rustc 1.19.0-nightly (557967766 2017-05-26)*\n \n-## 0.0.135 - 2017-05-24\n+## 0.0.135 \u2014 2017\u201405\u201424\n * Update to *rustc 1.19.0-nightly (5b13bff52 2017-05-23)*\n \n-## 0.0.134 - 2017-05-19\n+## 0.0.134 \u2014 2017\u201405\u201419\n * Update to *rustc 1.19.0-nightly (0ed1ec9f9 2017-05-18)*\n \n-## 0.0.133 - 2017-05-14\n+## 0.0.133 \u2014 2017\u201405\u201414\n * Update to *rustc 1.19.0-nightly (826d8f385 2017-05-13)*\n \n-## 0.0.132 - 2017-05-05\n+## 0.0.132 \u2014 2017\u201405\u201405\n * Fix various bugs and some ices\n \n-## 0.0.131 - 2017-05-04\n+## 0.0.131 \u2014 2017\u201405\u201404\n * Update to *rustc 1.19.0-nightly (2d4ed8e0c 2017-05-03)*\n \n-## 0.0.130 - 2017-05-03\n+## 0.0.130 \u2014 2017\u201405\u201403\n * Update to *rustc 1.19.0-nightly (6a5fc9eec 2017-05-02)*\n \n ## 0.0.129 \u2014 2017-05-01"}, {"sha": "1f50085c62498f071eb325466b42cf69fa80090f", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.136\"\n+version = \"0.0.137\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -31,7 +31,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.136\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.137\", path = \"clippy_lints\" }\n # end automatic update\n cargo_metadata = \"0.2\"\n "}, {"sha": "4901b662045bf81ffcfec7d779773a91a1c06ae6", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.136\"\n+version = \"0.0.137\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "8d18e613e134bffe7dd0aedbb1ac0b76fa1c82eb", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -286,9 +286,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         match def {\n             Def::Const(def_id) |\n             Def::AssociatedConst(def_id) => {\n-                let substs = self.tables\n-                    .node_id_item_substs(id)\n-                    .unwrap_or_else(|| self.tcx.intern_substs(&[]));\n+                let substs = self.tables.node_substs(id);\n                 let substs = if self.substs.is_empty() {\n                     substs\n                 } else {"}, {"sha": "6f073478027ac45ccb1c6aa950073dac1abf5a19", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 34, "deletions": 63, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -5,8 +5,6 @@ use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n use rustc::ty;\n-use rustc::ty::layout::TargetDataLayout;\n-use rustc::traits::Reveal;\n use rustc::util::nodemap::NodeSet;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n@@ -46,8 +44,7 @@ fn is_non_trait_box(ty: ty::Ty) -> bool {\n struct EscapeDelegate<'a, 'tcx: 'a> {\n     set: NodeSet,\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n-    target: TargetDataLayout,\n+    param_env: ty::ParamEnv<'tcx>,\n     too_large_for_stack: u64,\n }\n \n@@ -67,23 +64,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         _: Span,\n         node_id: NodeId\n     ) {\n-        // we store the infcx because it is expensive to recreate\n-        // the context each time.\n+        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n+        let param_env = cx.tcx.param_env(fn_def_id).reveal_all();\n         let mut v = EscapeDelegate {\n             set: NodeSet(),\n             tcx: cx.tcx,\n-            tables: cx.tables,\n-            target: TargetDataLayout::parse(cx.sess()),\n+            param_env: param_env,\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n-        let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n-        let fn_def_id = cx.tcx.hir.local_def_id(node_id);\n-        let region_maps = &cx.tcx.region_maps(fn_def_id);\n-        {\n-            let mut vis = ExprUseVisitor::new(&mut v, region_maps, &infcx);\n+        cx.tcx.infer_ctxt(body.id()).enter(|infcx| {\n+            let region_maps = &cx.tcx.region_maps(fn_def_id);\n+            let mut vis = ExprUseVisitor::new(&mut v, region_maps, &infcx, param_env);\n             vis.consume_body(body);\n-        }\n+        });\n \n         for node in v.set {\n             span_lint(cx,\n@@ -94,14 +88,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n+impl<'a, 'gcx: 'tcx, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'gcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n         if let Categorization::Local(lid) = cmt.cat {\n-            if self.set.contains(&lid) {\n-                if let Move(DirectRefMove) = mode {\n-                    // moved out or in. clearly can't be localized\n-                    self.set.remove(&lid);\n-                }\n+            if let Move(DirectRefMove) = mode {\n+                // moved out or in. clearly can't be localized\n+                self.set.remove(&lid);\n             }\n         }\n     }\n@@ -149,49 +141,30 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     }\n     fn borrow(\n         &mut self,\n-        borrow_id: NodeId,\n+        _: NodeId,\n         _: Span,\n         cmt: cmt<'tcx>,\n         _: ty::Region,\n         _: ty::BorrowKind,\n         loan_cause: LoanCause\n     ) {\n-        use rustc::ty::adjustment::Adjust;\n-\n         if let Categorization::Local(lid) = cmt.cat {\n-            if self.set.contains(&lid) {\n-                if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n-                    self.tables\n-                        .adjustments\n-                        .get(&borrow_id)\n-                        .map(|a| &a.kind) {\n-                    if LoanCause::AutoRef == loan_cause {\n-                        // x.foo()\n-                        if autoderefs == 0 {\n-                            self.set.remove(&lid); // Used without autodereffing (i.e. x.clone())\n-                        }\n-                    } else {\n-                        span_bug!(cmt.span, \"Unknown adjusted AutoRef\");\n-                    }\n-                } else if LoanCause::AddrOf == loan_cause {\n-                    // &x\n-                    if let Some(&Adjust::DerefRef { autoderefs, .. }) =\n-                        self.tables\n-                            .adjustments\n-                            .get(&self.tcx\n-                                .hir\n-                                .get_parent_node(borrow_id))\n-                            .map(|a| &a.kind) {\n-                        if autoderefs <= 1 {\n-                            // foo(&x) where no extra autoreffing is happening\n-                            self.set.remove(&lid);\n-                        }\n-                    }\n+            match loan_cause {\n+                // x.foo()\n+                // Used without autodereffing (i.e. x.clone())\n+                LoanCause::AutoRef |\n \n-                } else if LoanCause::MatchDiscriminant == loan_cause {\n-                    self.set.remove(&lid); // `match x` can move\n+                // &x\n+                // foo(&x) where no extra autoreffing is happening\n+                LoanCause::AddrOf |\n+\n+                // `match x` can move\n+                LoanCause::MatchDiscriminant => {\n+                    self.set.remove(&lid);\n                 }\n+\n                 // do nothing for matches, etc. These can't escape\n+                _ => {}\n             }\n         }\n     }\n@@ -200,19 +173,17 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n }\n \n impl<'a, 'tcx: 'a> EscapeDelegate<'a, 'tcx> {\n-    fn is_large_box(&self, ty: ty::Ty<'tcx>) -> bool {\n+    fn is_large_box(&self, ty: ty::Ty) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows.\n         if ty.is_box() {\n-            let inner = ty.boxed_ty();\n-            self.tcx.infer_ctxt((), Reveal::All).enter(|infcx| if let Ok(layout) = inner.layout(&infcx) {\n-                let size = layout.size(&self.target);\n-                size.bytes() > self.too_large_for_stack\n-            } else {\n-                false\n-            })\n-        } else {\n-            false\n+            if let Some(inner) = self.tcx.lift(&ty.boxed_ty()) {\n+                if let Ok(layout) = inner.layout(self.tcx, self.param_env) {\n+                    return layout.size(self.tcx).bytes() > self.too_large_for_stack;\n+                }\n+            }\n         }\n+\n+        false\n     }\n }"}, {"sha": "36cae6968d444e12095ab889c704634cdb0be5e3", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -137,11 +137,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n                 }\n             },\n             ExprMethodCall(..) => {\n-                let method_call = ty::MethodCall::expr(e.id);\n                 let borrowed_table = self.cx.tables;\n-                let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n-                let result_ty = method_type.ty.fn_ret();\n-                if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&result_ty).sty {\n+                if borrowed_table.expr_ty(e).is_never() {\n                     self.report_diverging_sub_expr(e);\n                 }\n             },"}, {"sha": "463358c99b4672d8f00765cc8f28033e5d0e9738", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -1,6 +1,5 @@\n use rustc::hir::intravisit;\n use rustc::hir;\n-use rustc::ty;\n use rustc::lint::*;\n use std::collections::HashSet;\n use syntax::ast;\n@@ -184,8 +183,8 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                 }\n             },\n             hir::ExprMethodCall(_, _, ref args) => {\n-                let method_call = ty::MethodCall::expr(expr.id);\n-                let base_type = self.cx.tables.method_map[&method_call].ty;\n+                let def_id = self.cx.tables.type_dependent_defs[&expr.id].def_id();\n+                let base_type = self.cx.tcx.type_of(def_id);\n \n                 if type_is_unsafe_function(base_type) {\n                     for arg in args {"}, {"sha": "611987ae163013d5bcefd949401f650366ece4a0", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -95,7 +95,7 @@ fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]\n             {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n                 let impl_ty = cx.tcx.type_of(did);\n-                impl_ty.fn_args().skip_binder().len() == 1\n+                impl_ty.fn_sig().inputs().skip_binder().len() == 1\n             }\n         } else {\n             false\n@@ -122,7 +122,7 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItemRef]) {\n             {\n                 let did = cx.tcx.hir.local_def_id(item.id.node_id);\n                 let impl_ty = cx.tcx.type_of(did);\n-                impl_ty.fn_args().skip_binder().len() == 1\n+                impl_ty.fn_sig().inputs().skip_binder().len() == 1\n             }\n         } else {\n             false"}, {"sha": "606399af547fb806f58ad6c2c761cea36bef36e4", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -8,6 +8,7 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n use rustc::ty;\n+use rustc::ty::subst::Subst;\n use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n use syntax::ast;\n@@ -676,13 +677,11 @@ fn check_for_loop_arg(cx: &LateContext, pat: &Pat, arg: &Expr, expr: &Expr) {\n                     lint_iter_method(cx, args, arg, &method_name);\n                 }\n             } else if method_name == \"into_iter\" && match_trait_method(cx, arg, &paths::INTO_ITERATOR) {\n-                let method_call = ty::MethodCall::expr(arg.id);\n-                let fn_ty = cx.tables\n-                    .method_map\n-                    .get(&method_call)\n-                    .map(|method_callee| method_callee.ty)\n-                    .expect(\"method calls need an entry in the method map\");\n-                let fn_arg_tys = fn_ty.fn_args();\n+                let def_id = cx.tables.type_dependent_defs[&arg.id].def_id();\n+                let substs = cx.tables.node_substs(arg.id);\n+                let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n+\n+                let fn_arg_tys = method_type.fn_sig().inputs();\n                 assert_eq!(fn_arg_tys.skip_binder().len(), 1);\n                 if fn_arg_tys.skip_binder()[0].is_region_ptr() {\n                     lint_iter_method(cx, args, arg, &method_name);"}, {"sha": "781398470b868b491d54c32e2e135640a4e9be8d", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -1,5 +1,6 @@\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n+use rustc::ty::{TypeAndMut, TypeVariants, TyS};\n+use rustc::ty::subst::Subst;\n use rustc::hir::*;\n use utils::span_lint;\n \n@@ -34,24 +35,20 @@ impl LintPass for UnnecessaryMutPassed {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        let borrowed_table = cx.tables;\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n-                let function_type = borrowed_table.node_types\n-                    .get(&fn_expr.id)\n-                    .expect(\"A function with an unknown type is called. If this happened, the compiler would have \\\n-                             aborted the compilation long ago\");\n                 if let ExprPath(ref path) = fn_expr.node {\n                     check_arguments(cx,\n                                     arguments,\n-                                    function_type,\n+                                    cx.tables.expr_ty(fn_expr),\n                                     &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n                 }\n             },\n             ExprMethodCall(ref name, _, ref arguments) => {\n-                let method_call = MethodCall::expr(e.id);\n-                let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n-                check_arguments(cx, arguments, method_type.ty, &name.node.as_str())\n+                let def_id = cx.tables.type_dependent_defs[&e.id].def_id();\n+                let substs = cx.tables.node_substs(e.id);\n+                let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);\n+                check_arguments(cx, arguments, method_type, &name.node.as_str())\n             },\n             _ => (),\n         }\n@@ -71,7 +68,7 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n                             span_lint(cx,\n                                       UNNECESSARY_MUT_PASSED,\n                                       argument.span,\n-                                      &format!(\"The function/method \\\"{}\\\" doesn't need a mutable reference\", name));\n+                                      &format!(\"The function/method `{}` doesn't need a mutable reference\", name));\n                         }\n                     },\n                     _ => (),"}, {"sha": "c1965be2c04893a7a55be35ebc3c68a82e0c97a5", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -5,6 +5,7 @@\n use rustc::lint::*;\n use rustc::hir::{ExprAddrOf, Expr, MutImmutable, Pat, PatKind, BindingMode};\n use rustc::ty;\n+use rustc::ty::adjustment::{Adjustment, Adjust};\n use utils::{span_lint, in_macro};\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n@@ -41,9 +42,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         }\n         if let ExprAddrOf(MutImmutable, ref inner) = e.node {\n             if let ty::TyRef(..) = cx.tables.expr_ty(inner).sty {\n-                if let Some(&ty::adjustment::Adjust::DerefRef { autoderefs, autoref, .. }) =\n-                    cx.tables.adjustments.get(&e.id).map(|a| &a.kind) {\n-                    if autoderefs > 1 && autoref.is_some() {\n+                for adj3 in cx.tables.expr_adjustments(e).windows(3) {\n+                    if let [\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Deref(_), .. },\n+                        Adjustment { kind: Adjust::Borrow(_), .. }\n+                    ] = *adj3 {\n                         span_lint(cx,\n                                   NEEDLESS_BORROW,\n                                   e.span,"}, {"sha": "2ce22b8c9c9a94e387dee574b8657cb2b8ddba3d", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -91,12 +91,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         // Collect moved variables and spans which will need dereferencings from the function body.\n         let MovedVariablesCtxt { moved_vars, spans_need_deref, .. } = {\n             let mut ctx = MovedVariablesCtxt::new(cx);\n-            let infcx = cx.tcx.borrowck_fake_infer_ctxt(body.id());\n-            let region_maps = &cx.tcx.region_maps(fn_def_id);\n-            {\n-                let mut v = euv::ExprUseVisitor::new(&mut ctx, region_maps, &infcx);\n-                v.consume_body(body);\n-            }\n+            cx.tcx.infer_ctxt(body.id()).enter(|infcx| {\n+                let param_env = cx.tcx.param_env(fn_def_id);\n+                let region_maps = &cx.tcx.region_maps(fn_def_id);\n+                euv::ExprUseVisitor::new(&mut ctx, region_maps, &infcx, param_env)\n+                    .consume_body(body);\n+            });\n             ctx\n         };\n \n@@ -199,7 +199,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt<'tcx>) {\n+    fn move_common(&mut self, _consume_id: NodeId, _span: Span, cmt: mc::cmt) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n@@ -210,7 +210,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n         }}\n     }\n \n-    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt<'tcx>) {\n+    fn non_moving_pat(&mut self, matched_pat: &Pat, cmt: mc::cmt) {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if_let_chain! {[\n@@ -262,7 +262,7 @@ impl<'a, 'tcx: 'a> MovedVariablesCtxt<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx: 'a> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n+impl<'a, 'gcx: 'tcx, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'gcx> {\n     fn consume(&mut self, consume_id: NodeId, consume_span: Span, cmt: mc::cmt<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move(_) = mode {\n             self.move_common(consume_id, consume_span, cmt);"}, {"sha": "1f19e454857292f42172f6ad4ed444d15629fd7a", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n             hir::ExprMatch(ref res, _, _) if is_try(expr).is_some() => {\n                 if let hir::ExprCall(ref func, ref args) = res.node {\n                     if let hir::ExprPath(ref path) = func.node {\n-                        if match_path(path, &paths::CARRIER_TRANSLATE) && args.len() == 1 {\n+                        if match_path(path, &paths::TRY_INTO_RESULT) && args.len() == 1 {\n                             check_method_call(cx, &args[0], expr);\n                         }\n                     }"}, {"sha": "d068fa51ca403834bb835230e5223dae075c289b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -9,7 +9,6 @@ use rustc::traits::Reveal;\n use rustc::traits;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty;\n-use rustc::ty::layout::TargetDataLayout;\n use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n@@ -184,12 +183,8 @@ pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n \n /// Check if the method call given in `expr` belongs to given type.\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n-    let method_call = ty::MethodCall::expr(expr.id);\n-\n-    let trt_id = cx.tables\n-        .method_map\n-        .get(&method_call)\n-        .and_then(|callee| cx.tcx.impl_of_method(callee.def_id));\n+    let method_call = cx.tables.type_dependent_defs[&expr.id];\n+    let trt_id = cx.tcx.impl_of_method(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx.tcx, trt_id, path)\n     } else {\n@@ -199,12 +194,8 @@ pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n \n /// Check if the method call given in `expr` belongs to given trait.\n pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n-    let method_call = ty::MethodCall::expr(expr.id);\n-\n-    let trt_id = cx.tables\n-        .method_map\n-        .get(&method_call)\n-        .and_then(|callee| cx.tcx.trait_of_item(callee.def_id));\n+    let method_call = cx.tables.type_dependent_defs[&expr.id];\n+    let trt_id = cx.tcx.trait_of_item(method_call.def_id());\n     if let Some(trt_id) = trt_id {\n         match_def_path(cx.tcx, trt_id, path)\n     } else {\n@@ -267,7 +258,6 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n }\n \n /// Get the definition associated to a path.\n-/// TODO: investigate if there is something more efficient for that.\n pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<def::Def> {\n     let cstore = &cx.tcx.sess.cstore;\n \n@@ -326,13 +316,15 @@ pub fn implements_trait<'a, 'tcx>(\n     parent_node_id: Option<NodeId>\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n-    let mut b = if let Some(id) = parent_node_id {\n-        cx.tcx.infer_ctxt(BodyId { node_id: id }, Reveal::All)\n+    let param_env = if let Some(id) = parent_node_id {\n+        let def_id = cx.tcx.hir.body_owner_def_id(BodyId { node_id: id });\n+        cx.tcx.param_env(def_id).reveal_all()\n     } else {\n-        cx.tcx.infer_ctxt((), Reveal::All)\n+        ty::ParamEnv::empty(Reveal::All)\n     };\n-    b.enter(|infcx| {\n-        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n+    cx.tcx.infer_ctxt(()).enter(|infcx| {\n+        let obligation = cx.tcx.predicate_for_trait_def(\n+            param_env, traits::ObligationCause::dummy(), trait_id, 0, ty, ty_params);\n \n         traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n     })\n@@ -787,12 +779,9 @@ pub fn same_tys<'a, 'tcx>(\n     b: ty::Ty<'tcx>,\n     parameter_item: DefId\n ) -> bool {\n-    let parameter_env = cx.tcx.param_env(parameter_item);\n-    cx.tcx.infer_ctxt(parameter_env, Reveal::All).enter(|infcx| {\n-        let substs = Substs::identity_for_item(cx.tcx, parameter_item);\n-        let new_a = a.subst(infcx.tcx, substs);\n-        let new_b = b.subst(infcx.tcx, substs);\n-        infcx.can_equate(&new_a, &new_b).is_ok()\n+    let param_env = cx.tcx.param_env(parameter_item).reveal_all();\n+    cx.tcx.infer_ctxt(()).enter(|infcx| {\n+        infcx.can_eq(param_env, a, b).is_ok()\n     })\n }\n \n@@ -970,7 +959,6 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n }\n \n pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n-    cx.tcx\n-        .infer_ctxt((), Reveal::All)\n-        .enter(|infcx| ty.layout(&infcx).ok().map(|lay| lay.size(&TargetDataLayout::parse(cx.sess())).bytes()))\n+    ty.layout(cx.tcx, ty::ParamEnv::empty(Reveal::All))\n+      .ok().map(|layout| layout.size(cx.tcx).bytes())\n }"}, {"sha": "738a497c6ab67f75ff98702ee71a65f74b2d42bb", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -9,7 +9,6 @@ pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n pub const BTREEMAP: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const BTREEMAP_ENTRY: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"Entry\"];\n pub const BTREESET: [&'static str; 4] = [\"collections\", \"btree\", \"set\", \"BTreeSet\"];\n-pub const CARRIER_TRANSLATE: [&'static str; 4] = [\"std\", \"ops\", \"Carrier\", \"translate\"];\n pub const CLONE: [&'static str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CLONE_TRAIT: [&'static str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n@@ -72,6 +71,7 @@ pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TO_OWNED: [&'static str; 3] = [\"collections\", \"borrow\", \"ToOwned\"];\n pub const TO_STRING: [&'static str; 3] = [\"collections\", \"string\", \"ToString\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n+pub const TRY_INTO_RESULT: [&'static str; 4] = [\"std\", \"ops\", \"Try\", \"into_result\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];\n pub const VEC_FROM_ELEM: [&'static str; 3] = [\"collections\", \"vec\", \"from_elem\"];"}, {"sha": "66c42d50e19a441c508be184cc737a94ad612e74", "filename": "clippy_tests/examples/for_loop.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_tests%2Fexamples%2Ffor_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_tests%2Fexamples%2Ffor_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Ffor_loop.stderr?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -295,6 +295,14 @@ error: this range is empty so this for loop will never run\n     |\n     = note: `-D reverse-range-loop` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+   --> for_loop.rs:192:22\n+    |\n+192 |     for i in (10..8).step_by(-1) {\n+    |                      ^^^^^^^\n+    |\n+    = note: `-D deprecated` implied by `-D warnings`\n+\n error: it is more idiomatic to loop over references to containers instead of using explicit iteration methods\n    --> for_loop.rs:207:15\n     |"}, {"sha": "c8f606db0e170e3928e2a19e4b743cd8e5b4b5a5", "filename": "clippy_tests/examples/mut_reference.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_tests%2Fexamples%2Fmut_reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_tests%2Fexamples%2Fmut_reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Fmut_reference.stderr?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -1,20 +1,20 @@\n-error: The function/method \"takes_an_immutable_reference\" doesn't need a mutable reference\n+error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n   --> mut_reference.rs:22:34\n    |\n 22 |     takes_an_immutable_reference(&mut 42);\n    |                                  ^^^^^^^\n    |\n    = note: `-D unnecessary-mut-passed` implied by `-D warnings`\n \n-error: The function/method \"as_ptr\" doesn't need a mutable reference\n+error: The function/method `as_ptr` doesn't need a mutable reference\n   --> mut_reference.rs:24:12\n    |\n 24 |     as_ptr(&mut 42);\n    |            ^^^^^^^\n    |\n    = note: `-D unnecessary-mut-passed` implied by `-D warnings`\n \n-error: The function/method \"takes_an_immutable_reference\" doesn't need a mutable reference\n+error: The function/method `takes_an_immutable_reference` doesn't need a mutable reference\n   --> mut_reference.rs:28:44\n    |\n 28 |     my_struct.takes_an_immutable_reference(&mut 42);"}, {"sha": "2f3aa7971d0160d47095bc1b9fac3f0adb448beb", "filename": "clippy_tests/examples/range.stderr", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_tests%2Fexamples%2Frange.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e/clippy_tests%2Fexamples%2Frange.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_tests%2Fexamples%2Frange.stderr?ref=5a6e48fd27ddbe6a6106c49e0deea4fd77b0190e", "patch": "@@ -6,6 +6,22 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:13:12\n+   |\n+13 |     (0..1).step_by(0);\n+   |            ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:15:12\n+   |\n+15 |     (0..1).step_by(1);\n+   |            ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` instead\n   --> range.rs:17:5\n    |\n@@ -14,6 +30,14 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:17:11\n+   |\n+17 |     (1..).step_by(0);\n+   |           ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` instead\n   --> range.rs:18:5\n    |\n@@ -22,6 +46,14 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:18:13\n+   |\n+18 |     (1...2).step_by(0);\n+   |             ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: Range::step_by(0) produces an infinite iterator. Consider using `std::iter::repeat()` instead\n   --> range.rs:21:5\n    |\n@@ -30,6 +62,14 @@ error: Range::step_by(0) produces an infinite iterator. Consider using `std::ite\n    |\n    = note: `-D range-step-by-zero` implied by `-D warnings`\n \n+error: use of deprecated item: replaced by `Iterator::step_by`\n+  --> range.rs:21:7\n+   |\n+21 |     x.step_by(0);\n+   |       ^^^^^^^\n+   |\n+   = note: `-D deprecated` implied by `-D warnings`\n+\n error: It is more idiomatic to use v1.iter().enumerate()\n   --> range.rs:29:14\n    |"}]}