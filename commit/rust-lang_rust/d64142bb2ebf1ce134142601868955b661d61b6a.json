{"sha": "d64142bb2ebf1ce134142601868955b661d61b6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NDE0MmJiMmViZjFjZTEzNDE0MjYwMTg2ODk1NWI2NjFkNjFiNmE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-11-07T10:01:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-07T10:01:51Z"}, "message": "Rollup merge of #55501 - nnethercote:DoCompleted, r=pnkfelix\n\nMake `process_obligations`' computation of `completed` optional.\n\nIt's only used in tests.\n\nThis reduces instruction counts on several benchmarks by 0.5--1%.", "tree": {"sha": "5895636aa29230746d4f214fc2b75bb8cf7597fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5895636aa29230746d4f214fc2b75bb8cf7597fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d64142bb2ebf1ce134142601868955b661d61b6a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb4rgQCRBK7hj4Ov3rIwAAdHIIAIxBDI1hsHkOkPH1EtKNO4h6\n6aUs/JlJ8m+jTN+sUGbM+qBJx50SqaWAq2x4A8aiZnV5KvOKcvuXNK+jWschrbAU\n8Ti9eVK8T9UrDEatLil5rZkK2HZd3OyDQq+QVbkQb05qqHyljmIvANjRO48xcWOv\nhGdpE2FQvbnuUe9WZjfOfLkEr3T13+AQMmQpg6rGjn1LDzmikRzMOVIbLiVkMv7C\njfiQvGEJ7DGYNr872L1lLddQ0IcqWe7ennwg6OhiBj+hX8Ty1p1zjLzUw5Q256wo\n39IafjvQwpmRgMG3n1YHcQbV43wkux1s5g+e5DCQqnM5Rpg6JxY4GIkobe9qi04=\n=2eSK\n-----END PGP SIGNATURE-----\n", "payload": "tree 5895636aa29230746d4f214fc2b75bb8cf7597fb\nparent 099c5878517add5fd932c808961a9612d3ec026a\nparent dbc3c6e56fe4cc7c4692b18067b335fc63ca1ec8\nauthor kennytm <kennytm@gmail.com> 1541584911 +0800\ncommitter GitHub <noreply@github.com> 1541584911 +0800\n\nRollup merge of #55501 - nnethercote:DoCompleted, r=pnkfelix\n\nMake `process_obligations`' computation of `completed` optional.\n\nIt's only used in tests.\n\nThis reduces instruction counts on several benchmarks by 0.5--1%.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d64142bb2ebf1ce134142601868955b661d61b6a", "html_url": "https://github.com/rust-lang/rust/commit/d64142bb2ebf1ce134142601868955b661d61b6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d64142bb2ebf1ce134142601868955b661d61b6a/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099c5878517add5fd932c808961a9612d3ec026a", "url": "https://api.github.com/repos/rust-lang/rust/commits/099c5878517add5fd932c808961a9612d3ec026a", "html_url": "https://github.com/rust-lang/rust/commit/099c5878517add5fd932c808961a9612d3ec026a"}, {"sha": "dbc3c6e56fe4cc7c4692b18067b335fc63ca1ec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc3c6e56fe4cc7c4692b18067b335fc63ca1ec8", "html_url": "https://github.com/rust-lang/rust/commit/dbc3c6e56fe4cc7c4692b18067b335fc63ca1ec8"}], "stats": {"total": 160, "additions": 88, "deletions": 72}, "files": [{"sha": "bc091a4e7e0848e0ebd81fd2f0e3dde53ab44ec7", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d64142bb2ebf1ce134142601868955b661d61b6a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64142bb2ebf1ce134142601868955b661d61b6a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d64142bb2ebf1ce134142601868955b661d61b6a", "patch": "@@ -12,8 +12,9 @@ use infer::InferCtxt;\n use mir::interpret::{GlobalId, ErrorHandled};\n use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, ToPredicate};\n use ty::error::ExpectedFound;\n-use rustc_data_structures::obligation_forest::{Error, ForestObligation, ObligationForest};\n-use rustc_data_structures::obligation_forest::{ObligationProcessor, ProcessResult};\n+use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n+use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_data_structures::obligation_forest::{ProcessResult};\n use std::marker::PhantomData;\n use hir::def_id::DefId;\n \n@@ -98,7 +99,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n                 selcx,\n                 register_region_obligations: self.register_region_obligations\n-            });\n+            }, DoCompleted::No);\n             debug!(\"select: outcome={:#?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection"}, {"sha": "c211d888df131b5b62f29fde6d1b98a5cc4496d5", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 34, "deletions": 20, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d64142bb2ebf1ce134142601868955b661d61b6a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64142bb2ebf1ce134142601868955b661d61b6a/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=d64142bb2ebf1ce134142601868955b661d61b6a", "patch": "@@ -162,8 +162,8 @@ enum NodeState {\n #[derive(Debug)]\n pub struct Outcome<O, E> {\n     /// Obligations that were completely evaluated, including all\n-    /// (transitive) subobligations.\n-    pub completed: Vec<O>,\n+    /// (transitive) subobligations. Only computed if requested.\n+    pub completed: Option<Vec<O>>,\n \n     /// Backtrace of obligations that were found to be in error.\n     pub errors: Vec<Error<O, E>>,\n@@ -177,6 +177,14 @@ pub struct Outcome<O, E> {\n     pub stalled: bool,\n }\n \n+/// Should `process_obligations` compute the `Outcome::completed` field of its\n+/// result?\n+#[derive(PartialEq)]\n+pub enum DoCompleted {\n+    No,\n+    Yes,\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n pub struct Error<O, E> {\n     pub error: E,\n@@ -282,8 +290,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 });\n             }\n         }\n-        let successful_obligations = self.compress();\n-        assert!(successful_obligations.is_empty());\n+        let successful_obligations = self.compress(DoCompleted::Yes);\n+        assert!(successful_obligations.unwrap().is_empty());\n         errors\n     }\n \n@@ -311,7 +319,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n     /// This CANNOT be unrolled (presently, at least).\n-    pub fn process_obligations<P>(&mut self, processor: &mut P) -> Outcome<O, P::Error>\n+    pub fn process_obligations<P>(&mut self, processor: &mut P, do_completed: DoCompleted)\n+                                  -> Outcome<O, P::Error>\n         where P: ObligationProcessor<Obligation=O>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n@@ -366,7 +375,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // There's no need to perform marking, cycle processing and compression when nothing\n             // changed.\n             return Outcome {\n-                completed: vec![],\n+                completed: if do_completed == DoCompleted::Yes { Some(vec![]) } else { None },\n                 errors,\n                 stalled,\n             };\n@@ -376,12 +385,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.process_cycles(processor);\n \n         // Now we have to compress the result\n-        let completed_obligations = self.compress();\n+        let completed = self.compress(do_completed);\n \n         debug!(\"process_obligations: complete\");\n \n         Outcome {\n-            completed: completed_obligations,\n+            completed,\n             errors,\n             stalled,\n         }\n@@ -524,7 +533,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// Beforehand, all nodes must be marked as `Done` and no cycles\n     /// on these nodes may be present. This is done by e.g. `process_cycles`.\n     #[inline(never)]\n-    fn compress(&mut self) -> Vec<O> {\n+    fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n         let nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n         node_rewrites.extend(0..nodes_len);\n@@ -573,21 +582,26 @@ impl<O: ForestObligation> ObligationForest<O> {\n         if dead_nodes == 0 {\n             node_rewrites.truncate(0);\n             self.scratch = Some(node_rewrites);\n-            return vec![];\n+            return if do_completed == DoCompleted::Yes { Some(vec![]) } else { None };\n         }\n \n         // Pop off all the nodes we killed and extract the success\n         // stories.\n-        let successful = (0..dead_nodes)\n-                             .map(|_| self.nodes.pop().unwrap())\n-                             .flat_map(|node| {\n-                                 match node.state.get() {\n-                                     NodeState::Error => None,\n-                                     NodeState::Done => Some(node.obligation),\n-                                     _ => unreachable!()\n-                                 }\n-                             })\n-            .collect();\n+        let successful = if do_completed == DoCompleted::Yes {\n+            Some((0..dead_nodes)\n+                .map(|_| self.nodes.pop().unwrap())\n+                .flat_map(|node| {\n+                    match node.state.get() {\n+                        NodeState::Error => None,\n+                        NodeState::Done => Some(node.obligation),\n+                        _ => unreachable!()\n+                    }\n+                })\n+                .collect())\n+        } else {\n+            self.nodes.truncate(self.nodes.len() - dead_nodes);\n+            None\n+        };\n         self.apply_rewrites(&node_rewrites);\n \n         node_rewrites.truncate(0);"}, {"sha": "2a418973fbda2010d37613bd78458123470bff5f", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d64142bb2ebf1ce134142601868955b661d61b6a/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64142bb2ebf1ce134142601868955b661d61b6a/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=d64142bb2ebf1ce134142601868955b661d61b6a", "patch": "@@ -10,7 +10,7 @@\n \n #![cfg(test)]\n \n-use super::{Error, ObligationForest, ObligationProcessor, Outcome, ProcessResult};\n+use super::{Error, DoCompleted, ObligationForest, ObligationProcessor, Outcome, ProcessResult};\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -84,8 +84,8 @@ fn push_pop() {\n                 \"C\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, vec![\"C\"]);\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"C\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"B is for broken\",\n@@ -108,8 +108,8 @@ fn push_pop() {\n                 \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, Vec::<&'static str>::new());\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), Vec::<&'static str>::new());\n     assert_eq!(err, Vec::new());\n \n \n@@ -127,8 +127,8 @@ fn push_pop() {\n                 \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, vec![\"A.3\", \"A.1\", \"A.3.i\"]);\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"A.3\", \"A.1\", \"A.3.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"A is for apple\",\n@@ -143,8 +143,8 @@ fn push_pop() {\n                 \"D.2.i\" => ProcessResult::Changed(vec![]),\n                 _ => panic!(\"unexpected obligation {:?}\", obligation),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, vec![\"D.2.i\", \"D.2\"]);\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"D.2.i\", \"D.2\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"D is for dumb\",\n@@ -171,8 +171,8 @@ fn success_in_grandchildren() {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert!(ok.is_empty());\n+        }, |_| {}), DoCompleted::Yes);\n+    assert!(ok.unwrap().is_empty());\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -183,8 +183,8 @@ fn success_in_grandchildren() {\n                 \"A.3\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, vec![\"A.3\", \"A.1\"]);\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"A.3\", \"A.1\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -194,8 +194,8 @@ fn success_in_grandchildren() {\n                 \"A.2.ii\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, vec![\"A.2.ii\"]);\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -204,14 +204,15 @@ fn success_in_grandchildren() {\n                 \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n-        }, |_| {}));\n-    assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n+        }, |_| {}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}));\n+        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}),\n+        DoCompleted::Yes);\n \n-    assert!(ok.is_empty());\n+    assert!(ok.unwrap().is_empty());\n     assert!(err.is_empty());\n }\n \n@@ -227,8 +228,8 @@ fn to_errors_no_throw() {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err.len(), 0);\n     let errors = forest.to_errors(());\n     assert_eq!(errors[0].backtrace, vec![\"A.1\", \"A\"]);\n@@ -248,8 +249,8 @@ fn diamond() {\n                 \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -259,8 +260,8 @@ fn diamond() {\n                 \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let mut d_count = 0;\n@@ -270,9 +271,9 @@ fn diamond() {\n                 \"D\" => { d_count += 1; ProcessResult::Changed(vec![]) },\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n+        }, |_|{}), DoCompleted::Yes);\n     assert_eq!(d_count, 1);\n-    assert_eq!(ok, vec![\"D\", \"A.2\", \"A.1\", \"A\"]);\n+    assert_eq!(ok.unwrap(), vec![\"D\", \"A.2\", \"A.1\", \"A\"]);\n     assert_eq!(err.len(), 0);\n \n     let errors = forest.to_errors(());\n@@ -285,8 +286,8 @@ fn diamond() {\n                 \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -296,8 +297,8 @@ fn diamond() {\n                 \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let mut d_count = 0;\n@@ -307,9 +308,9 @@ fn diamond() {\n                 \"D'\" => { d_count += 1; ProcessResult::Error(\"operation failed\") },\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n+        }, |_|{}), DoCompleted::Yes);\n     assert_eq!(d_count, 1);\n-    assert_eq!(ok.len(), 0);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err, vec![super::Error {\n         error: \"operation failed\",\n         backtrace: vec![\"D'\", \"A'.1\", \"A'\"]\n@@ -333,8 +334,8 @@ fn done_dependency() {\n                 \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok, vec![\"C: Sized\", \"B: Sized\", \"A: Sized\"]);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"C: Sized\", \"B: Sized\", \"A: Sized\"]);\n     assert_eq!(err.len(), 0);\n \n     forest.register_obligation(\"(A,B,C): Sized\");\n@@ -348,8 +349,8 @@ fn done_dependency() {\n                         ]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"(A,B,C): Sized\"]);\n     assert_eq!(err.len(), 0);\n }\n \n@@ -371,8 +372,8 @@ fn orphan() {\n                 \"C2\" => ProcessResult::Changed(vec![]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok, vec![\"C2\", \"C1\"]);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap(), vec![\"C2\", \"C1\"]);\n     assert_eq!(err.len(), 0);\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -382,8 +383,8 @@ fn orphan() {\n                 \"B\" => ProcessResult::Changed(vec![\"D\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let Outcome { completed: ok, errors: err, .. } =\n@@ -393,8 +394,8 @@ fn orphan() {\n                 \"E\" => ProcessResult::Error(\"E is for error\"),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err, vec![super::Error {\n         error: \"E is for error\",\n         backtrace: vec![\"E\", \"A\"]\n@@ -406,8 +407,8 @@ fn orphan() {\n                 \"D\" => ProcessResult::Error(\"D is dead\"),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err, vec![super::Error {\n         error: \"D is dead\",\n         backtrace: vec![\"D\"]\n@@ -431,8 +432,8 @@ fn simultaneous_register_and_error() {\n                 \"B\" => ProcessResult::Changed(vec![\"A\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err, vec![super::Error {\n         error: \"An error\",\n         backtrace: vec![\"A\"]\n@@ -449,8 +450,8 @@ fn simultaneous_register_and_error() {\n                 \"B\" => ProcessResult::Changed(vec![\"A\"]),\n                 _ => unreachable!(),\n             }\n-        }, |_|{}));\n-    assert_eq!(ok.len(), 0);\n+        }, |_|{}), DoCompleted::Yes);\n+    assert_eq!(ok.unwrap().len(), 0);\n     assert_eq!(err, vec![super::Error {\n         error: \"An error\",\n         backtrace: vec![\"A\"]"}]}