{"sha": "0734200e801d52662f02aff7fdd5026337798620", "node_id": "C_kwDOAAsO6NoAKDA3MzQyMDBlODAxZDUyNjYyZjAyYWZmN2ZkZDUwMjYzMzc3OTg2MjA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-27T20:53:04Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-27T21:23:06Z"}, "message": "Use autoderef", "tree": {"sha": "660139b220ef44e6815a7f7cab354c67e798de6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/660139b220ef44e6815a7f7cab354c67e798de6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0734200e801d52662f02aff7fdd5026337798620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0734200e801d52662f02aff7fdd5026337798620", "html_url": "https://github.com/rust-lang/rust/commit/0734200e801d52662f02aff7fdd5026337798620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0734200e801d52662f02aff7fdd5026337798620/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c", "html_url": "https://github.com/rust-lang/rust/commit/dca5f5bf8f55faaab84fb23db1b4c5ebdc404c0c"}], "stats": {"total": 121, "additions": 78, "deletions": 43}, "files": [{"sha": "45872a0b07aeb54b3fbd76b7f448db2aab6e8fa1", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 51, "deletions": 43, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0734200e801d52662f02aff7fdd5026337798620/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0734200e801d52662f02aff7fdd5026337798620/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=0734200e801d52662f02aff7fdd5026337798620", "patch": "@@ -61,55 +61,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pointing_at_return_type\n     }\n \n-    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n-    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// When encountering an fn-like type, try accessing the output of the type\n+    /// // and suggesting calling it if it satisfies a predicate (i.e. if the\n+    /// output has a method or a field):\n     /// ```compile_fail,E0308\n     /// fn foo(x: usize) -> usize { x }\n     /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n     /// ```\n-    fn suggest_fn_call(\n+    pub(crate) fn suggest_fn_call(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let (def_id, output, inputs) = match *found.kind() {\n-            ty::FnDef(def_id, _) => {\n-                let fn_sig = found.fn_sig(self.tcx);\n-                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len())\n-            }\n-            ty::Closure(def_id, substs) => {\n-                let fn_sig = substs.as_closure().sig();\n-                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len() - 1)\n-            }\n-            ty::Opaque(def_id, substs) => {\n-                let sig = self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            args.len(),\n-                        ))\n+        // Autoderef is useful here because sometimes we box callables, etc.\n+        let Some((def_id, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n+            match *found.kind() {\n+                ty::FnPtr(fn_sig) => Some((None, fn_sig.output(), fn_sig.inputs().skip_binder().len())),\n+                ty::FnDef(def_id, _) => {\n+                    let fn_sig = found.fn_sig(self.tcx);\n+                    Some((Some(def_id), fn_sig.output(), fn_sig.inputs().skip_binder().len()))\n+                }\n+                ty::Closure(def_id, substs) => {\n+                    let fn_sig = substs.as_closure().sig();\n+                    Some((Some(def_id), fn_sig.output(), fn_sig.inputs().skip_binder().len() - 1))\n+                }\n+                ty::Opaque(def_id, substs) => {\n+                    let sig = self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                args.len(),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    });\n+                    if let Some((output, inputs)) = sig {\n+                        Some((Some(def_id), output, inputs))\n                     } else {\n                         None\n                     }\n-                });\n-                if let Some((output, inputs)) = sig {\n-                    (def_id, output, inputs)\n-                } else {\n-                    return false;\n                 }\n+                _ => None,\n             }\n-            _ => return false,\n-        };\n+        }) else { return false; };\n \n         let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n-        let output = self.normalize_associated_types_in(expr.span, output);\n-        if !output.is_ty_var() && self.can_coerce(output, expected) {\n+        // We don't want to register any extra obligations, which should be\n+        // implied by wf, but also because that would possibly result in\n+        // erroneous errors later on.\n+        let infer::InferOk { value: output, obligations: _ } =\n+            self.normalize_associated_types_in_as_infer_ok(expr.span, output);\n+        if !output.is_ty_var() && can_satisfy(output) {\n             let (sugg_call, mut applicability) = match inputs {\n                 0 => (\"\".to_string(), Applicability::MachineApplicable),\n                 1..=4 => (\n@@ -119,11 +128,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n             };\n \n-            let msg = match self.tcx.def_kind(def_id) {\n-                DefKind::Fn => \"call this function\",\n-                DefKind::Closure | DefKind::OpaqueTy => \"call this closure\",\n-                DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\",\n-                DefKind::Ctor(CtorOf::Variant, _) => \"instantiate this tuple variant\",\n+            let msg = match def_id.map(|def_id| self.tcx.def_kind(def_id)) {\n+                Some(DefKind::Fn) => \"call this function\",\n+                Some(DefKind::Closure | DefKind::OpaqueTy) => \"call this closure\",\n+                Some(DefKind::Ctor(CtorOf::Struct, _)) => \"instantiate this tuple struct\",\n+                Some(DefKind::Ctor(CtorOf::Variant, _)) => \"instantiate this tuple variant\",\n                 _ => \"call this function\",\n             };\n \n@@ -178,12 +187,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n-        } else if let (ty::FnDef(def_id, ..), true) =\n-            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n+        } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n+            && let ty::FnDef(def_id, ..) = &found.kind()\n+            && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n         {\n-            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                err.span_label(sp, format!(\"{found} defined here\"));\n-            }\n+            err.span_label(sp, format!(\"{found} defined here\"));\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {"}, {"sha": "d19e4596a0cc1ba060c85b4e7757e6978ecea149", "filename": "src/test/ui/suggestions/call-boxed.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0734200e801d52662f02aff7fdd5026337798620/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0734200e801d52662f02aff7fdd5026337798620/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs?ref=0734200e801d52662f02aff7fdd5026337798620", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut x = 1i32;\n+    let y = Box::new(|| 1);\n+    x = y;\n+    //~^ ERROR mismatched types\n+    //~| HELP use parentheses to call this closure\n+}"}, {"sha": "9b619ac9a3f502fcc4983655dec8070c4362bd77", "filename": "src/test/ui/suggestions/call-boxed.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0734200e801d52662f02aff7fdd5026337798620/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0734200e801d52662f02aff7fdd5026337798620/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr?ref=0734200e801d52662f02aff7fdd5026337798620", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/call-boxed.rs:4:9\n+   |\n+LL |     let mut x = 1i32;\n+   |                 ---- expected due to this value\n+LL |     let y = Box::new(|| 1);\n+   |                      -- the found closure\n+LL |     x = y;\n+   |         ^ expected `i32`, found struct `Box`\n+   |\n+   = note: expected type `i32`\n+            found struct `Box<[closure@$DIR/call-boxed.rs:3:22: 3:24]>`\n+help: use parentheses to call this closure\n+   |\n+LL |     x = y();\n+   |          ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}