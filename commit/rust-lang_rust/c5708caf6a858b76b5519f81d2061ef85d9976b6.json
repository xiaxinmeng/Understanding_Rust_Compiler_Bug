{"sha": "c5708caf6a858b76b5519f81d2061ef85d9976b6", "node_id": "C_kwDOAAsO6NoAKGM1NzA4Y2FmNmE4NThiNzZiNTUxOWY4MWQyMDYxZWY4NWQ5OTc2YjY", "commit": {"author": {"name": "Ramon de C Valle", "email": "rcvalle@users.noreply.github.com", "date": "2021-10-14T19:24:53Z"}, "committer": {"name": "Ramon de C Valle", "email": "rcvalle@users.noreply.github.com", "date": "2021-10-27T06:33:55Z"}, "message": "Add documentation for LLVM CFI support\n\nThis commit adds initial documentation for LLVM Control Flow Integrity\n(CFI) support to the Rust compiler (see #89652 and #89653).", "tree": {"sha": "fd1399ee3ad54913b272947860218793c5a4d5f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd1399ee3ad54913b272947860218793c5a4d5f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5708caf6a858b76b5519f81d2061ef85d9976b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5708caf6a858b76b5519f81d2061ef85d9976b6", "html_url": "https://github.com/rust-lang/rust/commit/c5708caf6a858b76b5519f81d2061ef85d9976b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5708caf6a858b76b5519f81d2061ef85d9976b6/comments", "author": {"login": "rcvalle", "id": 3988004, "node_id": "MDQ6VXNlcjM5ODgwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3988004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcvalle", "html_url": "https://github.com/rcvalle", "followers_url": "https://api.github.com/users/rcvalle/followers", "following_url": "https://api.github.com/users/rcvalle/following{/other_user}", "gists_url": "https://api.github.com/users/rcvalle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcvalle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcvalle/subscriptions", "organizations_url": "https://api.github.com/users/rcvalle/orgs", "repos_url": "https://api.github.com/users/rcvalle/repos", "events_url": "https://api.github.com/users/rcvalle/events{/privacy}", "received_events_url": "https://api.github.com/users/rcvalle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rcvalle", "id": 3988004, "node_id": "MDQ6VXNlcjM5ODgwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3988004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rcvalle", "html_url": "https://github.com/rcvalle", "followers_url": "https://api.github.com/users/rcvalle/followers", "following_url": "https://api.github.com/users/rcvalle/following{/other_user}", "gists_url": "https://api.github.com/users/rcvalle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rcvalle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rcvalle/subscriptions", "organizations_url": "https://api.github.com/users/rcvalle/orgs", "repos_url": "https://api.github.com/users/rcvalle/repos", "events_url": "https://api.github.com/users/rcvalle/events{/privacy}", "received_events_url": "https://api.github.com/users/rcvalle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d30e9318900dd4f034c21f1378fea7b40998b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d30e9318900dd4f034c21f1378fea7b40998b07", "html_url": "https://github.com/rust-lang/rust/commit/5d30e9318900dd4f034c21f1378fea7b40998b07"}], "stats": {"total": 221, "additions": 202, "deletions": 19}, "files": [{"sha": "fa38dd54d60c89bc7730daa6c20b1c501df0d6df", "filename": "src/doc/rustc/src/exploit-mitigations.md", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c5708caf6a858b76b5519f81d2061ef85d9976b6/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5708caf6a858b76b5519f81d2061ef85d9976b6/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md?ref=c5708caf6a858b76b5519f81d2061ef85d9976b6", "patch": "@@ -123,9 +123,9 @@ equivalent.\n   <tr>\n    <td>Forward-edge control flow protection\n    </td>\n-   <td>No\n+   <td>Yes\n    </td>\n-   <td>\n+   <td>Nightly\n    </td>\n   </tr>\n   <tr>\n@@ -465,24 +465,27 @@ implementations such as [LLVM ControlFlowIntegrity\n commercially available [grsecurity/PaX Reuse Attack Protector\n (RAP)](https://grsecurity.net/rap_faq).\n \n-The Rust compiler does not support forward-edge control flow protection on\n-Linux<sup id=\"fnref:6\" role=\"doc-noteref\"><a href=\"#fn:6\"\n-class=\"footnote\">6</a></sup>. There is work currently ongoing to add support\n-for the [sanitizers](https://github.com/google/sanitizers)[40], which may or\n-may not include support for LLVM CFI.\n+The Rust compiler supports forward-edge control flow protection on nightly\n+builds[40]-[41] <sup id=\"fnref:6\" role=\"doc-noteref\"><a href=\"#fn:6\"\n+class=\"footnote\">6</a></sup>.\n \n ```text\n-$ readelf -s target/release/hello-rust | grep __cfi_init\n+$ readelf -s -W target/debug/rust-cfi | grep \"\\.cfi\"\n+    12: 0000000000005170    46 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi7add_one.cfi\n+    15: 00000000000051a0    16 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi7add_two.cfi\n+    17: 0000000000005270   396 FUNC    LOCAL  DEFAULT   14 _RNvCsjaOHoaNjor6_8rust_cfi4main.cfi\n+...\n ```\n-Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary.\n+Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary[41].\n \n-The presence of the `__cfi_init` symbol (and references to `__cfi_check`)\n-indicates that LLVM CFI (i.e., forward-edge control flow protection) is\n-enabled for a given binary. Conversely, the absence of the `__cfi_init`\n-symbol (and references to `__cfi_check`) indicates that LLVM CFI is not\n-enabled for a given binary (see Fig. 15).\n+The presence of symbols suffixed with \".cfi\" or the `__cfi_init` symbol (and\n+references to `__cfi_check`) indicates that LLVM CFI (i.e., forward-edge control\n+flow protection) is enabled for a given binary. Conversely, the absence of\n+symbols suffixed with \".cfi\" or the `__cfi_init` symbol (and references to\n+`__cfi_check`) indicates that LLVM CFI is not enabled for a given binary (see\n+Fig. 15).\n \n-<small id=\"fn:6\">6\\. It supports Control Flow Guard (CFG) on Windows (see\n+<small id=\"fn:6\">6\\. It also supports Control Flow Guard (CFG) on Windows (see\n <https://github.com/rust-lang/rust/issues/68793>). <a href=\"#fnref:6\"\n class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n \n@@ -689,5 +692,8 @@ defaults (unrelated to `READ_IMPLIES_EXEC`).\n 39. A. Crichton. \u201cRemove the alloc\\_jemalloc crate #55238.\u201d GitHub.\n     <https://github.com/rust-lang/rust/pull/55238>.\n \n-40. J. Aparicio. 2017. \u201cTracking issue for sanitizer support #39699.\u201d\n-    <https://github.com/rust-lang/rust/issues/39699>.\n+40. R. de C Valle. \u201cTracking Issue for LLVM Control Flow Integrity (CFI) Support\n+    for Rust #89653.\u201d GitHub. <https://github.com/rust-lang/rust/issues/89653>.\n+\n+41. \u201cControlFlowIntegrity.\u201d The Rust Unstable Book.\n+    <https://doc.rust-lang.org/beta/unstable-book/compiler-flags/sanitizer.html#controlflowintegrity>."}, {"sha": "b3dbc9a9956795273b3ec854ef72873681057206", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 179, "deletions": 2, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/c5708caf6a858b76b5519f81d2061ef85d9976b6/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5708caf6a858b76b5519f81d2061ef85d9976b6/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=c5708caf6a858b76b5519f81d2061ef85d9976b6", "patch": "@@ -1,19 +1,24 @@\n # `sanitizer`\n \n-The tracking issue for this feature is: [#39699](https://github.com/rust-lang/rust/issues/39699).\n+The tracking issues for this feature are:\n+\n+* [#39699](https://github.com/rust-lang/rust/issues/39699).\n+* [#89653](https://github.com/rust-lang/rust/issues/89653).\n \n ------------------------\n \n This feature allows for use of one of following sanitizers:\n \n * [AddressSanitizer][clang-asan] a fast memory error detector.\n+* [ControlFlowIntegrity][clang-cfi] LLVM Control Flow Integrity (CFI) provides\n+  forward-edge control flow protection.\n * [HWAddressSanitizer][clang-hwasan] a memory error detector similar to\n   AddressSanitizer, but based on partial hardware assistance.\n * [LeakSanitizer][clang-lsan] a run-time memory leak detector.\n * [MemorySanitizer][clang-msan] a detector of uninitialized reads.\n * [ThreadSanitizer][clang-tsan] a fast data race detector.\n \n-To enable a sanitizer compile with `-Zsanitizer=address`,\n+To enable a sanitizer compile with `-Zsanitizer=address`,`-Zsanitizer=cfi`,\n `-Zsanitizer=hwaddress`, `-Zsanitizer=leak`, `-Zsanitizer=memory` or\n `-Zsanitizer=thread`.\n \n@@ -177,6 +182,176 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n ==39249==ABORTING\n ```\n \n+# ControlFlowIntegrity\n+\n+The LLVM Control Flow Integrity (CFI) support in the Rust compiler initially\n+provides forward-edge control flow protection for Rust-compiled code only by\n+aggregating function pointers in groups identified by their number of arguments.\n+\n+Forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed\n+binaries\" (i.e., for when C or C++ and Rust -compiled code share the same\n+virtual address space) will be provided in later work by defining and using\n+compatible type identifiers (see Type metadata in the design document in the\n+tracking issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n+\n+LLVM CFI can be enabled with -Zsanitizer=cfi and requires LTO (i.e., -Clto).\n+\n+## Example\n+\n+```text\n+#![feature(asm, naked_functions)]\n+\n+use std::mem;\n+\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+#[naked]\n+pub extern \"C\" fn add_two(x: i32) {\n+    // x + 2 preceeded by a landing pad/nop block\n+    unsafe {\n+        asm!(\n+            \"\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             nop\n+             lea rax, [rdi+2]\n+             ret\n+        \",\n+            options(noreturn)\n+        );\n+    }\n+}\n+\n+fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    f(arg) + f(arg)\n+}\n+\n+fn main() {\n+    let answer = do_twice(add_one, 5);\n+\n+    println!(\"The answer is: {}\", answer);\n+\n+    println!(\"With CFI enabled, you should not see the next answer\");\n+    let f: fn(i32) -> i32 = unsafe {\n+        // Offsets 0-8 make it land in the landing pad/nop block, and offsets 1-8 are\n+        // invalid branch/call destinations (i.e., within the body of the function).\n+        mem::transmute::<*const u8, fn(i32) -> i32>((add_two as *const u8).offset(5))\n+    };\n+    let next_answer = do_twice(f, 5);\n+\n+    println!(\"The next answer is: {}\", next_answer);\n+}\n+```\n+Fig. 1.\u2003Modified example from the [Advanced Functions and\n+Closures][rust-book-ch19-05] chapter of the [The Rust Programming\n+Language][rust-book] book.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+The next answer is: 14\n+$\n+```\n+Fig. 2.\u2003Build and execution of the modified example with LLVM CFI disabled.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc -Clto -Zsanitizer=cfi rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+Illegal instruction\n+$\n+```\n+Fig. 3.\u2003Build and execution of the modified example with LLVM CFI enabled.\n+\n+When LLVM CFI is enabled, if there are any attempts to change/hijack control\n+flow using an indirect branch/call to an invalid destination, the execution is\n+terminated (see Fig. 3).\n+\n+```rust\n+use std::mem;\n+\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+fn add_two(x: i32, _y: i32) -> i32 {\n+    x + 2\n+}\n+\n+fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    f(arg) + f(arg)\n+}\n+\n+fn main() {\n+    let answer = do_twice(add_one, 5);\n+\n+    println!(\"The answer is: {}\", answer);\n+\n+    println!(\"With CFI enabled, you should not see the next answer\");\n+    let f: fn(i32) -> i32 =\n+        unsafe { mem::transmute::<*const u8, fn(i32) -> i32>(add_two as *const u8) };\n+    let next_answer = do_twice(f, 5);\n+\n+    println!(\"The next answer is: {}\", next_answer);\n+}\n+```\n+Fig. 4.\u2003Another modified example from the [Advanced Functions and\n+Closures][rust-book-ch19-05] chapter of the [The Rust Programming\n+Language][rust-book] book.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+The next answer is: 14\n+$\n+```\n+Fig. 5.\u2003Build and execution of the modified example with LLVM CFI disabled.\n+\n+[//]: # (FIXME: Replace with output from cargo using nightly when #89652 is merged)\n+\n+```shell\n+$ rustc -Clto -Zsanitizer=cfi rust_cfi.rs -o rust_cfi\n+$ ./rust_cfi\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+Illegal instruction\n+$\n+```\n+Fig. 6.\u2003Build and execution of the modified example with LLVM CFI enabled.\n+\n+When LLVM CFI is enabled, if there are any attempts to change/hijack control\n+flow using an indirect branch/call to a function with different number of\n+arguments than intended/passed in the call/branch site, the execution is also\n+terminated (see Fig. 6).\n+\n+Forward-edge control flow protection not only by aggregating function pointers\n+in groups identified by their number of arguments, but also their argument\n+types, will also be provided in later work by defining and using compatible type\n+identifiers (see Type metadata in the design document in the tracking\n+issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n+\n+[rust-book-ch19-05]: https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html\n+[rust-book]: https://doc.rust-lang.org/book/title-page.html\n+\n # HWAddressSanitizer\n \n HWAddressSanitizer is a newer variant of AddressSanitizer that consumes much\n@@ -404,12 +579,14 @@ Sanitizers produce symbolized stacktraces when llvm-symbolizer binary is in `PAT\n \n * [Sanitizers project page](https://github.com/google/sanitizers/wiki/)\n * [AddressSanitizer in Clang][clang-asan]\n+* [ControlFlowIntegrity in Clang][clang-cfi]\n * [HWAddressSanitizer in Clang][clang-hwasan]\n * [LeakSanitizer in Clang][clang-lsan]\n * [MemorySanitizer in Clang][clang-msan]\n * [ThreadSanitizer in Clang][clang-tsan]\n \n [clang-asan]: https://clang.llvm.org/docs/AddressSanitizer.html\n+[clang-cfi]: https://clang.llvm.org/docs/ControlFlowIntegrity.html\n [clang-hwasan]: https://clang.llvm.org/docs/HardwareAssistedAddressSanitizerDesign.html\n [clang-lsan]: https://clang.llvm.org/docs/LeakSanitizer.html\n [clang-msan]: https://clang.llvm.org/docs/MemorySanitizer.html"}]}