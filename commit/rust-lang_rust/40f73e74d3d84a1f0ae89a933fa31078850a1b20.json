{"sha": "40f73e74d3d84a1f0ae89a933fa31078850a1b20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZjczZTc0ZDNkODRhMWYwYWU4OWE5MzNmYTMxMDc4ODUwYTFiMjA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-21T07:27:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-21T07:57:35Z"}, "message": "traits/fulfill: allow `stalled_on` to track `ty::Const::Infer(_)` (unused yet).", "tree": {"sha": "7cac36d308e80f2a24bd2864bc09e80b1e6e51e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cac36d308e80f2a24bd2864bc09e80b1e6e51e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40f73e74d3d84a1f0ae89a933fa31078850a1b20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40f73e74d3d84a1f0ae89a933fa31078850a1b20", "html_url": "https://github.com/rust-lang/rust/commit/40f73e74d3d84a1f0ae89a933fa31078850a1b20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40f73e74d3d84a1f0ae89a933fa31078850a1b20/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8448d2291d39cf5d0b0e814ada1b6e407fa0533", "html_url": "https://github.com/rust-lang/rust/commit/d8448d2291d39cf5d0b0e814ada1b6e407fa0533"}], "stats": {"total": 134, "additions": 96, "deletions": 38}, "files": [{"sha": "5ada9ce5df7225735b4031f59a92d356dc47f8b2", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 74, "deletions": 11, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/40f73e74d3d84a1f0ae89a933fa31078850a1b20/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f73e74d3d84a1f0ae89a933fa31078850a1b20/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=40f73e74d3d84a1f0ae89a933fa31078850a1b20", "patch": "@@ -19,7 +19,7 @@ use rustc::traits::select;\n use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::relate::RelateResult;\n-use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n+use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n pub use rustc::ty::IntVarValue;\n use rustc::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n use rustc::ty::{ConstVid, FloatVid, IntVid, TyVid};\n@@ -501,6 +501,7 @@ impl NLLRegionVariableOrigin {\n     }\n }\n \n+// FIXME(eddyb) investigate overlap between this and `TyOrConstInferVar`.\n #[derive(Copy, Clone, Debug)]\n pub enum FixupError<'tcx> {\n     UnresolvedIntTy(IntVid),\n@@ -1608,14 +1609,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// `infer_ty_changed(infer_ty)` is equivalent to `shallow_resolve(ty) != ty`\n-    /// (where `ty.kind = ty::Infer(infer_ty)`), but more efficient. It's always\n+    /// `ty_or_const_infer_var_changed` is equivalent to one of these two:\n+    ///   * `shallow_resolve(ty) != ty` (where `ty.kind = ty::Infer(_)`)\n+    ///   * `shallow_resolve(ct) != ct` (where `ct.kind = ty::ConstKind::Infer(_)`)\n+    ///\n+    /// However, `ty_or_const_infer_var_changed` is more efficient. It's always\n     /// inlined, despite being large, because it has only two call sites that\n-    /// are extremely hot.\n+    /// are extremely hot (both in `traits::fulfill`'s checking of `stalled_on`\n+    /// inference variables), and it handles both `Ty` and `ty::Const` without\n+    /// having to resort to storing full `GenericArg`s in `stalled_on`.\n     #[inline(always)]\n-    pub fn infer_ty_changed(&self, infer_ty: ty::InferTy) -> bool {\n-        match infer_ty {\n-            ty::TyVar(v) => {\n+    pub fn ty_or_const_infer_var_changed(&self, infer_var: TyOrConstInferVar<'tcx>) -> bool {\n+        match infer_var {\n+            TyOrConstInferVar::Ty(v) => {\n                 use self::type_variable::TypeVariableValue;\n \n                 // If `inlined_probe` returns a `Known` value, it never equals\n@@ -1626,22 +1632,79 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            ty::IntVar(v) => {\n+            TyOrConstInferVar::TyInt(v) => {\n                 // If `inlined_probe_value` returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which never matches a\n                 // `ty::Infer(_)`.\n                 self.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n-            ty::FloatVar(v) => {\n-                // If `inlined_probe_value` returns a value it's always a\n+            TyOrConstInferVar::TyFloat(v) => {\n+                // If `probe_value` returns a value it's always a\n                 // `ty::Float(_)`, which never matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n                 self.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n-            _ => unreachable!(),\n+            TyOrConstInferVar::Const(v) => {\n+                // If `probe_value` returns a `Known` value, it never equals\n+                // `ty::ConstKind::Infer(ty::InferConst::Var(v))`.\n+                //\n+                // Not `inlined_probe_value(v)` because this call site is colder.\n+                match self.inner.borrow_mut().const_unification_table.probe_value(v).val {\n+                    ConstVariableValue::Unknown { .. } => false,\n+                    ConstVariableValue::Known { .. } => true,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Helper for `ty_or_const_infer_var_changed` (see comment on that), currently\n+/// used only for `traits::fulfill`'s list of `stalled_on` inference variables.\n+#[derive(Copy, Clone, Debug)]\n+pub enum TyOrConstInferVar<'tcx> {\n+    /// Equivalent to `ty::Infer(ty::TyVar(_))`.\n+    Ty(TyVid),\n+    /// Equivalent to `ty::Infer(ty::IntVar(_))`.\n+    TyInt(IntVid),\n+    /// Equivalent to `ty::Infer(ty::FloatVar(_))`.\n+    TyFloat(FloatVid),\n+\n+    /// Equivalent to `ty::ConstKind::Infer(ty::InferConst::Var(_))`.\n+    Const(ConstVid<'tcx>),\n+}\n+\n+impl TyOrConstInferVar<'tcx> {\n+    /// Tries to extract an inference variable from a type or a constant, returns `None`\n+    /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`) and\n+    /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n+    pub fn maybe_from_generic_arg(arg: GenericArg<'tcx>) -> Option<Self> {\n+        match arg.unpack() {\n+            GenericArgKind::Type(ty) => Self::maybe_from_ty(ty),\n+            GenericArgKind::Const(ct) => Self::maybe_from_const(ct),\n+            GenericArgKind::Lifetime(_) => None,\n+        }\n+    }\n+\n+    /// Tries to extract an inference variable from a type, returns `None`\n+    /// for types other than `ty::Infer(_)` (or `InferTy::Fresh*`).\n+    pub fn maybe_from_ty(ty: Ty<'tcx>) -> Option<Self> {\n+        match ty.kind {\n+            ty::Infer(ty::TyVar(v)) => Some(TyOrConstInferVar::Ty(v)),\n+            ty::Infer(ty::IntVar(v)) => Some(TyOrConstInferVar::TyInt(v)),\n+            ty::Infer(ty::FloatVar(v)) => Some(TyOrConstInferVar::TyFloat(v)),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Tries to extract an inference variable from a constant, returns `None`\n+    /// for constants other than `ty::ConstKind::Infer(_)` (or `InferConst::Fresh`).\n+    pub fn maybe_from_const(ct: &'tcx ty::Const<'tcx>) -> Option<Self> {\n+        match ct.val {\n+            ty::ConstKind::Infer(InferConst::Var(v)) => Some(TyOrConstInferVar::Const(v)),\n+            _ => None,\n         }\n     }\n }"}, {"sha": "559718fca546d9ab60a363be465e91bf52de066a", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/40f73e74d3d84a1f0ae89a933fa31078850a1b20/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40f73e74d3d84a1f0ae89a933fa31078850a1b20/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=40f73e74d3d84a1f0ae89a933fa31078850a1b20", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::InferCtxt;\n+use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc::ty::error::ExpectedFound;\n use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n@@ -73,7 +73,7 @@ pub struct FulfillmentContext<'tcx> {\n #[derive(Clone, Debug)]\n pub struct PendingPredicateObligation<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n-    pub stalled_on: Vec<ty::InferTy>,\n+    pub stalled_on: Vec<TyOrConstInferVar<'tcx>>,\n }\n \n // `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -266,8 +266,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n             // Match arms are in order of frequency, which matters because this\n             // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n             1 => {\n-                let infer = pending_obligation.stalled_on[0];\n-                self.selcx.infcx().infer_ty_changed(infer)\n+                let infer_var = pending_obligation.stalled_on[0];\n+                self.selcx.infcx().ty_or_const_infer_var_changed(infer_var)\n             }\n             0 => {\n                 // In this case we haven't changed, but wish to make a change.\n@@ -277,8 +277,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                 // This `for` loop was once a call to `all()`, but this lower-level\n                 // form was a perf win. See #64545 for details.\n                 (|| {\n-                    for &infer in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx().infer_ty_changed(infer) {\n+                    for &infer_var in &pending_obligation.stalled_on {\n+                        if self.selcx.infcx().ty_or_const_infer_var_changed(infer_var) {\n                             return true;\n                         }\n                     }\n@@ -309,13 +309,6 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n \n         debug!(\"process_obligation: obligation = {:?} cause = {:?}\", obligation, obligation.cause);\n \n-        fn infer_ty(ty: Ty<'tcx>) -> ty::InferTy {\n-            match ty.kind {\n-                ty::Infer(infer) => infer,\n-                _ => panic!(),\n-            }\n-        }\n-\n         match obligation.predicate {\n             ty::Predicate::Trait(ref data, _) => {\n                 let trait_obligation = obligation.with(data.clone());\n@@ -467,7 +460,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     obligation.cause.span,\n                 ) {\n                     None => {\n-                        pending_obligation.stalled_on = vec![infer_ty(ty)];\n+                        pending_obligation.stalled_on =\n+                            vec![TyOrConstInferVar::maybe_from_ty(ty).unwrap()];\n                         ProcessResult::Unchanged\n                     }\n                     Some(os) => ProcessResult::Changed(mk_pending(os)),\n@@ -483,8 +477,8 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n                     None => {\n                         // None means that both are unresolved.\n                         pending_obligation.stalled_on = vec![\n-                            infer_ty(subtype.skip_binder().a),\n-                            infer_ty(subtype.skip_binder().b),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().a).unwrap(),\n+                            TyOrConstInferVar::maybe_from_ty(subtype.skip_binder().b).unwrap(),\n                         ];\n                         ProcessResult::Unchanged\n                     }\n@@ -534,20 +528,21 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n     }\n }\n \n-/// Returns the set of type variables contained in a trait ref\n+/// Returns the set of type inference variables contained in a trait ref.\n fn trait_ref_type_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    t: ty::PolyTraitRef<'tcx>,\n-) -> Vec<ty::InferTy> {\n-    t.skip_binder() // ok b/c this check doesn't care about regions\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Vec<TyOrConstInferVar<'tcx>> {\n+    trait_ref\n+        .skip_binder() // ok b/c this check doesn't care about regions\n+        // FIXME(eddyb) walk over `GenericArg` to support const infer vars.\n         .input_types()\n-        .map(|t| selcx.infcx().resolve_vars_if_possible(&t))\n-        .filter(|t| t.has_infer_types())\n-        .flat_map(|t| t.walk())\n-        .filter_map(|t| match t.kind {\n-            ty::Infer(infer) => Some(infer),\n-            _ => None,\n-        })\n+        .map(|ty| selcx.infcx().resolve_vars_if_possible(&ty))\n+        // FIXME(eddyb) use `has_infer_types_or_const`.\n+        .filter(|ty| ty.has_infer_types())\n+        .flat_map(|ty| ty.walk())\n+        // FIXME(eddyb) use `TyOrConstInferVar::maybe_from_generic_arg`.\n+        .filter_map(TyOrConstInferVar::maybe_from_ty)\n         .collect()\n }\n "}]}