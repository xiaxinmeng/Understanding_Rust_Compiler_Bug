{"sha": "067cb6d53751b2c93d3e1ea45e7547069f865e6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2N2NiNmQ1Mzc1MWIyYzkzZDNlMWVhNDVlNzU0NzA2OWY4NjVlNmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-26T04:25:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-07-26T18:12:20Z"}, "message": "Run test process from a dedicated task\n\nThis avoids a race wherein test tasks could run processes that stole the\nenvironment of other tasks's processes.", "tree": {"sha": "ea64c5524c48b56640654faba395e4a12fc13db8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea64c5524c48b56640654faba395e4a12fc13db8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/067cb6d53751b2c93d3e1ea45e7547069f865e6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/067cb6d53751b2c93d3e1ea45e7547069f865e6a", "html_url": "https://github.com/rust-lang/rust/commit/067cb6d53751b2c93d3e1ea45e7547069f865e6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/067cb6d53751b2c93d3e1ea45e7547069f865e6a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bca34d11ef7d5f91dd0ebf438e3a99cba212e357", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca34d11ef7d5f91dd0ebf438e3a99cba212e357", "html_url": "https://github.com/rust-lang/rust/commit/bca34d11ef7d5f91dd0ebf438e3a99cba212e357"}], "stats": {"total": 217, "additions": 159, "deletions": 58}, "files": [{"sha": "31f0de97d58266d1d4111a3b79481d19ae46c073", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/067cb6d53751b2c93d3e1ea45e7547069f865e6a/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/067cb6d53751b2c93d3e1ea45e7547069f865e6a/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=067cb6d53751b2c93d3e1ea45e7547069f865e6a", "patch": "@@ -6,6 +6,7 @@ export program;\n export run_program;\n export start_program;\n export program_output;\n+export spawn_process;\n \n native \"rust\" mod rustrt {\n     fn rust_run_program(vbuf argv, int in_fd, int out_fd, int err_fd) -> int;"}, {"sha": "e3ddad7e703fc4fb4fff874b156234970d50ce90", "filename": "src/lib/task.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/067cb6d53751b2c93d3e1ea45e7547069f865e6a/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/067cb6d53751b2c93d3e1ea45e7547069f865e6a/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=067cb6d53751b2c93d3e1ea45e7547069f865e6a", "patch": "@@ -73,10 +73,12 @@ fn worker[T](fn(port[T]) f) -> rec(task task, chan[T] chan) {\n     type wordsz2 = rec(int a, int b);\n     type wordsz3 = rec(int a, int b, int c);\n     type wordsz4 = rec(int a, int b, int c, int d);\n+    type wordsz5 = rec(int a, int b, int c, int d, int e);\n     type opaquechan_1wordsz = chan[chan[wordsz1]];\n     type opaquechan_2wordsz = chan[chan[wordsz2]];\n     type opaquechan_3wordsz = chan[chan[wordsz3]];\n     type opaquechan_4wordsz = chan[chan[wordsz4]];\n+    type opaquechan_5wordsz = chan[chan[wordsz5]];\n \n     fn worktask1(opaquechan_1wordsz setupch, opaque fptr) {\n         let *fn(port[wordsz1]) f = unsafe::reinterpret_cast(fptr);\n@@ -106,6 +108,13 @@ fn worker[T](fn(port[T]) f) -> rec(task task, chan[T] chan) {\n         (*f)(p);\n     }\n \n+    fn worktask5(opaquechan_5wordsz setupch, opaque fptr) {\n+        let *fn(port[wordsz5]) f = unsafe::reinterpret_cast(fptr);\n+        auto p = port[wordsz5]();\n+        setupch <| chan(p);\n+        (*f)(p);\n+    }\n+\n     auto p = port[chan[T]]();\n     auto setupch = chan(p);\n     auto fptr = unsafe::reinterpret_cast(ptr::addr_of(f));\n@@ -123,6 +132,9 @@ fn worker[T](fn(port[T]) f) -> rec(task task, chan[T] chan) {\n     } else if Tsz == sys::size_of[wordsz4]() {\n         auto setupchptr = unsafe::reinterpret_cast(setupch);\n         spawn worktask4(setupchptr, fptr)\n+    } else if Tsz == sys::size_of[wordsz5]() {\n+        auto setupchptr = unsafe::reinterpret_cast(setupch);\n+        spawn worktask5(setupchptr, fptr)\n     } else {\n         fail #fmt(\"unhandled type size %u in task::worker\", Tsz)\n     };"}, {"sha": "2f3c6a6f953afd87f67725ea8713adad8239733c", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 146, "deletions": 58, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/067cb6d53751b2c93d3e1ea45e7547069f865e6a/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/067cb6d53751b2c93d3e1ea45e7547069f865e6a/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=067cb6d53751b2c93d3e1ea45e7547069f865e6a", "patch": "@@ -10,6 +10,7 @@ import std::generic_os::setenv;\n import std::generic_os::getenv;\n import std::os;\n import std::run;\n+import std::task;\n \n tag mode {\n     mode_compile_fail;\n@@ -138,24 +139,30 @@ fn mode_str(mode mode) -> str {\n     }\n }\n \n+type cx = rec(config config,\n+              procsrv::handle procsrv);\n+\n fn run_tests(&config config) {\n     auto opts = test_opts(config);\n-    auto tests = make_tests(config);\n+    auto cx = rec(config = config,\n+                  procsrv = procsrv::mk());\n+    auto tests = make_tests(cx);\n     test::run_tests_console(opts, tests);\n+    procsrv::close(cx.procsrv);\n }\n \n fn test_opts(&config config) -> test::test_opts {\n     rec(filter = config.filter,\n         run_ignored = config.run_ignored)\n }\n \n-fn make_tests(&config config) -> test::test_desc[] {\n-    log #fmt(\"making tests from %s\", config.src_base);\n+fn make_tests(&cx cx) -> test::test_desc[] {\n+    log #fmt(\"making tests from %s\", cx.config.src_base);\n     auto tests = ~[];\n-    for (str file in fs::list_dir(config.src_base)) {\n+    for (str file in fs::list_dir(cx.config.src_base)) {\n         log #fmt(\"inspecting file %s\", file);\n         if (is_test(file)) {\n-            tests += ~[make_test(config, file)];\n+            tests += ~[make_test(cx, file)];\n         }\n     }\n     ret tests;\n@@ -169,10 +176,10 @@ fn is_test(&str testfile) -> bool {\n          || str::starts_with(name, \"~\"))\n }\n \n-fn make_test(&config config, &str testfile) -> test::test_desc {\n+fn make_test(&cx cx, &str testfile) -> test::test_desc {\n     rec(name = testfile,\n-        fn = make_test_fn(config, testfile),\n-        ignore = is_test_ignored(config, testfile))\n+        fn = make_test_fn(cx, testfile),\n+        ignore = is_test_ignored(cx.config, testfile))\n }\n \n fn is_test_ignored(&config config, &str testfile) -> bool {\n@@ -199,22 +206,24 @@ iter iter_header(&str testfile) -> str {\n     }\n }\n \n-fn make_test_fn(&config config, &str testfile) -> test::test_fn {\n-    bind run_test(config, testfile)\n+fn make_test_fn(&cx cx, &str testfile) -> test::test_fn {\n+    auto testcx = rec(config = cx.config,\n+                      procsrv = procsrv::clone(cx.procsrv));\n+    bind run_test(testcx, testfile)\n }\n \n-fn run_test(config config, str testfile) {\n+fn run_test(cx cx, str testfile) {\n     log #fmt(\"running %s\", testfile);\n     auto props = load_props(testfile);\n-    alt (config.mode) {\n+    alt (cx.config.mode) {\n         mode_compile_fail {\n-            run_cfail_test(config, props, testfile);\n+            run_cfail_test(cx, props, testfile);\n         }\n         mode_run_fail {\n-            run_rfail_test(config, props, testfile);\n+            run_rfail_test(cx, props, testfile);\n         }\n         mode_run_pass {\n-            run_rpass_test(config, props, testfile);\n+            run_rpass_test(cx, props, testfile);\n         }\n     }\n }\n@@ -266,8 +275,8 @@ fn parse_name_value_directive(&str line, &str directive) -> option::t[str] {\n     }\n }\n \n-fn run_cfail_test(&config config, &test_props props, &str testfile) {\n-    auto procres = compile_test(config, props, testfile);\n+fn run_cfail_test(&cx cx, &test_props props, &str testfile) {\n+    auto procres = compile_test(cx, props, testfile);\n \n     if (procres.status == 0) {\n         fatal_procres(\"compile-fail test compiled successfully!\", procres);\n@@ -276,14 +285,14 @@ fn run_cfail_test(&config config, &test_props props, &str testfile) {\n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rfail_test(&config config, &test_props props, &str testfile) {\n-    auto procres = compile_test(config, props, testfile);\n+fn run_rfail_test(&cx cx, &test_props props, &str testfile) {\n+    auto procres = compile_test(cx, props, testfile);\n \n     if (procres.status != 0) {\n         fatal_procres(\"compilation failed!\", procres);\n     }\n \n-    procres = exec_compiled_test(config, testfile);\n+    procres = exec_compiled_test(cx, testfile);\n \n     if (procres.status == 0) {\n         fatal_procres(\"run-fail test didn't produce an error!\",\n@@ -293,14 +302,14 @@ fn run_rfail_test(&config config, &test_props props, &str testfile) {\n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rpass_test(&config config, &test_props props, &str testfile) {\n-    auto procres = compile_test(config, props, testfile);\n+fn run_rpass_test(&cx cx, &test_props props, &str testfile) {\n+    auto procres = compile_test(cx, props, testfile);\n \n     if (procres.status != 0) {\n         fatal_procres(\"compilation failed!\", procres);\n     }\n \n-    procres = exec_compiled_test(config, testfile);\n+    procres = exec_compiled_test(cx, testfile);\n \n     if (procres.status != 0) {\n         fatal_procres(\"test run failed!\", procres);\n@@ -346,26 +355,26 @@ type procargs = rec(str prog, vec[str] args);\n \n type procres = rec(int status, str out, str cmdline);\n \n-fn compile_test(&config config, &test_props props,\n+fn compile_test(&cx cx, &test_props props,\n                 &str testfile) -> procres {\n-    compose_and_run(config,\n+    compose_and_run(cx,\n                     testfile,\n                     bind make_compile_args(_, props, _),\n-                    config.compile_lib_path)\n+                    cx.config.compile_lib_path)\n }\n \n-fn exec_compiled_test(&config config, &str testfile) -> procres {\n-    compose_and_run(config,\n+fn exec_compiled_test(&cx cx, &str testfile) -> procres {\n+    compose_and_run(cx,\n                     testfile,\n                     make_run_args,\n-                    config.run_lib_path)\n+                    cx.config.run_lib_path)\n }\n \n-fn compose_and_run(&config config, &str testfile,\n+fn compose_and_run(&cx cx, &str testfile,\n                    fn(&config, &str) -> procargs make_args,\n                    &str lib_path) -> procres {\n-    auto procargs = make_args(config, testfile);\n-    ret program_output(config, testfile, lib_path,\n+    auto procargs = make_args(cx.config, testfile);\n+    ret program_output(cx, testfile, lib_path,\n                        procargs.prog, procargs.args);\n }\n \n@@ -396,16 +405,15 @@ fn split_maybe_args(&option::t[str] argstr) -> vec[str] {\n     }\n }\n \n-fn program_output(&config config, &str testfile,\n+fn program_output(&cx cx, &str testfile,\n                   &str lib_path, &str prog, &vec[str] args) -> procres {\n     auto cmdline = {\n         auto cmdline = make_cmdline(lib_path, prog, args);\n-        logv(config, #fmt(\"running %s\", cmdline));\n+        logv(cx.config, #fmt(\"running %s\", cmdline));\n         cmdline\n     };\n-    auto res = with_lib_path(lib_path,\n-                             bind run::program_output(prog, args));\n-    dump_output(config, testfile, res.out);\n+    auto res = procsrv::run(cx.procsrv, lib_path, prog, args);\n+    dump_output(cx.config, testfile, res.out);\n     ret rec(status = res.status,\n             out = res.out,\n             cmdline = cmdline);\n@@ -424,23 +432,6 @@ fn lib_path_cmd_prefix(&str path) -> str {\n     #fmt(\"%s=\\\"%s\\\"\", lib_path_env_var(), make_new_path(path))\n }\n \n-fn with_lib_path[T](&str path, fn() -> T f) -> T {\n-    auto maybe_oldpath = getenv(lib_path_env_var());\n-    append_lib_path(path);\n-    auto res = f();\n-    if option::is_some(maybe_oldpath) {\n-        export_lib_path(option::get(maybe_oldpath));\n-    } else {\n-        // FIXME: This should really be unset but we don't have that yet\n-        export_lib_path(\"\");\n-    }\n-    ret res;\n-}\n-\n-fn append_lib_path(&str path) {\n-    export_lib_path(make_new_path(path));\n-}\n-\n fn make_new_path(&str path) -> str {\n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n@@ -450,10 +441,6 @@ fn make_new_path(&str path) -> str {\n     }\n }\n \n-fn export_lib_path(&str path) {\n-    setenv(lib_path_env_var(), path);\n-}\n-\n #[cfg(target_os = \"linux\")]\n fn lib_path_env_var() -> str { \"LD_LIBRARY_PATH\" }\n \n@@ -524,6 +511,107 @@ fn logv(&config config, &str s) {\n     }\n }\n \n+\n+// So when running tests in parallel there's a potential race on environment\n+// variables if we let each task spawn its own children - between the time the\n+// environment is set and the process is spawned another task could spawn its\n+// child process. Because of that we have to use a complicated scheme with a\n+// dedicated server for spawning processes.\n+mod procsrv {\n+\n+    export handle;\n+    export mk;\n+    export clone;\n+    export run;\n+    export close;\n+\n+    type handle = chan[request];\n+\n+    tag request {\n+        exec(str, str, vec[str], chan[response]);\n+        stop;\n+    }\n+\n+    type response = rec(int pid, int outfd);\n+\n+    fn mk() -> handle {\n+        task::worker(worker).chan\n+    }\n+\n+    fn clone(&handle handle) -> handle {\n+        task::clone_chan(handle)\n+    }\n+\n+    fn close(&handle handle) {\n+        task::send(handle, stop);\n+    }\n+\n+    fn run(&handle handle, &str lib_path,\n+           &str prog, &vec[str] args) -> rec(int status, str out) {\n+        auto p = port[response]();\n+        auto ch = chan(p);\n+        task::send(handle,\n+                   exec(lib_path, prog, args, ch));\n+\n+        auto resp = task::recv(p);\n+        // Copied from run::program_output\n+        auto outfile = os::fd_FILE(resp.outfd);\n+        auto reader = io::new_reader(io::FILE_buf_reader(outfile, false));\n+        auto buf = \"\";\n+        while (!reader.eof()) {\n+            auto bytes = reader.read_bytes(4096u);\n+            buf += str::unsafe_from_bytes(bytes);\n+        }\n+        os::libc::fclose(outfile);\n+        ret rec(status = os::waitpid(resp.pid), out = buf);\n+    }\n+\n+    fn worker(port[request] p) {\n+        while (true) {\n+            alt task::recv(p) {\n+              exec(?lib_path, ?prog, ?args, ?respchan) {\n+                // This is copied from run::start_program\n+                auto pipe_in = os::pipe();\n+                auto pipe_out = os::pipe();\n+                auto spawnproc = bind run::spawn_process(\n+                    prog, args, pipe_in.in, pipe_out.out, 0);\n+                auto pid = with_lib_path(lib_path, spawnproc);\n+                if (pid == -1) { fail; }\n+                os::libc::close(pipe_in.in);\n+                os::libc::close(pipe_in.out);\n+                os::libc::close(pipe_out.out);\n+                task::send(respchan, rec(pid = pid,\n+                                         outfd = pipe_out.in));\n+              }\n+              stop {\n+                ret;\n+              }\n+            }\n+        }\n+    }\n+\n+    fn with_lib_path[T](&str path, fn() -> T f) -> T {\n+        auto maybe_oldpath = getenv(lib_path_env_var());\n+        append_lib_path(path);\n+        auto res = f();\n+        if option::is_some(maybe_oldpath) {\n+            export_lib_path(option::get(maybe_oldpath));\n+        } else {\n+            // FIXME: This should really be unset but we don't have that yet\n+            export_lib_path(\"\");\n+        }\n+        ret res;\n+    }\n+\n+    fn append_lib_path(&str path) {\n+        export_lib_path(make_new_path(path));\n+    }\n+\n+    fn export_lib_path(&str path) {\n+        setenv(lib_path_env_var(), path);\n+    }\n+}\n+\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil"}]}