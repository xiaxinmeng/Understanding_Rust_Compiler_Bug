{"sha": "7c04b3c5bd5b7e6fe70273d3e021818f86da4967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMDRiM2M1YmQ1YjdlNmZlNzAyNzNkM2UwMjE4MThmODZkYTQ5Njc=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-10-05T13:48:38Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-10-05T23:58:56Z"}, "message": "flesh out BTree docs", "tree": {"sha": "809ee44b446dde4876e0fceeb6cfa772bbd93b73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/809ee44b446dde4876e0fceeb6cfa772bbd93b73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c04b3c5bd5b7e6fe70273d3e021818f86da4967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c04b3c5bd5b7e6fe70273d3e021818f86da4967", "html_url": "https://github.com/rust-lang/rust/commit/7c04b3c5bd5b7e6fe70273d3e021818f86da4967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c04b3c5bd5b7e6fe70273d3e021818f86da4967/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79c21d9e7950e0ad16e0babeb040143419da31ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/79c21d9e7950e0ad16e0babeb040143419da31ef", "html_url": "https://github.com/rust-lang/rust/commit/79c21d9e7950e0ad16e0babeb040143419da31ef"}], "stats": {"total": 48, "additions": 48, "deletions": 0}, "files": [{"sha": "a061f9dcaef604bd9c2a520657b87f4a99cb758a", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c04b3c5bd5b7e6fe70273d3e021818f86da4967/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c04b3c5bd5b7e6fe70273d3e021818f86da4967/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=7c04b3c5bd5b7e6fe70273d3e021818f86da4967", "patch": "@@ -29,6 +29,47 @@ use ringbuf::RingBuf;\n \n \n /// A map based on a B-Tree.\n+///\n+/// B-Trees represent a fundamental compromise between cache-efficiency and actually minimizing\n+/// the amount of work performed in a search. In theory, a binary search tree (BST) is the optimal\n+/// choice for a sorted map, as a perfectly balanced BST performs the theoretical minimum amount of\n+/// comparisons necessary to find an element (log<sub>2</sub>n). However, in practice the way this\n+/// is done is *very* inefficient for modern computer architectures. In particular, every element\n+/// is stored in its own individually heap-allocated node. This means that every single insertion\n+/// triggers a heap-allocation, and every single comparison should be a cache-miss. Since these\n+/// are both notably expensive things to do in practice, we are forced to at very least reconsider\n+/// the BST strategy.\n+///\n+/// A B-Tree instead makes each node contain B-1 to 2B-1 elements in a contiguous array. By doing\n+/// this, we reduce the number of allocations by a factor of B, and improve cache effeciency in\n+/// searches. However, this does mean that searches will have to do *more* comparisons on average.\n+/// The precise number of comparisons depends on the node search strategy used. For optimal cache\n+/// effeciency, one could search the nodes linearly. For optimal comparisons, one could search\n+/// search the node using binary search. As a compromise, one could also perform a linear search\n+/// that initially only checks every i<sup>th</sup> element for some choice of i.\n+///\n+/// Currently, our implementation simply performs naive linear search. This provides excellent\n+/// performance on *small* nodes of elements which are cheap to compare. However in the future we\n+/// would like to further explore choosing the optimal search strategy based on the choice of B,\n+/// and possibly other factors. Using linear search, searching for a random element is expected\n+/// to take O(Blog<sub>B</sub>n) comparisons, which is generally worse than a BST. In practice,\n+/// however, performance is excellent. `BTreeMap` is able to readily outperform `TreeMap` under\n+/// many workloads, and is competetive where it doesn't. BTreeMap also generally *scales* better\n+/// than TreeMap, making it more appropriate for large datasets.\n+///\n+/// However, `TreeMap` may still be more appropriate to use in many contexts. If elements are very\n+/// large or expensive to compare, `TreeMap` may be more appropriate. It won't allocate any\n+/// more space than is needed, and will perform the minimal number of comparisons necessary.\n+/// `TreeMap` also provides much better performance stability guarantees. Generally, very few\n+/// changes need to be made to update a BST, and two updates are expected to take about the same\n+/// amount of time on roughly equal sized BSTs. However a B-Tree's performance is much more\n+/// amortized. If a node is overfull, it must be split into two nodes. If a node is underfull, it\n+/// may be merged with another. Both of these operations are relatively expensive to perform, and\n+/// it's possible to force one to occur at every single level of the tree in a single insertion or\n+/// deletion. In fact, a malicious or otherwise unlucky sequence of insertions and deletions can\n+/// force this degenerate behaviour to occur on every operation. While the total amount of work\n+/// done on each operation isn't *catastrophic*, and *is* still bounded by O(Blog<sub>B</sub>n),\n+/// it is certainly much slower when it does.\n #[deriving(Clone)]\n pub struct BTreeMap<K, V> {\n     root: Node<K, V>,\n@@ -93,6 +134,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n \n     /// Makes a new empty BTreeMap with the given B.\n+    ///\n+    /// B cannot be less than 2.\n     pub fn with_b(b: uint) -> BTreeMap<K, V> {\n         assert!(b > 1, \"B must be greater than 1\");\n         BTreeMap {"}, {"sha": "8958f0ef5bee749eee1b7f391fffda60918c5e7c", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c04b3c5bd5b7e6fe70273d3e021818f86da4967/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c04b3c5bd5b7e6fe70273d3e021818f86da4967/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=7c04b3c5bd5b7e6fe70273d3e021818f86da4967", "patch": "@@ -23,6 +23,9 @@ use core::fmt::Show;\n use {Mutable, Set, MutableSet, MutableMap, Map};\n \n /// A set based on a B-Tree.\n+///\n+/// See BTreeMap's documentation for a detailed discussion of this collection's performance\n+/// benefits and drawbacks.\n #[deriving(Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]\n pub struct BTreeSet<T>{\n     map: BTreeMap<T, ()>,\n@@ -65,6 +68,8 @@ impl<T: Ord> BTreeSet<T> {\n     }\n \n     /// Makes a new BTreeSet with the given B.\n+    ///\n+    /// B cannot be less than 2.\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n     }"}]}