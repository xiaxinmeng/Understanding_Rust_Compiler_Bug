{"sha": "daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhZWE5ZjRhZDliZDhhMzkxZWIyODNmY2M2ZjhlOTdlOTQzYzYzNDI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-04T22:27:21Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-07-08T16:16:58Z"}, "message": "Guide: match", "tree": {"sha": "3e4c03bbe4643e82031ade6ca5e1a7db3c253b47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e4c03bbe4643e82031ade6ca5e1a7db3c253b47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "html_url": "https://github.com/rust-lang/rust/commit/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e2ca0dfad8f2aff48c64887b1ec4276929eced", "html_url": "https://github.com/rust-lang/rust/commit/c9e2ca0dfad8f2aff48c64887b1ec4276929eced"}], "stats": {"total": 96, "additions": 96, "deletions": 0}, "files": [{"sha": "070dba8956d4d998ea3a17452f6832993223b704", "filename": "src/doc/guide.md", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/daea9f4ad9bd8a391eb283fcc6f8e97e943c6342/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=daea9f4ad9bd8a391eb283fcc6f8e97e943c6342", "patch": "@@ -956,6 +956,102 @@ Enums\n \n ## Match\n \n+Often, a simple `if`/`else` isn't enough, because you have more than two\n+possible options. And `else` conditions can get incredibly complicated. So\n+what's the solution?\n+\n+Rust has a keyword, `match`, that allows you to replace complicated `if`/`else`\n+groupings with something more powerful. Check it out:\n+\n+```rust\n+let x = 5i;\n+\n+match x {\n+    1 => println!(\"one\"),\n+    2 => println!(\"two\"),\n+    3 => println!(\"three\"),\n+    4 => println!(\"four\"),\n+    5 => println!(\"five\"),\n+    _ => println!(\"something else\"),\n+}\n+```\n+\n+`match` takes an expression, and then branches based on its value. Each 'arm' of\n+the branch is of the form `val => expression`. When the value matches, that arm's\n+expression will be evaluated. It's called `match` because of the term 'pattern\n+matching,' which `match` is an implementation of.\n+\n+So what's the big advantage here? Well, there are a few. First of all, `match`\n+does 'exhaustiveness checking.' Do you see that last arm, the one with the\n+underscore (`_`)? If we remove that arm, Rust will give us an error:\n+\n+```{ignore,notrust}\n+error: non-exhaustive patterns: `_` not covered\n+```\n+\n+In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n+integer, Rust knows that it can have a number of different values. For example,\n+`6i`. But without the `_`, there is no arm that could match, and so Rust refuses\n+to compile. `_` is sort of like a catch-all arm. If none of the other arms match,\n+the arm with `_` will. And since we have this catch-all arm, we now have an arm\n+for every possible value of `x`, and so our program will now compile.\n+\n+`match` statements also destructure enums, as well. Remember this code from the\n+section on enums?\n+\n+```{rust}\n+let x = 5i;\n+let y = 10i;\n+\n+let ordering = x.cmp(&y);\n+\n+if ordering == Less {\n+    println!(\"less\");\n+} else if ordering == Greater {\n+    println!(\"greater\");\n+} else if ordering == Equal {\n+    println!(\"equal\");\n+}\n+```\n+\n+We can re-write this as a `match`:\n+\n+```{rust}\n+let x = 5i;\n+let y = 10i;\n+\n+match x.cmp(&y) {\n+    Less    => println!(\"less\"),\n+    Greater => println!(\"greater\"),\n+    Equal   => println!(\"equal\"),\n+}\n+```\n+\n+This version has way less noise, and it also checks exhaustively to make sure\n+that we have covered all possible variants of `Ordering`. With our `if`/`else`\n+version, if we had forgotten the `Greater` case, for example, our program would\n+have happily compiled. If we forget in the `match`, it will not. Rust helps us\n+make sure to cover all of our bases.\n+\n+`match` is also an expression, which means we can use it on the right hand side\n+of a `let` binding. We could also implement the previous line like this:\n+\n+```\n+let x = 5i;\n+let y = 10i;\n+\n+let result = match x.cmp(&y) {\n+    Less    => \"less\",\n+    Greater => \"greater\",\n+    Equal   => \"equal\",\n+};\n+\n+println!(\"{}\", result);\n+```\n+\n+In this case, it doesn't make a lot of sense, as we are just making a temporary\n+string where we don't need to, but sometimes, it's a nice pattern.\n+\n ## Looping\n \n for"}]}