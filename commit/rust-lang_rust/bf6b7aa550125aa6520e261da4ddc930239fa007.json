{"sha": "bf6b7aa550125aa6520e261da4ddc930239fa007", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNmI3YWE1NTAxMjVhYTY1MjBlMjYxZGE0ZGRjOTMwMjM5ZmEwMDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-19T17:53:42Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-19T17:53:42Z"}, "message": "rewirte development part of README", "tree": {"sha": "b8291524a4b93badc1d770a0da07b9d9ab2d62f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8291524a4b93badc1d770a0da07b9d9ab2d62f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf6b7aa550125aa6520e261da4ddc930239fa007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf6b7aa550125aa6520e261da4ddc930239fa007", "html_url": "https://github.com/rust-lang/rust/commit/bf6b7aa550125aa6520e261da4ddc930239fa007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf6b7aa550125aa6520e261da4ddc930239fa007/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2481d6091ac59bec4e54be04b7361596c80412df", "url": "https://api.github.com/repos/rust-lang/rust/commits/2481d6091ac59bec4e54be04b7361596c80412df", "html_url": "https://github.com/rust-lang/rust/commit/2481d6091ac59bec4e54be04b7361596c80412df"}], "stats": {"total": 119, "additions": 66, "deletions": 53}, "files": [{"sha": "eb86d5b2ee31725debe3929fd5215021036a1fd1", "filename": "README.md", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/bf6b7aa550125aa6520e261da4ddc930239fa007/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf6b7aa550125aa6520e261da4ddc930239fa007/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=bf6b7aa550125aa6520e261da4ddc930239fa007", "patch": "@@ -113,90 +113,100 @@ find useful.\n ### Using a nightly rustc\n \n Miri heavily relies on internal rustc interfaces to execute MIR.  Still, some\n-things (like adding support for a new intrinsic) can be done by working just on\n-the Miri side.\n+things (like adding support for a new intrinsic or a shim for an external\n+function being called) can be done by working just on the Miri side.\n \n-To prepare, make sure you are using a nightly Rust compiler.  The most\n-convenient way is to install Miri using cargo, then you can easily run it on\n-other projects:\n-\n-```sh\n-rustup component remove miri # avoid having Miri installed twice\n-cargo +nightly install --path \"$DIR\" --force\n-cargo +nightly miri setup\n-```\n-\n-(We are giving `+nightly` explicitly here all the time because it is important\n-that all of these commands get executed with the same toolchain.)\n+To prepare, make sure you are using a nightly Rust compiler.  Then you should be\n+able to just `cargo build` Miri.\n \n In case this fails, your nightly might be incompatible with Miri master.  The\n `rust-version` file contains the commit hash of rustc that Miri is currently\n tested against; you can use that to find a nightly that works or you might have\n to wait for the next nightly to get released.\n \n-If you want to use a different libstd (not the one that comes with the\n-nightly), you can do that by running\n+### Testing the Miri driver\n+[testing-miri]: #testing-the-miri-driver\n \n-```sh\n-XARGO_RUST_SRC=~/src/rust/rustc/src/ cargo +nightly miri setup\n+The Miri driver in the `miri` binary is the \"heart\" of Miri: it is basically a\n+version of `rustc` that, instead of compiling your code, runs it.  It accepts\n+all the same flags as `rustc` (though the ones only affecting code generation\n+and linking obviously will have no effect) [and more][miri-flags].\n+\n+To run the Miri driver, you need to have the `MIRI_SYSROOT` environment variable\n+set to an appropriate sysroot.  You can generate such a sysroot with the\n+following incantation:\n+\n+```\n+cargo run --bin cargo-miri -- miri setup\n ```\n \n-Either way, you can now do `cargo +nightly miri run` to run Miri with your\n-local changes on whatever project you are debugging.\n+This basically runs the `cargo-miri` binary (which backs the `cargo miri`\n+subcommand) with `cargo`, and asks it to `setup`.  It should in the end print\n+the directory where the libstd was built.  In the following, we will assume it\n+is `~/.cache/miri/HOST`; you may have to adjust that if you are not using Linux.\n \n-`cargo miri setup` should end in printing the directory where the libstd was\n-built.  For the next step to work, set that as your `MIRI_SYSROOT` environment\n-variable:\n+Now you can run the driver directly using\n \n ```sh\n-export MIRI_SYSROOT=~/.cache/miri/HOST # or whatever the previous command said\n+MIRI_SYSROOT=~/.cache/miri/HOST cargo run tests/run-pass/format.rs # or whatever test you like\n ```\n \n-### Testing Miri\n+and you can run the test suite using\n \n-Instead of running an entire project using `cargo miri`, you can also use the\n-Miri \"driver\" directly to run just a single file.  That can be easier during\n-debugging.\n-\n-```sh\n-cargo run tests/run-pass/format.rs # or whatever test you like\n ```\n+cargo test\n+```\n+\n+We recommend adding the `--release` flag to make tests run faster.\n \n-You can also run the test suite with `cargo test --release`.  `cargo test\n---release FILTER` only runs those tests that contain `FILTER` in their filename\n-(including the base directory, e.g. `cargo test --release fail` will run all\n-compile-fail tests).  We recommend using `--release` to make test running take\n-less time.\n+`cargo test --release FILTER` only runs those tests that contain `FILTER` in\n+their filename (including the base directory, e.g. `cargo test --release fail`\n+will run all compile-fail tests).\n \n-Now you are set up!  You can write a failing test case, and tweak miri until it\n-fails no more.\n You can get a trace of which MIR statements are being executed by setting the\n `MIRI_LOG` environment variable.  For example:\n \n ```sh\n MIRI_LOG=info cargo run tests/run-pass/vecs.rs\n ```\n \n-Setting `MIRI_LOG` like this will configure logging for miri itself as well as\n+Setting `MIRI_LOG` like this will configure logging for Miri itself as well as\n the `rustc::mir::interpret` and `rustc_mir::interpret` modules in rustc.  You\n-can also do more targeted configuration, e.g. to debug the stacked borrows\n-implementation:\n+can also do more targeted configuration, e.g. the following helps debug the\n+stacked borrows implementation:\n+\n ```sh\n MIRI_LOG=rustc_mir::interpret=info,miri::stacked_borrows cargo run tests/run-pass/vecs.rs\n ```\n \n In addition, you can set `MIRI_BACKTRACE=1` to get a backtrace of where an\n-evaluation error was originally created.\n+evaluation error was originally raised.\n+\n+### Testing `cargo miri`\n+\n+Working with the driver directly gives you full control, but you also lose all\n+the convenience provided by cargo.  Once your test case depends on a crate, it\n+is probably easier to test it with the cargo wrapper.  You can install your\n+development version of Miri using\n+\n+```\n+cargo install --path . --force\n+```\n+\n+and then you can use it as if it was installed by `rustup`.  Make sure you use\n+the same toolchain when calling `cargo miri` that you used when installing Miri!\n \n+There's a test for the cargo wrapper in the `test-cargo-miri` directory; run\n+`./run-test.py` in there to execute it.\n \n ### Using a locally built rustc\n \n-Since the heart of Miri (the main interpreter engine) lives in rustc, working on\n-Miri will often require using a locally built rustc.  The bug you want to fix\n-may actually be on the rustc side, or you just need to get more detailed trace\n-of the execution than what is possible with release builds -- in both cases, you\n-should develop miri against a rustc you compiled yourself, with debug assertions\n-(and hence tracing) enabled.\n+A big part of the Miri driver lives in rustc, so working on Miri will sometimes\n+require using a locally built rustc.  The bug you want to fix may actually be on\n+the rustc side, or you just need to get more detailed trace of the execution\n+than what is possible with release builds -- in both cases, you should develop\n+miri against a rustc you compiled yourself, with debug assertions (and hence\n+tracing) enabled.\n \n The setup for a local rustc works as follows:\n ```sh\n@@ -216,18 +226,21 @@ rustup override set custom\n ```\n \n With this, you should now have a working development setup!  See\n-[\"Testing Miri\"](#testing-miri) above for how to proceed.\n+[above][testing-miri] for how to proceed working with the Miri driver.  Notice\n+that rustc's sysroot is already built for Miri in this case, so you can set\n+`MIRI_SYSROOT=$(rustc --print sysroot)`.\n \n Running `cargo miri` in this setup is a bit more complicated, because the Miri\n-binary you just created does not actually run without some environment variables.\n-But you can contort cargo into calling `cargo miri` the right way for you:\n+binary you just created needs help to find the libraries it links against.  On\n+Linux, you can set the rpath to make this \"just work\":\n \n ```sh\n-# in some other project's directory, to run `cargo miri test`:\n-MIRI_SYSROOT=$(rustc +custom --print sysroot) cargo +custom run --manifest-path /path/to/miri/Cargo.toml --bin cargo-miri --release -- miri test\n+export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/lib\"\n+cargo install --path . --force\n ```\n \n ### Miri `-Z` flags and environment variables\n+[miri-flags]: #miri--z-flags-and-environment-variables\n \n Several `-Z` flags are relevant for Miri:\n "}]}