{"sha": "78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YTVkNWI1NGUwZmY5MWJkYTg1MThkZjdlZDk2NzNjYzY1N2E0ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-12T00:19:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-12T00:19:13Z"}, "message": "Auto merge of #31123 - alexcrichton:who-doesnt-want-two-build-systems, r=brson\n\nThis series of commits adds the initial implementation of a new build system for\nthe compiler and standard library based on Cargo. The high-level architecture\nnow looks like:\n\n1. The `./configure` script is run with `--enable-rustbuild` and other standard\n   configuration options.\n2. A `Makefile` is generate which proxies commands to the new build system.\n3. The new build system has a Python script entry point which manages\n   downloading both a Rust and Cargo nightly. This initial script also manages\n   building the build system itself (which is written in Rust).\n4. The build system, written in rust and called `bootstrap`, architects how to\n   call `cargo` and manages building all native libraries and such.\n\nOne might reasonably ask \"why rewrite the build system?\", which is a good\nquestion! The Rust project has used Makefiles for as long as I can remember at\nleast, and while ugly and difficult to use are undeniably robust as they contain\nyears worth of tweaking and tuning for working on as many platforms in as many\nsituation as possible. The rationale behind this PR, however is:\n\n* The makefiles are impenetrable to all but a few people on this\n  planet. This means that contributions to the build system are almost\n  nonexistent, and furthermore if a build system change is needed it's\n  incredibly difficult to figure out how to do so. This hindrance prevents us\n  from doing some \"perhaps fancier\" things we may wish to do in make.\n\n* Our build system, while portable, is unfortunately not infinitely portable\n  everywhere.  For example the recently-introduced MSVC target is quite unlikely\n  to have `make` installed by default (e.g. it requires building inside of an\n  MSYS2 shell currently). Conversely, the portability of make comes at a cost of\n  crazy and weird hacks to work around all sorts of versions of software\n  everywhere, especially when it comes to the configure script and makefiles.\n  By rewriting this logic in one of the most robust platforms there is, Rust,\n  we get to assuage all of these worries for free!\n\n* There's a standard tool to build Rust crates, Cargo, but the standard library\n  and compiler don't use it. This means that they cannot benefit easily from the\n  crates.io ecosystem, nor can the ecosystem benefit from a standard way to\n  build this repository itself. Moving to Cargo should help assuage both of\n  these needs. This has the added benefit of making the compiler more\n  approachable for newbies as working on the compiler will just happen to be\n  working on a large Cargo project, all the same standard tools and tricks will\n  apply.\n\n* There's a huge amount of portability information in the main distribution, for\n  example around cross compiling, compiling on new OSes, etc. Pushing this logic\n  into standard crates (like `gcc`) enables the community to immediately benefit\n  from new build logic.\n\nDespite these benefits, it's going to be a long road to actually replace our\ncurrent build system. This PR is just the beginning and doesn't implement the\nfull suite of functionality as the current one, but there are many more to\nfollow! The current implementation strategy hopes to look like:\n\n1. Land a second build system in-tree that can be itereated on an and\n   contributed to. This will not be used just yet in terms of gating new commits\n   to the repo.\n2. Over time, bring the second build system to feature parity with the old build\n   system, start setting up CI for both build systems.\n3. At some point in the future, switch the default to the new build system, but\n   keep the old one around.\n4. At some further point in the future, delete the entire old build system.\n\n---\n\nAlright, so with all that out of the way, here's some more info on this PR\nitself. The inital build system here is contained in the `src/bootstrap`\ndirectory and just adds the necessary minimum bits to bootstrap the compiler\nitself. There is currently no support for building documentation, running tests,\nor installing, but the implemented support is:\n\n* Compiling LLVM with `cmake` instead of `./configure` + `make`. The LLVM\n  project is removing their autotools build system, so we'd have to make this\n  transition eventually anyway.\n\n* Compiling compiler-rt with `cmake` as well (for the same rationale as above).\n\n* Adding `Cargo.toml` to map out the dependency graph to all crates, and also\n  adding `build.rs` files where appropriate. For example `alloc_jemalloc` has a\n  script to build jemalloc, `flate` has a script to build `miniz.c`, `std` will\n  build `libbacktrace`, etc.\n\n* Orchestrating all the calls to `cargo` to build the standard distribution,\n  following the normal bootstrapping process. This also tracks dependencies\n  between steps to ensure cross-compilation targets happen as well.\n\n* Configuration is intended to eventually be done through a `config.toml` file,\n  so support is implemented for this. The most likely vector of configuration\n  for now, however, is likely through `config.mk` (what `./configure` emits), so\n  the build system currently parses this information.\n\nThere's still quite a few steps left to do, and I'll open up some follow-up\nissues (as well as a tracking issue) for this migration, but hopefully this is a\ngreat start to get going! This PR is currently tested on all the\nWindows/Linux/OSX triples for x86\\_64 and x86, but more portability is always\nwelcome!\n\n---\n\nFuture functionality left to implement\n\n* [ ] Re-verify that multi-host builds work\n* [ ] Verify android build works\n* [ ] Verify iOS build work (mostly compiler-rt)\n* [ ] Verify sha256 and ideally gpg of downloaded nightly compiler and nightly rustc\n* [ ] Implement testing -- this is a huge bullet point with lots of sub-bullets\n* [ ] Build and generate documentation (plus the various tools we have in-tree)\n* [ ] Move various src/etc scripts into Rust -- not sure how this interacts with `make` build system\n* [ ] Implement `make install` - like testing this is also quite massive\n* [x] Deduplicate version information with makefiles", "tree": {"sha": "2dc5ef96a9649578b8bf41b417a22b1f61fea215", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dc5ef96a9649578b8bf41b417a22b1f61fea215"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "html_url": "https://github.com/rust-lang/rust/commit/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98ec51a4ddc5519f809d667e7dbbf636d59ab653", "url": "https://api.github.com/repos/rust-lang/rust/commits/98ec51a4ddc5519f809d667e7dbbf636d59ab653", "html_url": "https://github.com/rust-lang/rust/commit/98ec51a4ddc5519f809d667e7dbbf636d59ab653"}, {"sha": "55dd595c081f76c90f212811ccb55fdf0861784b", "url": "https://api.github.com/repos/rust-lang/rust/commits/55dd595c081f76c90f212811ccb55fdf0861784b", "html_url": "https://github.com/rust-lang/rust/commit/55dd595c081f76c90f212811ccb55fdf0861784b"}], "stats": {"total": 4693, "additions": 4598, "deletions": 95}, "files": [{"sha": "b6f5f04bff62fc209f6f42654cba6079df8270ef", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -93,3 +93,4 @@ tmp.*.rs\n version.md\n version.ml\n version.texi\n+/target"}, {"sha": "7958ac9bfcfe3a5f4e24ed84637d09d0175e2659", "filename": "configure", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/configure", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -606,6 +606,7 @@ opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n+opt rustbuild 0 \"use the rust and cargo based build system\"\n \n # Optimization and debugging options. These may be overridden by the release channel, etc.\n opt_nosave optimize 1 \"build optimized rust code\"\n@@ -625,7 +626,7 @@ valopt llvm-root \"\" \"set LLVM root\"\n valopt python \"\" \"set path to python\"\n valopt jemalloc-root \"\" \"set directory where libjemalloc_pic.a is located\"\n valopt build \"${DEFAULT_BUILD}\" \"GNUs ./configure syntax LLVM build triple\"\n-valopt android-cross-path \"/opt/ndk_standalone\" \"Android NDK standalone path (deprecated)\"\n+valopt android-cross-path \"\" \"Android NDK standalone path (deprecated)\"\n valopt i686-linux-android-ndk \"\" \"i686-linux-android NDK standalone path\"\n valopt arm-linux-androideabi-ndk \"\" \"arm-linux-androideabi NDK standalone path\"\n valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n@@ -1422,7 +1423,7 @@ done\n step_msg \"configuring submodules\"\n \n # Have to be in the top of src directory for this\n-if [ -z $CFG_DISABLE_MANAGE_SUBMODULES ]\n+if [ -z $CFG_DISABLE_MANAGE_SUBMODULES ] && [ -z $CFG_ENABLE_RUSTBUILD ]\n then\n     cd ${CFG_SRC_DIR}\n \n@@ -1481,7 +1482,11 @@ do\n         ;;\n     esac\n \n-    if [ -z $CFG_LLVM_ROOT ]\n+    if [ -n \"$CFG_ENABLE_RUSTBUILD\" ]\n+    then\n+        msg \"not configuring LLVM, rustbuild in use\"\n+        do_reconfigure=0\n+    elif [ -z $CFG_LLVM_ROOT ]\n     then\n         LLVM_BUILD_DIR=${CFG_BUILD_DIR}$t/llvm\n         if [ -n \"$CFG_DISABLE_OPTIMIZE_LLVM\" ]\n@@ -1812,8 +1817,15 @@ do\n     putvar $CFG_LLVM_INST_DIR\n done\n \n+if [ -n \"$CFG_ENABLE_RUSTBUILD\" ]\n+then\n+    INPUT_MAKEFILE=src/bootstrap/mk/Makefile.in\n+else\n+    INPUT_MAKEFILE=Makefile.in\n+fi\n+\n msg\n-copy_if_changed ${CFG_SRC_DIR}Makefile.in ./Makefile\n+copy_if_changed ${CFG_SRC_DIR}${INPUT_MAKEFILE} ./Makefile\n move_if_changed config.tmp config.mk\n rm -f config.tmp\n touch config.stamp"}, {"sha": "bfd054ae988f2f6d2743c21756862eafc8c0b930", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -144,8 +144,7 @@ TARGET_CRATES += alloc_jemalloc\n DEPS_std += alloc_jemalloc\n DEPS_alloc_jemalloc := core libc native:jemalloc\n ONLY_RLIB_alloc_jemalloc := 1\n-else\n-RUSTFLAGS_rustc_back := --cfg disable_jemalloc\n+RUSTFLAGS_rustc_back := --cfg 'feature=\"jemalloc\"'\n endif\n \n ################################################################################"}, {"sha": "2bdbef35badf90110721e643523465b2dd03eb5c", "filename": "mk/llvm.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/mk%2Fllvm.mk", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/mk%2Fllvm.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fllvm.mk?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -102,7 +102,7 @@ $(foreach host,$(CFG_HOST), \\\n define LLVM_LINKAGE_DEPS\n $$(TLIB$(1)_T_$(2)_H_$(3))/stamp.rustc_llvm: $$(LLVM_LINKAGE_PATH_$(2))\n RUSTFLAGS$(1)_rustc_llvm_T_$(2) += $$(shell echo $$(LLVM_ALL_COMPONENTS_$(2)) | tr '-' '_' |\\\n-\tsed -e 's/^ //;s/\\([^ ]*\\)/\\-\\-cfg have_component_\\1/g')\n+\tsed -e 's/^ //;s/\\([^ ]*\\)/\\-\\-cfg \"llvm_component=\\\\\"\\1\\\\\"\"/g')\n endef\n \n $(foreach source,$(CFG_HOST), \\"}, {"sha": "f9593eb1609d8bb10bff8696298ecdff3c273b4d", "filename": "src/bootstrap/Cargo.lock", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,109 @@\n+[root]\n+name = \"bootstrap\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"cmake 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"filetime 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"gcc 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 0.2.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"cmake\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"gcc 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"filetime\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"num_cpus\"\n+version = \"0.2.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"kernel32-sys 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc-serialize\"\n+version = \"0.3.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.1.23\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"rustc-serialize 0.3.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+"}, {"sha": "8321f93c90f61f23e039ffda2cc0b8e73cee57c5", "filename": "src/bootstrap/Cargo.toml", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,29 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"bootstrap\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"bootstrap\"\n+path = \"lib.rs\"\n+\n+[[bin]]\n+name = \"bootstrap\"\n+path = \"main.rs\"\n+\n+[[bin]]\n+name = \"rustc\"\n+path = \"rustc.rs\"\n+\n+[dependencies]\n+build_helper = { path = \"../build_helper\" }\n+cmake = \"0.1.10\"\n+filetime = \"0.1\"\n+num_cpus = \"0.2\"\n+toml = \"0.1\"\n+getopts = \"0.2\"\n+rustc-serialize = \"0.3\"\n+winapi = \"0.2\"\n+kernel32-sys = \"0.2\"\n+gcc = \"0.3.17\"\n+libc = \"0.2\""}, {"sha": "9e97ec4da0769ecd5d6ef5fd0ba186f385b306c4", "filename": "src/bootstrap/README.md", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,110 @@\n+# Bootstrapping Rust\n+\n+This is an in-progress README which is targeted at helping to explain how Rust\n+is bootstrapped and in general some of the technical details of the build\n+system.\n+\n+> **Note**: This build system is currently under active development and is not\n+> intended to be the primarily used one just yet. The makefiles are currently\n+> the ones that are still \"guaranteed to work\" as much as possible at least.\n+\n+## Using the new build system\n+\n+When configuring Rust via `./configure`, pass the following to enable building\n+via this build system:\n+\n+```\n+./configure --enable-rustbuild\n+```\n+\n+## ...\n+\n+## Directory Layout\n+\n+This build system houses all output under the `target` directory, which looks\n+like this:\n+\n+```\n+# Root folder of all output. Everything is scoped underneath here\n+build/\n+\n+  # Location where the stage0 compiler downloads are all cached. This directory\n+  # only contains the tarballs themselves as they're extracted elsewhere.\n+  cache/\n+    2015-12-19/\n+    2016-01-15/\n+    2016-01-21/\n+    ...\n+\n+  # Output directory for building this build system itself. The stage0\n+  # cargo/rustc are used to build the build system into this location.\n+  bootstrap/\n+    debug/\n+    release/\n+\n+  # Each remaining directory is scoped by the \"host\" triple of compilation at\n+  # hand.\n+  x86_64-unknown-linux-gnu/\n+\n+    # The build artifacts for the `compiler-rt` library for the target this\n+    # folder is under. The exact layout here will likely depend on the platform,\n+    # and this is also built with CMake so the build system is also likely\n+    # different.\n+    compiler-rt/build/\n+\n+    # Output folder for LLVM if it is compiled for this target\n+    llvm/\n+\n+      # build folder (e.g. the platform-specific build system). Like with\n+      # compiler-rt this is compiled with CMake\n+      build/\n+\n+      # Installation of LLVM. Note that we run the equivalent of 'make install'\n+      # for LLVM to setup these folders.\n+      bin/\n+      lib/\n+      include/\n+      share/\n+      ...\n+\n+    # Location where the stage0 Cargo and Rust compiler are unpacked. This\n+    # directory is purely an extracted and overlaid tarball of these two (done\n+    # by the bootstrapy python script). In theory the build system does not\n+    # modify anything under this directory afterwards.\n+    stage0/\n+\n+    # These to build directories are the cargo output directories for builds of\n+    # the standard library and compiler, respectively. Internally these may also\n+    # have other target directories, which represent artifacts being compiled\n+    # from the host to the specified target.\n+    #\n+    # Essentially, each of these directories is filled in by one `cargo`\n+    # invocation. The build system instruments calling Cargo in the right order\n+    # with the right variables to ensure these are filled in correctly.\n+    stageN-std/\n+    stageN-rustc/\n+\n+    # This is a special case of the above directories, **not** filled in via\n+    # Cargo but rather the build system itself. The stage0 compiler already has\n+    # a set of target libraries for its own host triple (in its own sysroot)\n+    # inside of stage0/. When we run the stage0 compiler to bootstrap more\n+    # things, however, we don't want to use any of these libraries (as those are\n+    # the ones that we're building). So essentially, when the stage1 compiler is\n+    # being compiled (e.g. after libstd has been built), *this* is used as the\n+    # sysroot for the stage0 compiler being run.\n+    #\n+    # Basically this directory is just a temporary artifact use to configure the\n+    # stage0 compiler to ensure that the libstd we just built is used to\n+    # compile the stage1 compiler.\n+    stage0-rustc/lib/\n+\n+    # These output directories are intended to be standalone working\n+    # implementations of the compiler (corresponding to each stage). The build\n+    # system will link (using hard links) output from stageN-{std,rustc} into\n+    # each of these directories.\n+    #\n+    # In theory there is no extra build output in these directories.\n+    stage1/\n+    stage2/\n+    stage3/\n+```"}, {"sha": "744c30aa08f07f9603abc4c32fd6041c69e74a40", "filename": "src/bootstrap/bootstrap.py", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,316 @@\n+# Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import argparse\n+import contextlib\n+import os\n+import shutil\n+import subprocess\n+import sys\n+import tarfile\n+\n+def get(url, path, verbose=False):\n+    print(\"downloading \" + url)\n+    # see http://serverfault.com/questions/301128/how-to-download\n+    if sys.platform == 'win32':\n+        run([\"PowerShell.exe\", \"/nologo\", \"-Command\",\n+             \"(New-Object System.Net.WebClient).DownloadFile('\" + url +\n+                \"', '\" + path + \"')\"], verbose=verbose)\n+    else:\n+        run([\"curl\", \"-o\", path, url], verbose=verbose)\n+\n+def unpack(tarball, dst, verbose=False, match=None):\n+    print(\"extracting \" + tarball)\n+    fname = os.path.basename(tarball).replace(\".tar.gz\", \"\")\n+    with contextlib.closing(tarfile.open(tarball)) as tar:\n+        for p in tar.getnames():\n+            if \"/\" not in p:\n+                continue\n+            name = p.replace(fname + \"/\", \"\", 1)\n+            if match is not None and not name.startswith(match):\n+                continue\n+            name = name[len(match) + 1:]\n+\n+            fp = os.path.join(dst, name)\n+            if verbose:\n+                print(\"  extracting \" + p)\n+            tar.extract(p, dst)\n+            tp = os.path.join(dst, p)\n+            if os.path.isdir(tp) and os.path.exists(fp):\n+                continue\n+            shutil.move(tp, fp)\n+    shutil.rmtree(os.path.join(dst, fname))\n+\n+def run(args, verbose=False):\n+    if verbose:\n+        print(\"running: \" + ' '.join(args))\n+    sys.stdout.flush()\n+    # Use Popen here instead of call() as it apparently allows powershell on\n+    # Windows to not lock up waiting for input presumably.\n+    ret = subprocess.Popen(args)\n+    code = ret.wait()\n+    if code != 0:\n+        if not verbose:\n+            print(\"failed to run: \" + ' '.join(args))\n+        raise RuntimeError(\"failed to run command\")\n+\n+class RustBuild:\n+    def download_rust_nightly(self):\n+        cache_dst = os.path.join(self.build_dir, \"cache\")\n+        rustc_cache = os.path.join(cache_dst, self.snap_rustc_date())\n+        cargo_cache = os.path.join(cache_dst, self.snap_cargo_date())\n+        if not os.path.exists(rustc_cache):\n+            os.makedirs(rustc_cache)\n+        if not os.path.exists(cargo_cache):\n+            os.makedirs(cargo_cache)\n+\n+        if self.rustc().startswith(self.bin_root()) and \\\n+           (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n+            filename = \"rust-std-nightly-\" + self.build + \".tar.gz\"\n+            url = \"https://static.rust-lang.org/dist/\" + self.snap_rustc_date()\n+            tarball = os.path.join(rustc_cache, filename)\n+            if not os.path.exists(tarball):\n+                get(url + \"/\" + filename, tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(),\n+                   match=\"rust-std-\" + self.build,\n+                   verbose=self.verbose)\n+\n+            filename = \"rustc-nightly-\" + self.build + \".tar.gz\"\n+            url = \"https://static.rust-lang.org/dist/\" + self.snap_rustc_date()\n+            tarball = os.path.join(rustc_cache, filename)\n+            if not os.path.exists(tarball):\n+                get(url + \"/\" + filename, tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(), match=\"rustc\", verbose=self.verbose)\n+            with open(self.rustc_stamp(), 'w') as f:\n+                f.write(self.snap_rustc_date())\n+\n+        if self.cargo().startswith(self.bin_root()) and \\\n+           (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n+            filename = \"cargo-nightly-\" + self.build + \".tar.gz\"\n+            url = \"https://static.rust-lang.org/cargo-dist/\" + self.snap_cargo_date()\n+            tarball = os.path.join(cargo_cache, filename)\n+            if not os.path.exists(tarball):\n+                get(url + \"/\" + filename, tarball, verbose=self.verbose)\n+            unpack(tarball, self.bin_root(), match=\"cargo\", verbose=self.verbose)\n+            with open(self.cargo_stamp(), 'w') as f:\n+                f.write(self.snap_cargo_date())\n+\n+    def snap_cargo_date(self):\n+        return self._cargo_date\n+\n+    def snap_rustc_date(self):\n+        return self._rustc_date\n+\n+    def rustc_stamp(self):\n+        return os.path.join(self.bin_root(), '.rustc-stamp')\n+\n+    def cargo_stamp(self):\n+        return os.path.join(self.bin_root(), '.cargo-stamp')\n+\n+    def rustc_out_of_date(self):\n+        if not os.path.exists(self.rustc_stamp()):\n+            return True\n+        with open(self.rustc_stamp(), 'r') as f:\n+            return self.snap_rustc_date() != f.read()\n+\n+    def cargo_out_of_date(self):\n+        if not os.path.exists(self.cargo_stamp()):\n+            return True\n+        with open(self.cargo_stamp(), 'r') as f:\n+            return self.snap_cargo_date() != f.read()\n+\n+    def bin_root(self):\n+        return os.path.join(self.build_dir, self.build, \"stage0\")\n+\n+    def get_toml(self, key):\n+        for line in self.config_toml.splitlines():\n+            if line.startswith(key + ' ='):\n+                return self.get_string(line)\n+        return None\n+\n+    def get_mk(self, key):\n+        for line in iter(self.config_mk.splitlines()):\n+            if line.startswith(key):\n+                return line[line.find(':=') + 2:].strip()\n+        return None\n+\n+    def cargo(self):\n+        config = self.get_toml('cargo')\n+        if config:\n+            return config\n+        return os.path.join(self.bin_root(), \"bin/cargo\" + self.exe_suffix())\n+\n+    def rustc(self):\n+        config = self.get_toml('rustc')\n+        if config:\n+            return config\n+        config = self.get_mk('CFG_LOCAL_RUST')\n+        if config:\n+            return config + '/bin/rustc' + self.exe_suffix()\n+        return os.path.join(self.bin_root(), \"bin/rustc\" + self.exe_suffix())\n+\n+    def get_string(self, line):\n+        start = line.find('\"')\n+        end = start + 1 + line[start+1:].find('\"')\n+        return line[start+1:end]\n+\n+    def exe_suffix(self):\n+        if sys.platform == 'win32':\n+            return '.exe'\n+        else:\n+            return ''\n+\n+    def parse_nightly_dates(self):\n+        nightlies = os.path.join(self.rust_root, \"src/nightlies.txt\")\n+        with open(nightlies, 'r') as nightlies:\n+            rustc, cargo = nightlies.read().split(\"\\n\")[:2]\n+            assert rustc.startswith(\"rustc: \")\n+            assert cargo.startswith(\"cargo: \")\n+            self._rustc_date = rustc[len(\"rustc: \"):]\n+            self._cargo_date = cargo[len(\"cargo: \"):]\n+\n+    def build_bootstrap(self):\n+        env = os.environ.copy()\n+        env[\"CARGO_TARGET_DIR\"] = os.path.join(self.build_dir, \"bootstrap\")\n+        env[\"RUSTC\"] = self.rustc()\n+        env[\"LD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n+        env[\"DYLD_LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\")\n+        env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n+                      os.pathsep + env[\"PATH\"]\n+        self.run([self.cargo(), \"build\", \"--manifest-path\",\n+                  os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")],\n+                 env)\n+\n+    def run(self, args, env):\n+        proc = subprocess.Popen(args, env = env)\n+        ret = proc.wait()\n+        if ret != 0:\n+            sys.exit(ret)\n+\n+    def build_triple(self):\n+        config = self.get_toml('build')\n+        if config:\n+            return config\n+        config = self.get_mk('CFG_BUILD')\n+        if config:\n+            return config\n+        try:\n+            ostype = subprocess.check_output(['uname', '-s']).strip()\n+            cputype = subprocess.check_output(['uname', '-m']).strip()\n+        except FileNotFoundError:\n+            if sys.platform == 'win32':\n+                return 'x86_64-pc-windows-msvc'\n+            else:\n+                raise\n+\n+        # Darwin's `uname -s` lies and always returns i386. We have to use\n+        # sysctl instead.\n+        if ostype == 'Darwin' and cputype == 'i686':\n+            sysctl = subprocess.check_output(['sysctl', 'hw.optional.x86_64'])\n+            if sysctl.contains(': 1'):\n+                cputype = 'x86_64'\n+\n+        # The goal here is to come up with the same triple as LLVM would,\n+        # at least for the subset of platforms we're willing to target.\n+        if ostype == 'Linux':\n+            ostype = 'unknown-linux-gnu'\n+        elif ostype == 'FreeBSD':\n+            ostype = 'unknown-freebsd'\n+        elif ostype == 'DragonFly':\n+            ostype = 'unknown-dragonfly'\n+        elif ostype == 'Bitrig':\n+            ostype = 'unknown-bitrig'\n+        elif ostype == 'OpenBSD':\n+            ostype = 'unknown-openbsd'\n+        elif ostype == 'NetBSD':\n+            ostype = 'unknown-netbsd'\n+        elif ostype == 'Darwin':\n+            ostype = 'apple-darwin'\n+        elif ostype.startswith('MINGW'):\n+            # msys' `uname` does not print gcc configuration, but prints msys\n+            # configuration. so we cannot believe `uname -m`:\n+            # msys1 is always i686 and msys2 is always x86_64.\n+            # instead, msys defines $MSYSTEM which is MINGW32 on i686 and\n+            # MINGW64 on x86_64.\n+            ostype = 'pc-windows-gnu'\n+            cputype = 'i686'\n+            if os.environ.get('MSYSTEM') == 'MINGW64':\n+                cputype = 'x86_64'\n+        elif ostype.startswith('MSYS'):\n+            ostype = 'pc-windows-gnu'\n+        elif ostype.startswith('CYGWIN_NT'):\n+            cputype = 'i686'\n+            if ostype.endswith('WOW64'):\n+                cputype = 'x86_64'\n+            ostype = 'pc-windows-gnu'\n+        else:\n+            raise ValueError(\"unknown OS type: \" + ostype)\n+\n+        if cputype in {'i386', 'i486', 'i686', 'i786', 'x86'}:\n+            cputype = 'i686'\n+        elif cputype in {'xscale', 'arm'}:\n+            cputype = 'arm'\n+        elif cputype == 'armv7l':\n+            cputype = 'arm'\n+            ostype += 'eabihf'\n+        elif cputype == 'aarch64':\n+            cputype = 'aarch64'\n+        elif cputype in {'powerpc', 'ppc', 'ppc64'}:\n+            cputype = 'powerpc'\n+        elif cputype in {'amd64', 'x86_64', 'x86-64', 'x64'}:\n+            cputype = 'x86_64'\n+        else:\n+            raise ValueError(\"unknown cpu type: \" + cputype)\n+\n+        return cputype + '-' + ostype\n+\n+parser = argparse.ArgumentParser(description='Build rust')\n+parser.add_argument('--config')\n+parser.add_argument('-v', '--verbose', action='store_true')\n+\n+args = [a for a in sys.argv if a != '-h']\n+args, _ = parser.parse_known_args(args)\n+\n+# Configure initial bootstrap\n+rb = RustBuild()\n+rb.config_toml = ''\n+rb.config_mk = ''\n+rb.rust_root = os.path.abspath(os.path.join(__file__, '../../..'))\n+rb.build_dir = os.path.join(os.getcwd(), \"build\")\n+rb.verbose = args.verbose\n+\n+try:\n+    with open(args.config or 'config.toml') as config:\n+        rb.config_toml = config.read()\n+except:\n+    pass\n+try:\n+    rb.config_mk = open('config.mk').read()\n+except:\n+    pass\n+\n+# Fetch/build the bootstrap\n+rb.build = rb.build_triple()\n+rb.parse_nightly_dates()\n+rb.download_rust_nightly()\n+sys.stdout.flush()\n+rb.build_bootstrap()\n+sys.stdout.flush()\n+\n+# Run the bootstrap\n+args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n+args.extend(sys.argv[1:])\n+args.append('--src')\n+args.append(rb.rust_root)\n+args.append('--build')\n+args.append(rb.build)\n+env = os.environ.copy()\n+env[\"BOOTSTRAP_PARENT_ID\"] = str(os.getpid())\n+rb.run(args, env)"}, {"sha": "9f962e9d9e61a2b5c5ed710bb5fc7459a15b9e25", "filename": "src/bootstrap/build/cc.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcc.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::process::Command;\n+\n+use build_helper::{cc2ar, output};\n+use gcc;\n+\n+use build::Build;\n+use build::config::Target;\n+\n+pub fn find(build: &mut Build) {\n+    // For all targets we're going to need a C compiler for building some shims\n+    // and such as well as for being a linker for Rust code.\n+    for target in build.config.target.iter() {\n+        let mut cfg = gcc::Config::new();\n+        cfg.cargo_metadata(false).opt_level(0).debug(false)\n+           .target(target).host(&build.config.build);\n+\n+        let config = build.config.target_config.get(target);\n+        if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n+            cfg.compiler(cc);\n+        } else {\n+            set_compiler(&mut cfg, \"gcc\", target, config);\n+        }\n+\n+        let compiler = cfg.get_compiler();\n+        let ar = cc2ar(compiler.path(), target);\n+        build.verbose(&format!(\"CC_{} = {:?}\", target, compiler.path()));\n+        build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n+        build.cc.insert(target.to_string(), (compiler, ar));\n+    }\n+\n+    // For all host triples we need to find a C++ compiler as well\n+    for host in build.config.host.iter() {\n+        let mut cfg = gcc::Config::new();\n+        cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n+           .target(host).host(&build.config.build);\n+        let config = build.config.target_config.get(host);\n+        if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n+            cfg.compiler(cxx);\n+        } else {\n+            set_compiler(&mut cfg, \"g++\", host, config);\n+        }\n+        let compiler = cfg.get_compiler();\n+        build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n+        build.cxx.insert(host.to_string(), compiler);\n+    }\n+}\n+\n+fn set_compiler(cfg: &mut gcc::Config,\n+                gnu_compiler: &str,\n+                target: &str,\n+                config: Option<&Target>) {\n+    match target {\n+        // When compiling for android we may have the NDK configured in the\n+        // config.toml in which case we look there. Otherwise the default\n+        // compiler already takes into account the triple in question.\n+        t if t.contains(\"android\") => {\n+            if let Some(ndk) = config.and_then(|c| c.ndk.as_ref()) {\n+                let compiler = format!(\"{}-{}\", target, gnu_compiler);\n+                cfg.compiler(ndk.join(\"bin\").join(compiler));\n+            }\n+        }\n+\n+        // The default gcc version from OpenBSD may be too old, try using egcc,\n+        // which is a gcc version from ports, if this is the case.\n+        t if t.contains(\"openbsd\") => {\n+            let c = cfg.get_compiler();\n+            if !c.path().ends_with(gnu_compiler) {\n+                return\n+            }\n+\n+            let output = output(c.to_command().arg(\"--version\"));\n+            let i = match output.find(\" 4.\") {\n+                Some(i) => i,\n+                None => return,\n+            };\n+            match output[i + 3..].chars().next().unwrap() {\n+                '0' ... '6' => {}\n+                _ => return,\n+            }\n+            let alternative = format!(\"e{}\", gnu_compiler);\n+            if Command::new(&alternative).output().is_ok() {\n+                cfg.compiler(alternative);\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+}"}, {"sha": "628b1d764320b845f01030d9264b3511e1bc16f2", "filename": "src/bootstrap/build/channel.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fchannel.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fs::{self, File};\n+use std::io::prelude::*;\n+use std::path::Path;\n+use std::process::Command;\n+\n+use build_helper::output;\n+\n+use build::Build;\n+use build::util::mtime;\n+\n+pub fn collect(build: &mut Build) {\n+    let mut main_mk = String::new();\n+    t!(t!(File::open(build.src.join(\"mk/main.mk\"))).read_to_string(&mut main_mk));\n+    let mut release_num = \"\";\n+    let mut prerelease_version = \"\";\n+    for line in main_mk.lines() {\n+        if line.starts_with(\"CFG_RELEASE_NUM\") {\n+            release_num = line.split('=').skip(1).next().unwrap().trim();\n+        }\n+        if line.starts_with(\"CFG_PRERELEASE_VERSION\") {\n+            prerelease_version = line.split('=').skip(1).next().unwrap().trim();\n+        }\n+    }\n+\n+    // FIXME: this is duplicating makefile logic\n+    match &build.config.channel[..] {\n+        \"stable\" => {\n+            build.release = release_num.to_string();\n+            build.unstable_features = false;\n+        }\n+        \"beta\" => {\n+            build.release = format!(\"{}-beta{}\", release_num,\n+                                   prerelease_version);\n+            build.unstable_features = false;\n+        }\n+        \"nightly\" => {\n+            build.release = format!(\"{}-nightly\", release_num);\n+            build.unstable_features = true;\n+        }\n+        _ => {\n+            build.release = format!(\"{}-dev\", release_num);\n+            build.unstable_features = true;\n+        }\n+    }\n+    build.version = build.release.clone();\n+\n+    if fs::metadata(build.src.join(\".git\")).is_ok() {\n+        let ver_date = output(Command::new(\"git\").current_dir(&build.src)\n+                                      .arg(\"log\").arg(\"-1\")\n+                                      .arg(\"--date=short\")\n+                                      .arg(\"--pretty=format:%cd\"));\n+        let ver_hash = output(Command::new(\"git\").current_dir(&build.src)\n+                                      .arg(\"rev-parse\").arg(\"HEAD\"));\n+        let short_ver_hash = output(Command::new(\"git\")\n+                                            .current_dir(&build.src)\n+                                            .arg(\"rev-parse\")\n+                                            .arg(\"--short=9\")\n+                                            .arg(\"HEAD\"));\n+        let ver_date = ver_date.trim().to_string();\n+        let ver_hash = ver_hash.trim().to_string();\n+        let short_ver_hash = short_ver_hash.trim().to_string();\n+        build.version.push_str(&format!(\" ({} {})\", short_ver_hash,\n+                                       ver_date));\n+        build.ver_date = Some(ver_date.to_string());\n+        build.ver_hash = Some(ver_hash);\n+        build.short_ver_hash = Some(short_ver_hash);\n+    }\n+\n+    build.bootstrap_key = mtime(Path::new(\"config.toml\")).seconds()\n+                                                        .to_string();\n+}\n+"}, {"sha": "c22648b47109836a23def709144c46421b6c8e13", "filename": "src/bootstrap/build/compile.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fcompile.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,249 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+use build_helper::output;\n+\n+use build::util::{exe, staticlib, libdir, mtime, is_dylib};\n+use build::{Build, Compiler};\n+\n+/// Build the standard library.\n+///\n+/// This will build the standard library for a particular stage of the build\n+/// using the `compiler` targeting the `target` architecture. The artifacts\n+/// created will also be linked into the sysroot directory.\n+pub fn std<'a>(build: &'a Build, stage: u32, target: &str,\n+               compiler: &Compiler<'a>) {\n+    let host = compiler.host;\n+    println!(\"Building stage{} std artifacts ({} -> {})\", stage,\n+             host, target);\n+\n+    // Move compiler-rt into place as it'll be required by the compiler when\n+    // building the standard library to link the dylib of libstd\n+    let libdir = build.sysroot_libdir(stage, &host, target);\n+    let _ = fs::remove_dir_all(&libdir);\n+    t!(fs::create_dir_all(&libdir));\n+    t!(fs::hard_link(&build.compiler_rt_built.borrow()[target],\n+                     libdir.join(staticlib(\"compiler-rt\", target))));\n+\n+    build_startup_objects(build, target, &libdir);\n+\n+    let out_dir = build.cargo_out(stage, &host, true, target);\n+    build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n+    let mut cargo = build.cargo(stage, compiler, true, target, \"build\");\n+    cargo.arg(\"--features\").arg(build.std_features())\n+         .arg(\"--manifest-path\")\n+         .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"));\n+\n+    if let Some(target) = build.config.target_config.get(target) {\n+        if let Some(ref jemalloc) = target.jemalloc {\n+            cargo.env(\"JEMALLOC_OVERRIDE\", jemalloc);\n+        }\n+    }\n+    if let Some(ref p) = build.config.musl_root {\n+        if target.contains(\"musl\") {\n+            cargo.env(\"MUSL_ROOT\", p);\n+        }\n+    }\n+\n+    build.run(&mut cargo);\n+    add_to_sysroot(&out_dir, &libdir);\n+}\n+\n+/// Build and prepare startup objects like rsbegin.o and rsend.o\n+///\n+/// These are primarily used on Windows right now for linking executables/dlls.\n+/// They don't require any library support as they're just plain old object\n+/// files, so we just use the nightly snapshot compiler to always build them (as\n+/// no other compilers are guaranteed to be available).\n+fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n+    if !target.contains(\"pc-windows-gnu\") {\n+        return\n+    }\n+    let compiler = Compiler::new(0, &build.config.build);\n+    let compiler = build.compiler_path(&compiler);\n+\n+    for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n+        let file = t!(file);\n+        build.run(Command::new(&compiler)\n+                          .arg(\"--emit=obj\")\n+                          .arg(\"--out-dir\").arg(into)\n+                          .arg(file.path()));\n+    }\n+\n+    for obj in [\"crt2.o\", \"dllcrt2.o\"].iter() {\n+        t!(fs::copy(compiler_file(build.cc(target), obj), into.join(obj)));\n+    }\n+}\n+\n+/// Build the compiler.\n+///\n+/// This will build the compiler for a particular stage of the build using\n+/// the `compiler` targeting the `target` architecture. The artifacts\n+/// created will also be linked into the sysroot directory.\n+pub fn rustc<'a>(build: &'a Build, stage: u32, target: &str,\n+                 compiler: &Compiler<'a>) {\n+    let host = compiler.host;\n+    println!(\"Building stage{} compiler artifacts ({} -> {})\", stage,\n+             host, target);\n+\n+    let out_dir = build.cargo_out(stage, &host, false, target);\n+    let rustc = out_dir.join(exe(\"rustc\", target));\n+    build.clear_if_dirty(&out_dir, &libstd_shim(build, stage, &host, target));\n+\n+    let mut cargo = build.cargo(stage, compiler, false, target, \"build\");\n+    cargo.arg(\"--features\").arg(build.rustc_features(stage))\n+         .arg(\"--manifest-path\")\n+         .arg(build.src.join(\"src/rustc/Cargo.toml\"));\n+\n+    // In stage0 we may not need to build as many executables\n+    if stage == 0 {\n+        cargo.arg(\"--bin\").arg(\"rustc\");\n+    }\n+\n+    // Set some configuration variables picked up by build scripts and\n+    // the compiler alike\n+    cargo.env(\"CFG_RELEASE\", &build.release)\n+         .env(\"CFG_RELEASE_CHANNEL\", &build.config.channel)\n+         .env(\"CFG_VERSION\", &build.version)\n+         .env(\"CFG_BOOTSTRAP_KEY\", &build.bootstrap_key)\n+         .env(\"CFG_PREFIX\", build.config.prefix.clone().unwrap_or(String::new()))\n+         .env(\"RUSTC_BOOTSTRAP_KEY\", &build.bootstrap_key)\n+         .env(\"CFG_LIBDIR_RELATIVE\", \"lib\");\n+\n+    if let Some(ref ver_date) = build.ver_date {\n+        cargo.env(\"CFG_VER_DATE\", ver_date);\n+    }\n+    if let Some(ref ver_hash) = build.ver_hash {\n+        cargo.env(\"CFG_VER_HASH\", ver_hash);\n+    }\n+    if !build.unstable_features {\n+        cargo.env(\"CFG_DISABLE_UNSTABLE_FEATURES\", \"1\");\n+    }\n+    if let Some(config) = build.config.target_config.get(target) {\n+        if let Some(ref s) = config.llvm_config {\n+            cargo.env(\"LLVM_CONFIG\", s);\n+        }\n+    }\n+    if build.config.llvm_static_stdcpp {\n+        cargo.env(\"LLVM_STATIC_STDCPP\",\n+                  compiler_file(build.cxx(target), \"libstdc++.a\"));\n+    }\n+    if let Some(ref s) = build.config.rustc_default_linker {\n+        cargo.env(\"CFG_DEFAULT_LINKER\", s);\n+    }\n+    if let Some(ref s) = build.config.rustc_default_ar {\n+        cargo.env(\"CFG_DEFAULT_AR\", s);\n+    }\n+    build.run(&mut cargo);\n+\n+    let sysroot_libdir = build.sysroot_libdir(stage, host, target);\n+    add_to_sysroot(&out_dir, &sysroot_libdir);\n+\n+    if host == target {\n+        assemble_compiler(build, stage, target, &rustc);\n+    }\n+}\n+\n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+fn libstd_shim(build: &Build, stage: u32, host: &str, target: &str) -> PathBuf {\n+    build.cargo_out(stage, host, true, target).join(\"libstd_shim.rlib\")\n+}\n+\n+fn compiler_file(compiler: &Path, file: &str) -> String {\n+    output(Command::new(compiler)\n+                   .arg(format!(\"-print-file-name={}\", file))).trim().to_string()\n+}\n+\n+/// Prepare a new compiler from the artifacts in `stage`\n+///\n+/// This will link the compiler built by `host` during the stage\n+/// specified to the sysroot location for `host` to be the official\n+/// `stage + 1` compiler for that host. This means that the `rustc` binary\n+/// itself will be linked into place along with all supporting dynamic\n+/// libraries.\n+fn assemble_compiler(build: &Build, stage: u32, host: &str, rustc: &Path) {\n+    // Clear out old files\n+    let sysroot = build.sysroot(stage + 1, host);\n+    let _ = fs::remove_dir_all(&sysroot);\n+    t!(fs::create_dir_all(&sysroot));\n+\n+    // Link in all dylibs to the libdir\n+    let sysroot_libdir = sysroot.join(libdir(host));\n+    t!(fs::create_dir_all(&sysroot_libdir));\n+    let src_libdir = build.sysroot_libdir(stage, host, host);\n+    for f in t!(fs::read_dir(&src_libdir)).map(|f| t!(f)) {\n+        let filename = f.file_name().into_string().unwrap();\n+        if is_dylib(&filename) {\n+            t!(fs::hard_link(&f.path(), sysroot_libdir.join(&filename)));\n+        }\n+    }\n+\n+    // Link the compiler binary itself into place\n+    let bindir = sysroot.join(\"bin\");\n+    t!(fs::create_dir_all(&bindir));\n+    let compiler = build.compiler_path(&Compiler::new(stage + 1, host));\n+    let _ = fs::remove_file(&compiler);\n+    t!(fs::hard_link(rustc, compiler));\n+\n+    // See if rustdoc exists to link it into place\n+    let exe = exe(\"rustdoc\", host);\n+    let rustdoc_src = rustc.parent().unwrap().join(&exe);\n+    let rustdoc_dst = bindir.join(exe);\n+    if fs::metadata(&rustdoc_src).is_ok() {\n+        let _ = fs::remove_file(&rustdoc_dst);\n+        t!(fs::hard_link(&rustdoc_src, &rustdoc_dst));\n+    }\n+}\n+\n+/// Link some files into a rustc sysroot.\n+///\n+/// For a particular stage this will link all of the contents of `out_dir`\n+/// into the sysroot of the `host` compiler, assuming the artifacts are\n+/// compiled for the specified `target`.\n+fn add_to_sysroot(out_dir: &Path, sysroot_dst: &Path) {\n+    // Collect the set of all files in the dependencies directory, keyed\n+    // off the name of the library. We assume everything is of the form\n+    // `foo-<hash>.{rlib,so,...}`, and there could be multiple different\n+    // `<hash>` values for the same name (of old builds).\n+    let mut map = HashMap::new();\n+    for file in t!(fs::read_dir(out_dir.join(\"deps\"))).map(|f| t!(f)) {\n+        let filename = file.file_name().into_string().unwrap();\n+\n+        // We're only interested in linking rlibs + dylibs, other things like\n+        // unit tests don't get linked in\n+        if !filename.ends_with(\".rlib\") &&\n+           !filename.ends_with(\".lib\") &&\n+           !is_dylib(&filename) {\n+            continue\n+        }\n+        let file = file.path();\n+        let dash = filename.find(\"-\").unwrap();\n+        let key = (filename[..dash].to_string(),\n+                   file.extension().unwrap().to_owned());\n+        map.entry(key).or_insert(Vec::new())\n+           .push(file.clone());\n+    }\n+\n+    // For all hash values found, pick the most recent one to move into the\n+    // sysroot, that should be the one we just built.\n+    for (_, paths) in map {\n+        let (_, path) = paths.iter().map(|path| {\n+            (mtime(&path).seconds(), path)\n+        }).max().unwrap();\n+        t!(fs::hard_link(&path,\n+                         sysroot_dst.join(path.file_name().unwrap())));\n+    }\n+}"}, {"sha": "1e67c4a9a3e8d35e573db9ffb70a16adae7980c0", "filename": "src/bootstrap/build/config.rs", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fconfig.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,361 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::File;\n+use std::io::prelude::*;\n+use std::path::PathBuf;\n+use std::process;\n+\n+use num_cpus;\n+use rustc_serialize::Decodable;\n+use toml::{Parser, Decoder, Value};\n+\n+/// Global configuration for the entire build and/or bootstrap.\n+///\n+/// This structure is derived from a combination of both `config.toml` and\n+/// `config.mk`. As of the time of this writing it's unlikely that `config.toml`\n+/// is used all that much, so this is primarily filled out by `config.mk` which\n+/// is generated from `./configure`.\n+///\n+/// Note that this structure is not decoded directly into, but rather it is\n+/// filled out from the decoded forms of the structs below.\n+#[derive(Default)]\n+pub struct Config {\n+    pub ccache: bool,\n+    pub verbose: bool,\n+    pub submodules: bool,\n+    pub compiler_docs: bool,\n+    pub docs: bool,\n+    pub target_config: HashMap<String, Target>,\n+\n+    // llvm codegen options\n+    pub llvm_assertions: bool,\n+    pub llvm_optimize: bool,\n+    pub llvm_version_check: bool,\n+    pub llvm_static_stdcpp: bool,\n+\n+    // rust codegen options\n+    pub rust_optimize: bool,\n+    pub rust_codegen_units: u32,\n+    pub rust_debug_assertions: bool,\n+    pub rust_debuginfo: bool,\n+    pub rust_rpath: bool,\n+    pub rustc_default_linker: Option<String>,\n+    pub rustc_default_ar: Option<String>,\n+\n+    pub build: String,\n+    pub host: Vec<String>,\n+    pub target: Vec<String>,\n+    pub rustc: Option<String>,\n+    pub cargo: Option<String>,\n+\n+    // libstd features\n+    pub debug_jemalloc: bool,\n+    pub use_jemalloc: bool,\n+\n+    // misc\n+    pub channel: String,\n+    pub musl_root: Option<PathBuf>,\n+    pub prefix: Option<String>,\n+}\n+\n+/// Per-target configuration stored in the global configuration structure.\n+#[derive(Default)]\n+pub struct Target {\n+    pub llvm_config: Option<PathBuf>,\n+    pub jemalloc: Option<PathBuf>,\n+    pub cc: Option<PathBuf>,\n+    pub cxx: Option<PathBuf>,\n+    pub ndk: Option<PathBuf>,\n+}\n+\n+/// Structure of the `config.toml` file that configuration is read from.\n+///\n+/// This structure uses `Decodable` to automatically decode a TOML configuration\n+/// file into this format, and then this is traversed and written into the above\n+/// `Config` structure.\n+#[derive(RustcDecodable, Default)]\n+struct TomlConfig {\n+    build: Option<Build>,\n+    llvm: Option<Llvm>,\n+    rust: Option<Rust>,\n+    target: Option<HashMap<String, TomlTarget>>,\n+}\n+\n+/// TOML representation of various global build decisions.\n+#[derive(RustcDecodable, Default, Clone)]\n+struct Build {\n+    build: Option<String>,\n+    host: Vec<String>,\n+    target: Vec<String>,\n+    cargo: Option<String>,\n+    rustc: Option<String>,\n+    compiler_docs: Option<bool>,\n+    docs: Option<bool>,\n+}\n+\n+/// TOML representation of how the LLVM build is configured.\n+#[derive(RustcDecodable, Default)]\n+struct Llvm {\n+    ccache: Option<bool>,\n+    assertions: Option<bool>,\n+    optimize: Option<bool>,\n+    version_check: Option<bool>,\n+    static_libstdcpp: Option<bool>,\n+}\n+\n+/// TOML representation of how the Rust build is configured.\n+#[derive(RustcDecodable, Default)]\n+struct Rust {\n+    optimize: Option<bool>,\n+    codegen_units: Option<u32>,\n+    debug_assertions: Option<bool>,\n+    debuginfo: Option<bool>,\n+    debug_jemalloc: Option<bool>,\n+    use_jemalloc: Option<bool>,\n+    default_linker: Option<String>,\n+    default_ar: Option<String>,\n+    channel: Option<String>,\n+    musl_root: Option<String>,\n+    rpath: Option<bool>,\n+}\n+\n+/// TOML representation of how each build target is configured.\n+#[derive(RustcDecodable, Default)]\n+struct TomlTarget {\n+    llvm_config: Option<String>,\n+    jemalloc: Option<String>,\n+    cc: Option<String>,\n+    cxx: Option<String>,\n+    android_ndk: Option<String>,\n+}\n+\n+impl Config {\n+    pub fn parse(build: &str, file: Option<PathBuf>) -> Config {\n+        let mut config = Config::default();\n+        config.llvm_optimize = true;\n+        config.use_jemalloc = true;\n+        config.rust_optimize = true;\n+        config.submodules = true;\n+        config.docs = true;\n+        config.rust_rpath = true;\n+        config.rust_codegen_units = 1;\n+        config.build = build.to_string();\n+        config.channel = \"dev\".to_string();\n+\n+        let toml = file.map(|file| {\n+            let mut f = t!(File::open(&file));\n+            let mut toml = String::new();\n+            t!(f.read_to_string(&mut toml));\n+            let mut p = Parser::new(&toml);\n+            let table = match p.parse() {\n+                Some(table) => table,\n+                None => {\n+                    println!(\"failed to parse TOML configuration:\");\n+                    for err in p.errors.iter() {\n+                        let (loline, locol) = p.to_linecol(err.lo);\n+                        let (hiline, hicol) = p.to_linecol(err.hi);\n+                        println!(\"{}:{}-{}:{}: {}\", loline, locol, hiline,\n+                                 hicol, err.desc);\n+                    }\n+                    process::exit(2);\n+                }\n+            };\n+            let mut d = Decoder::new(Value::Table(table));\n+            match Decodable::decode(&mut d) {\n+                Ok(cfg) => cfg,\n+                Err(e) => {\n+                    println!(\"failed to decode TOML: {}\", e);\n+                    process::exit(2);\n+                }\n+            }\n+        }).unwrap_or_else(|| TomlConfig::default());\n+\n+        let build = toml.build.clone().unwrap_or(Build::default());\n+        set(&mut config.build, build.build.clone());\n+        config.host.push(config.build.clone());\n+        for host in build.host.iter() {\n+            if !config.host.contains(host) {\n+                config.host.push(host.clone());\n+            }\n+        }\n+        for target in config.host.iter().chain(&build.target) {\n+            if !config.target.contains(target) {\n+                config.target.push(target.clone());\n+            }\n+        }\n+        config.rustc = build.rustc;\n+        config.cargo = build.cargo;\n+        set(&mut config.compiler_docs, build.compiler_docs);\n+        set(&mut config.docs, build.docs);\n+\n+        if let Some(ref llvm) = toml.llvm {\n+            set(&mut config.ccache, llvm.ccache);\n+            set(&mut config.llvm_assertions, llvm.assertions);\n+            set(&mut config.llvm_optimize, llvm.optimize);\n+            set(&mut config.llvm_optimize, llvm.optimize);\n+            set(&mut config.llvm_version_check, llvm.version_check);\n+            set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n+        }\n+        if let Some(ref rust) = toml.rust {\n+            set(&mut config.rust_debug_assertions, rust.debug_assertions);\n+            set(&mut config.rust_debuginfo, rust.debuginfo);\n+            set(&mut config.rust_optimize, rust.optimize);\n+            set(&mut config.rust_rpath, rust.rpath);\n+            set(&mut config.debug_jemalloc, rust.debug_jemalloc);\n+            set(&mut config.use_jemalloc, rust.use_jemalloc);\n+            set(&mut config.channel, rust.channel.clone());\n+            config.rustc_default_linker = rust.default_linker.clone();\n+            config.rustc_default_ar = rust.default_ar.clone();\n+            config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n+\n+            match rust.codegen_units {\n+                Some(0) => config.rust_codegen_units = num_cpus::get() as u32,\n+                Some(n) => config.rust_codegen_units = n,\n+                None => {}\n+            }\n+        }\n+\n+        if let Some(ref t) = toml.target {\n+            for (triple, cfg) in t {\n+                let mut target = Target::default();\n+\n+                if let Some(ref s) = cfg.llvm_config {\n+                    target.llvm_config = Some(env::current_dir().unwrap().join(s));\n+                }\n+                if let Some(ref s) = cfg.jemalloc {\n+                    target.jemalloc = Some(env::current_dir().unwrap().join(s));\n+                }\n+                if let Some(ref s) = cfg.android_ndk {\n+                    target.ndk = Some(env::current_dir().unwrap().join(s));\n+                }\n+                target.cxx = cfg.cxx.clone().map(PathBuf::from);\n+                target.cc = cfg.cc.clone().map(PathBuf::from);\n+\n+                config.target_config.insert(triple.clone(), target);\n+            }\n+        }\n+\n+        return config\n+    }\n+\n+    pub fn update_with_config_mk(&mut self) {\n+        let mut config = String::new();\n+        File::open(\"config.mk\").unwrap().read_to_string(&mut config).unwrap();\n+        for line in config.lines() {\n+            let mut parts = line.splitn(2, \":=\").map(|s| s.trim());\n+            let key = parts.next().unwrap();\n+            let value = match parts.next() {\n+                Some(n) if n.starts_with('\\\"') => &n[1..n.len() - 1],\n+                Some(n) => n,\n+                None => continue\n+            };\n+\n+            macro_rules! check {\n+                ($(($name:expr, $val:expr),)*) => {\n+                    if value == \"1\" {\n+                        $(\n+                            if key == concat!(\"CFG_ENABLE_\", $name) {\n+                                $val = true;\n+                                continue\n+                            }\n+                            if key == concat!(\"CFG_DISABLE_\", $name) {\n+                                $val = false;\n+                                continue\n+                            }\n+                        )*\n+                    }\n+                }\n+            }\n+\n+            check! {\n+                (\"CCACHE\", self.ccache),\n+                (\"MANAGE_SUBMODULES\", self.submodules),\n+                (\"COMPILER_DOCS\", self.compiler_docs),\n+                (\"DOCS\", self.docs),\n+                (\"LLVM_ASSERTIONS\", self.llvm_assertions),\n+                (\"OPTIMIZE_LLVM\", self.llvm_optimize),\n+                (\"LLVM_VERSION_CHECK\", self.llvm_version_check),\n+                (\"LLVM_STATIC_STDCPP\", self.llvm_static_stdcpp),\n+                (\"OPTIMIZE\", self.rust_optimize),\n+                (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n+                (\"DEBUGINFO\", self.rust_debuginfo),\n+                (\"JEMALLOC\", self.use_jemalloc),\n+                (\"DEBUG_JEMALLOC\", self.debug_jemalloc),\n+                (\"RPATH\", self.rust_rpath),\n+            }\n+\n+            match key {\n+                \"CFG_BUILD\" => self.build = value.to_string(),\n+                \"CFG_HOST\" => {\n+                    self.host = value.split(\" \").map(|s| s.to_string())\n+                                     .collect();\n+                }\n+                \"CFG_TARGET\" => {\n+                    self.target = value.split(\" \").map(|s| s.to_string())\n+                                       .collect();\n+                }\n+                \"CFG_MUSL_ROOT\" if value.len() > 0 => {\n+                    self.musl_root = Some(PathBuf::from(value));\n+                }\n+                \"CFG_DEFAULT_AR\" if value.len() > 0 => {\n+                    self.rustc_default_ar = Some(value.to_string());\n+                }\n+                \"CFG_DEFAULT_LINKER\" if value.len() > 0 => {\n+                    self.rustc_default_linker = Some(value.to_string());\n+                }\n+                \"CFG_RELEASE_CHANNEL\" => {\n+                    self.channel = value.to_string();\n+                }\n+                \"CFG_PREFIX\" => {\n+                    self.prefix = Some(value.to_string());\n+                }\n+                \"CFG_LLVM_ROOT\" if value.len() > 0 => {\n+                    let target = self.target_config.entry(self.build.clone())\n+                                     .or_insert(Target::default());\n+                    let root = PathBuf::from(value);\n+                    target.llvm_config = Some(root.join(\"bin/llvm-config\"));\n+                }\n+                \"CFG_JEMALLOC_ROOT\" if value.len() > 0 => {\n+                    let target = self.target_config.entry(self.build.clone())\n+                                     .or_insert(Target::default());\n+                    target.jemalloc = Some(PathBuf::from(value));\n+                }\n+                \"CFG_ARM_LINUX_ANDROIDEABI_NDK\" if value.len() > 0 => {\n+                    let target = \"arm-linux-androideabi\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.ndk = Some(PathBuf::from(value));\n+                }\n+                \"CFG_I686_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n+                    let target = \"i686-linux-androideabi\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.ndk = Some(PathBuf::from(value));\n+                }\n+                \"CFG_AARCH64_LINUX_ANDROID_NDK\" if value.len() > 0 => {\n+                    let target = \"aarch64-linux-androideabi\".to_string();\n+                    let target = self.target_config.entry(target)\n+                                     .or_insert(Target::default());\n+                    target.ndk = Some(PathBuf::from(value));\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n+fn set<T>(field: &mut T, val: Option<T>) {\n+    if let Some(v) = val {\n+        *field = v;\n+    }\n+}"}, {"sha": "cd538bb0a905ad5598c7060854d5711f85366fa5", "filename": "src/bootstrap/build/flags.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fflags.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fs;\n+use std::path::PathBuf;\n+use std::process;\n+use std::slice;\n+\n+use getopts::Options;\n+\n+pub struct Flags {\n+    pub verbose: bool,\n+    pub stage: Option<u32>,\n+    pub build: String,\n+    pub host: Filter,\n+    pub target: Filter,\n+    pub step: Vec<String>,\n+    pub config: Option<PathBuf>,\n+    pub src: Option<PathBuf>,\n+    pub jobs: Option<u32>,\n+    pub args: Vec<String>,\n+}\n+\n+pub struct Filter {\n+    values: Vec<String>,\n+}\n+\n+impl Flags {\n+    pub fn parse(args: &[String]) -> Flags {\n+        let mut opts = Options::new();\n+        opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n+        opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n+        opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n+        opts.reqopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n+        opts.optmulti(\"\", \"target\", \"targets to build\", \"TARGET\");\n+        opts.optmulti(\"s\", \"step\", \"build step to execute\", \"STEP\");\n+        opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n+        opts.optopt(\"\", \"src\", \"path to repo root\", \"DIR\");\n+        opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n+        opts.optflag(\"h\", \"help\", \"print this help message\");\n+\n+        let usage = |n| -> ! {\n+            let brief = format!(\"Usage: rust.py [options]\");\n+            print!(\"{}\", opts.usage(&brief));\n+            process::exit(n);\n+        };\n+\n+        let m = opts.parse(args).unwrap_or_else(|e| {\n+            println!(\"failed to parse options: {}\", e);\n+            usage(1);\n+        });\n+        if m.opt_present(\"h\") {\n+            usage(0);\n+        }\n+\n+        if m.free.len() > 0 {\n+            println!(\"free arguments are not currently accepted\");\n+            usage(1);\n+        }\n+\n+        let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n+            if fs::metadata(\"config.toml\").is_ok() {\n+                Some(PathBuf::from(\"config.toml\"))\n+            } else {\n+                None\n+            }\n+        });\n+\n+        Flags {\n+            verbose: m.opt_present(\"v\"),\n+            stage: m.opt_str(\"stage\").map(|j| j.parse().unwrap()),\n+            build: m.opt_str(\"build\").unwrap(),\n+            host: Filter { values: m.opt_strs(\"host\") },\n+            target: Filter { values: m.opt_strs(\"target\") },\n+            step: m.opt_strs(\"step\"),\n+            config: cfg_file,\n+            src: m.opt_str(\"src\").map(PathBuf::from),\n+            jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            args: m.free.clone(),\n+        }\n+    }\n+}\n+\n+impl Filter {\n+    pub fn contains(&self, name: &str) -> bool {\n+        self.values.len() == 0 || self.values.iter().any(|s| s == name)\n+    }\n+\n+    pub fn iter(&self) -> slice::Iter<String> {\n+        self.values.iter()\n+    }\n+}"}, {"sha": "49e027ffda596112ceaf635f7ebbfe5fd8ac762b", "filename": "src/bootstrap/build/job.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fjob.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Job management on Windows for bootstrapping\n+//!\n+//! Most of the time when you're running a build system (e.g. make) you expect\n+//! Ctrl-C or abnormal termination to actually terminate the entire tree of\n+//! process in play, not just the one at the top. This currently works \"by\n+//! default\" on Unix platforms because Ctrl-C actually sends a signal to the\n+//! *process group* rather than the parent process, so everything will get torn\n+//! down. On Windows, however, this does not happen and Ctrl-C just kills the\n+//! parent process.\n+//!\n+//! To achieve the same semantics on Windows we use Job Objects to ensure that\n+//! all processes die at the same time. Job objects have a mode of operation\n+//! where when all handles to the object are closed it causes all child\n+//! processes associated with the object to be terminated immediately.\n+//! Conveniently whenever a process in the job object spawns a new process the\n+//! child will be associated with the job object as well. This means if we add\n+//! ourselves to the job object we create then everything will get torn down!\n+//!\n+//! Unfortunately most of the time the build system is actually called from a\n+//! python wrapper (which manages things like building the build system) so this\n+//! all doesn't quite cut it so far. To go the last mile we duplicate the job\n+//! object handle into our parent process (a python process probably) and then\n+//! close our own handle. This means that the only handle to the job object\n+//! resides in the parent python process, so when python dies the whole build\n+//! system dies (as one would probably expect!).\n+//!\n+//! Note that this module has a #[cfg(windows)] above it as none of this logic\n+//! is required on Unix.\n+\n+extern crate kernel32;\n+extern crate winapi;\n+\n+use std::env;\n+use std::io;\n+use std::mem;\n+\n+use self::winapi::*;\n+use self::kernel32::*;\n+\n+pub unsafe fn setup() {\n+    // Create a new job object for us to use\n+    let job = CreateJobObjectW(0 as *mut _, 0 as *const _);\n+    assert!(job != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+\n+    // Indicate that when all handles to the job object are gone that all\n+    // process in the object should be killed. Note that this includes our\n+    // entire process tree by default because we've added ourselves and and our\n+    // children will reside in the job by default.\n+    let mut info = mem::zeroed::<JOBOBJECT_EXTENDED_LIMIT_INFORMATION>();\n+    info.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;\n+    let r = SetInformationJobObject(job,\n+                                    JobObjectExtendedLimitInformation,\n+                                    &mut info as *mut _ as LPVOID,\n+                                    mem::size_of_val(&info) as DWORD);\n+    assert!(r != 0, \"{}\", io::Error::last_os_error());\n+\n+    // Assign our process to this job object\n+    let r = AssignProcessToJobObject(job, GetCurrentProcess());\n+    assert!(r != 0, \"{}\", io::Error::last_os_error());\n+\n+    // If we've got a parent process (e.g. the python script that called us)\n+    // then move ownership of this job object up to them. That way if the python\n+    // script is killed (e.g. via ctrl-c) then we'll all be torn down.\n+    //\n+    // If we don't have a parent (e.g. this was run directly) then we\n+    // intentionally leak the job object handle. When our process exits\n+    // (normally or abnormally) it will close the handle implicitly, causing all\n+    // processes in the job to be cleaned up.\n+    let pid = match env::var(\"BOOTSTRAP_PARENT_ID\") {\n+        Ok(s) => s,\n+        Err(..) => return,\n+    };\n+\n+    let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n+    assert!(parent != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+    let mut parent_handle = 0 as *mut _;\n+    let r = DuplicateHandle(GetCurrentProcess(), job,\n+                            parent, &mut parent_handle,\n+                            0, FALSE, DUPLICATE_SAME_ACCESS);\n+\n+    // If this failed, well at least we tried! An example of DuplicateHandle\n+    // failing in the past has been when the wrong python2 package spawed this\n+    // build system (e.g. the `python2` package in MSYS instead of\n+    // `mingw-w64-x86_64-python2`. Not sure why it failed, but the \"failure\n+    // mode\" here is that we only clean everything up when the build system\n+    // dies, not when the python parent does, so not too bad.\n+    if r != 0 {\n+        CloseHandle(job);\n+    }\n+}"}, {"sha": "6f962aae923348040e1222da35a6902d38c9c530", "filename": "src/bootstrap/build/mod.rs", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fmod.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,452 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::{self, File};\n+use std::path::{PathBuf, Path};\n+use std::process::Command;\n+\n+use build_helper::{run_silent, output};\n+use gcc;\n+use num_cpus;\n+\n+use build::util::{exe, mtime, libdir, add_lib_path};\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+mod cc;\n+mod channel;\n+mod compile;\n+mod config;\n+mod flags;\n+mod native;\n+mod sanity;\n+mod step;\n+mod util;\n+\n+pub use build::config::Config;\n+pub use build::flags::Flags;\n+\n+#[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n+pub struct Compiler<'a> {\n+    stage: u32,\n+    host: &'a str,\n+}\n+\n+pub struct Build {\n+    // User-specified configuration via config.toml\n+    config: Config,\n+\n+    // User-specified configuration via CLI flags\n+    flags: Flags,\n+\n+    // Derived properties from the above two configurations\n+    cargo: PathBuf,\n+    rustc: PathBuf,\n+    src: PathBuf,\n+    out: PathBuf,\n+    release: String,\n+    unstable_features: bool,\n+    ver_hash: Option<String>,\n+    short_ver_hash: Option<String>,\n+    ver_date: Option<String>,\n+    version: String,\n+    bootstrap_key: String,\n+\n+    // Runtime state filled in later on\n+    cc: HashMap<String, (gcc::Tool, PathBuf)>,\n+    cxx: HashMap<String, gcc::Tool>,\n+    compiler_rt_built: RefCell<HashMap<String, PathBuf>>,\n+}\n+\n+impl Build {\n+    pub fn new(flags: Flags, config: Config) -> Build {\n+        let cwd = t!(env::current_dir());\n+        let src = flags.src.clone().unwrap_or(cwd.clone());\n+        let out = cwd.join(\"build\");\n+\n+        let stage0_root = out.join(&config.build).join(\"stage0/bin\");\n+        let rustc = match config.rustc {\n+            Some(ref s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"rustc\", &config.build)),\n+        };\n+        let cargo = match config.cargo {\n+            Some(ref s) => PathBuf::from(s),\n+            None => stage0_root.join(exe(\"cargo\", &config.build)),\n+        };\n+\n+        Build {\n+            flags: flags,\n+            config: config,\n+            cargo: cargo,\n+            rustc: rustc,\n+            src: src,\n+            out: out,\n+\n+            release: String::new(),\n+            unstable_features: false,\n+            ver_hash: None,\n+            short_ver_hash: None,\n+            ver_date: None,\n+            version: String::new(),\n+            bootstrap_key: String::new(),\n+            cc: HashMap::new(),\n+            cxx: HashMap::new(),\n+            compiler_rt_built: RefCell::new(HashMap::new()),\n+        }\n+    }\n+\n+    pub fn build(&mut self) {\n+        use build::step::Source::*;\n+\n+        // see comments in job.rs for what's going on here\n+        #[cfg(windows)]\n+        fn setup_job() {\n+            mod job;\n+            unsafe { job::setup() }\n+        }\n+        #[cfg(not(windows))] fn setup_job() {}\n+        setup_job();\n+\n+        cc::find(self);\n+        sanity::check(self);\n+        channel::collect(self);\n+        self.update_submodules();\n+\n+        for target in step::all(self) {\n+            match target.src {\n+                Llvm { _dummy } => {\n+                    native::llvm(self, target.target);\n+                }\n+                CompilerRt { _dummy } => {\n+                    native::compiler_rt(self, target.target);\n+                }\n+                Libstd { stage, compiler } => {\n+                    compile::std(self, stage, target.target, &compiler);\n+                }\n+                Librustc { stage, compiler } => {\n+                    compile::rustc(self, stage, target.target, &compiler);\n+                }\n+                Rustc { stage } => {\n+                    println!(\"ok, rustc stage{} in {}\", stage, target.target);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn update_submodules(&self) {\n+        if !self.config.submodules {\n+            return\n+        }\n+        if fs::metadata(self.src.join(\".git\")).is_err() {\n+            return\n+        }\n+        let out = output(Command::new(\"git\").arg(\"submodule\").arg(\"status\"));\n+        if !out.lines().any(|l| l.starts_with(\"+\") || l.starts_with(\"-\")) {\n+            return\n+        }\n+\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"sync\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"init\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"update\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"update\")\n+                                    .arg(\"--recursive\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"status\")\n+                                    .arg(\"--recursive\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"foreach\")\n+                                    .arg(\"--recursive\")\n+                                    .arg(\"git\").arg(\"clean\").arg(\"-fdx\"));\n+        self.run(Command::new(\"git\").arg(\"submodule\").arg(\"foreach\")\n+                                    .arg(\"--recursive\")\n+                                    .arg(\"git\").arg(\"checkout\").arg(\".\"));\n+    }\n+\n+    /// Clear out `dir` if our build has been flagged as dirty, and also set\n+    /// ourselves as dirty if `file` changes when `f` is executed.\n+    fn clear_if_dirty(&self, dir: &Path, input: &Path) {\n+        let stamp = dir.join(\".stamp\");\n+        if mtime(&stamp) < mtime(input) {\n+            self.verbose(&format!(\"Dirty - {}\", dir.display()));\n+            let _ = fs::remove_dir_all(dir);\n+        }\n+        t!(fs::create_dir_all(dir));\n+        t!(File::create(stamp));\n+    }\n+\n+    /// Prepares an invocation of `cargo` to be run.\n+    ///\n+    /// This will create a `Command` that represents a pending execution of\n+    /// Cargo for the specified stage, whether or not the standard library is\n+    /// being built, and using the specified compiler targeting `target`.\n+    // FIXME: aren't stage/compiler duplicated?\n+    fn cargo(&self, stage: u32, compiler: &Compiler, is_std: bool,\n+             target: &str, cmd: &str) -> Command {\n+        let mut cargo = Command::new(&self.cargo);\n+        let host = compiler.host;\n+        let out_dir = self.stage_out(stage, host, is_std);\n+        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n+             .arg(cmd)\n+             .arg(\"--target\").arg(target)\n+             .arg(\"-j\").arg(self.jobs().to_string());\n+\n+        // Customize the compiler we're running. Specify the compiler to cargo\n+        // as our shim and then pass it some various options used to configure\n+        // how the actual compiler itself is called.\n+        cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+             .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n+             .env(\"RUSTC_STAGE\", self.stage_arg(stage, compiler).to_string())\n+             .env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+             .env(\"RUSTC_CODEGEN_UNITS\",\n+                  self.config.rust_codegen_units.to_string())\n+             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n+                  self.config.rust_debug_assertions.to_string())\n+             .env(\"RUSTC_SNAPSHOT\", &self.rustc)\n+             .env(\"RUSTC_SYSROOT\", self.sysroot(stage, host))\n+             .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir())\n+             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"))\n+             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+             .env(\"RUSTDOC\", self.tool(compiler, \"rustdoc\"));\n+\n+        // Specify some variuos options for build scripts used throughout the\n+        // build.\n+        //\n+        // FIXME: the guard against msvc shouldn't need to be here\n+        if !target.contains(\"msvc\") {\n+            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target))\n+                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target));\n+        }\n+\n+        // Environment variables *required* needed throughout the build\n+        //\n+        // FIXME: should update code to not require this env vars\n+        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n+\n+        if self.config.verbose || self.flags.verbose {\n+            cargo.arg(\"-v\");\n+        }\n+        if self.config.rust_optimize {\n+            cargo.arg(\"--release\");\n+        }\n+        self.add_rustc_lib_path(compiler, &mut cargo);\n+        return cargo\n+    }\n+\n+    /// Get a path to the compiler specified.\n+    fn compiler_path(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            self.rustc.clone()\n+        } else {\n+            self.sysroot(compiler.stage, compiler.host).join(\"bin\")\n+                .join(exe(\"rustc\", compiler.host))\n+        }\n+    }\n+\n+    /// Get the specified tool next to the specified compiler\n+    fn tool(&self, compiler: &Compiler, tool: &str) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            assert!(tool == \"rustdoc\", \"no tools other than rustdoc in stage0\");\n+            let mut rustdoc = self.rustc.clone();\n+            rustdoc.pop();\n+            rustdoc.push(exe(\"rustdoc\", &self.config.build));\n+            return rustdoc\n+        }\n+        let (stage, host) = (compiler.stage, compiler.host);\n+        self.cargo_out(stage - 1, host, false, host).join(exe(tool, host))\n+    }\n+\n+    /// Get a `Command` which is ready to run `tool` in `stage` built for\n+    /// `host`.\n+    #[allow(dead_code)] // this will be used soon\n+    fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n+        let mut cmd = Command::new(self.tool(&compiler, tool));\n+        let host = compiler.host;\n+        let stage = compiler.stage;\n+        let paths = vec![\n+            self.cargo_out(stage - 1, host, true, host).join(\"deps\"),\n+            self.cargo_out(stage - 1, host, false, host).join(\"deps\"),\n+        ];\n+        add_lib_path(paths, &mut cmd);\n+        return cmd\n+    }\n+\n+    fn stage_arg(&self, stage: u32, compiler: &Compiler) -> u32 {\n+        if stage == 0 && compiler.host != self.config.build {1} else {stage}\n+    }\n+\n+    /// Get the space-separated set of activated features for the standard\n+    /// library.\n+    fn std_features(&self) -> String {\n+        let mut features = String::new();\n+        if self.config.debug_jemalloc {\n+            features.push_str(\" debug-jemalloc\");\n+        }\n+        if self.config.use_jemalloc {\n+            features.push_str(\" jemalloc\");\n+        }\n+        return features\n+    }\n+\n+    /// Get the space-separated set of activated features for the compiler.\n+    fn rustc_features(&self, stage: u32) -> String {\n+        let mut features = String::new();\n+        if self.config.use_jemalloc {\n+            features.push_str(\" jemalloc\");\n+        }\n+        if stage > 0 {\n+            features.push_str(\" rustdoc\");\n+            features.push_str(\" rustbook\");\n+        }\n+        return features\n+    }\n+\n+    /// Component directory that Cargo will produce output into (e.g.\n+    /// release/debug)\n+    fn cargo_dir(&self) -> &'static str {\n+        if self.config.rust_optimize {\"release\"} else {\"debug\"}\n+    }\n+\n+    fn sysroot(&self, stage: u32, host: &str) -> PathBuf {\n+        if stage == 0 {\n+            self.stage_out(stage, host, false)\n+        } else {\n+            self.out.join(host).join(format!(\"stage{}\", stage))\n+        }\n+    }\n+\n+    fn sysroot_libdir(&self, stage: u32, host: &str, target: &str) -> PathBuf {\n+        self.sysroot(stage, host).join(\"lib\").join(\"rustlib\")\n+            .join(target).join(\"lib\")\n+    }\n+\n+    /// Returns the root directory for all output generated in a particular\n+    /// stage when running with a particular host compiler.\n+    ///\n+    /// The `is_std` flag indicates whether the root directory is for the\n+    /// bootstrap of the standard library or for the compiler.\n+    fn stage_out(&self, stage: u32, host: &str, is_std: bool) -> PathBuf {\n+        self.out.join(host)\n+            .join(format!(\"stage{}{}\", stage, if is_std {\"-std\"} else {\"-rustc\"}))\n+    }\n+\n+    /// Returns the root output directory for all Cargo output in a given stage,\n+    /// running a particular comipler, wehther or not we're building the\n+    /// standard library, and targeting the specified architecture.\n+    fn cargo_out(&self, stage: u32, host: &str, is_std: bool,\n+                 target: &str) -> PathBuf {\n+        self.stage_out(stage, host, is_std).join(target).join(self.cargo_dir())\n+    }\n+\n+    /// Root output directory for LLVM compiled for `target`\n+    fn llvm_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"llvm\")\n+    }\n+\n+    /// Root output directory for compiler-rt compiled for `target`\n+    fn compiler_rt_out(&self, target: &str) -> PathBuf {\n+        self.out.join(target).join(\"compiler-rt\")\n+    }\n+\n+    fn add_rustc_lib_path(&self, compiler: &Compiler, cmd: &mut Command) {\n+        // Windows doesn't need dylib path munging because the dlls for the\n+        // compiler live next to the compiler and the system will find them\n+        // automatically.\n+        if cfg!(windows) { return }\n+\n+        add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n+    }\n+\n+    fn rustc_libdir(&self, compiler: &Compiler) -> PathBuf {\n+        if compiler.is_snapshot(self) {\n+            self.rustc_snapshot_libdir()\n+        } else {\n+            self.sysroot(compiler.stage, compiler.host)\n+                .join(libdir(compiler.host))\n+        }\n+    }\n+\n+    fn rustc_snapshot_libdir(&self) -> PathBuf {\n+        self.rustc.parent().unwrap().parent().unwrap()\n+            .join(libdir(&self.config.build))\n+    }\n+\n+    fn run(&self, cmd: &mut Command) {\n+        self.verbose(&format!(\"running: {:?}\", cmd));\n+        run_silent(cmd)\n+    }\n+\n+    fn verbose(&self, msg: &str) {\n+        if self.flags.verbose || self.config.verbose {\n+            println!(\"{}\", msg);\n+        }\n+    }\n+\n+    fn jobs(&self) -> u32 {\n+        self.flags.jobs.unwrap_or(num_cpus::get() as u32)\n+    }\n+\n+    fn cc(&self, target: &str) -> &Path {\n+        self.cc[target].0.path()\n+    }\n+\n+    fn cflags(&self, target: &str) -> String {\n+        self.cc[target].0.args().iter()\n+            .map(|s| s.to_string_lossy())\n+            .collect::<Vec<_>>()\n+            .join(\" \")\n+    }\n+\n+    fn ar(&self, target: &str) -> &Path {\n+        &self.cc[target].1\n+    }\n+\n+    fn cxx(&self, target: &str) -> &Path {\n+        self.cxx[target].path()\n+    }\n+\n+    fn rustc_flags(&self, target: &str) -> Vec<String> {\n+        let mut base = match target {\n+            \"arm-unknown-linux-gnueabihf\" => {\n+                vec![\"-Ctarget-feature=+v6,+vfp2\".to_string()]\n+            }\n+            \"mips-unknown-linux-gnu\" => {\n+                vec![\"-Ctarget-cpu=mips32r2\".to_string(),\n+                     \"-Ctarget-feature=+mips32r2\".to_string(),\n+                     \"-Csoft-float\".to_string()]\n+            }\n+            \"mipsel-unknown-linux-gnu\" => {\n+                vec![\"-Ctarget-cpu=mips32\".to_string(),\n+                     \"-Ctarget-feature=+mips32\".to_string()]\n+            }\n+            _ => Vec::new(),\n+        };\n+        if target != self.config.build && !target.contains(\"msvc\") {\n+            base.push(format!(\"-Clinker={}\", self.cc(target).display()));\n+        }\n+        return base\n+    }\n+}\n+\n+impl<'a> Compiler<'a> {\n+    fn new(stage: u32, host: &'a str) -> Compiler<'a> {\n+        Compiler { stage: stage, host: host }\n+    }\n+\n+    fn is_snapshot(&self, build: &Build) -> bool {\n+        self.stage == 0 && self.host == build.config.build\n+    }\n+}"}, {"sha": "6ad5f4041239418c3741e27924f7fd1ff4a1dbf6", "filename": "src/bootstrap/build/native.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fnative.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::path::Path;\n+use std::process::Command;\n+use std::fs;\n+\n+use build_helper::output;\n+use cmake;\n+\n+use build::Build;\n+use build::util::{exe, staticlib};\n+\n+pub fn llvm(build: &Build, target: &str) {\n+    // If we're using a custom LLVM bail out here, but we can only use a\n+    // custom LLVM for the build triple.\n+    if let Some(config) = build.config.target_config.get(target) {\n+        if let Some(ref s) = config.llvm_config {\n+            return check_llvm_version(build, s);\n+        }\n+    }\n+\n+    // If the cleaning trigger is newer than our built artifacts (or if the\n+    // artifacts are missing) then we keep going, otherwise we bail out.\n+    let dst = build.llvm_out(target);\n+    let stamp = build.src.join(\"src/rustllvm/llvm-auto-clean-trigger\");\n+    let llvm_config = dst.join(\"bin\").join(exe(\"llvm-config\", target));\n+    build.clear_if_dirty(&dst, &stamp);\n+    if fs::metadata(llvm_config).is_ok() {\n+        return\n+    }\n+\n+    let _ = fs::remove_dir_all(&dst.join(\"build\"));\n+    t!(fs::create_dir_all(&dst.join(\"build\")));\n+    let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n+\n+    // http://llvm.org/docs/CMake.html\n+    let mut cfg = cmake::Config::new(build.src.join(\"src/llvm\"));\n+    cfg.target(target)\n+       .host(&build.config.build)\n+       .out_dir(&dst)\n+       .profile(if build.config.llvm_optimize {\"Release\"} else {\"Debug\"})\n+       .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n+       .define(\"LLVM_TARGETS_TO_BUILD\", \"X86;ARM;AArch64;Mips;PowerPC\")\n+       .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n+       .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n+       .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")\n+       .define(\"LLVM_ENABLE_ZLIB\", \"OFF\")\n+       .define(\"WITH_POLLY\", \"OFF\")\n+       .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n+       .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+       .define(\"LLVM_PARALLEL_COMPILE_JOBS\", build.jobs().to_string());\n+\n+    if target.starts_with(\"i686\") {\n+        cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n+    }\n+\n+    // http://llvm.org/docs/HowToCrossCompileLLVM.html\n+    if target != build.config.build {\n+        // FIXME: if the llvm root for the build triple is overridden then we\n+        //        should use llvm-tblgen from there, also should verify that it\n+        //        actually exists most of the time in normal installs of LLVM.\n+        let host = build.llvm_out(&build.config.build).join(\"bin/llvm-tblgen\");\n+        cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n+           .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n+           .define(\"LLVM_TABLEGEN\", &host)\n+           .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n+    }\n+\n+    // MSVC handles compiler business itself\n+    if !target.contains(\"msvc\") {\n+        if build.config.ccache {\n+           cfg.define(\"CMAKE_C_COMPILER\", \"ccache\")\n+              .define(\"CMAKE_C_COMPILER_ARG1\", build.cc(target))\n+              .define(\"CMAKE_CXX_COMPILER\", \"ccache\")\n+              .define(\"CMAKE_CXX_COMPILER_ARG1\", build.cxx(target));\n+        } else {\n+           cfg.define(\"CMAKE_C_COMPILER\", build.cc(target))\n+              .define(\"CMAKE_CXX_COMPILER\", build.cxx(target));\n+        }\n+        cfg.build_arg(\"-j\").build_arg(build.jobs().to_string());\n+    }\n+\n+    // FIXME: we don't actually need to build all LLVM tools and all LLVM\n+    //        libraries here, e.g. we just want a few components and a few\n+    //        tools. Figure out how to filter them down and only build the right\n+    //        tools and libs on all platforms.\n+    cfg.build();\n+}\n+\n+fn check_llvm_version(build: &Build, llvm_config: &Path) {\n+    if !build.config.llvm_version_check {\n+        return\n+    }\n+\n+    let mut cmd = Command::new(llvm_config);\n+    let version = output(cmd.arg(\"--version\"));\n+    if version.starts_with(\"3.5\") || version.starts_with(\"3.6\") ||\n+       version.starts_with(\"3.7\") {\n+        return\n+    }\n+    panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n+}\n+\n+pub fn compiler_rt(build: &Build, target: &str) {\n+    let dst = build.compiler_rt_out(target);\n+    let arch = target.split('-').next().unwrap();\n+    let mode = if build.config.rust_optimize {\"Release\"} else {\"Debug\"};\n+    let (dir, build_target, libname) = if target.contains(\"linux\") {\n+        let os = if target.contains(\"android\") {\"-android\"} else {\"\"};\n+        let target = format!(\"clang_rt.builtins-{}{}\", arch, os);\n+        (\"linux\".to_string(), target.clone(), target)\n+    } else if target.contains(\"darwin\") {\n+        let target = format!(\"clang_rt.builtins_{}_osx\", arch);\n+        (\"builtins\".to_string(), target.clone(), target)\n+    } else if target.contains(\"windows-gnu\") {\n+        let target = format!(\"clang_rt.builtins-{}\", arch);\n+        (\"windows\".to_string(), target.clone(), target)\n+    } else if target.contains(\"windows-msvc\") {\n+        (format!(\"windows/{}\", mode),\n+         \"lib/builtins/builtins\".to_string(),\n+         format!(\"clang_rt.builtins-{}\", arch.replace(\"i686\", \"i386\")))\n+    } else {\n+        panic!(\"can't get os from target: {}\", target)\n+    };\n+    let output = dst.join(\"build/lib\").join(dir)\n+                    .join(staticlib(&libname, target));\n+    build.compiler_rt_built.borrow_mut().insert(target.to_string(),\n+                                                output.clone());\n+    if fs::metadata(&output).is_ok() {\n+        return\n+    }\n+    let _ = fs::remove_dir_all(&dst);\n+    t!(fs::create_dir_all(&dst));\n+    let build_llvm_config = build.llvm_out(&build.config.build)\n+                                 .join(\"bin\")\n+                                 .join(exe(\"llvm-config\", &build.config.build));\n+    let mut cfg = cmake::Config::new(build.src.join(\"src/compiler-rt\"));\n+    cfg.target(target)\n+       .host(&build.config.build)\n+       .out_dir(&dst)\n+       .profile(mode)\n+       .define(\"LLVM_CONFIG_PATH\", build_llvm_config)\n+       .define(\"COMPILER_RT_DEFAULT_TARGET_TRIPLE\", target)\n+       .define(\"COMPILER_RT_BUILD_SANITIZERS\", \"OFF\")\n+       .define(\"COMPILER_RT_BUILD_EMUTLS\", \"OFF\")\n+       .define(\"CMAKE_C_COMPILER\", build.cc(target))\n+       .build_target(&build_target);\n+    cfg.build();\n+}"}, {"sha": "40f4c7076092d78f5e70dcfe16182f4fcf0a195a", "filename": "src/bootstrap/build/sanity.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fsanity.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::ffi::{OsStr, OsString};\n+use std::fs;\n+use std::process::Command;\n+\n+use build_helper::output;\n+\n+use build::Build;\n+\n+pub fn check(build: &mut Build) {\n+    let mut checked = HashSet::new();\n+    let path = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+    let mut need_cmd = |cmd: &OsStr| {\n+        if !checked.insert(cmd.to_owned()) {\n+            return\n+        }\n+        for path in env::split_paths(&path).map(|p| p.join(cmd)) {\n+            if fs::metadata(&path).is_ok() ||\n+               fs::metadata(path.with_extension(\"exe\")).is_ok() {\n+                return\n+            }\n+        }\n+        panic!(\"\\n\\ncouldn't find required command: {:?}\\n\\n\", cmd);\n+    };\n+\n+    // If we've got a git directory we're gona need git to update\n+    // submodules and learn about various other aspects.\n+    if fs::metadata(build.src.join(\".git\")).is_ok() {\n+        need_cmd(\"git\".as_ref());\n+    }\n+\n+    // We need cmake, but only if we're actually building LLVM\n+    for host in build.config.host.iter() {\n+        if let Some(config) = build.config.target_config.get(host) {\n+            if config.llvm_config.is_some() {\n+                continue\n+            }\n+        }\n+        need_cmd(\"cmake\".as_ref());\n+        break\n+    }\n+\n+    need_cmd(\"python\".as_ref());\n+\n+    // We're gonna build some custom C code here and there, host triples\n+    // also build some C++ shims for LLVM so we need a C++ compiler.\n+    for target in build.config.target.iter() {\n+        need_cmd(build.cc(target).as_ref());\n+        need_cmd(build.ar(target).as_ref());\n+    }\n+    for host in build.config.host.iter() {\n+        need_cmd(build.cxx(host).as_ref());\n+    }\n+\n+    for target in build.config.target.iter() {\n+        // Either can't build or don't want to run jemalloc on these targets\n+        if target.contains(\"rumprun\") ||\n+           target.contains(\"bitrig\") ||\n+           target.contains(\"openbsd\") ||\n+           target.contains(\"msvc\") {\n+            build.config.use_jemalloc = false;\n+        }\n+\n+        // Can't compile for iOS unless we're on OSX\n+        if target.contains(\"apple-ios\") &&\n+           !build.config.build.contains(\"apple-darwin\") {\n+            panic!(\"the iOS target is only supported on OSX\");\n+        }\n+\n+        // Make sure musl-root is valid if specified\n+        if target.contains(\"musl\") {\n+            match build.config.musl_root {\n+                Some(ref root) => {\n+                    if fs::metadata(root.join(\"lib/libc.a\")).is_err() {\n+                        panic!(\"couldn't find libc.a in musl dir: {}\",\n+                               root.join(\"lib\").display());\n+                    }\n+                    if fs::metadata(root.join(\"lib/libunwind.a\")).is_err() {\n+                        panic!(\"couldn't find libunwind.a in musl dir: {}\",\n+                               root.join(\"lib\").display());\n+                    }\n+                }\n+                None => {\n+                    panic!(\"when targeting MUSL the build.musl-root option \\\n+                            must be specified in config.toml\")\n+                }\n+            }\n+        }\n+\n+        if target.contains(\"msvc\") {\n+            // There are three builds of cmake on windows: MSVC, MinGW, and\n+            // Cygwin. The Cygwin build does not have generators for Visual\n+            // Studio, so detect that here and error.\n+            let out = output(Command::new(\"cmake\").arg(\"--help\"));\n+            if !out.contains(\"Visual Studio\") {\n+                panic!(\"\n+cmake does not support Visual Studio generators.\n+\n+This is likely due to it being an msys/cygwin build of cmake,\n+rather than the required windows version, built using MinGW\n+or Visual Studio.\n+\n+If you are building under msys2 try installing the mingw-w64-x86_64-cmake\n+package instead of cmake:\n+\n+$ pacman -R cmake && pacman -S mingw-w64-x86_64-cmake\n+\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "2fbf1a6ad1db251240d34a560176241d0ca5e602", "filename": "src/bootstrap/build/step.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Fstep.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+\n+use build::{Build, Compiler};\n+\n+#[derive(Hash, Eq, PartialEq, Clone, Debug)]\n+pub struct Step<'a> {\n+    pub src: Source<'a>,\n+    pub target: &'a str,\n+}\n+\n+macro_rules! targets {\n+    ($m:ident) => {\n+        $m! {\n+            (rustc, Rustc { stage: u32 }),\n+            (libstd, Libstd { stage: u32, compiler: Compiler<'a> }),\n+            (librustc, Librustc { stage: u32, compiler: Compiler<'a> }),\n+            (llvm, Llvm { _dummy: () }),\n+            (compiler_rt, CompilerRt { _dummy: () }),\n+        }\n+    }\n+}\n+\n+macro_rules! item { ($a:item) => ($a) }\n+\n+macro_rules! define_source {\n+    ($(($short:ident, $name:ident { $($args:tt)* }),)*) => {\n+        item! {\n+            #[derive(Hash, Eq, PartialEq, Clone, Debug)]\n+            pub enum Source<'a> {\n+                $($name { $($args)* }),*\n+            }\n+        }\n+    }\n+}\n+\n+targets!(define_source);\n+\n+pub fn all(build: &Build) -> Vec<Step> {\n+    let mut ret = Vec::new();\n+    let mut all = HashSet::new();\n+    for target in top_level(build) {\n+        fill(build, &target, &mut ret, &mut all);\n+    }\n+    return ret;\n+\n+    fn fill<'a>(build: &'a Build,\n+                target: &Step<'a>,\n+                ret: &mut Vec<Step<'a>>,\n+                set: &mut HashSet<Step<'a>>) {\n+        if set.insert(target.clone()) {\n+            for dep in target.deps(build) {\n+                fill(build, &dep, ret, set);\n+            }\n+            ret.push(target.clone());\n+        }\n+    }\n+}\n+\n+fn top_level(build: &Build) -> Vec<Step> {\n+    let mut targets = Vec::new();\n+    let stage = build.flags.stage.unwrap_or(2);\n+\n+    let host = Step {\n+        src: Source::Llvm { _dummy: () },\n+        target: build.flags.host.iter().next()\n+                     .unwrap_or(&build.config.build),\n+    };\n+    let target = Step {\n+        src: Source::Llvm { _dummy: () },\n+        target: build.flags.target.iter().next().map(|x| &x[..])\n+                     .unwrap_or(host.target)\n+    };\n+\n+    add_steps(build, stage, &host, &target, &mut targets);\n+\n+    if targets.len() == 0 {\n+        let t = Step {\n+            src: Source::Llvm { _dummy: () },\n+            target: &build.config.build,\n+        };\n+        for host in build.config.host.iter() {\n+            if !build.flags.host.contains(host) {\n+                continue\n+            }\n+            let host = t.target(host);\n+            targets.push(host.librustc(stage, host.compiler(stage)));\n+            for target in build.config.target.iter() {\n+                if !build.flags.target.contains(target) {\n+                    continue\n+                }\n+                targets.push(host.target(target)\n+                                 .libstd(stage, host.compiler(stage)));\n+            }\n+        }\n+    }\n+\n+    return targets\n+\n+}\n+\n+fn add_steps<'a>(build: &'a Build,\n+                 stage: u32,\n+                 host: &Step<'a>,\n+                 target: &Step<'a>,\n+                 targets: &mut Vec<Step<'a>>) {\n+    for step in build.flags.step.iter() {\n+        let compiler = host.compiler(stage);\n+        match &step[..] {\n+            \"libstd\" => targets.push(target.libstd(stage, compiler)),\n+            \"librustc\" => targets.push(target.libstd(stage, compiler)),\n+            \"rustc\" => targets.push(host.rustc(stage)),\n+            \"llvm\" => targets.push(target.llvm(())),\n+            \"compiler-rt\" => targets.push(target.compiler_rt(())),\n+            _ => panic!(\"unknown build target: `{}`\", step),\n+        }\n+    }\n+}\n+\n+macro_rules! constructors {\n+    ($(($short:ident, $name:ident { $($arg:ident: $t:ty),* }),)*) => {$(\n+        fn $short(&self, $($arg: $t),*) -> Step<'a> {\n+            Step {\n+                src: Source::$name { $($arg: $arg),* },\n+                target: self.target,\n+            }\n+        }\n+    )*}\n+}\n+\n+impl<'a> Step<'a> {\n+    fn compiler(&self, stage: u32) -> Compiler<'a> {\n+        Compiler::new(stage, self.target)\n+    }\n+\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, src: self.src.clone() }\n+    }\n+\n+    targets!(constructors);\n+\n+    pub fn deps(&self, build: &'a Build) -> Vec<Step<'a>> {\n+        match self.src {\n+            Source::Rustc { stage: 0 } => {\n+                if self.target == build.config.build {\n+                    Vec::new()\n+                } else {\n+                    let compiler = Compiler::new(0, &build.config.build);\n+                    vec![self.librustc(0, compiler)]\n+                }\n+            }\n+            Source::Rustc { stage } => {\n+                vec![self.librustc(stage - 1, self.compiler(stage - 1))]\n+            }\n+            Source::Librustc { stage, compiler } => {\n+                vec![self.libstd(stage, compiler), self.llvm(())]\n+            }\n+            Source::Libstd { stage: _, compiler } => {\n+                vec![self.compiler_rt(()),\n+                     self.rustc(compiler.stage).target(compiler.host)]\n+            }\n+            Source::CompilerRt { _dummy } => {\n+                vec![self.llvm(()).target(&build.config.build)]\n+            }\n+            Source::Llvm { _dummy } => Vec::new(),\n+        }\n+    }\n+}"}, {"sha": "6c700671f11115d396897e1e537a5ca66f6364f0", "filename": "src/bootstrap/build/util.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fbuild%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuild%2Futil.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,97 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::path::{Path, PathBuf};\n+use std::fs;\n+use std::process::Command;\n+\n+use bootstrap::{dylib_path, dylib_path_var};\n+use filetime::FileTime;\n+\n+pub fn staticlib(name: &str, target: &str) -> String {\n+    if target.contains(\"windows-msvc\") {\n+        format!(\"{}.lib\", name)\n+    } else {\n+        format!(\"lib{}.a\", name)\n+    }\n+}\n+\n+pub fn mtime(path: &Path) -> FileTime {\n+    fs::metadata(path).map(|f| {\n+        FileTime::from_last_modification_time(&f)\n+    }).unwrap_or(FileTime::zero())\n+}\n+\n+#[allow(dead_code)] // this will be used soon\n+pub fn cp_r(src: &Path, dst: &Path) {\n+    for f in t!(fs::read_dir(src)) {\n+        let f = t!(f);\n+        let path = f.path();\n+        let name = path.file_name().unwrap();\n+        let dst = dst.join(name);\n+        if t!(f.file_type()).is_dir() {\n+            let _ = fs::remove_dir_all(&dst);\n+            t!(fs::create_dir(&dst));\n+            cp_r(&path, &dst);\n+        } else {\n+            let _ = fs::remove_file(&dst);\n+            t!(fs::hard_link(&path, dst));\n+        }\n+    }\n+}\n+\n+/// Given an executable called `name`, return the filename for the\n+/// executable for a particular target.\n+pub fn exe(name: &str, target: &str) -> String {\n+    if target.contains(\"windows\") {\n+        format!(\"{}.exe\", name)\n+    } else {\n+        name.to_string()\n+    }\n+}\n+\n+pub fn is_dylib(name: &str) -> bool {\n+    name.ends_with(\".dylib\") || name.ends_with(\".so\") || name.ends_with(\".dll\")\n+}\n+\n+pub fn libdir(target: &str) -> &'static str {\n+    if target.contains(\"windows\") {\"bin\"} else {\"lib\"}\n+}\n+\n+pub fn add_lib_path(path: Vec<PathBuf>, cmd: &mut Command) {\n+    let mut list = dylib_path();\n+    for path in path {\n+        list.insert(0, path);\n+    }\n+    cmd.env(dylib_path_var(), t!(env::join_paths(list)));\n+}\n+\n+#[allow(dead_code)] // this will be used soon\n+pub fn up_to_date(src: &Path, dst: &Path) -> bool {\n+    let threshold = mtime(dst);\n+    let meta = t!(fs::metadata(src));\n+    if meta.is_dir() {\n+        dir_up_to_date(src, &threshold)\n+    } else {\n+        FileTime::from_last_modification_time(&meta) <= threshold\n+    }\n+}\n+\n+fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {\n+    t!(fs::read_dir(src)).map(|e| t!(e)).all(|e| {\n+        let meta = t!(e.metadata());\n+        if meta.is_dir() {\n+            dir_up_to_date(&e.path(), threshold)\n+        } else {\n+            FileTime::from_last_modification_time(&meta) < *threshold\n+        }\n+    })\n+}"}, {"sha": "3158a3ab058609a9719626dc656e01c38aee109b", "filename": "src/bootstrap/lib.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::ffi::OsString;\n+use std::path::PathBuf;\n+\n+pub fn dylib_path_var() -> &'static str {\n+    if cfg!(target_os = \"windows\") {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    }\n+}\n+\n+pub fn dylib_path() -> Vec<PathBuf> {\n+    env::split_paths(&env::var_os(dylib_path_var()).unwrap_or(OsString::new()))\n+        .collect()\n+}"}, {"sha": "32432132c1730bfa42aa095ca2b3fe88b1189e3c", "filename": "src/bootstrap/main.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmain.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+extern crate bootstrap;\n+extern crate build_helper;\n+extern crate cmake;\n+extern crate filetime;\n+extern crate gcc;\n+extern crate getopts;\n+extern crate libc;\n+extern crate num_cpus;\n+extern crate rustc_serialize;\n+extern crate toml;\n+\n+use std::env;\n+\n+use build::{Flags, Config, Build};\n+\n+mod build;\n+\n+fn main() {\n+    let args = env::args().skip(1).collect::<Vec<_>>();\n+    let flags = Flags::parse(&args);\n+    let mut config = Config::parse(&flags.build, flags.config.clone());\n+    if std::fs::metadata(\"config.mk\").is_ok() {\n+        config.update_with_config_mk();\n+    }\n+    Build::new(flags, config).build();\n+}"}, {"sha": "1157346d774ab3882f9d65f12d604c8e36833125", "filename": "src/bootstrap/mk/Makefile.in", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,23 @@\n+# Copyright 20126 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+include config.mk\n+include $(CFG_SRC_DIR)mk/util.mk\n+\n+ifdef VERBOSE\n+BOOTSTRAP_ARGS := -v\n+else\n+BOOTSTRAP_ARGS :=\n+endif\n+\n+BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py $(BOOTSTRAP_ARGS)\n+\n+all:\n+\t$(Q)$(BOOTSTRAP)"}, {"sha": "0c30360ba79f046c16f0078149d5fdccc80a76b0", "filename": "src/bootstrap/rustc.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbootstrap%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Frustc.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate bootstrap;\n+\n+use std::env;\n+use std::ffi::OsString;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    let args = env::args_os().skip(1).collect::<Vec<_>>();\n+    // Detect whether or not we're a build script depending on whether --target\n+    // is passed (a bit janky...)\n+    let is_build_script = args.iter()\n+                              .position(|i| i.to_str() == Some(\"--target\"))\n+                              .is_none();\n+\n+    // Build scripts always use the snapshot compiler which is guaranteed to be\n+    // able to produce an executable, whereas intermediate compilers may not\n+    // have the standard library built yet and may not be able to produce an\n+    // executable. Otherwise we just use the standard compiler we're\n+    // bootstrapping with.\n+    let rustc = if is_build_script {\n+        env::var_os(\"RUSTC_SNAPSHOT\").unwrap()\n+    } else {\n+        env::var_os(\"RUSTC_REAL\").unwrap()\n+    };\n+\n+    let mut cmd = Command::new(rustc);\n+    cmd.args(&args)\n+       .arg(\"--cfg\").arg(format!(\"stage{}\", env::var(\"RUSTC_STAGE\").unwrap()));\n+\n+    if is_build_script {\n+        // Build scripts are always built with the snapshot compiler, so we need\n+        // to be sure to set up the right path information for the OS dynamic\n+        // linker to find the libraries in question.\n+        if let Some(p) = env::var_os(\"RUSTC_SNAPSHOT_LIBDIR\") {\n+            let mut path = bootstrap::dylib_path();\n+            path.insert(0, PathBuf::from(p));\n+            cmd.env(bootstrap::dylib_path_var(), env::join_paths(path).unwrap());\n+        }\n+    } else {\n+        cmd.arg(\"--sysroot\").arg(env::var_os(\"RUSTC_SYSROOT\").unwrap());\n+\n+        // When we build Rust dylibs they're all intended for intermediate\n+        // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n+        // linking all deps statically into the dylib.\n+        cmd.arg(\"-Cprefer-dynamic\");\n+\n+        if let Some(s) = env::var_os(\"MUSL_ROOT\") {\n+            let mut root = OsString::from(\"native=\");\n+            root.push(&s);\n+            root.push(\"/lib\");\n+            cmd.arg(\"-L\").arg(&root);\n+        }\n+    }\n+\n+    // Set various options from config.toml to configure how we're building\n+    // code.\n+    if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {\n+        cmd.arg(\"-g\");\n+    }\n+    if env::var(\"RUSTC_RPATH\") == Ok(\"true\".to_string()) {\n+        cmd.arg(\"-Crpath\");\n+    }\n+    let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n+        Ok(s) => if s == \"true\" {\"y\"} else {\"n\"},\n+        Err(..) => \"n\",\n+    };\n+    cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n+    if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n+        cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n+    }\n+    if let Ok(s) = env::var(\"RUSTC_FLAGS\") {\n+        cmd.args(&s.split(\" \").filter(|s| !s.is_empty()).collect::<Vec<_>>());\n+    }\n+\n+    // Actually run the compiler!\n+    std::process::exit(match cmd.status() {\n+        Ok(s) => s.code().unwrap_or(1),\n+        Err(e) => panic!(\"\\n\\nfailed to run {:?}: {}\\n\\n\", cmd, e),\n+    })\n+}"}, {"sha": "01d704f816bbc8fc00813d2636f3fe44a847db35", "filename": "src/build_helper/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbuild_helper%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbuild_helper%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+name = \"build_helper\"\n+path = \"lib.rs\""}, {"sha": "092a1cabc746fb8ab44139c76e565eb8be397c09", "filename": "src/build_helper/lib.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(warnings)]\n+\n+use std::process::{Command, Stdio};\n+use std::path::{Path, PathBuf};\n+\n+pub fn run(cmd: &mut Command) {\n+    println!(\"running: {:?}\", cmd);\n+    run_silent(cmd);\n+}\n+\n+pub fn run_silent(cmd: &mut Command) {\n+    let status = match cmd.status() {\n+        Ok(status) => status,\n+        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+    };\n+    if !status.success() {\n+        fail(&format!(\"command did not execute successfully: {:?}\\n\\\n+                       expected success, got: {}\", cmd, status));\n+    }\n+}\n+\n+pub fn gnu_target(target: &str) -> String {\n+    match target {\n+        \"i686-pc-windows-msvc\" => \"i686-pc-win32\".to_string(),\n+        \"x86_64-pc-windows-msvc\" => \"x86_64-pc-win32\".to_string(),\n+        \"i686-pc-windows-gnu\" => \"i686-w64-mingw32\".to_string(),\n+        \"x86_64-pc-windows-gnu\" => \"x86_64-w64-mingw32\".to_string(),\n+        s => s.to_string(),\n+    }\n+}\n+\n+pub fn cc2ar(cc: &Path, target: &str) -> PathBuf {\n+    if target.contains(\"musl\") || target.contains(\"msvc\") {\n+        PathBuf::from(\"ar\")\n+    } else {\n+        let file = cc.file_name().unwrap().to_str().unwrap();\n+        cc.parent().unwrap().join(file.replace(\"gcc\", \"ar\")\n+                                      .replace(\"cc\", \"ar\")\n+                                      .replace(\"clang\", \"ar\"))\n+    }\n+}\n+\n+pub fn output(cmd: &mut Command) -> String {\n+    let output = match cmd.stderr(Stdio::inherit()).output() {\n+        Ok(status) => status,\n+        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+    };\n+    if !output.status.success() {\n+        panic!(\"command did not execute successfully: {:?}\\n\\\n+                expected success, got: {}\", cmd, output.status);\n+    }\n+    String::from_utf8(output.stdout).unwrap()\n+}\n+\n+fn fail(s: &str) -> ! {\n+    println!(\"\\n\\n{}\\n\\n\", s);\n+    std::process::exit(1);\n+}"}, {"sha": "fd3f4bf0b13b1111f57a7e2ba3d394821b443663", "filename": "src/etc/tidy.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -147,7 +147,7 @@ def interesting_file(f):\n                         report_err(\"snapshot out of date (\" + date\n                             + \"): \" + line)\n                 else:\n-                    if \"SNAP\" in line:\n+                    if \"SNAP \" in line:\n                         report_warn(\"unmatched SNAP line: \" + line)\n \n             if cr_flag in line:"}, {"sha": "5af8d9e8e27c18177847a43e5dbafad039d63ea6", "filename": "src/liballoc/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"alloc\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"alloc\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }\n+alloc_system = { path = \"../liballoc_system\" }"}, {"sha": "768a0c2c0a54deb93a7bc178a25110ca1b6001f6", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"alloc_jemalloc\"\n+version = \"0.0.0\"\n+build = \"build.rs\"\n+links = \"jemalloc\"\n+\n+[lib]\n+name = \"alloc_jemalloc\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }\n+\n+[build-dependencies]\n+build_helper = { path = \"../build_helper\" }\n+gcc = \"0.3.17\"\n+\n+[features]\n+debug = []"}, {"sha": "4bc752af48eee5fdfb58a41b5fbb5b37ea987bc5", "filename": "src/liballoc_jemalloc/build.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate build_helper;\n+extern crate gcc;\n+\n+use std::env;\n+use std::path::PathBuf;\n+use std::process::Command;\n+use build_helper::run;\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=cargobuild\");\n+\n+    let target = env::var(\"TARGET\").unwrap();\n+    let host = env::var(\"HOST\").unwrap();\n+    let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+    let src_dir = env::current_dir().unwrap();\n+\n+    if let Some(jemalloc) = env::var_os(\"JEMALLOC_OVERRIDE\") {\n+        let jemalloc = PathBuf::from(jemalloc);\n+        println!(\"cargo:rustc-link-search=native={}\",\n+                 jemalloc.parent().unwrap().display());\n+        let stem = jemalloc.file_stem().unwrap().to_str().unwrap();\n+        let name = jemalloc.file_name().unwrap().to_str().unwrap();\n+        let kind = if name.ends_with(\".a\") {\"static\"} else {\"dylib\"};\n+        println!(\"cargo:rustc-link-lib={}={}\", kind, &stem[3..]);\n+        return\n+    }\n+\n+    let compiler = gcc::Config::new().get_compiler();\n+    let ar = build_helper::cc2ar(compiler.path(), &target);\n+    let cflags = compiler.args().iter().map(|s| s.to_str().unwrap())\n+                         .collect::<Vec<_>>().join(\" \");\n+\n+    let mut cmd = Command::new(\"sh\");\n+    cmd.arg(src_dir.join(\"../jemalloc/configure\").to_str().unwrap()\n+                   .replace(\"C:\\\\\", \"/c/\")\n+                   .replace(\"\\\\\", \"/\"))\n+       .current_dir(&build_dir)\n+       .env(\"CC\", compiler.path())\n+       .env(\"EXTRA_CFLAGS\", cflags)\n+       .env(\"AR\", &ar)\n+       .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n+\n+    if target.contains(\"windows-gnu\") {\n+        // A bit of history here, this used to be --enable-lazy-lock added in\n+        // #14006 which was filed with jemalloc in jemalloc/jemalloc#83 which\n+        // was also reported to MinGW:\n+        //\n+        //  http://sourceforge.net/p/mingw-w64/bugs/395/\n+        //\n+        // When updating jemalloc to 4.0, however, it was found that binaries\n+        // would exit with the status code STATUS_RESOURCE_NOT_OWNED indicating\n+        // that a thread was unlocking a mutex it never locked. Disabling this\n+        // \"lazy lock\" option seems to fix the issue, but it was enabled by\n+        // default for MinGW targets in 13473c7 for jemalloc.\n+        //\n+        // As a result of all that, force disabling lazy lock on Windows, and\n+        // after reading some code it at least *appears* that the initialization\n+        // of mutexes is otherwise ok in jemalloc, so shouldn't cause problems\n+        // hopefully...\n+        //\n+        // tl;dr: make windows behave like other platforms by disabling lazy\n+        //        locking, but requires passing an option due to a historical\n+        //        default with jemalloc.\n+        cmd.arg(\"--disable-lazy-lock\");\n+    } else if target.contains(\"ios\") || target.contains(\"android\") {\n+        cmd.arg(\"--disable-tls\");\n+    }\n+\n+    if cfg!(feature = \"debug-jemalloc\") {\n+        cmd.arg(\"--enable-debug\");\n+    }\n+\n+    // Turn off broken quarantine (see jemalloc/jemalloc#161)\n+    cmd.arg(\"--disable-fill\");\n+    cmd.arg(\"--with-jemalloc-prefix=je_\");\n+    cmd.arg(format!(\"--host={}\", build_helper::gnu_target(&target)));\n+    cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n+\n+    run(&mut cmd);\n+    run(Command::new(\"make\")\n+                .current_dir(&build_dir)\n+                .arg(\"build_lib_static\")\n+                .arg(\"-j\").arg(env::var(\"NUM_JOBS\").unwrap()));\n+\n+    if target.contains(\"windows\") {\n+        println!(\"cargo:rustc-link-lib=static=jemalloc\");\n+    } else {\n+        println!(\"cargo:rustc-link-lib=static=jemalloc_pic\");\n+    }\n+    println!(\"cargo:rustc-link-search=native={}/lib\", build_dir.display());\n+    if target.contains(\"android\") {\n+        println!(\"cargo:rustc-link-lib=gcc\");\n+    } else if !target.contains(\"windows\") {\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+    }\n+}"}, {"sha": "2c46e37ac32b20e7aa7efe7c83975c8f1da58990", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -38,7 +38,10 @@ use libc::{c_int, c_void, size_t};\n                not(target_os = \"android\"),\n                not(target_env = \"musl\")),\n            link(name = \"pthread\"))]\n-extern \"C\" {\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n+extern {\n     fn je_mallocx(size: size_t, flags: c_int) -> *mut c_void;\n     fn je_rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n     fn je_xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;"}, {"sha": "88e8e2d7adbc38ee9a5a55f0e2fe990bade2c155", "filename": "src/liballoc_system/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"alloc_system\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }"}, {"sha": "b53c0a2f48bf701d2b8d0dc8f50c8c3125bc6f6f", "filename": "src/libarena/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"arena\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"arena\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]"}, {"sha": "18e322ff74f6cb9405e4f5be1d16173b704a8cb5", "filename": "src/libcollections/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"collections\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"collections\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+alloc = { path = \"../liballoc\" }\n+core = { path = \"../libcore\" }\n+rustc_unicode = { path = \"../librustc_unicode\" }"}, {"sha": "24455a1d841bd9be4c2009ece6d16f5c074166de", "filename": "src/libcore/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"core\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"core\"\n+path = \"lib.rs\"\n+test = false"}, {"sha": "52aa6bb86ef903637d4c60cc347561ed4339e487", "filename": "src/libflate/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibflate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibflate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"flate\"\n+version = \"0.0.0\"\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"flate\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[build-dependencies]\n+build_helper = { path = \"../build_helper\" }\n+gcc = \"0.3\""}, {"sha": "245c705dfcc2a41c657ec505d62107fdf94f30b6", "filename": "src/libflate/build.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibflate%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibflate%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Fbuild.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate gcc;\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=cargobuild\");\n+    gcc::Config::new()\n+        .file(\"../rt/miniz.c\")\n+        .compile(\"libminiz.a\");\n+}"}, {"sha": "a6bf735e459de53f4945f381c0d96bf9778843c5", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -79,7 +79,10 @@ impl Drop for Bytes {\n }\n \n #[link(name = \"miniz\", kind = \"static\")]\n-extern \"C\" {\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n+extern {\n     /// Raw miniz compression function.\n     fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n                                   src_buf_len: size_t,"}, {"sha": "b3f4d2deae2fc7f5a13f95b83c98203485886c64", "filename": "src/libfmt_macros/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"fmt_macros\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"fmt_macros\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]"}, {"sha": "99e3b892858884705877012ae485117c67459d1d", "filename": "src/libgetopts/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibgetopts%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibgetopts%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"getopts\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"getopts\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]"}, {"sha": "76ef3a1d188ce61ca863064310bf6a567ff7b919", "filename": "src/libgraphviz/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibgraphviz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibgraphviz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"graphviz\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"graphviz\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]"}, {"sha": "31a862478d034f8353f3a14132748aa6e1ddb3f2", "filename": "src/liblog/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliblog%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fliblog%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"log\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"log\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]"}, {"sha": "784654c0859900dd7c3e9edab786d8707bcfbd6b", "filename": "src/librand/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rand\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rand\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }"}, {"sha": "ab89ac2b7a1eb6a1c5f66cccd696d9ca3a863c1d", "filename": "src/librbml/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrbml%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrbml%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rbml\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rbml\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+serialize = { path = \"../libserialize\" }"}, {"sha": "2aefeb5fc2d44607f8e9e3e65279cb96f7d1f51b", "filename": "src/librustc/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,24 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+arena = { path = \"../libarena\" }\n+flate = { path = \"../libflate\" }\n+fmt_macros = { path = \"../libfmt_macros\" }\n+getopts = { path = \"../libgetopts\" }\n+graphviz = { path = \"../libgraphviz\" }\n+log = { path = \"../liblog\" }\n+rbml = { path = \"../librbml\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "255ca60e2b8f4a2f2e3586f00ac75b97322d54ad", "filename": "src/librustc_back/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_back%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_back%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_back\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_back\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+syntax = { path = \"../libsyntax\" }\n+serialize = { path = \"../libserialize\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_front = { path = \"../librustc_front\" }\n+log = { path = \"../liblog\" }\n+\n+[features]\n+jemalloc = []"}, {"sha": "0920155ef423de930ea0808a9e3e99379c1de5d5", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -501,9 +501,9 @@ impl Target {\n }\n \n fn maybe_jemalloc() -> String {\n-    if cfg!(disable_jemalloc) {\n-        \"alloc_system\".to_string()\n-    } else {\n+    if cfg!(feature = \"jemalloc\") {\n         \"alloc_jemalloc\".to_string()\n+    } else {\n+        \"alloc_system\".to_string()\n     }\n }"}, {"sha": "e82c6ec05c84b53f58f4f4ac030fee2db7ddbff5", "filename": "src/librustc_bitflags/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_bitflags%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_bitflags%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_bitflags\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_bitflags\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }"}, {"sha": "f78f6fb86ae2213a07a04ad62de595d6624c32d5", "filename": "src/librustc_borrowck/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_borrowck\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_borrowck\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+syntax = { path = \"../libsyntax\" }\n+graphviz = { path = \"../libgraphviz\" }\n+rustc = { path = \"../librustc\" }\n+rustc_front = { path = \"../librustc_front\" }"}, {"sha": "e2e16059d98718c534335bf277927d4cb35c7853", "filename": "src/librustc_data_structures/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_data_structures\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_data_structures\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+serialize = { path = \"../libserialize\" }"}, {"sha": "bf86e8f039ad4994fa22e9212dc5545ec148fd2f", "filename": "src/librustc_driver/Cargo.toml", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,33 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_driver\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_driver\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+arena = { path = \"../libarena\" }\n+flate = { path = \"../libflate\" }\n+getopts = { path = \"../libgetopts\" }\n+graphviz = { path = \"../libgraphviz\" }\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_borrowck = { path = \"../librustc_borrowck\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n+rustc_plugin = { path = \"../librustc_plugin\" }\n+rustc_passes = { path = \"../librustc_passes\" }\n+rustc_privacy = { path = \"../librustc_privacy\" }\n+rustc_resolve = { path = \"../librustc_resolve\" }\n+rustc_trans = { path = \"../librustc_trans\" }\n+rustc_typeck = { path = \"../librustc_typeck\" }\n+rustc_metadata = { path = \"../librustc_metadata\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }\n+syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "eae0b0646a3dde3ba576ea1c01f46174db352733", "filename": "src/librustc_front/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_front%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_front%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_front\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_front\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+syntax = { path = \"../libsyntax\" }\n+serialize = { path = \"../libserialize\" }"}, {"sha": "33443957d1b3b7d71cf8957565f231b4fe3fba47", "filename": "src/librustc_lint/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_lint\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_lint\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_front = { path = \"../librustc_front\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "62e1a71d196e28febb4a964ab422f4986173c346", "filename": "src/librustc_llvm/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_llvm\"\n+version = \"0.0.0\"\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"rustc_llvm\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[features]\n+static-libstdcpp = []\n+\n+[build-dependencies]\n+build_helper = { path = \"../build_helper\" }\n+gcc = \"0.3\""}, {"sha": "1c9982790cf4ae15e10465980341610422439d28", "filename": "src/librustc_llvm/build.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate gcc;\n+extern crate build_helper;\n+\n+use std::process::Command;\n+use std::env;\n+use std::path::PathBuf;\n+\n+use build_helper::output;\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=cargobuild\");\n+\n+    let target = env::var(\"TARGET\").unwrap();\n+    let llvm_config = env::var_os(\"LLVM_CONFIG\").map(PathBuf::from)\n+                           .unwrap_or_else(|| {\n+        match env::var_os(\"CARGO_TARGET_DIR\").map(PathBuf::from) {\n+            Some(dir) => {\n+                let to_test = dir.parent().unwrap().parent().unwrap()\n+                                 .join(&target).join(\"llvm/bin/llvm-config\");\n+                if Command::new(&to_test).output().is_ok() {\n+                    return to_test\n+                }\n+            }\n+            None => {}\n+        }\n+        PathBuf::from(\"llvm-config\")\n+    });\n+\n+    println!(\"cargo:rerun-if-changed={}\", llvm_config.display());\n+\n+    let optional_components = [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\",\n+                               \"pnacl\"];\n+\n+    // FIXME: surely we don't need all these components, right? Stuff like mcjit\n+    //        or interpreter the compiler itself never uses.\n+    let required_components = &[\"ipo\", \"bitreader\", \"bitwriter\", \"linker\",\n+                                \"asmparser\", \"mcjit\", \"interpreter\",\n+                                \"instrumentation\"];\n+\n+    let components = output(Command::new(&llvm_config).arg(\"--components\"));\n+    let mut components = components.split_whitespace().collect::<Vec<_>>();\n+    components.retain(|c| {\n+        optional_components.contains(c) || required_components.contains(c)\n+    });\n+\n+    for component in required_components {\n+        if !components.contains(component) {\n+            panic!(\"require llvm component {} but wasn't found\", component);\n+        }\n+    }\n+\n+    for component in components.iter() {\n+        println!(\"cargo:rustc-cfg=llvm_component=\\\"{}\\\"\", component);\n+    }\n+\n+    // Link in our own LLVM shims, compiled with the same flags as LLVM\n+    let mut cmd = Command::new(&llvm_config);\n+    cmd.arg(\"--cxxflags\");\n+    let cxxflags = output(&mut cmd);\n+    let mut cfg = gcc::Config::new();\n+    for flag in cxxflags.split_whitespace() {\n+        cfg.flag(flag);\n+    }\n+    cfg.file(\"../rustllvm/ExecutionEngineWrapper.cpp\")\n+       .file(\"../rustllvm/PassWrapper.cpp\")\n+       .file(\"../rustllvm/RustWrapper.cpp\")\n+       .file(\"../rustllvm/ArchiveWrapper.cpp\")\n+       .cpp(true)\n+       .cpp_link_stdlib(None) // we handle this below\n+       .compile(\"librustllvm.a\");\n+\n+    // Link in all LLVM libraries\n+    let mut cmd = Command::new(&llvm_config);\n+    cmd.arg(\"--libs\").arg(\"--system-libs\").args(&components[..]);\n+    for lib in output(&mut cmd).split_whitespace() {\n+        let name = if lib.starts_with(\"-l\") {\n+            &lib[2..]\n+        } else if lib.starts_with(\"-\") {\n+            &lib[1..]\n+        } else {\n+            continue\n+        };\n+\n+        // Don't need or want this library, but LLVM's CMake build system\n+        // doesn't provide a way to disable it, so filter it here even though we\n+        // may or may not have built it. We don't reference anything from this\n+        // library and it otherwise may just pull in extra dependencies on\n+        // libedit which we don't want\n+        if name == \"LLVMLineEditor\" {\n+            continue\n+        }\n+\n+        let kind = if name.starts_with(\"LLVM\") {\"static\"} else {\"dylib\"};\n+        println!(\"cargo:rustc-link-lib={}={}\", kind, name);\n+    }\n+\n+    // LLVM ldflags\n+    let mut cmd = Command::new(&llvm_config);\n+    cmd.arg(\"--ldflags\");\n+    for lib in output(&mut cmd).split_whitespace() {\n+        if lib.starts_with(\"-l\") {\n+            println!(\"cargo:rustc-link-lib={}\", &lib[2..]);\n+        } else if lib.starts_with(\"-L\") {\n+            println!(\"cargo:rustc-link-search=native={}\", &lib[2..]);\n+        }\n+    }\n+\n+    // C++ runtime library\n+    if !target.contains(\"msvc\") {\n+        if let Some(s) = env::var_os(\"LLVM_STATIC_STDCPP\") {\n+            assert!(!cxxflags.contains(\"stdlib=libc++\"));\n+            let path = PathBuf::from(s);\n+            println!(\"cargo:rustc-link-search=native={}\",\n+                     path.parent().unwrap().display());\n+            println!(\"cargo:rustc-link-lib=static=stdc++\");\n+        } else if cxxflags.contains(\"stdlib=libc++\") {\n+            println!(\"cargo:rustc-link-lib=c++\");\n+        } else {\n+            println!(\"cargo:rustc-link-lib=stdc++\");\n+        }\n+    }\n+}"}, {"sha": "1933c926e3018e9dd6eefdfc2be47a3445bedf43", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 43, "deletions": 78, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -609,6 +609,9 @@ pub mod debuginfo {\n // automatically updated whenever LLVM is updated to include an up-to-date\n // set of the libraries we need to link to LLVM for.\n #[link(name = \"rustllvm\", kind = \"static\")]\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n #[linked_from = \"rustllvm\"] // not quite true but good enough\n extern {\n     /* Create and destroy contexts. */\n@@ -2163,53 +2166,6 @@ extern {\n     pub fn LLVMRustFreeOperandBundleDef(Bundle: OperandBundleDefRef);\n }\n \n-#[cfg(have_component_x86)]\n-extern {\n-    pub fn LLVMInitializeX86TargetInfo();\n-    pub fn LLVMInitializeX86Target();\n-    pub fn LLVMInitializeX86TargetMC();\n-    pub fn LLVMInitializeX86AsmPrinter();\n-    pub fn LLVMInitializeX86AsmParser();\n-}\n-#[cfg(have_component_arm)]\n-extern {\n-    pub fn LLVMInitializeARMTargetInfo();\n-    pub fn LLVMInitializeARMTarget();\n-    pub fn LLVMInitializeARMTargetMC();\n-    pub fn LLVMInitializeARMAsmPrinter();\n-    pub fn LLVMInitializeARMAsmParser();\n-}\n-#[cfg(have_component_aarch64)]\n-extern {\n-    pub fn LLVMInitializeAArch64TargetInfo();\n-    pub fn LLVMInitializeAArch64Target();\n-    pub fn LLVMInitializeAArch64TargetMC();\n-    pub fn LLVMInitializeAArch64AsmPrinter();\n-    pub fn LLVMInitializeAArch64AsmParser();\n-}\n-#[cfg(have_component_mips)]\n-extern {\n-    pub fn LLVMInitializeMipsTargetInfo();\n-    pub fn LLVMInitializeMipsTarget();\n-    pub fn LLVMInitializeMipsTargetMC();\n-    pub fn LLVMInitializeMipsAsmPrinter();\n-    pub fn LLVMInitializeMipsAsmParser();\n-}\n-#[cfg(have_component_powerpc)]\n-extern {\n-    pub fn LLVMInitializePowerPCTargetInfo();\n-    pub fn LLVMInitializePowerPCTarget();\n-    pub fn LLVMInitializePowerPCTargetMC();\n-    pub fn LLVMInitializePowerPCAsmPrinter();\n-    pub fn LLVMInitializePowerPCAsmParser();\n-}\n-#[cfg(have_component_pnacl)]\n-extern {\n-    pub fn LLVMInitializePNaClTargetInfo();\n-    pub fn LLVMInitializePNaClTarget();\n-    pub fn LLVMInitializePNaClTargetMC();\n-}\n-\n // LLVM requires symbols from this library, but apparently they're not printed\n // during llvm-config?\n #[cfg(windows)]\n@@ -2396,47 +2352,55 @@ pub unsafe fn debug_loc_to_string(c: ContextRef, tr: DebugLocRef) -> String {\n \n pub fn initialize_available_targets() {\n     macro_rules! init_target(\n-        ($cfg:ident $arch:ident) => { {\n+        ($cfg:meta, $($method:ident),*) => { {\n             #[cfg($cfg)]\n             fn init() {\n+                extern {\n+                    $(fn $method();)*\n+                }\n                 unsafe {\n-                    let f = concat_idents!(LLVMInitialize, $arch, TargetInfo);\n-                    f();\n-                    let f = concat_idents!(LLVMInitialize, $arch, Target);\n-                    f();\n-                    let f = concat_idents!(LLVMInitialize, $arch, TargetMC);\n-                    f();\n-                    let f = concat_idents!(LLVMInitialize, $arch, AsmPrinter);\n-                    f();\n-                    let f = concat_idents!(LLVMInitialize, $arch, AsmParser);\n-                    f();\n+                    $($method();)*\n                 }\n             }\n             #[cfg(not($cfg))]\n             fn init() { }\n             init();\n         } }\n     );\n-\n-    init_target!(have_component_powerpc PowerPC);\n-    init_target!(have_component_mips Mips);\n-    init_target!(have_component_aarch64 AArch64);\n-    init_target!(have_component_arm ARM);\n-    init_target!(have_component_x86 X86);\n-\n-    // PNaCl doesn't provide some of the optional target components, so we\n-    // manually initialize it here.\n-    #[cfg(have_component_pnacl)]\n-    fn init_pnacl() {\n-        unsafe {\n-            LLVMInitializePNaClTargetInfo();\n-            LLVMInitializePNaClTarget();\n-            LLVMInitializePNaClTargetMC();\n-        }\n-    }\n-    #[cfg(not(have_component_pnacl))]\n-    fn init_pnacl() { }\n-    init_pnacl();\n+    init_target!(llvm_component = \"x86\",\n+                 LLVMInitializeX86TargetInfo,\n+                 LLVMInitializeX86Target,\n+                 LLVMInitializeX86TargetMC,\n+                 LLVMInitializeX86AsmPrinter,\n+                 LLVMInitializeX86AsmParser);\n+    init_target!(llvm_component = \"arm\",\n+                 LLVMInitializeARMTargetInfo,\n+                 LLVMInitializeARMTarget,\n+                 LLVMInitializeARMTargetMC,\n+                 LLVMInitializeARMAsmPrinter,\n+                 LLVMInitializeARMAsmParser);\n+    init_target!(llvm_component = \"aarch64\",\n+                 LLVMInitializeAArch64TargetInfo,\n+                 LLVMInitializeAArch64Target,\n+                 LLVMInitializeAArch64TargetMC,\n+                 LLVMInitializeAArch64AsmPrinter,\n+                 LLVMInitializeAArch64AsmParser);\n+    init_target!(llvm_component = \"mips\",\n+                 LLVMInitializeMipsTargetInfo,\n+                 LLVMInitializeMipsTarget,\n+                 LLVMInitializeMipsTargetMC,\n+                 LLVMInitializeMipsAsmPrinter,\n+                 LLVMInitializeMipsAsmParser);\n+    init_target!(llvm_component = \"powerpc\",\n+                 LLVMInitializePowerPCTargetInfo,\n+                 LLVMInitializePowerPCTarget,\n+                 LLVMInitializePowerPCTargetMC,\n+                 LLVMInitializePowerPCAsmPrinter,\n+                 LLVMInitializePowerPCAsmParser);\n+    init_target!(llvm_component = \"pnacl\",\n+                 LLVMInitializePNaClTargetInfo,\n+                 LLVMInitializePNaClTarget,\n+                 LLVMInitializePNaClTargetMC);\n }\n \n pub fn last_error() -> Option<String> {\n@@ -2486,6 +2450,7 @@ impl Drop for OperandBundleDef {\n // parts of LLVM that rustllvm depends on aren't thrown away by the linker.\n // Works to the above fix for #15460 to ensure LLVM dependencies that\n // are only used by rustllvm don't get stripped by the linker.\n+#[cfg(not(cargobuild))]\n mod llvmdeps {\n     include! { env!(\"CFG_LLVM_LINKAGE_FILE\") }\n }"}, {"sha": "3f8249aabf94840efc9ae7a12c26d43be8e3e4e9", "filename": "src/librustc_metadata/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,20 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_metadata\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_metadata\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+flate = { path = \"../libflate\" }\n+log = { path = \"../liblog\" }\n+rbml = { path = \"../librbml\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "93817ab0db61b782f7d0512e12430e8a69c277d6", "filename": "src/librustc_mir/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_mir\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_mir\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+graphviz = { path = \"../libgraphviz\" }\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_front = { path = \"../librustc_front\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "7cc6510fa1fd1ca656a70efb0d46e7bf3ce0b469", "filename": "src/librustc_passes/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_passes\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_passes\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_front = { path = \"../librustc_front\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "97bf4f854ccb432b17112fc13911413a2f1287a6", "filename": "src/librustc_platform_intrinsics/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_platform_intrinsics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_platform_intrinsics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_platform_intrinsics\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_platform_intrinsics\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc = { path = \"../librustc\" }"}, {"sha": "59cfe158624f088209a05fab851a14a20a049519", "filename": "src/librustc_plugin/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_plugin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_plugin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_plugin\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_metadata = { path = \"../librustc_metadata\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "56d6ca5543a0e592ae4aa05dd506b6a7bedd357f", "filename": "src/librustc_privacy/Cargo.toml", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,15 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_privacy\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_privacy\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_front = { path = \"../librustc_front\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "da01a36d7623760c42c2c2a0182c60e107ce6663", "filename": "src/librustc_resolve/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_resolve\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_resolve\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+syntax = { path = \"../libsyntax\" }\n+rustc = { path = \"../librustc\" }\n+rustc_front = { path = \"../librustc_front\" }\n+arena = { path = \"../libarena\" }"}, {"sha": "24320c4d563bc259ce81295b53998fc04b61b91a", "filename": "src/librustc_trans/Cargo.toml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,25 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_trans\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_trans\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+arena = { path = \"../libarena\" }\n+flate = { path = \"../libflate\" }\n+getopts = { path = \"../libgetopts\" }\n+graphviz = { path = \"../libgraphviz\" }\n+log = { path = \"../liblog\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_mir = { path = \"../librustc_mir\" }\n+rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "fd33e9da1f93786acdce840e06917d915448dec4", "filename": "src/librustc_typeck/Cargo.toml", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,19 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_typeck\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_typeck\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }\n+syntax = { path = \"../libsyntax\" }\n+arena = { path = \"../libarena\" }\n+fmt_macros = { path = \"../libfmt_macros\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }"}, {"sha": "1f4213f0abe406843f6c16c093bf3042637e1801", "filename": "src/librustc_unicode/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_unicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustc_unicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_unicode\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_unicode\"\n+path = \"lib.rs\"\n+test = false\n+\n+[dependencies]\n+core = { path = \"../libcore\" }"}, {"sha": "6b0ad30f4509c98f3e35aa9c4d5c3d45a003e832", "filename": "src/librustdoc/Cargo.toml", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,30 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustdoc\"\n+version = \"0.0.0\"\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"rustdoc\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+arena = { path = \"../libarena\" }\n+getopts = { path = \"../libgetopts\" }\n+rustc = { path = \"../librustc\" }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_driver = { path = \"../librustc_driver\" }\n+rustc_front = { path = \"../librustc_front\" }\n+rustc_lint = { path = \"../librustc_lint\" }\n+rustc_metadata = { path = \"../librustc_metadata\" }\n+rustc_resolve = { path = \"../librustc_resolve\" }\n+rustc_trans = { path = \"../librustc_trans\" }\n+serialize = { path = \"../libserialize\" }\n+syntax = { path = \"../libsyntax\" }\n+test = { path = \"../libtest\" }\n+log = { path = \"../liblog\" }\n+\n+[build-dependencies]\n+build_helper = { path = \"../build_helper\" }\n+gcc = \"0.3\""}, {"sha": "171954f325a5e5dbcafd82003efb2283109cd06d", "filename": "src/librustdoc/build.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustdoc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustdoc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fbuild.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate gcc;\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=cargobuild\");\n+    let mut cfg = gcc::Config::new();\n+    cfg.file(\"../rt/hoedown/src/autolink.c\")\n+       .file(\"../rt/hoedown/src/buffer.c\")\n+       .file(\"../rt/hoedown/src/document.c\")\n+       .file(\"../rt/hoedown/src/escape.c\")\n+       .file(\"../rt/hoedown/src/html.c\")\n+       .file(\"../rt/hoedown/src/html_blocks.c\")\n+       .file(\"../rt/hoedown/src/html_smartypants.c\")\n+       .file(\"../rt/hoedown/src/stack.c\")\n+       .file(\"../rt/hoedown/src/version.c\")\n+       .include(\"../rt/hoedown/src\")\n+       .compile(\"libhoedown.a\");\n+}"}, {"sha": "c0846cae687014291d5a5f6703d75e1e6f2cd271", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -157,6 +157,9 @@ struct hoedown_buffer {\n \n // hoedown FFI\n #[link(name = \"hoedown\", kind = \"static\")]\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n extern {\n     fn hoedown_html_renderer_new(render_flags: libc::c_uint,\n                                  nesting_level: libc::c_int)"}, {"sha": "919cda49c004c3de44de341ec2f0459ad3df3c87", "filename": "src/libserialize/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"serialize\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"serialize\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }"}, {"sha": "390c64d740867d7e91d1e965d1b969bb784cfee4", "filename": "src/libstd/Cargo.toml", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,30 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"std\"\n+version = \"0.0.0\"\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"std\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]\n+test = false\n+\n+[dependencies]\n+alloc = { path = \"../liballoc\" }\n+alloc_jemalloc = { path = \"../liballoc_jemalloc\", optional = true }\n+alloc_system = { path = \"../liballoc_system\" }\n+collections = { path = \"../libcollections\" }\n+core = { path = \"../libcore\" }\n+libc = { path = \"../rustc/libc_shim\" }\n+rand = { path = \"../librand\" }\n+rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_unicode = { path = \"../librustc_unicode\" }\n+\n+[build-dependencies]\n+build_helper = { path = \"../build_helper\" }\n+gcc = \"0.3\"\n+\n+[features]\n+jemalloc = [\"alloc_jemalloc\"]\n+debug-jemalloc = [\"alloc_jemalloc/debug\"]"}, {"sha": "8fb49a1be4ea6add15f85bcf006551066b403938", "filename": "src/libstd/build.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate gcc;\n+extern crate build_helper;\n+\n+use std::env;\n+use std::fs;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+use build_helper::run;\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=cargobuild\");\n+\n+    let target = env::var(\"TARGET\").unwrap();\n+    let host = env::var(\"HOST\").unwrap();\n+    if !target.contains(\"apple\") && !target.contains(\"msvc\") {\n+        build_libbacktrace(&host, &target);\n+    }\n+\n+    if target.contains(\"unknown-linux\") {\n+        if target.contains(\"musl\") {\n+            println!(\"cargo:rustc-link-lib=static=unwind\");\n+        } else {\n+            println!(\"cargo:rustc-link-lib=dl\");\n+            println!(\"cargo:rustc-link-lib=rt\");\n+            println!(\"cargo:rustc-link-lib=pthread\");\n+            println!(\"cargo:rustc-link-lib=gcc_s\");\n+        }\n+    } else if target.contains(\"android\") {\n+        println!(\"cargo:rustc-link-lib=dl\");\n+        println!(\"cargo:rustc-link-lib=log\");\n+        println!(\"cargo:rustc-link-lib=gcc\");\n+    } else if target.contains(\"freebsd\") {\n+        println!(\"cargo:rustc-link-lib=execinfo\");\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+        println!(\"cargo:rustc-link-lib=gcc_s\");\n+    } else if target.contains(\"dragonfly\") || target.contains(\"bitrig\") ||\n+              target.contains(\"netbsd\") || target.contains(\"openbsd\") {\n+        println!(\"cargo:rustc-link-lib=pthread\");\n+\n+        if target.contains(\"rumprun\") {\n+            println!(\"cargo:rustc-link-lib=unwind\");\n+        } else if target.contains(\"netbsd\") || target.contains(\"openbsd\") {\n+            println!(\"cargo:rustc-link-lib=gcc\");\n+        } else if target.contains(\"bitrig\") {\n+            println!(\"cargo:rustc-link-lib=c++abi\");\n+        } else if target.contains(\"dragonfly\") {\n+            println!(\"cargo:rustc-link-lib=gcc_pic\");\n+        }\n+    } else if target.contains(\"apple-darwin\") {\n+        println!(\"cargo:rustc-link-lib=System\");\n+    } else if target.contains(\"apple-ios\") {\n+        println!(\"cargo:rustc-link-lib=System\");\n+        println!(\"cargo:rustc-link-lib=objc\");\n+        println!(\"cargo:rustc-link-lib=framework=Security\");\n+        println!(\"cargo:rustc-link-lib=framework=Foundation\");\n+    } else if target.contains(\"windows\") {\n+        if target.contains(\"windows-gnu\") {\n+            println!(\"cargo:rustc-link-lib=gcc_eh\");\n+        }\n+        println!(\"cargo:rustc-link-lib=advapi32\");\n+        println!(\"cargo:rustc-link-lib=ws2_32\");\n+        println!(\"cargo:rustc-link-lib=userenv\");\n+        println!(\"cargo:rustc-link-lib=shell32\");\n+    }\n+}\n+\n+fn build_libbacktrace(host: &str, target: &str) {\n+    let src_dir = env::current_dir().unwrap().join(\"../libbacktrace\");\n+    let build_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+\n+    println!(\"cargo:rustc-link-lib=static=backtrace\");\n+    println!(\"cargo:rustc-link-search=native={}/.libs\", build_dir.display());\n+\n+    if fs::metadata(&build_dir.join(\".libs/libbacktrace.a\")).is_ok() {\n+        return\n+    }\n+\n+    let compiler = gcc::Config::new().get_compiler();\n+    let ar = build_helper::cc2ar(compiler.path(), target);\n+    let cflags = compiler.args().iter().map(|s| s.to_str().unwrap())\n+                         .collect::<Vec<_>>().join(\" \");\n+    run(Command::new(\"sh\")\n+                .current_dir(&build_dir)\n+                .arg(src_dir.join(\"configure\").to_str().unwrap()\n+                            .replace(\"C:\\\\\", \"/c/\")\n+                            .replace(\"\\\\\", \"/\"))\n+                .arg(\"--with-pic\")\n+                .arg(\"--disable-multilib\")\n+                .arg(\"--disable-shared\")\n+                .arg(\"--disable-host-shared\")\n+                .arg(format!(\"--host={}\", build_helper::gnu_target(target)))\n+                .arg(format!(\"--build={}\", build_helper::gnu_target(host)))\n+                .env(\"CC\", compiler.path())\n+                .env(\"AR\", &ar)\n+                .env(\"RANLIB\", format!(\"{} s\", ar.display()))\n+                .env(\"CFLAGS\", cflags));\n+    run(Command::new(\"make\")\n+                .current_dir(&build_dir)\n+                .arg(format!(\"INCDIR={}\", src_dir.display()))\n+                .arg(\"-j\").arg(env::var(\"NUM_JOBS\").unwrap()));\n+}"}, {"sha": "8a422246514bcc833c3734cc08b24c705a77fcbe", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -269,7 +269,10 @@ mod imp {\n     const kSecRandomDefault: *const SecRandom = ptr::null();\n \n     #[link(name = \"Security\", kind = \"framework\")]\n-    extern \"C\" {\n+    #[cfg(not(cargobuild))]\n+    extern {}\n+\n+    extern {\n         fn SecRandomCopyBytes(rnd: *const SecRandom,\n                               count: size_t, bytes: *mut u8) -> c_int;\n     }"}, {"sha": "a11200873d500b980ea89326f7f621689e0f87c1", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -12,6 +12,8 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n+#![cfg(not(cargobuild))]\n+\n // LLVM implements the `frem` instruction as a call to `fmod`, which lives in\n // libm. Hence, we must explicitly link to it.\n //"}, {"sha": "8b3cb04030c8272753e8e62a790551f29c40e2ac", "filename": "src/libstd/sys/common/gnu/libbacktrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -40,7 +40,7 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n                       errnum: libc::c_int);\n     enum backtrace_state {}\n     #[link(name = \"backtrace\", kind = \"static\")]\n-    #[cfg(not(test))]\n+    #[cfg(all(not(test), not(cargobuild)))]\n     extern {}\n \n     extern {"}, {"sha": "7cf9e2a54bd900ff7d575dd0ecded2fe9cffc3f7", "filename": "src/libstd/sys/common/unwind/gcc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -252,6 +252,9 @@ pub mod eh_frame_registry {\n     // See also: rtbegin.rs, `unwind` module.\n \n     #[link(name = \"gcc_eh\")]\n+    #[cfg(not(cargobuild))]\n+    extern {}\n+\n     extern {\n         fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n         fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);"}, {"sha": "b6a0bd844094b1ddeeb9999aa4ae8c6bff4169db", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -339,14 +339,15 @@ pub fn args() -> Args {\n pub fn args() -> Args {\n     use mem;\n \n-    #[link(name = \"objc\")]\n     extern {\n         fn sel_registerName(name: *const libc::c_uchar) -> Sel;\n         fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n         fn objc_getClass(class_name: *const libc::c_uchar) -> NsId;\n     }\n \n     #[link(name = \"Foundation\", kind = \"framework\")]\n+    #[link(name = \"objc\")]\n+    #[cfg(not(cargobuild))]\n     extern {}\n \n     type Sel = *const libc::c_void;"}, {"sha": "9fdeb0aef14c8317527531f07ee8b12ee8ecb584", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -966,6 +966,9 @@ pub enum EXCEPTION_DISPOSITION {\n #[link(name = \"userenv\")]\n #[link(name = \"shell32\")]\n #[link(name = \"advapi32\")]\n+#[cfg(not(cargobuild))]\n+extern {}\n+\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: WORD,\n                       lpWSAData: LPWSADATA) -> c_int;"}, {"sha": "3a1d18b85b657f730beae7a0062ccd8f4501fc1e", "filename": "src/libsyntax/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"syntax\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"syntax\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+arena = { path = \"../libarena\" }\n+fmt_macros = { path = \"../libfmt_macros\" }\n+serialize = { path = \"../libserialize\" }\n+term = { path = \"../libterm\" }\n+log = { path = \"../liblog\" }"}, {"sha": "e137815cd32fd919e380403fe43624e49f303560", "filename": "src/libsyntax_ext/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"syntax_ext\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"syntax_ext\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+fmt_macros = { path = \"../libfmt_macros\" }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "cdfc957297dee502f33f2c63ec658d80882b30db", "filename": "src/libterm/Cargo.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibterm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibterm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,12 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"term\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"term\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]\n+\n+[dependencies]\n+log = { path = \"../liblog\" }"}, {"sha": "96a84496b9c9c23245790d2eef7f67e58aa4a4ea", "filename": "src/libtest/Cargo.toml", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibtest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Flibtest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,14 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"test\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"test\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]\n+\n+[dependencies]\n+getopts = { path = \"../libgetopts\" }\n+term = { path = \"../libterm\" }\n+serialize = { path = \"../libserialize\" }"}, {"sha": "86186222d90bb4806bc3d6690d2b693517ae3726", "filename": "src/nightlies.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fnightlies.txt", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Fnightlies.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnightlies.txt?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,2 @@\n+rustc: 2015-12-19\n+cargo: 2016-01-21"}, {"sha": "c684c474efa9e3e067781c6a30adaaaa8d6151e6", "filename": "src/rustbook/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustbook%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustbook%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustbook\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustbook\"\n+path = \"main.rs\"\n+crate-type = [\"dylib\"]\n+\n+[dependencies]\n+rustc_back = { path = \"../librustc_back\" }\n+rustdoc = { path = \"../librustdoc\" }"}, {"sha": "bd4fc8992930e99715c243ae7829e524219166bc", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -36,7 +36,7 @@ mod test;\n \n static EXIT_STATUS: AtomicIsize = ATOMIC_ISIZE_INIT;\n \n-fn main() {\n+pub fn main() {\n     let mut term = Term::new();\n     let cmd: Vec<_> = env::args().collect();\n "}, {"sha": "2a7da33bb68dd7000834bcca2835ccfc0768d1cf", "filename": "src/rustc/Cargo.lock", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,368 @@\n+[root]\n+name = \"rustc-main\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustbook 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_driver 0.0.0\",\n+ \"rustdoc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"arena\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"flate\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"fmt_macros\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"graphviz\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"rbml\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustbook\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_back 0.0.0\",\n+ \"rustdoc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"getopts 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rbml 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_back\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_borrowck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_data_structures\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_driver\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"getopts 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_borrowck 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_passes 0.0.0\",\n+ \"rustc_plugin 0.0.0\",\n+ \"rustc_privacy 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_trans 0.0.0\",\n+ \"rustc_typeck 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"syntax_ext 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_front\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_lint\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_llvm\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustc_metadata\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"flate 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rbml 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_mir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_passes\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_platform_intrinsics\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_plugin\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_privacy\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_resolve\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_trans\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"flate 0.0.0\",\n+ \"getopts 0.0.0\",\n+ \"graphviz 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_data_structures 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_llvm 0.0.0\",\n+ \"rustc_mir 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_typeck\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_platform_intrinsics 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustdoc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"build_helper 0.1.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.0.0\",\n+ \"log 0.0.0\",\n+ \"rustc 0.0.0\",\n+ \"rustc_back 0.0.0\",\n+ \"rustc_driver 0.0.0\",\n+ \"rustc_front 0.0.0\",\n+ \"rustc_lint 0.0.0\",\n+ \"rustc_metadata 0.0.0\",\n+ \"rustc_resolve 0.0.0\",\n+ \"rustc_trans 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"syntax 0.0.0\",\n+ \"test 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"serialize\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena 0.0.0\",\n+ \"fmt_macros 0.0.0\",\n+ \"log 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"term 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"syntax_ext\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fmt_macros 0.0.0\",\n+ \"syntax 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"term\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"test\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"getopts 0.0.0\",\n+ \"serialize 0.0.0\",\n+ \"term 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+"}, {"sha": "9fcefd9d3a4dd5e399304489270f3865c25908b9", "filename": "src/rustc/Cargo.toml", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,36 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc-main\"\n+version = \"0.0.0\"\n+\n+[[bin]]\n+name = \"rustc\"\n+path = \"rustc.rs\"\n+\n+[[bin]]\n+name = \"rustdoc\"\n+path = \"rustdoc.rs\"\n+\n+[[bin]]\n+name = \"rustbook\"\n+path = \"rustbook.rs\"\n+\n+[profile.release]\n+opt-level = 2\n+\n+# These options are controlled from our rustc wrapper script, so turn them off\n+# here and have them controlled elsewhere.\n+[profile.dev]\n+debug = false\n+debug-assertions = false\n+\n+# All optional dependencies so the features passed to this Cargo.toml select\n+# what should actually be built.\n+[dependencies]\n+rustbook = { path = \"../rustbook\", optional = true }\n+rustc_back = { path = \"../librustc_back\" }\n+rustc_driver = { path = \"../librustc_driver\" }\n+rustdoc = { path = \"../librustdoc\", optional = true }\n+\n+[features]\n+jemalloc = [\"rustc_back/jemalloc\"]"}, {"sha": "a7860b50e08ff50aa19ebf1f256c5f4daba474d9", "filename": "src/rustc/libc_shim/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Flibc_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Flibc_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flibc_shim%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,20 @@\n+# This is a shim Cargo.toml over the \"real Cargo.toml\" found in the libc\n+# repository itself. The purpose for this is to add a build script which prints\n+# out `--cfg stdbuild` to mirror the makefiles' build system.\n+#\n+# Note that other than that this isn't actually needed, and we should probably\n+# remove this shim in favor of just working with cargo features directly with\n+# libc. That should make everything nicer!\n+\n+[package]\n+name = \"libc\"\n+version = \"0.0.0\"\n+authors = [\"The Rust Project Developers\"]\n+build = \"build.rs\"\n+\n+[lib]\n+name = \"libc\"\n+path = \"../../liblibc/src/lib.rs\"\n+\n+[dependencies]\n+core = { path = \"../../libcore\" }"}, {"sha": "bc428d6908235622cf3206dd5c90366d9ef3fbba", "filename": "src/rustc/libc_shim/build.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Flibc_shim%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Flibc_shim%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flibc_shim%2Fbuild.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See comments in Cargo.toml for why this exists\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=stdbuild\");\n+}"}, {"sha": "6f78f78bc55a61f9fddf98a6503ccda3a11663ca", "filename": "src/rustc/rustbook.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Frustbook.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Frustbook.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustbook.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustbook;\n+\n+fn main() { rustbook::main() }\n+"}, {"sha": "bfd01146d2c4644eda47b5490b0789b424dd53f3", "filename": "src/rustc/rustc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_driver;\n+\n+fn main() { rustc_driver::main() }"}, {"sha": "6fecd3a27a8a459f2d3237fe67d3bc4be2ca5502", "filename": "src/rustc/rustdoc.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustdoc.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustdoc)]\n+\n+extern crate rustdoc;\n+\n+fn main() { rustdoc::main() }"}, {"sha": "d88e9c7e5aa942797bd3823ce10c1508f5131d6e", "filename": "src/rustc/std_shim/Cargo.lock", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Fstd_shim%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Fstd_shim%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.lock?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,124 @@\n+[root]\n+name = \"std_shim\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"std 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"advapi32-sys\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"alloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc_system 0.0.0\",\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc_jemalloc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"build_helper 0.1.0\",\n+ \"core 0.0.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"alloc_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+ \"libc 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"build_helper\"\n+version = \"0.1.0\"\n+\n+[[package]]\n+name = \"collections\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"core 0.0.0\",\n+ \"rustc_unicode 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"core\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"gcc\"\n+version = \"0.3.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"advapi32-sys 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_bitflags\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"rustc_unicode\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"std\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"alloc 0.0.0\",\n+ \"alloc_jemalloc 0.0.0\",\n+ \"alloc_system 0.0.0\",\n+ \"build_helper 0.1.0\",\n+ \"collections 0.0.0\",\n+ \"core 0.0.0\",\n+ \"gcc 0.3.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.0.0\",\n+ \"rand 0.0.0\",\n+ \"rustc_bitflags 0.0.0\",\n+ \"rustc_unicode 0.0.0\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+"}, {"sha": "1ce3937157da04de1a804f56441b5cc9e9ee8dfa", "filename": "src/rustc/std_shim/Cargo.toml", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Fstd_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Fstd_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.toml?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,46 @@\n+# This is a shim Cargo.toml which serves as a proxy for building the standard\n+# library. The reason for this is a little subtle, as one might reasonably\n+# expect that we just `cargo build` the standard library itself.\n+#\n+# One of the output artifacts for the standard library is a dynamic library, and\n+# on platforms like OSX the name of the output artifact is actually encoded into\n+# the library itself (similar to a soname on Linux). When the library is linked\n+# against, this encoded name is what's literally looked for at runtime when the\n+# dynamic loader is probing for libraries.\n+#\n+# Cargo, however, by default will not mangle the output filename of the\n+# top-level target. If we were to run `cargo build` on libstd itself, we would\n+# generate a file `libstd.so`. When installing, however, this file is called\n+# something like `libstd-abcdef0123.so`. On OSX at least this causes a failure\n+# at runtime because the encoded \"soname\" is `libstd.so`, not what the file is\n+# actually called.\n+#\n+# By using this shim library to build the standard library by proxy we sidestep\n+# this problem. The standard library is built with mangled hex already in its\n+# name so there's nothing extra we need to do.\n+\n+[package]\n+name = \"std_shim\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+\n+[lib]\n+name = \"std_shim\"\n+path = \"lib.rs\"\n+\n+[profile.release]\n+opt-level = 2\n+\n+# These options are controlled from our rustc wrapper script, so turn them off\n+# here and have them controlled elsewhere.\n+[profile.dev]\n+debug = false\n+debug-assertions = false\n+\n+[dependencies]\n+std = { path = \"../../libstd\" }\n+\n+# Reexport features from std\n+[features]\n+jemalloc = [\"std/jemalloc\"]\n+debug-jemalloc = [\"std/debug-jemalloc\"]"}, {"sha": "3cf4cfab135fd4f7d4a84c8a4708d9fae1b99c4e", "filename": "src/rustc/std_shim/lib.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Fstd_shim%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a5d5b54e0ff91bda8518df7ed9673cc657a4e6/src%2Frustc%2Fstd_shim%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2Flib.rs?ref=78a5d5b54e0ff91bda8518df7ed9673cc657a4e6", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See comments in Cargo.toml for why this exists"}]}