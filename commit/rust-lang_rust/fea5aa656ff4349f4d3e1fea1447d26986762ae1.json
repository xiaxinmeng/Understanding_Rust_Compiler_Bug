{"sha": "fea5aa656ff4349f4d3e1fea1447d26986762ae1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlYTVhYTY1NmZmNDM0OWY0ZDNlMWZlYTE0NDdkMjY5ODY3NjJhZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-30T00:42:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-30T00:42:13Z"}, "message": "auto merge of #20160 : nick29581/rust/ranges2, r=nikomatsakis\n\nThe first six commits are from an earlier PR (#19858) and have already been reviewed. This PR makes an awful hack in the compiler to accommodate slices both natively and in the index a range form. After a snapshot we can hopefully add the new Index impls and then we can remove these awful hacks.\r\n\r\nr? @nikomatsakis (or anyone who knows the compiler, really)", "tree": {"sha": "3736614e84499fcde1623619b6e1336f2b2221d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3736614e84499fcde1623619b6e1336f2b2221d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fea5aa656ff4349f4d3e1fea1447d26986762ae1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fea5aa656ff4349f4d3e1fea1447d26986762ae1", "html_url": "https://github.com/rust-lang/rust/commit/fea5aa656ff4349f4d3e1fea1447d26986762ae1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fea5aa656ff4349f4d3e1fea1447d26986762ae1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71123902e17ad339649f33423995eac78da40e3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/71123902e17ad339649f33423995eac78da40e3c", "html_url": "https://github.com/rust-lang/rust/commit/71123902e17ad339649f33423995eac78da40e3c"}, {"sha": "113f8aa86b64c0be1981a69d110e42d22460b33c", "url": "https://api.github.com/repos/rust-lang/rust/commits/113f8aa86b64c0be1981a69d110e42d22460b33c", "html_url": "https://github.com/rust-lang/rust/commit/113f8aa86b64c0be1981a69d110e42d22460b33c"}], "stats": {"total": 864, "additions": 421, "deletions": 443}, "files": [{"sha": "df8e08f07a32150f4390a8fb914a01dd029629b3", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -453,7 +453,7 @@ impl<T> RingBuf<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (buf[mut tail..head], empty)\n+                (buf.slice_mut(tail, head), empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);"}, {"sha": "404804cd91d2ee76e980e26182a00d34bc42e66a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -94,7 +94,7 @@ use core::iter::{range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::FnMut;\n+use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n use core::prelude::{Ord, Ordering, RawPtr, Some, range};\n use core::ptr;\n@@ -1110,7 +1110,7 @@ impl<T> SliceExt<T> for [T] {\n \n     #[inline]\n     fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src[mut start..end].iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n@@ -1326,7 +1326,7 @@ impl<T> BorrowFrom<Vec<T>> for [T] {\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned[mut] }\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -2491,14 +2491,14 @@ mod tests {\n         assert!(a == [7i,2,3,4]);\n         let mut a = [1i,2,3,4,5];\n         let b = vec![5i,6,7,8,9,0];\n-        assert_eq!(a[mut 2..4].move_from(b,1,6), 2);\n+        assert_eq!(a.slice_mut(2, 4).move_from(b,1,6), 2);\n         assert!(a == [1i,2,6,7,5]);\n     }\n \n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1i,2,3,4,5];\n-        values[mut 1..4].reverse();\n+        values.slice_mut(1, 4).reverse();\n         assert!(values == [1,4,3,2,5]);\n     }\n \n@@ -2545,9 +2545,9 @@ mod tests {\n     fn test_bytes_set_memory() {\n         use slice::bytes::MutableByteVector;\n         let mut values = [1u8,2,3,4,5];\n-        values[mut 0..5].set_memory(0xAB);\n+        values.slice_mut(0, 5).set_memory(0xAB);\n         assert!(values == [0xAB, 0xAB, 0xAB, 0xAB, 0xAB]);\n-        values[mut 2..4].set_memory(0xFF);\n+        values.slice_mut(2, 4).set_memory(0xFF);\n         assert!(values == [0xAB, 0xAB, 0xFF, 0xFF, 0xAB]);\n     }\n "}, {"sha": "329fe7c7b4913bc63a52115acc980cc61c0a0107", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -179,7 +179,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         _ => ()\n     }\n \n-    buf[mut ..end].reverse();\n+    buf.slice_to_mut(end).reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -316,7 +316,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             impl<'a> fmt::FormatWriter for Filler<'a> {\n                 fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf[mut *self.end..],\n+                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n                                               bytes);\n                     *self.end += bytes.len();\n                     Ok(())"}, {"sha": "f6b79ccc42b01d3592031a3fed57571947f5470b", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -908,6 +908,14 @@ impl<Idx: Clone + Step> Iterator<Idx> for RangeFrom<Idx> {\n     }\n }\n \n+/// A range which is only bounded above.\n+#[deriving(Copy)]\n+#[lang=\"range_to\"]\n+pub struct RangeTo<Idx> {\n+    /// The upper bound of the range (exclusive).\n+    pub end: Idx,\n+}\n+\n \n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`."}, {"sha": "d25f96ac15fa656b32e8d4e14975ac080381da37", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -264,24 +264,26 @@ impl<T> SliceExt<T> for [T] {\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        self[mut start..end]\n+        ops::SliceMut::slice_or_fail_mut(self, &start, &end)\n     }\n \n     #[inline]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        self[mut start..]\n+        ops::SliceMut::slice_from_or_fail_mut(self, &start)\n     }\n \n     #[inline]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        self[mut ..end]\n+        ops::SliceMut::slice_to_or_fail_mut(self, &end)\n     }\n \n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let self2: &mut [T] = mem::transmute_copy(&self);\n-            (self[mut ..mid], self2[mut mid..])\n+\n+            (ops::SliceMut::slice_to_or_fail_mut(self, &mid),\n+             ops::SliceMut::slice_from_or_fail_mut(self2, &mid))\n         }\n     }\n \n@@ -315,14 +317,13 @@ impl<T> SliceExt<T> for [T] {\n \n     #[inline]\n     fn tail_mut(&mut self) -> &mut [T] {\n-        let len = self.len();\n-        self[mut 1..len]\n+        self.slice_from_mut(1)\n     }\n \n     #[inline]\n     fn init_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n-        self[mut 0..len - 1]\n+        self.slice_to_mut(len-1)\n     }\n \n     #[inline]\n@@ -560,7 +561,7 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self[mut i..].reverse();\n+        self.slice_from_mut(i).reverse();\n \n         true\n     }\n@@ -582,7 +583,7 @@ impl<T: Ord> OrdSliceExt<T> for [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self[mut i..].reverse();\n+        self.slice_from_mut(i).reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -990,7 +991,7 @@ impl<'a, T, P> Iterator<&'a mut [T]> for MutSplits<'a, T, P> where P: FnMut(&T)\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail[mut 1..];\n+                self.v = tail.slice_from_mut(1);\n                 Some(head)\n             }\n         }\n@@ -1026,7 +1027,7 @@ impl<'a, T, P> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T, P> where\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail[mut 1..])\n+                Some(tail.slice_from_mut(1))\n             }\n         }\n     }"}, {"sha": "1fc5f90028dad73ea219ff409ae8a59dce147f55", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -897,6 +897,7 @@ impl<'a> Iterator<&'a str> for SplitStr<'a> {\n     }\n }\n \n+\n /*\n Section: Comparing strings\n */"}, {"sha": "430188c7e4322c0b2bb5c0dec98a8f441fdb824e", "filename": "src/libcoretest/ops.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcoretest%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibcoretest%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fops.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use test::Bencher;\n-use core::ops::{Range, FullRange, RangeFrom};\n+use core::ops::{Range, FullRange, RangeFrom, RangeTo};\n \n // Overhead of dtors\n \n@@ -55,6 +55,12 @@ fn test_range_from() {\n     assert!(count == 10);\n }\n \n+#[test]\n+fn test_range_to() {\n+    // Not much to test.\n+    let _ = RangeTo { end: 42u };\n+}\n+\n #[test]\n fn test_full_range() {\n     // Not much to test."}, {"sha": "7dd0649e4837df827b145a76995d5372949f3790", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -735,7 +735,7 @@ mod tests {\n     fn test_input(g: LabelledGraph) -> IoResult<String> {\n         let mut writer = Vec::new();\n         render(&g, &mut writer).unwrap();\n-        (&mut writer[]).read_to_string()\n+        (&mut writer.as_slice()).read_to_string()\n     }\n \n     // All of the tests use raw-strings as the format for the expected outputs,\n@@ -847,7 +847,7 @@ r#\"digraph hasse_diagram {\n                  edge(1, 3, \";\"),    edge(2, 3, \";\"   )));\n \n         render(&g, &mut writer).unwrap();\n-        let r = (&mut writer[]).read_to_string();\n+        let r = (&mut writer.as_slice()).read_to_string();\n \n         assert_eq!(r.unwrap(),\n r#\"digraph syntax_tree {"}, {"sha": "cbe69295050ec02953a3ee0a9cc841819b780928", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -102,7 +102,7 @@ impl Writer for SeekableMemWriter {\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf[mut self.pos..], left);\n+                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "92aa70548c82bdd4d4dc3e5f8838d416fb88de4b", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -432,15 +432,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.call(expr, pred, &**l, Some(&**r).into_iter())\n             }\n \n-            ast::ExprSlice(ref base, ref start, ref end, _) => {\n-                self.call(expr,\n-                          pred,\n-                          &**base,\n-                          start.iter().chain(end.iter()).map(|x| &**x))\n-            }\n-\n             ast::ExprRange(ref start, ref end) => {\n-                let fields = Some(&**start).into_iter()\n+                let fields = start.as_ref().map(|e| &**e).into_iter()\n                     .chain(end.as_ref().map(|e| &**e).into_iter());\n                 self.straightline(expr, pred, fields)\n             }"}, {"sha": "b7cfb22b85f8ce9812c6462a3f3957ac9c427153", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -431,26 +431,33 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n-                if !self.walk_overloaded_operator(expr, &**lhs, vec![&**rhs], PassArgs::ByRef) {\n-                    self.select_from_expr(&**lhs);\n-                    self.consume_expr(&**rhs);\n+                match rhs.node {\n+                    ast::ExprRange(ref start, ref end) => {\n+                        // Hacked slicing syntax (KILLME).\n+                        let args = match (start, end) {\n+                            (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n+                            (&Some(ref e), &None) => vec![&**e],\n+                            (&None, &Some(ref e)) => vec![&**e],\n+                            (&None, &None) => Vec::new()\n+                        };\n+                        let overloaded =\n+                            self.walk_overloaded_operator(expr, &**lhs, args, PassArgs::ByRef);\n+                        assert!(overloaded);\n+                    }\n+                    _ => {\n+                        if !self.walk_overloaded_operator(expr,\n+                                                          &**lhs,\n+                                                          vec![&**rhs],\n+                                                          PassArgs::ByRef) {\n+                            self.select_from_expr(&**lhs);\n+                            self.consume_expr(&**rhs);\n+                        }\n+                    }\n                 }\n             }\n \n-            ast::ExprSlice(ref base, ref start, ref end, _) => {    // base[start..end]\n-                let args = match (start, end) {\n-                    (&Some(ref e1), &Some(ref e2)) => vec![&**e1, &**e2],\n-                    (&Some(ref e), &None) => vec![&**e],\n-                    (&None, &Some(ref e)) => vec![&**e],\n-                    (&None, &None) => Vec::new()\n-                };\n-                let overloaded =\n-                    self.walk_overloaded_operator(expr, &**base, args, PassArgs::ByRef);\n-                assert!(overloaded);\n-            }\n-\n             ast::ExprRange(ref start, ref end) => {\n-                self.consume_expr(&**start);\n+                start.as_ref().map(|e| self.consume_expr(&**e));\n                 end.as_ref().map(|e| self.consume_expr(&**e));\n             }\n "}, {"sha": "2aef43071992398eefc9197c2c8053e7e302b5dd", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -269,6 +269,7 @@ lets_do_this! {\n     SliceMutTraitLangItem,           \"slice_mut\",               slice_mut_trait;\n     RangeStructLangItem,             \"range\",                   range_struct;\n     RangeFromStructLangItem,         \"range_from\",              range_from_struct;\n+    RangeToStructLangItem,           \"range_to\",                range_to_struct;\n     FullRangeStructLangItem,         \"full_range\",              full_range_struct;\n \n     UnsafeTypeLangItem,              \"unsafe\",                  unsafe_type;"}, {"sha": "d3859ca12a9711930b26f2dcaac566daf6eafabb", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -514,7 +514,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n       ast::ExprMac(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n       ast::ExprParen(..) | ast::ExprInlineAsm(..) | ast::ExprBox(..) |\n-      ast::ExprSlice(..) | ast::ExprRange(..) => {\n+      ast::ExprRange(..) => {\n           visit::walk_expr(ir, expr);\n       }\n     }\n@@ -1191,15 +1191,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**l, r_succ)\n           }\n \n-          ast::ExprSlice(ref e1, ref e2, ref e3, _) => {\n-            let succ = e3.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            self.propagate_through_expr(&**e1, succ)\n-          }\n-\n           ast::ExprRange(ref e1, ref e2) => {\n             let succ = e2.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ));\n-            self.propagate_through_expr(&**e1, succ)\n+            e1.as_ref().map_or(succ, |e| self.propagate_through_expr(&**e, succ))\n           }\n \n           ast::ExprBox(None, ref e) |\n@@ -1495,7 +1489,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ast::ExprBlock(..) | ast::ExprMac(..) | ast::ExprAddrOf(..) |\n       ast::ExprStruct(..) | ast::ExprRepeat(..) | ast::ExprParen(..) |\n       ast::ExprClosure(..) | ast::ExprPath(..) | ast::ExprBox(..) |\n-      ast::ExprSlice(..) | ast::ExprRange(..) => {\n+      ast::ExprRange(..) => {\n         visit::walk_expr(this, expr);\n       }\n       ast::ExprIfLet(..) => {"}, {"sha": "5d3134b9629b2a416402dd51e52d22fa1e32b4fe", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -500,21 +500,28 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             self.cat_tup_field(expr, base_cmt, idx.node, expr_ty)\n           }\n \n-          ast::ExprIndex(ref base, _) => {\n-            let method_call = ty::MethodCall::expr(expr.id());\n-            match self.typer.node_method_ty(method_call) {\n-                Some(method_ty) => {\n-                    // If this is an index implemented by a method call, then it will\n-                    // include an implicit deref of the result.\n-                    let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n-                    self.cat_deref(expr,\n-                                   self.cat_rvalue_node(expr.id(),\n-                                                        expr.span(),\n-                                                        ret_ty), 1, true)\n+          ast::ExprIndex(ref base, ref idx) => {\n+            match idx.node {\n+                ast::ExprRange(..) => {\n+                    // Slicing syntax special case (KILLME).\n+                    self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                 }\n-                None => {\n-                    let base_cmt = self.cat_expr(&**base);\n-                    self.cat_index(expr, base_cmt)\n+                _ => {\n+                    let method_call = ty::MethodCall::expr(expr.id());\n+                    match self.typer.node_method_ty(method_call) {\n+                        Some(method_ty) => {\n+                            // If this is an index implemented by a method call, then it will\n+                            // include an implicit deref of the result.\n+                            let ret_ty = ty::ty_fn_ret(method_ty).unwrap();\n+                            self.cat_deref(expr,\n+                                           self.cat_rvalue_node(expr.id(),\n+                                                                expr.span(),\n+                                                                ret_ty), 1, true)\n+                        }\n+                        None => {\n+                            self.cat_index(expr, self.cat_expr(&**base))\n+                        }\n+                    }\n                 }\n             }\n           }\n@@ -531,7 +538,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprClosure(..) | ast::ExprRet(..) |\n-          ast::ExprUnary(..) | ast::ExprSlice(..) | ast::ExprRange(..) |\n+          ast::ExprUnary(..) | ast::ExprRange(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprBinary(..) | ast::ExprWhile(..) |"}, {"sha": "392724bc9a18ee79ad35c13f15bc96fc92384031", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -485,6 +485,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n \n     let prev_cx = visitor.cx;\n     visitor.cx.parent = Some(expr.id);\n+\n     {\n         let region_maps = &mut visitor.region_maps;\n         let terminating = |id| {"}, {"sha": "232646f64a7d1f720945c977623754b7d3f48366", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -4322,9 +4322,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             // the index method invoked for `a[i]` always yields an `&T`\n             ast::ExprIndex(..) => LvalueExpr,\n \n-            // the slice method invoked for `a[..]` always yields an `&T`\n-            ast::ExprSlice(..) => LvalueExpr,\n-\n             // `for` loops are statements\n             ast::ExprForLoop(..) => RvalueStmtExpr,\n \n@@ -4389,8 +4386,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnary(ast::UnDeref, _) |\n         ast::ExprField(..) |\n         ast::ExprTupField(..) |\n-        ast::ExprIndex(..) |\n-        ast::ExprSlice(..) => {\n+        ast::ExprIndex(..) => {\n             LvalueExpr\n         }\n "}, {"sha": "e1f0168d86be45e59827499870eea5e0333aed96", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -139,14 +139,14 @@ impl FixedBuffer for FixedBuffer64 {\n             let buffer_remaining = size - self.buffer_idx;\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n-                        self.buffer[mut self.buffer_idx..size],\n+                        self.buffer.slice_mut(self.buffer_idx, size),\n                         input[..buffer_remaining]);\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n             } else {\n                 copy_memory(\n-                    self.buffer[mut self.buffer_idx..self.buffer_idx + input.len()],\n+                    self.buffer.slice_mut(self.buffer_idx, self.buffer_idx + input.len()),\n                     input);\n                 self.buffer_idx += input.len();\n                 return;\n@@ -165,7 +165,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // be empty.\n         let input_remaining = input.len() - i;\n         copy_memory(\n-            self.buffer[mut ..input_remaining],\n+            self.buffer.slice_to_mut(input_remaining),\n             input[i..]);\n         self.buffer_idx += input_remaining;\n     }\n@@ -176,13 +176,13 @@ impl FixedBuffer for FixedBuffer64 {\n \n     fn zero_until(&mut self, idx: uint) {\n         assert!(idx >= self.buffer_idx);\n-        self.buffer[mut self.buffer_idx..idx].set_memory(0);\n+        self.buffer.slice_mut(self.buffer_idx, idx).set_memory(0);\n         self.buffer_idx = idx;\n     }\n \n     fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n         self.buffer_idx += len;\n-        return self.buffer[mut self.buffer_idx - len..self.buffer_idx];\n+        return self.buffer.slice_mut(self.buffer_idx - len, self.buffer_idx);\n     }\n \n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n@@ -362,7 +362,7 @@ impl Engine256State {\n              )\n         );\n \n-        read_u32v_be(w[mut 0..16], data);\n+        read_u32v_be(w.slice_mut(0, 16), data);\n \n         // Putting the message schedule inside the same loop as the round calculations allows for\n         // the compiler to generate better code.\n@@ -498,14 +498,14 @@ impl Digest for Sha256 {\n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        write_u32_be(out[mut 0..4], self.engine.state.h0);\n-        write_u32_be(out[mut 4..8], self.engine.state.h1);\n-        write_u32_be(out[mut 8..12], self.engine.state.h2);\n-        write_u32_be(out[mut 12..16], self.engine.state.h3);\n-        write_u32_be(out[mut 16..20], self.engine.state.h4);\n-        write_u32_be(out[mut 20..24], self.engine.state.h5);\n-        write_u32_be(out[mut 24..28], self.engine.state.h6);\n-        write_u32_be(out[mut 28..32], self.engine.state.h7);\n+        write_u32_be(out.slice_mut(0, 4), self.engine.state.h0);\n+        write_u32_be(out.slice_mut(4, 8), self.engine.state.h1);\n+        write_u32_be(out.slice_mut(8, 12), self.engine.state.h2);\n+        write_u32_be(out.slice_mut(12, 16), self.engine.state.h3);\n+        write_u32_be(out.slice_mut(16, 20), self.engine.state.h4);\n+        write_u32_be(out.slice_mut(20, 24), self.engine.state.h5);\n+        write_u32_be(out.slice_mut(24, 28), self.engine.state.h6);\n+        write_u32_be(out.slice_mut(28, 32), self.engine.state.h7);\n     }\n \n     fn reset(&mut self) {"}, {"sha": "2374e8b340be770f28baffa6f184399448eaac70", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -246,7 +246,6 @@ mod svh_visitor {\n         SawExprAssign,\n         SawExprAssignOp(ast::BinOp),\n         SawExprIndex,\n-        SawExprSlice,\n         SawExprRange,\n         SawExprPath,\n         SawExprAddrOf(ast::Mutability),\n@@ -280,7 +279,6 @@ mod svh_visitor {\n             ExprField(_, id)         => SawExprField(content(id.node)),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,\n-            ExprSlice(..)            => SawExprSlice,\n             ExprRange(..)            => SawExprRange,\n             ExprPath(..)             => SawExprPath,\n             ExprAddrOf(m, _)         => SawExprAddrOf(m),"}, {"sha": "f96aa484ffc9516887b348406138d1bbf07c7f01", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -24,7 +24,8 @@ use trans::common;\n use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n use trans::debuginfo;\n use trans::glue;\n-use middle::region;\n+// Temporary due to slicing syntax hacks (KILLME)\n+//use middle::region;\n use trans::type_::Type;\n use middle::ty::{mod, Ty};\n use std::fmt;\n@@ -128,15 +129,16 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         // excluding id's that correspond to closure bodies only). For\n         // now we just say that if there is already an AST scope on the stack,\n         // this new AST scope had better be its immediate child.\n-        let top_scope = self.top_ast_scope();\n+        // Temporarily removed due to slicing syntax hacks (KILLME).\n+        /*let top_scope = self.top_ast_scope();\n         if top_scope.is_some() {\n             assert_eq!(self.ccx\n                            .tcx()\n                            .region_maps\n                            .opt_encl_scope(region::CodeExtent::from_node_id(debug_loc.id))\n                            .map(|s|s.node_id()),\n                        top_scope);\n-        }\n+        }*/\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n                                           Some(debug_loc)));"}, {"sha": "56c42c7afdeb8bfd956c2c50f0cc44398cb72d08", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -3533,20 +3533,14 @@ fn create_scope_map(cx: &CrateContext,\n             }\n \n             ast::ExprAssignOp(_, ref lhs, ref rhs) |\n-            ast::ExprIndex(ref lhs, ref rhs)        |\n+            ast::ExprIndex(ref lhs, ref rhs) |\n             ast::ExprBinary(_, ref lhs, ref rhs)    => {\n                 walk_expr(cx, &**lhs, scope_stack, scope_map);\n                 walk_expr(cx, &**rhs, scope_stack, scope_map);\n             }\n \n-            ast::ExprSlice(ref base, ref start, ref end, _) => {\n-                walk_expr(cx, &**base, scope_stack, scope_map);\n-                start.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n-                end.as_ref().map(|x| walk_expr(cx, &**x, scope_stack, scope_map));\n-            }\n-\n             ast::ExprRange(ref start, ref end) => {\n-                walk_expr(cx, &**start, scope_stack, scope_map);\n+                start.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n                 end.as_ref().map(|e| walk_expr(cx, &**e, scope_stack, scope_map));\n             }\n "}, {"sha": "f49769ba0d9c630dd6a43df8e863c152bf835a2c", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -585,36 +585,40 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_rec_tup_field(bcx, &**base, idx.node)\n         }\n         ast::ExprIndex(ref base, ref idx) => {\n-            trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n-        }\n-        ast::ExprSlice(ref base, ref start, ref end, _) => {\n-            let _icx = push_ctxt(\"trans_slice\");\n-            let ccx = bcx.ccx();\n-\n-            let method_call = MethodCall::expr(expr.id);\n-            let method_ty = ccx.tcx()\n-                               .method_map\n-                               .borrow()\n-                               .get(&method_call)\n-                               .map(|method| method.ty);\n-            let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n-\n-            let mut args = vec![];\n-            start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n-            end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n-\n-            let result_ty = ty::ty_fn_ret(monomorphize_type(bcx, method_ty.unwrap())).unwrap();\n-            let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n-\n-            unpack_result!(bcx,\n-                           trans_overloaded_op(bcx,\n-                                               expr,\n-                                               method_call,\n-                                               base_datum,\n-                                               args,\n-                                               Some(SaveIn(scratch.val)),\n-                                               true));\n-            DatumBlock::new(bcx, scratch.to_expr_datum())\n+            match idx.node {\n+                ast::ExprRange(ref start, ref end) => {\n+                    // Special case for slicing syntax (KILLME).\n+                    let _icx = push_ctxt(\"trans_slice\");\n+                    let ccx = bcx.ccx();\n+\n+                    let method_call = MethodCall::expr(expr.id);\n+                    let method_ty = ccx.tcx()\n+                                       .method_map\n+                                       .borrow()\n+                                       .get(&method_call)\n+                                       .map(|method| method.ty);\n+                    let base_datum = unpack_datum!(bcx, trans(bcx, &**base));\n+\n+                    let mut args = vec![];\n+                    start.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+                    end.as_ref().map(|e| args.push((unpack_datum!(bcx, trans(bcx, &**e)), e.id)));\n+\n+                    let result_ty = ty::ty_fn_ret(monomorphize_type(bcx,\n+                                                                    method_ty.unwrap())).unwrap();\n+                    let scratch = rvalue_scratch_datum(bcx, result_ty, \"trans_slice\");\n+\n+                    unpack_result!(bcx,\n+                                   trans_overloaded_op(bcx,\n+                                                       expr,\n+                                                       method_call,\n+                                                       base_datum,\n+                                                       args,\n+                                                       Some(SaveIn(scratch.val)),\n+                                                       true));\n+                    DatumBlock::new(bcx, scratch.to_expr_datum())\n+                }\n+                _ => trans_index(bcx, expr, &**base, &**idx, MethodCall::expr(expr.id))\n+            }\n         }\n         ast::ExprBox(_, ref contents) => {\n             // Special case for `Box<T>`\n@@ -1064,22 +1068,34 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n \n             // A range just desugars into a struct.\n-            let (did, fields) = match end {\n-                &Some(ref end) => {\n+            // Note that the type of the start and end may not be the same, but\n+            // they should only differ in their lifetime, which should not matter\n+            // in trans.\n+            let (did, fields, ty_params) = match (start, end) {\n+                (&Some(ref start), &Some(ref end)) => {\n                     // Desugar to Range\n-                    let fields = vec!(make_field(\"start\", start.clone()),\n-                                      make_field(\"end\", end.clone()));\n-                    (tcx.lang_items.range_struct(), fields)\n+                    let fields = vec![make_field(\"start\", start.clone()),\n+                                      make_field(\"end\", end.clone())];\n+                    (tcx.lang_items.range_struct(), fields, vec![node_id_type(bcx, start.id)])\n                 }\n-                &None => {\n+                (&Some(ref start), &None) => {\n                     // Desugar to RangeFrom\n-                    let fields = vec!(make_field(\"start\", start.clone()));\n-                    (tcx.lang_items.range_from_struct(), fields)\n+                    let fields = vec![make_field(\"start\", start.clone())];\n+                    (tcx.lang_items.range_from_struct(), fields, vec![node_id_type(bcx, start.id)])\n+                }\n+                (&None, &Some(ref end)) => {\n+                    // Desugar to RangeTo\n+                    let fields = vec![make_field(\"end\", end.clone())];\n+                    (tcx.lang_items.range_to_struct(), fields, vec![node_id_type(bcx, end.id)])\n+                }\n+                _ => {\n+                    // Desugar to FullRange\n+                    (tcx.lang_items.full_range_struct(), vec![], vec![])\n                 }\n             };\n \n             if let Some(did) = did {\n-                let substs = Substs::new_type(vec![node_id_type(bcx, start.id)], vec![]);\n+                let substs = Substs::new_type(ty_params, vec![]);\n                 trans_struct(bcx,\n                              fields.as_slice(),\n                              None,"}, {"sha": "cf6715e2d73208c388bcd166adda36bfcfd67749", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -488,7 +488,6 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 ast::ExprParen(ref expr) |\n                 ast::ExprField(ref expr, _) |\n                 ast::ExprTupField(ref expr, _) |\n-                ast::ExprSlice(ref expr, _, _, _) |\n                 ast::ExprIndex(ref expr, _) |\n                 ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),\n                 _ => break,"}, {"sha": "fb23ad8e340cee03941b3242336e7ea7e9d9302c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 205, "deletions": 226, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -2003,7 +2003,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n-#[deriving(Copy, Show)]\n+#[deriving(Copy, Show,PartialEq,Eq)]\n pub enum LvaluePreference {\n     PreferMutLvalue,\n     NoPreference\n@@ -2214,57 +2214,6 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Autoderefs `base_expr`, looking for a `Slice` impl. If it finds one, installs the relevant\n-/// method info and returns the result type (else None).\n-fn try_overloaded_slice<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                  method_call: MethodCall,\n-                                  expr: &ast::Expr,\n-                                  base_expr: &ast::Expr,\n-                                  base_ty: Ty<'tcx>,\n-                                  start_expr: &Option<P<ast::Expr>>,\n-                                  end_expr: &Option<P<ast::Expr>>,\n-                                  mutbl: ast::Mutability)\n-                                  -> Option<Ty<'tcx>> // return type is result of slice\n-{\n-    let lvalue_pref = match mutbl {\n-        ast::MutMutable => PreferMutLvalue,\n-        ast::MutImmutable => NoPreference\n-    };\n-\n-    let opt_method_ty =\n-        autoderef_for_index(fcx, base_expr, base_ty, lvalue_pref, |adjusted_ty, autoderefref| {\n-            try_overloaded_slice_step(fcx, method_call, expr, base_expr,\n-                                      adjusted_ty, autoderefref, mutbl,\n-                                      start_expr, end_expr)\n-        });\n-\n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_ty_or_err = opt_method_ty.unwrap_or(ty::mk_err());\n-\n-    let mut args = vec![];\n-    start_expr.as_ref().map(|x| args.push(x));\n-    end_expr.as_ref().map(|x| args.push(x));\n-\n-    check_method_argument_types(fcx,\n-                                expr.span,\n-                                method_ty_or_err,\n-                                expr,\n-                                args.as_slice(),\n-                                AutorefArgs::Yes,\n-                                DontTupleArguments);\n-\n-    opt_method_ty.map(|method_ty| {\n-        let result_ty = ty::ty_fn_ret(method_ty);\n-        match result_ty {\n-            ty::FnConverging(result_ty) => result_ty,\n-            ty::FnDiverging => {\n-                fcx.tcx().sess.span_bug(expr.span,\n-                                        \"slice trait does not define a `!` return\")\n-            }\n-        }\n-    })\n-}\n \n /// Checks for a `Slice` (or `SliceMut`) impl at the relevant level of autoderef. If it finds one,\n /// installs method info and returns type of method (else None).\n@@ -2274,65 +2223,79 @@ fn try_overloaded_slice_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                        base_expr: &ast::Expr,\n                                        base_ty: Ty<'tcx>, // autoderef'd type\n                                        autoderefref: ty::AutoDerefRef<'tcx>,\n-                                       mutbl: ast::Mutability,\n+                                       lvalue_pref: LvaluePreference,\n                                        start_expr: &Option<P<ast::Expr>>,\n                                        end_expr: &Option<P<ast::Expr>>)\n-                                       // result type is type of method being called\n-                                       -> Option<Ty<'tcx>>\n+                                       -> Option<(Ty<'tcx>, /* index type */\n+                                                  Ty<'tcx>)> /* return type */\n {\n-    let method = if mutbl == ast::MutMutable {\n-        // Try `SliceMut` first, if preferred.\n-        match fcx.tcx().lang_items.slice_mut_trait() {\n-            Some(trait_did) => {\n-                let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_or_fail_mut\",\n-                    (&Some(_), &None) => \"slice_from_or_fail_mut\",\n-                    (&None, &Some(_)) => \"slice_to_or_fail_mut\",\n-                    (&None, &None) => \"as_mut_slice_\",\n-                };\n+    let input_ty = fcx.infcx().next_ty_var();\n+    let return_ty = fcx.infcx().next_ty_var();\n \n-                method::lookup_in_trait_adjusted(fcx,\n-                                                 expr.span,\n-                                                 Some(&*base_expr),\n-                                                 token::intern(method_name),\n-                                                 trait_did,\n-                                                 autoderefref,\n-                                                 base_ty,\n-                                                 None)\n+    let method = match lvalue_pref {\n+        PreferMutLvalue => {\n+            // Try `SliceMut` first, if preferred.\n+            match fcx.tcx().lang_items.slice_mut_trait() {\n+                Some(trait_did) => {\n+                    let method_name = match (start_expr, end_expr) {\n+                        (&Some(_), &Some(_)) => \"slice_or_fail_mut\",\n+                        (&Some(_), &None) => \"slice_from_or_fail_mut\",\n+                        (&None, &Some(_)) => \"slice_to_or_fail_mut\",\n+                        (&None, &None) => \"as_mut_slice_\",\n+                    };\n+\n+                    method::lookup_in_trait_adjusted(fcx,\n+                                                     expr.span,\n+                                                     Some(&*base_expr),\n+                                                     token::intern(method_name),\n+                                                     trait_did,\n+                                                     autoderefref,\n+                                                     base_ty,\n+                                                     Some(vec![input_ty, return_ty]))\n+                }\n+                _ => None,\n             }\n-            _ => None,\n         }\n-    } else {\n-        // Otherwise, fall back to `Slice`.\n-        // FIXME(#17293) this will not coerce base_expr, so we miss the Slice\n-        // trait for `&mut [T]`.\n-        match fcx.tcx().lang_items.slice_trait() {\n-            Some(trait_did) => {\n-                let method_name = match (start_expr, end_expr) {\n-                    (&Some(_), &Some(_)) => \"slice_or_fail\",\n-                    (&Some(_), &None) => \"slice_from_or_fail\",\n-                    (&None, &Some(_)) => \"slice_to_or_fail\",\n-                    (&None, &None) => \"as_slice_\",\n-                };\n+        NoPreference => {\n+            // Otherwise, fall back to `Slice`.\n+            match fcx.tcx().lang_items.slice_trait() {\n+                Some(trait_did) => {\n+                    let method_name = match (start_expr, end_expr) {\n+                        (&Some(_), &Some(_)) => \"slice_or_fail\",\n+                        (&Some(_), &None) => \"slice_from_or_fail\",\n+                        (&None, &Some(_)) => \"slice_to_or_fail\",\n+                        (&None, &None) => \"as_slice_\",\n+                    };\n \n-                method::lookup_in_trait_adjusted(fcx,\n-                                                 expr.span,\n-                                                 Some(&*base_expr),\n-                                                 token::intern(method_name),\n-                                                 trait_did,\n-                                                 autoderefref,\n-                                                 base_ty,\n-                                                 None)\n+                    method::lookup_in_trait_adjusted(fcx,\n+                                                     expr.span,\n+                                                     Some(&*base_expr),\n+                                                     token::intern(method_name),\n+                                                     trait_did,\n+                                                     autoderefref,\n+                                                     base_ty,\n+                                                     Some(vec![input_ty, return_ty]))\n+                }\n+                _ => None,\n             }\n-            _ => None,\n         }\n     };\n \n     // If some lookup succeeded, install method in table\n     method.map(|method| {\n-        let ty = method.ty;\n-        fcx.inh.method_map.borrow_mut().insert(method_call, method);\n-        ty\n+        let method_ty = method.ty;\n+        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method));\n+\n+        let result_ty = ty::ty_fn_ret(method_ty);\n+        let result_ty = match result_ty {\n+            ty::FnConverging(result_ty) => result_ty,\n+            ty::FnDiverging => {\n+                fcx.tcx().sess.span_bug(expr.span,\n+                \"slice trait does not define a `!` return\")\n+            }\n+        };\n+\n+        (input_ty, result_ty)\n     })\n }\n \n@@ -4211,155 +4174,171 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n-          check_expr(fcx, &**idx);\n           let base_t = fcx.expr_ty(&**base);\n-          let idx_t = fcx.expr_ty(&**idx);\n           if ty::type_is_error(base_t) {\n               fcx.write_ty(id, base_t);\n-          } else if ty::type_is_error(idx_t) {\n-              fcx.write_ty(id, idx_t);\n           } else {\n-              let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n-\n-              let result =\n-                  autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n-                      try_index_step(fcx,\n-                                     MethodCall::expr(expr.id),\n-                                     expr,\n-                                     &**base,\n-                                     adj_ty,\n-                                     adj,\n-                                     lvalue_pref)\n-                  });\n-\n-              match result {\n-                  Some((index_ty, element_ty)) => {\n-                      check_expr_has_type(fcx, &**idx, index_ty);\n-                      fcx.write_ty(id, element_ty);\n-                  }\n-                  _ => {\n-                      check_expr_has_type(fcx, &**idx, ty::mk_err());\n-                      fcx.type_error_message(\n-                          expr.span,\n-                          |actual| {\n-                              format!(\"cannot index a value of type `{}`\",\n-                                      actual)\n-                          },\n-                          base_t,\n-                          None);\n-                      fcx.write_ty(id, ty::mk_err())\n+              match idx.node {\n+                ast::ExprRange(ref start, ref end) => {\n+                  // A slice, rather than an index. Special cased for now (KILLME).\n+                  let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n+\n+                  let result =\n+                      autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n+                          try_overloaded_slice_step(fcx,\n+                                                    MethodCall::expr(expr.id),\n+                                                    expr,\n+                                                    &**base,\n+                                                    adj_ty,\n+                                                    adj,\n+                                                    lvalue_pref,\n+                                                    start,\n+                                                    end)\n+                      });\n+\n+                  let mut args = vec![];\n+                  start.as_ref().map(|x| args.push(x));\n+                  end.as_ref().map(|x| args.push(x));\n+\n+                  match result {\n+                      Some((index_ty, element_ty)) => {\n+                          for a in args.iter() {\n+                            check_expr_has_type(fcx, &***a, index_ty);\n+                          }\n+                          fcx.write_ty(idx.id, element_ty);\n+                          fcx.write_ty(id, element_ty)\n+                      }\n+                      _ => {\n+                          for a in args.iter() {\n+                            check_expr(fcx, &***a);\n+                          }\n+                          fcx.type_error_message(expr.span,\n+                             |actual| {\n+                                  format!(\"cannot take a slice of a value with type `{}`\",\n+                                          actual)\n+                             },\n+                             base_t,\n+                             None);\n+                          fcx.write_ty(idx.id, ty::mk_err());\n+                          fcx.write_ty(id, ty::mk_err())\n+                      }\n                   }\n-              }\n-          }\n-       }\n-       ast::ExprSlice(ref base, ref start, ref end, mutbl) => {\n-          check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n-          let raw_base_t = fcx.expr_ty(&**base);\n-\n-          let mut some_err = false;\n-          if ty::type_is_error(raw_base_t) {\n-              fcx.write_ty(id, raw_base_t);\n-              some_err = true;\n-          }\n-\n-          {\n-              let check_slice_idx = |e: &ast::Expr| {\n-                  check_expr(fcx, e);\n-                  let e_t = fcx.expr_ty(e);\n-                  if ty::type_is_error(e_t) {\n-                    fcx.write_ty(e.id, e_t);\n-                    some_err = true;\n-                  }\n-              };\n-              start.as_ref().map(|e| check_slice_idx(&**e));\n-              end.as_ref().map(|e| check_slice_idx(&**e));\n-          }\n-\n-          if !some_err {\n-              let base_t = structurally_resolved_type(fcx,\n-                                                      expr.span,\n-                                                      raw_base_t);\n-              let method_call = MethodCall::expr(expr.id);\n-              match try_overloaded_slice(fcx,\n-                                         method_call,\n-                                         expr,\n-                                         &**base,\n-                                         base_t,\n-                                         start,\n-                                         end,\n-                                         mutbl) {\n-                  Some(ty) => fcx.write_ty(id, ty),\n-                  None => {\n-                        fcx.type_error_message(expr.span,\n-                           |actual| {\n-                                format!(\"cannot take a {}slice of a value with type `{}`\",\n-                                        if mutbl == ast::MutMutable {\n-                                            \"mutable \"\n-                                        } else {\n-                                            \"\"\n-                                        },\n-                                        actual)\n-                           },\n-                           base_t,\n-                           None);\n-                        fcx.write_ty(id, ty::mk_err())\n+                }\n+                _ => {\n+                  check_expr(fcx, &**idx);\n+                  let idx_t = fcx.expr_ty(&**idx);\n+                  if ty::type_is_error(idx_t) {\n+                      fcx.write_ty(id, idx_t);\n+                  } else {\n+                      let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n+\n+                      let result =\n+                          autoderef_for_index(fcx, &**base, base_t, lvalue_pref, |adj_ty, adj| {\n+                              try_index_step(fcx,\n+                                             MethodCall::expr(expr.id),\n+                                             expr,\n+                                             &**base,\n+                                             adj_ty,\n+                                             adj,\n+                                             lvalue_pref)\n+                          });\n+\n+                      match result {\n+                          Some((index_ty, element_ty)) => {\n+                              check_expr_has_type(fcx, &**idx, index_ty);\n+                              fcx.write_ty(id, element_ty);\n+                          }\n+                          _ => {\n+                              check_expr_has_type(fcx, &**idx, ty::mk_err());\n+                              fcx.type_error_message(\n+                                  expr.span,\n+                                  |actual| {\n+                                      format!(\"cannot index a value of type `{}`\",\n+                                              actual)\n+                                  },\n+                                  base_t,\n+                                  None);\n+                              fcx.write_ty(id, ty::mk_err())\n+                          }\n+                      }\n                   }\n+                }\n               }\n           }\n        }\n        ast::ExprRange(ref start, ref end) => {\n-          check_expr(fcx, &**start);\n-          let t_start = fcx.expr_ty(&**start);\n-\n-          let idx_type = if let &Some(ref e) = end {\n+          let t_start = start.as_ref().map(|e| {\n             check_expr(fcx, &**e);\n-            let t_end = fcx.expr_ty(&**e);\n-            if ty::type_is_error(t_end) {\n-                ty::mk_err()\n-            } else if t_start == ty::mk_err() {\n-                ty::mk_err()\n-            } else {\n-                infer::common_supertype(fcx.infcx(),\n-                                        infer::RangeExpression(expr.span),\n-                                        true,\n-                                        t_start,\n-                                        t_end)\n+            fcx.expr_ty(&**e)\n+          });\n+          let t_end = end.as_ref().map(|e| {\n+            check_expr(fcx, &**e);\n+            fcx.expr_ty(&**e)\n+          });\n+\n+          let idx_type = match (t_start, t_end) {\n+            (Some(ty), None) | (None, Some(ty)) => Some(ty),\n+            (Some(t_start), Some(t_end))\n+              if ty::type_is_error(t_start) || ty::type_is_error(t_end) => {\n+                Some(ty::mk_err())\n             }\n-          } else {\n-            t_start\n+            (Some(t_start), Some(t_end)) => {\n+                Some(infer::common_supertype(fcx.infcx(),\n+                                             infer::RangeExpression(expr.span),\n+                                             true,\n+                                             t_start,\n+                                             t_end))\n+            }\n+            _ => None\n           };\n \n           // Note that we don't check the type of start/end satisfy any\n           // bounds because right the range structs do not have any. If we add\n           // some bounds, then we'll need to check `t_start` against them here.\n \n-          let range_type = if idx_type == ty::mk_err() {\n-            ty::mk_err()\n-          } else {\n-            // Find the did from the appropriate lang item.\n-            let did = if end.is_some() {\n-                // Range\n-                tcx.lang_items.range_struct()\n-            } else {\n-                // RangeFrom\n-                tcx.lang_items.range_from_struct()\n-            };\n-\n-            if let Some(did) = did {\n-                let polytype = ty::lookup_item_type(tcx, did);\n-                let substs = Substs::new_type(vec![idx_type], vec![]);\n-                let bounds = polytype.generics.to_bounds(tcx, &substs);\n-                fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::new(expr.span,\n-                                                 fcx.body_id,\n-                                                 traits::ItemObligation(did)),\n-                    &bounds);\n-\n-                ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n-            } else {\n+          let range_type = match idx_type {\n+            Some(idx_type) if ty::type_is_error(idx_type) => {\n                 ty::mk_err()\n             }\n+            Some(idx_type) => {\n+                // Find the did from the appropriate lang item.\n+                let did = match (start, end) {\n+                    (&Some(_), &Some(_)) => tcx.lang_items.range_struct(),\n+                    (&Some(_), &None) => tcx.lang_items.range_from_struct(),\n+                    (&None, &Some(_)) => tcx.lang_items.range_to_struct(),\n+                    (&None, &None) => {\n+                        tcx.sess.span_bug(expr.span, \"full range should be dealt with above\")\n+                    }\n+                };\n+\n+                if let Some(did) = did {\n+                    let polytype = ty::lookup_item_type(tcx, did);\n+                    let substs = Substs::new_type(vec![idx_type], vec![]);\n+                    let bounds = polytype.generics.to_bounds(tcx, &substs);\n+                    fcx.add_obligations_for_parameters(\n+                        traits::ObligationCause::new(expr.span,\n+                                                     fcx.body_id,\n+                                                     traits::ItemObligation(did)),\n+                        &bounds);\n+\n+                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                } else {\n+                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    ty::mk_err()\n+                }\n+            }\n+            None => {\n+                // Neither start nor end => FullRange\n+                if let Some(did) = tcx.lang_items.full_range_struct() {\n+                    let substs = Substs::new_type(vec![], vec![]);\n+                    ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n+                } else {\n+                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    ty::mk_err()\n+                }\n+            }\n           };\n+\n           fcx.write_ty(id, range_type);\n        }\n "}, {"sha": "fdbce101c1d6c3ddef3cc6a9fa688e784346a7e2", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -104,7 +104,7 @@ impl<R: Reader> BufferedReader<R> {\n impl<R: Reader> Buffer for BufferedReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(self.buf[mut]));\n+            self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n         Ok(self.buf[self.pos..self.cap])\n@@ -219,7 +219,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf[mut self.pos..];\n+            let dst = self.buf.slice_from_mut(self.pos);\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())"}, {"sha": "5f68bbef93220d82cde2cd606d1d22ecf90cd5cd", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -87,7 +87,7 @@ impl Reader for ChanReader {\n         loop {\n             let count = match self.fill_buf().ok() {\n                 Some(src) => {\n-                    let dst = buf[mut num_read..];\n+                    let dst = buf.slice_from_mut(num_read);\n                     let count = cmp::min(src.len(), dst.len());\n                     bytes::copy_memory(dst, src[..count]);\n                     count"}, {"sha": "f2db2875ebf2ca44f1da07f55630ceba7cf813a5", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -931,11 +931,11 @@ mod test {\n         {\n             let mut read_stream = File::open_mode(filename, Open, Read);\n             {\n-                let read_buf = read_mem[mut 0..4];\n+                let read_buf = read_mem.slice_mut(0, 4);\n                 check!(read_stream.read(read_buf));\n             }\n             {\n-                let read_buf = read_mem[mut 4..8];\n+                let read_buf = read_mem.slice_mut(4, 8);\n                 check!(read_stream.read(read_buf));\n             }\n         }"}, {"sha": "20b1162d859c778e71c740c3c09157919b345aa7", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -169,7 +169,7 @@ impl Reader for MemReader {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = self.buf[self.pos.. self.pos + write_len];\n-            let output = buf[mut ..write_len];\n+            let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -214,7 +214,7 @@ impl<'a> Reader for &'a [u8] {\n         let write_len = min(buf.len(), self.len());\n         {\n             let input = self[..write_len];\n-            let output = buf[mut ..write_len];\n+            let output = buf.slice_to_mut(write_len);\n             slice::bytes::copy_memory(output, input);\n         }\n \n@@ -279,7 +279,7 @@ impl<'a> BufWriter<'a> {\n impl<'a> Writer for BufWriter<'a> {\n     #[inline]\n     fn write(&mut self, src: &[u8]) -> IoResult<()> {\n-        let dst = self.buf[mut self.pos..];\n+        let dst = self.buf.slice_from_mut(self.pos);\n         let dst_len = dst.len();\n \n         if dst_len == 0 {\n@@ -359,7 +359,7 @@ impl<'a> Reader for BufReader<'a> {\n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n             let input = self.buf[self.pos.. self.pos + write_len];\n-            let output = buf[mut ..write_len];\n+            let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -652,7 +652,7 @@ mod test {\n         assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[1, 2, 3];\n         assert_eq!(buf, b);\n-        assert!(r.read_at_least(0, buf[mut ..0]).is_ok());\n+        assert!(r.read_at_least(0, buf.slice_to_mut(0)).is_ok());\n         assert_eq!(buf, b);\n         assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n         let b: &[_] = &[4, 5, 6];"}, {"sha": "e1f5efae79fc7e45055ed419e52299a59db570ec", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -513,7 +513,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf[mut read..]) {\n+                match self.read(buf.slice_from_mut(read)) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1123,7 +1123,7 @@ pub trait Writer {\n     #[inline]\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8, ..4];\n-        let n = c.encode_utf8(buf[mut]).unwrap_or(0);\n+        let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n         self.write(buf[..n])\n     }\n \n@@ -1555,7 +1555,7 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf[mut start..width])) {\n+                match try!(self.read(buf.slice_mut(start, width))) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),"}, {"sha": "4830b15a8432e0c046241339ee07a3e5fd00e46d", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -250,7 +250,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16, ..8];\n             gs.clone_from_slice(head);\n-            gs[mut 8 - tail.len() .. 8].clone_from_slice(tail);\n+            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n "}, {"sha": "5bf47dceb5a0e2c7c8e600343955601c1b620aac", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -49,7 +49,7 @@ use sys_common;\n ///     match socket.recv_from(&mut buf) {\n ///         Ok((amt, src)) => {\n ///             // Send a reply to the socket we received data from\n-///             let buf = buf[mut ..amt];\n+///             let buf = buf.slice_to_mut(amt);\n ///             buf.reverse();\n ///             socket.send_to(buf, src);\n ///         }"}, {"sha": "43893ca0126532f494a471328b60052732d22936", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -51,7 +51,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf[mut ..len]);\n+        let res = self.inner.read(buf.slice_to_mut(len));\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}"}, {"sha": "46c3a4f622a5448defd13e981288eede71929b52", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -55,7 +55,7 @@ mod imp {\n         let mut read = 0;\n         let len = v.len();\n         while read < len {\n-            let result = getrandom(v[mut read..]);\n+            let result = getrandom(v.slice_from_mut(read));\n             if result == -1 {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {"}, {"sha": "6b007056a51141ac2ce4c9fae6bd1bf5227f2a5d", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -139,7 +139,7 @@ fn abort_(args: &fmt::Arguments) -> ! {\n     }\n     impl<'a> FormatWriter for BufWriter<'a> {\n         fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n-            let left = self.buf[mut self.pos..];\n+            let left = self.buf.slice_from_mut(self.pos);\n             let to_write = bytes[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();"}, {"sha": "debcbcd2154bddba0ebef01c2aadc164cde55b51", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -723,8 +723,7 @@ pub enum Expr_ {\n     ExprField(P<Expr>, SpannedIdent),\n     ExprTupField(P<Expr>, Spanned<uint>),\n     ExprIndex(P<Expr>, P<Expr>),\n-    ExprSlice(P<Expr>, Option<P<Expr>>, Option<P<Expr>>, Mutability),\n-    ExprRange(P<Expr>, Option<P<Expr>>),\n+    ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n     /// Variable reference, possibly containing `::` and/or\n     /// type parameters, e.g. foo::bar::<baz>"}, {"sha": "4607520655ea1fdb5c9e4dff307d1daf80bac353", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -307,10 +307,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_expr(&mut self, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprSlice(..) => {\n+            ast::ExprRange(..) => {\n                 self.gate_feature(\"slicing_syntax\",\n                                   e.span,\n-                                  \"slicing syntax is experimental\");\n+                                  \"range syntax is experimental\");\n             }\n             _ => {}\n         }"}, {"sha": "11a9fdee0b9b0cb0528b474328e80b53b30c67f1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -1384,14 +1384,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n             }\n-            ExprSlice(e, e1, e2, m) => {\n-                ExprSlice(folder.fold_expr(e),\n-                          e1.map(|x| folder.fold_expr(x)),\n-                          e2.map(|x| folder.fold_expr(x)),\n-                          m)\n-            }\n             ExprRange(e1, e2) => {\n-                ExprRange(folder.fold_expr(e1),\n+                ExprRange(e1.map(|x| folder.fold_expr(x)),\n                           e2.map(|x| folder.fold_expr(x)))\n             }\n             ExprPath(pth) => ExprPath(folder.fold_path(pth)),"}, {"sha": "2f43661eebeba7da6fad98c5a930b6381e486093", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -25,7 +25,7 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n+use ast::{ExprField, ExprTupField, ExprClosure, ExprIf, ExprIfLet, ExprIndex};\n use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n@@ -66,7 +66,7 @@ use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n use ast;\n use ast_util::{mod, as_prec, ident_to_path, operator_prec};\n-use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp};\n+use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp, DUMMY_SP};\n use diagnostic;\n use ext::tt::macro_parser;\n use parse;\n@@ -2135,16 +2135,23 @@ impl<'a> Parser<'a> {\n                     expr: P<Expr>,\n                     start: Option<P<Expr>>,\n                     end: Option<P<Expr>>,\n-                    mutbl: Mutability)\n+                    _mutbl: Mutability)\n                     -> ast::Expr_ {\n-        ExprSlice(expr, start, end, mutbl)\n+        // FIXME: we could give more accurate span info here.\n+        let (lo, hi) = match (&start, &end) {\n+            (&Some(ref s), &Some(ref e)) => (s.span.lo, e.span.hi),\n+            (&Some(ref s), &None) => (s.span.lo, s.span.hi),\n+            (&None, &Some(ref e)) => (e.span.lo, e.span.hi),\n+            (&None, &None) => (DUMMY_SP.lo, DUMMY_SP.hi),\n+        };\n+        ExprIndex(expr, self.mk_expr(lo, hi, ExprRange(start, end)))\n     }\n \n     pub fn mk_range(&mut self,\n                     start: P<Expr>,\n                     end: Option<P<Expr>>)\n                     -> ast::Expr_ {\n-        ExprRange(start, end)\n+        ExprRange(Some(start), end)\n     }\n \n     pub fn mk_field(&mut self, expr: P<Expr>, ident: ast::SpannedIdent) -> ast::Expr_ {"}, {"sha": "accffbc35babead701d83cf1e050d2930a6dfd6c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -1739,15 +1739,7 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**index));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::ExprSlice(ref e, ref start, ref end, ref mutbl) => {\n-                try!(self.print_expr(&**e));\n-                try!(word(&mut self.s, \"[\"));\n-                if mutbl == &ast::MutMutable {\n-                    try!(word(&mut self.s, \"mut\"));\n-                    if start.is_some() || end.is_some() {\n-                        try!(space(&mut self.s));\n-                    }\n-                }\n+            ast::ExprRange(ref start, ref end) => {\n                 if let &Some(ref e) = start {\n                     try!(self.print_expr(&**e));\n                 }\n@@ -1757,14 +1749,6 @@ impl<'a> State<'a> {\n                 if let &Some(ref e) = end {\n                     try!(self.print_expr(&**e));\n                 }\n-                try!(word(&mut self.s, \"]\"));\n-            }\n-            ast::ExprRange(ref start, ref end) => {\n-                try!(self.print_expr(&**start));\n-                try!(word(&mut self.s, \"..\"));\n-                if let &Some(ref e) = end {\n-                    try!(self.print_expr(&**e));\n-                }\n             }\n             ast::ExprPath(ref path) => try!(self.print_path(path, true)),\n             ast::ExprBreak(opt_ident) => {"}, {"sha": "22cfea862517efc15fbcec1df0f07ffe8fe81bf3", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -866,13 +866,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**main_expression);\n             visitor.visit_expr(&**index_expression)\n         }\n-        ExprSlice(ref main_expression, ref start, ref end, _) => {\n-            visitor.visit_expr(&**main_expression);\n-            walk_expr_opt(visitor, start);\n-            walk_expr_opt(visitor, end)\n-        }\n         ExprRange(ref start, ref end) => {\n-            visitor.visit_expr(&**start);\n+            walk_expr_opt(visitor, start);\n             walk_expr_opt(visitor, end)\n         }\n         ExprPath(ref path) => {"}, {"sha": "398728bb51652f68af32d3ce2db9aa41dd5ffa30", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -521,7 +521,7 @@ impl<I> Iterator<u16> for Utf16Encoder<I> where I: Iterator<char> {\n \n         let mut buf = [0u16, ..2];\n         self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(buf[mut]).unwrap_or(0);\n+            let n = ch.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n             if n == 2 { self.extra = buf[1]; }\n             buf[0]\n         })"}, {"sha": "ef38f5ef74341a841d8ae2a7d4bef56617ae317a", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -52,7 +52,7 @@ fn rotate(x: &mut [i32]) {\n \n fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n     for i in range(1, perm.len()) {\n-        rotate(perm[mut ..i + 1]);\n+        rotate(perm.slice_to_mut(i + 1));\n         let count_i = &mut count[i];\n         if *count_i >= i as i32 {\n             *count_i = 0;\n@@ -131,7 +131,7 @@ impl Perm {\n \n \n fn reverse(tperm: &mut [i32], mut k: uint) {\n-    tperm[mut ..k].reverse()\n+    tperm.slice_to_mut(k).reverse()\n }\n \n fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {"}, {"sha": "178d6777939d837ddf05cf878328ff51a8901ea9", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -128,7 +128,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n \n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n-        copy_memory(buf[mut alu_len..buf_len],\n+        copy_memory(buf.slice_mut(alu_len, buf_len),\n                     alu[..LINE_LEN]);\n \n         let mut pos = 0;"}, {"sha": "6ee2233f1686223306930f1f438e65725dab1273", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -254,6 +254,6 @@ fn parallel<'a, I, T, F>(mut iter: I, f: F)\n fn main() {\n     let mut data = read_to_end(&mut stdin_raw()).unwrap();\n     let tables = &Tables::new();\n-    parallel(mut_dna_seqs(data[mut]), |&: seq| reverse_complement(seq, tables));\n+    parallel(mut_dna_seqs(data.as_mut_slice()), |&: seq| reverse_complement(seq, tables));\n     stdout_raw().write(data.as_mut_slice()).unwrap();\n }"}, {"sha": "4af748661fd12e43b115e1cf3c9e50639506415c", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // Test range syntax - type errors.\n+#![feature(slicing_syntax)]\n \n pub fn main() {\n     // Mixed types."}, {"sha": "74c304884a07c09f3a20b3328f43f6d8093eb5d4", "filename": "src/test/compile-fail/range-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Frange-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-2.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // Test range syntax - borrow errors.\n+#![feature(slicing_syntax)]\n \n pub fn main() {\n     let r = {"}, {"sha": "24f710d2ae3f4140f044457c9e98c5eb2d89ddd3", "filename": "src/test/compile-fail/slice-2.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -20,8 +20,4 @@ fn main() {\n     x[Foo..]; //~ ERROR cannot take a slice of a value with type `Foo`\n     x[..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n     x[Foo..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    x[mut]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n-    x[mut Foo..]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n-    x[mut ..Foo]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n-    x[mut Foo..Foo]; //~ ERROR cannot take a mutable slice of a value with type `Foo`\n }"}, {"sha": "8970bcfd153a13b8b3bb2546eb6e7ef8e249b7e4", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -15,5 +15,6 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice\n-    let y = x[mut 2..4]; //~ ERROR cannot borrow\n+    let slice: &mut [int] = &mut [0, 1];\n+    x[2..4] = slice; //~ ERROR cannot borrow\n }"}, {"sha": "ad6b384d74701423207c8a3e360b48718c4e4a23", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -16,9 +16,4 @@ fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable.\n     let y: &mut[_] = x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutabl\n-\n-    let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n-    // Can't borrow mutably twice\n-    let y = x[mut 1..2];\n-    let y = x[mut 4..5]; //~ERROR cannot borrow\n }"}, {"sha": "864cee03f24dae94cb7e3a6efbc5b5904fed6a96", "filename": "src/test/run-pass/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Frun-pass%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fea5aa656ff4349f4d3e1fea1447d26986762ae1/src%2Ftest%2Frun-pass%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange.rs?ref=fea5aa656ff4349f4d3e1fea1447d26986762ae1", "patch": "@@ -10,6 +10,8 @@\n \n // Test range syntax.\n \n+#![feature(slicing_syntax)]\n+\n fn foo() -> int { 42 }\n \n pub fn main() {"}]}