{"sha": "fb4e3b62e05555815b7e2b55383b853c472c3712", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNGUzYjYyZTA1NTU1ODE1YjdlMmI1NTM4M2I4NTNjNDcyYzM3MTI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-24T11:07:27Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-05-27T15:28:35Z"}, "message": "Add fields to Slice", "tree": {"sha": "0271fd7d48714f03712f072e48de72ac0b6d2c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0271fd7d48714f03712f072e48de72ac0b6d2c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb4e3b62e05555815b7e2b55383b853c472c3712", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4e3b62e05555815b7e2b55383b853c472c3712", "html_url": "https://github.com/rust-lang/rust/commit/fb4e3b62e05555815b7e2b55383b853c472c3712", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb4e3b62e05555815b7e2b55383b853c472c3712/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b6586b989053b98f098928f79e95f3e30b3899c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6586b989053b98f098928f79e95f3e30b3899c", "html_url": "https://github.com/rust-lang/rust/commit/0b6586b989053b98f098928f79e95f3e30b3899c"}], "stats": {"total": 46, "additions": 19, "deletions": 27}, "files": [{"sha": "775c7c234fda1bd87fe777df9da14b114fa167ef", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e3b62e05555815b7e2b55383b853c472c3712/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e3b62e05555815b7e2b55383b853c472c3712/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fb4e3b62e05555815b7e2b55383b853c472c3712", "patch": "@@ -43,7 +43,6 @@ use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::marker::PhantomData;\n use std::ops::Deref;\n use rustc_data_structures::sync::Lrc;\n use std::slice;\n@@ -592,20 +591,13 @@ extern {\n /// A wrapper for slices with the additional invariant\n /// that the slice is interned and no other slice with\n /// the same contents can exist in the same context.\n-/// This means we can use pointer + length for both\n+/// This means we can use pointer for both\n /// equality comparisons and hashing.\n-pub struct Slice<T>(PhantomData<T>, OpaqueSliceContents);\n-\n-impl<T> Slice<T> {\n-    /// Returns the offset of the array\n-    #[inline(always)]\n-    fn offset() -> usize {\n-        // Align up the size of the len (usize) field\n-        let align = mem::align_of::<T>();\n-        let align_mask = align - 1;\n-        let offset = mem::size_of::<usize>();\n-        (offset + align_mask) & !align_mask\n-    }\n+#[repr(C)]\n+pub struct Slice<T> {\n+    len: usize,\n+    data: [T; 0],\n+    opaque: OpaqueSliceContents,\n }\n \n impl<T: Copy> Slice<T> {\n@@ -615,24 +607,27 @@ impl<T: Copy> Slice<T> {\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n \n-        let offset = Slice::<T>::offset();\n+        // Align up the size of the len (usize) field\n+        let align = mem::align_of::<T>();\n+        let align_mask = align - 1;\n+        let offset = mem::size_of::<usize>();\n+        let offset = (offset + align_mask) & !align_mask;\n+\n         let size = offset + slice.len() * mem::size_of::<T>();\n \n-        let mem: *mut u8 = arena.alloc_raw(\n+        let mem = arena.alloc_raw(\n             size,\n-            cmp::max(mem::align_of::<T>(), mem::align_of::<usize>())).as_mut_ptr();\n-\n+            cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n+            let result = &mut *(mem.as_mut_ptr() as *mut Slice<T>);\n             // Write the length\n-            *(mem as *mut usize) = slice.len();\n+            result.len = slice.len();\n \n             // Write the elements\n-            let arena_slice = slice::from_raw_parts_mut(\n-                mem.offset(offset as isize) as *mut T,\n-                slice.len());\n+            let arena_slice = slice::from_raw_parts_mut(result.data.as_mut_ptr(), result.len);\n             arena_slice.copy_from_slice(slice);\n \n-            &*(mem as *const Slice<T>)\n+            result\n         }\n     }\n }\n@@ -686,10 +681,7 @@ impl<T> Deref for Slice<T> {\n     #[inline(always)]\n     fn deref(&self) -> &[T] {\n         unsafe {\n-            let raw = self as *const _ as *const u8;\n-            let len = *(raw as *const usize);\n-            let slice = raw.offset(Slice::<T>::offset() as isize);\n-            slice::from_raw_parts(slice as *const T, len)\n+            slice::from_raw_parts(self.data.as_ptr(), self.len)\n         }\n     }\n }"}]}