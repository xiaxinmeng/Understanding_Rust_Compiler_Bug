{"sha": "fd6f62f9c71722282eb71ae040290e1addab8282", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNmY2MmY5YzcxNzIyMjgyZWI3MWFlMDQwMjkwZTFhZGRhYjgyODI=", "commit": {"author": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-11-04T18:11:37Z"}, "committer": {"name": "Gareth Daniel Smith", "email": "garethdanielsmith@gmail.com", "date": "2012-11-04T18:11:37Z"}, "message": "Add more doc-comments for Reader, ReaderUtil, Writer and WriterUtil (loosely associated with issue #2004).", "tree": {"sha": "f3b1dc8d6f722b30024586391cea2ee4669aeb17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3b1dc8d6f722b30024586391cea2ee4669aeb17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd6f62f9c71722282eb71ae040290e1addab8282", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6f62f9c71722282eb71ae040290e1addab8282", "html_url": "https://github.com/rust-lang/rust/commit/fd6f62f9c71722282eb71ae040290e1addab8282", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd6f62f9c71722282eb71ae040290e1addab8282/comments", "author": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dretch", "id": 1428731, "node_id": "MDQ6VXNlcjE0Mjg3MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1428731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dretch", "html_url": "https://github.com/Dretch", "followers_url": "https://api.github.com/users/Dretch/followers", "following_url": "https://api.github.com/users/Dretch/following{/other_user}", "gists_url": "https://api.github.com/users/Dretch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dretch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dretch/subscriptions", "organizations_url": "https://api.github.com/users/Dretch/orgs", "repos_url": "https://api.github.com/users/Dretch/repos", "events_url": "https://api.github.com/users/Dretch/events{/privacy}", "received_events_url": "https://api.github.com/users/Dretch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aba903de7000d7b2b915ba5772b4d82fc6b9f34", "html_url": "https://github.com/rust-lang/rust/commit/0aba903de7000d7b2b915ba5772b4d82fc6b9f34"}], "stats": {"total": 141, "additions": 115, "deletions": 26}, "files": [{"sha": "4629878b4b7eae76ab81f65b9d1c756a1396ecc8", "filename": "src/libcore/io.rs", "status": "modified", "additions": 115, "deletions": 26, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/fd6f62f9c71722282eb71ae040290e1addab8282/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd6f62f9c71722282eb71ae040290e1addab8282/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=fd6f62f9c71722282eb71ae040290e1addab8282", "patch": "@@ -32,96 +32,126 @@ extern mod rustrt {\n pub enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n \n \n-// The raw underlying reader trait. All readers must implement this.\n+/// The raw underlying reader trait. All readers must implement this.\n pub trait Reader {\n     // FIXME (#2004): Seekable really should be orthogonal.\n \n+    /// Read up to len bytes (or EOF) and put them into bytes (which\n+    /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n     fn read(bytes: &[mut u8], len: uint) -> uint;\n+\n+    /// Read a single byte, returning a negative value for EOF or read error.\n     fn read_byte() -> int;\n+\n+    /// Behaves like the libc function ungetc.\n     fn unread_byte(int);\n+\n+    /// Return whether the stream is currently at EOF position.\n     fn eof() -> bool;\n-    fn seek(int, SeekStyle);\n+\n+    /// Move the current position within the stream. The second parameter\n+    /// determines the position that the first parameter is relative to.\n+    fn seek(position: int, style: SeekStyle);\n+\n+    /// Return the current position within the stream.\n     fn tell() -> uint;\n }\n \n-// Generic utility functions defined on readers\n+/// Generic utility functions defined on readers.\n pub trait ReaderUtil {\n+\n+    /// Read len bytes into a new vec.\n     fn read_bytes(len: uint) -> ~[u8];\n+\n+    /// Read up until the first '\\n' char (which is not returned), or EOF.\n     fn read_line() -> ~str;\n \n+    /// Read n utf-8 encoded chars.\n     fn read_chars(n: uint) -> ~[char];\n+\n+    /// Read a single utf-8 encoded char.\n     fn read_char() -> char;\n+\n+    /// Read up until the first null byte (which is not returned), or EOF.\n     fn read_c_str() -> ~str;\n+\n+    /// Read all the data remaining in the stream in one go.\n     fn read_whole_stream() -> ~[u8];\n+\n+    /// Iterate over every byte until the iterator breaks or EOF.\n     fn each_byte(it: fn(int) -> bool);\n+\n+    /// Iterate over every char until the iterator breaks or EOF.\n     fn each_char(it: fn(char) -> bool);\n-    fn each_line(it: fn((&str)) -> bool);\n \n-    /// read n (between 1 and 8) little-endian unsigned integer bytes\n+    /// Iterate over every line until the iterator breaks or EOF.\n+    fn each_line(it: fn(&str) -> bool);\n+\n+    /// Read n (between 1 and 8) little-endian unsigned integer bytes.\n     fn read_le_uint_n(nbytes: uint) -> u64;\n \n-    /// read n (between 1 and 8) little-endian signed integer bytes\n+    /// Read n (between 1 and 8) little-endian signed integer bytes.\n     fn read_le_int_n(nbytes: uint) -> i64;\n \n-    /// read n (between 1 and 8) big-endian unsigned integer bytes\n+    /// Read n (between 1 and 8) big-endian unsigned integer bytes.\n     fn read_be_uint_n(nbytes: uint) -> u64;\n \n-    /// read n (between 1 and 8) big-endian signed integer bytes\n+    /// Read n (between 1 and 8) big-endian signed integer bytes.\n     fn read_be_int_n(nbytes: uint) -> i64;\n \n-    /// read a little-endian uint (number of bytes read depends on system)\n+    /// Read a little-endian uint (number of bytes depends on system).\n     fn read_le_uint() -> uint;\n \n-    /// read a little-endian int (number of bytes read depends on system)\n+    /// Read a little-endian int (number of bytes depends on system).\n     fn read_le_int() -> int;\n \n-    /// read a big-endian uint (number of bytes read depends on system)\n+    /// Read a big-endian uint (number of bytes depends on system).\n     fn read_be_uint() -> uint;\n \n-    /// read a big-endian int (number of bytes read depends on system)\n+    /// Read a big-endian int (number of bytes depends on system).\n     fn read_be_int() -> int;\n \n-    /// read a big-endian u64 (8 bytes)\n+    /// Read a big-endian u64 (8 bytes).\n     fn read_be_u64() -> u64;\n \n-    /// read a big-endian u32 (4 bytes)\n+    /// Read a big-endian u32 (4 bytes).\n     fn read_be_u32() -> u32;\n \n-    /// read a big-endian u16 (2 bytes)\n+    /// Read a big-endian u16 (2 bytes).\n     fn read_be_u16() -> u16;\n \n-    /// read a big-endian i64 (8 bytes)\n+    /// Read a big-endian i64 (8 bytes).\n     fn read_be_i64() -> i64;\n \n-    /// read a big-endian i32 (4 bytes)\n+    /// Read a big-endian i32 (4 bytes).\n     fn read_be_i32() -> i32;\n \n-    /// read a big-endian i16 (2 bytes)\n+    /// Read a big-endian i16 (2 bytes).\n     fn read_be_i16() -> i16;\n \n-    /// read a little-endian u64 (8 bytes)\n+    /// Read a little-endian u64 (8 bytes).\n     fn read_le_u64() -> u64;\n \n-    /// read a little-endian u32 (4 bytes)\n+    /// Read a little-endian u32 (4 bytes).\n     fn read_le_u32() -> u32;\n \n-    /// read a little-endian u16 (2 bytes)\n+    /// Read a little-endian u16 (2 bytes).\n     fn read_le_u16() -> u16;\n \n-    /// read a litle-endian i64 (8 bytes)\n+    /// Read a litle-endian i64 (8 bytes).\n     fn read_le_i64() -> i64;\n \n-    /// read a litle-endian i32 (4 bytes)\n+    /// Read a litle-endian i32 (4 bytes).\n     fn read_le_i32() -> i32;\n \n-    /// read a litle-endian i16 (2 bytes)\n+    /// Read a litle-endian i16 (2 bytes).\n     fn read_le_i16() -> i16;\n \n-    /// read a u8 (1 byte)\n+    /// Read a u8 (1 byte).\n     fn read_u8() -> u8;\n \n-    /// read a i8 (1 byte)\n+    /// Read a i8 (1 byte).\n     fn read_i8() -> i8;\n }\n \n@@ -504,11 +534,23 @@ pub impl WriterType : Eq {\n \n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n+/// The raw underlying writer trait. All writers must implement this.\n pub trait Writer {\n+\n+    /// Write all of the given bytes.\n     fn write(v: &[const u8]);\n+\n+    /// Move the current position within the stream. The second parameter\n+    /// determines the position that the first parameter is relative to.\n     fn seek(int, SeekStyle);\n+\n+    /// Return the current position within the stream.\n     fn tell() -> uint;\n+\n+    /// Flush the output buffer for this stream (if there is one).\n     fn flush() -> int;\n+\n+    /// Determine if this Writer is writing to a file or not.\n     fn get_type() -> WriterType;\n }\n \n@@ -712,29 +754,76 @@ pub fn u64_from_be_bytes(data: &[const u8],\n \n // FIXME: #3048 combine trait+impl (or just move these to\n // default methods on writer)\n+/// Generic utility functions defined on writers.\n pub trait WriterUtil {\n+\n+    /// Write a single utf-8 encoded char.\n     fn write_char(ch: char);\n+\n+    /// Write every char in the given str, encoded as utf-8.\n     fn write_str(s: &str);\n+\n+    /// Write the given str, as utf-8, followed by '\\n'.\n     fn write_line(s: &str);\n+\n+    /// Write the result of passing n through `int::to_str_bytes`.\n     fn write_int(n: int);\n+\n+    /// Write the result of passing n through `uint::to_str_bytes`.\n     fn write_uint(n: uint);\n+\n+    /// Write a little-endian uint (number of bytes depends on system).\n     fn write_le_uint(n: uint);\n+\n+    /// Write a little-endian int (number of bytes depends on system).\n     fn write_le_int(n: int);\n+\n+    /// Write a big-endian uint (number of bytes depends on system).\n     fn write_be_uint(n: uint);\n+\n+    /// Write a big-endian int (number of bytes depends on system).\n     fn write_be_int(n: int);\n+\n+    /// Write a big-endian u64 (8 bytes).\n     fn write_be_u64(n: u64);\n+\n+    /// Write a big-endian u32 (4 bytes).\n     fn write_be_u32(n: u32);\n+\n+    /// Write a big-endian u16 (2 bytes).\n     fn write_be_u16(n: u16);\n+\n+    /// Write a big-endian i64 (8 bytes).\n     fn write_be_i64(n: i64);\n+\n+    /// Write a big-endian i32 (4 bytes).\n     fn write_be_i32(n: i32);\n+\n+    /// Write a big-endian i16 (2 bytes).\n     fn write_be_i16(n: i16);\n+\n+    /// Write a little-endian u64 (8 bytes).\n     fn write_le_u64(n: u64);\n+\n+    /// Write a little-endian u32 (4 bytes).\n     fn write_le_u32(n: u32);\n+\n+    /// Write a little-endian u16 (2 bytes).\n     fn write_le_u16(n: u16);\n+\n+    /// Write a little-endian i64 (8 bytes).\n     fn write_le_i64(n: i64);\n+\n+    /// Write a little-endian i32 (4 bytes).\n     fn write_le_i32(n: i32);\n+\n+    /// Write a little-endian i16 (2 bytes).\n     fn write_le_i16(n: i16);\n+\n+    /// Write a u8 (1 byte).\n     fn write_u8(n: u8);\n+\n+    /// Write a i8 (1 byte).\n     fn write_i8(n: i8);\n }\n "}]}