{"sha": "5a292309c55639a12d10b3c37b9f800d8b802b6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMjkyMzA5YzU1NjM5YTEyZDEwYjNjMzdiOWY4MDBkOGI4MDJiNmQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-10T14:01:08Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2020-03-10T17:06:01Z"}, "message": "Add and fix tests", "tree": {"sha": "29de25283ac4cc391b2364969b3b9ead1d812993", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29de25283ac4cc391b2364969b3b9ead1d812993"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a292309c55639a12d10b3c37b9f800d8b802b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a292309c55639a12d10b3c37b9f800d8b802b6d", "html_url": "https://github.com/rust-lang/rust/commit/5a292309c55639a12d10b3c37b9f800d8b802b6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a292309c55639a12d10b3c37b9f800d8b802b6d/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e00a1e0b79e2b2c0c20a96e5341e3a35f46f99b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e00a1e0b79e2b2c0c20a96e5341e3a35f46f99b7", "html_url": "https://github.com/rust-lang/rust/commit/e00a1e0b79e2b2c0c20a96e5341e3a35f46f99b7"}], "stats": {"total": 201, "additions": 141, "deletions": 60}, "files": [{"sha": "298ec22ff1d032d849c240d6eb30feb53b256200", "filename": "crates/ra_hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 121, "deletions": 60, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/5a292309c55639a12d10b3c37b9f800d8b802b6d/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a292309c55639a12d10b3c37b9f800d8b802b6d/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=5a292309c55639a12d10b3c37b9f800d8b802b6d", "patch": "@@ -90,15 +90,15 @@ register_builtin! {\n     (line, Line) => line_expand,\n     (stringify, Stringify) => stringify_expand,\n     (format_args, FormatArgs) => format_args_expand,\n-    (env, Env) => env_expand,\n-    (option_env, OptionEnv) => option_env_expand,\n     // format_args_nl only differs in that it adds a newline in the end,\n     // so we use the same stub expansion for now\n     (format_args_nl, FormatArgsNl) => format_args_expand,\n \n     EAGER:\n     (concat, Concat) => concat_expand,\n-    (include, Include) => include_expand\n+    (include, Include) => include_expand,\n+    (env, Env) => env_expand,\n+    (option_env, OptionEnv) => option_env_expand\n }\n \n fn line_expand(\n@@ -137,31 +137,6 @@ fn stringify_expand(\n     Ok(expanded)\n }\n \n-fn env_expand(\n-    _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n-    _tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n-    // dummy implementation for type-checking purposes\n-    // we cannot use an empty string here, because for\n-    // `include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"))` will become\n-    // `include!(\"foo.rs\"), which maybe infinite loop\n-    let expanded = quote! { \"__RA_UNIMPLEMENTATED__\" };\n-\n-    Ok(expanded)\n-}\n-\n-fn option_env_expand(\n-    _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n-    _tt: &tt::Subtree,\n-) -> Result<tt::Subtree, mbe::ExpandError> {\n-    // dummy implementation for type-checking purposes\n-    let expanded = quote! { std::option::Option::None::<&str> };\n-\n-    Ok(expanded)\n-}\n-\n fn column_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n@@ -278,30 +253,36 @@ fn concat_expand(\n \n fn relative_file(db: &dyn AstDatabase, call_id: MacroCallId, path: &str) -> Option<FileId> {\n     let call_site = call_id.as_file().original_file(db);\n-    let path = RelativePath::new(&path);\n \n-    let res = db.resolve_relative_path(call_site, &path)?;\n-    // Prevent include itself\n-    if res == call_site {\n-        return None;\n+    // Handle trivial case\n+    if let Some(res) = db.resolve_relative_path(call_site, &RelativePath::new(&path)) {\n+        // Prevent include itself\n+        return if res == call_site { None } else { Some(res) };\n     }\n-    Some(res)\n+\n+    // Extern paths ?\n+    let krate = db.relevant_crates(call_site).get(0)?.clone();\n+    let (extern_source_id, relative_file) = db.crate_graph()[krate].env.extern_path(path)?;\n+\n+    db.resolve_extern_path(extern_source_id, &relative_file)\n }\n \n-fn include_expand(\n-    db: &dyn AstDatabase,\n-    arg_id: EagerMacroId,\n-    tt: &tt::Subtree,\n-) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n-    let path = tt\n-        .token_trees\n+fn parse_string(tt: &tt::Subtree) -> Result<String, mbe::ExpandError> {\n+    tt.token_trees\n         .get(0)\n         .and_then(|tt| match tt {\n             tt::TokenTree::Leaf(tt::Leaf::Literal(it)) => unquote_str(&it),\n             _ => None,\n         })\n-        .ok_or_else(|| mbe::ExpandError::ConversionError)?;\n+        .ok_or_else(|| mbe::ExpandError::ConversionError)\n+}\n \n+fn include_expand(\n+    db: &dyn AstDatabase,\n+    arg_id: EagerMacroId,\n+    tt: &tt::Subtree,\n+) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+    let path = parse_string(tt)?;\n     let file_id =\n         relative_file(db, arg_id.into(), &path).ok_or_else(|| mbe::ExpandError::ConversionError)?;\n \n@@ -314,12 +295,58 @@ fn include_expand(\n     Ok((res, FragmentKind::Items))\n }\n \n+fn get_env_inner(db: &dyn AstDatabase, arg_id: EagerMacroId, key: &str) -> Option<String> {\n+    let call_id: MacroCallId = arg_id.into();\n+    let original_file = call_id.as_file().original_file(db);\n+\n+    let krate = db.relevant_crates(original_file).get(0)?.clone();\n+    db.crate_graph()[krate].env.get(key)\n+}\n+\n+fn env_expand(\n+    db: &dyn AstDatabase,\n+    arg_id: EagerMacroId,\n+    tt: &tt::Subtree,\n+) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+    let key = parse_string(tt)?;\n+\n+    // FIXME:\n+    // If the environment variable is not defined int rustc, then a compilation error will be emitted.\n+    // We might do the same if we fully support all other stuffs.\n+    // But for now on, we should return some dummy string for better type infer purpose.\n+    // However, we cannot use an empty string here, because for\n+    // `include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"))` will become\n+    // `include!(\"foo.rs\"), which might go to infinite loop\n+    let s = get_env_inner(db, arg_id, &key).unwrap_or(\"__RA_UNIMPLEMENTATED__\".to_string());\n+    let expanded = quote! { #s };\n+\n+    Ok((expanded, FragmentKind::Expr))\n+}\n+\n+fn option_env_expand(\n+    db: &dyn AstDatabase,\n+    arg_id: EagerMacroId,\n+    tt: &tt::Subtree,\n+) -> Result<(tt::Subtree, FragmentKind), mbe::ExpandError> {\n+    let key = parse_string(tt)?;\n+    let expanded = match get_env_inner(db, arg_id, &key) {\n+        None => quote! { std::option::Option::None::<&str> },\n+        Some(s) => quote! { std::option::Some(#s) },\n+    };\n+\n+    Ok((expanded, FragmentKind::Expr))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::{name::AsName, test_db::TestDB, AstNode, MacroCallId, MacroCallKind, MacroCallLoc};\n+    use crate::{\n+        name::AsName, test_db::TestDB, AstNode, EagerCallLoc, MacroCallId, MacroCallKind,\n+        MacroCallLoc,\n+    };\n     use ra_db::{fixture::WithFixture, SourceDatabase};\n     use ra_syntax::ast::NameOwner;\n+    use std::sync::Arc;\n \n     fn expand_builtin_macro(ra_fixture: &str) -> String {\n         let (db, file_id) = TestDB::with_single_file(&ra_fixture);\n@@ -330,27 +357,61 @@ mod tests {\n         let ast_id_map = db.ast_id_map(file_id.into());\n \n         let expander = find_by_name(&macro_calls[0].name().unwrap().as_name()).unwrap();\n-        let expander = expander.left().unwrap();\n \n-        // the first one should be a macro_rules\n-        let def = MacroDefId {\n-            krate: Some(CrateId(0)),\n-            ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n-            kind: MacroDefKind::BuiltIn(expander),\n-        };\n+        let file_id = match expander {\n+            Either::Left(expander) => {\n+                // the first one should be a macro_rules\n+                let def = MacroDefId {\n+                    krate: Some(CrateId(0)),\n+                    ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n+                    kind: MacroDefKind::BuiltIn(expander),\n+                };\n \n-        let loc = MacroCallLoc {\n-            def,\n-            kind: MacroCallKind::FnLike(AstId::new(\n-                file_id.into(),\n-                ast_id_map.ast_id(&macro_calls[1]),\n-            )),\n-        };\n+                let loc = MacroCallLoc {\n+                    def,\n+                    kind: MacroCallKind::FnLike(AstId::new(\n+                        file_id.into(),\n+                        ast_id_map.ast_id(&macro_calls[1]),\n+                    )),\n+                };\n+\n+                let id: MacroCallId = db.intern_macro(loc).into();\n+                id.as_file()\n+            }\n+            Either::Right(expander) => {\n+                // the first one should be a macro_rules\n+                let def = MacroDefId {\n+                    krate: Some(CrateId(0)),\n+                    ast_id: Some(AstId::new(file_id.into(), ast_id_map.ast_id(&macro_calls[0]))),\n+                    kind: MacroDefKind::BuiltInEager(expander),\n+                };\n \n-        let id: MacroCallId = db.intern_macro(loc).into();\n-        let parsed = db.parse_or_expand(id.as_file()).unwrap();\n+                let args = macro_calls[1].token_tree().unwrap();\n+                let parsed_args = mbe::ast_to_token_tree(&args).unwrap().0;\n+\n+                let arg_id = db.intern_eager_expansion({\n+                    EagerCallLoc {\n+                        def,\n+                        fragment: FragmentKind::Expr,\n+                        subtree: Arc::new(parsed_args.clone()),\n+                        file_id: file_id.into(),\n+                    }\n+                });\n+\n+                let (subtree, fragment) = expander.expand(&db, arg_id, &parsed_args).unwrap();\n+                let eager = EagerCallLoc {\n+                    def,\n+                    fragment,\n+                    subtree: Arc::new(subtree),\n+                    file_id: file_id.into(),\n+                };\n+\n+                let id: MacroCallId = db.intern_eager_expansion(eager.into()).into();\n+                id.as_file()\n+            }\n+        };\n \n-        parsed.text().to_string()\n+        db.parse_or_expand(file_id).unwrap().to_string()\n     }\n \n     #[test]"}, {"sha": "32457bbf7a1ff95c7510bcceb0b34d96f7dd382f", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a292309c55639a12d10b3c37b9f800d8b802b6d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a292309c55639a12d10b3c37b9f800d8b802b6d/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=5a292309c55639a12d10b3c37b9f800d8b802b6d", "patch": "@@ -549,6 +549,26 @@ fn main() {\n     );\n }\n \n+#[test]\n+fn infer_builtin_macros_env() {\n+    assert_snapshot!(\n+        infer(r#\"\n+//- /main.rs env:foo=bar\n+#[rustc_builtin_macro]\n+macro_rules! env {() => {}}\n+\n+fn main() {\n+    let x = env!(\"foo\");\n+}\n+\"#),\n+        @r###\"\n+    ![0; 5) '\"bar\"': &str\n+    [88; 116) '{     ...o\"); }': ()\n+    [98; 99) 'x': &str\n+    \"###\n+    );\n+}\n+\n #[test]\n fn infer_derive_clone_simple() {\n     let (db, pos) = TestDB::with_position("}]}