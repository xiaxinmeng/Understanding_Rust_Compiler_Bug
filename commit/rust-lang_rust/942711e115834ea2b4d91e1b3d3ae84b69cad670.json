{"sha": "942711e115834ea2b4d91e1b3d3ae84b69cad670", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MjcxMWUxMTU4MzRlYTJiNGQ5MWUxYjNkM2FlODRiNjljYWQ2NzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-22T01:34:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-22T01:34:54Z"}, "message": "Auto merge of #43690 - scalexm:issue-28229, r=nikomatsakis\n\nGenerate builtin impls for `Clone`\n\nThis fixes a long-standing ICE and limitation where some builtin types implement `Copy` but not `Clone` (whereas `Clone` is a super trait of `Copy`).\n\nHowever, this PR has a few side-effects:\n* `Clone` is now marked as a lang item.\n* `[T; N]` is now `Clone` if `T: Clone` (currently, only if `T: Copy` and for `N <= 32`).\n* `fn foo<'a>() where &'a mut (): Clone { }` won't compile anymore because of how bounds for builtin traits are handled (e.g. same thing currently if you replace `Clone` by `Copy` in this example). Of course this function is unusable anyway, an error would pop as soon as it is called.\n\nHence, I'm wondering wether this PR would need an RFC...\nAlso, cc-ing @nikomatsakis, @arielb1.\n\nRelated issues: #28229, #24000.", "tree": {"sha": "bb91d32e15edc91af3c6a48d49e8fc89c1460dae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb91d32e15edc91af3c6a48d49e8fc89c1460dae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/942711e115834ea2b4d91e1b3d3ae84b69cad670", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/942711e115834ea2b4d91e1b3d3ae84b69cad670", "html_url": "https://github.com/rust-lang/rust/commit/942711e115834ea2b4d91e1b3d3ae84b69cad670", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/942711e115834ea2b4d91e1b3d3ae84b69cad670/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8df670b6a60f245d266dbd0b650a549b7b806bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/8df670b6a60f245d266dbd0b650a549b7b806bac", "html_url": "https://github.com/rust-lang/rust/commit/8df670b6a60f245d266dbd0b650a549b7b806bac"}, {"sha": "d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d", "html_url": "https://github.com/rust-lang/rust/commit/d58b40e16b9466ba4e049fe0dae8b8d08df1d44d"}], "stats": {"total": 642, "additions": 618, "deletions": 24}, "files": [{"sha": "4b7706bac300fe4b1a1ebd1316c01cbb7d75d7bc", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -124,6 +124,7 @@ macro_rules! array_impls {\n             }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             impl<T:Copy> Clone for [T; $N] {\n                 fn clone(&self) -> [T; $N] {\n                     *self"}, {"sha": "2dc51718b97b23e0e0a7a491dd091f340585efbb", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -88,6 +88,7 @@\n /// }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(not(stage0), lang = \"clone\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n     ///\n@@ -131,6 +132,7 @@ pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData\n pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<'a, T: ?Sized> Clone for &'a T {\n     /// Returns a shallow copy of the reference.\n     #[inline]\n@@ -140,6 +142,7 @@ impl<'a, T: ?Sized> Clone for &'a T {\n macro_rules! clone_impl {\n     ($t:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         impl Clone for $t {\n             /// Returns a deep copy of the value.\n             #[inline]"}, {"sha": "63e9373e936068cc2085e6f8750abfbdcf9159ec", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -876,6 +876,7 @@ pub fn eq<T: ?Sized>(a: *const T, b: *const T) -> bool {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<T: ?Sized> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n@@ -884,6 +885,7 @@ impl<T: ?Sized> Clone for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<T: ?Sized> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n@@ -895,6 +897,7 @@ impl<T: ?Sized> Clone for *mut T {\n macro_rules! fnptr_impls_safety_abi {\n     ($FnTy: ty, $($Arg: ident),*) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[cfg(stage0)]\n         impl<Ret, $($Arg),*> Clone for $FnTy {\n             #[inline]\n             fn clone(&self) -> Self {"}, {"sha": "555843dba418ecaeebb88d3c36015865edfb46fd", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -22,6 +22,7 @@ macro_rules! tuple_impls {\n     )+) => {\n         $(\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[cfg(stage0)]\n             impl<$($T:Clone),+> Clone for ($($T,)+) {\n                 fn clone(&self) -> ($($T,)+) {\n                     ($(self.$idx.clone(),)+)"}, {"sha": "5f51579945e33ea5e7e44338720d83f241862b71", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -663,6 +663,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::In\n                 def_id.hash_stable(hcx, hasher);\n                 t.hash_stable(hcx, hasher);\n             }\n+            ty::InstanceDef::CloneShim(def_id, t) => {\n+                def_id.hash_stable(hcx, hasher);\n+                t.hash_stable(hcx, hasher);\n+            }\n         }\n     }\n }"}, {"sha": "9ba4252b52e570c4665f93bf84de25a469dafb4a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -274,6 +274,7 @@ language_item_table! {\n     SizedTraitLangItem,              \"sized\",                   sized_trait;\n     UnsizeTraitLangItem,             \"unsize\",                  unsize_trait;\n     CopyTraitLangItem,               \"copy\",                    copy_trait;\n+    CloneTraitLangItem,              \"clone\",                   clone_trait;\n     SyncTraitLangItem,               \"sync\",                    sync_trait;\n     FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n "}, {"sha": "46bdb1344b2fe3fe920192e135b40e49370ec27d", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -1296,6 +1296,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n          } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n              self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n          } else {\n+            if self.tcx().lang_items.clone_trait() == Some(def_id) {\n+                // Same builtin conditions as `Copy`, i.e. every type which has builtin support\n+                // for `Copy` also has builtin support for `Clone`, + tuples and arrays of `Clone`\n+                // types have builtin support for `Clone`.\n+                let clone_conditions = self.copy_conditions(obligation);\n+                self.assemble_builtin_bound_candidates(clone_conditions, &mut candidates)?;\n+            }\n+\n              self.assemble_closure_candidates(obligation, &mut candidates)?;\n              self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n              self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n@@ -2164,8 +2172,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         match candidate {\n             BuiltinCandidate { has_nested } => {\n-                Ok(VtableBuiltin(\n-                    self.confirm_builtin_candidate(obligation, has_nested)))\n+                let data = self.confirm_builtin_candidate(obligation, has_nested);\n+                Ok(VtableBuiltin(data))\n             }\n \n             ParamCandidate(param) => {\n@@ -2271,6 +2279,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 _ if Some(trait_def) == self.tcx().lang_items.copy_trait() => {\n                     self.copy_conditions(obligation)\n                 }\n+                _ if Some(trait_def) == self.tcx().lang_items.clone_trait() => {\n+                    self.copy_conditions(obligation)\n+                }\n                 _ => bug!(\"unexpected builtin trait {:?}\", trait_def)\n             };\n             let nested = match conditions {\n@@ -2291,6 +2302,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         debug!(\"confirm_builtin_candidate: obligations={:?}\",\n                obligations);\n+\n         VtableBuiltinData { nested: obligations }\n     }\n \n@@ -2598,8 +2610,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn confirm_builtin_unsize_candidate(&mut self,\n                                         obligation: &TraitObligation<'tcx>,)\n-                                        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>,\n-                                                  SelectionError<'tcx>> {\n+        -> Result<VtableBuiltinData<PredicateObligation<'tcx>>, SelectionError<'tcx>>\n+    {\n         let tcx = self.tcx();\n \n         // assemble_candidates_for_unsizing should ensure there are no late bound"}, {"sha": "d913c76ec3c09c096cde8e9118692be242bbf6c3", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                 })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n                 vtable_base,"}, {"sha": "7d543f689c24d179283eaa80904b2906b4070bab", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -24,15 +24,22 @@ pub struct Instance<'tcx> {\n pub enum InstanceDef<'tcx> {\n     Item(DefId),\n     Intrinsic(DefId),\n-    // <fn() as FnTrait>::call_*\n-    // def-id is FnTrait::call_*\n+\n+    /// <fn() as FnTrait>::call_*\n+    /// def-id is FnTrait::call_*\n     FnPtrShim(DefId, Ty<'tcx>),\n-    // <Trait as Trait>::fn\n+\n+    /// <Trait as Trait>::fn\n     Virtual(DefId, usize),\n-    // <[mut closure] as FnOnce>::call_once\n+\n+    /// <[mut closure] as FnOnce>::call_once\n     ClosureOnceShim { call_once: DefId },\n-    // drop_in_place::<T>; None for empty drop glue.\n+\n+    /// drop_in_place::<T>; None for empty drop glue.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n+\n+    /// Builtin method implementation, e.g. `Clone::clone`.\n+    CloneShim(DefId, Ty<'tcx>),\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -43,9 +50,9 @@ impl<'tcx> InstanceDef<'tcx> {\n             InstanceDef::FnPtrShim(def_id, _) |\n             InstanceDef::Virtual(def_id, _) |\n             InstanceDef::Intrinsic(def_id, ) |\n-            InstanceDef::ClosureOnceShim { call_once: def_id }\n-                => def_id,\n-            InstanceDef::DropGlue(def_id, _) => def_id\n+            InstanceDef::ClosureOnceShim { call_once: def_id } |\n+            InstanceDef::DropGlue(def_id, _) |\n+            InstanceDef::CloneShim(def_id, _) => def_id\n         }\n     }\n \n@@ -80,6 +87,9 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::DropGlue(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n             }\n+            InstanceDef::CloneShim(_, ty) => {\n+                write!(f, \" - shim({:?})\", ty)\n+            }\n         }\n     }\n }"}, {"sha": "f9bbcc1bbe086cb1a22dae090e12ec224dd858de", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -2232,7 +2232,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::InstanceDef::FnPtrShim(..) |\n             ty::InstanceDef::Virtual(..) |\n             ty::InstanceDef::ClosureOnceShim { .. } |\n-            ty::InstanceDef::DropGlue(..) => {\n+            ty::InstanceDef::DropGlue(..) |\n+            ty::InstanceDef::CloneShim(..) => {\n                 self.mir_shims(instance)\n             }\n         }"}, {"sha": "6bee1ceff89fbcdfc3be88bb5534887aa4c3937f", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 384, "deletions": 4, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -17,6 +17,7 @@ use rustc::mir::transform::MirSource;\n use rustc::ty::{self, Ty};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::ty::maps::Providers;\n+use rustc_const_math::{ConstInt, ConstUsize};\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n@@ -98,14 +99,25 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         ty::InstanceDef::DropGlue(def_id, ty) => {\n             build_drop_shim(tcx, def_id, ty)\n         }\n+        ty::InstanceDef::CloneShim(def_id, ty) => {\n+            let name = tcx.item_name(def_id).as_str();\n+            if name == \"clone\" {\n+                build_clone_shim(tcx, def_id, ty)\n+            } else if name == \"clone_from\" {\n+                debug!(\"make_shim({:?}: using default trait implementation\", instance);\n+                return tcx.optimized_mir(def_id);\n+            } else {\n+                bug!(\"builtin clone shim {:?} not supported\", instance)\n+            }\n+        }\n         ty::InstanceDef::Intrinsic(_) => {\n             bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n         }\n     };\n-        debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n-        no_landing_pads::no_landing_pads(tcx, &mut result);\n-        simplify::simplify_cfg(&mut result);\n-        add_call_guards::CriticalCallEdges.add_call_guards(&mut result);\n+    debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n+    no_landing_pads::no_landing_pads(tcx, &mut result);\n+    simplify::simplify_cfg(&mut result);\n+    add_call_guards::CriticalCallEdges.add_call_guards(&mut result);\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n     tcx.alloc_mir(result)\n@@ -259,6 +271,374 @@ impl<'a, 'tcx> DropElaborator<'a, 'tcx> for DropShimElaborator<'a, 'tcx> {\n     }\n }\n \n+/// Build a `Clone::clone` shim for `self_ty`. Here, `def_id` is `Clone::clone`.\n+fn build_clone_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+                              def_id: DefId,\n+                              self_ty: ty::Ty<'tcx>)\n+                              -> Mir<'tcx>\n+{\n+    debug!(\"build_clone_shim(def_id={:?})\", def_id);\n+\n+    let mut builder = CloneShimBuilder::new(tcx, def_id);\n+    let is_copy = !self_ty.moves_by_default(tcx, tcx.param_env(def_id), builder.span);\n+\n+    match self_ty.sty {\n+        _ if is_copy => builder.copy_shim(),\n+        ty::TyArray(ty, len) => builder.array_shim(ty, len),\n+        ty::TyTuple(tys, _) => builder.tuple_shim(tys),\n+        _ => {\n+            bug!(\"clone shim for `{:?}` which is not `Copy` and is not an aggregate\", self_ty);\n+        }\n+    };\n+\n+    builder.into_mir()\n+}\n+\n+struct CloneShimBuilder<'a, 'tcx: 'a> {\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n+    span: Span,\n+    sig: ty::FnSig<'tcx>,\n+}\n+\n+impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n+    fn new(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Self {\n+        let sig = tcx.fn_sig(def_id);\n+        let sig = tcx.erase_late_bound_regions(&sig);\n+        let span = tcx.def_span(def_id);\n+\n+        CloneShimBuilder {\n+            tcx,\n+            def_id,\n+            local_decls: local_decls_for_sig(&sig, span),\n+            blocks: IndexVec::new(),\n+            span,\n+            sig,\n+        }\n+    }\n+\n+    fn into_mir(self) -> Mir<'tcx> {\n+        Mir::new(\n+            self.blocks,\n+            IndexVec::from_elem_n(\n+                VisibilityScopeData { span: self.span, parent_scope: None }, 1\n+            ),\n+            IndexVec::new(),\n+            self.sig.output(),\n+            self.local_decls,\n+            self.sig.inputs().len(),\n+            vec![],\n+            self.span\n+        )\n+    }\n+\n+    fn source_info(&self) -> SourceInfo {\n+        SourceInfo { span: self.span, scope: ARGUMENT_VISIBILITY_SCOPE }\n+    }\n+\n+    fn block(\n+        &mut self,\n+        statements: Vec<Statement<'tcx>>,\n+        kind: TerminatorKind<'tcx>,\n+        is_cleanup: bool\n+    ) -> BasicBlock {\n+        let source_info = self.source_info();\n+        self.blocks.push(BasicBlockData {\n+            statements,\n+            terminator: Some(Terminator { source_info, kind }),\n+            is_cleanup,\n+        })\n+    }\n+\n+    fn make_statement(&self, kind: StatementKind<'tcx>) -> Statement<'tcx> {\n+        Statement {\n+            source_info: self.source_info(),\n+            kind,\n+        }\n+    }\n+\n+    fn copy_shim(&mut self) {\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Use(Operand::Consume(rcvr))\n+            )\n+        );\n+        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+    }\n+\n+    fn make_lvalue(&mut self, mutability: Mutability, ty: ty::Ty<'tcx>) -> Lvalue<'tcx> {\n+        let span = self.span;\n+        Lvalue::Local(\n+            self.local_decls.push(temp_decl(mutability, ty, span))\n+        )\n+    }\n+\n+    fn make_clone_call(\n+        &mut self,\n+        ty: ty::Ty<'tcx>,\n+        rcvr_field: Lvalue<'tcx>,\n+        next: BasicBlock,\n+        cleanup: BasicBlock\n+    ) -> Lvalue<'tcx> {\n+        let tcx = self.tcx;\n+\n+        let substs = Substs::for_item(\n+            tcx,\n+            self.def_id,\n+            |_, _| tcx.types.re_erased,\n+            |_, _| ty\n+        );\n+\n+        // `func == Clone::clone(&ty) -> ty`\n+        let func = Operand::Constant(box Constant {\n+            span: self.span,\n+            ty: tcx.mk_fn_def(self.def_id, substs),\n+            literal: Literal::Value {\n+                value: ConstVal::Function(self.def_id, substs),\n+            },\n+        });\n+\n+        let ref_loc = self.make_lvalue(\n+            Mutability::Not,\n+            tcx.mk_ref(tcx.types.re_erased, ty::TypeAndMut {\n+                ty,\n+                mutbl: hir::Mutability::MutImmutable,\n+            })\n+        );\n+\n+        let loc = self.make_lvalue(Mutability::Not, ty);\n+\n+        // `let ref_loc: &ty = &rcvr_field;`\n+        let statement = self.make_statement(\n+            StatementKind::Assign(\n+                ref_loc.clone(),\n+                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Shared, rcvr_field)\n+            )\n+        );\n+\n+        // `let loc = Clone::clone(ref_loc);`\n+        self.block(vec![statement], TerminatorKind::Call {\n+            func,\n+            args: vec![Operand::Consume(ref_loc)],\n+            destination: Some((loc.clone(), next)),\n+            cleanup: Some(cleanup),\n+        }, false);\n+\n+        loc\n+    }\n+\n+    fn loop_header(\n+        &mut self,\n+        beg: Lvalue<'tcx>,\n+        end: Lvalue<'tcx>,\n+        loop_body: BasicBlock,\n+        loop_end: BasicBlock,\n+        is_cleanup: bool\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let cond = self.make_lvalue(Mutability::Mut, tcx.types.bool);\n+        let compute_cond = self.make_statement(\n+            StatementKind::Assign(\n+                cond.clone(),\n+                Rvalue::BinaryOp(BinOp::Ne, Operand::Consume(end), Operand::Consume(beg))\n+            )\n+        );\n+\n+        // `if end != beg { goto loop_body; } else { goto loop_end; }`\n+        self.block(\n+            vec![compute_cond],\n+            TerminatorKind::if_(tcx, Operand::Consume(cond), loop_body, loop_end),\n+            is_cleanup\n+        );\n+    }\n+\n+    fn make_usize(&self, value: usize) -> Box<Constant<'tcx>> {\n+        let value = ConstUsize::new(value as u64, self.tcx.sess.target.uint_type).unwrap();\n+        box Constant {\n+            span: self.span,\n+            ty: self.tcx.types.usize,\n+            literal: Literal::Value {\n+                value: ConstVal::Integral(ConstInt::Usize(value))\n+            }\n+        }\n+    }\n+\n+    fn array_shim(&mut self, ty: ty::Ty<'tcx>, len: usize) {\n+        let tcx = self.tcx;\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n+        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let end = self.make_lvalue(Mutability::Not, tcx.types.usize);\n+        let ret = self.make_lvalue(Mutability::Mut, tcx.mk_array(ty, len));\n+\n+        // BB #0\n+        // `let mut beg = 0;`\n+        // `let end = len;`\n+        // `goto #1;`\n+        let inits = vec![\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    beg.clone(),\n+                    Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+                )\n+            ),\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    end.clone(),\n+                    Rvalue::Use(Operand::Constant(self.make_usize(len)))\n+                )\n+            )\n+        ];\n+        self.block(inits, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n+\n+        // BB #1: loop {\n+        //     BB #2;\n+        //     BB #3;\n+        // }\n+        // BB #4;\n+        self.loop_header(beg.clone(), end, BasicBlock::new(2), BasicBlock::new(4), false);\n+\n+        // BB #2\n+        // `let cloned = Clone::clone(rcvr[beg])`;\n+        // Goto #3 if ok, #5 if unwinding happens.\n+        let rcvr_field = rcvr.clone().index(Operand::Consume(beg.clone()));\n+        let cloned = self.make_clone_call(ty, rcvr_field, BasicBlock::new(3), BasicBlock::new(5));\n+\n+        // BB #3\n+        // `ret[beg] = cloned;`\n+        // `beg = beg + 1;`\n+        // `goto #1`;\n+        let ret_field = ret.clone().index(Operand::Consume(beg.clone()));\n+        let statements = vec![\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    ret_field,\n+                    Rvalue::Use(Operand::Consume(cloned))\n+                )\n+            ),\n+            self.make_statement(\n+                StatementKind::Assign(\n+                    beg.clone(),\n+                    Rvalue::BinaryOp(\n+                        BinOp::Add,\n+                        Operand::Consume(beg.clone()),\n+                        Operand::Constant(self.make_usize(1))\n+                    )\n+                )\n+            )\n+        ];\n+        self.block(statements, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);\n+\n+        // BB #4\n+        // `return ret;`\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Use(Operand::Consume(ret.clone())),\n+            )\n+        );\n+        self.block(vec![ret_statement], TerminatorKind::Return, false);\n+\n+        // BB #5 (cleanup)\n+        // `let end = beg;`\n+        // `let mut beg = 0;`\n+        // goto #6;\n+        let end = beg;\n+        let beg = self.make_lvalue(Mutability::Mut, tcx.types.usize);\n+        let init = self.make_statement(\n+            StatementKind::Assign(\n+                beg.clone(),\n+                Rvalue::Use(Operand::Constant(self.make_usize(0)))\n+            )\n+        );\n+        self.block(vec![init], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n+\n+        // BB #6 (cleanup): loop {\n+        //     BB #7;\n+        //     BB #8;\n+        // }\n+        // BB #9;\n+        self.loop_header(beg.clone(), end, BasicBlock::new(7), BasicBlock::new(9), true);\n+\n+        // BB #7 (cleanup)\n+        // `drop(ret[beg])`;\n+        self.block(vec![], TerminatorKind::Drop {\n+            location: ret.index(Operand::Consume(beg.clone())),\n+            target: BasicBlock::new(8),\n+            unwind: None,\n+        }, true);\n+\n+        // BB #8 (cleanup)\n+        // `beg = beg + 1;`\n+        // `goto #6;`\n+        let statement = self.make_statement(\n+            StatementKind::Assign(\n+                beg.clone(),\n+                Rvalue::BinaryOp(\n+                    BinOp::Add,\n+                    Operand::Consume(beg.clone()),\n+                    Operand::Constant(self.make_usize(1))\n+                )\n+            )\n+        );\n+        self.block(vec![statement], TerminatorKind::Goto { target: BasicBlock::new(6) }, true);\n+\n+        // BB #9 (resume)\n+        self.block(vec![], TerminatorKind::Resume, true);\n+    }\n+\n+    fn tuple_shim(&mut self, tys: &ty::Slice<ty::Ty<'tcx>>) {\n+        let rcvr = Lvalue::Local(Local::new(1+0)).deref();\n+\n+        let mut returns = Vec::new();\n+        for (i, ity) in tys.iter().enumerate() {\n+            let rcvr_field = rcvr.clone().field(Field::new(i), *ity);\n+\n+            // BB #(2i)\n+            // `returns[i] = Clone::clone(&rcvr.i);`\n+            // Goto #(2i + 2) if ok, #(2i + 1) if unwinding happens.\n+            returns.push(\n+                self.make_clone_call(\n+                    *ity,\n+                    rcvr_field,\n+                    BasicBlock::new(2 * i + 2),\n+                    BasicBlock::new(2 * i + 1),\n+                )\n+            );\n+\n+            // BB #(2i + 1) (cleanup)\n+            if i == 0 {\n+                // Nothing to drop, just resume.\n+                self.block(vec![], TerminatorKind::Resume, true);\n+            } else {\n+                // Drop previous field and goto previous cleanup block.\n+                self.block(vec![], TerminatorKind::Drop {\n+                    location: returns[i - 1].clone(),\n+                    target: BasicBlock::new(2 * i - 1),\n+                    unwind: None,\n+                }, true);\n+            }\n+        }\n+\n+        // `return (returns[0], returns[1], ..., returns[tys.len() - 1]);`\n+        let ret_statement = self.make_statement(\n+            StatementKind::Assign(\n+                Lvalue::Local(RETURN_POINTER),\n+                Rvalue::Aggregate(\n+                    box AggregateKind::Tuple,\n+                    returns.into_iter().map(Operand::Consume).collect()\n+                )\n+            )\n+        );\n+       self.block(vec![ret_statement], TerminatorKind::Return, false);\n+    }\n+}\n+\n /// Build a \"call\" shim for `def_id`. The shim calls the\n /// function specified by `call_kind`, first adjusting its first\n /// argument according to `rcvr_adjustment`."}, {"sha": "c5de3a4ffb0fd65816620e174bb0b22a50e389c9", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -699,7 +699,8 @@ fn visit_instance_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Item(..) |\n-        ty::InstanceDef::FnPtrShim(..) => {\n+        ty::InstanceDef::FnPtrShim(..) |\n+        ty::InstanceDef::CloneShim(..) => {\n             output.push(create_fn_trans_item(instance));\n         }\n     }\n@@ -716,7 +717,8 @@ fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instan\n         ty::InstanceDef::Virtual(..) |\n         ty::InstanceDef::FnPtrShim(..) |\n         ty::InstanceDef::DropGlue(..) |\n-        ty::InstanceDef::Intrinsic(_) => return true\n+        ty::InstanceDef::Intrinsic(_) |\n+        ty::InstanceDef::CloneShim(..) => return true\n     };\n     match tcx.hir.get_if_local(def_id) {\n         Some(hir_map::NodeForeignItem(..)) => {"}, {"sha": "b0d8be23b0d968358b9027204582a3f9d97fa649", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -143,6 +143,12 @@ fn resolve_associated_item<'a, 'tcx>(\n                 substs: rcvr_substs\n             }\n         }\n+        traits::VtableBuiltin(..) if Some(trait_id) == tcx.lang_items.clone_trait() => {\n+            Instance {\n+                def: ty::InstanceDef::CloneShim(def_id, trait_ref.self_ty()),\n+                substs: rcvr_substs\n+            }\n+        }\n         _ => {\n             bug!(\"static call to invalid vtable: {:?}\", vtbl)\n         }"}, {"sha": "26256fa78dd4d51706722669445697cd961fd070", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -361,7 +361,8 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 InstanceDef::Virtual(..) |\n                                 InstanceDef::Intrinsic(..) |\n                                 InstanceDef::ClosureOnceShim { .. } |\n-                                InstanceDef::DropGlue(..) => {\n+                                InstanceDef::DropGlue(..) |\n+                                InstanceDef::CloneShim(..) => {\n                                     bug!(\"partitioning: Encountered unexpected\n                                           root translation item: {:?}\",\n                                           trans_item)\n@@ -603,7 +604,8 @@ fn characteristic_def_id_of_trans_item<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n                 ty::InstanceDef::ClosureOnceShim { .. } |\n                 ty::InstanceDef::Intrinsic(..) |\n                 ty::InstanceDef::DropGlue(..) |\n-                ty::InstanceDef::Virtual(..) => return None\n+                ty::InstanceDef::Virtual(..) |\n+                ty::InstanceDef::CloneShim(..) => return None\n             };\n \n             // If this is a method, we want to put it into the same module as"}, {"sha": "096b778cab2d3f28e8c576f2fce90fdb25e9f4c7", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -719,6 +719,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 continue;\n             }\n \n+            self.assemble_builtin_candidates(import_id, trait_def_id, item.clone());\n+\n             self.assemble_extension_candidates_for_trait_impls(import_id, trait_def_id,\n                                                                item.clone());\n \n@@ -732,6 +734,49 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n+    fn assemble_builtin_candidates(&mut self,\n+                                   import_id: Option<ast::NodeId>,\n+                                   trait_def_id: DefId,\n+                                   item: ty::AssociatedItem) {\n+        if Some(trait_def_id) == self.tcx.lang_items.clone_trait() {\n+            self.assemble_builtin_clone_candidates(import_id, trait_def_id, item);\n+        }\n+    }\n+\n+    fn assemble_builtin_clone_candidates(&mut self,\n+                                         import_id: Option<ast::NodeId>,\n+                                         trait_def_id: DefId,\n+                                         item: ty::AssociatedItem) {\n+        for step in Rc::clone(&self.steps).iter() {\n+            match step.self_ty.sty {\n+                ty::TyInfer(ty::IntVar(_)) | ty::TyInfer(ty::FloatVar(_)) |\n+                ty::TyUint(_) | ty::TyInt(_) | ty::TyBool | ty::TyFloat(_) |\n+                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+                ty::TyRawPtr(..) | ty::TyError | ty::TyNever |\n+                ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) |\n+                ty::TyArray(..) | ty::TyTuple(..) => {\n+                    ()\n+                }\n+\n+                _ => continue,\n+            };\n+\n+            let substs = Substs::for_item(self.tcx,\n+                                          trait_def_id,\n+                                          |def, _| self.region_var_for_def(self.span, def),\n+                                          |def, substs| {\n+                if def.index == 0 {\n+                    step.self_ty\n+                } else {\n+                    self.type_var_for_def(self.span, def, substs)\n+                }\n+            });\n+\n+            let xform_self_ty = self.xform_self_ty(&item, step.self_ty, substs);\n+            self.push_inherent_candidate(xform_self_ty, item, TraitCandidate, import_id);\n+        }\n+    }\n+\n     fn assemble_extension_candidates_for_trait_impls(&mut self,\n                                                      import_id: Option<ast::NodeId>,\n                                                      trait_def_id: DefId,"}, {"sha": "90a411352869ccf09bc42faa68970554750c2ccc", "filename": "src/test/run-pass/builtin-clone-unwind.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone-unwind.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that builtin implementations of `Clone` cleanup everything\n+// in case of unwinding.\n+\n+use std::thread;\n+use std::rc::Rc;\n+\n+struct S(Rc<()>);\n+\n+impl Clone for S {\n+    fn clone(&self) -> Self {\n+        if Rc::strong_count(&self.0) == 7 {\n+            panic!(\"oops\");\n+        }\n+\n+        S(self.0.clone())\n+    }\n+}\n+\n+fn main() {\n+    let counter = Rc::new(());\n+\n+    // Unwinding with tuples...\n+    let ccounter = counter.clone();\n+    let result = std::panic::catch_unwind(move || {\n+        let _ = (\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter)\n+        ).clone();\n+    });\n+\n+    assert!(result.is_err());\n+    assert_eq!(\n+        1,\n+        Rc::strong_count(&counter)\n+    );\n+\n+    // ... and with arrays.\n+    let ccounter = counter.clone();\n+    let child = std::panic::catch_unwind(move || {\n+        let _ = [\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter.clone()),\n+            S(ccounter)\n+        ].clone();\n+    });\n+\n+    assert!(result.is_err());\n+    assert_eq!(\n+        1,\n+        Rc::strong_count(&counter)\n+    );\n+}"}, {"sha": "95903610931b2e9f7ec6d2a1482afc342038047a", "filename": "src/test/run-pass/builtin-clone.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-clone.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `Clone` is correctly implemented for builtin types.\n+// Also test that cloning an array or a tuple is done right, i.e.\n+// each component is cloned.\n+\n+fn test_clone<T: Clone>(arg: T) {\n+    let _ = arg.clone();\n+}\n+\n+fn foo() { }\n+\n+#[derive(Debug, PartialEq, Eq)]\n+struct S(i32);\n+\n+impl Clone for S {\n+    fn clone(&self) -> Self {\n+        S(self.0 + 1)\n+    }\n+}\n+\n+fn main() {\n+    test_clone(foo);\n+    test_clone([1; 56]);\n+    test_clone((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1));\n+\n+    let a = [S(0), S(1), S(2)];\n+    let b = [S(1), S(2), S(3)];\n+    assert_eq!(b, a.clone());\n+\n+    let a = (\n+        (S(1), S(0)),\n+        (\n+            (S(0), S(0), S(1)),\n+            S(0)\n+        )\n+    );\n+    let b = (\n+        (S(2), S(1)),\n+        (\n+            (S(1), S(1), S(2)),\n+            S(1)\n+        )\n+    );\n+    assert_eq!(b, a.clone());\n+}"}, {"sha": "a8fb11f9c62bd58b4f94c71dcaa1cf142e1b0b9a", "filename": "src/test/run-pass/issue-37725.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Ftest%2Frun-pass%2Fissue-37725.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942711e115834ea2b4d91e1b3d3ae84b69cad670/src%2Ftest%2Frun-pass%2Fissue-37725.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-37725.rs?ref=942711e115834ea2b4d91e1b3d3ae84b69cad670", "patch": "@@ -8,7 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n-    s.clone();\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+fn foo<'a>(s: &'a mut ()) where &'a mut (): Foo {\n+    s.foo();\n }\n fn main() {}"}]}