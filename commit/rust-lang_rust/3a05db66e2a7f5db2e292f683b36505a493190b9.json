{"sha": "3a05db66e2a7f5db2e292f683b36505a493190b9", "node_id": "C_kwDOAAsO6NoAKDNhMDVkYjY2ZTJhN2Y1ZGIyZTI5MmY2ODNiMzY1MDVhNDkzMTkwYjk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-02T08:15:02Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-11-12T12:10:33Z"}, "message": "Simplify suggestions for errors in generators.", "tree": {"sha": "6b3378d6ebf6554f81fbbb32a1ba56a0fd4be355", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b3378d6ebf6554f81fbbb32a1ba56a0fd4be355"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a05db66e2a7f5db2e292f683b36505a493190b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a05db66e2a7f5db2e292f683b36505a493190b9", "html_url": "https://github.com/rust-lang/rust/commit/3a05db66e2a7f5db2e292f683b36505a493190b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a05db66e2a7f5db2e292f683b36505a493190b9/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825f8edc2fff167304d40c826f136e82967d68f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/825f8edc2fff167304d40c826f136e82967d68f3", "html_url": "https://github.com/rust-lang/rust/commit/825f8edc2fff167304d40c826f136e82967d68f3"}], "stats": {"total": 93, "additions": 42, "deletions": 51}, "files": [{"sha": "8375d11d6be3860c75e5154bd1730f39b1869d91", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/3a05db66e2a7f5db2e292f683b36505a493190b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a05db66e2a7f5db2e292f683b36505a493190b9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3a05db66e2a7f5db2e292f683b36505a493190b9", "patch": "@@ -44,7 +44,7 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n #[derive(Debug)]\n pub enum GeneratorInteriorOrUpvar {\n     // span of interior type\n-    Interior(Span),\n+    Interior(Span, Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>),\n     // span of upvar\n     Upvar(Span),\n }\n@@ -283,7 +283,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n-        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         is_async: bool,\n         outer_generator: Option<DefId>,\n         trait_pred: ty::TraitPredicate<'tcx>,\n@@ -2003,17 +2002,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .as_local()\n             .and_then(|def_id| hir.maybe_body_owned_by(def_id))\n             .map(|body_id| hir.body(body_id));\n-        let is_async = match generator_did.as_local() {\n-            Some(_) => generator_body\n-                .and_then(|body| body.generator_kind())\n-                .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n-                .unwrap_or(false),\n-            None => self\n-                .tcx\n-                .generator_kind(generator_did)\n-                .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n-                .unwrap_or(false),\n-        };\n+        let is_async = self\n+            .tcx\n+            .generator_kind(generator_did)\n+            .map(|generator_kind| matches!(generator_kind, hir::GeneratorKind::Async(..)))\n+            .unwrap_or(false);\n         let mut visitor = AwaitsVisitor::default();\n         if let Some(body) = generator_body {\n             visitor.visit_body(body);\n@@ -2043,61 +2036,60 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             eq\n         };\n \n-        let mut interior_or_upvar_span = None;\n-        let mut interior_extra_info = None;\n-\n         // Get the typeck results from the infcx if the generator is the function we are currently\n         // type-checking; otherwise, get them by performing a query.  This is needed to avoid\n         // cycles. If we can't use resolved types because the generator comes from another crate,\n         // we still provide a targeted error but without all the relevant spans.\n-        let generator_data: Option<GeneratorData<'tcx, '_>> = match &self.typeck_results {\n-            Some(t) if t.hir_owner.to_def_id() == generator_did_root => {\n-                Some(GeneratorData::Local(&t))\n-            }\n+        let generator_data = match &self.typeck_results {\n+            Some(t) if t.hir_owner.to_def_id() == generator_did_root => GeneratorData::Local(&t),\n             _ if generator_did.is_local() => {\n-                Some(GeneratorData::Local(self.tcx.typeck(generator_did.expect_local())))\n+                GeneratorData::Local(self.tcx.typeck(generator_did.expect_local()))\n             }\n-            _ => self\n-                .tcx\n-                .generator_diagnostic_data(generator_did)\n-                .as_ref()\n-                .map(|generator_diag_data| GeneratorData::Foreign(generator_diag_data)),\n+            _ if let Some(generator_diag_data) = self.tcx.generator_diagnostic_data(generator_did) => {\n+                GeneratorData::Foreign(generator_diag_data)\n+            }\n+            _ => return false,\n         };\n \n-        if let Some(generator_data) = generator_data.as_ref() {\n-            interior_or_upvar_span =\n-                generator_data.try_get_upvar_span(&self, generator_did, ty_matches);\n+        let mut interior_or_upvar_span = None;\n \n-            // The generator interior types share the same binders\n-            if let Some(cause) =\n-                generator_data.get_generator_interior_types().skip_binder().iter().find(\n-                    |ty::GeneratorInteriorTypeCause { ty, .. }| {\n-                        ty_matches(generator_data.get_generator_interior_types().rebind(*ty))\n-                    },\n-                )\n-            {\n-                let from_awaited_ty = generator_data.get_from_await_ty(visitor, hir, ty_matches);\n-                let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } =\n-                    cause;\n+        let from_awaited_ty = generator_data.get_from_await_ty(visitor, hir, ty_matches);\n+        debug!(?from_awaited_ty);\n \n-                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(*span));\n-                interior_extra_info = Some((*scope_span, *yield_span, *expr, from_awaited_ty));\n-            }\n+        // The generator interior types share the same binders\n+        if let Some(cause) =\n+            generator_data.get_generator_interior_types().skip_binder().iter().find(\n+                |ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                    ty_matches(generator_data.get_generator_interior_types().rebind(*ty))\n+                },\n+            )\n+        {\n+            let ty::GeneratorInteriorTypeCause { span, scope_span, yield_span, expr, .. } = cause;\n \n-            if interior_or_upvar_span.is_none() && generator_data.is_foreign() {\n-                interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(span));\n-            }\n+            interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(\n+                *span,\n+                Some((*scope_span, *yield_span, *expr, from_awaited_ty)),\n+            ));\n         }\n \n+        if interior_or_upvar_span.is_none() {\n+            interior_or_upvar_span =\n+                generator_data.try_get_upvar_span(&self, generator_did, ty_matches);\n+        }\n+\n+        if interior_or_upvar_span.is_none() && generator_data.is_foreign() {\n+            interior_or_upvar_span = Some(GeneratorInteriorOrUpvar::Interior(span, None));\n+        }\n+\n+        debug!(?interior_or_upvar_span);\n         if let Some(interior_or_upvar_span) = interior_or_upvar_span {\n-            let typeck_results = generator_data.and_then(|generator_data| match generator_data {\n+            let typeck_results = match generator_data {\n                 GeneratorData::Local(typeck_results) => Some(typeck_results),\n                 GeneratorData::Foreign(_) => None,\n-            });\n+            };\n             self.note_obligation_cause_for_async_await(\n                 err,\n                 interior_or_upvar_span,\n-                interior_extra_info,\n                 is_async,\n                 outer_generator,\n                 trait_ref,\n@@ -2119,7 +2111,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         interior_or_upvar_span: GeneratorInteriorOrUpvar,\n-        interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         is_async: bool,\n         outer_generator: Option<DefId>,\n         trait_pred: ty::TraitPredicate<'tcx>,\n@@ -2241,7 +2232,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             }\n         };\n         match interior_or_upvar_span {\n-            GeneratorInteriorOrUpvar::Interior(interior_span) => {\n+            GeneratorInteriorOrUpvar::Interior(interior_span, interior_extra_info) => {\n                 if let Some((scope_span, yield_span, expr, from_awaited_ty)) = interior_extra_info {\n                     if let Some(await_span) = from_awaited_ty {\n                         // The type causing this obligation is one being awaited at await_span."}]}