{"sha": "7c4f8cb45924326e21547d19cbed683115657616", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNGY4Y2I0NTkyNDMyNmUyMTU0N2QxOWNiZWQ2ODMxMTU2NTc2MTY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-04-20T19:11:01Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-28T20:26:19Z"}, "message": "Further work on typestate_check\n\nLots of work on typestate_check, seems to get a lot of the way\nthrough checking the standard library.\n\n* Added for, for_each, assign_op, bind, cast, put, check, break,\nand cont. (I'm not sure break and cont are actually handled correctly.)\n\n* Fixed side-effect bug in seq_preconds so that unioning the\npreconditions of a sequence of statements or expressions\nis handled correctly.\n\n* Pass poststate correctly through a stmt_decl.\n\n* Handle expr_ret and expr_fail properly (after execution of a ret\nor fail, everything is true -- this is needed to handle ifs and alts\nwhere one branch is a ret or fail)\n\n* Fixed bug in set_prestate_ann where a thing that needed to be\nmutated wasn't getting passed as an alias\n\n* Fixed bug in how expr_alt was treated (zero is not the identity\nfor intersect, who knew, right?)\n\n* Update logging to reflect log_err vs. log\n\n* Fixed find_locals so as to return all local decls and exclude\nfunction arguments.\n\n* Make union_postconds work on an empty vector (needed to handle\nempty blocks correctly)\n\n* Added _vec.cat_options, which takes a list of option[T] to a list\nof T, ignoring any Nones\n\n* Added two test cases.", "tree": {"sha": "9b27e94ec87c7bec6f1e4bd4e15c742d7d241d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b27e94ec87c7bec6f1e4bd4e15c742d7d241d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4f8cb45924326e21547d19cbed683115657616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4f8cb45924326e21547d19cbed683115657616", "html_url": "https://github.com/rust-lang/rust/commit/7c4f8cb45924326e21547d19cbed683115657616", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4f8cb45924326e21547d19cbed683115657616/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0980b7d79e8209ba91a2a85c720f238bbc478ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0980b7d79e8209ba91a2a85c720f238bbc478ed", "html_url": "https://github.com/rust-lang/rust/commit/b0980b7d79e8209ba91a2a85c720f238bbc478ed"}], "stats": {"total": 614, "additions": 483, "deletions": 131}, "files": [{"sha": "04aeebdf37ca4fee132eccca5d376bceb4715314", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 343, "deletions": 119, "changes": 462, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f8cb45924326e21547d19cbed683115657616/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f8cb45924326e21547d19cbed683115657616/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=7c4f8cb45924326e21547d19cbed683115657616", "patch": "@@ -101,14 +101,19 @@ import util.common.uistr;\n import util.common.elt_exprs;\n import util.common.field_exprs;\n import util.common.log_expr;\n+import util.common.log_expr_err;\n import util.common.log_stmt;\n import util.common.log_block;\n+import util.common.log_stmt_err;\n+import util.common.log_block_err;\n+import util.common.decl_lhs;\n import util.typestate_ann;\n import util.typestate_ann.ts_ann;\n import util.typestate_ann.empty_pre_post;\n import util.typestate_ann.empty_poststate;\n import util.typestate_ann.true_precond;\n import util.typestate_ann.true_postcond;\n+import util.typestate_ann.false_postcond;\n import util.typestate_ann.postcond;\n import util.typestate_ann.precond;\n import util.typestate_ann.poststate;\n@@ -131,8 +136,10 @@ import util.typestate_ann.empty_prestate;\n import util.typestate_ann.empty_ann;\n import util.typestate_ann.extend_prestate;\n import util.typestate_ann.extend_poststate;\n+import util.typestate_ann.relax_prestate;\n import util.typestate_ann.intersect;\n import util.typestate_ann.pp_clone;\n+import util.typestate_ann.clone;\n \n import middle.ty;\n import middle.ty.ann_to_type;\n@@ -156,6 +163,7 @@ import std._vec.push;\n import std._vec.slice;\n import std._vec.unzip;\n import std._vec.plus_option;\n+import std._vec.cat_options;\n import std.option;\n import std.option.t;\n import std.option.some;\n@@ -184,16 +192,23 @@ import util.typestate_ann.require_and_preserve;\n \n /**** debugging junk  ****/\n \n-fn log_bitv(fn_info enclosing, bitv.t v) {\n+fn bitv_to_str(fn_info enclosing, bitv.t v) -> str {\n   auto s = \"\";\n \n   for each (@tup(def_id, tup(uint, ident)) p in enclosing.items()) {\n     if (bitv.get(v, p._1._0)) {\n       s += \" \" + p._1._1 + \" \";\n     }\n   }\n+  ret s;\n+}\n+\n+fn log_bitv(fn_info enclosing, bitv.t v) {\n+    log(bitv_to_str(enclosing, v));\n+}\n \n-  log(s);\n+fn log_bitv_err(fn_info enclosing, bitv.t v) {\n+    log_err(bitv_to_str(enclosing, v));\n }\n \n fn log_cond(vec[uint] v) -> () {\n@@ -217,6 +232,15 @@ fn log_pp(&pre_and_post pp) -> () {\n   log_cond(p2);\n }\n \n+fn log_states(&pre_and_post_state pp) -> () {\n+  auto p1 = bitv.to_vec(pp.prestate);\n+  auto p2 = bitv.to_vec(pp.poststate);\n+  log(\"prestate:\");\n+  log_cond(p1);\n+  log(\"poststate:\");\n+  log_cond(p2);\n+}\n+\n fn print_ident(&ident i) -> () {\n   log(\" \" + i + \" \");\n }\n@@ -256,18 +280,19 @@ fn num_locals(fn_info m) -> uint {\n   ret m.size();\n }\n \n-fn find_locals(_fn f) -> vec[tup(ident,def_id)] {\n-  auto res = _vec.alloc[tup(ident,def_id)](0u);\n+fn collect_local(&@vec[tup(ident, def_id)] vars, &span sp, @ast.local loc) \n+    -> @decl {\n+    log(\"collect_local: pushing \" + loc.ident);\n+    _vec.push[tup(ident, def_id)](*vars, tup(loc.ident, loc.id));\n+    ret @respan(sp, decl_local(loc));\n+}\n \n-  for each (@tup(ident, block_index_entry) p\n-          in f.body.node.index.items()) {\n-    alt (p._1) {\n-      case (ast.bie_local(?loc)) {\n-        res += vec(tup(loc.ident,loc.id));\n-      }\n-      case (_) { }\n-    }\n-  }\n+fn find_locals(_fn f) -> @vec[tup(ident,def_id)] {\n+  auto res = @_vec.alloc[tup(ident,def_id)](0u);\n+\n+  auto fld = fold.new_identity_fold[@vec[tup(ident, def_id)]]();\n+  fld = @rec(fold_decl_local = bind collect_local(_,_,_) with *fld);\n+  auto ignore = fold.fold_fn[@vec[tup(ident, def_id)]](res, fld, f);\n \n   ret res;\n }\n@@ -285,12 +310,12 @@ fn mk_fn_info(_fn f) -> fn_info {\n   let uint next = 0u;\n   let vec[ast.arg] f_args = f.decl.inputs;\n \n-  for (ast.arg v in f_args) {\n-    next = add_var(v.id, v.ident, next, res);\n-  }\n+  /* ignore args, which we know are initialized;\n+     just collect locally declared vars */\n \n-  let vec[tup(ident,def_id)] locals = find_locals(f);\n-  for (tup(ident,def_id) p in locals) {\n+  let @vec[tup(ident,def_id)] locals = find_locals(f);\n+  log(uistr(_vec.len[tup(ident, def_id)](*locals)) + \" locals\");\n+  for (tup(ident,def_id) p in *locals) {\n     next = add_var(p._1, p._0, next, res);\n   }\n \n@@ -435,6 +460,12 @@ fn expr_ann(&expr e) -> ann {\n     case (ast.expr_chan(_,?a)) {\n       ret a;\n     }\n+    case (expr_break(?a)) {\n+        ret a;\n+    }\n+    case (expr_cont(?a)) {\n+        ret a;\n+    }\n   }\n }\n \n@@ -679,8 +710,9 @@ fn seq_preconds(uint num_vars, vec[pre_and_post] pps) -> precond {\n     let precond rest = seq_preconds(num_vars,\n                          slice[pre_and_post](pps, 1u, sz));\n     difference(rest, first.postcondition);\n-    union(first.precondition, rest);\n-    ret first.precondition;\n+    auto res = clone(first.precondition);\n+    union(res, rest);\n+    ret res;\n   }\n   else {\n       ret true_precond(num_vars);\n@@ -701,10 +733,13 @@ fn union_postconds_go(&postcond first, &vec[postcond] rest) -> postcond {\n   ret first;\n }\n \n-fn union_postconds(&vec[postcond] pcs) -> postcond {\n-  check (len[postcond](pcs) > 0u);\n-\n-  ret union_postconds_go(bitv.clone(pcs.(0)), pcs);\n+fn union_postconds(uint nv, &vec[postcond] pcs) -> postcond {\n+  if (len[postcond](pcs) > 0u) {\n+      ret union_postconds_go(bitv.clone(pcs.(0)), pcs);\n+  }\n+  else {\n+      ret empty_prestate(nv);\n+  }\n }\n \n /* Gee, maybe we could use foldl or something */\n@@ -804,6 +839,8 @@ fn find_pre_post_item(fn_info_map fm, fn_info enclosing, &item i) -> () {\n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n                        &vec[@expr] args, ann a) {\n+    auto nv = num_locals(enclosing);\n+\n     fn do_one(fn_info_map fm, fn_info enclosing,\n               &@expr e) -> () {\n         find_pre_post_expr(fm, enclosing, *e);\n@@ -820,9 +857,22 @@ fn find_pre_post_exprs(&fn_info_map fm, &fn_info enclosing,\n     auto h = get_post;\n \n     set_pre_and_post(a,\n-       rec(precondition=seq_preconds(num_locals(enclosing), pps),\n+       rec(precondition=seq_preconds(nv, pps),\n            postcondition=union_postconds\n-           (_vec.map[pre_and_post, postcond](h, pps))));\n+           (nv, (_vec.map[pre_and_post, postcond](h, pps)))));\n+}\n+\n+fn find_pre_post_loop(&fn_info_map fm, &fn_info enclosing, &@decl d,\n+     &@expr index, &block body, &ann a) -> () {\n+    find_pre_post_expr(fm, enclosing, *index);\n+    find_pre_post_block(fm, enclosing, body);\n+    auto loop_precond = declare_var(enclosing, decl_lhs(d),\n+           seq_preconds(num_locals(enclosing), vec(expr_pp(*index),\n+                                                   block_pp(body))));\n+    auto loop_postcond = intersect_postconds\n+        (vec(expr_postcond(*index), block_postcond(body)));\n+    set_pre_and_post(a, rec(precondition=loop_precond,\n+                            postcondition=loop_postcond));\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n@@ -833,21 +883,26 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         find_pre_post_expr(fm, enclosing, *e);\n     }\n     fn pp_one(&@expr e) -> pre_and_post {\n-        be expr_pp(*e);\n+        ret expr_pp(*e);\n     }\n-\n-    /*    log(\"find_pre_post_expr (num_locals =\" +\n+    /*\n+        log(\"find_pre_post_expr (num_locals =\" +\n              uistr(num_local_vars) + \"):\");\n           log_expr(e);\n     */\n-\n-    alt(e.node) {\n-        case(expr_call(?operator, ?operands, ?a)) {\n+    alt (e.node) {\n+        case (expr_call(?operator, ?operands, ?a)) {\n             auto args = _vec.clone[@expr](operands);\n             _vec.push[@expr](args, operator);\n             find_pre_post_exprs(fm, enclosing, args, a);\n         }\n-        case(expr_path(?p, ?maybe_def, ?a)) {\n+        case (expr_vec(?args, _, ?a)) {\n+            find_pre_post_exprs(fm, enclosing, args, a);\n+        }\n+        case (expr_tup(?elts, ?a)) {\n+            find_pre_post_exprs(fm, enclosing, elt_exprs(elts), a);\n+        }\n+        case (expr_path(?p, ?maybe_def, ?a)) {\n             auto df;\n             alt (maybe_def) {\n                 case (none[def])\n@@ -872,6 +927,17 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             find_pre_post_expr(fm, enclosing, *arg);\n             set_pre_and_post(a, expr_pp(*arg));\n         }\n+        case(expr_put(?opt, ?a)) {\n+            alt (opt) {\n+                case (some[@expr](?arg)) {\n+                    find_pre_post_expr(fm, enclosing, *arg);\n+                    set_pre_and_post(a, expr_pp(*arg));\n+                }\n+                case (none[@expr]) {\n+                    set_pre_and_post(a, empty_pre_post(num_local_vars));\n+                }\n+            }\n+        }\n         case (expr_block(?b, ?a)) {\n             find_pre_post_block(fm, enclosing, b);\n             set_pre_and_post(a, block_pp(b));\n@@ -886,6 +952,8 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                 case (expr_path(?p, some[def](def_local(?d_id)), ?a_lhs)) {\n                     find_pre_post_expr(fm, enclosing, *rhs);\n                     set_pre_and_post(a, expr_pp(*rhs));\n+                    log(\"gen:\");\n+                    log_expr(e);\n                     gen(enclosing, a, d_id);\n                 }\n                 case (_) {\n@@ -895,19 +963,26 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                 }\n             }\n         }\n+        case (expr_assign_op(_, ?lhs, ?rhs, ?a)) {\n+            /* Different from expr_assign in that the lhs *must*\n+               already be initialized */\n+            find_pre_post_exprs(fm, enclosing, vec(lhs, rhs), a);\n+        }\n         case (expr_lit(_,?a)) {\n             set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case (expr_ret(?maybe_val, ?a)) {\n             alt (maybe_val) {\n                 case (none[@expr]) {\n-                    set_pre_and_post(a, empty_pre_post(num_local_vars));\n+                    set_pre_and_post(a,\n+                      rec(precondition=true_precond(num_local_vars),\n+                          postcondition=false_postcond(num_local_vars)));\n                 }\n                 case (some[@expr](?ret_val)) {\n                     find_pre_post_expr(fm, enclosing, *ret_val);\n                     let pre_and_post pp =\n                         rec(precondition=expr_precond(*ret_val),\n-                            postcondition=empty_poststate(num_local_vars));\n+                            postcondition=false_postcond(num_local_vars));\n                     set_pre_and_post(a, pp);\n                 }\n             }\n@@ -930,14 +1005,17 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                         seq_preconds(num_local_vars,\n                                      vec(expr_pp(*antec), block_pp(conseq)));\n                     auto postcond_true_case = union_postconds\n-                        (vec(expr_postcond(*antec), block_postcond(conseq)));\n+                        (num_local_vars,\n+                         vec(expr_postcond(*antec), block_postcond(conseq)));\n                     auto precond_false_case = seq_preconds\n                         (num_local_vars,\n                          vec(expr_pp(*antec), expr_pp(*altern)));\n                     auto postcond_false_case = union_postconds\n-                        (vec(expr_postcond(*antec), expr_postcond(*altern)));\n-                    auto precond_res = union_postconds(vec(precond_true_case,\n-                                                       precond_false_case));\n+                        (num_local_vars,\n+                         vec(expr_postcond(*antec), expr_postcond(*altern)));\n+                    auto precond_res = union_postconds\n+                        (num_local_vars,\n+                         vec(precond_true_case, precond_false_case));\n                     auto postcond_res = intersect_postconds\n                         (vec(postcond_true_case, postcond_false_case));\n                     set_pre_and_post(a, rec(precondition=precond_res,\n@@ -954,6 +1032,10 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n             find_pre_post_expr(fm, enclosing, *operand);\n             set_pre_and_post(a, expr_pp(*operand));\n         }\n+        case (expr_cast(?operand, _, ?a)) {\n+            find_pre_post_expr(fm, enclosing, *operand);\n+            set_pre_and_post(a, expr_pp(*operand));\n+        }\n         case (expr_while(?test, ?body, ?a)) {\n             find_pre_post_expr(fm, enclosing, *test);\n             find_pre_post_block(fm, enclosing, body);\n@@ -966,6 +1048,12 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n                   intersect_postconds(vec(expr_postcond(*test),\n                                           block_postcond(body)))));\n         }\n+        case (expr_for(?d, ?index, ?body, ?a)) {\n+            find_pre_post_loop(fm, enclosing, d, index, body, a);\n+        }\n+        case (expr_for_each(?d, ?index, ?body, ?a)) {\n+            find_pre_post_loop(fm, enclosing, d, index, body, a);\n+        }\n         case (expr_index(?e, ?sub, ?a)) {\n             find_pre_post_exprs(fm, enclosing, vec(e, sub), a);\n         }\n@@ -998,12 +1086,27 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n         }\n         case (expr_fail(?a)) {\n             set_pre_and_post(a,\n+                             /* if execution continues after fail,\n+                                then everything is true! */\n                rec(precondition=empty_prestate(num_local_vars),\n-                   postcondition=true_postcond(num_local_vars)));\n+                   postcondition=false_postcond(num_local_vars)));\n+        }\n+        case (expr_check_expr(?p, ?a)) {\n+            /* will need to change when we support arbitrary predicates... */\n+            find_pre_post_expr(fm, enclosing, *p);\n+            set_pre_and_post(a, expr_pp(*p));\n+        }\n+        case(expr_bind(?operator, ?maybe_args, ?a)) {\n+            auto args = _vec.cat_options[@expr](maybe_args);\n+            _vec.push[@expr](args, operator); /* ??? order of eval? */\n+            find_pre_post_exprs(fm, enclosing, args, a);\n+        }\n+        case (expr_break(?a)) {\n+            set_pre_and_post(a, empty_pre_post(num_local_vars));\n         }\n         case(_) {\n-            log(\"this sort of expr isn't implemented!\");\n-            log_expr(e);\n+            log_err(\"this sort of expr isn't implemented!\");\n+            log_expr_err(e);\n             fail;\n         }\n     }\n@@ -1012,10 +1115,18 @@ fn find_pre_post_expr(&fn_info_map fm, &fn_info enclosing, &expr e) -> () {\n fn gen(&fn_info enclosing, &ann a, def_id id) -> bool {\n   check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n-\n   ret set_in_postcond(i, (ann_to_ts_ann_fail_more(a)).conditions);\n }\n \n+fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n+   -> prestate {\n+    check(enclosing.contains_key(id));\n+    let uint i = (enclosing.get(id))._0;\n+    auto res = clone(pre);\n+    relax_prestate(i, res);\n+    ret res;\n+}\n+\n fn gen_poststate(&fn_info enclosing, &ann a, def_id id) -> bool {\n   check(enclosing.contains_key(id));\n   let uint i = (enclosing.get(id))._0;\n@@ -1039,7 +1150,13 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n                         /* Inherit ann from initializer, and add var being\n                            initialized to the postcondition */\n                         set_pre_and_post(a, rhs_pp);\n+                        /*  log(\"gen (decl):\");\n+                            log_stmt(s); */\n                         gen(enclosing, a, alocal.id); \n+                        /*                     log_err(\"for stmt\");\n+                        log_stmt(s);\n+                        log_err(\"pp = \");\n+                        log_pp(stmt_pp(s)); */\n                     }\n                     case(none[ast.initializer]) {\n                         auto pp = empty_pre_post(num_local_vars);\n@@ -1064,6 +1181,8 @@ fn find_pre_post_stmt(fn_info_map fm, &fn_info enclosing, &ast.stmt s)\n \n fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     -> () {\n+    auto nv = num_locals(enclosing);\n+\n     fn do_one_(fn_info_map fm, fn_info i, &@stmt s) -> () {\n         find_pre_post_stmt(fm, i, *s);\n     }\n@@ -1089,13 +1208,13 @@ fn find_pre_post_block(&fn_info_map fm, &fn_info enclosing, block b)\n     auto g = get_pp_expr;\n     plus_option[pre_and_post](pps,\n        option.map[@expr, pre_and_post](g, b.node.expr));\n-    auto block_precond  = seq_preconds(num_locals(enclosing), pps);\n+    auto block_precond  = seq_preconds(nv, pps);\n     auto h = get_post;\n     auto postconds =  _vec.map[pre_and_post, postcond](h, pps);\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n     _vec.push[postcond](postconds, block_precond);\n-    auto block_postcond = union_postconds(postconds);\n+    auto block_postcond = union_postconds(nv, postconds);\n     set_pre_and_post(b.node.a, rec(precondition=block_precond,\n                                    postcondition=block_postcond));\n }\n@@ -1142,11 +1261,11 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n   }\n }\n \n-fn set_prestate_ann(ann a, prestate pre) -> bool {\n-  alt (a) {\n+fn set_prestate_ann(@ann a, prestate pre) -> bool {\n+  alt (*a) {\n     case (ann_type(_,_,?ts_a)) {\n       check (! is_none[@ts_ann](ts_a));\n-      ret set_prestate(*get[@ts_ann](ts_a), pre);\n+      ret set_prestate(get[@ts_ann](ts_a), pre);\n     }\n     case (ann_none) {\n       log(\"set_prestate_ann: expected an ann_type here\");\n@@ -1246,17 +1365,37 @@ fn pure_exp(&ann a, &prestate p) -> bool {\n   ret changed;\n }\n \n+fn find_pre_post_state_loop(fn_info_map fm, fn_info enclosing,\n+   prestate pres, &@decl d, &@expr index, &block body, &ann a) -> bool {\n+    auto changed = false;\n+\n+    /* same issues as while */\n+    changed = extend_prestate_ann(a, pres) || changed;\n+    changed = find_pre_post_state_expr(fm, enclosing, pres, index)\n+        || changed;\n+    /* in general, would need the intersection of\n+       (poststate of index, poststate of body) */\n+    changed = find_pre_post_state_block(fm, enclosing,\n+                expr_poststate(*index), body) || changed;\n+    auto res_p = intersect_postconds(vec(expr_poststate(*index),\n+                                         block_poststate(body)));\n+  \n+    changed = extend_poststate_ann(a, res_p) || changed;\n+    ret changed;\n+}\n+\n fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                             &prestate pres, &@expr e) -> bool {\n   auto changed = false;\n   auto num_local_vars = num_locals(enclosing);\n \n+  /* FIXME could get rid of some of the copy/paste */\n   alt (e.node) {\n     case (expr_vec(?elts, _, ?a)) {\n-      be find_pre_post_state_exprs(fm, enclosing, pres, a, elts); \n+      ret find_pre_post_state_exprs(fm, enclosing, pres, a, elts); \n     }\n     case (expr_tup(?elts, ?a)) {\n-      be find_pre_post_state_exprs(fm, enclosing, pres, a, elt_exprs(elts));\n+      ret find_pre_post_state_exprs(fm, enclosing, pres, a, elt_exprs(elts));\n     }\n     case (expr_call(?operator, ?operands, ?a)) {\n       /* do the prestate for the rator */\n@@ -1267,15 +1406,37 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                                     expr_poststate(*operator), a, operands)\n           || changed);\n     }\n+    case (expr_bind(?operator, ?maybe_args, ?a)) {\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, operator)\n+            || changed;\n+        ret (find_pre_post_state_exprs(fm, enclosing,\n+          expr_poststate(*operator), a, cat_options[@expr](maybe_args))\n+            || changed);\n+    }\n     case (expr_path(_,_,?a)) {\n       ret pure_exp(a, pres);\n     }\n     case (expr_log(_,?e,?a)) {\n+        /* factor out the \"one exp\" pattern */\n         changed = find_pre_post_state_expr(fm, enclosing, pres, e);\n         changed = extend_prestate_ann(a, pres) || changed;\n         changed = extend_poststate_ann(a, expr_poststate(*e)) || changed;\n         ret changed;\n     }\n+    case (expr_put(?maybe_e, ?a)) {\n+        alt (maybe_e) {\n+            case (some[@expr](?arg)) {\n+                changed = find_pre_post_state_expr(fm, enclosing, pres, arg);\n+                changed = extend_prestate_ann(a, pres) || changed;\n+                changed = extend_poststate_ann(a, expr_poststate(*arg))\n+                    || changed;\n+                ret changed;\n+            }\n+            case (none[@expr]) {\n+                ret pure_exp(a, pres);\n+            }\n+        }\n+    }\n     case (expr_lit(?l,?a)) {\n         ret pure_exp(a, pres);\n     }\n@@ -1327,7 +1488,7 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n     }\n     case (expr_ret(?maybe_ret_val, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n-        set_poststate_ann(a, empty_poststate(num_local_vars));\n+        set_poststate_ann(a, false_postcond(num_local_vars));\n         alt(maybe_ret_val) {\n             case (none[@expr]) { /* do nothing */ }\n             case (some[@expr](?ret_val)) {\n@@ -1368,6 +1529,16 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = extend_poststate_ann(a, expr_poststate(*r)) || changed;\n         ret changed;\n     }\n+    case (expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n+        /* quite similar to binary -- should abstract this */\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, lhs)\n+                    || changed;\n+        changed = find_pre_post_state_expr(fm,\n+                    enclosing, expr_poststate(*lhs), rhs) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*rhs)) || changed;\n+        ret changed;\n+    }\n     case (expr_while(?test, ?body, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n         /* to handle general predicates, we need to pass in\n@@ -1387,6 +1558,12 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n                                         block_poststate(body)))) || changed;\n         ret changed;\n     }\n+    case (expr_for(?d, ?index, ?body, ?a)) {\n+        ret find_pre_post_state_loop(fm, enclosing, pres, d, index, body, a);\n+    }\n+    case (expr_for_each(?d, ?index, ?body, ?a)) {\n+        ret find_pre_post_state_loop(fm, enclosing, pres, d, index, body, a);\n+    }\n     case (expr_index(?e, ?sub, ?a)) {\n         changed = extend_prestate_ann(a, pres) || changed; \n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n@@ -1399,13 +1576,21 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n         changed = extend_prestate_ann(a, pres) || changed; \n         changed = find_pre_post_state_expr(fm, enclosing, pres, e) || changed;\n         auto e_post = expr_poststate(*e);\n-        auto a_post = ann_to_poststate(a);\n-        for (arm an_alt in alts) {\n-            changed = find_pre_post_state_block(fm, enclosing, e_post,\n-                        an_alt.block) || changed;\n-            changed = intersect(a_post, block_poststate(an_alt.block))\n-               || changed;\n+        auto a_post;\n+        if (_vec.len[arm](alts) > 0u) {\n+            a_post = false_postcond(num_local_vars);\n+            for (arm an_alt in alts) {\n+                changed = find_pre_post_state_block(fm, enclosing, e_post,\n+                                                    an_alt.block) || changed;\n+                changed = intersect(a_post, block_poststate(an_alt.block))\n+                    || changed;\n+            }\n         }\n+        else {\n+            // No alts; poststate is the poststate of the test\n+            a_post = e_post;\n+        }\n+        changed = extend_poststate_ann(a, a_post);\n         ret changed;\n     }\n     case (expr_field(?e,_,?a)) {\n@@ -1422,14 +1607,36 @@ fn find_pre_post_state_expr(&fn_info_map fm, &fn_info enclosing,\n           || changed;\n         ret changed;\n     }\n+    case (expr_cast(?operand, _, ?a)) {\n+           changed = find_pre_post_state_expr(fm, enclosing, pres, operand)\n+          || changed;\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = extend_poststate_ann(a, expr_poststate(*operand))\n+          || changed;\n+        ret changed;\n+    }\n     case (expr_fail(?a)) {\n         changed = extend_prestate_ann(a, pres) || changed;\n-        changed = set_poststate_ann(a, true_postcond(num_local_vars))\n+        /* if execution continues after fail, then everything is true! woo! */\n+        changed = set_poststate_ann(a, false_postcond(num_local_vars))\n           || changed;\n+        /*        log_err(\"fail: poststate = \");\n+                  log_bitv(enclosing, expr_poststate(*e)); */\n+        ret changed;\n+    }\n+    case (expr_check_expr(?p, ?a)) {\n+        changed = extend_prestate_ann(a, pres) || changed;\n+        changed = find_pre_post_state_expr(fm, enclosing, pres, p) || changed;\n+        /* p is pure, so the poststate must be the same as the prestate */\n+        changed = extend_poststate_ann(a, pres) || changed;\n         ret changed;\n     }\n+    case (expr_break(?a)) {\n+        ret pure_exp(a, pres);\n+    }\n     case (_) {\n-      log(\"find_pre_post_state_expr: implement this case!\");\n+      log_err(\"find_pre_post_state_expr: implement this case!\");\n+      log_expr_err(*e);\n       fail;\n     }\n   }\n@@ -1442,41 +1649,41 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n   auto stmt_ann_ = stmt_to_ann(*s);\n   check (!is_none[@ts_ann](stmt_ann_));\n   auto stmt_ann = *(get[@ts_ann](stmt_ann_));\n-  /*                  \n-              log(\"*At beginning: stmt = \");\n+  /*\n+              log_err(\"*At beginning: stmt = \");\n               log_stmt(*s);\n-              log(\"*prestate = \");\n-              log(bitv.to_str(stmt_ann.states.prestate));\n-              log(\"*poststate =\");\n-              log(bitv.to_str(stmt_ann.states.poststate));\n-              log(\"*changed =\");\n+              log_err(\"*prestate = \");\n+              log_err(bitv.to_str(stmt_ann.states.prestate));\n+              log_err(\"*poststate =\");\n+              log_err(bitv.to_str(stmt_ann.states.poststate));\n+              log_err(\"*changed =\");\n               log(changed);\n-  */       \n+  */\n   alt (s.node) {\n     case (stmt_decl(?adecl, ?a)) {\n       alt (adecl.node) {\n         case (ast.decl_local(?alocal)) {\n           alt (alocal.init) {\n             case (some[ast.initializer](?an_init)) {\n-              changed = find_pre_post_state_expr\n-                (fm, enclosing, pres, an_init.expr) || changed;\n-              changed = extend_poststate(stmt_ann.states.poststate,\n-                                         expr_poststate(*an_init.expr))\n-                  || changed;\n-              changed = gen_poststate(enclosing, a, alocal.id) || changed;\n-    \n-              /*\n-              log(\"Summary: stmt = \");\n+                changed = extend_prestate(stmt_ann.states.prestate, pres)\n+                    || changed;\n+                changed = find_pre_post_state_expr\n+                    (fm, enclosing, pres, an_init.expr) || changed;\n+                changed = extend_poststate(stmt_ann.states.poststate,\n+                                           expr_poststate(*an_init.expr))\n+                    || changed;\n+                changed = gen_poststate(enclosing, a, alocal.id) || changed;\n+                /*  \n+              log_err(\"Summary: stmt = \");\n               log_stmt(*s);\n-              log(\"prestate = \");\n-              log(bitv.to_str(stmt_ann.states.prestate));\n+              log_err(\"prestate = \");\n+              log_err(bitv.to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n-              log(\"poststate =\");\n+              log_err(\"poststate =\");\n               log_bitv(enclosing, stmt_ann.states.poststate);\n-              log(\"changed =\");\n-              log(changed);\n-              */\n-\n+              log_err(\"changed =\");\n+              log_err(changed);\n+                */\n               ret changed;\n             }\n             case (none[ast.initializer]) {\n@@ -1489,7 +1696,11 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n           }\n         }\n         case (ast.decl_item(?an_item)) {\n-            be find_pre_post_state_item(fm, enclosing, an_item);\n+            changed = extend_prestate(stmt_ann.states.prestate, pres)\n+               || changed;\n+            changed = extend_poststate(stmt_ann.states.poststate, pres)\n+               || changed;\n+            ret (find_pre_post_state_item(fm, enclosing, an_item) || changed);\n         }\n       }\n     }\n@@ -1499,16 +1710,16 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n           || changed;\n       changed = extend_poststate(stmt_ann.states.poststate,\n                                  expr_poststate(*e)) || changed;\n-      /*\n-              log(\"Summary: stmt = \");\n+\n+      /*              log_err(\"Summary: stmt = \");\n               log_stmt(*s);\n-              log(\"prestate = \");\n-              log(bitv.to_str(stmt_ann.states.prestate));\n+              log_err(\"prestate = \");\n+              log_err(bitv.to_str(stmt_ann.states.prestate));\n               log_bitv(enclosing, stmt_ann.states.prestate);\n-              log(\"poststate =\");\n+              log_err(\"poststate =\");\n               log_bitv(enclosing, stmt_ann.states.poststate);\n-              log(\"changed =\");\n-              log(changed);\n+              log_err(\"changed =\");\n+              log_err(changed);\n       */\n       ret changed;\n     }\n@@ -1519,7 +1730,7 @@ fn find_pre_post_state_stmt(&fn_info_map fm, &fn_info enclosing,\n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n-                             &prestate pres0, block b)\n+                             &prestate pres0, &block b)\n   -> bool {\n \n   auto changed = false;\n@@ -1545,8 +1756,20 @@ fn find_pre_post_state_block(&fn_info_map fm, &fn_info enclosing,\n       post = expr_poststate(*e);\n     }\n   }\n-  set_prestate_ann(b.node.a, pres0);\n+  set_prestate_ann(@b.node.a, pres0);\n   set_poststate_ann(b.node.a, post);\n+\n+  /*\n+  log_err(\"For block:\");\n+  log_block(b);\n+  log_err(\"poststate = \");\n+  log_states(block_states(b));\n+  log_err(\"pres0:\");\n+  log_bitv(enclosing, pres0);\n+  log_err(\"post:\");\n+  log_bitv(enclosing, post);\n+  */\n+\n   ret changed;\n }\n \n@@ -1579,12 +1802,12 @@ fn check_states_expr(fn_info enclosing, &expr e) -> () {\n   let prestate pres   = expr_prestate(e);\n \n   if (!implies(pres, prec)) {\n-      log(\"check_states_expr: unsatisfied precondition for \");\n-      log_expr(e);\n-      log(\"Precondition: \");\n-      log_bitv(enclosing, prec);\n-      log(\"Prestate: \");\n-      log_bitv(enclosing, pres);\n+      log_err(\"check_states_expr: unsatisfied precondition for \");\n+      log_expr_err(e);\n+      log_err(\"Precondition: \");\n+      log_bitv_err(enclosing, prec);\n+      log_err(\"Prestate: \");\n+      log_bitv_err(enclosing, pres);\n       fail;\n   }\n }\n@@ -1608,12 +1831,12 @@ fn check_states_stmt(fn_info enclosing, &stmt s) -> () {\n       */\n \n       if (!implies(pres, prec)) {\n-        log(\"check_states_stmt: unsatisfied precondition for \");\n-        log_stmt(s);\n-        log(\"Precondition: \");\n-        log_bitv(enclosing, prec);\n-        log(\"Prestate: \");\n-        log_bitv(enclosing, pres);\n+        log_err(\"check_states_stmt: unsatisfied precondition for \");\n+        log_stmt_err(s);\n+        log_err(\"Precondition: \");\n+        log_bitv_err(enclosing, prec);\n+        log_err(\"Prestate: \");\n+        log_bitv_err(enclosing, pres);\n         fail;\n       }\n     }\n@@ -1680,8 +1903,12 @@ fn check_obj_state(&fn_info_map f_info_map, vec[obj_field] fields,\n fn init_ann(&fn_info fi, ann a) -> ann {\n     alt (a) {\n         case (ann_none) {\n-            log(\"init_ann: shouldn't see ann_none\");\n-            fail;\n+            //            log(\"init_ann: shouldn't see ann_none\");\n+            // fail;\n+            log(\"warning: init_ann: saw ann_none\");\n+            ret a; // Would be better to fail so we can catch bugs that\n+            // result in an uninitialized ann -- but don't want to have to\n+            // write code to handle native_mods properly\n         }\n         case (ann_type(?t,?ps,_)) {\n             ret ann_type(t, ps, some[@ts_ann](@empty_ann(num_locals(fi))));\n@@ -1692,8 +1919,10 @@ fn init_ann(&fn_info fi, ann a) -> ann {\n fn init_blank_ann(&() ignore, ann a) -> ann {\n     alt (a) {\n         case (ann_none) {\n-            log(\"init_ann: shouldn't see ann_none\");\n-            fail;\n+            //            log(\"init_blank_ann: shouldn't see ann_none\");\n+            //fail;\n+            log(\"warning: init_blank_ann: saw ann_none\");\n+            ret a;\n         }\n         case (ann_type(?t,?ps,_)) {\n             ret ann_type(t, ps, some[@ts_ann](@empty_ann(0u)));\n@@ -1706,7 +1935,7 @@ fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n     log_block(respan(sp, b));\n     alt(b.a) {\n         case (ann_none) {\n-            log(\"init_ann: shouldn't see ann_none\");\n+            log(\"init_block: shouldn't see ann_none\");\n             fail;\n         }\n         case (ann_type(?t,?ps,_)) {\n@@ -1730,7 +1959,6 @@ fn item_fn_anns(&fn_info_map fm, &span sp, ident i, &ast._fn f,\n     auto fld0 = fold.new_identity_fold[fn_info]();\n \n     fld0 = @rec(fold_ann = bind init_ann(_,_) \n-                //   fold_block = bind init_block(_,_,_)\n                     with *fld0);\n \n     ret fold.fold_item[fn_info]\n@@ -1999,11 +2227,6 @@ fn annotate_mod(&fn_info_map fm, &ast._mod m) -> ast._mod {\n     }\n     ret rec(items=new_items, index=new_index with m);\n }\n-fn annotate_native_mod(&fn_info_map fm, &ast.native_mod m)\n-       -> ast.native_mod {\n-    log(\"implement annotate_native_mod!\");\n-    fail;\n-}\n fn annotate_method(&fn_info_map fm, &@method m) -> @method {\n     auto f_info = get_fn_info(fm, m.node.id);\n     auto fld0 = fold.new_identity_fold[fn_info]();\n@@ -2044,9 +2267,7 @@ fn annotate_item_inner(&fn_info_map fm, &@ast.item item) -> @ast.item {\n                        ast.item_mod(ident, annotate_mod(fm, mm), id));\n         }\n         case (ast.item_native_mod(?ident, ?mm, ?id)) {\n-            ret @respan(item.span,\n-                  ast.item_native_mod(ident, \n-                    annotate_native_mod(fm, mm), id));\n+            ret item;\n         }\n         case (ast.item_ty(_,_,_,_,_)) {\n             ret item;\n@@ -2090,6 +2311,9 @@ fn annotate_item(&fn_info_map fm, &@ast.item item) -> @ast.item {\n             auto outer = fold.fold_item[()]((), fld0, item);\n             ret annotate_item_inner(fm, outer);\n         }\n+        case (ast.item_native_mod(?i, ?nm, ?id)) {\n+            ret item;\n+        }\n         case (ast.item_ty(_,_,_,_,_)) {\n             ret item;\n         }"}, {"sha": "d2ed72a0ff3411603d6ee9272d7b82ab81494261", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f8cb45924326e21547d19cbed683115657616/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f8cb45924326e21547d19cbed683115657616/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=7c4f8cb45924326e21547d19cbed683115657616", "patch": "@@ -98,9 +98,9 @@ fn uistr(uint i) -> str {\n \n fn elt_expr(&ast.elt e) -> @ast.expr { ret e.expr; }\n \n-fn elt_exprs(vec[ast.elt] elts) -> vec[@ast.expr] {\n+fn elt_exprs(&vec[ast.elt] elts) -> vec[@ast.expr] {\n     auto f = elt_expr;\n-    be _vec.map[ast.elt, @ast.expr](f, elts);\n+    ret _vec.map[ast.elt, @ast.expr](f, elts);\n }\n \n fn field_expr(&ast.field f) -> @ast.expr { ret f.expr; }\n@@ -115,26 +115,41 @@ fn plain_ann(middle.ty.ctxt tcx) -> ast.ann {\n                    none[vec[middle.ty.t]], none[@ts_ann]);\n }\n \n-fn log_expr(&ast.expr e) -> () {\n+fn expr_to_str(&ast.expr e) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front.lexer.cmnt]],\n                   mutable cur_cmnt=0u);\n-\n   print_expr(out, @e);\n-  log(s.get_str());\n+  ret s.get_str();\n }\n \n-fn log_block(&ast.block b) -> () {\n+fn log_expr(&ast.expr e) -> () {\n+    log(expr_to_str(e));\n+}\n+\n+fn log_expr_err(&ast.expr e) -> () {\n+    log_err(expr_to_str(e));\n+}\n+\n+fn block_to_str(&ast.block b) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front.lexer.cmnt]],\n                   mutable cur_cmnt=0u);\n \n   print_block(out, b);\n-  log(s.get_str());\n+  ret s.get_str();\n+}\n+\n+fn log_block(&ast.block b) -> () {\n+    log(block_to_str(b));\n+}\n+\n+fn log_block_err(&ast.block b) -> () {\n+    log_err(block_to_str(b));\n }\n \n fn log_ann(&ast.ann a) -> () {\n@@ -148,7 +163,7 @@ fn log_ann(&ast.ann a) -> () {\n     }\n }\n \n-fn log_stmt(ast.stmt st) -> () {\n+fn stmt_to_str(&ast.stmt st) -> str {\n   let str_writer s = string_writer();\n   auto out_ = mkstate(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n@@ -163,7 +178,48 @@ fn log_stmt(ast.stmt st) -> () {\n     }\n     case (_) { /* do nothing */ }\n   }\n-  log(s.get_str());\n+  ret s.get_str();\n+}\n+\n+fn log_stmt(&ast.stmt st) -> () {\n+    log(stmt_to_str(st));\n+}\n+\n+fn log_stmt_err(&ast.stmt st) -> () {\n+    log_err(stmt_to_str(st));\n+}\n+\n+fn decl_lhs(@ast.decl d) -> ast.def_id {\n+    alt (d.node) {\n+        case (ast.decl_local(?l)) {\n+            ret l.id;\n+        }\n+        case (ast.decl_item(?an_item)) {\n+            alt (an_item.node) {\n+                case (ast.item_const(_,_,_,?d,_)) {\n+                    ret d;\n+                }\n+                case (ast.item_fn(_,_,_,?d,_)) {\n+                    ret d;\n+                }\n+                case (ast.item_mod(_,_,?d)) {\n+                    ret d;\n+                }\n+                case (ast.item_native_mod(_,_,?d)) {\n+                    ret d;\n+                }\n+                case (ast.item_ty(_,_,_,?d,_)) {\n+                    ret d;\n+                }\n+                case (ast.item_tag(_,_,_,?d,_)) {\n+                    ret d;\n+                }\n+                case (ast.item_obj(_,_,_,?d,_)) {\n+                    ret d.ctor; /* This doesn't really make sense */\n+                }\n+            }\n+        } \n+    }\n }\n \n //"}, {"sha": "b7fbc3cc25d5858c2d00723756614c43f4b182b3", "filename": "src/comp/util/typestate_ann.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f8cb45924326e21547d19cbed683115657616/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f8cb45924326e21547d19cbed683115657616/src%2Fcomp%2Futil%2Ftypestate_ann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ftypestate_ann.rs?ref=7c4f8cb45924326e21547d19cbed683115657616", "patch": "@@ -44,6 +44,10 @@ fn empty_poststate(uint num_vars) -> poststate {\n   be true_precond(num_vars);\n }\n \n+fn false_postcond(uint num_vars) -> postcond {\n+    be bitv.create(num_vars, true);\n+}\n+\n fn empty_pre_post(uint num_vars) -> pre_and_post {\n   ret(rec(precondition=empty_prestate(num_vars),\n           postcondition=empty_poststate(num_vars)));\n@@ -119,7 +123,7 @@ fn set_postcondition(&ts_ann a, &postcond p) -> () {\n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n-fn set_prestate(&ts_ann a, &prestate p) -> bool {\n+fn set_prestate(@ts_ann a, &prestate p) -> bool {\n   ret bitv.copy(a.states.prestate, p);\n }\n \n@@ -139,6 +143,13 @@ fn extend_poststate(&poststate p, &poststate new) -> bool {\n   ret bitv.union(p, new);\n }\n \n+// Clears the given bit in p\n+fn relax_prestate(uint i, &prestate p) -> bool {\n+    auto was_set = bitv.get(p, i);\n+    bitv.set(p, i, false);\n+    ret was_set;\n+}\n+\n fn ann_precond(&ts_ann a) -> precond {\n   ret a.conditions.precondition;\n }\n@@ -148,8 +159,12 @@ fn ann_prestate(&ts_ann a) -> prestate {\n }\n \n fn pp_clone(&pre_and_post p) -> pre_and_post {\n-  ret rec(precondition=bitv.clone(p.precondition),\n-          postcondition=bitv.clone(p.postcondition));\n+  ret rec(precondition=clone(p.precondition),\n+          postcondition=clone(p.postcondition));\n+}\n+\n+fn clone(prestate p) -> prestate {\n+    ret bitv.clone(p);\n }\n \n // returns true if a implies b"}, {"sha": "3718ac357e06c929a68a805e330ee57a458fc520", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f8cb45924326e21547d19cbed683115657616/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f8cb45924326e21547d19cbed683115657616/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=7c4f8cb45924326e21547d19cbed683115657616", "patch": "@@ -282,6 +282,21 @@ fn plus_option[T](&vec[T] v, &option.t[T] o) -> () {\n     }\n }\n \n+fn cat_options[T](&vec[option.t[T]] v) -> vec[T] {\n+    let vec[T] res = vec();\n+\n+    for (option.t[T] o in v) {\n+        alt (o) {\n+            case (none[T]) { }\n+            case (some[T](?t)) {\n+                res += vec(t);\n+            }\n+        }\n+    }\n+\n+    ret res;\n+}\n+\n // TODO: Remove in favor of built-in \"freeze\" operation when it's implemented.\n fn freeze[T](vec[mutable T] v) -> vec[T] {\n     let vec[T] result = vec();"}, {"sha": "a7c77bba2eaac71c4275c6d98a3235ca79ef8c3a", "filename": "src/test/run-pass/use-uninit-alt.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f8cb45924326e21547d19cbed683115657616/src%2Ftest%2Frun-pass%2Fuse-uninit-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f8cb45924326e21547d19cbed683115657616/src%2Ftest%2Frun-pass%2Fuse-uninit-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-uninit-alt.rs?ref=7c4f8cb45924326e21547d19cbed683115657616", "patch": "@@ -0,0 +1,21 @@\n+fn foo[T](&myoption[T] o) -> int {\n+  let int x = 5;\n+\n+  alt (o) {\n+    case (none[T]) { }\n+    case (some[T](?t)) {\n+      x += 1;\n+    }\n+  }\n+  \n+  ret x;\n+}\n+\n+tag myoption[T] {\n+  none;\n+  some(T);\n+}\n+\n+fn main() {\n+  log(5);\n+}\n\\ No newline at end of file"}, {"sha": "36514d13ce1393b58d1fb29759a621a30224c218", "filename": "src/test/run-pass/use-uninit-alt2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7c4f8cb45924326e21547d19cbed683115657616/src%2Ftest%2Frun-pass%2Fuse-uninit-alt2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4f8cb45924326e21547d19cbed683115657616/src%2Ftest%2Frun-pass%2Fuse-uninit-alt2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-uninit-alt2.rs?ref=7c4f8cb45924326e21547d19cbed683115657616", "patch": "@@ -0,0 +1,21 @@\n+fn foo[T](&myoption[T] o) -> int {\n+  let int x;\n+\n+  alt (o) {\n+    case (none[T]) { fail; }\n+    case (some[T](?t)) {\n+      x = 5;\n+    }\n+  }\n+  \n+  ret x;\n+}\n+\n+tag myoption[T] {\n+  none;\n+  some(T);\n+}\n+\n+fn main() {\n+  log(5);\n+}\n\\ No newline at end of file"}]}