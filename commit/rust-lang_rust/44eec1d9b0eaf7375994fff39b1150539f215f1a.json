{"sha": "44eec1d9b0eaf7375994fff39b1150539f215f1a", "node_id": "C_kwDOAAsO6NoAKDQ0ZWVjMWQ5YjBlYWY3Mzc1OTk0ZmZmMzliMTE1MDUzOWYyMTVmMWE", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-02-26T06:47:20Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-03-01T22:42:06Z"}, "message": "Merge two different equality specialization traits in `core`", "tree": {"sha": "9d1d91263390a8c1e76e740002f2489020e49b9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d1d91263390a8c1e76e740002f2489020e49b9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44eec1d9b0eaf7375994fff39b1150539f215f1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44eec1d9b0eaf7375994fff39b1150539f215f1a", "html_url": "https://github.com/rust-lang/rust/commit/44eec1d9b0eaf7375994fff39b1150539f215f1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44eec1d9b0eaf7375994fff39b1150539f215f1a/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5c7d2b37780dac1092e75f12ab97dd56c30861d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5c7d2b37780dac1092e75f12ab97dd56c30861d", "html_url": "https://github.com/rust-lang/rust/commit/c5c7d2b37780dac1092e75f12ab97dd56c30861d"}], "stats": {"total": 276, "additions": 182, "deletions": 94}, "files": [{"sha": "d749865f76f518fb26d87ccb901aacf69f5e7a6d", "filename": "library/core/src/array/equality.rs", "status": "modified", "additions": 6, "deletions": 67, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Farray%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fequality.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -1,6 +1,5 @@\n+use crate::cmp::BytewiseEq;\n use crate::convert::TryInto;\n-use crate::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n-use crate::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A, B, const N: usize> PartialEq<[B; N]> for [A; N]\n@@ -144,74 +143,14 @@ impl<T: PartialEq<Other>, Other, const N: usize> SpecArrayEq<Other, N> for T {\n     }\n }\n \n-impl<T: IsRawEqComparable<U>, U, const N: usize> SpecArrayEq<U, N> for T {\n+impl<T: BytewiseEq<U>, U, const N: usize> SpecArrayEq<U, N> for T {\n     fn spec_eq(a: &[T; N], b: &[U; N]) -> bool {\n-        // SAFETY: This is why `IsRawEqComparable` is an `unsafe trait`.\n-        unsafe {\n-            let b = &*b.as_ptr().cast::<[T; N]>();\n-            crate::intrinsics::raw_eq(a, b)\n-        }\n+        // SAFETY: Arrays are compared element-wise, and don't add any padding\n+        // between elements, so when the elements are `BytewiseEq`, we can\n+        // compare the entire array at once.\n+        unsafe { crate::intrinsics::raw_eq(a, crate::mem::transmute(b)) }\n     }\n     fn spec_ne(a: &[T; N], b: &[U; N]) -> bool {\n         !Self::spec_eq(a, b)\n     }\n }\n-\n-/// `U` exists on here mostly because `min_specialization` didn't let me\n-/// repeat the `T` type parameter in the above specialization, so instead\n-/// the `T == U` constraint comes from the impls on this.\n-/// # Safety\n-/// - Neither `Self` nor `U` has any padding.\n-/// - `Self` and `U` have the same layout.\n-/// - `Self: PartialEq<U>` is byte-wise (this means no floats, among other things)\n-#[rustc_specialization_trait]\n-unsafe trait IsRawEqComparable<U>: PartialEq<U> {}\n-\n-macro_rules! is_raw_eq_comparable {\n-    ($($t:ty),+ $(,)?) => {$(\n-        unsafe impl IsRawEqComparable<$t> for $t {}\n-    )+};\n-}\n-\n-// SAFETY: All the ordinary integer types have no padding, and are not pointers.\n-is_raw_eq_comparable!(u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\n-\n-// SAFETY: bool and char have *niches*, but no *padding* (and these are not pointer types), so this\n-// is sound\n-is_raw_eq_comparable!(bool, char);\n-\n-// SAFETY: Similarly, the non-zero types have a niche, but no undef and no pointers,\n-// and they compare like their underlying numeric type.\n-is_raw_eq_comparable!(\n-    NonZeroU8,\n-    NonZeroU16,\n-    NonZeroU32,\n-    NonZeroU64,\n-    NonZeroU128,\n-    NonZeroUsize,\n-    NonZeroI8,\n-    NonZeroI16,\n-    NonZeroI32,\n-    NonZeroI64,\n-    NonZeroI128,\n-    NonZeroIsize,\n-);\n-\n-// SAFETY: The NonZero types have the \"null\" optimization guaranteed, and thus\n-// are also safe to equality-compare bitwise inside an `Option`.\n-// The way `PartialOrd` is defined for `Option` means that this wouldn't work\n-// for `<` or `>` on the signed types, but since we only do `==` it's fine.\n-is_raw_eq_comparable!(\n-    Option<NonZeroU8>,\n-    Option<NonZeroU16>,\n-    Option<NonZeroU32>,\n-    Option<NonZeroU64>,\n-    Option<NonZeroU128>,\n-    Option<NonZeroUsize>,\n-    Option<NonZeroI8>,\n-    Option<NonZeroI16>,\n-    Option<NonZeroI32>,\n-    Option<NonZeroI64>,\n-    Option<NonZeroI128>,\n-    Option<NonZeroIsize>,\n-);"}, {"sha": "5b5f55d0e65b0679007bded9e455b235fa4d184a", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -22,6 +22,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+mod bytewise;\n+pub(crate) use bytewise::BytewiseEq;\n+\n use crate::marker::Destruct;\n \n use self::Ordering::*;"}, {"sha": "2548d9e24c9dbd50a6664522a0d0d82e81f6a849", "filename": "library/core/src/cmp/bytewise.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fcmp%2Fbytewise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fcmp%2Fbytewise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp%2Fbytewise.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -0,0 +1,83 @@\n+use crate::num::{NonZeroI128, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI8, NonZeroIsize};\n+use crate::num::{NonZeroU128, NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU8, NonZeroUsize};\n+\n+/// Types where `==` & `!=` are equivalent to comparing their underlying bytes.\n+///\n+/// Importantly, this means no floating-point types, as those have different\n+/// byte representations (like `-0` and `+0`) which compare as the same.\n+/// Since byte arrays are `Eq`, that implies that these types are probably also\n+/// `Eq`, but that's not technically required to use this trait.\n+///\n+/// `Rhs` is *de facto* always `Self`, but the separate parameter is important\n+/// to avoid the `specializing impl repeats parameter` error when consuming this.\n+///\n+/// # Safety\n+///\n+/// - `Self` and `Rhs` have no padding.\n+/// - `Self` and `Rhs` have the same layout (size and alignment).\n+/// - Neither `Self` nor `Rhs` have provenance, so integer comparisons are correct.\n+/// - `<Self as PartialEq<Rhs>>::{eq,ne}` are equivalent to comparing the bytes.\n+#[rustc_specialization_trait]\n+pub(crate) unsafe trait BytewiseEq<Rhs = Self>: PartialEq<Rhs> + Sized {}\n+\n+macro_rules! is_bytewise_comparable {\n+    ($($t:ty),+ $(,)?) => {$(\n+        unsafe impl BytewiseEq for $t {}\n+    )+};\n+}\n+\n+// SAFETY: All the ordinary integer types have no padding, and are not pointers.\n+is_bytewise_comparable!(u8, u16, u32, u64, u128, usize, i8, i16, i32, i64, i128, isize);\n+\n+// SAFETY: These have *niches*, but no *padding* and no *provenance*,\n+// so we can compare them directly.\n+is_bytewise_comparable!(bool, char, super::Ordering);\n+\n+// SAFETY: Similarly, the non-zero types have a niche, but no undef and no pointers,\n+// and they compare like their underlying numeric type.\n+is_bytewise_comparable!(\n+    NonZeroU8,\n+    NonZeroU16,\n+    NonZeroU32,\n+    NonZeroU64,\n+    NonZeroU128,\n+    NonZeroUsize,\n+    NonZeroI8,\n+    NonZeroI16,\n+    NonZeroI32,\n+    NonZeroI64,\n+    NonZeroI128,\n+    NonZeroIsize,\n+);\n+\n+// SAFETY: The NonZero types have the \"null\" optimization guaranteed, and thus\n+// are also safe to equality-compare bitwise inside an `Option`.\n+// The way `PartialOrd` is defined for `Option` means that this wouldn't work\n+// for `<` or `>` on the signed types, but since we only do `==` it's fine.\n+is_bytewise_comparable!(\n+    Option<NonZeroU8>,\n+    Option<NonZeroU16>,\n+    Option<NonZeroU32>,\n+    Option<NonZeroU64>,\n+    Option<NonZeroU128>,\n+    Option<NonZeroUsize>,\n+    Option<NonZeroI8>,\n+    Option<NonZeroI16>,\n+    Option<NonZeroI32>,\n+    Option<NonZeroI64>,\n+    Option<NonZeroI128>,\n+    Option<NonZeroIsize>,\n+);\n+\n+macro_rules! is_bytewise_comparable_array_length {\n+    ($($n:literal),+ $(,)?) => {$(\n+        // SAFETY: Arrays have no padding between elements, so if the elements are\n+        // `BytewiseEq`, then the whole array can be too.\n+        unsafe impl<T: BytewiseEq<U>, U> BytewiseEq<[U; $n]> for [T; $n] {}\n+    )+};\n+}\n+\n+// Frustratingly, this can't be made const-generic as it gets\n+//    error: specializing impl repeats parameter `N`\n+// so just do it for a couple of plausibly-common ones.\n+is_bytewise_comparable_array_length!(0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64);"}, {"sha": "18a90599c4db9994c404aefd68dcd61f1d36f4ec", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -2093,6 +2093,10 @@ extern \"rust-intrinsic\" {\n     /// Above some backend-decided threshold this will emit calls to `memcmp`,\n     /// like slice equality does, instead of causing massive code size.\n     ///\n+    /// Since this works by comparing the underlying bytes, the actual `T` is\n+    /// not particularly important.  It will be used for its size and alignment,\n+    /// but any validity restrictions will be ignored, not enforced.\n+    ///\n     /// # Safety\n     ///\n     /// It's UB to call this if any of the *bytes* in `*a` or `*b` are uninitialized or carry a"}, {"sha": "7601dd3c75608f9abcae2cb61252cdc609e552e3", "filename": "library/core/src/slice/cmp.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fcmp.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -1,6 +1,6 @@\n //! Comparison traits for `[T]`.\n \n-use crate::cmp::{self, Ordering};\n+use crate::cmp::{self, BytewiseEq, Ordering};\n use crate::ffi;\n use crate::mem;\n \n@@ -77,7 +77,7 @@ where\n // Use memcmp for bytewise equality when the types allow\n impl<A, B> SlicePartialEq<B> for [A]\n where\n-    A: BytewiseEquality<B>,\n+    A: BytewiseEq<B>,\n {\n     fn equal(&self, other: &[B]) -> bool {\n         if self.len() != other.len() {\n@@ -203,29 +203,6 @@ impl SliceOrd for u8 {\n     }\n }\n \n-// Hack to allow specializing on `Eq` even though `Eq` has a method.\n-#[rustc_unsafe_specialization_marker]\n-trait MarkerEq<T>: PartialEq<T> {}\n-\n-impl<T: Eq> MarkerEq<T> for T {}\n-\n-#[doc(hidden)]\n-/// Trait implemented for types that can be compared for equality using\n-/// their bytewise representation\n-#[rustc_specialization_trait]\n-trait BytewiseEquality<T>: MarkerEq<T> + Copy {}\n-\n-macro_rules! impl_marker_for {\n-    ($traitname:ident, $($ty:ty)*) => {\n-        $(\n-            impl $traitname<$ty> for $ty { }\n-        )*\n-    }\n-}\n-\n-impl_marker_for!(BytewiseEquality,\n-                 u8 i8 u16 i16 u32 i32 u64 i64 u128 i128 usize isize char bool);\n-\n pub(super) trait SliceContains: Sized {\n     fn slice_contains(&self, x: &[Self]) -> bool;\n }"}, {"sha": "abfe295f8b677fa993e8b6bfa05d0e512415caee", "filename": "tests/codegen/array-equality.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/tests%2Fcodegen%2Farray-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/tests%2Fcodegen%2Farray-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Farray-equality.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O\n+// compile-flags: -O -Z merge-functions=disabled\n // only-x86_64\n \n #![crate_type = \"lib\"]\n@@ -43,6 +43,15 @@ pub fn array_eq_long(a: &[u16; 1234], b: &[u16; 1234]) -> bool {\n     a == b\n }\n \n+// CHECK-LABEL: @array_char_eq\n+#[no_mangle]\n+pub fn array_char_eq(a: [char; 2], b: [char; 2]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i64 %0, %1\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n+    a == b\n+}\n+\n // CHECK-LABEL: @array_eq_zero_short(i48\n #[no_mangle]\n pub fn array_eq_zero_short(x: [u16; 3]) -> bool {\n@@ -52,6 +61,25 @@ pub fn array_eq_zero_short(x: [u16; 3]) -> bool {\n     x == [0; 3]\n }\n \n+// CHECK-LABEL: @array_eq_none_short(i40\n+#[no_mangle]\n+pub fn array_eq_none_short(x: [Option<std::num::NonZeroU8>; 5]) -> bool {\n+    // CHECK-NEXT: start:\n+    // CHECK-NEXT: %[[EQ:.+]] = icmp eq i40 %0, 0\n+    // CHECK-NEXT: ret i1 %[[EQ]]\n+    x == [None; 5]\n+}\n+\n+// CHECK-LABEL: @array_eq_zero_nested(\n+#[no_mangle]\n+pub fn array_eq_zero_nested(x: [[u8; 3]; 3]) -> bool {\n+    // CHECK: %[[VAL:.+]] = load i72\n+    // CHECK-SAME: align 1\n+    // CHECK: %[[EQ:.+]] = icmp eq i72 %[[VAL]], 0\n+    // CHECK: ret i1 %[[EQ]]\n+    x == [[0; 3]; 3]\n+}\n+\n // CHECK-LABEL: @array_eq_zero_mid(\n #[no_mangle]\n pub fn array_eq_zero_mid(x: [u16; 8]) -> bool {"}, {"sha": "8f0adab35e710523126d59190fea80c8b5e1f0b6", "filename": "tests/codegen/slice-ref-equality.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/44eec1d9b0eaf7375994fff39b1150539f215f1a/tests%2Fcodegen%2Fslice-ref-equality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eec1d9b0eaf7375994fff39b1150539f215f1a/tests%2Fcodegen%2Fslice-ref-equality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fslice-ref-equality.rs?ref=44eec1d9b0eaf7375994fff39b1150539f215f1a", "patch": "@@ -1,7 +1,10 @@\n-// compile-flags: -C opt-level=3 -Zmerge-functions=disabled\n+// compile-flags: -O -Zmerge-functions=disabled\n+// ignore-debug (the extra assertions get in the way)\n \n #![crate_type = \"lib\"]\n \n+use std::num::{NonZeroI16, NonZeroU32};\n+\n // #71602 reported a simple array comparison just generating a loop.\n // This was originally fixed by ensuring it generates a single bcmp,\n // but we now generate it as a load+icmp instead. `is_zero_slice` was\n@@ -36,3 +39,54 @@ pub fn is_zero_array(data: &[u8; 4]) -> bool {\n     // CHECK-NEXT: ret i1 %[[EQ]]\n     *data == [0; 4]\n }\n+\n+// The following test the extra specializations to make sure that slice\n+// equality for non-byte types also just emit a `bcmp`, not a loop.\n+\n+// CHECK-LABEL: @eq_slice_of_nested_u8(\n+// CHECK-SAME: [[USIZE:i16|i32|i64]] noundef %1\n+// CHECK-SAME: [[USIZE]] noundef %3\n+#[no_mangle]\n+fn eq_slice_of_nested_u8(x: &[[u8; 3]], y: &[[u8; 3]]) -> bool {\n+    // CHECK: icmp eq [[USIZE]] %1, %3\n+    // CHECK: %[[BYTES:.+]] = mul nsw [[USIZE]] %1, 3\n+    // CHECK: tail call{{( noundef)?}} i32 @{{bcmp|memcmp}}({{i8\\*|ptr}}\n+    // CHECK-SAME: , [[USIZE]]{{( noundef)?}} %[[BYTES]])\n+    x == y\n+}\n+\n+// CHECK-LABEL: @eq_slice_of_i32(\n+// CHECK-SAME: [[USIZE:i16|i32|i64]] noundef %1\n+// CHECK-SAME: [[USIZE]] noundef %3\n+#[no_mangle]\n+fn eq_slice_of_i32(x: &[i32], y: &[i32]) -> bool {\n+    // CHECK: icmp eq [[USIZE]] %1, %3\n+    // CHECK: %[[BYTES:.+]] = shl nsw [[USIZE]] %1, 2\n+    // CHECK: tail call{{( noundef)?}} i32 @{{bcmp|memcmp}}({{i32\\*|ptr}}\n+    // CHECK-SAME: , [[USIZE]]{{( noundef)?}} %[[BYTES]])\n+    x == y\n+}\n+\n+// CHECK-LABEL: @eq_slice_of_nonzero(\n+// CHECK-SAME: [[USIZE:i16|i32|i64]] noundef %1\n+// CHECK-SAME: [[USIZE]] noundef %3\n+#[no_mangle]\n+fn eq_slice_of_nonzero(x: &[NonZeroU32], y: &[NonZeroU32]) -> bool {\n+    // CHECK: icmp eq [[USIZE]] %1, %3\n+    // CHECK: %[[BYTES:.+]] = shl nsw [[USIZE]] %1, 2\n+    // CHECK: tail call{{( noundef)?}} i32 @{{bcmp|memcmp}}({{i32\\*|ptr}}\n+    // CHECK-SAME: , [[USIZE]]{{( noundef)?}} %[[BYTES]])\n+    x == y\n+}\n+\n+// CHECK-LABEL: @eq_slice_of_option_of_nonzero(\n+// CHECK-SAME: [[USIZE:i16|i32|i64]] noundef %1\n+// CHECK-SAME: [[USIZE]] noundef %3\n+#[no_mangle]\n+fn eq_slice_of_option_of_nonzero(x: &[Option<NonZeroI16>], y: &[Option<NonZeroI16>]) -> bool {\n+    // CHECK: icmp eq [[USIZE]] %1, %3\n+    // CHECK: %[[BYTES:.+]] = shl nsw [[USIZE]] %1, 1\n+    // CHECK: tail call{{( noundef)?}} i32 @{{bcmp|memcmp}}({{i16\\*|ptr}}\n+    // CHECK-SAME: , [[USIZE]]{{( noundef)?}} %[[BYTES]])\n+    x == y\n+}"}]}