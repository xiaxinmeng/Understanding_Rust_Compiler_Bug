{"sha": "6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMWJhN2MxYmMxYTExMTNiNjhjNzEwMDg5NGYzM2YyZmI1ZjdlYmY=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-28T01:39:20Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-05-28T01:39:59Z"}, "message": "Fix needless_collect with binding shadowing", "tree": {"sha": "b3fe21ae73c76b21ae770b18b5f37cd4786588cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3fe21ae73c76b21ae770b18b5f37cd4786588cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf", "html_url": "https://github.com/rust-lang/rust/commit/6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "543a8a6aac8b346c75dc69cb5b7945a52f72ffe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/543a8a6aac8b346c75dc69cb5b7945a52f72ffe7", "html_url": "https://github.com/rust-lang/rust/commit/543a8a6aac8b346c75dc69cb5b7945a52f72ffe7"}], "stats": {"total": 79, "additions": 35, "deletions": 44}, "files": [{"sha": "b3992157cd42ad25864b281b3b104f12b613aba8", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=6c1ba7c1bc1a1113b68c7100894f33f2fb5f7ebf", "patch": "@@ -7,10 +7,10 @@ use clippy_utils::{is_trait_method, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, Local, Pat, PatKind, QPath, StmtKind, Ty};\n+use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, PatKind, StmtKind, Ty};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n@@ -88,24 +88,23 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n     if let ExprKind::Block(block, _) = expr.kind {\n         for stmt in block.stmts {\n             if_chain! {\n-                if let StmtKind::Local(\n-                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(init_expr), ty, .. }\n-                ) = stmt.kind;\n+                if let StmtKind::Local(local) = stmt.kind;\n+                if let PatKind::Binding(_, id, ..) = local.pat.kind;\n+                if let Some(init_expr) = local.init;\n                 if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                if let Some(hir_id) = get_hir_id(*ty, method_name.args);\n+                if let Some(hir_id) = get_hir_id(local.ty, method_name.args);\n                 if let Some(ty) = cx.typeck_results().node_type_opt(hir_id);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n-                        id: *pat_id,\n+                        id,\n                         count: 0,\n                     };\n                     walk_block(&mut used_count_visitor, block);\n@@ -187,48 +186,40 @@ enum IterFunctionKind {\n struct IterFunctionVisitor {\n     uses: Vec<IterFunction>,\n     seen_other: bool,\n-    target: Ident,\n+    target: HirId,\n }\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. }) = args.get(0);\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                let len = sym!(len);\n-                let is_empty = sym!(is_empty);\n-                let contains = sym!(contains);\n-                match method_name.ident.name {\n-                    sym::into_iter => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n-                    ),\n-                    name if name == len => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n-                    ),\n-                    name if name == is_empty => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n-                    ),\n-                    name if name == contains => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n-                    ),\n+        if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if path_to_local_id(recv, self.target) {\n+                match &*method_name.ident.name.as_str() {\n+                    \"into_iter\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IntoIter,\n+                        span: expr.span,\n+                    }),\n+                    \"len\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Len,\n+                        span: expr.span,\n+                    }),\n+                    \"is_empty\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IsEmpty,\n+                        span: expr.span,\n+                    }),\n+                    \"contains\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Contains(args[0].span),\n+                        span: expr.span,\n+                    }),\n                     _ => self.seen_other = true,\n                 }\n-                return\n+                return;\n             }\n         }\n         // Check if the collection is used for anything else\n-        if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. } = expr;\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                self.seen_other = true;\n-            } else {\n-                walk_expr(self, expr);\n-            }\n+        if path_to_local_id(expr, self.target) {\n+            self.seen_other = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n     }\n \n@@ -262,10 +253,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n-        target: identifier,\n+        target: id,\n         seen_other: false,\n     };\n     visitor.visit_block(block);"}]}