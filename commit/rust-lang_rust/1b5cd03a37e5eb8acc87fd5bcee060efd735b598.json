{"sha": "1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "node_id": "C_kwDOAAsO6NoAKDFiNWNkMDNhMzdlNWViOGFjYzg3ZmQ1YmNlZTA2MGVmZDczNWI1OTg", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-07T19:30:28Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-02-07T19:30:28Z"}, "message": "Actually check in fixup.rs", "tree": {"sha": "35e4e33f6639cb82ed355a3888e88fe872d9e722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35e4e33f6639cb82ed355a3888e88fe872d9e722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "html_url": "https://github.com/rust-lang/rust/commit/1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3601e9860e533c7990d90dbd773a49039bb037e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3601e9860e533c7990d90dbd773a49039bb037e", "html_url": "https://github.com/rust-lang/rust/commit/c3601e9860e533c7990d90dbd773a49039bb037e"}], "stats": {"total": 140, "additions": 140, "deletions": 0}, "files": [{"sha": "11ae5c67214d3f3798e75ca6fb9db4309853ae77", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "patch": "@@ -526,6 +526,7 @@ dependencies = [\n  \"cfg\",\n  \"cov-mark\",\n  \"either\",\n+ \"expect-test\",\n  \"hashbrown 0.12.0\",\n  \"itertools\",\n  \"la-arena\","}, {"sha": "d7b4cbf82e2e83ce5284c8d53755b5abb4943ec8", "filename": "crates/hir_expand/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/crates%2Fhir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/crates%2Fhir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2FCargo.toml?ref=1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "patch": "@@ -27,3 +27,6 @@ profile = { path = \"../profile\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }\n mbe = { path = \"../mbe\", version = \"0.0.0\" }\n limit = { path = \"../limit\", version = \"0.0.0\" }\n+\n+[dev-dependencies]\n+expect-test = \"1.2.0-pre.1\""}, {"sha": "f82fba46e9dd616cdb356994670463567a609564", "filename": "crates/hir_expand/src/fixup.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/crates%2Fhir_expand%2Fsrc%2Ffixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b5cd03a37e5eb8acc87fd5bcee060efd735b598/crates%2Fhir_expand%2Fsrc%2Ffixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Ffixup.rs?ref=1b5cd03a37e5eb8acc87fd5bcee060efd735b598", "patch": "@@ -0,0 +1,136 @@\n+use mbe::SyntheticToken;\n+use rustc_hash::FxHashMap;\n+use syntax::{\n+    ast::{self, AstNode},\n+    match_ast, SyntaxKind, SyntaxNode, SyntaxToken,\n+};\n+use tt::{Leaf, Subtree};\n+\n+#[derive(Debug)]\n+pub struct SyntaxFixups {\n+    pub append: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+    pub replace: FxHashMap<SyntaxNode, Vec<SyntheticToken>>,\n+}\n+\n+pub fn fixup_syntax(node: &SyntaxNode) -> SyntaxFixups {\n+    let mut append = FxHashMap::default();\n+    let mut replace = FxHashMap::default();\n+    let mut preorder = node.preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            syntax::WalkEvent::Enter(node) => node,\n+            syntax::WalkEvent::Leave(_) => continue,\n+        };\n+        if node.kind() == SyntaxKind::ERROR {\n+            // TODO this might not be helpful\n+            replace.insert(node, Vec::new());\n+            preorder.skip_subtree();\n+            continue;\n+        }\n+        match_ast! {\n+            match node {\n+                ast::FieldExpr(it) => {\n+                    if it.name_ref().is_none() {\n+                        // incomplete field access: some_expr.|\n+                        append.insert(node.clone(), vec![(SyntaxKind::IDENT, \"__ra_fixup\".into())]);\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+    SyntaxFixups { append, replace }\n+}\n+\n+pub fn reverse_fixups(tt: &mut Subtree) {\n+    tt.token_trees.retain(|tt| match tt {\n+        tt::TokenTree::Leaf(Leaf::Ident(ident)) => ident.text != \"__ra_fixup\",\n+        _ => true,\n+    });\n+    tt.token_trees.iter_mut().for_each(|tt| match tt {\n+        tt::TokenTree::Subtree(tt) => reverse_fixups(tt),\n+        _ => {}\n+    });\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{Expect, expect};\n+\n+    use super::reverse_fixups;\n+\n+    #[track_caller]\n+    fn check(ra_fixture: &str, mut expect: Expect) {\n+        let parsed = syntax::SourceFile::parse(ra_fixture);\n+        let fixups = super::fixup_syntax(&parsed.syntax_node());\n+        let (mut tt, _tmap) = mbe::syntax_node_to_token_tree_censored(\n+            &parsed.syntax_node(),\n+            fixups.replace,\n+            fixups.append,\n+        );\n+\n+        let mut actual = tt.to_string();\n+        actual.push_str(\"\\n\");\n+\n+        expect.indent(false);\n+        expect.assert_eq(&actual);\n+\n+        // the fixed-up tree should be syntactically valid\n+        let (parse, _) = mbe::token_tree_to_syntax_node(&tt, ::mbe::TopEntryPoint::MacroItems);\n+        assert_eq!(parse.errors(), &[], \"parse has syntax errors. parse tree:\\n{:#?}\", parse.syntax_node());\n+\n+        reverse_fixups(&mut tt);\n+\n+        // the fixed-up + reversed version should be equivalent to the original input\n+        // (but token IDs don't matter)\n+        let (original_as_tt, _) = mbe::syntax_node_to_token_tree(&parsed.syntax_node());\n+        assert_eq!(tt.to_string(), original_as_tt.to_string());\n+    }\n+\n+    #[test]\n+    fn incomplete_field_expr_1() {\n+        check(r#\"\n+fn foo() {\n+    a.\n+}\n+\"#, expect![[r#\"\n+fn foo () {a . __ra_fixup}\n+\"#]])\n+    }\n+\n+    #[test]\n+    fn incomplete_field_expr_2() {\n+        check(r#\"\n+fn foo() {\n+    a. ;\n+}\n+\"#, expect![[r#\"\n+fn foo () {a . __ra_fixup ;}\n+\"#]])\n+    }\n+\n+    #[test]\n+    fn incomplete_field_expr_3() {\n+        check(r#\"\n+fn foo() {\n+    a. ;\n+    bar();\n+}\n+\"#, expect![[r#\"\n+fn foo () {a . __ra_fixup ; bar () ;}\n+\"#]])\n+    }\n+\n+    #[test]\n+    fn field_expr_before_call() {\n+        // another case that easily happens while typing\n+        check(r#\"\n+fn foo() {\n+    a.b\n+    bar();\n+}\n+\"#, expect![[r#\"\n+fn foo () {a . b bar () ;}\n+\"#]])\n+    }\n+}"}]}