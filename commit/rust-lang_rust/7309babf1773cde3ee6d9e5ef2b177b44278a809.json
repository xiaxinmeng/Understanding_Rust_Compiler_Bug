{"sha": "7309babf1773cde3ee6d9e5ef2b177b44278a809", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczMDliYWJmMTc3M2NkZTNlZTZkOWU1ZWYyYjE3N2I0NDI3OGE4MDk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-12-03T22:58:13Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-01-03T19:50:18Z"}, "message": "coherence: code cleanup", "tree": {"sha": "c9a33269f87eb6d74608f70890cf407d91741a67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9a33269f87eb6d74608f70890cf407d91741a67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7309babf1773cde3ee6d9e5ef2b177b44278a809", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7309babf1773cde3ee6d9e5ef2b177b44278a809", "html_url": "https://github.com/rust-lang/rust/commit/7309babf1773cde3ee6d9e5ef2b177b44278a809", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7309babf1773cde3ee6d9e5ef2b177b44278a809/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8a2f9838d9df85d757118a44855004f9805792f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a2f9838d9df85d757118a44855004f9805792f", "html_url": "https://github.com/rust-lang/rust/commit/f8a2f9838d9df85d757118a44855004f9805792f"}], "stats": {"total": 615, "additions": 298, "deletions": 317}, "files": [{"sha": "8a12eba7d5d20b3a0022137056b81f95d5cbf124", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 281, "deletions": 288, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/7309babf1773cde3ee6d9e5ef2b177b44278a809/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7309babf1773cde3ee6d9e5ef2b177b44278a809/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=7309babf1773cde3ee6d9e5ef2b177b44278a809", "patch": "@@ -22,336 +22,329 @@ use rustc::ty::subst::Subst;\n use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n \n+use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n use rustc::hir::{self, ItemImpl};\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    populate_destructors(tcx);\n-    check_implementations_of_copy(tcx);\n-    check_implementations_of_coerce_unsized(tcx);\n-}\n+    if let Some(drop_trait) = tcx.lang_items.drop_trait() {\n+        tcx.lookup_trait_def(drop_trait).for_each_impl(tcx, |impl_did| {\n+            visit_implementation_of_drop(tcx, impl_did)\n+        });\n+    }\n \n-fn populate_destructors<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let drop_trait = match tcx.lang_items.drop_trait() {\n-        Some(id) => id,\n-        None => return,\n-    };\n-    tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n-    let drop_trait = tcx.lookup_trait_def(drop_trait);\n-\n-    drop_trait.for_each_impl(tcx, |impl_did| {\n-        let items = tcx.associated_item_def_ids(impl_did);\n-        if items.is_empty() {\n-            // We'll error out later. For now, just don't ICE.\n-            return;\n-        }\n-        let method_def_id = items[0];\n+    if let Some(copy_trait) = tcx.lang_items.copy_trait() {\n+        tcx.lookup_trait_def(copy_trait).for_each_impl(tcx, |impl_did| {\n+            visit_implementation_of_copy(tcx, impl_did)\n+        });\n+    }\n \n-        let self_type = tcx.item_type(impl_did);\n-        match self_type.sty {\n-            ty::TyAdt(type_def, _) => {\n-                type_def.set_destructor(method_def_id);\n+    if let Some(coerce_unsized_trait) = tcx.lang_items.coerce_unsized_trait() {\n+        let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n+            Ok(id) => id,\n+            Err(err) => {\n+                tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n             }\n-            _ => {\n-                // Destructors only work on nominal types.\n-                if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n-                    match tcx.map.find(impl_node_id) {\n-                        Some(hir_map::NodeItem(item)) => {\n-                            let span = match item.node {\n-                                ItemImpl(.., ref ty, _) => ty.span,\n-                                _ => item.span,\n-                            };\n-                            struct_span_err!(tcx.sess,\n-                                             span,\n-                                             E0120,\n-                                             \"the Drop trait may only be implemented on \\\n-                                              structures\")\n-                                    .span_label(span,\n-                                                &format!(\"implementing Drop requires a struct\"))\n-                                .emit();\n-                        }\n-                        _ => {\n-                            bug!(\"didn't find impl in ast map\");\n-                        }\n+        };\n+\n+        tcx.lookup_trait_def(coerce_unsized_trait).for_each_impl(tcx, |impl_did| {\n+            visit_implementation_of_coerce_unsized(tcx, impl_did,\n+                                                   unsize_trait, coerce_unsized_trait)\n+        });\n+    }\n+}\n+\n+fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+    let items = tcx.associated_item_def_ids(impl_did);\n+    if items.is_empty() {\n+        // We'll error out later. For now, just don't ICE.\n+        return;\n+    }\n+    let method_def_id = items[0];\n+\n+    let self_type = tcx.item_type(impl_did);\n+    match self_type.sty {\n+        ty::TyAdt(type_def, _) => {\n+            type_def.set_destructor(method_def_id);\n+        }\n+        _ => {\n+            // Destructors only work on nominal types.\n+            if let Some(impl_node_id) = tcx.map.as_local_node_id(impl_did) {\n+                match tcx.map.find(impl_node_id) {\n+                    Some(hir_map::NodeItem(item)) => {\n+                        let span = match item.node {\n+                            ItemImpl(.., ref ty, _) => ty.span,\n+                            _ => item.span,\n+                        };\n+                        struct_span_err!(tcx.sess,\n+                                         span,\n+                                         E0120,\n+                                         \"the Drop trait may only be implemented on \\\n+                                         structures\")\n+                            .span_label(span,\n+                                        &format!(\"implementing Drop requires a struct\"))\n+                            .emit();\n+                    }\n+                    _ => {\n+                        bug!(\"didn't find impl in ast map\");\n                     }\n-                } else {\n-                    bug!(\"found external impl of Drop trait on \\\n-                          something other than a struct\");\n                 }\n+            } else {\n+                bug!(\"found external impl of Drop trait on \\\n+                      something other than a struct\");\n             }\n         }\n-    });\n+    }\n }\n \n-fn check_implementations_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let copy_trait = match tcx.lang_items.copy_trait() {\n-        Some(id) => id,\n-        None => return,\n+fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId) {\n+    debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n+\n+    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+        n\n+    } else {\n+        debug!(\"visit_implementation_of_copy(): impl not in this \\\n+                crate\");\n+        return;\n     };\n-    tcx.populate_implementations_for_trait_if_necessary(copy_trait);\n-    let copy_trait = tcx.lookup_trait_def(copy_trait);\n-\n-    copy_trait.for_each_impl(tcx, |impl_did| {\n-        debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n-\n-        let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-            n\n-        } else {\n-            debug!(\"check_implementations_of_copy(): impl not in this \\\n-                    crate\");\n-            return;\n-        };\n \n-        let self_type = tcx.item_type(impl_did);\n-        debug!(\"check_implementations_of_copy: self_type={:?} (bound)\",\n-               self_type);\n-\n-        let span = tcx.map.span(impl_node_id);\n-        let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-        let self_type = self_type.subst(tcx, &param_env.free_substs);\n-        assert!(!self_type.has_escaping_regions());\n-\n-        debug!(\"check_implementations_of_copy: self_type={:?} (free)\",\n-               self_type);\n-\n-        match param_env.can_type_implement_copy(tcx, self_type, span) {\n-            Ok(()) => {}\n-            Err(CopyImplementationError::InfrigingField(name)) => {\n-                struct_span_err!(tcx.sess,\n-                                 span,\n-                                 E0204,\n-                                 \"the trait `Copy` may not be implemented for this type\")\n-                    .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n-                    .emit()\n-            }\n-            Err(CopyImplementationError::InfrigingVariant(name)) => {\n-                let item = tcx.map.expect_item(impl_node_id);\n-                let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n-                    tr.path.span\n-                } else {\n-                    span\n-                };\n-\n-                struct_span_err!(tcx.sess,\n-                                 span,\n-                                 E0205,\n-                                 \"the trait `Copy` may not be implemented for this type\")\n-                    .span_label(span,\n-                                &format!(\"variant `{}` does not implement `Copy`\", name))\n-                    .emit()\n-            }\n-            Err(CopyImplementationError::NotAnAdt) => {\n-                let item = tcx.map.expect_item(impl_node_id);\n-                let span = if let ItemImpl(.., ref ty, _) = item.node {\n-                    ty.span\n-                } else {\n-                    span\n-                };\n-\n-                struct_span_err!(tcx.sess,\n-                                 span,\n-                                 E0206,\n-                                 \"the trait `Copy` may not be implemented for this type\")\n-                    .span_label(span, &format!(\"type is not a structure or enumeration\"))\n-                    .emit();\n-            }\n-            Err(CopyImplementationError::HasDestructor) => {\n-                struct_span_err!(tcx.sess,\n-                                 span,\n-                                 E0184,\n-                                 \"the trait `Copy` may not be implemented for this type; the \\\n-                                  type has a destructor\")\n-                        .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n-                    .emit();\n-            }\n+    let self_type = tcx.item_type(impl_did);\n+    debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\",\n+           self_type);\n+\n+    let span = tcx.map.span(impl_node_id);\n+    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+    let self_type = self_type.subst(tcx, &param_env.free_substs);\n+    assert!(!self_type.has_escaping_regions());\n+\n+    debug!(\"visit_implementation_of_copy: self_type={:?} (free)\",\n+           self_type);\n+\n+    match param_env.can_type_implement_copy(tcx, self_type, span) {\n+        Ok(()) => {}\n+        Err(CopyImplementationError::InfrigingField(name)) => {\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0204,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n+                .emit()\n         }\n-    });\n-}\n+        Err(CopyImplementationError::InfrigingVariant(name)) => {\n+            let item = tcx.map.expect_item(impl_node_id);\n+            let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n+                tr.path.span\n+            } else {\n+                span\n+            };\n \n-fn check_implementations_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let coerce_unsized_trait = match tcx.lang_items.coerce_unsized_trait() {\n-        Some(id) => id,\n-        None => return,\n-    };\n-    let unsize_trait = match tcx.lang_items.require(UnsizeTraitLangItem) {\n-        Ok(id) => id,\n-        Err(err) => {\n-            tcx.sess.fatal(&format!(\"`CoerceUnsized` implementation {}\", err));\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0205,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(span,\n+                            &format!(\"variant `{}` does not implement `Copy`\", name))\n+                .emit()\n         }\n-    };\n+        Err(CopyImplementationError::NotAnAdt) => {\n+            let item = tcx.map.expect_item(impl_node_id);\n+            let span = if let ItemImpl(.., ref ty, _) = item.node {\n+                ty.span\n+            } else {\n+                span\n+            };\n \n-    let trait_def = tcx.lookup_trait_def(coerce_unsized_trait);\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0206,\n+                             \"the trait `Copy` may not be implemented for this type\")\n+                .span_label(span, &format!(\"type is not a structure or enumeration\"))\n+                .emit();\n+        }\n+        Err(CopyImplementationError::HasDestructor) => {\n+            struct_span_err!(tcx.sess,\n+                             span,\n+                             E0184,\n+                             \"the trait `Copy` may not be implemented for this type; the \\\n+                              type has a destructor\")\n+                .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n+                .emit();\n+        }\n+    }\n+}\n \n-    trait_def.for_each_impl(tcx, |impl_did| {\n-        debug!(\"check_implementations_of_coerce_unsized: impl_did={:?}\",\n-               impl_did);\n+fn visit_implementation_of_coerce_unsized<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did: DefId,\n+    unsize_trait: DefId, coerce_unsized_trait: DefId)\n+{\n+    debug!(\"visit_implementation_of_coerce_unsized: impl_did={:?}\",\n+           impl_did);\n+\n+    let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n+        n\n+    } else {\n+        debug!(\"visit_implementation_of_coerce_unsized(): impl not \\\n+                in this crate\");\n+        return;\n+    };\n \n-        let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n-            n\n-        } else {\n-            debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n-                    in this crate\");\n-            return;\n+    let source = tcx.item_type(impl_did);\n+    let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+    let target = trait_ref.substs.type_at(1);\n+    debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (bound)\",\n+           source,\n+           target);\n+\n+    let span = tcx.map.span(impl_node_id);\n+    let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n+    let source = source.subst(tcx, &param_env.free_substs);\n+    let target = target.subst(tcx, &param_env.free_substs);\n+    assert!(!source.has_escaping_regions());\n+\n+    debug!(\"visit_implementation_of_coerce_unsized: {:?} -> {:?} (free)\",\n+           source,\n+           target);\n+\n+    tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n+        let cause = ObligationCause::misc(span, impl_node_id);\n+        let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n+                           mt_b: ty::TypeAndMut<'tcx>,\n+                           mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n+            if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n+                infcx.report_mismatched_types(&cause,\n+                                              mk_ptr(mt_b.ty),\n+                                              target,\n+                                              ty::error::TypeError::Mutability)\n+                         .emit();\n+            }\n+            (mt_a.ty, mt_b.ty, unsize_trait, None)\n         };\n+        let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n+            (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n \n-        let source = tcx.item_type(impl_did);\n-        let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n-        let target = trait_ref.substs.type_at(1);\n-        debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n-               source,\n-               target);\n-\n-        let span = tcx.map.span(impl_node_id);\n-        let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n-        let source = source.subst(tcx, &param_env.free_substs);\n-        let target = target.subst(tcx, &param_env.free_substs);\n-        assert!(!source.has_escaping_regions());\n-\n-        debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n-               source,\n-               target);\n-\n-        tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n-            let cause = ObligationCause::misc(span, impl_node_id);\n-            let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n-                               mt_b: ty::TypeAndMut<'tcx>,\n-                               mk_ptr: &Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-                if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                    infcx.report_mismatched_types(&cause,\n-                                                  mk_ptr(mt_b.ty),\n-                                                  target,\n-                                                  ty::error::TypeError::Mutability)\n-                         .emit();\n-                }\n-                (mt_a.ty, mt_b.ty, unsize_trait, None)\n-            };\n-            let (source, target, trait_def_id, kind) = match (&source.sty, &target.sty) {\n-                (&ty::TyBox(a), &ty::TyBox(b)) => (a, b, unsize_trait, None),\n+            (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n+                infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n+            }\n \n-                (&ty::TyRef(r_a, mt_a), &ty::TyRef(r_b, mt_b)) => {\n-                    infcx.sub_regions(infer::RelateObjectBound(span), r_b, r_a);\n-                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ref(r_b, ty))\n-                }\n+            (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n+            (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n+                check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+            }\n \n-                (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) |\n-                (&ty::TyRawPtr(mt_a), &ty::TyRawPtr(mt_b)) => {\n-                    check_mutbl(mt_a, mt_b, &|ty| tcx.mk_imm_ptr(ty))\n+            (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n+                if def_a.is_struct() && def_b.is_struct() => {\n+                if def_a != def_b {\n+                    let source_path = tcx.item_path_str(def_a.did);\n+                    let target_path = tcx.item_path_str(def_b.did);\n+                    span_err!(tcx.sess,\n+                              span,\n+                              E0377,\n+                              \"the trait `CoerceUnsized` may only be implemented \\\n+                               for a coercion between structures with the same \\\n+                               definition; expected {}, found {}\",\n+                              source_path,\n+                              target_path);\n+                    return;\n                 }\n \n-                (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n-                    if def_a.is_struct() && def_b.is_struct() => {\n-                    if def_a != def_b {\n-                        let source_path = tcx.item_path_str(def_a.did);\n-                        let target_path = tcx.item_path_str(def_b.did);\n-                        span_err!(tcx.sess,\n-                                  span,\n-                                  E0377,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures with the same \\\n-                                   definition; expected {}, found {}\",\n-                                  source_path,\n-                                  target_path);\n-                        return;\n-                    }\n+                let fields = &def_a.struct_variant().fields;\n+                let diff_fields = fields.iter()\n+                    .enumerate()\n+                    .filter_map(|(i, f)| {\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                    let fields = &def_a.struct_variant().fields;\n-                    let diff_fields = fields.iter()\n-                        .enumerate()\n-                        .filter_map(|(i, f)| {\n-                            let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+                        if tcx.item_type(f.did).is_phantom_data() {\n+                            // Ignore PhantomData fields\n+                            return None;\n+                        }\n \n-                            if tcx.item_type(f.did).is_phantom_data() {\n-                                // Ignore PhantomData fields\n+                        // Ignore fields that aren't significantly changed\n+                        if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                            if ok.obligations.is_empty() {\n                                 return None;\n                             }\n+                        }\n \n-                            // Ignore fields that aren't significantly changed\n-                            if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n-                                if ok.obligations.is_empty() {\n-                                    return None;\n-                                }\n-                            }\n-\n-                            // Collect up all fields that were significantly changed\n-                            // i.e. those that contain T in coerce_unsized T -> U\n-                            Some((i, a, b))\n-                        })\n-                        .collect::<Vec<_>>();\n-\n-                    if diff_fields.is_empty() {\n-                        span_err!(tcx.sess,\n-                                  span,\n-                                  E0374,\n-                                  \"the trait `CoerceUnsized` may only be implemented \\\n-                                   for a coercion between structures with one field \\\n-                                   being coerced, none found\");\n-                        return;\n-                    } else if diff_fields.len() > 1 {\n-                        let item = tcx.map.expect_item(impl_node_id);\n-                        let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n-                            t.path.span\n-                        } else {\n-                            tcx.map.span(impl_node_id)\n-                        };\n-\n-                        let mut err = struct_span_err!(tcx.sess,\n-                                                       span,\n-                                                       E0375,\n-                                                       \"implementing the trait \\\n-                                                        `CoerceUnsized` requires multiple \\\n-                                                        coercions\");\n-                        err.note(\"`CoerceUnsized` may only be implemented for \\\n-                                  a coercion between structures with one field being coerced\");\n-                        err.note(&format!(\"currently, {} fields need coercions: {}\",\n-                                          diff_fields.len(),\n-                                          diff_fields.iter()\n-                                          .map(|&(i, a, b)| {\n-                                              format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                          })\n-                                          .collect::<Vec<_>>()\n-                                          .join(\", \")));\n-                        err.span_label(span, &format!(\"requires multiple coercions\"));\n-                        err.emit();\n-                        return;\n-                    }\n+                        // Collect up all fields that were significantly changed\n+                        // i.e. those that contain T in coerce_unsized T -> U\n+                        Some((i, a, b))\n+                    })\n+                    .collect::<Vec<_>>();\n \n-                    let (i, a, b) = diff_fields[0];\n-                    let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n-                    (a, b, coerce_unsized_trait, Some(kind))\n-                }\n-\n-                _ => {\n+                if diff_fields.is_empty() {\n                     span_err!(tcx.sess,\n                               span,\n-                              E0376,\n+                              E0374,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n-                               for a coercion between structures\");\n+                               for a coercion between structures with one field \\\n+                               being coerced, none found\");\n+                    return;\n+                } else if diff_fields.len() > 1 {\n+                    let item = tcx.map.expect_item(impl_node_id);\n+                    let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n+                        t.path.span\n+                    } else {\n+                        tcx.map.span(impl_node_id)\n+                    };\n+\n+                    let mut err = struct_span_err!(tcx.sess,\n+                                                   span,\n+                                                   E0375,\n+                                                   \"implementing the trait \\\n+                                                    `CoerceUnsized` requires multiple \\\n+                                                    coercions\");\n+                    err.note(\"`CoerceUnsized` may only be implemented for \\\n+                              a coercion between structures with one field being coerced\");\n+                    err.note(&format!(\"currently, {} fields need coercions: {}\",\n+                                      diff_fields.len(),\n+                                      diff_fields.iter()\n+                                      .map(|&(i, a, b)| {\n+                                          format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                      })\n+                                      .collect::<Vec<_>>()\n+                                      .join(\", \")));\n+                    err.span_label(span, &format!(\"requires multiple coercions\"));\n+                    err.emit();\n                     return;\n                 }\n-            };\n-\n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n \n-            // Register an obligation for `A: Trait<B>`.\n-            let cause = traits::ObligationCause::misc(span, impl_node_id);\n-            let predicate =\n-                tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                let (i, a, b) = diff_fields[0];\n+                let kind = ty::adjustment::CustomCoerceUnsized::Struct(i);\n+                (a, b, coerce_unsized_trait, Some(kind))\n+            }\n \n-            // Check that all transitive obligations are satisfied.\n-            if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n-                infcx.report_fulfillment_errors(&errors);\n+            _ => {\n+                span_err!(tcx.sess,\n+                          span,\n+                          E0376,\n+                          \"the trait `CoerceUnsized` may only be implemented \\\n+                           for a coercion between structures\");\n+                return;\n             }\n+        };\n \n-            // Finally, resolve all regions.\n-            let mut free_regions = FreeRegionMap::new();\n-            free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n-                                                             .caller_bounds);\n-            infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+        let mut fulfill_cx = traits::FulfillmentContext::new();\n \n-            if let Some(kind) = kind {\n-                tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n-            }\n-        });\n+        // Register an obligation for `A: Trait<B>`.\n+        let cause = traits::ObligationCause::misc(span, impl_node_id);\n+        let predicate =\n+            tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n+        fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+\n+        // Check that all transitive obligations are satisfied.\n+        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(&errors);\n+        }\n+\n+        // Finally, resolve all regions.\n+        let mut free_regions = FreeRegionMap::new();\n+        free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+                                                         .caller_bounds);\n+        infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+\n+        if let Some(kind) = kind {\n+            tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n+        }\n     });\n }"}, {"sha": "316e6555b41ecc8590067a4adcc84e87be7f1059", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7309babf1773cde3ee6d9e5ef2b177b44278a809/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7309babf1773cde3ee6d9e5ef2b177b44278a809/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=7309babf1773cde3ee6d9e5ef2b177b44278a809", "patch": "@@ -16,7 +16,6 @@\n // mappings. That mapping code resides here.\n \n use hir::def_id::DefId;\n-use rustc::traits::Reveal;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n@@ -25,7 +24,6 @@ use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n use rustc::ty::{TyProjection, TyAnon};\n use CrateCtxt;\n-use rustc::infer::{InferCtxt};\n use syntax_pos::Span;\n use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -37,16 +35,15 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    crate_context: &'a CrateCtxt<'a, 'gcx>,\n-    inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n+struct CoherenceChecker<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n+struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.cc.check_implementation(item)\n@@ -60,15 +57,15 @@ impl<'a, 'gcx, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCheckVisitor<'a, 'gcx,\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n             TyAdt(def, _) => Some(def.did),\n \n             TyDynamic(ref t, ..) => t.principal().map(|p| p.def_id()),\n \n-            TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n+            TyBox(_) => self.tcx.lang_items.owned_box(),\n \n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n             TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n@@ -88,21 +85,21 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_item_likes_in_krate(\n+        self.tcx.visit_all_item_likes_in_krate(\n             DepNode::CoherenceCheckImpl,\n             &mut CoherenceCheckVisitor { cc: self });\n-        builtin::check(self.crate_context.tcx);\n+        builtin::check(self.tcx);\n     }\n \n     fn check_implementation(&self, item: &Item) {\n-        let tcx = self.crate_context.tcx;\n+        let tcx = self.tcx;\n         let impl_did = tcx.map.local_def_id(item.id);\n         let self_type = tcx.item_type(impl_did);\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n \n-        if let Some(trait_ref) = self.crate_context.tcx.impl_trait_ref(impl_did) {\n+        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{:?}', item '{}'\",\n                    trait_ref,\n                    item.name);\n@@ -113,9 +110,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 return;\n             }\n \n-            enforce_trait_manually_implementable(self.crate_context.tcx,\n-                                                 item.span,\n-                                                 trait_ref.def_id);\n+            enforce_trait_manually_implementable(self.tcx, item.span, trait_ref.def_id);\n             self.add_trait_impl(trait_ref, impl_did);\n         } else {\n             // Skip inherent impls where the self type is an error\n@@ -134,16 +129,15 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        let tcx = self.crate_context.tcx;\n-        tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n+        self.tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n     }\n \n-    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n+    fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n                impl_trait_ref,\n                impl_def_id);\n-        let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n-        trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n+        let trait_def = self.tcx.lookup_trait_def(impl_trait_ref.def_id);\n+        trait_def.record_local_impl(self.tcx, impl_def_id, impl_trait_ref);\n     }\n }\n \n@@ -176,13 +170,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    ccx.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n-        CoherenceChecker {\n-                crate_context: ccx,\n-                inference_context: infcx,\n-            }\n-            .check();\n-    });\n+    CoherenceChecker { tcx: ccx.tcx }.check();\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);\n     overlap::check(ccx.tcx);"}]}