{"sha": "e0e24c4e76e5e86442329c68fb33829490fd1a58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZTI0YzRlNzZlNWU4NjQ0MjMyOWM2OGZiMzM4Mjk0OTBmZDFhNTg=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-11-09T19:17:50Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-11-09T19:17:50Z"}, "message": "Merge pull request #573 from nrc/doom_panic\n\nFormat tuple structs better", "tree": {"sha": "a119a3a8aa4a66bc6220dd1d87f9cec99b22e12c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a119a3a8aa4a66bc6220dd1d87f9cec99b22e12c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0e24c4e76e5e86442329c68fb33829490fd1a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e24c4e76e5e86442329c68fb33829490fd1a58", "html_url": "https://github.com/rust-lang/rust/commit/e0e24c4e76e5e86442329c68fb33829490fd1a58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0e24c4e76e5e86442329c68fb33829490fd1a58/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5354f961968361f9264b10b060d72fc48fa33312", "url": "https://api.github.com/repos/rust-lang/rust/commits/5354f961968361f9264b10b060d72fc48fa33312", "html_url": "https://github.com/rust-lang/rust/commit/5354f961968361f9264b10b060d72fc48fa33312"}, {"sha": "bcda2824a2a798b2a9b6065c67171811d7b7bc5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcda2824a2a798b2a9b6065c67171811d7b7bc5b", "html_url": "https://github.com/rust-lang/rust/commit/bcda2824a2a798b2a9b6065c67171811d7b7bc5b"}], "stats": {"total": 246, "additions": 189, "deletions": 57}, "files": [{"sha": "e2484f8298e6ba18328f478ed2bec5adab40fb51", "filename": "src/items.rs", "status": "modified", "additions": 153, "deletions": 57, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/e0e24c4e76e5e86442329c68fb33829490fd1a58/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e24c4e76e5e86442329c68fb33829490fd1a58/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=e0e24c4e76e5e86442329c68fb33829490fd1a58", "patch": "@@ -440,7 +440,8 @@ impl<'a> FmtVisitor<'a> {\n                                                                   self.config,\n                                                                   indent,\n                                                                   where_density,\n-                                                                  span.hi));\n+                                                                  \"{\",\n+                                                                  Some(span.hi)));\n         result.push_str(&where_clause_str);\n \n         Some((result, force_new_line_for_brace))\n@@ -636,7 +637,8 @@ impl<'a> FmtVisitor<'a> {\n         let enum_snippet = self.snippet(span);\n         let body_start = span.lo + BytePos(enum_snippet.find_uncommented(\"{\").unwrap() as u32 + 1);\n         let generics_str = self.format_generics(generics,\n-                                                \" {\",\n+                                                \"{\",\n+                                                \"{\",\n                                                 self.block_indent,\n                                                 self.block_indent.block_indent(self.config),\n                                                 mk_sp(span.lo, body_start))\n@@ -768,33 +770,58 @@ impl<'a> FmtVisitor<'a> {\n                          span: Span,\n                          offset: Indent)\n                          -> Option<String> {\n+        match *struct_def {\n+            ast::VariantData::Unit(..) => {\n+                self.format_unit_struct(item_name, ident, vis)\n+            }\n+            ast::VariantData::Tuple(ref fields, _) => {\n+                self.format_tuple_struct(item_name, ident, vis, fields, generics, span, offset)\n+            }\n+            ast::VariantData::Struct(ref fields, _) => {\n+                self.format_struct_struct(item_name, ident, vis, fields, generics, span, offset)\n+            }\n+        }\n+    }\n+\n+    fn format_unit_struct(&self,\n+                          item_name: &str,\n+                          ident: ast::Ident,\n+                          vis: ast::Visibility)\n+                          -> Option<String> {\n         let mut result = String::with_capacity(1024);\n \n         let header_str = self.format_header(item_name, ident, vis);\n         result.push_str(&header_str);\n+        result.push(';');\n+        return Some(result);\n+    }\n \n-        let (fields, body_lo, opener, terminator) = match *struct_def {\n-            ast::VariantData::Unit(..) => {\n-                result.push(';');\n-                return Some(result);\n-            }\n-            ast::VariantData::Tuple(ref vec, _) => {\n-                (vec, vec[0].span.lo, \"(\", \")\")\n-            }\n-            ast::VariantData::Struct(ref vec, _) => {\n-                (vec, span_after(span, \"{\", self.codemap), \" {\", \"}\")\n-            }\n-        };\n+    fn format_struct_struct(&self,\n+                            item_name: &str,\n+                            ident: ast::Ident,\n+                            vis: ast::Visibility,\n+                            fields: &[ast::StructField],\n+                            generics: Option<&ast::Generics>,\n+                            span: Span,\n+                            offset: Indent)\n+                            -> Option<String> {\n+        let mut result = String::with_capacity(1024);\n+\n+        let header_str = self.format_header(item_name, ident, vis);\n+        result.push_str(&header_str);\n+\n+        let body_lo = span_after(span, \"{\", self.codemap);\n \n         let generics_str = match generics {\n             Some(g) => {\n                 try_opt!(self.format_generics(g,\n-                                              opener,\n+                                              \"{\",\n+                                              \"{\",\n                                               offset,\n                                               offset + header_str.len(),\n                                               mk_sp(span.lo, body_lo)))\n             }\n-            None => opener.to_owned(),\n+            None => \" {\".to_owned(),\n         };\n         result.push_str(&generics_str);\n \n@@ -804,18 +831,90 @@ impl<'a> FmtVisitor<'a> {\n             return Some(result);\n         }\n \n-        let item_indent = if let ast::VariantData::Tuple(..) = *struct_def {\n-            self.block_indent + result.len()\n-        } else {\n-            offset.block_indent(self.config)\n+        let item_indent = offset.block_indent(self.config);\n+        // 2 = \",\"\n+        let item_budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 1));\n+\n+        let context = self.get_context();\n+        let items = itemize_list(self.codemap,\n+                                 fields.iter(),\n+                                 \"}\",\n+                                 |field| {\n+                                     // Include attributes and doc comments, if present\n+                                     if !field.node.attrs.is_empty() {\n+                                         field.node.attrs[0].span.lo\n+                                     } else {\n+                                         field.span.lo\n+                                     }\n+                                 },\n+                                 |field| field.node.ty.span.hi,\n+                                 |field| field.rewrite(&context, item_budget, item_indent),\n+                                 span_after(span, \"{\", self.codemap),\n+                                 span.hi);\n+        // 1 = ,\n+        let budget = self.config.max_width - offset.width() + self.config.tab_spaces - 1;\n+        let fmt = ListFormatting {\n+            tactic: DefinitiveListTactic::Vertical,\n+            separator: \",\",\n+            trailing_separator: self.config.struct_trailing_comma,\n+            indent: item_indent,\n+            width: budget,\n+            ends_with_newline: true,\n+            config: self.config,\n+        };\n+        Some(format!(\"{}\\n{}{}\\n{}}}\",\n+                     result,\n+                     offset.block_indent(self.config).to_string(self.config),\n+                     try_opt!(write_list(items, &fmt)),\n+                     offset.to_string(self.config)))\n+    }\n+\n+    fn format_tuple_struct(&self,\n+                           item_name: &str,\n+                           ident: ast::Ident,\n+                           vis: ast::Visibility,\n+                           fields: &[ast::StructField],\n+                           generics: Option<&ast::Generics>,\n+                           span: Span,\n+                           offset: Indent)\n+                           -> Option<String> {\n+        assert!(!fields.is_empty(), \"Tuple struct with no fields?\");\n+        let mut result = String::with_capacity(1024);\n+\n+        let header_str = self.format_header(item_name, ident, vis);\n+        result.push_str(&header_str);\n+\n+        let body_lo = fields[0].span.lo;\n+\n+        let (generics_str, where_clause_str) = match generics {\n+            Some(ref generics) => {\n+                let generics_str = try_opt!(self.rewrite_generics(generics,\n+                                                                  offset,\n+                                                                  offset + header_str.len(),\n+                                                                  mk_sp(span.lo, body_lo)));\n+\n+                let where_clause_str = try_opt!(self.rewrite_where_clause(&generics.where_clause,\n+                                                                          self.config,\n+                                                                          self.block_indent,\n+                                                                          Density::Compressed,\n+                                                                          \";\",\n+                                                                          None));\n+\n+                (generics_str, where_clause_str)\n+            }\n+            None => (\"\".to_owned(), \"\".to_owned()),\n         };\n-        // 2 = \");\" or \",\"\n+        result.push_str(&generics_str);\n+        result.push('(');\n+\n+        let item_indent = self.block_indent + result.len();\n+        // 2 = \");\"\n         let item_budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 2));\n \n         let context = self.get_context();\n         let items = itemize_list(self.codemap,\n                                  fields.iter(),\n-                                 terminator,\n+                                 \")\",\n                                  |field| {\n                                      // Include attributes and doc comments, if present\n                                      if !field.node.attrs.is_empty() {\n@@ -826,37 +925,25 @@ impl<'a> FmtVisitor<'a> {\n                                  },\n                                  |field| field.node.ty.span.hi,\n                                  |field| field.rewrite(&context, item_budget, item_indent),\n-                                 span_after(span, opener.trim(), self.codemap),\n+                                 span_after(span, \"(\", self.codemap),\n                                  span.hi);\n-        match *struct_def {\n-            ast::VariantData::Tuple(..) => {\n-                // 2 = );\n-                let budget = try_opt!(self.config.max_width.checked_sub(item_indent.width() + 2));\n-                let rewrite = try_opt!(format_item_list(items, budget, item_indent, self.config));\n-                result.push_str(&rewrite);\n-                result.push(')');\n-                Some(result)\n-            }\n-            ast::VariantData::Struct(..) => {\n-                // 1 = ,\n-                let budget = self.config.max_width - offset.width() + self.config.tab_spaces - 1;\n-                let fmt = ListFormatting {\n-                    tactic: DefinitiveListTactic::Vertical,\n-                    separator: \",\",\n-                    trailing_separator: self.config.struct_trailing_comma,\n-                    indent: item_indent,\n-                    width: budget,\n-                    ends_with_newline: true,\n-                    config: self.config,\n-                };\n-                Some(format!(\"{}\\n{}{}\\n{}}}\",\n-                             result,\n-                             offset.block_indent(self.config).to_string(self.config),\n-                             try_opt!(write_list(items, &fmt)),\n-                             offset.to_string(self.config)))\n-            }\n-            _ => unreachable!(),\n+        let body = try_opt!(format_item_list(items, item_budget, item_indent, self.config));\n+        result.push_str(&body);\n+        result.push(')');\n+\n+        if where_clause_str.len() > 0 && !where_clause_str.contains('\\n') &&\n+           (result.contains('\\n') ||\n+            self.block_indent.width() + result.len() + where_clause_str.len() + 1 >\n+            self.config.max_width) {\n+            // We need to put the where clause on a new line, but we didn'to_string\n+            // know that earlier, so the where clause will not be indented properly.\n+            result.push('\\n');\n+            result.push_str(&(self.block_indent + (self.config.tab_spaces - 1))\n+                                 .to_string(self.config));\n         }\n+        result.push_str(&where_clause_str);\n+\n+        Some(result)\n     }\n \n     fn format_header(&self, item_name: &str, ident: ast::Ident, vis: ast::Visibility) -> String {\n@@ -866,6 +953,7 @@ impl<'a> FmtVisitor<'a> {\n     fn format_generics(&self,\n                        generics: &ast::Generics,\n                        opener: &str,\n+                       terminator: &str,\n                        offset: Indent,\n                        generics_offset: Indent,\n                        span: Span)\n@@ -877,12 +965,14 @@ impl<'a> FmtVisitor<'a> {\n                                                                       self.config,\n                                                                       self.block_indent,\n                                                                       Density::Tall,\n-                                                                      span.hi));\n+                                                                      terminator,\n+                                                                      Some(span.hi)));\n             result.push_str(&where_clause_str);\n             result.push_str(&self.block_indent.to_string(self.config));\n             result.push('\\n');\n-            result.push_str(opener.trim());\n+            result.push_str(opener);\n         } else {\n+            result.push(' ');\n             result.push_str(opener);\n         }\n \n@@ -938,7 +1028,7 @@ impl<'a> FmtVisitor<'a> {\n                                  |&(_, ref str)| str.clone(),\n                                  span_after(span, \"<\", self.codemap),\n                                  span.hi);\n-        let list_str = try_opt!(::lists::format_item_list(items, h_budget, offset, self.config));\n+        let list_str = try_opt!(format_item_list(items, h_budget, offset, self.config));\n \n         Some(format!(\"<{}>\", list_str))\n     }\n@@ -948,7 +1038,8 @@ impl<'a> FmtVisitor<'a> {\n                             config: &Config,\n                             indent: Indent,\n                             density: Density,\n-                            span_end: BytePos)\n+                            terminator: &str,\n+                            span_end: Option<BytePos>)\n                             -> Option<String> {\n         if where_clause.predicates.is_empty() {\n             return Some(String::new());\n@@ -973,16 +1064,21 @@ impl<'a> FmtVisitor<'a> {\n \n         let budget = self.config.max_width - offset.width();\n         let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n+        // If we don't have the start of the next span, then use the end of the\n+        // predicates, but that means we miss comments.\n+        let len = where_clause.predicates.len();\n+        let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n+        let span_end = span_end.unwrap_or(end_of_preds);\n         let items = itemize_list(self.codemap,\n                                  where_clause.predicates.iter(),\n-                                 \"{\",\n+                                 terminator,\n                                  |pred| span_for_where_pred(pred).lo,\n                                  |pred| span_for_where_pred(pred).hi,\n                                  |pred| pred.rewrite(&context, budget, offset),\n                                  span_start,\n                                  span_end);\n         let item_vec = items.collect::<Vec<_>>();\n-        // FIXME: we don't need to collect here if the where_layout isnt\n+        // FIXME: we don't need to collect here if the where_layout isn't\n         // HorizontalVertical.\n         let tactic = definitive_tactic(&item_vec, self.config.where_layout, budget);\n "}, {"sha": "a4e377f154eb9ed3f53d312f1586e3e9c30b5262", "filename": "tests/source/structs.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e0e24c4e76e5e86442329c68fb33829490fd1a58/tests%2Fsource%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e24c4e76e5e86442329c68fb33829490fd1a58/tests%2Fsource%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstructs.rs?ref=e0e24c4e76e5e86442329c68fb33829490fd1a58", "patch": "@@ -122,3 +122,16 @@ struct Deep {\n                                                      Type,\n                                                      NodeType>,\n }\n+\n+struct Foo<T>(T);\n+struct Foo<T>(T) where T: Copy, T: Eq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUU);\n+struct Foo<T>(TTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTTTT) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUU) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, // Foo\n+              UUUUUUUUUUUUUUUUUUUUUUUU /* Bar */,\n+              // Baz\n+              TTTTTTTTTTTTTTTTTTT,\n+              // Qux (FIXME #572 - doc comment)\n+              UUUUUUUUUUUUUUUUUUU);"}, {"sha": "a79663b0fed759c66a59ad7cd8c80b08eba12add", "filename": "tests/target/structs.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e0e24c4e76e5e86442329c68fb33829490fd1a58/tests%2Ftarget%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0e24c4e76e5e86442329c68fb33829490fd1a58/tests%2Ftarget%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstructs.rs?ref=e0e24c4e76e5e86442329c68fb33829490fd1a58", "patch": "@@ -118,3 +118,26 @@ struct Deep {\n                                                                          Type,\n                                                                          NodeType>,\n }\n+\n+struct Foo<T>(T);\n+struct Foo<T>(T)\n+    where T: Copy,\n+          T: Eq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT,\n+              UUUUUUUUUUUUUUUUUUUUUUUU,\n+              TTTTTTTTTTTTTTTTTTT,\n+              UUUUUUUUUUUUUUUUUUU);\n+struct Foo<T>(TTTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTT) where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, UUUUUUUUUUUUUUUUUUUUUUUU, TTTTTTTTTTTTTTTTTTTTT)\n+    where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT,\n+              UUUUUUUUUUUUUUUUUUUUUUUU,\n+              TTTTTTTTTTTTTTTTTTT,\n+              UUUUUUUUUUUUUUUUUUU)\n+    where T: PartialEq;\n+struct Foo<T>(TTTTTTTTTTTTTTTTT, // Foo\n+              UUUUUUUUUUUUUUUUUUUUUUUU, // Bar\n+              // Baz\n+              TTTTTTTTTTTTTTTTTTT,\n+              // Qux (FIXME #572 - doc comment)\n+              UUUUUUUUUUUUUUUUUUU);"}]}