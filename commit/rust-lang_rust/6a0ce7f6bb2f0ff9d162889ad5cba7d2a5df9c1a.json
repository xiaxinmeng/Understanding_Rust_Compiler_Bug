{"sha": "6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMGNlN2Y2YmIyZjBmZjlkMTYyODg5YWQ1Y2JhN2QyYTVkZjljMWE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-03-17T17:36:30Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-03-17T17:36:30Z"}, "message": "Sync from rust 04ae50179a802d1d18bb780baa85f55864f56616", "tree": {"sha": "1dbf224f788f376c04782b9323e33095f83742f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dbf224f788f376c04782b9323e33095f83742f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "html_url": "https://github.com/rust-lang/rust/commit/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e86b95480fac70673bd837e7fcfa45458bd52eb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86b95480fac70673bd837e7fcfa45458bd52eb7", "html_url": "https://github.com/rust-lang/rust/commit/e86b95480fac70673bd837e7fcfa45458bd52eb7"}, {"sha": "21a0c8e9e47942dcbc47f1680d076daeb5629451", "url": "https://api.github.com/repos/rust-lang/rust/commits/21a0c8e9e47942dcbc47f1680d076daeb5629451", "html_url": "https://github.com/rust-lang/rust/commit/21a0c8e9e47942dcbc47f1680d076daeb5629451"}], "stats": {"total": 72, "additions": 50, "deletions": 22}, "files": [{"sha": "b37a5f308c8f9c2a6ef516fa8968e8a1ad51a82f", "filename": "src/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "patch": "@@ -469,8 +469,11 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n     // FIXME find a cleaner way to support varargs\n     if fn_sig.c_variadic {\n-        if fn_sig.abi != Abi::C {\n-            fx.tcx.sess.span_fatal(span, &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi));\n+        if !matches!(fn_sig.abi, Abi::C { .. }) {\n+            fx.tcx.sess.span_fatal(\n+                span,\n+                &format!(\"Variadic call for non-C abi {:?}\", fn_sig.abi),\n+            );\n         }\n         let sig_ref = fx.bcx.func.dfg.call_signature(call_inst).unwrap();\n         let abi_params = call_args"}, {"sha": "ee0244b1ad02aafc55f3e54aee406f25c8809a16", "filename": "src/base.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "patch": "@@ -835,6 +835,27 @@ fn codegen_stmt<'tcx>(\n             }\n         }\n         StatementKind::Coverage { .. } => fx.tcx.sess.fatal(\"-Zcoverage is unimplemented\"),\n+        StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping {\n+          src,\n+          dst,\n+          count,\n+        }) => {\n+            let dst = codegen_operand(fx, dst);\n+            let pointee = dst\n+              .layout()\n+              .pointee_info_at(fx, rustc_target::abi::Size::ZERO)\n+              .expect(\"Expected pointer\");\n+            let dst = dst.load_scalar(fx);\n+            let src = codegen_operand(fx, src).load_scalar(fx);\n+            let count = codegen_operand(fx, count).load_scalar(fx);\n+            let elem_size: u64 = pointee.size.bytes();\n+            let bytes = if elem_size != 1 {\n+               fx.bcx.ins().imul_imm(count, elem_size as i64)\n+            } else {\n+               count\n+            };\n+            fx.bcx.call_memcpy(fx.cx.module.target_config(), dst, src, bytes);\n+        }\n     }\n }\n "}, {"sha": "038b09f71d8ceec31c8cd5007bd4f20dac8fd29a", "filename": "src/constant.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, Allocation, ConstValue, ErrorHandled, GlobalAlloc, Pointer, Scalar,\n };\n-use rustc_middle::ty::{Const, ConstKind};\n+use rustc_middle::ty::ConstKind;\n \n use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n@@ -39,7 +39,10 @@ impl ConstantCx {\n pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n-        let const_ = fx.monomorphize(constant.literal);\n+        let const_ = match fx.monomorphize(constant.literal) {\n+            ConstantKind::Ty(ct) => ct,\n+            ConstantKind::Val(..) => continue,\n+        };\n         match const_.val {\n             ConstKind::Value(_) => {}\n             ConstKind::Unevaluated(def, ref substs, promoted) => {\n@@ -115,19 +118,17 @@ pub(crate) fn codegen_constant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n ) -> CValue<'tcx> {\n-    let const_ = fx.monomorphize(constant.literal);\n+    let const_ = match fx.monomorphize(constant.literal) {\n+        ConstantKind::Ty(ct) => ct,\n+        ConstantKind::Val(val, ty) => return codegen_const_value(fx, val, ty),\n+    };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n         ConstKind::Unevaluated(def, ref substs, promoted) if fx.tcx.is_static(def.did) => {\n             assert!(substs.is_empty());\n             assert!(promoted.is_none());\n \n-            return codegen_static_ref(\n-                fx,\n-                def.did,\n-                fx.layout_of(fx.monomorphize(&constant.literal.ty)),\n-            )\n-            .to_cvalue(fx);\n+            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty)).to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(def, ref substs, promoted) => {\n             match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), def, substs, promoted, None) {\n@@ -427,11 +428,14 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut dyn Module, cx: &mut Constant\n pub(crate) fn mir_operand_get_const_val<'tcx>(\n     fx: &FunctionCx<'_, '_, 'tcx>,\n     operand: &Operand<'tcx>,\n-) -> Option<&'tcx Const<'tcx>> {\n+) -> Option<ConstValue<'tcx>> {\n     match operand {\n         Operand::Copy(_) | Operand::Move(_) => None,\n-        Operand::Constant(const_) => {\n-            Some(fx.monomorphize(const_.literal).eval(fx.tcx, ParamEnv::reveal_all()))\n-        }\n+        Operand::Constant(const_) => match const_.literal {\n+            ConstantKind::Ty(const_) => {\n+                fx.monomorphize(const_).eval(fx.tcx, ParamEnv::reveal_all()).val.try_to_value()\n+            }\n+            ConstantKind::Val(val, _) => Some(val),\n+        },\n     }\n }"}, {"sha": "83c91f789cd25eb219e10431cc1bf44905e32d2c", "filename": "src/intrinsics/llvm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fllvm.rs?ref=6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "patch": "@@ -53,7 +53,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         };\n         llvm.x86.sse2.cmp.ps | llvm.x86.sse2.cmp.pd, (c x, c y, o kind) {\n             let kind_const = crate::constant::mir_operand_get_const_val(fx, kind).expect(\"llvm.x86.sse2.cmp.* kind not const\");\n-            let flt_cc = match kind_const.val.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n+            let flt_cc = match kind_const.try_to_bits(Size::from_bytes(1)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", kind_const)) {\n                 0 => FloatCC::Equal,\n                 1 => FloatCC::LessThan,\n                 2 => FloatCC::LessThanOrEqual,\n@@ -84,7 +84,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         llvm.x86.sse2.psrli.d, (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ushr_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n                 };\n@@ -94,7 +94,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n         llvm.x86.sse2.pslli.d, (c a, o imm8) {\n             let imm8 = crate::constant::mir_operand_get_const_val(fx, imm8).expect(\"llvm.x86.sse2.psrli.d imm8 not const\");\n             simd_for_each_lane(fx, a, ret, |fx, _lane_layout, res_lane_layout, lane| {\n-                let res_lane = match imm8.val.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n+                let res_lane = match imm8.try_to_bits(Size::from_bytes(4)).unwrap_or_else(|| panic!(\"imm8 not scalar: {:?}\", imm8)) {\n                     imm8 if imm8 < 32 => fx.bcx.ins().ishl_imm(lane, i64::from(imm8 as u8)),\n                     _ => fx.bcx.ins().iconst(types::I32, 0),\n                 };"}, {"sha": "e0a3056e58c11f251a440eaf6e3db87403cfe36f", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=6a0ce7f6bb2f0ff9d162889ad5cba7d2a5df9c1a", "patch": "@@ -85,8 +85,8 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 use rustc_middle::mir::interpret::*;\n                 let idx_const = crate::constant::mir_operand_get_const_val(fx, idx).expect(\"simd_shuffle* idx not const\");\n \n-                let idx_bytes = match idx_const.val {\n-                    ty::ConstKind::Value(ConstValue::ByRef { alloc, offset }) => {\n+                let idx_bytes = match idx_const {\n+                    ConstValue::ByRef { alloc, offset } => {\n                         let ptr = Pointer::new(AllocId(0 /* dummy */), offset);\n                         let size = Size::from_bytes(4 * ret_lane_count /* size_of([u32; ret_lane_count]) */);\n                         alloc.get_bytes(fx, ptr, size).unwrap()\n@@ -130,7 +130,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 );\n             };\n \n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n+            let idx = idx_const.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n             let (lane_count, _lane_ty) = base.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_insert] idx {} >= lane_count {}\", idx, lane_count));\n@@ -159,7 +159,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                 return;\n             };\n \n-            let idx = idx_const.val.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n+            let idx = idx_const.try_to_bits(Size::from_bytes(4 /* u32*/)).unwrap_or_else(|| panic!(\"kind not scalar: {:?}\", idx_const));\n             let (lane_count, _lane_ty) = v.layout().ty.simd_size_and_type(fx.tcx);\n             if idx >= lane_count.into() {\n                 fx.tcx.sess.span_fatal(fx.mir.span, &format!(\"[simd_extract] idx {} >= lane_count {}\", idx, lane_count));"}]}