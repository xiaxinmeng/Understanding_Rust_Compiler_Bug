{"sha": "7e9098ff692eccd07c509f1a6bee1328e8882d34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlOTA5OGZmNjkyZWNjZDA3YzUwOWYxYTZiZWUxMzI4ZTg4ODJkMzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-12T10:11:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-12-12T10:11:20Z"}, "message": "treat ref-to-raw cast like a reborrow: do a special kind of retag", "tree": {"sha": "8bb76235cf914644a94c70935891c65ba984b6e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bb76235cf914644a94c70935891c65ba984b6e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e9098ff692eccd07c509f1a6bee1328e8882d34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e9098ff692eccd07c509f1a6bee1328e8882d34", "html_url": "https://github.com/rust-lang/rust/commit/7e9098ff692eccd07c509f1a6bee1328e8882d34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e9098ff692eccd07c509f1a6bee1328e8882d34/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ec371747a742d8f96effe80b9bfcfa53ff6fa62", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec371747a742d8f96effe80b9bfcfa53ff6fa62", "html_url": "https://github.com/rust-lang/rust/commit/8ec371747a742d8f96effe80b9bfcfa53ff6fa62"}], "stats": {"total": 91, "additions": 31, "deletions": 60}, "files": [{"sha": "e821b4f76a34196532b65f0a71e151759e5d2986", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e9098ff692eccd07c509f1a6bee1328e8882d34/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9098ff692eccd07c509f1a6bee1328e8882d34/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=7e9098ff692eccd07c509f1a6bee1328e8882d34", "patch": "@@ -474,36 +474,10 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         }\n     }\n \n-    #[inline]\n-    fn escape_to_raw(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: OpTy<'tcx, Self::PointerTag>,\n-    ) -> EvalResult<'tcx> {\n-        // It is tempting to check the type here, but drop glue does EscapeToRaw\n-        // on a raw pointer.\n-        // This is deliberately NOT `deref_operand` as we do not want `tag_dereference`\n-        // to be called!  That would kill the original tag if we got a raw ptr.\n-        let place = ecx.ref_to_mplace(ecx.read_immediate(ptr)?)?;\n-        let size = ecx.size_and_align_of_mplace(place)?.map(|(size, _)| size)\n-            // for extern types, just cover what we can\n-            .unwrap_or_else(|| place.layout.size);\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n-            !ecx.machine.validate || size == Size::ZERO\n-        {\n-            // No tracking, or no retagging. The latter is possible because a dependency of ours\n-            // might be called with different flags than we are, so there are `Retag`\n-            // statements but we do not want to execute them.\n-            Ok(())\n-        } else {\n-            ecx.escape_to_raw(place, size)\n-        }\n-    }\n-\n     #[inline(always)]\n     fn retag(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        fn_entry: bool,\n-        two_phase: bool,\n+        kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Borrow>,\n     ) -> EvalResult<'tcx> {\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n@@ -514,7 +488,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             // uninitialized data.\n              Ok(())\n         } else {\n-            ecx.retag(fn_entry, two_phase, place)\n+            ecx.retag(kind, place)\n         }\n     }\n "}, {"sha": "27d4a4f7f7b5801adf3bbe2e1cf7d37f11d9393a", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7e9098ff692eccd07c509f1a6bee1328e8882d34/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9098ff692eccd07c509f1a6bee1328e8882d34/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=7e9098ff692eccd07c509f1a6bee1328e8882d34", "patch": "@@ -4,6 +4,7 @@ use std::rc::Rc;\n \n use rustc::ty::{self, layout::Size};\n use rustc::hir::{Mutability, MutMutable, MutImmutable};\n+use rustc::mir::RetagKind;\n \n use crate::{\n     EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n@@ -550,10 +551,11 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n     }\n \n     /// Retag an indidual pointer, returning the retagged version.\n+    /// `mutbl` can be `None` to make this a raw pointer.\n     fn retag_reference(\n         &mut self,\n         val: ImmTy<'tcx, Borrow>,\n-        mutbl: Mutability,\n+        mutbl: Option<Mutability>,\n         fn_barrier: bool,\n         two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Borrow>> {\n@@ -571,16 +573,17 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // Compute new borrow.\n         let time = this.machine.stacked_borrows.increment_clock();\n         let new_bor = match mutbl {\n-            MutMutable => Borrow::Uniq(time),\n-            MutImmutable => Borrow::Shr(Some(time)),\n+            Some(MutMutable) => Borrow::Uniq(time),\n+            Some(MutImmutable) => Borrow::Shr(Some(time)),\n+            None => Borrow::default(),\n         };\n \n         // Reborrow.\n         this.reborrow(place, size, fn_barrier, new_bor)?;\n         let new_place = place.with_tag(new_bor);\n         // Handle two-phase borrows.\n         if two_phase {\n-            assert!(mutbl == MutMutable, \"two-phase shared borrows make no sense\");\n+            assert!(mutbl == Some(MutMutable), \"two-phase shared borrows make no sense\");\n             // We immediately share it, to allow read accesses\n             let two_phase_time = this.machine.stacked_borrows.increment_clock();\n             let two_phase_bor = Borrow::Shr(Some(two_phase_time));\n@@ -665,59 +668,47 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         Ok(())\n     }\n \n-    /// The given place may henceforth be accessed through raw pointers.\n-    #[inline(always)]\n-    fn escape_to_raw(\n-        &mut self,\n-        place: MPlaceTy<'tcx, Borrow>,\n-        size: Size,\n-    ) -> EvalResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        this.reborrow(place, size, /*fn_barrier*/ false, Borrow::default())?;\n-        Ok(())\n-    }\n-\n     fn retag(\n         &mut self,\n-        fn_entry: bool,\n-        two_phase: bool,\n+        kind: RetagKind,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n         // Determine mutability and whether to add a barrier.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n-        fn qualify(ty: ty::Ty<'_>, fn_entry: bool) -> Option<(Mutability, bool)> {\n+        fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(Option<Mutability>, bool)> {\n             match ty.sty {\n                 // References are simple\n-                ty::Ref(_, _, mutbl) => Some((mutbl, fn_entry)),\n+                ty::Ref(_, _, mutbl) => Some((Some(mutbl), kind == RetagKind::FnEntry)),\n+                // Raw pointers need to be enabled\n+                ty::RawPtr(..) if kind == RetagKind::Raw => Some((None, false)),\n                 // Boxes do not get a barrier: Barriers reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n-                ty::Adt(..) if ty.is_box() => Some((MutMutable, false)),\n+                ty::Adt(..) if ty.is_box() => Some((Some(MutMutable), false)),\n                 _ => None,\n             }\n         }\n \n         // We need a visitor to visit all references.  However, that requires\n         // a `MemPlace`, so we have a fast path for reference types that\n         // avoids allocating.\n-        if let Some((mutbl, barrier)) = qualify(place.layout.ty, fn_entry) {\n+        if let Some((mutbl, barrier)) = qualify(place.layout.ty, kind) {\n             // fast path\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n-            let val = this.retag_reference(val, mutbl, barrier, two_phase)?;\n+            let val = this.retag_reference(val, mutbl, barrier, kind == RetagKind::TwoPhase)?;\n             this.write_immediate(val, place)?;\n             return Ok(());\n         }\n         let place = this.force_allocation(place)?;\n \n-        let mut visitor = RetagVisitor { ecx: this, fn_entry, two_phase };\n+        let mut visitor = RetagVisitor { ecx: this, kind };\n         visitor.visit_value(place)?;\n \n         // The actual visitor\n         struct RetagVisitor<'ecx, 'a, 'mir, 'tcx> {\n             ecx: &'ecx mut MiriEvalContext<'a, 'mir, 'tcx>,\n-            fn_entry: bool,\n-            two_phase: bool,\n+            kind: RetagKind,\n         }\n         impl<'ecx, 'a, 'mir, 'tcx>\n             MutValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n@@ -736,9 +727,14 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             {\n                 // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n                 // making it useless.\n-                if let Some((mutbl, barrier)) = qualify(place.layout.ty, self.fn_entry) {\n+                if let Some((mutbl, barrier)) = qualify(place.layout.ty, self.kind) {\n                     let val = self.ecx.read_immediate(place.into())?;\n-                    let val = self.ecx.retag_reference(val, mutbl, barrier, self.two_phase)?;\n+                    let val = self.ecx.retag_reference(\n+                        val,\n+                        mutbl,\n+                        barrier,\n+                        self.kind == RetagKind::TwoPhase\n+                    )?;\n                     self.ecx.write_immediate(val, place.into())?;\n                 }\n                 Ok(())"}, {"sha": "197c11197efa679a682ace4911417247e9dc750d", "filename": "tests/compile-fail/stacked_borrows/transmute-is-no-escape.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e9098ff692eccd07c509f1a6bee1328e8882d34/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e9098ff692eccd07c509f1a6bee1328e8882d34/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=7e9098ff692eccd07c509f1a6bee1328e8882d34", "patch": "@@ -1,13 +1,14 @@\n // Make sure we cannot use raw ptrs that got transmuted from mutable references\n // (i.e, no EscapeToRaw happened).\n-// We could, in principle, to EscapeToRaw lazily to allow this code, but that\n+// We could, in principle, do EscapeToRaw lazily to allow this code, but that\n // would no alleviate the need for EscapeToRaw (see `ref_raw_int_raw` in\n // `run-pass/stacked-borrows.rs`), and thus increase overall complexity.\n use std::mem;\n \n fn main() {\n-    let mut x: i32 = 42;\n-    let raw: *mut i32 = unsafe { mem::transmute(&mut x) };\n-    let raw = raw as usize as *mut i32; // make sure we killed the tag\n+    let mut x: [i32; 2] = [42, 43];\n+    let _raw: *mut i32 = unsafe { mem::transmute(&mut x[0]) };\n+    // `raw` still carries a tag, so we get another pointer to the same location that does not carry a tag\n+    let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n     unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n }"}]}