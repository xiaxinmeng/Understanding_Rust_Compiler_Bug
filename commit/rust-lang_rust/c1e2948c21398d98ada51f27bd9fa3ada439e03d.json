{"sha": "c1e2948c21398d98ada51f27bd9fa3ada439e03d", "node_id": "C_kwDOAAsO6NoAKGMxZTI5NDhjMjEzOThkOThhZGE1MWYyN2JkOWZhM2FkYTQzOWUwM2Q", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-31T06:00:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-31T06:00:42Z"}, "message": "Rollup merge of #93461 - dtolnay:fmtyield, r=davidtwco\n\nAccommodate yield points in the format_args expansion\n\nFixes #93274.\n\nFor the case `println!(\"{} {:?}\", \"\", async {}.await)` in the issue, the expansion before:\n\n```rust\n::std::io::_print(\n    ::core::fmt::Arguments::new_v1(\n        &[\"\", \" \", \"\\n\"],\n        &[\n            ::core::fmt::ArgumentV1::new(&\"\", ::core::fmt::Display::fmt),\n            ::core::fmt::ArgumentV1::new(&async {}.await, ::core::fmt::Debug::fmt),\n        ],\n    ),\n);\n```\n\nAfter:\n\n```rust\n::std::io::_print(\n    ::core::fmt::Arguments::new_v1(\n        &[\"\", \" \", \"\\n\"],\n        &match (&\"\", &async {}.await) {\n            _args => [\n                ::core::fmt::ArgumentV1::new(_args.0, ::core::fmt::Display::fmt),\n                ::core::fmt::ArgumentV1::new(_args.1, ::core::fmt::Debug::fmt),\n            ],\n        },\n    ),\n);\n```", "tree": {"sha": "776941fc8495bc55eef89511bec16d34b9a3c431", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/776941fc8495bc55eef89511bec16d34b9a3c431"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1e2948c21398d98ada51f27bd9fa3ada439e03d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh93sKCRBK7hj4Ov3rIwAAadUIAF4Hptr5bFGuZesdGJ5CzzRa\n53FiQvmHYb2KgKb4BBGHapLmAOVTpL4s/AnuJBuEvyWLlmMvJpfIqVRg3aNU/+Mr\nKFG0lFF1uor9O3Hj5dThN9Bx1UYTZwVEzEXMdT0L9H0VGPCNHI4b2HkSmPb9Ymu6\nkq2mHXN70MihYYr1QluHHV1j+60i99kLyU+1XSccSDS6btQ6CkJ7uyd3ebTQ3Ip2\nHcSecRLKslxjq/6+JtkSA42AFOnzDxjzQ8wzQoyjXgRApNOlJIkBa6JxMKcp/63n\n6cWxAIrjXm5E7ZgmwmQwniw3yhJ0UZwUPvz/XO1mF/FBKzR62mjWKeRojRk3uUg=\n=4N7u\n-----END PGP SIGNATURE-----\n", "payload": "tree 776941fc8495bc55eef89511bec16d34b9a3c431\nparent 8fd2ff57fa936f1fb24afe1f452e8d2ef9b485d6\nparent 858d6a071199b30ea95c744895f61f93ad188ffb\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643608842 +0100\ncommitter GitHub <noreply@github.com> 1643608842 +0100\n\nRollup merge of #93461 - dtolnay:fmtyield, r=davidtwco\n\nAccommodate yield points in the format_args expansion\n\nFixes #93274.\n\nFor the case `println!(\"{} {:?}\", \"\", async {}.await)` in the issue, the expansion before:\n\n```rust\n::std::io::_print(\n    ::core::fmt::Arguments::new_v1(\n        &[\"\", \" \", \"\\n\"],\n        &[\n            ::core::fmt::ArgumentV1::new(&\"\", ::core::fmt::Display::fmt),\n            ::core::fmt::ArgumentV1::new(&async {}.await, ::core::fmt::Debug::fmt),\n        ],\n    ),\n);\n```\n\nAfter:\n\n```rust\n::std::io::_print(\n    ::core::fmt::Arguments::new_v1(\n        &[\"\", \" \", \"\\n\"],\n        &match (&\"\", &async {}.await) {\n            _args => [\n                ::core::fmt::ArgumentV1::new(_args.0, ::core::fmt::Display::fmt),\n                ::core::fmt::ArgumentV1::new(_args.1, ::core::fmt::Debug::fmt),\n            ],\n        },\n    ),\n);\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e2948c21398d98ada51f27bd9fa3ada439e03d", "html_url": "https://github.com/rust-lang/rust/commit/c1e2948c21398d98ada51f27bd9fa3ada439e03d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1e2948c21398d98ada51f27bd9fa3ada439e03d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fd2ff57fa936f1fb24afe1f452e8d2ef9b485d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd2ff57fa936f1fb24afe1f452e8d2ef9b485d6", "html_url": "https://github.com/rust-lang/rust/commit/8fd2ff57fa936f1fb24afe1f452e8d2ef9b485d6"}, {"sha": "858d6a071199b30ea95c744895f61f93ad188ffb", "url": "https://api.github.com/repos/rust-lang/rust/commits/858d6a071199b30ea95c744895f61f93ad188ffb", "html_url": "https://github.com/rust-lang/rust/commit/858d6a071199b30ea95c744895f61f93ad188ffb"}], "stats": {"total": 88, "additions": 84, "deletions": 4}, "files": [{"sha": "aaa6580acc6f08543d8895009306d3fc29229f32", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c1e2948c21398d98ada51f27bd9fa3ada439e03d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e2948c21398d98ada51f27bd9fa3ada439e03d/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=c1e2948c21398d98ada51f27bd9fa3ada439e03d", "patch": "@@ -4,6 +4,7 @@ use Position::*;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::tokenstream::TokenStream;\n+use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, Applicability, DiagnosticBuilder};\n@@ -788,17 +789,31 @@ impl<'a, 'b> Context<'a, 'b> {\n         // the order provided to fmt::Arguments. When arguments are repeated, we\n         // want the expression evaluated only once.\n         //\n-        // Thus in the not nicely ordered case we emit the following instead:\n+        // Further, if any arg _after the first one_ contains a yield point such\n+        // as `await` or `yield`, the above short form is inconvenient for the\n+        // caller because it would keep a temporary of type ArgumentV1 alive\n+        // across the yield point. ArgumentV1 can't implement Send since it\n+        // holds a type-erased arbitrary type.\n+        //\n+        // Thus in the not nicely ordered case, and in the yielding case, we\n+        // emit the following instead:\n         //\n         //     match (&$arg0, &$arg1, \u2026) {\n         //         args => [ArgumentV1::new(args.$i, \u2026), ArgumentV1::new(args.$j, \u2026), \u2026]\n         //     }\n         //\n         // for the sequence of indices $i, $j, \u2026 governed by fmt_arg_index_and_ty.\n+        // This more verbose representation ensures that all arguments are\n+        // evaluated a single time each, in the order written by the programmer,\n+        // and that the surrounding future/generator (if any) is Send whenever\n+        // possible.\n+        let no_need_for_match =\n+            nicely_ordered && !original_args.iter().skip(1).any(|e| may_contain_yield_point(e));\n+\n         for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n             let e = &mut original_args[arg_index];\n             let span = e.span;\n-            let arg = if nicely_ordered {\n+            let arg = if no_need_for_match {\n                 let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n                 // The indices are strictly ordered so e has not been taken yet.\n                 self.ecx.expr_addr_of(expansion_span, P(e.take()))\n@@ -814,10 +829,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         let args_array = self.ecx.expr_vec(self.macsp, fmt_args);\n         let args_slice = self.ecx.expr_addr_of(\n             self.macsp,\n-            if nicely_ordered {\n+            if no_need_for_match {\n                 args_array\n             } else {\n-                // In the !nicely_ordered case, none of the exprs were moved\n+                // In the !no_need_for_match case, none of the exprs were moved\n                 // away in the previous loop.\n                 //\n                 // This uses the arg span for `&arg` so that borrowck errors\n@@ -1226,3 +1241,35 @@ pub fn expand_preparsed_format_args(\n \n     cx.into_expr()\n }\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            self.0 = true;\n+        }\n+\n+        fn visit_attribute(&mut self, _: &ast::Attribute) {\n+            // Conservatively assume this may be a proc macro attribute in\n+            // expression position.\n+            self.0 = true;\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}, {"sha": "e484074cc9a557492ab1463d06daaf7c0cb1a89d", "filename": "src/test/ui/fmt/format-with-yield-point.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c1e2948c21398d98ada51f27bd9fa3ada439e03d/src%2Ftest%2Fui%2Ffmt%2Fformat-with-yield-point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1e2948c21398d98ada51f27bd9fa3ada439e03d/src%2Ftest%2Fui%2Ffmt%2Fformat-with-yield-point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-with-yield-point.rs?ref=c1e2948c21398d98ada51f27bd9fa3ada439e03d", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+// edition:2021\n+\n+macro_rules! m {\n+    () => {\n+        async {}.await\n+    };\n+}\n+\n+async fn with_await() {\n+    println!(\"{} {:?}\", \"\", async {}.await);\n+}\n+\n+async fn with_macro_call_expr() {\n+    println!(\"{} {:?}\", \"\", m!());\n+}\n+\n+async fn with_macro_call_stmt_semi() {\n+    println!(\"{} {:?}\", \"\", { m!(); });\n+}\n+\n+async fn with_macro_call_stmt_braced() {\n+    println!(\"{} {:?}\", \"\", { m!{} });\n+}\n+\n+fn assert_send(_: impl Send) {}\n+\n+fn main() {\n+    assert_send(with_await());\n+    assert_send(with_macro_call_expr());\n+    assert_send(with_macro_call_stmt_semi());\n+    assert_send(with_macro_call_stmt_braced());\n+}"}]}