{"sha": "fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZGIzMmFkZmM0OWUwZDY5YjdmZDhlNDQxMzViZWE1OTM4MmQyY2I=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-11T23:05:07Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-12T00:03:04Z"}, "message": "Group references by FileId", "tree": {"sha": "5cffb6d3f0a0a168bfa48d7adcd6fa233e30b3db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cffb6d3f0a0a168bfa48d7adcd6fa233e30b3db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "html_url": "https://github.com/rust-lang/rust/commit/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52fa926f005890f07dffc789c84c2be57a6bdccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/52fa926f005890f07dffc789c84c2be57a6bdccc", "html_url": "https://github.com/rust-lang/rust/commit/52fa926f005890f07dffc789c84c2be57a6bdccc"}], "stats": {"total": 580, "additions": 324, "deletions": 256}, "files": [{"sha": "21b13977b6e53f9dcb932dcd7195c3d8894894a4", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -2,12 +2,16 @@ use std::iter;\n \n use either::Either;\n use hir::{AsName, Module, ModuleDef, Name, Variant};\n-use ide_db::helpers::{\n-    insert_use::{insert_use, ImportScope},\n-    mod_path_to_ast,\n+use ide_db::{\n+    defs::Definition,\n+    helpers::{\n+        insert_use::{insert_use, ImportScope},\n+        mod_path_to_ast,\n+    },\n+    search::{FileReference, FileReferences},\n+    RootDatabase,\n };\n-use ide_db::{defs::Definition, search::Reference, RootDatabase};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashSet;\n use syntax::{\n     algo::{find_node_at_offset, SyntaxRewriter},\n     ast::{self, edit::IndentLevel, make, AstNode, NameOwner, VisibilityOwner},\n@@ -58,29 +62,29 @@ pub(crate) fn extract_struct_from_enum_variant(\n             let mut visited_modules_set = FxHashSet::default();\n             let current_module = enum_hir.module(ctx.db());\n             visited_modules_set.insert(current_module);\n-            let mut rewriters = FxHashMap::default();\n-            for reference in usages {\n-                let rewriter = rewriters\n-                    .entry(reference.file_range.file_id)\n-                    .or_insert_with(SyntaxRewriter::default);\n-                let source_file = ctx.sema.parse(reference.file_range.file_id);\n-                update_reference(\n-                    ctx,\n-                    rewriter,\n-                    reference,\n-                    &source_file,\n-                    &enum_module_def,\n-                    &variant_hir_name,\n-                    &mut visited_modules_set,\n-                );\n-            }\n-            let mut rewriter =\n-                rewriters.remove(&ctx.frange.file_id).unwrap_or_else(SyntaxRewriter::default);\n-            for (file_id, rewriter) in rewriters {\n+            let mut def_rewriter = None;\n+            for FileReferences { file_id, references: refs } in usages {\n+                let mut rewriter = SyntaxRewriter::default();\n+                let source_file = ctx.sema.parse(file_id);\n+                for reference in refs {\n+                    update_reference(\n+                        ctx,\n+                        &mut rewriter,\n+                        reference,\n+                        &source_file,\n+                        &enum_module_def,\n+                        &variant_hir_name,\n+                        &mut visited_modules_set,\n+                    );\n+                }\n+                if file_id == ctx.frange.file_id {\n+                    def_rewriter = Some(rewriter);\n+                    continue;\n+                }\n                 builder.edit_file(file_id);\n                 builder.rewrite(rewriter);\n             }\n-            builder.edit_file(ctx.frange.file_id);\n+            let mut rewriter = def_rewriter.unwrap_or_default();\n             update_variant(&mut rewriter, &variant);\n             extract_struct_def(\n                 &mut rewriter,\n@@ -90,6 +94,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 &variant.parent_enum().syntax().clone().into(),\n                 enum_ast.visibility(),\n             );\n+            builder.edit_file(ctx.frange.file_id);\n             builder.rewrite(rewriter);\n         },\n     )\n@@ -205,13 +210,13 @@ fn update_variant(rewriter: &mut SyntaxRewriter, variant: &ast::Variant) -> Opti\n fn update_reference(\n     ctx: &AssistContext,\n     rewriter: &mut SyntaxRewriter,\n-    reference: Reference,\n+    reference: FileReference,\n     source_file: &SourceFile,\n     enum_module_def: &ModuleDef,\n     variant_hir_name: &Name,\n     visited_modules_set: &mut FxHashSet<Module>,\n ) -> Option<()> {\n-    let offset = reference.file_range.range.start();\n+    let offset = reference.range.start();\n     let (segment, expr) = if let Some(path_expr) =\n         find_node_at_offset::<ast::PathExpr>(source_file.syntax(), offset)\n     {"}, {"sha": "928df6825fc554959fe4071a6322a75d67f16535", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -1,4 +1,7 @@\n-use ide_db::{defs::Definition, search::ReferenceKind};\n+use ide_db::{\n+    defs::Definition,\n+    search::{FileReference, ReferenceKind},\n+};\n use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n@@ -63,48 +66,44 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         let_stmt.syntax().text_range()\n     };\n \n-    let mut wrap_in_parens = vec![true; refs.len()];\n-\n-    for (i, desc) in refs.iter().enumerate() {\n-        let usage_node = ctx\n-            .covering_node_for_range(desc.file_range.range)\n-            .ancestors()\n-            .find_map(ast::PathExpr::cast)?;\n-        let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n-        let usage_parent = match usage_parent_option {\n-            Some(u) => u,\n-            None => {\n-                wrap_in_parens[i] = false;\n-                continue;\n-            }\n-        };\n-\n-        wrap_in_parens[i] = match (&initializer_expr, usage_parent) {\n-            (ast::Expr::CallExpr(_), _)\n-            | (ast::Expr::IndexExpr(_), _)\n-            | (ast::Expr::MethodCallExpr(_), _)\n-            | (ast::Expr::FieldExpr(_), _)\n-            | (ast::Expr::TryExpr(_), _)\n-            | (ast::Expr::RefExpr(_), _)\n-            | (ast::Expr::Literal(_), _)\n-            | (ast::Expr::TupleExpr(_), _)\n-            | (ast::Expr::ArrayExpr(_), _)\n-            | (ast::Expr::ParenExpr(_), _)\n-            | (ast::Expr::PathExpr(_), _)\n-            | (ast::Expr::BlockExpr(_), _)\n-            | (ast::Expr::EffectExpr(_), _)\n-            | (_, ast::Expr::CallExpr(_))\n-            | (_, ast::Expr::TupleExpr(_))\n-            | (_, ast::Expr::ArrayExpr(_))\n-            | (_, ast::Expr::ParenExpr(_))\n-            | (_, ast::Expr::ForExpr(_))\n-            | (_, ast::Expr::WhileExpr(_))\n-            | (_, ast::Expr::BreakExpr(_))\n-            | (_, ast::Expr::ReturnExpr(_))\n-            | (_, ast::Expr::MatchExpr(_)) => false,\n-            _ => true,\n-        };\n-    }\n+    let wrap_in_parens = refs\n+        .iter()\n+        .flat_map(|refs| &refs.references)\n+        .map(|&FileReference { range, .. }| {\n+            let usage_node =\n+                ctx.covering_node_for_range(range).ancestors().find_map(ast::PathExpr::cast)?;\n+            let usage_parent_option = usage_node.syntax().parent().and_then(ast::Expr::cast);\n+            let usage_parent = match usage_parent_option {\n+                Some(u) => u,\n+                None => return Ok(false),\n+            };\n+\n+            Ok(!matches!((&initializer_expr, usage_parent),\n+                (ast::Expr::CallExpr(_), _)\n+                | (ast::Expr::IndexExpr(_), _)\n+                | (ast::Expr::MethodCallExpr(_), _)\n+                | (ast::Expr::FieldExpr(_), _)\n+                | (ast::Expr::TryExpr(_), _)\n+                | (ast::Expr::RefExpr(_), _)\n+                | (ast::Expr::Literal(_), _)\n+                | (ast::Expr::TupleExpr(_), _)\n+                | (ast::Expr::ArrayExpr(_), _)\n+                | (ast::Expr::ParenExpr(_), _)\n+                | (ast::Expr::PathExpr(_), _)\n+                | (ast::Expr::BlockExpr(_), _)\n+                | (ast::Expr::EffectExpr(_), _)\n+                | (_, ast::Expr::CallExpr(_))\n+                | (_, ast::Expr::TupleExpr(_))\n+                | (_, ast::Expr::ArrayExpr(_))\n+                | (_, ast::Expr::ParenExpr(_))\n+                | (_, ast::Expr::ForExpr(_))\n+                | (_, ast::Expr::WhileExpr(_))\n+                | (_, ast::Expr::BreakExpr(_))\n+                | (_, ast::Expr::ReturnExpr(_))\n+                | (_, ast::Expr::MatchExpr(_))\n+            ))\n+        })\n+        .collect::<Result<Vec<_>, _>>()?;\n \n     let init_str = initializer_expr.syntax().text().to_string();\n     let init_in_paren = format!(\"({})\", &init_str);\n@@ -116,15 +115,17 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n         target,\n         move |builder| {\n             builder.delete(delete_range);\n-            for (desc, should_wrap) in refs.iter().zip(wrap_in_parens) {\n+            for (reference, should_wrap) in\n+                refs.iter().flat_map(|refs| &refs.references).zip(wrap_in_parens)\n+            {\n                 let replacement =\n                     if should_wrap { init_in_paren.clone() } else { init_str.clone() };\n-                match desc.kind {\n+                match reference.kind {\n                     ReferenceKind::FieldShorthandForLocal => {\n                         mark::hit!(inline_field_shorthand);\n-                        builder.insert(desc.file_range.range.end(), format!(\": {}\", replacement))\n+                        builder.insert(reference.range.end(), format!(\": {}\", replacement))\n                     }\n-                    _ => builder.replace(desc.file_range.range, replacement),\n+                    _ => builder.replace(reference.range, replacement),\n                 }\n             }\n         },"}, {"sha": "4f3b8ac4617f5807aae7effee4b631efd76b84d3", "filename": "crates/assists/src/handlers/remove_unused_param.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -1,8 +1,11 @@\n-use ide_db::{defs::Definition, search::Reference};\n+use ide_db::{\n+    defs::Definition,\n+    search::{FileReference, FileReferences},\n+};\n use syntax::{\n     algo::find_node_at_range,\n     ast::{self, ArgListOwner},\n-    AstNode, SyntaxKind, SyntaxNode, TextRange, T,\n+    AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, T,\n };\n use test_utils::mark;\n use SyntaxKind::WHITESPACE;\n@@ -58,32 +61,40 @@ pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Opt\n         param.syntax().text_range(),\n         |builder| {\n             builder.delete(range_to_remove(param.syntax()));\n-            for usage in fn_def.usages(&ctx.sema).all() {\n-                process_usage(ctx, builder, usage, param_position);\n+            for usages in fn_def.usages(&ctx.sema).all() {\n+                process_usages(ctx, builder, usages, param_position);\n             }\n         },\n     )\n }\n \n-fn process_usage(\n+fn process_usages(\n     ctx: &AssistContext,\n     builder: &mut AssistBuilder,\n-    usage: Reference,\n+    usages: FileReferences,\n+    arg_to_remove: usize,\n+) {\n+    let source_file = ctx.sema.parse(usages.file_id);\n+    builder.edit_file(usages.file_id);\n+    for usage in usages.references {\n+        if let Some(text_range) = process_usage(&source_file, usage, arg_to_remove) {\n+            builder.delete(text_range);\n+        }\n+    }\n+}\n+\n+fn process_usage(\n+    source_file: &SourceFile,\n+    FileReference { range, .. }: FileReference,\n     arg_to_remove: usize,\n-) -> Option<()> {\n-    let source_file = ctx.sema.parse(usage.file_range.file_id);\n-    let call_expr: ast::CallExpr =\n-        find_node_at_range(source_file.syntax(), usage.file_range.range)?;\n+) -> Option<TextRange> {\n+    let call_expr: ast::CallExpr = find_node_at_range(source_file.syntax(), range)?;\n     let call_expr_range = call_expr.expr()?.syntax().text_range();\n-    if !call_expr_range.contains_range(usage.file_range.range) {\n+    if !call_expr_range.contains_range(range) {\n         return None;\n     }\n     let arg = call_expr.arg_list()?.args().nth(arg_to_remove)?;\n-\n-    builder.edit_file(usage.file_range.file_id);\n-    builder.delete(range_to_remove(arg.syntax()));\n-\n-    Some(())\n+    Some(range_to_remove(arg.syntax()))\n }\n \n fn range_to_remove(node: &SyntaxNode) -> TextRange {"}, {"sha": "90d3b9a31e6b544511e24cca308e0798f0e6232d", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -3,8 +3,8 @@\n use indexmap::IndexMap;\n \n use hir::Semantics;\n-use ide_db::call_info::FnCallNode;\n use ide_db::RootDatabase;\n+use ide_db::{call_info::FnCallNode, search::FileReferences};\n use syntax::{ast, AstNode, TextRange};\n \n use crate::{\n@@ -47,22 +47,23 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n \n     let mut calls = CallLocations::default();\n \n-    for reference in refs.info.references() {\n-        let file_id = reference.file_range.file_id;\n+    for &FileReferences { file_id, ref references } in refs.info.references() {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n-        let token = file.token_at_offset(reference.file_range.range.start()).next()?;\n-        let token = sema.descend_into_macros(token);\n-        let syntax = token.parent();\n-\n-        // This target is the containing function\n-        if let Some(nav) = syntax.ancestors().find_map(|node| {\n-            let fn_ = ast::Fn::cast(node)?;\n-            let def = sema.to_def(&fn_)?;\n-            def.try_to_nav(sema.db)\n-        }) {\n-            let relative_range = reference.file_range.range;\n-            calls.add(&nav, relative_range);\n+        for reference in references {\n+            let token = file.token_at_offset(reference.range.start()).next()?;\n+            let token = sema.descend_into_macros(token);\n+            let syntax = token.parent();\n+\n+            // This target is the containing function\n+            if let Some(nav) = syntax.ancestors().find_map(|node| {\n+                let fn_ = ast::Fn::cast(node)?;\n+                let def = sema.to_def(&fn_)?;\n+                def.try_to_nav(sema.db)\n+            }) {\n+                let relative_range = reference.range;\n+                calls.add(&nav, relative_range);\n+            }\n         }\n     }\n "}, {"sha": "1e03832ece885275c36e53335afbba7b99e6f893", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -92,7 +92,7 @@ pub use ide_db::base_db::{\n };\n pub use ide_db::{\n     call_info::CallInfo,\n-    search::{Reference, ReferenceAccess, ReferenceKind},\n+    search::{FileReference, ReferenceAccess, ReferenceKind},\n };\n pub use ide_db::{\n     label::Label,"}, {"sha": "132680bfbf0a3ab9b1f470be2437c46670d62506", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -14,8 +14,7 @@ pub(crate) mod rename;\n use hir::Semantics;\n use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n-    search::Reference,\n-    search::{ReferenceAccess, ReferenceKind, SearchScope},\n+    search::{FileReference, FileReferences, ReferenceAccess, ReferenceKind, SearchScope},\n     RootDatabase,\n };\n use syntax::{\n@@ -29,7 +28,7 @@ use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeI\n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n     declaration: Declaration,\n-    references: Vec<Reference>,\n+    references: Vec<FileReferences>,\n }\n \n #[derive(Debug, Clone)]\n@@ -48,7 +47,7 @@ impl ReferenceSearchResult {\n         &self.declaration.nav\n     }\n \n-    pub fn references(&self) -> &[Reference] {\n+    pub fn references(&self) -> &[FileReferences] {\n         &self.references\n     }\n \n@@ -63,20 +62,22 @@ impl ReferenceSearchResult {\n // allow turning ReferenceSearchResult into an iterator\n // over References\n impl IntoIterator for ReferenceSearchResult {\n-    type Item = Reference;\n-    type IntoIter = std::vec::IntoIter<Reference>;\n+    type Item = FileReferences;\n+    type IntoIter = std::vec::IntoIter<FileReferences>;\n \n     fn into_iter(mut self) -> Self::IntoIter {\n         let mut v = Vec::with_capacity(self.len());\n-        v.push(Reference {\n-            file_range: FileRange {\n-                file_id: self.declaration.nav.file_id,\n-                range: self.declaration.nav.focus_or_full_range(),\n-            },\n+        v.append(&mut self.references);\n+        let decl_ref = FileReference {\n+            range: self.declaration.nav.focus_or_full_range(),\n             kind: self.declaration.kind,\n             access: self.declaration.access,\n-        });\n-        v.append(&mut self.references);\n+        };\n+        let file_id = self.declaration.nav.file_id;\n+        match v.iter_mut().find(|it| it.file_id == file_id) {\n+            Some(file_refs) => file_refs.references.push(decl_ref),\n+            None => v.push(FileReferences { file_id, references: vec![decl_ref] }),\n+        }\n         v.into_iter()\n     }\n }\n@@ -109,13 +110,11 @@ pub(crate) fn find_all_refs(\n \n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n-    let references = def\n-        .usages(sema)\n-        .set_scope(search_scope)\n-        .all()\n-        .into_iter()\n-        .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n-        .collect();\n+    let mut references = def.usages(sema).set_scope(search_scope).all();\n+    references.iter_mut().for_each(|it| {\n+        it.references.retain(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n+    });\n+    references.retain(|r| !r.references.is_empty());\n \n     let nav = def.try_to_nav(sema.db)?;\n     let decl_range = nav.focus_or_full_range();\n@@ -255,7 +254,8 @@ fn try_find_self_references(\n     syntax: &SyntaxNode,\n     position: FilePosition,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n-    let self_token = syntax.token_at_offset(position.offset).find(|t| t.kind() == T![self])?;\n+    let FilePosition { file_id, offset } = position;\n+    let self_token = syntax.token_at_offset(offset).find(|t| t.kind() == T![self])?;\n     let parent = self_token.parent();\n     match_ast! {\n         match parent {\n@@ -276,7 +276,7 @@ fn try_find_self_references(\n \n     let declaration = Declaration {\n         nav: NavigationTarget {\n-            file_id: position.file_id,\n+            file_id,\n             full_range: self_param.syntax().text_range(),\n             focus_range: Some(param_self_token.text_range()),\n             name: param_self_token.text().clone(),\n@@ -295,25 +295,29 @@ fn try_find_self_references(\n     let references = function\n         .body()\n         .map(|body| {\n-            body.syntax()\n-                .descendants()\n-                .filter_map(ast::PathExpr::cast)\n-                .filter_map(|expr| {\n-                    let path = expr.path()?;\n-                    if path.qualifier().is_none() {\n-                        path.segment()?.self_token()\n-                    } else {\n-                        None\n-                    }\n-                })\n-                .map(|token| Reference {\n-                    file_range: FileRange { file_id: position.file_id, range: token.text_range() },\n-                    kind: ReferenceKind::SelfKw,\n-                    access: declaration.access, // FIXME: properly check access kind here instead of copying it from the declaration\n-                })\n-                .collect()\n+            FileReferences {\n+                file_id,\n+                references: body\n+                    .syntax()\n+                    .descendants()\n+                    .filter_map(ast::PathExpr::cast)\n+                    .filter_map(|expr| {\n+                        let path = expr.path()?;\n+                        if path.qualifier().is_none() {\n+                            path.segment()?.self_token()\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .map(|token| FileReference {\n+                        range: token.text_range(),\n+                        kind: ReferenceKind::SelfKw,\n+                        access: declaration.access, // FIXME: properly check access kind here instead of copying it from the declaration\n+                    })\n+                    .collect(),\n+            }\n         })\n-        .unwrap_or_default();\n+        .map_or_else(Vec::default, |it| vec![it]);\n \n     Some(RangeInfo::new(\n         param_self_token.text_range(),\n@@ -324,7 +328,7 @@ fn try_find_self_references(\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n-    use ide_db::base_db::FileId;\n+    use ide_db::{base_db::FileId, search::FileReferences};\n     use stdx::format_to;\n \n     use crate::{fixture, SearchScope};\n@@ -1018,12 +1022,14 @@ impl Foo {\n             actual += \"\\n\\n\";\n         }\n \n-        for r in &refs.references {\n-            format_to!(actual, \"{:?} {:?} {:?}\", r.file_range.file_id, r.file_range.range, r.kind);\n-            if let Some(access) = r.access {\n-                format_to!(actual, \" {:?}\", access);\n+        for FileReferences { file_id, references } in refs.references {\n+            for r in references {\n+                format_to!(actual, \"{:?} {:?} {:?}\", file_id, r.range, r.kind);\n+                if let Some(access) = r.access {\n+                    format_to!(actual, \" {:?}\", access);\n+                }\n+                actual += \"\\n\";\n             }\n-            actual += \"\\n\";\n         }\n         expect.assert_eq(&actual)\n     }"}, {"sha": "dd08e1c32dc3971e1850a14e2520013f1c8b5884", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -6,9 +6,10 @@ use std::{\n };\n \n use hir::{Module, ModuleDef, ModuleSource, Semantics};\n-use ide_db::base_db::{AnchoredPathBuf, FileId, FileRange, SourceDatabaseExt};\n use ide_db::{\n+    base_db::{AnchoredPathBuf, FileId, FileRange, SourceDatabaseExt},\n     defs::{Definition, NameClass, NameRefClass},\n+    search::FileReferences,\n     RootDatabase,\n };\n use syntax::{\n@@ -20,8 +21,8 @@ use test_utils::mark;\n use text_edit::TextEdit;\n \n use crate::{\n-    FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind, ReferenceSearchResult,\n-    SourceChange, SourceFileEdit, TextRange, TextSize,\n+    FilePosition, FileSystemEdit, RangeInfo, ReferenceKind, ReferenceSearchResult, SourceChange,\n+    SourceFileEdit, TextRange, TextSize,\n };\n \n type RenameResult<T> = Result<T, RenameError>;\n@@ -173,39 +174,45 @@ fn find_all_refs(\n         .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n-fn source_edit_from_reference(\n+fn source_edit_from_references(\n     sema: &Semantics<RootDatabase>,\n-    reference: Reference,\n+    &FileReferences { file_id, ref references }: &FileReferences,\n     new_name: &str,\n ) -> SourceFileEdit {\n-    let mut replacement_text = String::new();\n-    let range = match reference.kind {\n-        ReferenceKind::FieldShorthandForField => {\n-            mark::hit!(test_rename_struct_field_for_shorthand);\n-            replacement_text.push_str(new_name);\n-            replacement_text.push_str(\": \");\n-            TextRange::new(reference.file_range.range.start(), reference.file_range.range.start())\n-        }\n-        ReferenceKind::FieldShorthandForLocal => {\n-            mark::hit!(test_rename_local_for_field_shorthand);\n-            replacement_text.push_str(\": \");\n-            replacement_text.push_str(new_name);\n-            TextRange::new(reference.file_range.range.end(), reference.file_range.range.end())\n-        }\n-        ReferenceKind::RecordFieldExprOrPat => {\n-            mark::hit!(test_rename_field_expr_pat);\n-            replacement_text.push_str(new_name);\n-            edit_text_range_for_record_field_expr_or_pat(sema, reference.file_range, new_name)\n-        }\n-        _ => {\n-            replacement_text.push_str(new_name);\n-            reference.file_range.range\n-        }\n-    };\n-    SourceFileEdit {\n-        file_id: reference.file_range.file_id,\n-        edit: TextEdit::replace(range, replacement_text),\n+    let mut edit = TextEdit::builder();\n+    for reference in references {\n+        let mut replacement_text = String::new();\n+        let range = match reference.kind {\n+            ReferenceKind::FieldShorthandForField => {\n+                mark::hit!(test_rename_struct_field_for_shorthand);\n+                replacement_text.push_str(new_name);\n+                replacement_text.push_str(\": \");\n+                TextRange::new(reference.range.start(), reference.range.start())\n+            }\n+            ReferenceKind::FieldShorthandForLocal => {\n+                mark::hit!(test_rename_local_for_field_shorthand);\n+                replacement_text.push_str(\": \");\n+                replacement_text.push_str(new_name);\n+                TextRange::new(reference.range.end(), reference.range.end())\n+            }\n+            ReferenceKind::RecordFieldExprOrPat => {\n+                mark::hit!(test_rename_field_expr_pat);\n+                replacement_text.push_str(new_name);\n+                edit_text_range_for_record_field_expr_or_pat(\n+                    sema,\n+                    FileRange { file_id, range: reference.range },\n+                    new_name,\n+                )\n+            }\n+            _ => {\n+                replacement_text.push_str(new_name);\n+                reference.range\n+            }\n+        };\n+        edit.replace(range, replacement_text);\n     }\n+\n+    SourceFileEdit { file_id, edit: edit.finish() }\n }\n \n fn edit_text_range_for_record_field_expr_or_pat(\n@@ -277,9 +284,9 @@ fn rename_mod(\n \n     let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n     let ref_edits = refs\n-        .references\n-        .into_iter()\n-        .map(|reference| source_edit_from_reference(sema, reference, new_name));\n+        .references()\n+        .iter()\n+        .map(|reference| source_edit_from_references(sema, reference, new_name));\n     source_file_edits.extend(ref_edits);\n \n     Ok(RangeInfo::new(range, SourceChange::from_edits(source_file_edits, file_system_edits)))\n@@ -331,17 +338,10 @@ fn rename_to_self(\n \n     let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n \n-    let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n-        .into_iter()\n-        .partition(|reference| param_range.intersect(reference.file_range.range).is_some());\n-\n-    if param_ref.is_empty() {\n-        bail!(\"Parameter to rename not found\");\n-    }\n-\n-    let mut edits = usages\n-        .into_iter()\n-        .map(|reference| source_edit_from_reference(sema, reference, \"self\"))\n+    let mut edits = refs\n+        .references()\n+        .iter()\n+        .map(|reference| source_edit_from_references(sema, reference, \"self\"))\n         .collect::<Vec<_>>();\n \n     edits.push(SourceFileEdit {\n@@ -467,7 +467,7 @@ fn rename_reference(\n \n     let edit = refs\n         .into_iter()\n-        .map(|reference| source_edit_from_reference(sema, reference, new_name))\n+        .map(|reference| source_edit_from_references(sema, &reference, new_name))\n         .collect::<Vec<_>>();\n \n     Ok(RangeInfo::new(range, SourceChange::from(edit)))"}, {"sha": "b8359a9b4dd96c8859e1badd91dcbeb16970643e", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -8,6 +8,7 @@ use std::{convert::TryInto, mem};\n \n use base_db::{FileId, FileRange, SourceDatabaseExt};\n use hir::{DefWithBody, HasSource, Module, ModuleSource, Semantics, Visibility};\n+use itertools::Itertools;\n use once_cell::unsync::Lazy;\n use rustc_hash::FxHashMap;\n use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n@@ -19,8 +20,22 @@ use crate::{\n };\n \n #[derive(Debug, Clone)]\n-pub struct Reference {\n-    pub file_range: FileRange,\n+pub struct FileReferences {\n+    pub file_id: FileId,\n+    pub references: Vec<FileReference>,\n+}\n+\n+impl FileReferences {\n+    pub fn file_ranges(&self) -> impl Iterator<Item = FileRange> + '_ {\n+        self.references\n+            .iter()\n+            .map(move |&FileReference { range, .. }| FileRange { file_id: self.file_id, range })\n+    }\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct FileReference {\n+    pub range: TextRange,\n     pub kind: ReferenceKind,\n     pub access: Option<ReferenceAccess>,\n }\n@@ -252,23 +267,33 @@ impl<'a> FindUsages<'a> {\n \n     pub fn at_least_one(self) -> bool {\n         let mut found = false;\n-        self.search(&mut |_reference| {\n+        self.search(&mut |_, _| {\n             found = true;\n             true\n         });\n         found\n     }\n \n-    pub fn all(self) -> Vec<Reference> {\n-        let mut res = Vec::new();\n-        self.search(&mut |reference| {\n-            res.push(reference);\n+    /// The [`FileReferences`] returned always have unique [`FileId`]s.\n+    pub fn all(self) -> Vec<FileReferences> {\n+        let mut res = <Vec<FileReferences>>::new();\n+        self.search(&mut |file_id, reference| {\n+            match res.iter_mut().find(|it| it.file_id == file_id) {\n+                Some(file_refs) => file_refs.references.push(reference),\n+                _ => res.push(FileReferences { file_id, references: vec![reference] }),\n+            }\n             false\n         });\n+        assert!(res\n+            .iter()\n+            .map(|refs| refs.file_id)\n+            .sorted_unstable()\n+            .tuple_windows::<(_, _)>()\n+            .all(|(a, b)| a < b));\n         res\n     }\n \n-    fn search(self, sink: &mut dyn FnMut(Reference) -> bool) {\n+    fn search(self, sink: &mut dyn FnMut(FileId, FileReference) -> bool) {\n         let _p = profile::span(\"FindUsages:search\");\n         let sema = self.sema;\n \n@@ -320,16 +345,14 @@ impl<'a> FindUsages<'a> {\n     fn found_lifetime(\n         &self,\n         lifetime: &ast::Lifetime,\n-        sink: &mut dyn FnMut(Reference) -> bool,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify_lifetime(self.sema, lifetime) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n-                let reference = Reference {\n-                    file_range: self.sema.original_range(lifetime.syntax()),\n-                    kind: ReferenceKind::Lifetime,\n-                    access: None,\n-                };\n-                sink(reference)\n+                let FileRange { file_id, range } = self.sema.original_range(lifetime.syntax());\n+                let reference =\n+                    FileReference { range, kind: ReferenceKind::Lifetime, access: None };\n+                sink(file_id, reference)\n             }\n             _ => false, // not a usage\n         }\n@@ -338,7 +361,7 @@ impl<'a> FindUsages<'a> {\n     fn found_name_ref(\n         &self,\n         name_ref: &ast::NameRef,\n-        sink: &mut dyn FnMut(Reference) -> bool,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n     ) -> bool {\n         match NameRefClass::classify(self.sema, &name_ref) {\n             Some(NameRefClass::Definition(def)) if &def == self.def => {\n@@ -352,46 +375,50 @@ impl<'a> FindUsages<'a> {\n                     ReferenceKind::Other\n                 };\n \n-                let reference = Reference {\n-                    file_range: self.sema.original_range(name_ref.syntax()),\n-                    kind,\n-                    access: reference_access(&def, &name_ref),\n-                };\n-                sink(reference)\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n+                let reference =\n+                    FileReference { range, kind, access: reference_access(&def, &name_ref) };\n+                sink(file_id, reference)\n             }\n             Some(NameRefClass::FieldShorthand { local_ref: local, field_ref: field }) => {\n+                let FileRange { file_id, range } = self.sema.original_range(name_ref.syntax());\n                 let reference = match self.def {\n-                    Definition::Field(_) if &field == self.def => Reference {\n-                        file_range: self.sema.original_range(name_ref.syntax()),\n+                    Definition::Field(_) if &field == self.def => FileReference {\n+                        range,\n                         kind: ReferenceKind::FieldShorthandForField,\n                         access: reference_access(&field, &name_ref),\n                     },\n-                    Definition::Local(l) if &local == l => Reference {\n-                        file_range: self.sema.original_range(name_ref.syntax()),\n+                    Definition::Local(l) if &local == l => FileReference {\n+                        range,\n                         kind: ReferenceKind::FieldShorthandForLocal,\n                         access: reference_access(&Definition::Local(local), &name_ref),\n                     },\n                     _ => return false, // not a usage\n                 };\n-                sink(reference)\n+                sink(file_id, reference)\n             }\n             _ => false, // not a usage\n         }\n     }\n \n-    fn found_name(&self, name: &ast::Name, sink: &mut dyn FnMut(Reference) -> bool) -> bool {\n+    fn found_name(\n+        &self,\n+        name: &ast::Name,\n+        sink: &mut dyn FnMut(FileId, FileReference) -> bool,\n+    ) -> bool {\n         match NameClass::classify(self.sema, name) {\n             Some(NameClass::PatFieldShorthand { local_def: _, field_ref }) => {\n-                let reference = match self.def {\n-                    Definition::Field(_) if &field_ref == self.def => Reference {\n-                        file_range: self.sema.original_range(name.syntax()),\n-                        kind: ReferenceKind::FieldShorthandForField,\n-                        // FIXME: mutable patterns should have `Write` access\n-                        access: Some(ReferenceAccess::Read),\n-                    },\n-                    _ => return false, // not a usage\n+                if !matches!(self.def, Definition::Field(_) if &field_ref == self.def) {\n+                    return false;\n+                }\n+                let FileRange { file_id, range } = self.sema.original_range(name.syntax());\n+                let reference = FileReference {\n+                    range,\n+                    kind: ReferenceKind::FieldShorthandForField,\n+                    // FIXME: mutable patterns should have `Write` access\n+                    access: Some(ReferenceAccess::Read),\n                 };\n-                sink(reference)\n+                sink(file_id, reference)\n             }\n             _ => false, // not a usage\n         }"}, {"sha": "d862f370ad7caf931d4b244e11ebe86de93c432d", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -12,6 +12,7 @@ use ide::{\n     FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, LineIndex, NavigationTarget,\n     Query, RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange, SymbolKind, TextEdit,\n };\n+use ide_db::search::FileReferences;\n use itertools::Itertools;\n use lsp_server::ErrorCode;\n use lsp_types::{\n@@ -812,14 +813,19 @@ pub(crate) fn handle_references(\n     };\n \n     let locations = if params.context.include_declaration {\n-        refs.into_iter()\n-            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n-            .collect()\n+        let mut locations = Vec::default();\n+        refs.into_iter().for_each(|it| {\n+            locations.extend(\n+                it.file_ranges().filter_map(|frange| to_proto::location(&snap, frange).ok()),\n+            )\n+        });\n+        locations\n     } else {\n         // Only iterate over the references if include_declaration was false\n         refs.references()\n             .iter()\n-            .filter_map(|reference| to_proto::location(&snap, reference.file_range).ok())\n+            .flat_map(FileReferences::file_ranges)\n+            .filter_map(|frange| to_proto::location(&snap, frange).ok())\n             .collect()\n     };\n \n@@ -1176,7 +1182,8 @@ pub(crate) fn handle_code_lens_resolve(\n                 .map(|r| {\n                     r.references()\n                         .iter()\n-                        .filter_map(|it| to_proto::location(&snap, it.file_range).ok())\n+                        .flat_map(FileReferences::file_ranges)\n+                        .filter_map(|frange| to_proto::location(&snap, frange).ok())\n                         .collect_vec()\n                 })\n                 .unwrap_or_default();\n@@ -1221,12 +1228,18 @@ pub(crate) fn handle_document_highlight(\n \n     let res = refs\n         .into_iter()\n-        .filter(|reference| reference.file_range.file_id == position.file_id)\n-        .map(|reference| DocumentHighlight {\n-            range: to_proto::range(&line_index, reference.file_range.range),\n-            kind: reference.access.map(to_proto::document_highlight_kind),\n+        .find(|refs| refs.file_id == position.file_id)\n+        .map(|file_refs| {\n+            file_refs\n+                .references\n+                .into_iter()\n+                .map(|r| DocumentHighlight {\n+                    range: to_proto::range(&line_index, r.range),\n+                    kind: r.access.map(to_proto::document_highlight_kind),\n+                })\n+                .collect()\n         })\n-        .collect();\n+        .unwrap_or_default();\n     Ok(Some(res))\n }\n "}, {"sha": "a1d653aff6545aa154b827fad326df38c452fbf8", "filename": "crates/ssr/src/search.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbdb32adfc49e0d69b7fd8e44135bea59382d2cb/crates%2Fssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fssr%2Fsrc%2Fsearch.rs?ref=fbdb32adfc49e0d69b7fd8e44135bea59382d2cb", "patch": "@@ -5,10 +5,10 @@ use crate::{\n     resolving::{ResolvedPath, ResolvedPattern, ResolvedRule},\n     Match, MatchFinder,\n };\n-use ide_db::base_db::{FileId, FileRange};\n use ide_db::{\n+    base_db::{FileId, FileRange},\n     defs::Definition,\n-    search::{Reference, SearchScope},\n+    search::{FileReferences, SearchScope},\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode, SyntaxKind, SyntaxNode};\n@@ -20,7 +20,7 @@ use test_utils::mark;\n /// them more than once.\n #[derive(Default)]\n pub(crate) struct UsageCache {\n-    usages: Vec<(Definition, Vec<Reference>)>,\n+    usages: Vec<(Definition, Vec<FileReferences>)>,\n }\n \n impl<'db> MatchFinder<'db> {\n@@ -58,8 +58,12 @@ impl<'db> MatchFinder<'db> {\n     ) {\n         if let Some(resolved_path) = pick_path_for_usages(pattern) {\n             let definition: Definition = resolved_path.resolution.clone().into();\n-            for reference in self.find_usages(usage_cache, definition) {\n-                if let Some(node_to_match) = self.find_node_to_match(resolved_path, reference) {\n+            for file_range in self\n+                .find_usages(usage_cache, definition)\n+                .iter()\n+                .flat_map(FileReferences::file_ranges)\n+            {\n+                if let Some(node_to_match) = self.find_node_to_match(resolved_path, file_range) {\n                     if !is_search_permitted_ancestors(&node_to_match) {\n                         mark::hit!(use_declaration_with_braces);\n                         continue;\n@@ -73,11 +77,11 @@ impl<'db> MatchFinder<'db> {\n     fn find_node_to_match(\n         &self,\n         resolved_path: &ResolvedPath,\n-        reference: &Reference,\n+        file_range: FileRange,\n     ) -> Option<SyntaxNode> {\n-        let file = self.sema.parse(reference.file_range.file_id);\n+        let file = self.sema.parse(file_range.file_id);\n         let depth = resolved_path.depth as usize;\n-        let offset = reference.file_range.range.start();\n+        let offset = file_range.range.start();\n         if let Some(path) =\n             self.sema.find_node_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n         {\n@@ -108,7 +112,7 @@ impl<'db> MatchFinder<'db> {\n         &self,\n         usage_cache: &'a mut UsageCache,\n         definition: Definition,\n-    ) -> &'a [Reference] {\n+    ) -> &'a [FileReferences] {\n         // Logically if a lookup succeeds we should just return it. Unfortunately returning it would\n         // extend the lifetime of the borrow, then we wouldn't be able to do the insertion on a\n         // cache miss. This is a limitation of NLL and is fixed with Polonius. For now we do two\n@@ -250,7 +254,7 @@ fn is_search_permitted(node: &SyntaxNode) -> bool {\n }\n \n impl UsageCache {\n-    fn find(&mut self, definition: &Definition) -> Option<&[Reference]> {\n+    fn find(&mut self, definition: &Definition) -> Option<&[FileReferences]> {\n         // We expect a very small number of cache entries (generally 1), so a linear scan should be\n         // fast enough and avoids the need to implement Hash for Definition.\n         for (d, refs) in &self.usages {"}]}