{"sha": "649a7bf38a59e16da26cda03f7131f2b006d8178", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0OWE3YmYzOGE1OWUxNmRhMjZjZGEwM2Y3MTMxZjJiMDA2ZDgxNzg=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-01T18:34:52Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-01T18:34:52Z"}, "message": "Comments and cleanup.", "tree": {"sha": "d6c75f23a56e30a9ac3258fb58d7958b0401a1d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c75f23a56e30a9ac3258fb58d7958b0401a1d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/649a7bf38a59e16da26cda03f7131f2b006d8178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/649a7bf38a59e16da26cda03f7131f2b006d8178", "html_url": "https://github.com/rust-lang/rust/commit/649a7bf38a59e16da26cda03f7131f2b006d8178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/649a7bf38a59e16da26cda03f7131f2b006d8178/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8410ec7e542abc67d25eda019e0b61d333a418d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8410ec7e542abc67d25eda019e0b61d333a418d4", "html_url": "https://github.com/rust-lang/rust/commit/8410ec7e542abc67d25eda019e0b61d333a418d4"}], "stats": {"total": 71, "additions": 49, "deletions": 22}, "files": [{"sha": "3e3f8654be36b0bcbe9645034856accfd148bd49", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/649a7bf38a59e16da26cda03f7131f2b006d8178/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/649a7bf38a59e16da26cda03f7131f2b006d8178/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=649a7bf38a59e16da26cda03f7131f2b006d8178", "patch": "@@ -1,3 +1,10 @@\n+// trans.rs: Translate the completed AST to the LLVM IR.\n+//\n+// Some functions here, such as trans_block and trans_expr, return a value --\n+// the result of the translation to LLVM -- while others, such as trans_fn,\n+// trans_obj, and trans_item, are called only for the side effect of adding a\n+// particular definition to the LLVM IR output we're producing.\n+\n import std::int;\n import std::str;\n import std::uint;\n@@ -130,8 +137,9 @@ type local_ctxt = rec(vec[str] path,\n                       @crate_ctxt ccx);\n \n \n-// The type used for llself.\n-type self_vt = rec(ValueRef v, ty::t t);\n+// Types used for llself.\n+type val_self_pair = rec(ValueRef v, ty::t t);\n+type ty_self_pair = tup(TypeRef, ty::t);\n \n // Function context.  Every LLVM function we create will have one of these.\n state type fn_ctxt = rec(\n@@ -155,7 +163,7 @@ state type fn_ctxt = rec(\n     // function, due to LLVM's quirks.\n \n     // A block for all the function's allocas, so that LLVM will coalesce them\n-    // into a single alloca.\n+    // into a single alloca call.\n     mutable BasicBlockRef llallocas, \n \n     // A block containing code that copies incoming arguments to space already\n@@ -174,7 +182,7 @@ state type fn_ctxt = rec(\n     // llallocas?\n \n     // The 'self' object currently in use in this function, if there is one.\n-    mutable option::t[self_vt] llself,\n+    mutable option::t[val_self_pair] llself,\n \n     // If this function is actually a iter, a block containing the code called\n     // whenever the iter calls 'put'.\n@@ -4668,9 +4676,9 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         }\n         case (ast::expr_self_method(?ident, ?ann)) {\n             alt (cx.fcx.llself) {\n-                case (some(?s_vt)) {\n-                    auto r =  s_vt.v;\n-                    auto t =  s_vt.t;\n+                case (some(?pair)) {\n+                    auto r =  pair.v;\n+                    auto t =  pair.t;\n                     ret trans_field(cx, e.span, r, t, ident, ann);\n                 }\n                 case (_) {\n@@ -6694,7 +6702,7 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp,\n              mutable llallocas=llbbs._0,\n              mutable llcopyargs=llbbs._1,\n              mutable llderivedtydescs=llbbs._2,\n-             mutable llself=none[self_vt],\n+             mutable llself=none[val_self_pair],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n              llobjfields=llobjfields,\n@@ -6713,18 +6721,28 @@ fn new_fn_ctxt(@local_ctxt cx, &span sp,\n //  - new_fn_ctxt\n //  - trans_args\n \n+// create_llargs_for_fn_args: Creates a mapping from incoming arguments to\n+// allocas created for them.\n+//\n+// When we translate a function, we need to map its incoming arguments to the\n+// spaces that have been created for them (by code in the llallocas field of\n+// the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n+// field of the fn_ctxt with\n fn create_llargs_for_fn_args(&@fn_ctxt cx,\n                              ast::proto proto,\n-                             option::t[tup(TypeRef, ty::t)] ty_self,\n+                             option::t[ty_self_pair] ty_self,\n                              ty::t ret_ty,\n                              &vec[ast::arg] args,\n                              &vec[ast::ty_param] ty_params) {\n \n+    // Skip the implicit arguments 0, 1, and 2.  TODO: Pull out 3u and define\n+    // it as a constant, since we're using it in several places in trans this\n+    // way.\n     auto arg_n = 3u;\n \n     alt (ty_self) {\n         case (some(?tt)) {\n-            cx.llself = some[self_vt](rec(v = cx.llenv, t = tt._1));\n+            cx.llself = some[val_self_pair](rec(v = cx.llenv, t = tt._1));\n         }\n         case (none) {\n             auto i = 0u;\n@@ -6738,13 +6756,18 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n         }\n     }\n \n+    // If the function is actually an iter, populate the lliterbody field of\n+    // the function context with the ValueRef that we get from\n+    // llvm::LLVMGetParam for the iter's body.\n     if (proto == ast::proto_iter) {\n         auto llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n         assert (llarg as int != 0);\n         cx.lliterbody = some[ValueRef](llarg);\n         arg_n += 1u;\n     }\n \n+    // Populate the llargs field of the function context with the ValueRefs\n+    // that we get from llvm::LLVMGetParam for each argument.\n     for (ast::arg arg in args) {\n         auto llarg = llvm::LLVMGetParam(cx.llfn, arg_n);\n         assert (llarg as int != 0);\n@@ -6758,17 +6781,17 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n // were passed and whatnot. Apparently mem2reg will mop up.\n \n fn copy_any_self_to_alloca(@fn_ctxt fcx,\n-                           option::t[tup(TypeRef, ty::t)] ty_self) {\n+                           option::t[ty_self_pair] ty_self) {\n \n     auto bcx = llallocas_block_ctxt(fcx);\n \n     alt (fcx.llself) {\n-        case (some(?s_vt)) {\n+        case (some(?pair)) {\n             alt (ty_self) {\n-                case (some[tup(TypeRef, ty::t)](?tt)) {\n+                case (some[ty_self_pair](?tt)) {\n                     auto a = alloca(bcx, tt._0);\n-                    bcx.build.Store(s_vt.v, a);\n-                    fcx.llself = some[self_vt](rec(v = a, t = s_vt.t));\n+                    bcx.build.Store(pair.v, a);\n+                    fcx.llself = some[val_self_pair](rec(v = a, t = pair.t));\n                 }\n             }\n         }\n@@ -6842,7 +6865,7 @@ fn ret_ty_of_fn(&@crate_ctxt ccx, ast::ann ann) -> ty::t {\n     ret ret_ty_of_fn_ty(ccx, ty::ann_to_type(ccx.tcx.node_types, ann));\n }\n \n-fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n+fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n     auto bcx = llallocas_block_ctxt(fcx);\n \n     let vec[ty::t] field_tys = [];\n@@ -6921,7 +6944,7 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ast::def_id fid,\n-            option::t[tup(TypeRef, ty::t)] ty_self,\n+            option::t[ty_self_pair] ty_self,\n             &vec[ast::ty_param] ty_params, &ast::ann ann) {\n     auto llfndecl = cx.ccx.item_ids.get(fid);\n \n@@ -6949,6 +6972,10 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ast::def_id fid,\n     auto lltop = bcx.llbb;\n \n     auto block_ty = node_ann_type(cx.ccx, f.body.node.a);\n+    // This call to trans_block is the place where we bridge between\n+    // translation calls that don't have a return value (trans_crate,\n+    // trans_mod, trans_item, trans_obj, et cetera) and those that do\n+    // (trans_block, trans_expr, et cetera).\n     auto res = if (!ty::type_is_nil(cx.ccx.tcx, block_ty)\n                    && !ty::type_is_bot(cx.ccx.tcx, block_ty)) {\n         trans_block(bcx, f.body, save_in(fcx.llretptr))\n@@ -7007,7 +7034,7 @@ fn create_vtbl(@local_ctxt cx,\n         cx.ccx.item_symbols.insert(m.node.id, s);\n \n         trans_fn(mcx, m.span, m.node.meth, m.node.id,\n-                 some[tup(TypeRef, ty::t)](tup(llself_ty, self_ty)),\n+                 some[ty_self_pair](tup(llself_ty, self_ty)),\n                  ty_params, m.node.ann);\n         methods += [llfn];\n     }\n@@ -7036,7 +7063,7 @@ fn trans_dtor(@local_ctxt cx,\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n \n     trans_fn(dcx, dtor.span, dtor.node.meth, dtor.node.id,\n-             some[tup(TypeRef, ty::t)](tup(llself_ty, self_ty)),\n+             some[ty_self_pair](tup(llself_ty, self_ty)),\n              ty_params, dtor.node.ann);\n \n     ret llfn;\n@@ -7065,7 +7092,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::def_id oid,\n \n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     create_llargs_for_fn_args(fcx, ast::proto_fn,\n-                              none[tup(TypeRef, ty::t)],\n+                              none[ty_self_pair],\n                               ret_ty_of_fn(ccx, ann),\n                               fn_args, ty_params);\n \n@@ -7232,7 +7259,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n     auto fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n \n     create_llargs_for_fn_args(fcx, ast::proto_fn,\n-                              none[tup(TypeRef, ty::t)],\n+                              none[ty_self_pair],\n                               ret_ty_of_fn(cx.ccx, variant.node.ann),\n                               fn_args, ty_params);\n \n@@ -7325,7 +7352,7 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n     alt (item.node) {\n         case (ast::item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             auto sub_cx = extend_path(cx, name);\n-            trans_fn(sub_cx, item.span, f, fid, none[tup(TypeRef, ty::t)],\n+            trans_fn(sub_cx, item.span, f, fid, none[ty_self_pair],\n                      tps, ann);\n         }\n         case (ast::item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {"}]}