{"sha": "cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYmQ3MGQ0ZjI1YmMyNTVkODBiNmI5YmEwYTY1ZjZjNTk1N2YyYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-17T09:13:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-17T09:13:51Z"}, "message": "Auto merge of #54941 - pnkfelix:issue-21232-reject-partial-reinit, r=nikomatsakis\n\nreject partial init and reinit of uninitialized data\n\nReject partial initialization of uninitialized structured types (i.e. structs and tuples) and also reject partial *reinitialization* of such types.\n\nFix #54986\n\nFix #54499\n\ncc #21232", "tree": {"sha": "85fe0b9b58b570a6483c9dd5d6344f84b4b0518c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85fe0b9b58b570a6483c9dd5d6344f84b4b0518c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "html_url": "https://github.com/rust-lang/rust/commit/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7f0da367bae7587ed0ef69bd4384392099fc9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7f0da367bae7587ed0ef69bd4384392099fc9e", "html_url": "https://github.com/rust-lang/rust/commit/9d7f0da367bae7587ed0ef69bd4384392099fc9e"}, {"sha": "233fdb4b1486b3b98bd1bb80f83138924a8a734e", "url": "https://api.github.com/repos/rust-lang/rust/commits/233fdb4b1486b3b98bd1bb80f83138924a8a734e", "html_url": "https://github.com/rust-lang/rust/commit/233fdb4b1486b3b98bd1bb80f83138924a8a734e"}], "stats": {"total": 1895, "additions": 1689, "deletions": 206}, "files": [{"sha": "9a0623ca539387c930d870092fa32fe40d268e99", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1967,7 +1967,10 @@ impl<'tcx> Place<'tcx> {\n         Place::Projection(Box::new(PlaceProjection { base: self, elem }))\n     }\n \n-    /// Find the innermost `Local` from this `Place`.\n+    /// Find the innermost `Local` from this `Place`, *if* it is either a local itself or\n+    /// a single deref of a local.\n+    ///\n+    /// FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local(&self) -> Option<Local> {\n         match self {\n             Place::Local(local) |\n@@ -1978,6 +1981,15 @@ impl<'tcx> Place<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    /// Find the innermost `Local` from this `Place`.\n+    pub fn base_local(&self) -> Option<Local> {\n+        match self {\n+            Place::Local(local) => Some(*local),\n+            Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n+            Place::Promoted(..) | Place::Static(..) => None,\n+        }\n+    }\n }\n \n impl<'tcx> Debug for Place<'tcx> {"}, {"sha": "546746aa72ebb9a929c9393439882d8c253c709a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -51,16 +51,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         &mut self,\n         context: Context,\n         desired_action: InitializationRequiringAction,\n-        (place, span): (&Place<'tcx>, Span),\n+        (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n-            \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} place={:?} \\\n-             span={:?} mpi={:?}\",\n-            context, desired_action, place, span, mpi\n+            \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} \\\n+             moved_place={:?} used_place={:?} span={:?} mpi={:?}\",\n+            context, desired_action, moved_place, used_place, span, mpi\n         );\n \n-        let use_spans = self.move_spans(place, context.loc)\n+        let use_spans = self.move_spans(moved_place, context.loc)\n             .or_else(|| self.borrow_spans(span, context.loc));\n         let span = use_spans.args_or_use();\n \n@@ -75,7 +75,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .collect();\n \n         if move_out_indices.is_empty() {\n-            let root_place = self.prefixes(&place, PrefixSet::All).last().unwrap();\n+            let root_place = self.prefixes(&used_place, PrefixSet::All).last().unwrap();\n \n             if self.uninitialized_error_reported\n                 .contains(&root_place.clone())\n@@ -89,14 +89,15 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             self.uninitialized_error_reported.insert(root_place.clone());\n \n-            let item_msg = match self.describe_place_with_options(place, IncludingDowncast(true)) {\n+            let item_msg = match self.describe_place_with_options(used_place,\n+                                                                  IncludingDowncast(true)) {\n                 Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             let mut err = self.infcx.tcx.cannot_act_on_uninitialized_variable(\n                 span,\n                 desired_action.as_noun(),\n-                &self.describe_place_with_options(place, IncludingDowncast(true))\n+                &self.describe_place_with_options(moved_place, IncludingDowncast(true))\n                     .unwrap_or(\"_\".to_owned()),\n                 Origin::Mir,\n             );\n@@ -111,7 +112,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         } else {\n             if let Some((reported_place, _)) = self.move_error_reported.get(&move_out_indices) {\n                 if self.prefixes(&reported_place, PrefixSet::All)\n-                    .any(|p| p == place)\n+                    .any(|p| p == used_place)\n                 {\n                     debug!(\n                         \"report_use_of_moved_or_uninitialized place: error suppressed \\\n@@ -128,7 +129,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 span,\n                 desired_action.as_noun(),\n                 msg,\n-                self.describe_place_with_options(&place, IncludingDowncast(true)),\n+                self.describe_place_with_options(&moved_place, IncludingDowncast(true)),\n                 Origin::Mir,\n             );\n \n@@ -181,7 +182,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 );\n             }\n \n-            if let Some(ty) = self.retrieve_type_for_place(place) {\n+            if let Some(ty) = self.retrieve_type_for_place(used_place) {\n                 let needs_note = match ty.sty {\n                     ty::Closure(id, _) => {\n                         let tables = self.infcx.tcx.typeck_tables_of(id);\n@@ -219,7 +220,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n \n             if let Some((_, mut old_err)) = self.move_error_reported\n-                .insert(move_out_indices, (place.clone(), err))\n+                .insert(move_out_indices, (used_place.clone(), err))\n             {\n                 // Cancel the old error so it doesn't ICE.\n                 old_err.cancel();"}, {"sha": "1f8d077fb69045119859b56ad1e5dc032b85f49f", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 148, "deletions": 40, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -36,9 +36,8 @@ use std::collections::BTreeMap;\n \n use syntax_pos::Span;\n \n-use dataflow::indexes::BorrowIndex;\n-use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveError, MovePathIndex};\n-use dataflow::move_paths::indexes::MoveOutIndex;\n+use dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n+use dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveError};\n use dataflow::Borrows;\n use dataflow::DataflowResultsConsumer;\n use dataflow::FlowAtLocation;\n@@ -853,6 +852,7 @@ enum InitializationRequiringAction {\n     MatchOn,\n     Use,\n     Assignment,\n+    PartialAssignment,\n }\n \n struct RootPlace<'d, 'tcx: 'd> {\n@@ -868,6 +868,7 @@ impl InitializationRequiringAction {\n             InitializationRequiringAction::MatchOn => \"use\", // no good noun\n             InitializationRequiringAction::Use => \"use\",\n             InitializationRequiringAction::Assignment => \"assign\",\n+            InitializationRequiringAction::PartialAssignment => \"assign to part\",\n         }\n     }\n \n@@ -878,6 +879,7 @@ impl InitializationRequiringAction {\n             InitializationRequiringAction::MatchOn => \"matched on\",\n             InitializationRequiringAction::Use => \"used\",\n             InitializationRequiringAction::Assignment => \"assigned\",\n+            InitializationRequiringAction::PartialAssignment => \"partially assigned\",\n         }\n     }\n }\n@@ -1439,10 +1441,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         debug!(\"check_if_reassignment_to_immutable_state({:?})\", local);\n \n         // Check if any of the initializiations of `local` have happened yet:\n-        let mpi = self.move_data.rev_lookup.find_local(local);\n-        let init_indices = &self.move_data.init_path_map[mpi];\n-        let first_init_index = init_indices.iter().find(|&ii| flow_state.ever_inits.contains(*ii));\n-        if let Some(&init_index) = first_init_index {\n+        if let Some(init_index) = self.is_local_ever_initialized(local, flow_state) {\n             // And, if so, report an error.\n             let init = &self.move_data.inits[init_index];\n             let span = init.span(&self.mir);\n@@ -1498,12 +1497,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         debug!(\"check_if_full_path_is_moved place: {:?}\", place_span.0);\n         match self.move_path_closest_to(place_span.0) {\n-            Ok(mpi) => {\n+            Ok((prefix, mpi)) => {\n                 if maybe_uninits.contains(mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n                         context,\n                         desired_action,\n-                        place_span,\n+                        (prefix, place_span.0, place_span.1),\n                         mpi,\n                     );\n                     return; // don't bother finding other problems.\n@@ -1561,7 +1560,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 self.report_use_of_moved_or_uninitialized(\n                     context,\n                     desired_action,\n-                    place_span,\n+                    (place_span.0, place_span.0, place_span.1),\n                     child_mpi,\n                 );\n                 return; // don't bother finding other problems.\n@@ -1579,14 +1578,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// An Err result includes a tag indicated why the search failed.\n     /// Currently this can only occur if the place is built off of a\n     /// static variable, as we do not track those in the MoveData.\n-    fn move_path_closest_to(\n+    fn move_path_closest_to<'a>(\n         &mut self,\n-        place: &Place<'tcx>,\n-    ) -> Result<MovePathIndex, NoMovePathFound> {\n+        place: &'a Place<'tcx>,\n+    ) -> Result<(&'a Place<'tcx>, MovePathIndex), NoMovePathFound> where 'cx: 'a {\n         let mut last_prefix = place;\n         for prefix in self.prefixes(place, PrefixSet::All) {\n             if let Some(mpi) = self.move_path_for_place(prefix) {\n-                return Ok(mpi);\n+                return Ok((prefix, mpi));\n             }\n             last_prefix = prefix;\n         }\n@@ -1667,6 +1666,26 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // recur further)\n                                     break;\n                                 }\n+\n+\n+                                // Once `let s; s.x = V; read(s.x);`,\n+                                // is allowed, remove this match arm.\n+                                ty::Adt(..) | ty::Tuple(..) => {\n+                                    check_parent_of_field(self, context, base, span, flow_state);\n+\n+                                    if let Some(local) = place.base_local() {\n+                                        // rust-lang/rust#21232,\n+                                        // #54499, #54986: during\n+                                        // period where we reject\n+                                        // partial initialization, do\n+                                        // not complain about\n+                                        // unnecessary `mut` on an\n+                                        // attempt to do a partial\n+                                        // initialization.\n+                                        self.used_mut.insert(local);\n+                                    }\n+                                }\n+\n                                 _ => {}\n                             }\n                         }\n@@ -1677,8 +1696,73 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n         }\n-    }\n \n+        fn check_parent_of_field<'cx, 'gcx, 'tcx>(this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n+                                                  context: Context,\n+                                                  base: &Place<'tcx>,\n+                                                  span: Span,\n+                                                  flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+        {\n+            // rust-lang/rust#21232: Until Rust allows reads from the\n+            // initialized parts of partially initialized structs, we\n+            // will, starting with the 2018 edition, reject attempts\n+            // to write to structs that are not fully initialized.\n+            //\n+            // In other words, *until* we allow this:\n+            //\n+            // 1. `let mut s; s.x = Val; read(s.x);`\n+            //\n+            // we will for now disallow this:\n+            //\n+            // 2. `let mut s; s.x = Val;`\n+            //\n+            // and also this:\n+            //\n+            // 3. `let mut s = ...; drop(s); s.x=Val;`\n+            //\n+            // This does not use check_if_path_or_subpath_is_moved,\n+            // because we want to *allow* reinitializations of fields:\n+            // e.g. want to allow\n+            //\n+            // `let mut s = ...; drop(s.x); s.x=Val;`\n+            //\n+            // This does not use check_if_full_path_is_moved on\n+            // `base`, because that would report an error about the\n+            // `base` as a whole, but in this scenario we *really*\n+            // want to report an error about the actual thing that was\n+            // moved, which may be some prefix of `base`.\n+\n+            // Shallow so that we'll stop at any dereference; we'll\n+            // report errors about issues with such bases elsewhere.\n+            let maybe_uninits = &flow_state.uninits;\n+\n+            // Find the shortest uninitialized prefix you can reach\n+            // without going over a Deref.\n+            let mut shortest_uninit_seen = None;\n+            for prefix in this.prefixes(base, PrefixSet::Shallow) {\n+                let mpi = match this.move_path_for_place(prefix) {\n+                    Some(mpi) => mpi, None => continue,\n+                };\n+\n+                if maybe_uninits.contains(mpi) {\n+                    debug!(\"check_parent_of_field updating shortest_uninit_seen from {:?} to {:?}\",\n+                           shortest_uninit_seen, Some((prefix, mpi)));\n+                    shortest_uninit_seen = Some((prefix, mpi));\n+                } else {\n+                    debug!(\"check_parent_of_field {:?} is definitely initialized\", (prefix, mpi));\n+                }\n+            }\n+\n+            if let Some((prefix, mpi)) = shortest_uninit_seen {\n+                this.report_use_of_moved_or_uninitialized(\n+                    context,\n+                    InitializationRequiringAction::PartialAssignment,\n+                    (prefix, base, span),\n+                    mpi,\n+                );\n+            }\n+        }\n+    }\n \n     /// Check the permissions for the given place and read or write kind\n     ///\n@@ -1692,13 +1776,23 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         location: Location,\n     ) -> bool {\n         debug!(\n-            \"check_access_permissions({:?}, {:?}, {:?})\",\n+            \"check_access_permissions({:?}, {:?}, is_local_mutation_allowed: {:?})\",\n             place, kind, is_local_mutation_allowed\n         );\n \n         let error_access;\n         let the_place_err;\n \n+        // rust-lang/rust#21232, #54986: during period where we reject\n+        // partial initialization, do not complain about mutability\n+        // errors except for actual mutation (as opposed to an attempt\n+        // to do a partial initialization).\n+        let previously_initialized = if let Some(local) = place.base_local() {\n+            self.is_local_ever_initialized(local, flow_state).is_some()\n+        } else {\n+            true\n+        };\n+\n         match kind {\n             Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n             | Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. }))\n@@ -1791,14 +1885,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // at this point, we have set up the error reporting state.\n-        self.report_mutability_error(\n-            place,\n-            span,\n-            the_place_err,\n-            error_access,\n-            location,\n-        );\n-        return true;\n+        if previously_initialized {\n+            self.report_mutability_error(\n+                place,\n+                span,\n+                the_place_err,\n+                error_access,\n+                location,\n+            );\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    fn is_local_ever_initialized(&self,\n+                                 local: Local,\n+                                 flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+                                 -> Option<InitIndex>\n+    {\n+        let mpi = self.move_data.rev_lookup.find_local(local);\n+        let ii = &self.move_data.init_path_map[mpi];\n+        for &index in ii {\n+            if flow_state.ever_inits.contains(index) {\n+                return Some(index);\n+            }\n+        }\n+        return None;\n     }\n \n     /// Adds the place into the used mutable variables set\n@@ -1812,18 +1925,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 place: Place::Local(local),\n                 is_local_mutation_allowed,\n             } => {\n-                if is_local_mutation_allowed != LocalMutationIsAllowed::Yes {\n-                    // If the local may be initialized, and it is now currently being\n-                    // mutated, then it is justified to be annotated with the `mut`\n-                    // keyword, since the mutation may be a possible reassignment.\n-                    let mpi = self.move_data.rev_lookup.find_local(*local);\n-                    let ii = &self.move_data.init_path_map[mpi];\n-                    for &index in ii {\n-                        if flow_state.ever_inits.contains(index) {\n-                            self.used_mut.insert(*local);\n-                            break;\n-                        }\n-                    }\n+                // If the local may have been initialized, and it is now currently being\n+                // mutated, then it is justified to be annotated with the `mut`\n+                // keyword, since the mutation may be a possible reassignment.\n+                if is_local_mutation_allowed != LocalMutationIsAllowed::Yes &&\n+                    self.is_local_ever_initialized(*local, flow_state).is_some()\n+                {\n+                    self.used_mut.insert(*local);\n                 }\n             }\n             RootPlace {\n@@ -1849,7 +1957,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Whether this value be written or borrowed mutably.\n+    /// Whether this value can be written or borrowed mutably.\n     /// Returns the root place if the place passed in is a projection.\n     fn is_mutable<'d>(\n         &self,\n@@ -1927,14 +2035,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => return Err(place),\n+                                    hir::MutImmutable => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n                                     hir::MutMutable => {\n-                                        return Ok(RootPlace {\n+                                        Ok(RootPlace {\n                                             place,\n                                             is_local_mutation_allowed,\n-                                        });\n+                                        })\n                                     }\n                                 }\n                             }"}, {"sha": "83445c6657e934c32a94b532148059187396165a", "filename": "src/test/run-pass/issues/issue-26996.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26996.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26996.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-26996.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -9,6 +9,20 @@\n // except according to those terms.\n \n // run-pass\n+\n+// This test is bogus (i.e. should be compile-fail) during the period\n+// where #54986 is implemented and #54987 is *not* implemented. For\n+// now: just ignore it under nll\n+//\n+// ignore-compare-mode-nll\n+\n+// This test is checking that the write to `c.0` (which has been moved out of)\n+// won't overwrite the state in `c2`.\n+//\n+// That's a fine thing to test when this code is accepted by the\n+// compiler, and this code is being transcribed accordingly into\n+// the ui test issue-21232-partial-init-and-use.rs\n+\n fn main() {\n     let mut c = (1, \"\".to_owned());\n     match c {"}, {"sha": "dbad8556aeb2305b0f031ab05452189a7682c9f4", "filename": "src/test/run-pass/issues/issue-27021.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27021.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -9,6 +9,22 @@\n // except according to those terms.\n \n // run-pass\n+\n+// This test is bogus (i.e. should be compile-fail) during the period\n+// where #54986 is implemented and #54987 is *not* implemented. For\n+// now: just ignore it under nll\n+//\n+// ignore-compare-mode-nll\n+\n+// These are variants of issue-26996.rs. In all cases we are writing\n+// into a record field that has been moved out of, and ensuring that\n+// such a write won't overwrite the state of the thing it was moved\n+// into.\n+//\n+// That's a fine thing to test when this code is accepted by the\n+// compiler, and this code is being transcribed accordingly into\n+// the ui test issue-21232-partial-init-and-use.rs\n+\n fn main() {\n     let mut c = (1, (1, \"\".to_owned()));\n     match c {"}, {"sha": "db3c9792f3560fc532fabb9ac96db07908ea62ce", "filename": "src/test/run-pass/issues/issue-49298.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Frun-pass%2Fissues%2Fissue-49298.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Frun-pass%2Fissues%2Fissue-49298.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-49298.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -12,6 +12,22 @@\n #![feature(test)]\n #![allow(unused_mut)] // under NLL we get warning about `x` below: rust-lang/rust#54499\n \n+// This test is bogus (i.e. should be compile-fail) during the period\n+// where #54986 is implemented and #54987 is *not* implemented. For\n+// now: just ignore it under nll\n+//\n+// ignore-compare-mode-nll\n+\n+// This test is checking that the space allocated for `x.1` does not\n+// overlap with `y`. (The reason why such a thing happened at one\n+// point was because `x.0: Void` and thus the whole type of `x` was\n+// uninhabited, and so the compiler thought it was safe to use the\n+// space of `x.1` to hold `y`.)\n+//\n+// That's a fine thing to test when this code is accepted by the\n+// compiler, and this code is being transcribed accordingly into\n+// the ui test issue-21232-partial-init-and-use.rs\n+\n extern crate test;\n \n enum Void {}"}, {"sha": "59af97d9f13db6101307ab788f5a59ffd574b780", "filename": "src/test/ui/borrowck/assign_mutable_fields.nll.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fassign_mutable_fields.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fassign_mutable_fields.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fassign_mutable_fields.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,9 +1,15 @@\n-error[E0381]: use of possibly uninitialized variable: `x`\n-  --> $DIR/assign_mutable_fields.rs:29:10\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n+  --> $DIR/assign_mutable_fields.rs:19:5\n    |\n-LL |     drop(x); //~ ERROR\n-   |          ^ use of possibly uninitialized `x`\n+LL |     x.0 = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n \n-error: aborting due to previous error\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n+  --> $DIR/assign_mutable_fields.rs:27:5\n+   |\n+LL |     x.0 = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0381`."}, {"sha": "81d9e958e28e20710504f549718853ee920515dd", "filename": "src/test/ui/borrowck/borrowck-field-sensitivity.nll.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-field-sensitivity.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-field-sensitivity.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-field-sensitivity.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,12 +1,12 @@\n-error[E0382]: use of moved value: `*x.b`\n+error[E0382]: use of moved value: `x.b`\n   --> $DIR/borrowck-field-sensitivity.rs:18:10\n    |\n LL |     drop(x.b);\n    |          --- value moved here\n LL |     drop(*x.b); //~ ERROR use of moved value: `*x.b`\n    |          ^^^^ value used here after move\n \n-error[E0382]: use of moved value: `*x.b`\n+error[E0382]: use of moved value: `x.b`\n   --> $DIR/borrowck-field-sensitivity.rs:24:10\n    |\n LL |     let y = A { a: 3, .. x };\n@@ -104,7 +104,25 @@ LL |     let _z = A { a: 4, .. x };  //~ ERROR use of moved value: `x.b`\n    |\n    = note: move occurs because `x.b` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n \n-error: aborting due to 11 previous errors\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n+  --> $DIR/borrowck-field-sensitivity.rs:91:5\n+   |\n+LL |     x.a = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n+  --> $DIR/borrowck-field-sensitivity.rs:97:5\n+   |\n+LL |     x.a = 1;\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n+  --> $DIR/borrowck-field-sensitivity.rs:104:5\n+   |\n+LL |     x.b = box 1;\n+   |     ^^^ use of possibly uninitialized `x`\n+\n+error: aborting due to 14 previous errors\n \n-Some errors occurred: E0382, E0499, E0505.\n-For more information about an error, try `rustc --explain E0382`.\n+Some errors occurred: E0381, E0382, E0499, E0505.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "e602597844457ccd1c8a199e6f2e168441a77cf3", "filename": "src/test/ui/borrowck/borrowck-init-in-fru.ast.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.ast.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0381]: use of possibly uninitialized variable: `origin.y`\n+error[E0381]: use of possibly uninitialized variable: `origin`\n   --> $DIR/borrowck-init-in-fru.rs:22:5\n    |\n LL |     origin = point {x: 10,.. origin};"}, {"sha": "e602597844457ccd1c8a199e6f2e168441a77cf3", "filename": "src/test/ui/borrowck/borrowck-init-in-fru.mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.mir.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0381]: use of possibly uninitialized variable: `origin.y`\n+error[E0381]: use of possibly uninitialized variable: `origin`\n   --> $DIR/borrowck-init-in-fru.rs:22:5\n    |\n LL |     origin = point {x: 10,.. origin};"}, {"sha": "97eb83d0f14efedb1c37a26edfa8a6f608ab338a", "filename": "src/test/ui/borrowck/borrowck-uninit-field-access.ast.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.ast.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,10 +1,10 @@\n-error[E0381]: use of possibly uninitialized variable: `a.x`\n+error[E0381]: use of possibly uninitialized variable: `a`\n   --> $DIR/borrowck-uninit-field-access.rs:34:13\n    |\n LL |     let _ = a.x + 1; //[ast]~ ERROR use of possibly uninitialized variable: `a.x`\n    |             ^^^ use of possibly uninitialized `a.x`\n \n-error[E0382]: use of moved value: `line1.origin.x`\n+error[E0382]: use of moved value: `line1.origin`\n   --> $DIR/borrowck-uninit-field-access.rs:39:13\n    |\n LL |     let _moved = line1.origin;"}, {"sha": "97eb83d0f14efedb1c37a26edfa8a6f608ab338a", "filename": "src/test/ui/borrowck/borrowck-uninit-field-access.mir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-field-access.mir.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,10 +1,10 @@\n-error[E0381]: use of possibly uninitialized variable: `a.x`\n+error[E0381]: use of possibly uninitialized variable: `a`\n   --> $DIR/borrowck-uninit-field-access.rs:34:13\n    |\n LL |     let _ = a.x + 1; //[ast]~ ERROR use of possibly uninitialized variable: `a.x`\n    |             ^^^ use of possibly uninitialized `a.x`\n \n-error[E0382]: use of moved value: `line1.origin.x`\n+error[E0382]: use of moved value: `line1.origin`\n   --> $DIR/borrowck-uninit-field-access.rs:39:13\n    |\n LL |     let _moved = line1.origin;"}, {"sha": "e9caf7d9e1e7e5f5c3203182215eb00df3619ffc", "filename": "src/test/ui/borrowck/borrowck-uninit-ref-chain.ast.nll.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.ast.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,33 +1,45 @@\n-error[E0381]: borrow of possibly uninitialized variable: `**x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-uninit-ref-chain.rs:21:14\n    |\n LL |     let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n    |              ^^^^ use of possibly uninitialized `**x`\n \n-error[E0381]: borrow of possibly uninitialized variable: `**x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-uninit-ref-chain.rs:25:14\n    |\n LL |     let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n    |              ^^^^ use of possibly uninitialized `**x`\n \n-error[E0381]: borrow of possibly uninitialized variable: `**x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-uninit-ref-chain.rs:29:14\n    |\n LL |     let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n    |              ^^^^ use of possibly uninitialized `**x`\n \n-error[E0381]: borrow of possibly uninitialized variable: `a.y`\n-  --> $DIR/borrowck-uninit-ref-chain.rs:46:14\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:34:5\n    |\n-LL |     let _b = &a.y; //[ast]~ ERROR use of possibly uninitialized variable: `a.y` [E0381]\n-   |              ^^^^ use of possibly uninitialized `a.y`\n+LL |     a.x = 0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^ use of possibly uninitialized `a`\n \n-error[E0381]: borrow of possibly uninitialized variable: `**a.y`\n-  --> $DIR/borrowck-uninit-ref-chain.rs:51:14\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:39:5\n    |\n-LL |     let _b = &**a.y; //[ast]~ ERROR use of possibly uninitialized variable: `**a.y` [E0381]\n-   |              ^^^^^^ use of possibly uninitialized `**a.y`\n+LL |     a.x = &&0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^^^ use of possibly uninitialized `a`\n \n-error: aborting due to 5 previous errors\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:45:5\n+   |\n+LL |     a.x = 0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^ use of possibly uninitialized `a`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:50:5\n+   |\n+LL |     a.x = &&0;       //[mir]~ assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^^^ use of possibly uninitialized `a`\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0381`."}, {"sha": "e9caf7d9e1e7e5f5c3203182215eb00df3619ffc", "filename": "src/test/ui/borrowck/borrowck-uninit-ref-chain.mir.stderr", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.mir.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,33 +1,45 @@\n-error[E0381]: borrow of possibly uninitialized variable: `**x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-uninit-ref-chain.rs:21:14\n    |\n LL |     let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n    |              ^^^^ use of possibly uninitialized `**x`\n \n-error[E0381]: borrow of possibly uninitialized variable: `**x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-uninit-ref-chain.rs:25:14\n    |\n LL |     let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n    |              ^^^^ use of possibly uninitialized `**x`\n \n-error[E0381]: borrow of possibly uninitialized variable: `**x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-uninit-ref-chain.rs:29:14\n    |\n LL |     let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n    |              ^^^^ use of possibly uninitialized `**x`\n \n-error[E0381]: borrow of possibly uninitialized variable: `a.y`\n-  --> $DIR/borrowck-uninit-ref-chain.rs:46:14\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:34:5\n    |\n-LL |     let _b = &a.y; //[ast]~ ERROR use of possibly uninitialized variable: `a.y` [E0381]\n-   |              ^^^^ use of possibly uninitialized `a.y`\n+LL |     a.x = 0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^ use of possibly uninitialized `a`\n \n-error[E0381]: borrow of possibly uninitialized variable: `**a.y`\n-  --> $DIR/borrowck-uninit-ref-chain.rs:51:14\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:39:5\n    |\n-LL |     let _b = &**a.y; //[ast]~ ERROR use of possibly uninitialized variable: `**a.y` [E0381]\n-   |              ^^^^^^ use of possibly uninitialized `**a.y`\n+LL |     a.x = &&0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^^^ use of possibly uninitialized `a`\n \n-error: aborting due to 5 previous errors\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:45:5\n+   |\n+LL |     a.x = 0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^ use of possibly uninitialized `a`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `a`\n+  --> $DIR/borrowck-uninit-ref-chain.rs:50:5\n+   |\n+LL |     a.x = &&0;       //[mir]~ assign to part of possibly uninitialized variable: `a` [E0381]\n+   |     ^^^^^^^^^ use of possibly uninitialized `a`\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0381`."}, {"sha": "dc9d8405102eea4fba7cdff22b460d301381917d", "filename": "src/test/ui/borrowck/borrowck-uninit-ref-chain.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-uninit-ref-chain.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -31,23 +31,23 @@ fn main() {\n \n \n     let mut a: S<i32, i32>;\n-    a.x = 0;\n+    a.x = 0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n     let _b = &a.x; //[ast]~ ERROR use of possibly uninitialized variable: `a.x` [E0381]\n-                   // (deliberately *not* an error under MIR-borrowck)\n+\n \n     let mut a: S<&&i32, &&i32>;\n-    a.x = &&0;\n+    a.x = &&0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n     let _b = &**a.x; //[ast]~ ERROR use of possibly uninitialized variable: `**a.x` [E0381]\n-                     // (deliberately *not* an error under MIR-borrowck)\n+\n \n \n     let mut a: S<i32, i32>;\n-    a.x = 0;\n+    a.x = 0;       //[mir]~ ERROR assign to part of possibly uninitialized variable: `a` [E0381]\n     let _b = &a.y; //[ast]~ ERROR use of possibly uninitialized variable: `a.y` [E0381]\n-                   //[mir]~^ ERROR [E0381]\n+\n \n     let mut a: S<&&i32, &&i32>;\n-    a.x = &&0;\n+    a.x = &&0;       //[mir]~ assign to part of possibly uninitialized variable: `a` [E0381]\n     let _b = &**a.y; //[ast]~ ERROR use of possibly uninitialized variable: `**a.y` [E0381]\n-                     //[mir]~^ ERROR [E0381]\n+\n }"}, {"sha": "423a44514db81525a229aac04a32ca4f7e08bf8d", "filename": "src/test/ui/borrowck/borrowck-union-move-assign.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move-assign.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `u.a`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move-assign.rs:27:21\n    |\n LL |             let a = u.a;\n@@ -8,7 +8,7 @@ LL |             let a = u.a; //~ ERROR use of moved value: `u.a`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.a`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move-assign.rs:33:21\n    |\n LL |             let a = u.a;\n@@ -19,7 +19,7 @@ LL |             let a = u.a; // OK\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.a`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move-assign.rs:39:21\n    |\n LL |             let a = u.a;"}, {"sha": "8597117dbcc8a0099d72a9268ec49b5599d375a3", "filename": "src/test/ui/borrowck/borrowck-union-move.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-move.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `u.n1`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:36:21\n    |\n LL |             let a = u.n1;\n@@ -18,7 +18,7 @@ LL |             let a = u; //~ ERROR use of partially moved value: `u`\n    |\n    = note: move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.n2`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:46:21\n    |\n LL |             let a = u.n1;\n@@ -28,7 +28,7 @@ LL |             let a = u.n2; //~ ERROR use of moved value: `u.n2`\n    |\n    = note: move occurs because `u` has type `Unn`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.n`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:73:21\n    |\n LL |             let a = u.n;\n@@ -38,7 +38,7 @@ LL |             let a = u.n; //~ ERROR use of moved value: `u.n`\n    |\n    = note: move occurs because `u` has type `Ucn`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.c`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/borrowck-union-move.rs:78:21\n    |\n LL |             let a = u.n;"}, {"sha": "94a7a4866e6b90f3aa304e1c6130266939a3a1e0", "filename": "src/test/ui/borrowck/borrowck-union-uninitialized.nll.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-uninitialized.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-uninitialized.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-union-uninitialized.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,9 +1,15 @@\n-error[E0381]: use of possibly uninitialized variable: `u.a`\n-  --> $DIR/borrowck-union-uninitialized.rs:26:18\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/borrowck-union-uninitialized.rs:23:9\n    |\n-LL |         let ua = u.a; //~ ERROR use of possibly uninitialized variable: `u.a`\n-   |                  ^^^ use of possibly uninitialized `u.a`\n+LL |         s.a = 0;\n+   |         ^^^^^^^ use of possibly uninitialized `s`\n \n-error: aborting due to previous error\n+error[E0381]: assign to part of possibly uninitialized variable: `u`\n+  --> $DIR/borrowck-union-uninitialized.rs:24:9\n+   |\n+LL |         u.a = 0;\n+   |         ^^^^^^^ use of possibly uninitialized `u`\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0381`."}, {"sha": "502978f25be9435643614686eb486524055a9736", "filename": "src/test/ui/borrowck/borrowck-use-in-index-lvalue.ast.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-in-index-lvalue.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-in-index-lvalue.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-in-index-lvalue.ast.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,10 +1,10 @@\n-error[E0381]: use of possibly uninitialized variable: `*w`\n+error[E0381]: use of possibly uninitialized variable: `w`\n   --> $DIR/borrowck-use-in-index-lvalue.rs:16:5\n    |\n LL |     w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]\n    |     ^^^^ use of possibly uninitialized `*w`\n \n-error[E0381]: use of possibly uninitialized variable: `*w`\n+error[E0381]: use of possibly uninitialized variable: `w`\n   --> $DIR/borrowck-use-in-index-lvalue.rs:20:5\n    |\n LL |     w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]"}, {"sha": "502978f25be9435643614686eb486524055a9736", "filename": "src/test/ui/borrowck/borrowck-use-in-index-lvalue.mir.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-in-index-lvalue.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-in-index-lvalue.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-in-index-lvalue.mir.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,10 +1,10 @@\n-error[E0381]: use of possibly uninitialized variable: `*w`\n+error[E0381]: use of possibly uninitialized variable: `w`\n   --> $DIR/borrowck-use-in-index-lvalue.rs:16:5\n    |\n LL |     w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]\n    |     ^^^^ use of possibly uninitialized `*w`\n \n-error[E0381]: use of possibly uninitialized variable: `*w`\n+error[E0381]: use of possibly uninitialized variable: `w`\n   --> $DIR/borrowck-use-in-index-lvalue.rs:20:5\n    |\n LL |     w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]"}, {"sha": "22e95ca3ad0e2ee922383395c2fa6b058361126f", "filename": "src/test/ui/borrowck/borrowck-use-uninitialized-in-cast-trait.ast.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.ast.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0381]: borrow of possibly uninitialized variable: `*x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-use-uninitialized-in-cast-trait.rs:22:13\n    |\n LL |     let y = x as *const Foo; //[ast]~ ERROR use of possibly uninitialized variable: `*x`"}, {"sha": "22e95ca3ad0e2ee922383395c2fa6b058361126f", "filename": "src/test/ui/borrowck/borrowck-use-uninitialized-in-cast-trait.mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.mir.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0381]: borrow of possibly uninitialized variable: `*x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-use-uninitialized-in-cast-trait.rs:22:13\n    |\n LL |     let y = x as *const Foo; //[ast]~ ERROR use of possibly uninitialized variable: `*x`"}, {"sha": "11897f50910e17df1c4d6965aa57dca33c1b8519", "filename": "src/test/ui/borrowck/borrowck-use-uninitialized-in-cast.ast.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.ast.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0381]: borrow of possibly uninitialized variable: `*x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-use-uninitialized-in-cast.rs:20:13\n    |\n LL |     let y = x as *const i32; //[ast]~ ERROR use of possibly uninitialized variable: `*x` [E0381]"}, {"sha": "11897f50910e17df1c4d6965aa57dca33c1b8519", "filename": "src/test/ui/borrowck/borrowck-use-uninitialized-in-cast.mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.mir.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0381]: borrow of possibly uninitialized variable: `*x`\n+error[E0381]: borrow of possibly uninitialized variable: `x`\n   --> $DIR/borrowck-use-uninitialized-in-cast.rs:20:13\n    |\n LL |     let y = x as *const i32; //[ast]~ ERROR use of possibly uninitialized variable: `*x` [E0381]"}, {"sha": "d72cc20971b0e3c4a32b381bfa548a2f7e566e1f", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-marks-mut-as-used.ast.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.ast.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,39 @@\n+error[E0381]: use of possibly uninitialized variable: `t.0`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:25:31\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ use of possibly uninitialized `t.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `t.1`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:25:36\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ use of possibly uninitialized `t.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.0`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:35:31\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ use of possibly uninitialized `u.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.1`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:35:36\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ use of possibly uninitialized `u.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.x`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:45:31\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ use of possibly uninitialized `v.x`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.y`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:45:36\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ use of possibly uninitialized `v.y`\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "ebc6c7fca62b9a387547b72c04de429d6a5be98f", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-marks-mut-as-used.nll.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:22:9\n+   |\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `u`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:32:9\n+   |\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `u`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `v`\n+  --> $DIR/issue-54499-field-mutation-marks-mut-as-used.rs:42:9\n+   |\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `v`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "4358e8e440237a9a63daa0facce066362aff42f3", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-marks-mut-as-used.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-marks-mut-as-used.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,49 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let mut t: Tuple;\n+        t.0 = S(1);\n+        //[nll]~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        t.1 = 2;\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `t.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `t.1` [E0381]\n+    }\n+\n+    {\n+        let mut u: Tpair;\n+        u.0 = S(1);\n+        //[nll]~^ ERROR assign to part of possibly uninitialized variable: `u` [E0381]\n+        u.1 = 2;\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `u.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `u.1` [E0381]\n+    }\n+\n+    {\n+        let mut v: Spair;\n+        v.x = S(1);\n+        //[nll]~^ ERROR assign to part of possibly uninitialized variable: `v` [E0381]\n+        v.y = 2;\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `v.x` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `v.y` [E0381]\n+    }\n+}"}, {"sha": "e3b5341d2bcff0aa293f3ea8bdc29277ed9c6871", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.ast.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.ast.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,69 @@\n+error[E0382]: use of moved value: `t.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:25:31\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `t.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:25:36\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:33:31\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:33:36\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.x`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:41:31\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.y`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:41:36\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "001ed59059cc89893ca10a4749d32df961408baa", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,33 @@\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:23:9\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `u`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:31:9\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `v`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out-with-mut.rs:39:9\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "b6339c4a3c754a6b18d7bdbc1eec7d2fa4ca8c84", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out-with-mut.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out-with-mut.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,43 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let mut t: Tuple = (S(0), 0);\n+        drop(t);\n+        t.0 = S(1);\n+        t.1 = 2;\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+    }\n+\n+    {\n+        let mut u: Tpair = Tpair(S(0), 0);\n+        drop(u);\n+        u.0 = S(1);\n+        u.1 = 2;\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+    }\n+\n+    {\n+        let mut v: Spair = Spair { x: S(0), y: 0 };\n+        drop(v);\n+        v.x = S(1);\n+        v.y = 2;\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+    }\n+}"}, {"sha": "565272af39049fdc9a8895f9ecd0d1753db0da3c", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.ast.stderr", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.ast.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,124 @@\n+error[E0594]: cannot assign to field `t.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: make this binding mutable: `mut t`\n+LL |         drop(t);\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `t.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:27:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: make this binding mutable: `mut t`\n+...\n+LL |         t.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: make this binding mutable: `mut u`\n+LL |         drop(u);\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:42:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: make this binding mutable: `mut u`\n+...\n+LL |         u.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.x` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: make this binding mutable: `mut v`\n+LL |         drop(v);\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.y` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:57:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: make this binding mutable: `mut v`\n+...\n+LL |         v.y = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0382]: use of moved value: `t.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:30:31\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `t.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:30:36\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.0`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:45:31\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `u.1`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:45:36\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.x`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:60:31\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error[E0382]: use of moved value: `v.y`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:60:36\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+...\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ value used here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors occurred: E0382, E0594.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "d35d0058027d42ed81a0bd01ebc6a86d41032e12", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.nll.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,88 @@\n+error[E0594]: cannot assign to `t.0`, as `t` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut t`\n+LL |         drop(t);\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ cannot assign\n+\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:23:9\n+   |\n+LL |         drop(t);\n+   |              - value moved here\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(S, i32)`, which does not implement the `Copy` trait\n+\n+error[E0594]: cannot assign to `t.1`, as `t` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:27:9\n+   |\n+LL |         let t: Tuple = (S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut t`\n+...\n+LL |         t.1 = 2;\n+   |         ^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `u.0`, as `u` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut u`\n+LL |         drop(u);\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ cannot assign\n+\n+error[E0382]: assign to part of moved value: `u`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:38:9\n+   |\n+LL |         drop(u);\n+   |              - value moved here\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `u` has type `Tpair`, which does not implement the `Copy` trait\n+\n+error[E0594]: cannot assign to `u.1`, as `u` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:42:9\n+   |\n+LL |         let u: Tpair = Tpair(S(0), 0);\n+   |             - help: consider changing this to be mutable: `mut u`\n+...\n+LL |         u.1 = 2;\n+   |         ^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `v.x`, as `v` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: consider changing this to be mutable: `mut v`\n+LL |         drop(v);\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ cannot assign\n+\n+error[E0382]: assign to part of moved value: `v`\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:53:9\n+   |\n+LL |         drop(v);\n+   |              - value moved here\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `v` has type `Spair`, which does not implement the `Copy` trait\n+\n+error[E0594]: cannot assign to `v.y`, as `v` is not declared as mutable\n+  --> $DIR/issue-54499-field-mutation-of-moved-out.rs:57:9\n+   |\n+LL |         let v: Spair = Spair { x: S(0), y: 0 };\n+   |             - help: consider changing this to be mutable: `mut v`\n+...\n+LL |         v.y = 2;\n+   |         ^^^^^^^ cannot assign\n+\n+error: aborting due to 9 previous errors\n+\n+Some errors occurred: E0382, E0594.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "b19dcd65a6c7e2afdc1dea76853aacfde6d33f5e", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-moved-out.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-moved-out.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,64 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let t: Tuple = (S(0), 0);\n+        drop(t);\n+        t.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `t.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of moved value: `t` [E0382]\n+        //[nll]~| ERROR cannot assign to `t.0`, as `t` is not declared as mutable [E0594]\n+        t.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `t.1` of immutable binding [E0594]\n+        //[nll]~^^ ERROR cannot assign to `t.1`, as `t` is not declared as mutable [E0594]\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+        //[ast]~^ ERROR use of moved value: `t.0` [E0382]\n+        //[ast]~| ERROR use of moved value: `t.1` [E0382]\n+    }\n+\n+    {\n+        let u: Tpair = Tpair(S(0), 0);\n+        drop(u);\n+        u.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `u.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of moved value: `u` [E0382]\n+        //[nll]~| ERROR cannot assign to `u.0`, as `u` is not declared as mutable [E0594]\n+        u.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `u.1` of immutable binding [E0594]\n+        //[nll]~^^ ERROR cannot assign to `u.1`, as `u` is not declared as mutable [E0594]\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+        //[ast]~^ ERROR use of moved value: `u.0` [E0382]\n+        //[ast]~| ERROR use of moved value: `u.1` [E0382]\n+    }\n+\n+    {\n+        let v: Spair = Spair { x: S(0), y: 0 };\n+        drop(v);\n+        v.x = S(1);\n+        //[ast]~^ ERROR cannot assign to field `v.x` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of moved value: `v` [E0382]\n+        //[nll]~| ERROR cannot assign to `v.x`, as `v` is not declared as mutable [E0594]\n+        v.y = 2;\n+        //[ast]~^ ERROR cannot assign to field `v.y` of immutable binding [E0594]\n+        //[nll]~^^ ERROR cannot assign to `v.y`, as `v` is not declared as mutable [E0594]\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+        //[ast]~^ ERROR use of moved value: `v.x` [E0382]\n+        //[ast]~| ERROR use of moved value: `v.y` [E0382]\n+    }\n+}"}, {"sha": "ea6b63b7a297dc88c26c455c9dc4f40899d8b8ca", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-never-init.ast.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.ast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.ast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.ast.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,91 @@\n+error[E0594]: cannot assign to field `t.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:22:9\n+   |\n+LL |         let t: Tuple;\n+   |             - help: make this binding mutable: `mut t`\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `t.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:25:9\n+   |\n+LL |         let t: Tuple;\n+   |             - help: make this binding mutable: `mut t`\n+...\n+LL |         t.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.0` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:34:9\n+   |\n+LL |         let u: Tpair;\n+   |             - help: make this binding mutable: `mut u`\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `u.1` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:37:9\n+   |\n+LL |         let u: Tpair;\n+   |             - help: make this binding mutable: `mut u`\n+...\n+LL |         u.1 = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.x` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:46:9\n+   |\n+LL |         let v: Spair;\n+   |             - help: make this binding mutable: `mut v`\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to field `v.y` of immutable binding\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:49:9\n+   |\n+LL |         let v: Spair;\n+   |             - help: make this binding mutable: `mut v`\n+...\n+LL |         v.y = 2;\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0381]: use of possibly uninitialized variable: `t.0`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:27:31\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                               ^^^ use of possibly uninitialized `t.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `t.1`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:27:36\n+   |\n+LL |         println!(\"{:?} {:?}\", t.0, t.1);\n+   |                                    ^^^ use of possibly uninitialized `t.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.0`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:39:31\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                               ^^^ use of possibly uninitialized `u.0`\n+\n+error[E0381]: use of possibly uninitialized variable: `u.1`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:39:36\n+   |\n+LL |         println!(\"{:?} {:?}\", u.0, u.1);\n+   |                                    ^^^ use of possibly uninitialized `u.1`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.x`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:51:31\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                               ^^^ use of possibly uninitialized `v.x`\n+\n+error[E0381]: use of possibly uninitialized variable: `v.y`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:51:36\n+   |\n+LL |         println!(\"{:?} {:?}\", v.x, v.y);\n+   |                                    ^^^ use of possibly uninitialized `v.y`\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors occurred: E0381, E0594.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "3dc2b5b3b8f9f0a6786c21f6f763be606a5528d5", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-never-init.nll.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,21 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:22:9\n+   |\n+LL |         t.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `u`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:34:9\n+   |\n+LL |         u.0 = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `u`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `v`\n+  --> $DIR/issue-54499-field-mutation-of-never-init.rs:46:9\n+   |\n+LL |         v.x = S(1);\n+   |         ^^^^^^^^^^ use of possibly uninitialized `v`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "03eb9621ee215fed3d0a93301c69e7d9124ed09f", "filename": "src/test/ui/borrowck/issue-54499-field-mutation-of-never-init.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-54499-field-mutation-of-never-init.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,55 @@\n+// revisions: ast nll\n+\n+// Since we are testing nll migration explicitly as a separate\n+// revision, don't worry about the --compare-mode=nll on this test.\n+\n+// ignore-compare-mode-nll\n+\n+//[ast]compile-flags: -Z borrowck=ast\n+//[nll]compile-flags: -Z borrowck=migrate -Z two-phase-borrows\n+\n+#![warn(unused)]\n+#[derive(Debug)]\n+struct S(i32);\n+\n+type Tuple = (S, i32);\n+struct Tpair(S, i32);\n+struct Spair { x: S, y: i32 }\n+\n+fn main() {\n+    {\n+        let t: Tuple;\n+        t.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `t.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+        t.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `t.1` of immutable binding [E0594]\n+        println!(\"{:?} {:?}\", t.0, t.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `t.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `t.1` [E0381]\n+    }\n+\n+    {\n+        let u: Tpair;\n+        u.0 = S(1);\n+        //[ast]~^ ERROR cannot assign to field `u.0` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of possibly uninitialized variable: `u` [E0381]\n+        u.1 = 2;\n+        //[ast]~^ ERROR cannot assign to field `u.1` of immutable binding [E0594]\n+        println!(\"{:?} {:?}\", u.0, u.1);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `u.0` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `u.1` [E0381]\n+    }\n+\n+    {\n+        let v: Spair;\n+        v.x = S(1);\n+        //[ast]~^ ERROR cannot assign to field `v.x` of immutable binding [E0594]\n+        //[nll]~^^ ERROR assign to part of possibly uninitialized variable: `v` [E0381]\n+        v.y = 2;\n+        //[ast]~^ ERROR cannot assign to field `v.y` of immutable binding [E0594]\n+        println!(\"{:?} {:?}\", v.x, v.y);\n+        //[ast]~^ ERROR use of possibly uninitialized variable: `v.x` [E0381]\n+        //[ast]~| ERROR use of possibly uninitialized variable: `v.y` [E0381]\n+    }\n+}"}, {"sha": "1f0938dd3d27ba168b1fb2421aa0fcd8fe965c22", "filename": "src/test/ui/borrowck/reassignment_immutable_fields.nll.stderr", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,44 +1,15 @@\n-error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n   --> $DIR/reassignment_immutable_fields.rs:17:5\n    |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n LL |     x.0 = 1; //~ ERROR\n-   |     ^^^^^^^ cannot assign\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n \n-error[E0594]: cannot assign to `x.1`, as `x` is not declared as mutable\n-  --> $DIR/reassignment_immutable_fields.rs:18:5\n-   |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n-LL |     x.0 = 1; //~ ERROR\n-LL |     x.1 = 22; //~ ERROR\n-   |     ^^^^^^^^ cannot assign\n-\n-error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n   --> $DIR/reassignment_immutable_fields.rs:25:5\n    |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n-LL |     x.0 = 1; //~ ERROR\n-   |     ^^^^^^^ cannot assign\n-\n-error[E0594]: cannot assign to `x.1`, as `x` is not declared as mutable\n-  --> $DIR/reassignment_immutable_fields.rs:26:5\n-   |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n LL |     x.0 = 1; //~ ERROR\n-LL |     x.1 = 22; //~ ERROR\n-   |     ^^^^^^^^ cannot assign\n-\n-error[E0381]: use of possibly uninitialized variable: `x`\n-  --> $DIR/reassignment_immutable_fields.rs:27:10\n-   |\n-LL |     drop(x); //~ ERROR\n-   |          ^ use of possibly uninitialized `x`\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0381, E0594.\n-For more information about an error, try `rustc --explain E0381`.\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "7da9dbfc088cb5a0f15ef80b27272f918117cc78", "filename": "src/test/ui/borrowck/reassignment_immutable_fields_overlapping.nll.stderr", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_overlapping.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_overlapping.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_overlapping.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,20 +1,9 @@\n-error[E0594]: cannot assign to `x.a`, as `x` is not declared as mutable\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n   --> $DIR/reassignment_immutable_fields_overlapping.rs:22:5\n    |\n-LL |     let x: Foo;\n-   |         - help: consider changing this to be mutable: `mut x`\n LL |     x.a = 1;  //~ ERROR\n-   |     ^^^^^^^ cannot assign\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n \n-error[E0594]: cannot assign to `x.b`, as `x` is not declared as mutable\n-  --> $DIR/reassignment_immutable_fields_overlapping.rs:23:5\n-   |\n-LL |     let x: Foo;\n-   |         - help: consider changing this to be mutable: `mut x`\n-LL |     x.a = 1;  //~ ERROR\n-LL |     x.b = 22; //~ ERROR\n-   |     ^^^^^^^^ cannot assign\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0594`.\n+For more information about this error, try `rustc --explain E0381`."}, {"sha": "96677be724131274f26565b030aa8085b25eea1e", "filename": "src/test/ui/borrowck/reassignment_immutable_fields_twice.nll.stderr", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_twice.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_twice.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Freassignment_immutable_fields_twice.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -7,32 +7,13 @@ LL |     x = (22, 44);\n LL |     x.0 = 1; //~ ERROR\n    |     ^^^^^^^ cannot assign\n \n-error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n+error[E0381]: assign to part of possibly uninitialized variable: `x`\n   --> $DIR/reassignment_immutable_fields_twice.rs:22:5\n    |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n-LL |     x.0 = 1; //~ ERROR\n-   |     ^^^^^^^ cannot assign\n-\n-error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n-  --> $DIR/reassignment_immutable_fields_twice.rs:23:5\n-   |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n LL |     x.0 = 1; //~ ERROR\n-LL |     x.0 = 22; //~ ERROR\n-   |     ^^^^^^^^ cannot assign\n-\n-error[E0594]: cannot assign to `x.1`, as `x` is not declared as mutable\n-  --> $DIR/reassignment_immutable_fields_twice.rs:24:5\n-   |\n-LL |     let x: (u32, u32);\n-   |         - help: consider changing this to be mutable: `mut x`\n-...\n-LL |     x.1 = 44; //~ ERROR\n-   |     ^^^^^^^^ cannot assign\n+   |     ^^^^^^^ use of possibly uninitialized `x`\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0594`.\n+Some errors occurred: E0381, E0594.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "cdc5a047c07245729558156b08203842514901ac", "filename": "src/test/ui/issues/issue-17385.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fissues%2Fissue-17385.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fissues%2Fissue-17385.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17385.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `foo.0`\n+error[E0382]: use of moved value: `foo`\n   --> $DIR/issue-17385.rs:29:11\n    |\n LL |     drop(foo);"}, {"sha": "769e5474e000aec2e49aeafc6e16a1d5da3418b9", "filename": "src/test/ui/issues/issue-27282-move-match-input-into-guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -26,7 +26,7 @@ fn main() {\n         _ if { (|| { let bar = b; *bar = false; })();\n                      false } => { },\n         &mut true => { println!(\"You might think we should get here\"); },\n-        //~^ ERROR use of moved value: `*b` [E0382]\n+        //~^ ERROR use of moved value: `b` [E0382]\n         _ => panic!(\"surely we could never get here, since rustc warns it is unreachable.\"),\n     }\n }"}, {"sha": "5f3b07bd1e8b89131db9e17c86dd776dd90f97bc", "filename": "src/test/ui/issues/issue-27282-move-match-input-into-guard.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-27282-move-match-input-into-guard.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `*b`\n+error[E0382]: use of moved value: `b`\n   --> $DIR/issue-27282-move-match-input-into-guard.rs:28:14\n    |\n LL |         _ if { (|| { let bar = b; *bar = false; })();"}, {"sha": "463a64f4beca897e26de52df3b1404aed15069f3", "filename": "src/test/ui/liveness/liveness-use-after-move.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-use-after-move.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: borrow of moved value: `*x`\n+error[E0382]: borrow of moved value: `x`\n   --> $DIR/liveness-use-after-move.rs:16:20\n    |\n LL |     let y = x;"}, {"sha": "abafd330573ee8b8dba3e5f551e35d0691271b0e", "filename": "src/test/ui/nll/issue-21232-partial-init-and-erroneous-use.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,66 @@\n+// This test enumerates various cases of interest where a ADT or tuple is\n+// partially initialized and then used in some way that is wrong *even*\n+// after rust-lang/rust#54987 is implemented.\n+//\n+// See rust-lang/rust#21232, rust-lang/rust#54986, and rust-lang/rust#54987.\n+//\n+// See issue-21232-partial-init-and-use.rs for cases of tests that are\n+// meant to compile and run successfully once rust-lang/rust#54987 is\n+// implemented.\n+\n+#![feature(nll)]\n+\n+struct D {\n+    x: u32,\n+    s: S,\n+}\n+\n+struct S {\n+    y: u32,\n+    z: u32,\n+}\n+\n+\n+impl Drop for D {\n+    fn drop(&mut self) { }\n+}\n+\n+fn cannot_partially_init_adt_with_drop() {\n+    let d: D;\n+    d.x = 10;\n+    //~^ ERROR assign of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_init_mutable_adt_with_drop() {\n+    let mut d: D;\n+    d.x = 10;\n+    //~^ ERROR assign of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_reinit_adt_with_drop() {\n+    let mut d = D { x: 0, s: S{ y: 0, z: 0 } };\n+    drop(d);\n+    d.x = 10;\n+    //~^ ERROR assign of moved value: `d` [E0382]\n+}\n+\n+fn cannot_partially_init_inner_adt_via_outer_with_drop() {\n+    let d: D;\n+    d.s.y = 20;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_init_inner_adt_via_mutable_outer_with_drop() {\n+    let mut d: D;\n+    d.s.y = 20;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `d` [E0381]\n+}\n+\n+fn cannot_partially_reinit_inner_adt_via_outer_with_drop() {\n+    let mut d = D { x: 0, s: S{ y: 0, z: 0} };\n+    drop(d);\n+    d.s.y = 20;\n+    //~^ ERROR assign to part of moved value: `d` [E0382]\n+}\n+\n+fn main() { }"}, {"sha": "e29c44760a987ecfe39f154a67c6d146b5cde2e8", "filename": "src/test/ui/nll/issue-21232-partial-init-and-erroneous-use.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-erroneous-use.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,48 @@\n+error[E0381]: assign of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:30:5\n+   |\n+LL |     d.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `d`\n+\n+error[E0381]: assign of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:36:5\n+   |\n+LL |     d.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `d`\n+\n+error[E0382]: assign of moved value: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:43:5\n+   |\n+LL |     drop(d);\n+   |          - value moved here\n+LL |     d.x = 10;\n+   |     ^^^^^^^^ value assigned here after move\n+   |\n+   = note: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:49:5\n+   |\n+LL |     d.s.y = 20;\n+   |     ^^^^^^^^^^ use of possibly uninitialized `d.s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:55:5\n+   |\n+LL |     d.s.y = 20;\n+   |     ^^^^^^^^^^ use of possibly uninitialized `d.s`\n+\n+error[E0382]: assign to part of moved value: `d`\n+  --> $DIR/issue-21232-partial-init-and-erroneous-use.rs:62:5\n+   |\n+LL |     drop(d);\n+   |          - value moved here\n+LL |     d.s.y = 20;\n+   |     ^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors occurred: E0381, E0382.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "e3ae4c0dcbe5725afec62e49a7e3049e2920f2ba", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,311 @@\n+// This test enumerates various cases of interest for partial\n+// [re]initialization of ADTs and tuples.\n+//\n+// See rust-lang/rust#21232, rust-lang/rust#54986, and rust-lang/rust#54987.\n+//\n+// All of tests in this file are expected to change from being\n+// rejected, at least under NLL (by rust-lang/rust#54986) to being\n+// **accepted** when rust-lang/rust#54987 is implemented.\n+// (That's why there are assertions in the code.)\n+//\n+// See issue-21232-partial-init-and-erroneous-use.rs for cases of\n+// tests that are meant to continue failing to compile once\n+// rust-lang/rust#54987 is implemented.\n+\n+#![feature(nll)]\n+\n+struct S<Y> {\n+    x: u32,\n+\n+    // Note that even though `y` may implement `Drop`, under #54987 we\n+    // will still allow partial initialization of `S` itself.\n+    y: Y,\n+}\n+\n+enum Void { }\n+\n+type B = Box<u32>;\n+\n+impl S<B> { fn new() -> Self { S { x: 0, y: Box::new(0) } } }\n+\n+fn borrow_s(s: &S<B>) { assert_eq!(s.x, 10); assert_eq!(*s.y, 20); }\n+fn move_s(s: S<B>) {  assert_eq!(s.x, 10); assert_eq!(*s.y, 20); }\n+fn borrow_field(x: &u32) { assert_eq!(*x, 10); }\n+\n+type T = (u32, B);\n+type Tvoid = (u32, Void);\n+\n+fn borrow_t(t: &T) { assert_eq!(t.0, 10); assert_eq!(*t.1, 20); }\n+fn move_t(t: T) {  assert_eq!(t.0, 10); assert_eq!(*t.1, 20); }\n+\n+struct Q<F> {\n+    v: u32,\n+    r: R<F>,\n+}\n+\n+struct R<F> {\n+    w: u32,\n+    f: F,\n+}\n+\n+impl<F> Q<F> { fn new(f: F) -> Self { Q { v: 0, r: R::new(f) } } }\n+impl<F> R<F> { fn new(f: F) -> Self { R { w: 0, f } } }\n+\n+// Axes to cover:\n+// * local/field: Is the structure in a local or a field\n+// * fully/partial/void: Are we fully initializing it before using any part?\n+//                       Is whole type empty due to a void component?\n+// * init/reinit: First initialization, or did we previously inititalize and then move out?\n+// * struct/tuple: Is this a struct or a (X, Y).\n+//\n+// As a shorthand for the cases above, adding a numeric summary to\n+// each test's fn name to denote each point on each axis.\n+//\n+// E.g. 1000 = field fully init struct; 0211 = local void reinit tuple\n+\n+// It got pretty monotonous writing the same code over and over, and I\n+// feared I would forget details. So I abstracted some desiderata into\n+// macros. But I left the initialization code inline, because that's\n+// where the errors for #54986 will be emited.\n+\n+macro_rules! use_fully {\n+    (struct $s:expr) => { {\n+        borrow_field(& $s.x );\n+        borrow_s(& $s );\n+        move_s( $s );\n+    } };\n+\n+    (tuple $t:expr) => { {\n+        borrow_field(& $t.0 );\n+        borrow_t(& $t );\n+        move_t( $t );\n+    } }\n+}\n+\n+macro_rules! use_part {\n+    (struct $s:expr) => { {\n+        borrow_field(& $s.x );\n+        match $s { S { ref x, y: _ } => { borrow_field(x); } }\n+    } };\n+\n+    (tuple $t:expr) => { {\n+        borrow_field(& $t.0 );\n+        match $t { (ref x, _) => { borrow_field(x); } }\n+    } }\n+}\n+\n+fn test_0000_local_fully_init_and_use_struct() {\n+    let s: S<B>;\n+    s.x = 10; s.y = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `s` [E0381]\n+    use_fully!(struct s);\n+}\n+\n+fn test_0001_local_fully_init_and_use_tuple() {\n+    let t: T;\n+    t.0 = 10; t.1 = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    use_fully!(tuple t);\n+}\n+\n+fn test_0010_local_fully_reinit_and_use_struct() {\n+    let mut s: S<B> = S::new(); drop(s);\n+    s.x = 10; s.y = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `s` [E0382]\n+    use_fully!(struct s);\n+}\n+\n+fn test_0011_local_fully_reinit_and_use_tuple() {\n+    let mut t: T = (0, Box::new(0)); drop(t);\n+    t.0 = 10; t.1 = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `t` [E0382]\n+    use_fully!(tuple t);\n+}\n+\n+fn test_0100_local_partial_init_and_use_struct() {\n+    let s: S<B>;\n+    s.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `s` [E0381]\n+    use_part!(struct s);\n+}\n+\n+fn test_0101_local_partial_init_and_use_tuple() {\n+    let t: T;\n+    t.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    use_part!(tuple t);\n+}\n+\n+fn test_0110_local_partial_reinit_and_use_struct() {\n+    let mut s: S<B> = S::new(); drop(s);\n+    s.x = 10;\n+    //~^ ERROR assign to part of moved value: `s` [E0382]\n+    use_part!(struct s);\n+}\n+\n+fn test_0111_local_partial_reinit_and_use_tuple() {\n+    let mut t: T = (0, Box::new(0)); drop(t);\n+    t.0 = 10;\n+    //~^ ERROR assign to part of moved value: `t` [E0382]\n+    use_part!(tuple t);\n+}\n+\n+fn test_0200_local_void_init_and_use_struct() {\n+    let s: S<Void>;\n+    s.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `s` [E0381]\n+    use_part!(struct s);\n+}\n+\n+fn test_0201_local_void_init_and_use_tuple() {\n+    let t: Tvoid;\n+    t.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `t` [E0381]\n+    use_part!(tuple t);\n+}\n+\n+// NOTE: uniform structure of tests here makes n21n (aka combining\n+// Void with Reinit) an (even more) senseless case, as we cannot\n+// safely create initial instance containing Void to move out of and\n+// then reinitialize. While I was tempted to sidestep this via some\n+// unsafe code (eek), lets just instead not encode such tests.\n+\n+// fn test_0210_local_void_reinit_and_use_struct() { unimplemented!() }\n+// fn test_0211_local_void_reinit_and_use_tuple() { unimplemented!() }\n+\n+fn test_1000_field_fully_init_and_use_struct() {\n+    let q: Q<S<B>>;\n+    q.r.f.x = 10; q.r.f.y = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_fully!(struct q.r.f);\n+}\n+\n+fn test_1001_field_fully_init_and_use_tuple() {\n+    let q: Q<T>;\n+    q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_fully!(tuple q.r.f);\n+}\n+\n+fn test_1010_field_fully_reinit_and_use_struct() {\n+    let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+    q.r.f.x = 10; q.r.f.y = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_fully!(struct q.r.f);\n+}\n+\n+fn test_1011_field_fully_reinit_and_use_tuple() {\n+    let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+    q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_fully!(tuple q.r.f);\n+}\n+\n+fn test_1100_field_partial_init_and_use_struct() {\n+    let q: Q<S<B>>;\n+    q.r.f.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(struct q.r.f);\n+}\n+\n+fn test_1101_field_partial_init_and_use_tuple() {\n+    let q: Q<T>;\n+    q.r.f.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(tuple q.r.f);\n+}\n+\n+fn test_1110_field_partial_reinit_and_use_struct() {\n+    let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+    q.r.f.x = 10;\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_part!(struct q.r.f);\n+}\n+\n+fn test_1111_field_partial_reinit_and_use_tuple() {\n+    let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+    q.r.f.0 = 10;\n+    //~^ ERROR assign to part of moved value: `q.r` [E0382]\n+    use_part!(tuple q.r.f);\n+}\n+\n+fn test_1200_field_void_init_and_use_struct() {\n+    let mut q: Q<S<Void>>;\n+    q.r.f.x = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(struct q.r.f);\n+}\n+\n+fn test_1201_field_void_init_and_use_tuple() {\n+    let mut q: Q<Tvoid>;\n+    q.r.f.0 = 10;\n+    //~^ ERROR assign to part of possibly uninitialized variable: `q` [E0381]\n+    use_part!(tuple q.r.f);\n+}\n+\n+// See NOTE abve.\n+\n+// fn test_1210_field_void_reinit_and_use_struct() { unimplemented!() }\n+// fn test_1211_field_void_reinit_and_use_tuple() { unimplemented!() }\n+\n+// The below are some additional cases of interest that have been\n+// transcribed from other bugs based on old erroneous codegen when we\n+// encountered partial writes.\n+\n+fn issue_26996() {\n+    let mut c = (1, \"\".to_owned());\n+    match c {\n+        c2 => {\n+            c.0 = 2; //~ ERROR assign to part of moved value\n+            assert_eq!(c2.0, 1);\n+        }\n+    }\n+}\n+\n+fn issue_27021() {\n+    let mut c = (1, (1, \"\".to_owned()));\n+    match c {\n+        c2 => {\n+            (c.1).0 = 2; //~ ERROR assign to part of moved value\n+            assert_eq!((c2.1).0, 1);\n+        }\n+    }\n+\n+    let mut c = (1, (1, (1, \"\".to_owned())));\n+    match c.1 {\n+        c2 => {\n+            ((c.1).1).0 = 3; //~ ERROR assign to part of moved value\n+            assert_eq!((c2.1).0, 1);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    test_0000_local_fully_init_and_use_struct();\n+    test_0001_local_fully_init_and_use_tuple();\n+    test_0010_local_fully_reinit_and_use_struct();\n+    test_0011_local_fully_reinit_and_use_tuple();\n+    test_0100_local_partial_init_and_use_struct();\n+    test_0101_local_partial_init_and_use_tuple();\n+    test_0110_local_partial_reinit_and_use_struct();\n+    test_0111_local_partial_reinit_and_use_tuple();\n+    test_0200_local_void_init_and_use_struct();\n+    test_0201_local_void_init_and_use_tuple();\n+    // test_0210_local_void_reinit_and_use_struct();\n+    // test_0211_local_void_reinit_and_use_tuple();\n+    test_1000_field_fully_init_and_use_struct();\n+    test_1001_field_fully_init_and_use_tuple();\n+    test_1010_field_fully_reinit_and_use_struct();\n+    test_1011_field_fully_reinit_and_use_tuple();\n+    test_1100_field_partial_init_and_use_struct();\n+    test_1101_field_partial_init_and_use_tuple();\n+    test_1110_field_partial_reinit_and_use_struct();\n+    test_1111_field_partial_reinit_and_use_tuple();\n+    test_1200_field_void_init_and_use_struct();\n+    test_1201_field_void_init_and_use_tuple();\n+    // test_1210_field_void_reinit_and_use_struct();\n+    // test_1211_field_void_reinit_and_use_tuple();\n+\n+    issue_26996();\n+    issue_27021();\n+}"}, {"sha": "aec7f676fcebd6688b2d912f52e398f5f416a1d6", "filename": "src/test/ui/nll/issue-21232-partial-init-and-use.stderr", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-21232-partial-init-and-use.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,186 @@\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:99:5\n+   |\n+LL |     s.x = 10; s.y = Box::new(20);\n+   |     ^^^^^^^^ use of possibly uninitialized `s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:106:5\n+   |\n+LL |     t.0 = 10; t.1 = Box::new(20);\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0382]: assign to part of moved value: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:113:5\n+   |\n+LL |     let mut s: S<B> = S::new(); drop(s);\n+   |                                      - value moved here\n+LL |     s.x = 10; s.y = Box::new(20);\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:120:5\n+   |\n+LL |     let mut t: T = (0, Box::new(0)); drop(t);\n+   |                                           - value moved here\n+LL |     t.0 = 10; t.1 = Box::new(20);\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:127:5\n+   |\n+LL |     s.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:134:5\n+   |\n+LL |     t.0 = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0382]: assign to part of moved value: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:141:5\n+   |\n+LL |     let mut s: S<B> = S::new(); drop(s);\n+   |                                      - value moved here\n+LL |     s.x = 10;\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `s` has type `S<std::boxed::Box<u32>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:148:5\n+   |\n+LL |     let mut t: T = (0, Box::new(0)); drop(t);\n+   |                                           - value moved here\n+LL |     t.0 = 10;\n+   |     ^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `t` has type `(u32, std::boxed::Box<u32>)`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `s`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:155:5\n+   |\n+LL |     s.x = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `s`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `t`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:162:5\n+   |\n+LL |     t.0 = 10;\n+   |     ^^^^^^^^ use of possibly uninitialized `t`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:178:5\n+   |\n+LL |     q.r.f.x = 10; q.r.f.y = Box::new(20);\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:185:5\n+   |\n+LL |     q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:192:5\n+   |\n+LL |     let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+   |                                                 --- value moved here\n+LL |     q.r.f.x = 10; q.r.f.y = Box::new(20);\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<S<std::boxed::Box<u32>>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:199:5\n+   |\n+LL |     let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+   |                                                      --- value moved here\n+LL |     q.r.f.0 = 10; q.r.f.1 = Box::new(20);\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<(u32, std::boxed::Box<u32>)>`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:206:5\n+   |\n+LL |     q.r.f.x = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:213:5\n+   |\n+LL |     q.r.f.0 = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:220:5\n+   |\n+LL |     let mut q: Q<S<B>> = Q::new(S::new()); drop(q.r);\n+   |                                                 --- value moved here\n+LL |     q.r.f.x = 10;\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<S<std::boxed::Box<u32>>>`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `q.r`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:227:5\n+   |\n+LL |     let mut q: Q<T> = Q::new((0, Box::new(0))); drop(q.r);\n+   |                                                      --- value moved here\n+LL |     q.r.f.0 = 10;\n+   |     ^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `q.r` has type `R<(u32, std::boxed::Box<u32>)>`, which does not implement the `Copy` trait\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:234:5\n+   |\n+LL |     q.r.f.x = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0381]: assign to part of possibly uninitialized variable: `q`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:241:5\n+   |\n+LL |     q.r.f.0 = 10;\n+   |     ^^^^^^^^^^^^ use of possibly uninitialized `q.r.f`\n+\n+error[E0382]: assign to part of moved value: `c`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:259:13\n+   |\n+LL |         c2 => {\n+   |         -- value moved here\n+LL |             c.0 = 2; //~ ERROR assign to part of moved value\n+   |             ^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `c` has type `(i32, std::string::String)`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `c`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:269:13\n+   |\n+LL |         c2 => {\n+   |         -- value moved here\n+LL |             (c.1).0 = 2; //~ ERROR assign to part of moved value\n+   |             ^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `c` has type `(i32, (i32, std::string::String))`, which does not implement the `Copy` trait\n+\n+error[E0382]: assign to part of moved value: `c.1`\n+  --> $DIR/issue-21232-partial-init-and-use.rs:277:13\n+   |\n+LL |         c2 => {\n+   |         -- value moved here\n+LL |             ((c.1).1).0 = 3; //~ ERROR assign to part of moved value\n+   |             ^^^^^^^^^^^^^^^ value partially assigned here after move\n+   |\n+   = note: move occurs because `c.1` has type `(i32, (i32, std::string::String))`, which does not implement the `Copy` trait\n+\n+error: aborting due to 23 previous errors\n+\n+Some errors occurred: E0381, E0382.\n+For more information about an error, try `rustc --explain E0381`."}, {"sha": "43debec69b5f25ceaf11cc1d170289479fb6e14f", "filename": "src/test/ui/nll/issue-51512.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-51512.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-51512.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51512.rs?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -15,5 +15,5 @@ fn main() {\n     let range = 0..1;\n     let r = range;\n     let x = range.start;\n-    //~^ ERROR use of moved value: `range.start` [E0382]\n+    //~^ ERROR use of moved value: `range` [E0382]\n }"}, {"sha": "49c419998a4809d766bf8e8902114e02debc8e48", "filename": "src/test/ui/nll/issue-51512.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-51512.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `range.start`\n+error[E0382]: use of moved value: `range`\n   --> $DIR/issue-51512.rs:17:13\n    |\n LL |     let r = range;"}, {"sha": "a4f5e41b5291c7e57db7eae26469bdf0712eddab", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `u.y`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:29:13\n    |\n LL |     let a = u.x.0;\n@@ -8,7 +8,7 @@ LL |     let a = u.y; //~ ERROR use of moved value: `u.y`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.y`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n    |\n LL |     let a = (u.x.0).0;\n@@ -18,7 +18,7 @@ LL |     let a = u.y; //~ ERROR use of moved value: `u.y`\n    |\n    = note: move occurs because `u` has type `U`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value: `u.x`\n+error[E0382]: use of moved value: `u`\n   --> $DIR/union-borrow-move-parent-sibling.rs:53:13\n    |\n LL |     let a = *u.y;"}, {"sha": "f13324955fab0d7c32696399e26241848a4d51d0", "filename": "src/test/ui/use/use-after-move-self-based-on-type.nll.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self-based-on-type.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -0,0 +1,13 @@\n+error[E0382]: use of moved value: `self`\n+  --> $DIR/use-after-move-self-based-on-type.rs:22:16\n+   |\n+LL |         self.bar();\n+   |         ---- value moved here\n+LL |         return self.x;  //~ ERROR use of moved value: `self.x`\n+   |                ^^^^^^ value used here after move\n+   |\n+   = note: move occurs because `self` has type `S`, which does not implement the `Copy` trait\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0382`."}, {"sha": "241dc32bb05e3b18c140938e2d33fbdfe23031d0", "filename": "src/test/ui/use/use-after-move-self.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-after-move-self.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: use of moved value: `*self.x`\n+error[E0382]: use of moved value: `self`\n   --> $DIR/use-after-move-self.rs:20:16\n    |\n LL |         self.bar();"}, {"sha": "e2c4a19debe4b5da84062e374267716f3b56f668", "filename": "src/test/ui/walk-struct-literal-with.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fwalk-struct-literal-with.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7/src%2Ftest%2Fui%2Fwalk-struct-literal-with.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwalk-struct-literal-with.nll.stderr?ref=cbbd70d4f25bc255d80b6b9ba0a65f6c5957f2b7", "patch": "@@ -1,4 +1,4 @@\n-error[E0382]: borrow of moved value: `start.test`\n+error[E0382]: borrow of moved value: `start`\n   --> $DIR/walk-struct-literal-with.rs:26:20\n    |\n LL |     let end = Mine{other_val:1, ..start.make_string_bar()};"}]}