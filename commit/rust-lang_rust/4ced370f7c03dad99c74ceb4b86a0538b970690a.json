{"sha": "4ced370f7c03dad99c74ceb4b86a0538b970690a", "node_id": "C_kwDOAAsO6NoAKDRjZWQzNzBmN2MwM2RhZDk5Yzc0Y2ViNGI4NmEwNTM4Yjk3MDY5MGE", "commit": {"author": {"name": "mejrs", "email": "", "date": "2022-09-28T13:11:27Z"}, "committer": {"name": "mejrs", "email": "", "date": "2022-11-29T16:33:50Z"}, "message": "Make `missing_copy_implementations` more cautious", "tree": {"sha": "b9c8dfd78187732b12425fbfde09cc2dc32404e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9c8dfd78187732b12425fbfde09cc2dc32404e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ced370f7c03dad99c74ceb4b86a0538b970690a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ced370f7c03dad99c74ceb4b86a0538b970690a", "html_url": "https://github.com/rust-lang/rust/commit/4ced370f7c03dad99c74ceb4b86a0538b970690a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ced370f7c03dad99c74ceb4b86a0538b970690a/comments", "author": {}, "committer": {}, "parents": [{"sha": "c372b1470109547e37dcc29ffd4723ac9f66f15d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c372b1470109547e37dcc29ffd4723ac9f66f15d", "html_url": "https://github.com/rust-lang/rust/commit/c372b1470109547e37dcc29ffd4723ac9f66f15d"}], "stats": {"total": 69, "additions": 68, "deletions": 1}, "files": [{"sha": "1ea41098413f8966ee5dfd858d17df9d61ce8840", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4ced370f7c03dad99c74ceb4b86a0538b970690a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ced370f7c03dad99c74ceb4b86a0538b970690a/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=4ced370f7c03dad99c74ceb4b86a0538b970690a", "patch": "@@ -46,14 +46,16 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::List;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_target::abi::{Abi, VariantIdx};\n-use rustc_trait_selection::traits::{self, misc::can_type_implement_copy};\n+use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n+use rustc_trait_selection::traits::{self, misc::can_type_implement_copy, EvaluationResult};\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n \n@@ -750,10 +752,40 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         if def.has_dtor(cx.tcx) {\n             return;\n         }\n+\n+        // If the type contains a raw pointer, it may represent something like a handle,\n+        // and recommending Copy might be a bad idea.\n+        for field in def.all_fields() {\n+            let did = field.did;\n+            if cx.tcx.type_of(did).is_unsafe_ptr() {\n+                return;\n+            }\n+        }\n         let param_env = ty::ParamEnv::empty();\n         if ty.is_copy_modulo_regions(cx.tcx, param_env) {\n             return;\n         }\n+\n+        // We shouldn't recommend implementing `Copy` on stateful things,\n+        // such as iterators.\n+        if let Some(iter_trait) = cx.tcx.get_diagnostic_item(sym::Iterator) {\n+            if cx.tcx.infer_ctxt().enter(|infer_ctxt| {\n+                infer_ctxt.type_implements_trait(iter_trait, ty, List::empty(), param_env)\n+                    == EvaluationResult::EvaluatedToOk\n+            }) {\n+                return;\n+            }\n+        }\n+\n+        // Default value of clippy::trivially_copy_pass_by_ref\n+        const MAX_SIZE: u64 = 256;\n+\n+        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes()) {\n+            if size > MAX_SIZE {\n+                return;\n+            }\n+        }\n+\n         if can_type_implement_copy(\n             cx.tcx,\n             param_env,"}, {"sha": "051a905aed643d7817e7124a41fb4cc0d197eeb2", "filename": "src/test/ui/lint/lint-missing-copy-implementations-allow.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4ced370f7c03dad99c74ceb4b86a0538b970690a/src%2Ftest%2Fui%2Flint%2Flint-missing-copy-implementations-allow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ced370f7c03dad99c74ceb4b86a0538b970690a/src%2Ftest%2Fui%2Flint%2Flint-missing-copy-implementations-allow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-missing-copy-implementations-allow.rs?ref=4ced370f7c03dad99c74ceb4b86a0538b970690a", "patch": "@@ -0,0 +1,35 @@\n+// check-pass\n+#![deny(missing_copy_implementations)]\n+\n+// Don't recommend implementing Copy on something stateful like an iterator.\n+pub struct MyIterator {\n+    num: u8,\n+}\n+\n+impl Iterator for MyIterator {\n+    type Item = u8;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        todo!()\n+    }\n+}\n+\n+pub struct Handle {\n+    inner: *mut (),\n+}\n+\n+pub struct Handle2 {\n+    inner: *const (),\n+}\n+\n+pub enum MaybeHandle {\n+    Ptr(*mut ()),\n+}\n+\n+pub union UnionHandle {\n+    ptr: *mut (),\n+}\n+\n+pub struct Array([u8; 2048]);\n+\n+fn main() {}"}]}