{"sha": "0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZTk5N2NlZTZkYzZmNzE1NjRlMzBiNWM4ZjQwNzQ5YmY0Y2ZjMjM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-19T22:22:57Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-19T22:29:27Z"}, "message": "rustc: Make structured comparison glue instead of emitting it inline", "tree": {"sha": "8f21eee9026c81bebffb240f74609195fe68e96e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f21eee9026c81bebffb240f74609195fe68e96e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "html_url": "https://github.com/rust-lang/rust/commit/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7dd75c904277630675e432b3398a584d882b5ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7dd75c904277630675e432b3398a584d882b5ac", "html_url": "https://github.com/rust-lang/rust/commit/b7dd75c904277630675e432b3398a584d882b5ac"}], "stats": {"total": 547, "additions": 350, "deletions": 197}, "files": [{"sha": "d9b58c114e94db5aa63a438d65569d06fe884c34", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 333, "deletions": 196, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "patch": "@@ -374,7 +374,7 @@ fn T_tydesc(type_names tn) -> TypeRef {\n                                      T_ptr(T_nil()),\n                                      tydescpp,\n                                      pvoid), T_void()));\n-    auto cmp_glue_fn_ty = T_ptr(T_fn(vec(T_ptr(T_i8()),\n+    auto cmp_glue_fn_ty = T_ptr(T_fn(vec(T_ptr(T_i1()),\n                                          T_taskptr(tn),\n                                          T_ptr(T_nil()),\n                                          tydescpp,\n@@ -887,6 +887,10 @@ fn C_int(int i) -> ValueRef {\n     ret C_integral(i, T_int());\n }\n \n+fn C_i8(uint i) -> ValueRef {\n+    ret C_integral(i as int, T_i8());\n+}\n+\n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n fn C_cstr(@crate_ctxt cx, str s) -> ValueRef {\n@@ -1730,7 +1734,7 @@ fn make_generic_glue(@local_ctxt cx,\n         }\n         case (mgghf_cmp) {\n             auto llrawptr1 = llvm.LLVMGetParam(llfn, 5u);\n-            auto llval1 = bcx.build.BitCast(llrawptr0, llty);\n+            auto llval1 = bcx.build.BitCast(llrawptr1, llty);\n \n             auto llcmpval = llvm.LLVMGetParam(llfn, 6u);\n \n@@ -1980,9 +1984,257 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n     ret res(next_cx, phi);\n }\n \n-fn make_cmp_glue(@block_ctxt cx, ValueRef v0, ValueRef v1, @ty.t t,\n-        ValueRef llop) {\n-    cx.build.RetVoid();     // TODO\n+// Structural comparison: a rather involved form of glue.\n+\n+fn make_cmp_glue(@block_ctxt cx,\n+                 ValueRef lhs0,\n+                 ValueRef rhs0,\n+                 @ty.t t,\n+                 ValueRef llop) {\n+    auto lhs = load_if_immediate(cx, lhs0, t);\n+    auto rhs = load_if_immediate(cx, rhs0, t);\n+\n+    if (ty.type_is_scalar(t)) {\n+        make_scalar_cmp_glue(cx, lhs, rhs, t, llop);\n+\n+    } else if (ty.type_is_box(t)) {\n+        lhs = cx.build.GEP(lhs, vec(C_int(0), C_int(abi.box_rc_field_body)));\n+        rhs = cx.build.GEP(rhs, vec(C_int(0), C_int(abi.box_rc_field_body)));\n+        auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n+\n+        rslt.bcx.build.Store(rslt.val, cx.fcx.llretptr);\n+        rslt.bcx.build.RetVoid();\n+\n+    } else if (ty.type_is_structural(t)\n+               || ty.type_is_sequence(t)) {\n+\n+        auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n+        auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n+        cx.build.Br(scx.llbb);\n+\n+        /*\n+         * We're doing lexicographic comparison here. We start with the\n+         * assumption that the two input elements are equal. Depending on\n+         * operator, this means that the result is either true or false;\n+         * equality produces 'true' for ==, <= and >=. It produces 'false' for\n+         * !=, < and >.\n+         *\n+         * We then move one element at a time through the structure checking\n+         * for pairwise element equality. If we have equality, our assumption\n+         * about overall sequence equality is not modified, so we have to move\n+         * to the next element.\n+         *\n+         * If we do not have pairwise element equality, we have reached an\n+         * element that 'decides' the lexicographic comparison. So we exit the\n+         * loop with a flag that indicates the true/false sense of that\n+         * decision, by testing the element again with the operator we're\n+         * interested in.\n+         *\n+         * When we're lucky, LLVM should be able to fold some of these two\n+         * tests together (as they're applied to the same operands and in some\n+         * cases are sometimes redundant). But we don't bother trying to\n+         * optimize combinations like that, at this level.\n+         */\n+\n+        auto flag = alloca(scx, T_i1());\n+        llvm.LLVMSetValueName(flag, _str.buf(\"flag\"));\n+\n+        auto r;\n+        if (ty.type_is_sequence(t)) {\n+\n+            // If we hit == all the way through the minimum-shared-length\n+            // section, default to judging the relative sequence lengths.\n+            r = compare_integral_values(scx,\n+                                        vec_fill(scx, lhs),\n+                                        vec_fill(scx, rhs),\n+                                        false,\n+                                        llop);\n+            r.bcx.build.Store(r.val, flag);\n+\n+        } else {\n+            // == and <= default to true if they find == all the way. <\n+            // defaults to false if it finds == all the way.\n+            auto result_if_equal = scx.build.ICmp(lib.llvm.LLVMIntNE, llop,\n+                                                  C_i8(abi.cmp_glue_op_lt));\n+            scx.build.Store(result_if_equal, flag);\n+            r = res(scx, C_nil());\n+        }\n+\n+        fn inner(@block_ctxt last_cx,\n+                 bool load_inner,\n+                 ValueRef flag,\n+                 ValueRef llop,\n+                 @block_ctxt cx,\n+                 ValueRef av0,\n+                 ValueRef bv0,\n+                 @ty.t t) -> result {\n+\n+            auto cnt_cx = new_sub_block_ctxt(cx, \"continue_comparison\");\n+            auto stop_cx = new_sub_block_ctxt(cx, \"stop_comparison\");\n+\n+            auto av = av0;\n+            auto bv = bv0;\n+            if (load_inner) {\n+                // If `load_inner` is true, then the pointer type will always\n+                // be i8, because the data part of a vector always has type\n+                // i8[]. So we need to cast it to the proper type.\n+\n+                if (!ty.type_has_dynamic_size(t)) {\n+                    auto llelemty = T_ptr(type_of(last_cx.fcx.lcx.ccx, t));\n+                    av = cx.build.PointerCast(av, llelemty);\n+                    bv = cx.build.PointerCast(bv, llelemty);\n+                }\n+\n+                av = load_if_immediate(cx, av, t);\n+                bv = load_if_immediate(cx, bv, t);\n+            }\n+\n+            // First 'eq' comparison: if so, continue to next elts.\n+            auto eq_r = call_cmp_glue(cx, av, bv, t,\n+                                      C_i8(abi.cmp_glue_op_eq));\n+            eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n+\n+            // Second 'op' comparison: find out how this elt-pair decides.\n+            auto stop_r = call_cmp_glue(stop_cx, av, bv, t, llop);\n+            stop_r.bcx.build.Store(stop_r.val, flag);\n+            stop_r.bcx.build.Br(last_cx.llbb);\n+            ret res(cnt_cx, C_nil());\n+        }\n+\n+        if (ty.type_is_structural(t)) {\n+            r = iter_structural_ty_full(r.bcx, lhs, rhs, t,\n+                                        bind inner(next, false, flag, llop,\n+                                                   _, _, _, _));\n+        } else {\n+            auto lhs_p0 = vec_p0(r.bcx, lhs);\n+            auto rhs_p0 = vec_p0(r.bcx, rhs);\n+            auto min_len = umin(r.bcx, vec_fill(r.bcx, lhs),\n+                                vec_fill(r.bcx, rhs));\n+            auto rhs_lim = r.bcx.build.GEP(rhs_p0, vec(min_len));\n+            auto elt_ty = ty.sequence_element_type(t);\n+            r = size_of(r.bcx, elt_ty);\n+            r = iter_sequence_raw(r.bcx, lhs_p0, rhs_p0, rhs_lim, r.val,\n+                                  bind inner(next, true, flag, llop,\n+                                             _, _, _, elt_ty));\n+        }\n+\n+        r.bcx.build.Br(next.llbb);\n+        auto v = next.build.Load(flag);\n+\n+        next.build.Store(v, cx.fcx.llretptr);\n+        next.build.RetVoid();\n+\n+\n+    } else {\n+        // FIXME: compare obj, fn by pointer?\n+        trans_fail(cx, none[common.span],\n+                   \"attempt to compare values of type \" + ty.ty_to_str(t));\n+    }\n+}\n+\n+// A helper function to create scalar comparison glue.\n+fn make_scalar_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t t,\n+                        ValueRef llop) {\n+    if (ty.type_is_fp(t)) {\n+        make_fp_cmp_glue(cx, lhs, rhs, t, llop);\n+        ret;\n+    }\n+\n+    if (ty.type_is_integral(t) || ty.type_is_bool(t)) {\n+        make_integral_cmp_glue(cx, lhs, rhs, t, llop);\n+        ret;\n+    }\n+\n+    if (ty.type_is_nil(t)) {\n+        cx.build.Store(C_bool(true), cx.fcx.llretptr);\n+        cx.build.RetVoid();\n+        ret;\n+    }\n+\n+    trans_fail(cx, none[common.span],\n+               \"attempt to compare values of type \" + ty.ty_to_str(t));\n+}\n+\n+// A helper function to create floating point comparison glue.\n+fn make_fp_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t fptype,\n+                    ValueRef llop) {\n+    auto last_cx = new_sub_block_ctxt(cx, \"last\");\n+\n+    auto eq_cx = new_sub_block_ctxt(cx, \"eq\");\n+    auto eq_result = eq_cx.build.FCmp(lib.llvm.LLVMRealUEQ, lhs, rhs);\n+    eq_cx.build.Br(last_cx.llbb);\n+\n+    auto lt_cx = new_sub_block_ctxt(cx, \"lt\");\n+    auto lt_result = lt_cx.build.FCmp(lib.llvm.LLVMRealULT, lhs, rhs);\n+    lt_cx.build.Br(last_cx.llbb);\n+\n+    auto le_cx = new_sub_block_ctxt(cx, \"le\");\n+    auto le_result = le_cx.build.FCmp(lib.llvm.LLVMRealULE, lhs, rhs);\n+    le_cx.build.Br(last_cx.llbb);\n+\n+    auto unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n+    unreach_cx.build.Unreachable();\n+\n+    auto llswitch = cx.build.Switch(llop, unreach_cx.llbb, 3u);\n+    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_eq), eq_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_lt), lt_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_le), le_cx.llbb);\n+\n+    auto last_result =\n+        last_cx.build.Phi(T_i1(), vec(eq_result, lt_result, le_result),\n+                          vec(eq_cx.llbb, lt_cx.llbb, le_cx.llbb));\n+    last_cx.build.Store(last_result, cx.fcx.llretptr);\n+    last_cx.build.RetVoid();\n+}\n+\n+// A helper function to compare integral values. This is used by both\n+// `make_integral_cmp_glue` and `make_cmp_glue`.\n+fn compare_integral_values(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                           bool signed, ValueRef llop) -> result {\n+    auto lt_cmp; auto le_cmp;\n+    if (signed) {\n+        lt_cmp = lib.llvm.LLVMIntSLT;\n+        le_cmp = lib.llvm.LLVMIntSLE;\n+    } else {\n+        lt_cmp = lib.llvm.LLVMIntULT;\n+        le_cmp = lib.llvm.LLVMIntULE;\n+    }\n+\n+    auto last_cx = new_sub_block_ctxt(cx, \"last\");\n+\n+    auto eq_cx = new_sub_block_ctxt(cx, \"eq\");\n+    auto eq_result = eq_cx.build.ICmp(lib.llvm.LLVMIntEQ, lhs, rhs);\n+    eq_cx.build.Br(last_cx.llbb);\n+\n+    auto lt_cx = new_sub_block_ctxt(cx, \"lt\");\n+    auto lt_result = lt_cx.build.ICmp(lt_cmp, lhs, rhs);\n+    lt_cx.build.Br(last_cx.llbb);\n+\n+    auto le_cx = new_sub_block_ctxt(cx, \"le\");\n+    auto le_result = le_cx.build.ICmp(le_cmp, lhs, rhs);\n+    le_cx.build.Br(last_cx.llbb);\n+\n+    auto unreach_cx = new_sub_block_ctxt(cx, \"unreach\");\n+    unreach_cx.build.Unreachable();\n+\n+    auto llswitch = cx.build.Switch(llop, unreach_cx.llbb, 3u);\n+    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_eq), eq_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_lt), lt_cx.llbb);\n+    llvm.LLVMAddCase(llswitch, C_i8(abi.cmp_glue_op_le), le_cx.llbb);\n+\n+    auto last_result =\n+        last_cx.build.Phi(T_i1(), vec(eq_result, lt_result, le_result),\n+                          vec(eq_cx.llbb, lt_cx.llbb, le_cx.llbb));\n+    ret res(last_cx, last_result);\n+}\n+\n+// A helper function to create integral comparison glue.\n+fn make_integral_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n+                          @ty.t intype, ValueRef llop) {\n+    auto r = compare_integral_values(cx, lhs, rhs, ty.type_is_signed(intype),\n+                                     llop);\n+    r.bcx.build.Store(r.val, r.bcx.fcx.llretptr);\n+    r.bcx.build.RetVoid();\n }\n \n \n@@ -2403,6 +2655,42 @@ fn call_tydesc_glue(@block_ctxt cx, ValueRef v, @ty.t t, int field) {\n                           td.val, field);\n }\n \n+fn call_cmp_glue(@block_ctxt cx, ValueRef lhs, ValueRef rhs, @ty.t t,\n+                 ValueRef llop) -> result {\n+    // We can't use call_tydesc_glue_full() and friends here because compare\n+    // glue has a special signature.\n+\n+    auto lllhs = spill_if_immediate(cx, lhs, t);\n+    auto llrhs = spill_if_immediate(cx, rhs, t);\n+\n+    auto llrawlhsptr = cx.build.BitCast(lllhs, T_ptr(T_i8()));\n+    auto llrawrhsptr = cx.build.BitCast(llrhs, T_ptr(T_i8()));\n+\n+    auto r = get_tydesc(cx, t);\n+    auto lltydescs =\n+        r.bcx.build.GEP(r.val, vec(C_int(0),\n+                                   C_int(abi.tydesc_field_first_param)));\n+    lltydescs = r.bcx.build.Load(lltydescs);\n+    auto llfnptr =\n+        r.bcx.build.GEP(r.val, vec(C_int(0),\n+                                   C_int(abi.tydesc_field_cmp_glue)));\n+    auto llfn = r.bcx.build.Load(llfnptr);\n+\n+    auto llcmpresultptr = r.bcx.build.Alloca(T_i1());\n+\n+    let vec[ValueRef] llargs = vec(llcmpresultptr,\n+                                   r.bcx.fcx.lltaskptr,\n+                                   C_null(T_ptr(T_nil())),\n+                                   lltydescs,\n+                                   llrawlhsptr,\n+                                   llrawrhsptr,\n+                                   llop);\n+\n+    r.bcx.build.FastCall(llfn, llargs);\n+\n+    ret res(r.bcx, r.bcx.build.Load(llcmpresultptr));\n+}\n+\n fn take_ty(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     if (!ty.type_is_scalar(t)) {\n         call_tydesc_glue(cx, v, t, abi.tydesc_field_take_glue);\n@@ -2661,7 +2949,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n \n fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n                  ValueRef lhs0, ValueRef rhs0) -> result {\n-\n+    // Autoderef both sides.\n     auto cx = cx0;\n \n     auto lhs_r = autoderef(cx, lhs0, t0);\n@@ -2674,194 +2962,30 @@ fn trans_compare(@block_ctxt cx0, ast.binop op, @ty.t t0,\n \n     auto t = autoderefed_ty(t0);\n \n-    if (ty.type_is_scalar(t)) {\n-        ret res(cx, trans_scalar_compare(cx, op, t, lhs, rhs));\n-\n-    } else if (ty.type_is_structural(t)\n-               || ty.type_is_sequence(t)) {\n-\n-        auto scx = new_sub_block_ctxt(cx, \"structural compare start\");\n-        auto next = new_sub_block_ctxt(cx, \"structural compare end\");\n-        cx.build.Br(scx.llbb);\n-\n-        /*\n-         * We're doing lexicographic comparison here. We start with the\n-         * assumption that the two input elements are equal. Depending on\n-         * operator, this means that the result is either true or false;\n-         * equality produces 'true' for ==, <= and >=. It produces 'false' for\n-         * !=, < and >.\n-         *\n-         * We then move one element at a time through the structure checking\n-         * for pairwise element equality. If we have equality, our assumption\n-         * about overall sequence equality is not modified, so we have to move\n-         * to the next element.\n-         *\n-         * If we do not have pairwise element equality, we have reached an\n-         * element that 'decides' the lexicographic comparison. So we exit the\n-         * loop with a flag that indicates the true/false sense of that\n-         * decision, by testing the element again with the operator we're\n-         * interested in.\n-         *\n-         * When we're lucky, LLVM should be able to fold some of these two\n-         * tests together (as they're applied to the same operands and in some\n-         * cases are sometimes redundant). But we don't bother trying to\n-         * optimize combinations like that, at this level.\n-         */\n-\n-        auto flag = alloca(scx, T_i1());\n-\n-        if (ty.type_is_sequence(t)) {\n-\n-            // If we hit == all the way through the minimum-shared-length\n-            // section, default to judging the relative sequence lengths.\n-            auto len_cmp =\n-                trans_integral_compare(scx, op, plain_ty(ty.ty_uint),\n-                                       vec_fill(scx, lhs),\n-                                       vec_fill(scx, rhs));\n-            scx.build.Store(len_cmp, flag);\n-\n-        } else {\n-            auto T = C_integral(1, T_i1());\n-            auto F = C_integral(0, T_i1());\n-\n-            alt (op) {\n-                // ==, <= and >= default to true if they find == all the way.\n-                case (ast.eq) { scx.build.Store(T, flag); }\n-                case (ast.le) { scx.build.Store(T, flag); }\n-                case (ast.ge) { scx.build.Store(T, flag); }\n-                case (_) {\n-                    // < > default to false if they find == all the way.\n-                    scx.build.Store(F, flag);\n-                }\n-\n-            }\n-        }\n-\n-        fn inner(@block_ctxt last_cx,\n-                 bool load_inner,\n-                 ValueRef flag,\n-                 ast.binop op,\n-                 @block_ctxt cx,\n-                 ValueRef av0,\n-                 ValueRef bv0,\n-                 @ty.t t) -> result {\n-\n-            auto cnt_cx = new_sub_block_ctxt(cx, \"continue comparison\");\n-            auto stop_cx = new_sub_block_ctxt(cx, \"stop comparison\");\n-\n-            auto av = av0;\n-            auto bv = bv0;\n-            if (load_inner) {\n-                av = load_if_immediate(cx, av, t);\n-                bv = load_if_immediate(cx, bv, t);\n-            }\n-\n-            // First 'eq' comparison: if so, continue to next elts.\n-            auto eq_r = trans_compare(cx, ast.eq, t, av, bv);\n-            eq_r.bcx.build.CondBr(eq_r.val, cnt_cx.llbb, stop_cx.llbb);\n-\n-            // Second 'op' comparison: find out how this elt-pair decides.\n-            auto stop_r = trans_compare(stop_cx, op, t, av, bv);\n-            stop_r.bcx.build.Store(stop_r.val, flag);\n-            stop_r.bcx.build.Br(last_cx.llbb);\n-            ret res(cnt_cx, C_nil());\n-        }\n-\n-        auto r;\n-        if (ty.type_is_structural(t)) {\n-            r = iter_structural_ty_full(scx, lhs, rhs, t,\n-                                        bind inner(next, false, flag, op,\n-                                                   _, _, _, _));\n-        } else {\n-            auto lhs_p0 = vec_p0(scx, lhs);\n-            auto rhs_p0 = vec_p0(scx, rhs);\n-            auto min_len = umin(scx, vec_fill(scx, lhs), vec_fill(scx, rhs));\n-            auto rhs_lim = scx.build.GEP(rhs_p0, vec(min_len));\n-            auto elt_ty = ty.sequence_element_type(t);\n-            auto elt_llsz_r = size_of(scx, elt_ty);\n-            scx = elt_llsz_r.bcx;\n-            r = iter_sequence_raw(scx, lhs_p0, rhs_p0, rhs_lim,\n-                                  elt_llsz_r.val,\n-                                  bind inner(next, true, flag, op,\n-                                             _, _, _, elt_ty));\n-        }\n-\n-        r.bcx.build.Br(next.llbb);\n-        auto v = next.build.Load(flag);\n-        ret res(next, v);\n-\n-\n-    } else {\n-        // FIXME: compare obj, fn by pointer?\n-        cx.fcx.lcx.ccx.sess.unimpl(\"type in trans_compare\");\n-        ret res(cx, C_bool(false));\n-    }\n-}\n-\n-fn trans_scalar_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n-                        ValueRef lhs, ValueRef rhs) -> ValueRef {\n-    if (ty.type_is_fp(t)) {\n-        ret trans_fp_compare(cx, op, t, lhs, rhs);\n-    } else {\n-        ret trans_integral_compare(cx, op, t, lhs, rhs);\n-    }\n-}\n-\n-fn trans_fp_compare(@block_ctxt cx, ast.binop op, @ty.t fptype,\n-                    ValueRef lhs, ValueRef rhs) -> ValueRef {\n-\n-    auto cmp = lib.llvm.LLVMIntEQ;\n+    // Determine the operation we need.\n+    // FIXME: Use or-patterns when we have them.\n+    auto llop;\n     alt (op) {\n-        // FIXME: possibly use the unordered-or-< predicates here,\n-        // for now we're only going with ordered-and-< style (no NaNs).\n-        case (ast.eq) { cmp = lib.llvm.LLVMRealOEQ; }\n-        case (ast.ne) { cmp = lib.llvm.LLVMRealONE; }\n-        case (ast.lt) { cmp = lib.llvm.LLVMRealOLT; }\n-        case (ast.gt) { cmp = lib.llvm.LLVMRealOGT; }\n-        case (ast.le) { cmp = lib.llvm.LLVMRealOLE; }\n-        case (ast.ge) { cmp = lib.llvm.LLVMRealOGE; }\n+        case (ast.eq) { llop = C_i8(abi.cmp_glue_op_eq); }\n+        case (ast.lt) { llop = C_i8(abi.cmp_glue_op_lt); }\n+        case (ast.le) { llop = C_i8(abi.cmp_glue_op_le); }\n+        case (ast.ne) { llop = C_i8(abi.cmp_glue_op_eq); }\n+        case (ast.ge) { llop = C_i8(abi.cmp_glue_op_lt); }\n+        case (ast.gt) { llop = C_i8(abi.cmp_glue_op_le); }\n     }\n \n-    ret cx.build.FCmp(cmp, lhs, rhs);\n-}\n+    auto rslt = call_cmp_glue(cx, lhs, rhs, t, llop);\n \n-fn trans_integral_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n-                          ValueRef lhs, ValueRef rhs) -> ValueRef {\n-    auto cmp = lib.llvm.LLVMIntEQ;\n+    // Invert the result if necessary.\n+    // FIXME: Use or-patterns when we have them.\n     alt (op) {\n-        case (ast.eq) { cmp = lib.llvm.LLVMIntEQ; }\n-        case (ast.ne) { cmp = lib.llvm.LLVMIntNE; }\n-\n-        case (ast.lt) {\n-            if (ty.type_is_signed(intype)) {\n-                cmp = lib.llvm.LLVMIntSLT;\n-            } else {\n-                cmp = lib.llvm.LLVMIntULT;\n-            }\n-        }\n-        case (ast.le) {\n-            if (ty.type_is_signed(intype)) {\n-                cmp = lib.llvm.LLVMIntSLE;\n-            } else {\n-                cmp = lib.llvm.LLVMIntULE;\n-            }\n-        }\n-        case (ast.gt) {\n-            if (ty.type_is_signed(intype)) {\n-                cmp = lib.llvm.LLVMIntSGT;\n-            } else {\n-                cmp = lib.llvm.LLVMIntUGT;\n-            }\n-        }\n-        case (ast.ge) {\n-            if (ty.type_is_signed(intype)) {\n-                cmp = lib.llvm.LLVMIntSGE;\n-            } else {\n-                cmp = lib.llvm.LLVMIntUGE;\n-            }\n-        }\n+        case (ast.eq) { ret res(rslt.bcx, rslt.val);                     }\n+        case (ast.lt) { ret res(rslt.bcx, rslt.val);                     }\n+        case (ast.le) { ret res(rslt.bcx, rslt.val);                     }\n+        case (ast.ne) { ret res(rslt.bcx, rslt.bcx.build.Not(rslt.val)); }\n+        case (ast.ge) { ret res(rslt.bcx, rslt.bcx.build.Not(rslt.val)); }\n+        case (ast.gt) { ret res(rslt.bcx, rslt.bcx.build.Not(rslt.val)); }\n     }\n-    ret cx.build.ICmp(cmp, lhs, rhs);\n }\n \n fn trans_vec_append(@block_ctxt cx, @ty.t t,\n@@ -3678,7 +3802,7 @@ fn trans_alt(@block_ctxt cx, @ast.expr expr,\n     }\n \n     auto default_cx = this_cx;\n-    auto default_res = trans_fail(default_cx, expr.span,\n+    auto default_res = trans_fail(default_cx, some[common.span](expr.span),\n                                   \"non-exhaustive match failure\");\n \n     // FIXME: This isn't quite right, particularly re: dynamic types\n@@ -3976,7 +4100,8 @@ fn trans_index(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     bcx.build.CondBr(bounds_check, next_cx.llbb, fail_cx.llbb);\n \n     // fail: bad bounds check.\n-    auto fail_res = trans_fail(fail_cx, sp, \"bounds check\");\n+    auto fail_res = trans_fail(fail_cx, some[common.span](sp),\n+                               \"bounds check\");\n \n     auto body = next_cx.build.GEP(v, vec(C_int(0), C_int(abi.vec_elt_data)));\n     auto elt;\n@@ -4893,7 +5018,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n         }\n \n         case (ast.expr_fail(_)) {\n-            ret trans_fail(cx, e.span, \"explicit failure\");\n+            ret trans_fail(cx, some[common.span](e.span), \"explicit failure\");\n         }\n \n         case (ast.expr_log(?lvl, ?a, _)) {\n@@ -5062,7 +5187,7 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n \n     auto expr_str = pretty.pprust.expr_to_str(e);\n     auto fail_cx = new_sub_block_ctxt(cx, \"fail\");\n-    auto fail_res = trans_fail(fail_cx, e.span, expr_str);\n+    auto fail_res = trans_fail(fail_cx, some[common.span](e.span), expr_str);\n \n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n     cond_res.bcx.build.CondBr(cond_res.val,\n@@ -5071,11 +5196,23 @@ fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn trans_fail(@block_ctxt cx, common.span sp, str fail_str) -> result {\n+fn trans_fail(@block_ctxt cx, option.t[common.span] sp_opt, str fail_str)\n+        -> result {\n     auto V_fail_str = p2i(C_cstr(cx.fcx.lcx.ccx, fail_str));\n-    auto loc = cx.fcx.lcx.ccx.sess.lookup_pos(sp.lo);\n-    auto V_filename = p2i(C_cstr(cx.fcx.lcx.ccx, loc.filename));\n-    auto V_line = loc.line as int;\n+\n+    auto V_filename; auto V_line;\n+    alt (sp_opt) {\n+        case (some[common.span](?sp)) {\n+            auto loc = cx.fcx.lcx.ccx.sess.lookup_pos(sp.lo);\n+            V_filename = p2i(C_cstr(cx.fcx.lcx.ccx, loc.filename));\n+            V_line = loc.line as int;\n+        }\n+        case (none[common.span]) {\n+            V_filename = p2i(C_str(cx.fcx.lcx.ccx, \"<runtime>\"));\n+            V_line = 0;\n+        }\n+    }\n+\n     auto args = vec(V_fail_str, V_filename, C_int(V_line));\n \n     auto sub = trans_upcall(cx, \"upcall_fail\", args);"}, {"sha": "a25c00576c1db59f2f4b5c39a065161d98cc00e9", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "patch": "@@ -437,6 +437,13 @@ fn type_is_nil(@t ty) -> bool {\n     fail;\n }\n \n+fn type_is_bool(@t ty) -> bool {\n+    alt (ty.struct) {\n+        case (ty_bool) { ret true; }\n+        case (_) { ret false; }\n+    }\n+}\n+\n \n fn type_is_structural(@t ty) -> bool {\n     alt (ty.struct) {"}, {"sha": "e8bc4788c9a59e64a9f77fc95fb877043cb005fe", "filename": "src/test/run-pass/seq-compare.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Ftest%2Frun-pass%2Fseq-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fseq-compare.rs?ref=0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "patch": "@@ -13,4 +13,4 @@ fn main() {\n   check (vec(1,2,3,4) > vec(1,2,3));\n   check (vec(1,2,3) == vec(1,2,3));\n   check (vec(1,2,3) != vec(1,1,3));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3049faec6b6b817c151db132f8259a83bdbdb3e9", "filename": "src/test/run-pass/structured-compare-recursive.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ee997cee6dc6f71564e30b5c8f40749bf4cfc23/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstructured-compare-recursive.rs?ref=0ee997cee6dc6f71564e30b5c8f40749bf4cfc23", "patch": "@@ -0,0 +1,9 @@\n+tag taggy {\n+    foo(@taggy);\n+    bar;\n+}\n+\n+fn main() {\n+    check (bar <= bar);\n+}\n+"}]}