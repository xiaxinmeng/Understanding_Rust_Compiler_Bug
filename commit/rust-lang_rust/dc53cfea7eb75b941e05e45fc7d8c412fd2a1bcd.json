{"sha": "dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNTNjZmVhN2ViNzViOTQxZTA1ZTQ1ZmM3ZDhjNDEyZmQyYTFiY2Q=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-08-23T00:24:26Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-09-12T00:05:18Z"}, "message": "Add test cases and address review comments", "tree": {"sha": "716adf8059452e1e148ca7f5b3803c92acc3d5bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/716adf8059452e1e148ca7f5b3803c92acc3d5bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "html_url": "https://github.com/rust-lang/rust/commit/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d2a935e6cf25e0bc86354962929ee02513549b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2a935e6cf25e0bc86354962929ee02513549b7", "html_url": "https://github.com/rust-lang/rust/commit/5d2a935e6cf25e0bc86354962929ee02513549b7"}], "stats": {"total": 175, "additions": 156, "deletions": 19}, "files": [{"sha": "bcfcee23d13fee878ff5efe780f611cd8958b6d9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "patch": "@@ -617,14 +617,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 ref prior_arms,\n                 last_ty,\n                 scrut_hir_id,\n-                suggest_box,\n+                opt_suggest_box_span,\n                 arm_span,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n-                    if let Some(ret_sp) = suggest_box {\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n                         self.suggest_boxing_for_return_impl_trait(\n                             err,\n                             ret_sp,\n@@ -684,7 +684,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-                    if let Some(ret_sp) = suggest_box {\n+                    if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n                             err,\n@@ -699,7 +699,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 else_sp,\n                 outer,\n                 semicolon,\n-                suggest_box,\n+                opt_suggest_box_span,\n             }) => {\n                 err.span_label(then, \"expected because of this\");\n                 if let Some(sp) = outer {\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-                if let Some(ret_sp) = suggest_box {\n+                if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,\n                         ret_sp,"}, {"sha": "9db3b57a5c21e565af003382d797b02f008da833", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "patch": "@@ -350,7 +350,7 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n-    pub suggest_box: Option<Span>,\n+    pub opt_suggest_box_span: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -359,7 +359,7 @@ pub struct IfExpressionCause {\n     pub else_sp: Span,\n     pub outer: Option<Span>,\n     pub semicolon: Option<Span>,\n-    pub suggest_box: Option<Span>,\n+    pub opt_suggest_box_span: Option<Span>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]"}, {"sha": "08cf178c81390e1e17d47a2a07663ef57caeea28", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "patch": "@@ -119,13 +119,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n             // we check if the different arms would work with boxed trait objects instead and\n             // provide a structured suggestion in that case.\n-            let suggest_box = match (\n+            let opt_suggest_box_span = match (\n                 orig_expected,\n-                self.body_id\n-                    .owner\n-                    .to_def_id()\n-                    .as_local()\n-                    .and_then(|id| self.ret_coercion_impl_trait.map(|ty| (id, ty))),\n+                self.ret_coercion_impl_trait.map(|ty| (self.body_id.owner, ty)),\n             ) {\n                 (Expectation::ExpectHasType(expected), Some((id, ty)))\n                     if self.in_tail_expr && self.can_coerce(arm_ty, expected) =>\n@@ -181,7 +177,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             &arm.body,\n                             then_ty,\n                             arm_ty,\n-                            suggest_box,\n+                            opt_suggest_box_span,\n                         );\n                         coercion.coerce(self, &cause, &arm.body, arm_ty);\n                     }\n@@ -205,7 +201,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             prior_arms: other_arms.clone(),\n                             last_ty: prior_arm_ty.unwrap(),\n                             scrut_hir_id: scrut.hir_id,\n-                            suggest_box,\n+                            opt_suggest_box_span,\n                         }),\n                     ),\n                 };\n@@ -330,7 +326,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         else_expr: &'tcx hir::Expr<'tcx>,\n         then_ty: Ty<'tcx>,\n         else_ty: Ty<'tcx>,\n-        suggest_box: Option<Span>,\n+        opt_suggest_box_span: Option<Span>,\n     ) -> ObligationCause<'tcx> {\n         let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n             // The `if`/`else` isn't in one line in the output, include some context to make it\n@@ -421,7 +417,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 else_sp: error_sp,\n                 outer: outer_sp,\n                 semicolon: remove_semicolon,\n-                suggest_box,\n+                opt_suggest_box_span,\n             }),\n         )\n     }"}, {"sha": "fa7664a83eee073f7588794011a8f5f73f336117", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.rs?ref=dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "patch": "@@ -63,4 +63,39 @@ fn dog() -> impl std::fmt::Display {\n     }\n }\n \n+fn hat() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n+    match 13 {\n+        0 => {\n+            return 0i32;\n+        }\n+        _ => {\n+            1u32\n+        }\n+    }\n+}\n+\n+fn pug() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n+    match 13 {\n+        0 => 0i32,\n+        1 => 1u32, //~ ERROR `match` arms have incompatible types\n+        _ => 2u32,\n+    }\n+}\n+\n+fn man() -> dyn std::fmt::Display { //~ ERROR return type cannot have an unboxed trait object\n+    if false {\n+        0i32\n+    } else {\n+        1u32 //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn apt() -> impl std::fmt::Display {\n+    if let Some(42) = Some(42) {\n+        0i32\n+    } else {\n+        1u32 //~ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n fn main() {}"}, {"sha": "eb4dc45c8a9320e136428e8b6699a3e560de9ef9", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 108, "deletions": 2, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=dc53cfea7eb75b941e05e45fc7d8c412fd2a1bcd", "patch": "@@ -207,6 +207,112 @@ LL |         0 => Box::new(0i32),\n LL |         1 => Box::new(1u32),\n    |\n \n-error: aborting due to 8 previous errors\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:97:9\n+   |\n+LL | /     if let Some(42) = Some(42) {\n+LL | |         0i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         1u32\n+   | |         ^^^^ expected `i32`, found `u32`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+help: you could change the return type to be a boxed trait object\n+   |\n+LL | fn apt() -> Box<dyn std::fmt::Display> {\n+   |             ^^^^^^^                  ^\n+help: if you change the return type to expect trait objects, box the returned expressions\n+   |\n+LL |         Box::new(0i32)\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:66:13\n+   |\n+LL | fn hat() -> dyn std::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn hat() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL |         0 => {\n+LL |             return Box::new(0i32);\n+LL |         }\n+LL |         _ => {\n+ ...\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:80:14\n+   |\n+LL | /     match 13 {\n+LL | |         0 => 0i32,\n+   | |              ---- this is found to be of type `i32`\n+LL | |         1 => 1u32,\n+   | |              ^^^^ expected `i32`, found `u32`\n+LL | |         _ => 2u32,\n+LL | |     }\n+   | |_____- `match` arms have incompatible types\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:77:13\n+   |\n+LL | fn pug() -> dyn std::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn pug() -> Box<dyn std::fmt::Display> {\n+LL |     match 13 {\n+LL |         0 => Box::new(0i32),\n+LL |         1 => Box::new(1u32),\n+LL |         _ => Box::new(2u32),\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:89:9\n+   |\n+LL | /     if false {\n+LL | |         0i32\n+   | |         ---- expected because of this\n+LL | |     } else {\n+LL | |         1u32\n+   | |         ^^^^ expected `i32`, found `u32`\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:85:13\n+   |\n+LL | fn man() -> dyn std::fmt::Display {\n+   |             ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl std::fmt::Display` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn man() -> Box<dyn std::fmt::Display> {\n+LL |     if false {\n+LL |         Box::new(0i32)\n+LL |     } else {\n+LL |         Box::new(1u32)\n+   |\n+\n+error: aborting due to 14 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0308, E0746.\n+For more information about an error, try `rustc --explain E0308`."}]}