{"sha": "bdd70622e2a721b8b384df103e8514372fef1150", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDcwNjIyZTJhNzIxYjhiMzg0ZGYxMDNlODUxNDM3MmZlZjExNTA=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-05-30T19:06:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-30T19:06:44Z"}, "message": "Rollup merge of #85709 - Aaron1011:fix-pat-crate-edition, r=petrochenkov\n\nUse correct edition when parsing `:pat` matchers\n\nAs described in issue #85708, we currently do not properly decode\n`SyntaxContext::root()` and `ExpnId::root()` from foreign crates. As a\nresult, when we decode a span from a foreign crate with\n`SyntaxContext::root()`, we end up up considering it to have the edition\nof the *current* crate, instead of the foreign crate where it was\noriginally created.\n\nA full fix for this issue will be a fairly significant undertaking.\nFortunately, it's possible to implement a partial fix, which gives us\nthe correct edition-dependent behavior for `:pat` matchers when the\nmacro is loaded from another crate. Since we have the edition of the\nmacro's defining crate available, we can 'recover' from seeing a\n`SyntaxContext::root()` and use the edition of the macro's defining\ncrate.\n\nAny solution to issue #85708 must reproduce the behavior of this\ntargeted fix - properly preserving a foreign `SyntaxContext::root()`\nmeans (among other things) preserving its edition, which by definition\nis the edition of the foreign crate itself. Therefore, this fix moves us\ncloser to the correct overall solution, and does not expose any new\nincorrect behavior to macros.", "tree": {"sha": "79715300d98d178607204fa407c244bc56e7435e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79715300d98d178607204fa407c244bc56e7435e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd70622e2a721b8b384df103e8514372fef1150", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgs+JECRBK7hj4Ov3rIwAAUusIAAcXzeaKSBQJmD2oSkiTnnPP\niQQPD5zKzP3posVCOcD+/8lheEHDsq1rtuAizLPqxXOl94XeqJMsCKMHjdPCbLow\nrTSYIyPHQAbU74qfbG9jPwYJalHGjbAI+3oFk7vq2fBtuuDf40nUPulECxwmhI2p\nIqagUyFZ8tFtqLLayzThTs/XOtLYf4eKYF3OiSAZC97sHd7w+Jhpt6Cp7u0ryx8a\n3qH0Djx2bDduo6XLnQjsfMSBvxjRLYM690BR1CAlT+qMuafCWgNpF8uUeZGRWjat\nHDgk+McSolJqtUXt4NeN21wUkXqjNxK6Ou9aOUbtD3RXZBnIGAIECCtBeDZDz7Q=\n=oJ6i\n-----END PGP SIGNATURE-----\n", "payload": "tree 79715300d98d178607204fa407c244bc56e7435e\nparent 9c873c1240c0b4f7e7a26e9b01a4591cc2b6bb0f\nparent d874ecc84f84cb4b3e1675c560759bb5deccf8d2\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1622401604 +0200\ncommitter GitHub <noreply@github.com> 1622401604 +0200\n\nRollup merge of #85709 - Aaron1011:fix-pat-crate-edition, r=petrochenkov\n\nUse correct edition when parsing `:pat` matchers\n\nAs described in issue #85708, we currently do not properly decode\n`SyntaxContext::root()` and `ExpnId::root()` from foreign crates. As a\nresult, when we decode a span from a foreign crate with\n`SyntaxContext::root()`, we end up up considering it to have the edition\nof the *current* crate, instead of the foreign crate where it was\noriginally created.\n\nA full fix for this issue will be a fairly significant undertaking.\nFortunately, it's possible to implement a partial fix, which gives us\nthe correct edition-dependent behavior for `:pat` matchers when the\nmacro is loaded from another crate. Since we have the edition of the\nmacro's defining crate available, we can 'recover' from seeing a\n`SyntaxContext::root()` and use the edition of the macro's defining\ncrate.\n\nAny solution to issue #85708 must reproduce the behavior of this\ntargeted fix - properly preserving a foreign `SyntaxContext::root()`\nmeans (among other things) preserving its edition, which by definition\nis the edition of the foreign crate itself. Therefore, this fix moves us\ncloser to the correct overall solution, and does not expose any new\nincorrect behavior to macros.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd70622e2a721b8b384df103e8514372fef1150", "html_url": "https://github.com/rust-lang/rust/commit/bdd70622e2a721b8b384df103e8514372fef1150", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd70622e2a721b8b384df103e8514372fef1150/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c873c1240c0b4f7e7a26e9b01a4591cc2b6bb0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c873c1240c0b4f7e7a26e9b01a4591cc2b6bb0f", "html_url": "https://github.com/rust-lang/rust/commit/9c873c1240c0b4f7e7a26e9b01a4591cc2b6bb0f"}, {"sha": "d874ecc84f84cb4b3e1675c560759bb5deccf8d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d874ecc84f84cb4b3e1675c560759bb5deccf8d2", "html_url": "https://github.com/rust-lang/rust/commit/d874ecc84f84cb4b3e1675c560759bb5deccf8d2"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "6608573d720a84a9fb2a558c5925185d4d566bbd", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdd70622e2a721b8b384df103e8514372fef1150/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd70622e2a721b8b384df103e8514372fef1150/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=bdd70622e2a721b8b384df103e8514372fef1150", "patch": "@@ -467,6 +467,7 @@ pub fn compile_declarative_macro(\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n+                            edition,\n                         )\n                         .pop()\n                         .unwrap();\n@@ -492,6 +493,7 @@ pub fn compile_declarative_macro(\n                             &sess.parse_sess,\n                             def.id,\n                             features,\n+                            edition,\n                         )\n                         .pop()\n                         .unwrap();"}, {"sha": "fb7479eafc86f5e155640393e1efd8891f4c5873", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bdd70622e2a721b8b384df103e8514372fef1150/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd70622e2a721b8b384df103e8514372fef1150/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=bdd70622e2a721b8b384df103e8514372fef1150", "patch": "@@ -9,7 +9,8 @@ use rustc_feature::Features;\n use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{kw, Ident};\n \n-use rustc_span::Span;\n+use rustc_span::edition::Edition;\n+use rustc_span::{Span, SyntaxContext};\n \n use rustc_data_structures::sync::Lrc;\n \n@@ -32,6 +33,7 @@ const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `node_id`: the NodeId of the macro we are parsing.\n /// - `features`: language features so we can do feature gating.\n+/// - `edition`: the edition of the crate defining the macro\n ///\n /// # Returns\n ///\n@@ -42,6 +44,7 @@ pub(super) fn parse(\n     sess: &ParseSess,\n     node_id: NodeId,\n     features: &Features,\n+    edition: Edition,\n ) -> Vec<TokenTree> {\n     // Will contain the final collection of `self::TokenTree`\n     let mut result = Vec::new();\n@@ -52,7 +55,7 @@ pub(super) fn parse(\n     while let Some(tree) = trees.next() {\n         // Given the parsed tree, if there is a metavar and we are expecting matchers, actually\n         // parse out the matcher (i.e., in `$id:ident` this would parse the `:` and `ident`).\n-        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features);\n+        let tree = parse_tree(tree, &mut trees, expect_matchers, sess, node_id, features, edition);\n         match tree {\n             TokenTree::MetaVar(start_sp, ident) if expect_matchers => {\n                 let span = match trees.next() {\n@@ -64,7 +67,19 @@ pub(super) fn parse(\n \n                                     let kind =\n                                         token::NonterminalKind::from_symbol(frag.name, || {\n-                                            span.edition()\n+                                            // FIXME(#85708) - once we properly decode a foreign\n+                                            // crate's `SyntaxContext::root`, then we can replace\n+                                            // this with just `span.edition()`. A\n+                                            // `SyntaxContext::root()` from the current crate will\n+                                            // have the edition of the current crate, and a\n+                                            // `SyntaxxContext::root()` from a foreign crate will\n+                                            // have the edition of that crate (which we manually\n+                                            // retrieve via the `edition` parameter).\n+                                            if span.ctxt() == SyntaxContext::root() {\n+                                                edition\n+                                            } else {\n+                                                span.edition()\n+                                            }\n                                         })\n                                         .unwrap_or_else(\n                                             || {\n@@ -117,13 +132,15 @@ pub(super) fn parse(\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`: language features so we can do feature gating.\n+/// - `edition` - the edition of the crate defining the macro\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n     outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n     features: &Features,\n+    edition: Edition,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n@@ -151,7 +168,7 @@ fn parse_tree(\n                         sess.span_diagnostic.span_err(span.entire(), &msg);\n                     }\n                     // Parse the contents of the sequence itself\n-                    let sequence = parse(tts, expect_matchers, sess, node_id, features);\n+                    let sequence = parse(tts, expect_matchers, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n@@ -204,7 +221,7 @@ fn parse_tree(\n             span,\n             Lrc::new(Delimited {\n                 delim,\n-                tts: parse(tts, expect_matchers, sess, node_id, features),\n+                tts: parse(tts, expect_matchers, sess, node_id, features, edition),\n             }),\n         ),\n     }"}, {"sha": "26d4c96d52433c296a823aadbf5c5614542b3abe", "filename": "src/test/ui/macros/auxiliary/foreign-crate-macro-pat.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bdd70622e2a721b8b384df103e8514372fef1150/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fforeign-crate-macro-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd70622e2a721b8b384df103e8514372fef1150/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fforeign-crate-macro-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fauxiliary%2Fforeign-crate-macro-pat.rs?ref=bdd70622e2a721b8b384df103e8514372fef1150", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+\n+#[macro_export]\n+macro_rules! custom_matches {\n+    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )? $(,)?) => {\n+        match $expression {\n+            $( $pattern )|+ $( if $guard )? => true,\n+            _ => false\n+        }\n+    }\n+}"}, {"sha": "ed67142ce3de2b20fd9af49a2630e7b89350dfe4", "filename": "src/test/ui/macros/cross-crate-pat-span.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdd70622e2a721b8b384df103e8514372fef1150/src%2Ftest%2Fui%2Fmacros%2Fcross-crate-pat-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd70622e2a721b8b384df103e8514372fef1150/src%2Ftest%2Fui%2Fmacros%2Fcross-crate-pat-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fcross-crate-pat-span.rs?ref=bdd70622e2a721b8b384df103e8514372fef1150", "patch": "@@ -0,0 +1,12 @@\n+// edition:2021\n+// check-pass\n+// aux-build: foreign-crate-macro-pat.rs\n+//\n+// Tests that the edition of the foreign crate is used\n+// when determining the behavior of the `:pat` matcher.\n+\n+extern crate foreign_crate_macro_pat;\n+\n+fn main() {\n+    let _b = foreign_crate_macro_pat::custom_matches!(b'3', b'0' ..= b'9');\n+}"}, {"sha": "53f134c265fd75c2b6615f574875894b163153ef", "filename": "src/test/ui/macros/issue-84429-matches-edition.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bdd70622e2a721b8b384df103e8514372fef1150/src%2Ftest%2Fui%2Fmacros%2Fissue-84429-matches-edition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd70622e2a721b8b384df103e8514372fef1150/src%2Ftest%2Fui%2Fmacros%2Fissue-84429-matches-edition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-84429-matches-edition.rs?ref=bdd70622e2a721b8b384df103e8514372fef1150", "patch": "@@ -0,0 +1,9 @@\n+// edition:2021\n+// check-pass\n+//\n+// Regression test for issue #84429\n+// Tests that we can properly invoke `matches!` from a 2021-edition crate.\n+\n+fn main() {\n+    let _b = matches!(b'3', b'0' ..= b'9');\n+}"}]}