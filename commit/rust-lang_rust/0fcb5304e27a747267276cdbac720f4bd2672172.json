{"sha": "0fcb5304e27a747267276cdbac720f4bd2672172", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmY2I1MzA0ZTI3YTc0NzI2NzI3NmNkYmFjNzIwZjRiZDI2NzIxNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T12:46:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-27T12:46:42Z"}, "message": "Auto merge of #4962 - JohnTitor:rustup-1227, r=matthiaskrgr\n\nRustup to rust-lang/rust#66936\n\nchangelog: none", "tree": {"sha": "6db1d892d4187d4bea58d8ecc783fe594c2eefca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6db1d892d4187d4bea58d8ecc783fe594c2eefca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fcb5304e27a747267276cdbac720f4bd2672172", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fcb5304e27a747267276cdbac720f4bd2672172", "html_url": "https://github.com/rust-lang/rust/commit/0fcb5304e27a747267276cdbac720f4bd2672172", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fcb5304e27a747267276cdbac720f4bd2672172/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0c4744d57365e051ba3480dc0eed2540735097e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0c4744d57365e051ba3480dc0eed2540735097e", "html_url": "https://github.com/rust-lang/rust/commit/b0c4744d57365e051ba3480dc0eed2540735097e"}, {"sha": "e2636729ec6f1c9ba4e071699488d1089756c7c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2636729ec6f1c9ba4e071699488d1089756c7c6", "html_url": "https://github.com/rust-lang/rust/commit/e2636729ec6f1c9ba4e071699488d1089756c7c6"}], "stats": {"total": 1390, "additions": 735, "deletions": 655}, "files": [{"sha": "68582ecddf75b1e9dce6339439babd0e4da82308", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -60,14 +60,14 @@ const KNOWN_CONSTS: [(f64, &str, usize); 16] = [\n declare_lint_pass!(ApproxConstant => [APPROX_CONSTANT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ApproxConstant {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Lit(lit) = &e.kind {\n             check_lit(cx, &lit.node, e);\n         }\n     }\n }\n \n-fn check_lit(cx: &LateContext<'_, '_>, lit: &LitKind, e: &Expr) {\n+fn check_lit(cx: &LateContext<'_, '_>, lit: &LitKind, e: &Expr<'_>) {\n     match *lit {\n         LitKind::Float(s, LitFloatType::Suffixed(fty)) => match fty {\n             FloatTy::F32 => check_known_consts(cx, e, s, \"f32\"),\n@@ -78,7 +78,7 @@ fn check_lit(cx: &LateContext<'_, '_>, lit: &LitKind, e: &Expr) {\n     }\n }\n \n-fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr, s: symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext<'_, '_>, e: &Expr<'_>, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in &KNOWN_CONSTS {"}, {"sha": "cff9a590e12180ecd01e8f4261ddaa868fe41df0", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -54,7 +54,7 @@ pub struct Arithmetic {\n impl_lint_pass!(Arithmetic => [INTEGER_ARITHMETIC, FLOAT_ARITHMETIC]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if self.expr_span.is_some() {\n             return;\n         }\n@@ -107,7 +107,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if Some(expr.span) == self.expr_span {\n             self.expr_span = None;\n         }"}, {"sha": "6c24ccfc32319bde3df2e3dff3c0e7aab407bd29", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -33,7 +33,7 @@ declare_clippy_lint! {\n declare_lint_pass!(AssertionsOnConstants => [ASSERTIONS_ON_CONSTANTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssertionsOnConstants {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         let lint_true = || {\n             span_help_and_lint(\n                 cx,\n@@ -110,7 +110,7 @@ enum AssertKind {\n /// ```\n ///\n /// where `message` is any expression and `c` is a constant bool.\n-fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<AssertKind> {\n+fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n         if let ExprKind::Match(ref expr, ref arms, _) = expr.kind;\n         // matches { let _t = expr; _t }\n@@ -124,7 +124,7 @@ fn match_assert_with_message<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx E\n         if let LitKind::Bool(true) = lit.node;\n         // arm 1 block\n         if let ExprKind::Block(ref block, _) = arms[0].body.kind;\n-        if block.stmts.len() == 0;\n+        if block.stmts.is_empty();\n         if let Some(block_expr) = &block.expr;\n         if let ExprKind::Block(ref inner_block, _) = block_expr.kind;\n         if let Some(begin_panic_call) = &inner_block.expr;"}, {"sha": "5fd6e7ffd59f78308b1ec08600dde941d9e84c2c", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -59,7 +59,7 @@ declare_lint_pass!(AssignOps => [ASSIGN_OP_PATTERN, MISREFACTORED_ASSIGN_OP]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n     #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         match &expr.kind {\n             hir::ExprKind::AssignOp(op, lhs, rhs) => {\n                 if let hir::ExprKind::Binary(binop, l, r) = &rhs.kind {\n@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n             hir::ExprKind::Assign(assignee, e, _) => {\n                 if let hir::ExprKind::Binary(op, l, r) = &e.kind {\n                     #[allow(clippy::cognitive_complexity)]\n-                    let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n+                    let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n                         let ty = cx.tables.expr_ty(assignee);\n                         let rty = cx.tables.expr_ty(rhs);\n                         macro_rules! ops {\n@@ -190,11 +190,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n \n fn lint_misrefactored_assign_op(\n     cx: &LateContext<'_, '_>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     op: hir::BinOp,\n-    rhs: &hir::Expr,\n-    assignee: &hir::Expr,\n-    rhs_other: &hir::Expr,\n+    rhs: &hir::Expr<'_>,\n+    assignee: &hir::Expr<'_>,\n+    rhs_other: &hir::Expr<'_>,\n ) {\n     span_lint_and_then(\n         cx,\n@@ -240,13 +240,13 @@ fn is_commutative(op: hir::BinOpKind) -> bool {\n }\n \n struct ExprVisitor<'a, 'tcx> {\n-    assignee: &'a hir::Expr,\n+    assignee: &'a hir::Expr<'a>,\n     counter: u8,\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         if SpanlessEq::new(self.cx).ignore_fn().eq_expr(self.assignee, expr) {\n             self.counter += 1;\n         }"}, {"sha": "7b41acf392ecb7c4053de4ecb3c09179c88878c1", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -380,7 +380,7 @@ fn is_relevant_trait(cx: &LateContext<'_, '_>, item: &TraitItem<'_>) -> bool {\n     }\n }\n \n-fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, block: &Block) -> bool {\n+fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n     if let Some(stmt) = block.stmts.first() {\n         match &stmt.kind {\n             StmtKind::Local(_) => true,\n@@ -392,7 +392,7 @@ fn is_relevant_block(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, bl\n     }\n }\n \n-fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr) -> bool {\n+fn is_relevant_expr(cx: &LateContext<'_, '_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Block(block, _) => is_relevant_block(cx, tables, block),\n         ExprKind::Ret(Some(e)) => is_relevant_expr(cx, tables, e),"}, {"sha": "0d8329c65918c615acaaf1f674992e1fff6689bb", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -112,7 +112,7 @@ impl BitMask {\n impl_lint_pass!(BitMask => [BAD_BIT_MASK, INEFFECTIVE_BIT_MASK, VERBOSE_BIT_MASK]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(cmp, left, right) = &e.kind {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n@@ -165,7 +165,7 @@ fn invert_cmp(cmp: BinOpKind) -> BinOpKind {\n     }\n }\n \n-fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n+fn check_compare(cx: &LateContext<'_, '_>, bit_op: &Expr<'_>, cmp_op: BinOpKind, cmp_value: u128, span: Span) {\n     if let ExprKind::Binary(op, left, right) = &bit_op.kind {\n         if op.node != BinOpKind::BitAnd && op.node != BinOpKind::BitOr {\n             return;\n@@ -319,7 +319,7 @@ fn check_ineffective_gt(cx: &LateContext<'_, '_>, span: Span, m: u128, c: u128,\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr) -> Option<u128> {\n+fn fetch_int_literal(cx: &LateContext<'_, '_>, lit: &Expr<'_>) -> Option<u128> {\n     match constant(cx, cx.tables, lit)?.0 {\n         Constant::Int(n) => Some(n),\n         _ => None,"}, {"sha": "c3ea889cfa9a6acf740971bee770ee4c509e9a00", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -37,7 +37,7 @@ impl BlacklistedName {\n impl_lint_pass!(BlacklistedName => [BLACKLISTED_NAME]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlacklistedName {\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n         if let PatKind::Binding(.., ident, _) = pat.kind {\n             if self.blacklist.contains(&ident.name.to_string()) {\n                 span_lint("}, {"sha": "18b1503915626a459093d2933011ac09dc12ec77", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -46,12 +46,12 @@ declare_clippy_lint! {\n declare_lint_pass!(BlockInIfCondition => [BLOCK_IN_IF_CONDITION_EXPR, BLOCK_IN_IF_CONDITION_STMT]);\n \n struct ExVisitor<'a, 'tcx> {\n-    found_block: Option<&'tcx Expr>,\n+    found_block: Option<&'tcx Expr<'tcx>>,\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         if let ExprKind::Closure(_, _, eid, _, _) = expr.kind {\n             let body = self.cx.tcx.hir().body(eid);\n             let ex = &body.value;\n@@ -72,7 +72,7 @@ const COMPLEX_BLOCK_MESSAGE: &str = \"in an 'if' condition, avoid complex blocks\n                                      instead, move the block or closure higher and bind it with a 'let'\";\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }"}, {"sha": "d63dca2cac7d082db09116a0df6afeb2e741440c", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -75,12 +75,12 @@ struct NonminimalBoolVisitor<'a, 'tcx> {\n \n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx, 'v> {\n-    terminals: Vec<&'v Expr>,\n+    terminals: Vec<&'v Expr<'v>>,\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n-    fn extract(&mut self, op: BinOpKind, a: &[&'v Expr], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n+    fn extract(&mut self, op: BinOpKind, a: &[&'v Expr<'_>], mut v: Vec<Bool>) -> Result<Vec<Bool>, String> {\n         for a in a {\n             if let ExprKind::Binary(binop, lhs, rhs) = &a.kind {\n                 if binop.node == op {\n@@ -93,7 +93,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n         Ok(v)\n     }\n \n-    fn run(&mut self, e: &'v Expr) -> Result<Bool, String> {\n+    fn run(&mut self, e: &'v Expr<'_>) -> Result<Bool, String> {\n         fn negate(bin_op_kind: BinOpKind) -> Option<BinOpKind> {\n             match bin_op_kind {\n                 BinOpKind::Eq => Some(BinOpKind::Ne),\n@@ -154,7 +154,7 @@ impl<'a, 'tcx, 'v> Hir2Qmm<'a, 'tcx, 'v> {\n }\n \n struct SuggestContext<'a, 'tcx, 'v> {\n-    terminals: &'v [&'v Expr],\n+    terminals: &'v [&'v Expr<'v>],\n     cx: &'a LateContext<'a, 'tcx>,\n     output: String,\n }\n@@ -222,7 +222,7 @@ impl<'a, 'tcx, 'v> SuggestContext<'a, 'tcx, 'v> {\n     }\n }\n \n-fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<String> {\n+fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n     match &expr.kind {\n         ExprKind::Binary(binop, lhs, rhs) => {\n             if !implements_ord(cx, lhs) {\n@@ -266,7 +266,7 @@ fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<String> {\n     }\n }\n \n-fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr]) -> String {\n+fn suggest(cx: &LateContext<'_, '_>, suggestion: &Bool, terminals: &[&Expr<'_>]) -> String {\n     let mut suggest_context = SuggestContext {\n         terminals,\n         cx,\n@@ -332,7 +332,7 @@ fn terminal_stats(b: &Bool) -> Stats {\n }\n \n impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n-    fn bool_expr(&self, e: &'tcx Expr) {\n+    fn bool_expr(&self, e: &'tcx Expr<'_>) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n             cx: self.cx,\n@@ -437,7 +437,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'tcx Expr) {\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         if in_macro(e.span) {\n             return;\n         }\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n     }\n }\n \n-fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr) -> bool {\n+fn implements_ord<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n     get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n@@ -470,7 +470,7 @@ struct NotSimplificationVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for NotSimplificationVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Unary(UnNot, inner) = &expr.kind {\n             if let Some(suggestion) = simplify_not(self.cx, inner) {\n                 span_lint_and_sugg("}, {"sha": "9a0e56240f11c59b08b2e4aaf6eb11fe056f548f", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -36,7 +36,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.kind;\n             if count.ident.name == sym!(count);\n@@ -96,11 +96,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     }\n }\n \n-fn check_arg(name: Name, arg: Name, needle: &Expr) -> bool {\n+fn check_arg(name: Name, arg: Name, needle: &Expr<'_>) -> bool {\n     name == arg && !contains_name(name, needle)\n }\n \n-fn get_path_name(expr: &Expr) -> Option<Name> {\n+fn get_path_name(expr: &Expr<'_>) -> Option<Name> {\n     match expr.kind {\n         ExprKind::Box(ref e) | ExprKind::AddrOf(BorrowKind::Ref, _, ref e) | ExprKind::Unary(UnOp::UnDeref, ref e) => {\n             get_path_name(e)"}, {"sha": "af07cbea46f16725a3bda03fef2cb7d1f2d1a898", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr<'_>) {\n         let result = if_chain! {\n             if !in_external_macro(cx.sess(), item.span);\n             if let ExprKind::Binary(op, ref left, ref right) = &item.kind;\n@@ -84,12 +84,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n \n /// Searches for a single check from unsigned to _ is done\n /// todo: check for case signed -> larger unsigned == only x >= 0\n-fn single_check(expr: &Expr) -> Option<Conversion<'_>> {\n+fn single_check<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     check_upper_bound(expr).filter(|cv| cv.cvt == ConversionType::FromUnsigned)\n }\n \n /// Searches for a combination of upper & lower bound checks\n-fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr, right: &'a Expr) -> Option<Conversion<'a>> {\n+fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr<'_>, right: &'a Expr<'_>) -> Option<Conversion<'a>> {\n     let upper_lower = |l, r| {\n         let upper = check_upper_bound(l);\n         let lower = check_lower_bound(r);\n@@ -104,7 +104,7 @@ fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr, right: &'a Expr) -\n #[derive(Clone, Debug)]\n struct Conversion<'a> {\n     cvt: ConversionType,\n-    expr_to_cast: &'a Expr,\n+    expr_to_cast: &'a Expr<'a>,\n     to_type: Option<&'a str>,\n }\n \n@@ -141,7 +141,7 @@ impl<'a> Conversion<'a> {\n     }\n \n     /// Try to construct a new conversion if the conversion type is valid\n-    fn try_new(expr_to_cast: &'a Expr, from_type: &str, to_type: &'a str) -> Option<Conversion<'a>> {\n+    fn try_new(expr_to_cast: &'a Expr<'_>, from_type: &str, to_type: &'a str) -> Option<Conversion<'a>> {\n         ConversionType::try_new(from_type, to_type).map(|cvt| Conversion {\n             cvt,\n             expr_to_cast,\n@@ -150,7 +150,7 @@ impl<'a> Conversion<'a> {\n     }\n \n     /// Construct a new conversion without type constraint\n-    fn new_any(expr_to_cast: &'a Expr) -> Conversion<'a> {\n+    fn new_any(expr_to_cast: &'a Expr<'_>) -> Conversion<'a> {\n         Conversion {\n             cvt: ConversionType::SignedToUnsigned,\n             expr_to_cast,\n@@ -180,7 +180,7 @@ impl ConversionType {\n }\n \n /// Check for `expr <= (to_type::max_value() as from_type)`\n-fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n+fn check_upper_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n     if_chain! {\n          if let ExprKind::Binary(ref op, ref left, ref right) = &expr.kind;\n          if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n@@ -195,8 +195,8 @@ fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n }\n \n /// Check for `expr >= 0|(to_type::min_value() as from_type)`\n-fn check_lower_bound(expr: &Expr) -> Option<Conversion<'_>> {\n-    fn check_function<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+fn check_lower_bound<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<Conversion<'tcx>> {\n+    fn check_function<'a>(candidate: &'a Expr<'a>, check: &'a Expr<'a>) -> Option<Conversion<'a>> {\n         (check_lower_bound_zero(candidate, check)).or_else(|| (check_lower_bound_min(candidate, check)))\n     }\n \n@@ -209,7 +209,7 @@ fn check_lower_bound(expr: &Expr) -> Option<Conversion<'_>> {\n }\n \n /// Check for `expr >= 0`\n-fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+fn check_lower_bound_zero<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = &check.kind;\n         if let LitKind::Int(0, _) = &lit.node;\n@@ -223,7 +223,7 @@ fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Co\n }\n \n /// Check for `expr >= (to_type::min_value() as from_type)`\n-fn check_lower_bound_min<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+fn check_lower_bound_min<'a>(candidate: &'a Expr<'_>, check: &'a Expr<'_>) -> Option<Conversion<'a>> {\n     if let Some((from, to)) = get_types_from_cast(check, MIN_VALUE, SINTS) {\n         Conversion::try_new(candidate, from, to)\n     } else {\n@@ -232,9 +232,9 @@ fn check_lower_bound_min<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Con\n }\n \n /// Tries to extract the from- and to-type from a cast expression\n-fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) -> Option<(&'a str, &'a str)> {\n+fn get_types_from_cast<'a>(expr: &'a Expr<'_>, func: &'a str, types: &'a [&str]) -> Option<(&'a str, &'a str)> {\n     // `to_type::maxmin_value() as from_type`\n-    let call_from_cast: Option<(&Expr, &str)> = if_chain! {\n+    let call_from_cast: Option<(&Expr<'_>, &str)> = if_chain! {\n         // to_type::maxmin_value(), from_type\n         if let ExprKind::Cast(ref limit, ref from_type) = &expr.kind;\n         if let TyKind::Path(ref from_type_path) = &from_type.kind;\n@@ -248,7 +248,7 @@ fn get_types_from_cast<'a>(expr: &'a Expr, func: &'a str, types: &'a [&str]) ->\n     };\n \n     // `from_type::from(to_type::maxmin_value())`\n-    let limit_from: Option<(&Expr, &str)> = call_from_cast.or_else(|| {\n+    let limit_from: Option<(&Expr<'_>, &str)> = call_from_cast.or_else(|| {\n         if_chain! {\n             // `from_type::from, to_type::maxmin_value()`\n             if let ExprKind::Call(ref from_func, ref args) = &expr.kind;\n@@ -327,7 +327,7 @@ fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n }\n \n /// Will return the expressions as if they were expr1 <= expr2\n-fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr, right: &'a Expr) -> Option<(&'a Expr, &'a Expr)> {\n+fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr<'a>, right: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     match op.node {\n         BinOpKind::Le => Some((left, right)),\n         BinOpKind::Ge => Some((right, left)),"}, {"sha": "37c1283db8dcdff2af1150180acb2167244f174a", "filename": "clippy_lints/src/cognitive_complexity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fcognitive_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcognitive_complexity.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -141,7 +141,7 @@ struct CCHelper {\n }\n \n impl<'tcx> Visitor<'tcx> for CCHelper {\n-    fn visit_expr(&mut self, e: &'tcx Expr) {\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         walk_expr(self, e);\n         match e.kind {\n             ExprKind::Match(_, ref arms, _) => {"}, {"sha": "0ee8bb1992959985cc0cacdbc490c0a1dce6d646", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -54,7 +54,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ComparisonChain => [COMPARISON_CHAIN]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ComparisonChain {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }"}, {"sha": "29a087bba1137fb538449f207161f17f685c66cb", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -178,7 +178,7 @@ pub fn lit_to_constant(lit: &LitKind, ty: Option<Ty<'_>>) -> Constant {\n pub fn constant<'c, 'cc>(\n     lcx: &LateContext<'c, 'cc>,\n     tables: &'c ty::TypeckTables<'cc>,\n-    e: &Expr,\n+    e: &Expr<'_>,\n ) -> Option<(Constant, bool)> {\n     let mut cx = ConstEvalLateContext {\n         lcx,\n@@ -193,7 +193,7 @@ pub fn constant<'c, 'cc>(\n pub fn constant_simple<'c, 'cc>(\n     lcx: &LateContext<'c, 'cc>,\n     tables: &'c ty::TypeckTables<'cc>,\n-    e: &Expr,\n+    e: &Expr<'_>,\n ) -> Option<Constant> {\n     constant(lcx, tables, e).and_then(|(cst, res)| if res { None } else { Some(cst) })\n }\n@@ -222,7 +222,7 @@ pub struct ConstEvalLateContext<'a, 'tcx> {\n \n impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// Simple constant folding: Insert an expression, get a constant or none.\n-    pub fn expr(&mut self, e: &Expr) -> Option<Constant> {\n+    pub fn expr(&mut self, e: &Expr<'_>) -> Option<Constant> {\n         if let Some((ref cond, ref then, otherwise)) = higher::if_block(&e) {\n             return self.ifthenelse(cond, then, otherwise);\n         }\n@@ -315,7 +315,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n \n     /// Create `Some(Vec![..])` of all constants, unless there is any\n     /// non-constant part.\n-    fn multi(&mut self, vec: &[Expr]) -> Option<Vec<Constant>> {\n+    fn multi(&mut self, vec: &[Expr<'_>]) -> Option<Vec<Constant>> {\n         vec.iter().map(|elem| self.expr(elem)).collect::<Option<_>>()\n     }\n \n@@ -348,15 +348,15 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     /// A block can only yield a constant if it only has one constant expression.\n-    fn block(&mut self, block: &Block) -> Option<Constant> {\n+    fn block(&mut self, block: &Block<'_>) -> Option<Constant> {\n         if block.stmts.is_empty() {\n             block.expr.as_ref().and_then(|b| self.expr(b))\n         } else {\n             None\n         }\n     }\n \n-    fn ifthenelse(&mut self, cond: &Expr, then: &Expr, otherwise: Option<&Expr>) -> Option<Constant> {\n+    fn ifthenelse(&mut self, cond: &Expr<'_>, then: &Expr<'_>, otherwise: Option<&Expr<'_>>) -> Option<Constant> {\n         if let Some(Constant::Bool(b)) = self.expr(cond) {\n             if b {\n                 self.expr(&*then)\n@@ -368,7 +368,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n         }\n     }\n \n-    fn binop(&mut self, op: BinOp, left: &Expr, right: &Expr) -> Option<Constant> {\n+    fn binop(&mut self, op: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> Option<Constant> {\n         let l = self.expr(left)?;\n         let r = self.expr(right);\n         match (l, r) {"}, {"sha": "e5f770539c332139675b0fbd9608ce51f1b715f1", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -153,7 +153,7 @@ declare_clippy_lint! {\n declare_lint_pass!(CopyAndPaste => [IFS_SAME_COND, SAME_FUNCTIONS_IN_IF_CONDITION, IF_SAME_THEN_ELSE, MATCH_SAME_ARMS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if !expr.span.from_expansion() {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(expr) = get_parent_expr(cx, expr) {\n@@ -174,8 +174,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n }\n \n /// Implementation of `IF_SAME_THEN_ELSE`.\n-fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block]) {\n-    let eq: &dyn Fn(&&Block, &&Block) -> bool = &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n+fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block<'_>]) {\n+    let eq: &dyn Fn(&&Block<'_>, &&Block<'_>) -> bool =\n+        &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).eq_block(lhs, rhs) };\n \n     if let Some((i, j)) = search_same_sequenced(blocks, eq) {\n         span_note_and_lint(\n@@ -190,14 +191,14 @@ fn lint_same_then_else(cx: &LateContext<'_, '_>, blocks: &[&Block]) {\n }\n \n /// Implementation of `IFS_SAME_COND`.\n-fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n-    let hash: &dyn Fn(&&Expr) -> u64 = &|expr| -> u64 {\n+fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n+    let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx, cx.tables);\n         h.hash_expr(expr);\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr, &&Expr) -> bool =\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool =\n         &|&lhs, &rhs| -> bool { SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) };\n \n     for (i, j) in search_same(conds, hash, eq) {\n@@ -213,14 +214,14 @@ fn lint_same_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n }\n \n /// Implementation of `SAME_FUNCTIONS_IN_IF_CONDITION`.\n-fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n-    let hash: &dyn Fn(&&Expr) -> u64 = &|expr| -> u64 {\n+fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr<'_>]) {\n+    let hash: &dyn Fn(&&Expr<'_>) -> u64 = &|expr| -> u64 {\n         let mut h = SpanlessHash::new(cx, cx.tables);\n         h.hash_expr(expr);\n         h.finish()\n     };\n \n-    let eq: &dyn Fn(&&Expr, &&Expr) -> bool = &|&lhs, &rhs| -> bool {\n+    let eq: &dyn Fn(&&Expr<'_>, &&Expr<'_>) -> bool = &|&lhs, &rhs| -> bool {\n         // Do not spawn warning if `IFS_SAME_COND` already produced it.\n         if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs, rhs) {\n             return false;\n@@ -241,7 +242,7 @@ fn lint_same_fns_in_if_cond(cx: &LateContext<'_, '_>, conds: &[&Expr]) {\n }\n \n /// Implementation of `MATCH_SAME_ARMS`.\n-fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n+fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>) {\n     fn same_bindings<'tcx>(\n         cx: &LateContext<'_, 'tcx>,\n         lhs: &FxHashMap<Symbol, Ty<'tcx>>,\n@@ -254,13 +255,13 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n     }\n \n     if let ExprKind::Match(_, ref arms, MatchSource::Normal) = expr.kind {\n-        let hash = |&(_, arm): &(usize, &Arm)| -> u64 {\n+        let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n             let mut h = SpanlessHash::new(cx, cx.tables);\n             h.hash_expr(&arm.body);\n             h.finish()\n         };\n \n-        let eq = |&(lindex, lhs): &(usize, &Arm), &(rindex, rhs): &(usize, &Arm)| -> bool {\n+        let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n             let min_index = usize::min(lindex, rindex);\n             let max_index = usize::max(lindex, rindex);\n \n@@ -272,7 +273,7 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n                 same_bindings(cx, &bindings(cx, &lhs.pat), &bindings(cx, &rhs.pat))\n         };\n \n-        let indexed_arms: Vec<(usize, &Arm)> = arms.iter().enumerate().collect();\n+        let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n         for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n             span_lint_and_then(\n                 cx,\n@@ -313,11 +314,11 @@ fn lint_match_arms<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr) {\n }\n \n /// Returns the list of bindings in a pattern.\n-fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<Symbol, Ty<'tcx>> {\n-    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>) -> FxHashMap<Symbol, Ty<'tcx>> {\n+    fn bindings_impl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat<'_>, map: &mut FxHashMap<Symbol, Ty<'tcx>>) {\n         match pat.kind {\n             PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => bindings_impl(cx, pat, map),\n-            PatKind::TupleStruct(_, ref pats, _) => {\n+            PatKind::TupleStruct(_, pats, _) => {\n                 for pat in pats {\n                     bindings_impl(cx, pat, map);\n                 }\n@@ -330,17 +331,17 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> FxHashMap<Symbol\n                     bindings_impl(cx, as_pat, map);\n                 }\n             },\n-            PatKind::Or(ref fields) | PatKind::Tuple(ref fields, _) => {\n+            PatKind::Or(fields) | PatKind::Tuple(fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, pat, map);\n                 }\n             },\n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(_, fields, _) => {\n                 for pat in fields {\n                     bindings_impl(cx, &pat.pat, map);\n                 }\n             },\n-            PatKind::Slice(ref lhs, ref mid, ref rhs) => {\n+            PatKind::Slice(lhs, ref mid, rhs) => {\n                 for pat in lhs {\n                     bindings_impl(cx, pat, map);\n                 }"}, {"sha": "ceacd41e0de854381b487c58993ff4151b9b3786", "filename": "clippy_lints/src/default_trait_access.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fdefault_trait_access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_trait_access.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -32,7 +32,7 @@ declare_clippy_lint! {\n declare_lint_pass!(DefaultTraitAccess => [DEFAULT_TRAIT_ACCESS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DefaultTraitAccess {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path, ..) = expr.kind;\n             if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);"}, {"sha": "5cadf41fd1b98247866922fbee7d5e8f6abd513b", "filename": "clippy_lints/src/double_comparison.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fdouble_comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_comparison.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -40,7 +40,7 @@ declare_lint_pass!(DoubleComparisons => [DOUBLE_COMPARISONS]);\n \n impl<'a, 'tcx> DoubleComparisons {\n     #[allow(clippy::similar_names)]\n-    fn check_binop(cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr, rhs: &'tcx Expr, span: Span) {\n+    fn check_binop(cx: &LateContext<'a, 'tcx>, op: BinOpKind, lhs: &'tcx Expr<'_>, rhs: &'tcx Expr<'_>, span: Span) {\n         let (lkind, llhs, lrhs, rkind, rlhs, rrhs) = match (&lhs.kind, &rhs.kind) {\n             (ExprKind::Binary(lb, llhs, lrhs), ExprKind::Binary(rb, rlhs, rrhs)) => {\n                 (lb.node, llhs, lrhs, rb.node, rlhs, rrhs)\n@@ -88,7 +88,7 @@ impl<'a, 'tcx> DoubleComparisons {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DoubleComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = expr.kind {\n             Self::check_binop(cx, kind.node, lhs, rhs, expr.span);\n         }"}, {"sha": "a0619f02df1b550149d8165f7797138f7bee5fbb", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -110,7 +110,7 @@ const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that\n declare_lint_pass!(DropForgetRef => [DROP_REF, FORGET_REF, DROP_COPY, FORGET_COPY]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DropForgetRef {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = path.kind;"}, {"sha": "cf8d0f542ad02bb9d4345860f77cafd6d7abc9f1", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -34,7 +34,7 @@ declare_clippy_lint! {\n declare_lint_pass!(DurationSubsec => [DURATION_SUBSEC]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n             if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.kind;"}, {"sha": "1d935d2a448eaf9994b91d2c251ecddd3cd51984", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -53,7 +53,7 @@ declare_clippy_lint! {\n declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapPass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some((ref check, ref then_block, ref else_block)) = higher::if_block(&expr) {\n             if let ExprKind::Unary(UnOp::UnNot, ref check) = check.kind {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n@@ -100,8 +100,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapPass {\n \n fn check_cond<'a, 'tcx, 'b>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    check: &'b Expr,\n-) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n+    check: &'b Expr<'b>,\n+) -> Option<(&'static str, &'b Expr<'b>, &'b Expr<'b>)> {\n     if_chain! {\n         if let ExprKind::MethodCall(ref path, _, ref params) = check.kind;\n         if params.len() >= 2;\n@@ -130,13 +130,13 @@ struct InsertVisitor<'a, 'tcx, 'b> {\n     cx: &'a LateContext<'a, 'tcx>,\n     span: Span,\n     ty: &'static str,\n-    map: &'b Expr,\n-    key: &'b Expr,\n+    map: &'b Expr<'b>,\n+    key: &'b Expr<'b>,\n     sole_expr: bool,\n }\n \n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref params) = expr.kind;\n             if params.len() == 3;"}, {"sha": "90b1b2d92cb549c6d3fa6dd291558d28272ebd8d", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -49,7 +49,7 @@ declare_lint_pass!(EqOp => [EQ_OP, OP_REF]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(op, ref left, ref right) = e.kind {\n             if e.span.from_expansion() {\n                 return;"}, {"sha": "6e10e0c1aa91908d73fa12ac3d8c131af7744b85", "filename": "clippy_lints/src/erasing_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ferasing_op.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -31,7 +31,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ErasingOp => [ERASING_OP]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ErasingOp {\n     }\n }\n \n-fn check(cx: &LateContext<'_, '_>, e: &Expr, span: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, span: Span) {\n     if let Some(Constant::Int(0)) = constant_simple(cx, cx.tables, e) {\n         span_lint(\n             cx,"}, {"sha": "acaa432137d03d5f77e26d0078c52611eeeb857a", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -61,13 +61,13 @@ declare_clippy_lint! {\n declare_lint_pass!(EtaReduction => [REDUNDANT_CLOSURE, REDUNDANT_CLOSURE_FOR_METHOD_CALLS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n \n         match expr.kind {\n-            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n                 for arg in args {\n                     check_closure(cx, arg)\n                 }\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n     }\n }\n \n-fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n+fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if let ExprKind::Closure(_, ref decl, eid, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(eid);\n         let ex = &body.value;\n@@ -99,7 +99,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n \n             if !type_is_unsafe_function(cx, fn_ty);\n \n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.into_iter());\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n \n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure found\", |db| {\n@@ -127,7 +127,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n             let method_def_id = cx.tables.type_dependent_def_id(ex.hir_id).unwrap();\n             if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n \n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.into_iter());\n+            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n \n             if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n \n@@ -146,7 +146,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr) {\n }\n \n /// Tries to determine the type for universal function call to be used instead of the closure\n-fn get_ufcs_type_name(cx: &LateContext<'_, '_>, method_def_id: def_id::DefId, self_arg: &Expr) -> Option<String> {\n+fn get_ufcs_type_name(cx: &LateContext<'_, '_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n     let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n     let actual_type_of_self = &cx.tables.node_type(self_arg.hir_id);\n \n@@ -200,8 +200,8 @@ fn get_type_name(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> String {\n }\n \n fn compare_inputs(\n-    closure_inputs: &mut dyn Iterator<Item = &Param>,\n-    call_args: &mut dyn Iterator<Item = &Expr>,\n+    closure_inputs: &mut dyn Iterator<Item = &Param<'_>>,\n+    call_args: &mut dyn Iterator<Item = &Expr<'_>>,\n ) -> bool {\n     for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n         if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {"}, {"sha": "27ede8bdfdbfff4c1efc3358a64de47b7d4a412c", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -59,7 +59,7 @@ declare_clippy_lint! {\n declare_lint_pass!(EvalOrderDependence => [EVAL_ORDER_DEPENDENCE, DIVERGING_SUB_EXPRESSION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // Find a write to a local variable.\n         match expr.kind {\n             ExprKind::Assign(ref lhs, ..) | ExprKind::AssignOp(_, ref lhs, _) => {\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n             _ => {},\n         }\n     }\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n             StmtKind::Local(ref local) => {\n                 if let Local { init: Some(ref e), .. } = **local {\n@@ -100,10 +100,10 @@ struct DivergenceVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n-    fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n+    fn maybe_walk_expr(&mut self, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Closure(..) => {},\n-            ExprKind::Match(ref e, ref arms, _) => {\n+            ExprKind::Match(ref e, arms, _) => {\n                 self.visit_expr(e);\n                 for arm in arms {\n                     if let Some(ref guard) = arm.guard {\n@@ -118,13 +118,13 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n             _ => walk_expr(self, e),\n         }\n     }\n-    fn report_diverging_sub_expr(&mut self, e: &Expr) {\n+    fn report_diverging_sub_expr(&mut self, e: &Expr<'_>) {\n         span_lint(self.cx, DIVERGING_SUB_EXPRESSION, e.span, \"sub-expression diverges\");\n     }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'tcx Expr) {\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Continue(_) | ExprKind::Break(_, _) | ExprKind::Ret(_) => self.report_diverging_sub_expr(e),\n             ExprKind::Call(ref func, _) => {\n@@ -153,7 +153,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n         }\n         self.maybe_walk_expr(e);\n     }\n-    fn visit_block(&mut self, _: &'tcx Block) {\n+    fn visit_block(&mut self, _: &'tcx Block<'_>) {\n         // don't continue over blocks, LateLintPass already does that\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -214,7 +214,7 @@ enum StopEarly {\n     Stop,\n }\n \n-fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n+fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr<'_>) -> StopEarly {\n     if expr.hir_id == vis.last_expr.hir_id {\n         return StopEarly::KeepGoing;\n     }\n@@ -261,7 +261,7 @@ fn check_expr<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> St\n     StopEarly::KeepGoing\n }\n \n-fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n+fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt<'_>) -> StopEarly {\n     match stmt.kind {\n         StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => check_expr(vis, expr),\n         // If the declaration is of a local variable, check its initializer\n@@ -281,14 +281,14 @@ struct ReadVisitor<'a, 'tcx> {\n     var: HirId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n-    write_expr: &'tcx Expr,\n+    write_expr: &'tcx Expr<'tcx>,\n     /// The last (highest in the AST) expression we've checked, so we know not\n     /// to recheck it.\n-    last_expr: &'tcx Expr,\n+    last_expr: &'tcx Expr<'tcx>,\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if expr.hir_id == self.last_expr.hir_id {\n             return;\n         }\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n }\n \n /// Returns `true` if `expr` is the LHS of an assignment, like `expr = ...`.\n-fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn is_in_assignment_position(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         if let ExprKind::Assign(ref lhs, ..) = parent.kind {\n             return lhs.hir_id == expr.hir_id;"}, {"sha": "f6dd026335c761af82b02bfb9d6c156ac8695d34", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -40,7 +40,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ExcessivePrecision => [EXCESSIVE_PRECISION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::Float(fty) = ty.kind;"}, {"sha": "6acc4fa1f4a06911b43cd59751e0f09afdcd3c38", "filename": "clippy_lints/src/exit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexit.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -26,7 +26,7 @@ declare_clippy_lint! {\n declare_lint_pass!(Exit => [EXIT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Exit {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref _args) = e.kind;\n             if let ExprKind::Path(ref path) = path_expr.kind;"}, {"sha": "46655ca0003ee51f02e5dc8d742f4d02bddf9208", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -30,18 +30,18 @@ declare_clippy_lint! {\n declare_lint_pass!(ExplicitWrite => [EXPLICIT_WRITE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n             if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.kind;\n             if unwrap_fun.ident.name == sym!(unwrap);\n             // match call to write_fmt\n-            if unwrap_args.len() > 0;\n-            if let ExprKind::MethodCall(ref write_fun, _, ref write_args) =\n+            if !unwrap_args.is_empty();\n+            if let ExprKind::MethodCall(ref write_fun, _, write_args) =\n                 unwrap_args[0].kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            if write_args.len() > 0;\n+            if !write_args.is_empty();\n             if let Some(dest_name) = if match_function_call(cx, &write_args[0], &paths::STDOUT).is_some() {\n                 Some(\"stdout\")\n             } else if match_function_call(cx, &write_args[0], &paths::STDERR).is_some() {\n@@ -130,12 +130,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n }\n \n // Extract the output string from the given `write_args`.\n-fn write_output_string(write_args: &HirVec<Expr>) -> Option<String> {\n+fn write_output_string(write_args: &[Expr<'_>]) -> Option<String> {\n     if_chain! {\n         // Obtain the string that should be printed\n         if write_args.len() > 1;\n         if let ExprKind::Call(_, ref output_args) = write_args[1].kind;\n-        if output_args.len() > 0;\n+        if !output_args.is_empty();\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref output_string_expr) = output_args[0].kind;\n         if let ExprKind::Array(ref string_exprs) = output_string_expr.kind;\n         // we only want to provide an automatic suggestion for simple (non-format) strings"}, {"sha": "91dbee39a02a9c498b4d3ad9eea329f83da924aa", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -57,7 +57,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n \n     impl<'a, 'tcx> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n-        fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n             // check for `begin_panic`\n             if_chain! {\n                 if let ExprKind::Call(ref func_expr, _) = expr.kind;"}, {"sha": "9f7a11332c3644ffe6c4ecf69bd3086222d1cd61", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -38,7 +38,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         let span = match is_expn_of(expr.span, \"format\") {\n             Some(s) if !s.from_expansion() => s,\n             _ => return,\n@@ -72,7 +72,11 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n     });\n }\n \n-fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'tcx [Arm]) -> Option<String> {\n+fn on_argumentv1_new<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+) -> Option<String> {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref format_args) = expr.kind;\n         if let ExprKind::Array(ref elems) = arms[0].body.kind;\n@@ -111,7 +115,7 @@ fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arm\n     None\n }\n \n-fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n+fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n     if_chain! {\n         if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1);\n         if args.len() == 2;\n@@ -138,7 +142,7 @@ fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<S\n     None\n }\n \n-fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n+fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<String> {\n     if_chain! {\n         if let Some(args) = match_function_call(cx, expr, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n         if args.len() == 3;\n@@ -172,7 +176,7 @@ fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Opti\n ///    ...,\n /// }]\n /// ```\n-fn check_unformatted(expr: &Expr) -> bool {\n+fn check_unformatted(expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n         if let ExprKind::Array(ref exprs) = expr.kind;"}, {"sha": "0d7b24fd762de37ce7badde4f60b7fc6d2f6ea92", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -483,7 +483,7 @@ fn has_mutable_arg(cx: &LateContext<'_, '_>, body: &hir::Body<'_>) -> bool {\n     body.params.iter().any(|param| is_mutable_pat(cx, &param.pat, &mut tys))\n }\n \n-fn is_mutable_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, tys: &mut FxHashSet<DefId>) -> bool {\n+fn is_mutable_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, tys: &mut FxHashSet<DefId>) -> bool {\n     if let hir::PatKind::Wild = pat.kind {\n         return false; // ignore `_` patterns\n     }\n@@ -518,7 +518,7 @@ fn is_mutable_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>, span: Span,\n     }\n }\n \n-fn raw_ptr_arg(arg: &hir::Param, ty: &hir::Ty) -> Option<hir::HirId> {\n+fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty) -> Option<hir::HirId> {\n     if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n         Some(id)\n     } else {\n@@ -533,9 +533,9 @@ struct DerefVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n-            hir::ExprKind::Call(ref f, ref args) => {\n+            hir::ExprKind::Call(ref f, args) => {\n                 let ty = self.tables.expr_ty(f);\n \n                 if type_is_unsafe_function(self.cx, ty) {\n@@ -544,7 +544,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, _, ref args) => {\n+            hir::ExprKind::MethodCall(_, _, args) => {\n                 let def_id = self.tables.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n@@ -567,7 +567,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr) {\n+    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n         if let hir::ExprKind::Path(ref qpath) = ptr.kind {\n             if let Res::Local(id) = qpath_res(self.cx, qpath, ptr.hir_id) {\n                 if self.ptrs.contains(&id) {\n@@ -589,14 +589,14 @@ struct StaticMutVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         use hir::ExprKind::*;\n \n         if self.mutates_static {\n             return;\n         }\n         match expr.kind {\n-            Call(_, ref args) | MethodCall(_, _, ref args) => {\n+            Call(_, args) | MethodCall(_, _, args) => {\n                 let mut tys = FxHashSet::default();\n                 for arg in args {\n                     let def_id = arg.hir_id.owner_def_id();\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n     }\n }\n \n-fn is_mutated_static(cx: &LateContext<'_, '_>, e: &hir::Expr) -> bool {\n+fn is_mutated_static(cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::*;\n \n     match e.kind {"}, {"sha": "8ee3b75c9593d5d58e24a77d3a47a73fea1f54b2", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -46,7 +46,7 @@ declare_clippy_lint! {\n declare_lint_pass!(GetLastWithLen => [GET_LAST_WITH_LEN]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Is a method call\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;"}, {"sha": "c266c496090c9b11d2dede40ce76fc73e1fcd64f", "filename": "clippy_lints/src/identity_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fidentity_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_conversion.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -32,7 +32,7 @@ pub struct IdentityConversion {\n impl_lint_pass!(IdentityConversion => [IDENTITY_CONVERSION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -114,7 +114,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityConversion {\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if Some(&e.hir_id) == self.try_desugar_arm.last() {\n             self.try_desugar_arm.pop();\n         }"}, {"sha": "5f9e0aecb19ea1dbfe9d55ad56554ec4e15c5562", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -29,7 +29,7 @@ declare_clippy_lint! {\n declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -56,7 +56,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n }\n \n #[allow(clippy::cast_possible_wrap)]\n-fn check(cx: &LateContext<'_, '_>, e: &Expr, m: i8, span: Span, arg: Span) {\n+fn check(cx: &LateContext<'_, '_>, e: &Expr<'_>, m: i8, span: Span, arg: Span) {\n     if let Some(Constant::Int(v)) = constant_simple(cx, cx.tables, e) {\n         let check = match cx.tables.expr_ty(e).kind {\n             ty::Int(ity) => unsext(cx.tcx, -1_i128, ity),"}, {"sha": "166f371e14602ef0c22aa62135f69b4d81a478bd", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -62,8 +62,8 @@ fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str)\n     });\n }\n \n-fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n-    match &expr.kind {\n+fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n+    match expr.kind {\n         // loops could be using `break` instead of `return`\n         ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n             if let Some(expr) = &block.expr {\n@@ -92,7 +92,7 @@ fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr) {\n             let check_all_arms = match source {\n                 MatchSource::IfLetDesugar {\n                     contains_else_clause: has_else,\n-                } => *has_else,\n+                } => has_else,\n                 _ => true,\n             };\n "}, {"sha": "837df9f3808edd0a4c80a15326a3195d8dc94188", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -89,7 +89,7 @@ declare_clippy_lint! {\n declare_lint_pass!(IndexingSlicing => [INDEXING_SLICING, OUT_OF_BOUNDS_INDEXING]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IndexingSlicing {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(ref array, ref index) = &expr.kind {\n             let ty = cx.tables.expr_ty(array);\n             if let Some(range) = higher::range(cx, index) {"}, {"sha": "26695a66894dc89ba27388ca2a36289902463a68", "filename": "clippy_lints/src/infallible_destructuring_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfallible_destructuring_match.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -44,7 +44,7 @@ declare_clippy_lint! {\n declare_lint_pass!(InfallibleDestructingMatch => [INFALLIBLE_DESTRUCTURING_MATCH]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfallibleDestructingMatch {\n-    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n         if_chain! {\n             if let Some(ref expr) = local.init;\n             if let ExprKind::Match(ref target, ref arms, MatchSource::Normal) = expr.kind;"}, {"sha": "74d4d9c072bdc632f0ef73939cf34832e08f0d32", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -46,7 +46,7 @@ declare_clippy_lint! {\n declare_lint_pass!(InfiniteIter => [INFINITE_ITER, MAYBE_INFINITE_ITER]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InfiniteIter {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         let (lint, msg) = match complete_infinite_iter(cx, expr) {\n             Infinite => (INFINITE_ITER, \"infinite iteration detected\"),\n             MaybeInfinite => (MAYBE_INFINITE_ITER, \"possible infinite iteration detected\"),\n@@ -141,7 +141,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n     (\"scan\", 3, First, MaybeInfinite),\n ];\n \n-fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n+fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n@@ -217,7 +217,7 @@ const INFINITE_COLLECTORS: [&[&str]; 8] = [\n     &paths::VEC_DEQUE,\n ];\n \n-fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr) -> Finiteness {\n+fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n         ExprKind::MethodCall(ref method, _, ref args) => {\n             for &(name, len) in &COMPLETING_METHODS {"}, {"sha": "57c9a8537452e428616a6d6ee0b14bf7e5160061", "filename": "clippy_lints/src/integer_division.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Finteger_division.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Finteger_division.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finteger_division.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -29,7 +29,7 @@ declare_clippy_lint! {\n declare_lint_pass!(IntegerDivision => [INTEGER_DIVISION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IntegerDivision {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if is_integer_division(cx, expr) {\n             span_help_and_lint(\n                 cx,\n@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IntegerDivision {\n     }\n }\n \n-fn is_integer_division<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) -> bool {\n+fn is_integer_division<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n     if_chain! {\n         if let hir::ExprKind::Binary(binop, left, right) = &expr.kind;\n         if let hir::BinOpKind::Div = &binop.node;"}, {"sha": "f5d5c95ed7aac096fce10adba7335fb13c4bb95d", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -40,7 +40,7 @@ impl LargeStackArrays {\n impl_lint_pass!(LargeStackArrays => [LARGE_STACK_ARRAYS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeStackArrays {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.tables.expr_ty(expr).kind;"}, {"sha": "c17e43ea8ccd3b754ae66e3a4569e96eba88509f", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -207,7 +207,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item<'_>, impl_items: &[Imp\n     }\n }\n \n-fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr, lit: &Expr, op: &str, compare_to: u32) {\n+fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n     if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n@@ -224,7 +224,7 @@ fn check_len(\n     cx: &LateContext<'_, '_>,\n     span: Span,\n     method_name: Name,\n-    args: &[Expr],\n+    args: &[Expr<'_>],\n     lit: &LitKind,\n     op: &str,\n     compare_to: u32,\n@@ -255,7 +255,7 @@ fn check_len(\n }\n \n /// Checks if this type has an `is_empty` method.\n-fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn has_is_empty(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     /// Gets an `AssocItem` and return true if it matches `is_empty(self)`.\n     fn is_is_empty(cx: &LateContext<'_, '_>, item: &ty::AssocItem) -> bool {\n         if let ty::AssocKind::Method = item.kind {"}, {"sha": "4ac88d573f3ffde10395ba1bee69a84fefff4dfb", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -56,7 +56,7 @@ declare_clippy_lint! {\n declare_lint_pass!(LetIfSeq => [USELESS_LET_IF_SEQ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block<'_>) {\n         let mut it = block.stmts.iter().peekable();\n         while let Some(stmt) = it.next() {\n             if_chain! {\n@@ -143,7 +143,7 @@ struct UsedVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::Path(ref qpath) = expr.kind;\n             if let Res::Local(local_id) = qpath_res(self.cx, qpath, expr.hir_id);\n@@ -163,8 +163,8 @@ impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n fn check_assign<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     decl: hir::HirId,\n-    block: &'tcx hir::Block,\n-) -> Option<&'tcx hir::Expr> {\n+    block: &'tcx hir::Block<'_>,\n+) -> Option<&'tcx hir::Expr<'tcx>> {\n     if_chain! {\n         if block.expr.is_none();\n         if let Some(expr) = block.stmts.iter().last();\n@@ -195,7 +195,7 @@ fn check_assign<'a, 'tcx>(\n     None\n }\n \n-fn used_in_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, id: hir::HirId, expr: &'tcx hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> bool {\n     let mut v = UsedVisitor { cx, id, used: false };\n     hir::intravisit::walk_expr(&mut v, expr);\n     v.used"}, {"sha": "4933b3049c28166f22d4ab41061418db3c7695f9", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -33,7 +33,7 @@ declare_clippy_lint! {\n declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnderscore {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &Stmt<'_>) {\n         if_chain! {\n             if let StmtKind::Local(ref local) = stmt.kind;\n             if let PatKind::Wild = local.pat.kind;"}, {"sha": "7fb924ee75f6df82b5162aa6913d5592a426b06c", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -475,7 +475,7 @@ declare_lint_pass!(Loops => [\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some((pat, arg, body)) = higher::for_loop(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n@@ -651,22 +651,22 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block, main_loop_id: HirId) -> NeverLoopResult {\n+fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n     let expr = once(block.expr.as_ref().map(|p| &**p));\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n \n-fn stmt_to_expr(stmt: &Stmt) -> Option<&Expr> {\n+fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match stmt.kind {\n         StmtKind::Semi(ref e, ..) | StmtKind::Expr(ref e, ..) => Some(e),\n         StmtKind::Local(ref local) => local.init.as_ref().map(|p| &**p),\n         _ => None,\n     }\n }\n \n-fn never_loop_expr(expr: &Expr, main_loop_id: HirId) -> NeverLoopResult {\n+fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.kind {\n         ExprKind::Box(ref e)\n         | ExprKind::Unary(_, ref e)\n@@ -726,27 +726,27 @@ fn never_loop_expr(expr: &Expr, main_loop_id: HirId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+fn never_loop_expr_seq<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n \n fn check_for_loop<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx Pat,\n-    arg: &'tcx Expr,\n-    body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n ) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n     check_for_loop_reverse_range(cx, arg, expr);\n@@ -757,7 +757,7 @@ fn check_for_loop<'a, 'tcx>(\n     detect_manual_memcpy(cx, pat, arg, body, expr);\n }\n \n-fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> bool {\n+fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = expr.kind;\n         if let QPath::Resolved(None, ref path) = *qpath;\n@@ -806,8 +806,8 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n     is_slice || is_type_diagnostic_item(cx, ty, Symbol::intern(\"vec_type\")) || match_type(cx, ty, &paths::VEC_DEQUE)\n }\n \n-fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: HirId) -> Option<FixedOffsetVar> {\n-    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr, var: HirId) -> Option<String> {\n+fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>, var: HirId) -> Option<FixedOffsetVar> {\n+    fn extract_offset<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n         match e.kind {\n             ExprKind::Lit(ref l) => match l.node {\n                 ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n@@ -861,7 +861,7 @@ fn get_fixed_offset_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var:\n \n fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &Expr,\n+    expr: &Expr<'_>,\n     var: HirId,\n ) -> Option<FixedOffsetVar> {\n     if_chain! {\n@@ -879,12 +879,12 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n \n fn get_indexed_assignments<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    body: &Expr,\n+    body: &Expr<'_>,\n     var: HirId,\n ) -> Vec<(FixedOffsetVar, FixedOffsetVar)> {\n     fn get_assignment<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,\n-        e: &Expr,\n+        e: &Expr<'_>,\n         var: HirId,\n     ) -> Option<(FixedOffsetVar, FixedOffsetVar)> {\n         if let ExprKind::Assign(ref lhs, ref rhs, _) = e.kind {\n@@ -931,10 +931,10 @@ fn get_indexed_assignments<'a, 'tcx>(\n /// object to another.\n fn detect_manual_memcpy<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx Pat,\n-    arg: &'tcx Expr,\n-    body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n ) {\n     if let Some(higher::Range {\n         start: Some(start),\n@@ -968,7 +968,7 @@ fn detect_manual_memcpy<'a, 'tcx>(\n                 }\n             };\n \n-            let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| {\n+            let print_limit = |end: &Option<&Expr<'_>>, offset: Offset, var_name: &str| {\n                 if let Some(end) = *end {\n                     if_chain! {\n                         if let ExprKind::MethodCall(ref method, _, ref len_args) = end.kind;\n@@ -1044,10 +1044,10 @@ fn detect_manual_memcpy<'a, 'tcx>(\n #[allow(clippy::too_many_lines)]\n fn check_for_loop_range<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx Pat,\n-    arg: &'tcx Expr,\n-    body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n ) {\n     if let Some(higher::Range {\n         start: Some(start),\n@@ -1206,7 +1206,7 @@ fn check_for_loop_range<'a, 'tcx>(\n     }\n }\n \n-fn is_len_call(expr: &Expr, var: Name) -> bool {\n+fn is_len_call(expr: &Expr<'_>, var: Name) -> bool {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.kind;\n         if len_args.len() == 1;\n@@ -1224,7 +1224,7 @@ fn is_len_call(expr: &Expr, var: Name) -> bool {\n \n fn is_end_eq_array_len<'tcx>(\n     cx: &LateContext<'_, 'tcx>,\n-    end: &Expr,\n+    end: &Expr<'_>,\n     limits: ast::RangeLimits,\n     indexed_ty: Ty<'tcx>,\n ) -> bool {\n@@ -1244,7 +1244,7 @@ fn is_end_eq_array_len<'tcx>(\n     false\n }\n \n-fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx Expr, expr: &'tcx Expr) {\n+fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n     // if this for loop is iterating over a two-sided range...\n     if let Some(higher::Range {\n         start: Some(start),\n@@ -1316,7 +1316,7 @@ fn check_for_loop_reverse_range<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arg: &'tcx\n     }\n }\n \n-fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_name: &str) {\n+fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr<'_>], arg: &Expr<'_>, method_name: &str) {\n     let mut applicability = Applicability::MachineApplicable;\n     let object = snippet_with_applicability(cx, args[0].span, \"_\", &mut applicability);\n     let muta = if method_name == \"iter_mut\" { \"mut \" } else { \"\" };\n@@ -1332,7 +1332,7 @@ fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr], arg: &Expr, method_\n     )\n }\n \n-fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Expr) {\n+fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n     if let ExprKind::MethodCall(ref method, _, ref args) = arg.kind {\n         // just the receiver, no arguments\n@@ -1389,7 +1389,7 @@ fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr, expr: &Ex\n }\n \n /// Checks for `for` loops over `Option`s and `Result`s.\n-fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n+fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     let ty = cx.tables.expr_ty(arg);\n     if match_type(cx, ty, &paths::OPTION) {\n         span_help_and_lint(\n@@ -1428,10 +1428,10 @@ fn check_arg_type(cx: &LateContext<'_, '_>, pat: &Pat, arg: &Expr) {\n \n fn check_for_loop_explicit_counter<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx Pat,\n-    arg: &'tcx Expr,\n-    body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n ) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n@@ -1491,7 +1491,7 @@ fn check_for_loop_explicit_counter<'a, 'tcx>(\n \n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses.\n-fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr, applic_ref: &mut Applicability) -> String {\n+fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr<'_>, applic_ref: &mut Applicability) -> String {\n     let impls_iterator = get_trait_def_id(cx, &paths::ITERATOR)\n         .map_or(false, |id| implements_trait(cx, cx.tables.expr_ty(arg), id, &[]));\n     if impls_iterator {\n@@ -1527,10 +1527,10 @@ fn make_iterator_snippet(cx: &LateContext<'_, '_>, arg: &Expr, applic_ref: &mut\n /// Checks for the `FOR_KV_MAP` lint.\n fn check_for_loop_over_map_kv<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx Pat,\n-    arg: &'tcx Expr,\n-    body: &'tcx Expr,\n-    expr: &'tcx Expr,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n ) {\n     let pat_span = pat.span;\n \n@@ -1618,7 +1618,7 @@ impl<'tcx> MutatePairDelegate {\n     }\n }\n \n-fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr, body: &Expr) {\n+fn check_for_mut_range_bound(cx: &LateContext<'_, '_>, arg: &Expr<'_>, body: &Expr<'_>) {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1645,7 +1645,7 @@ fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr<'_>) -> Option<HirId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.kind;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1669,7 +1669,7 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId>\n \n fn check_for_mutation(\n     cx: &LateContext<'_, '_>,\n-    body: &Expr,\n+    body: &Expr<'_>,\n     bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n@@ -1686,7 +1686,7 @@ fn check_for_mutation(\n }\n \n /// Returns `true` if the pattern is a `PatWild` or an ident prefixed with `_`.\n-fn pat_is_wild<'tcx>(pat: &'tcx PatKind, body: &'tcx Expr) -> bool {\n+fn pat_is_wild<'tcx>(pat: &'tcx PatKind<'_>, body: &'tcx Expr<'_>) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n         PatKind::Binding(.., ident, None) if ident.as_str().starts_with('_') => {\n@@ -1707,7 +1707,7 @@ struct UsedVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for UsedVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if match_var(expr, self.var) {\n             self.used = true;\n         } else {\n@@ -1727,7 +1727,7 @@ struct LocalUsedVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LocalUsedVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if same_var(self.cx, expr, self.local) {\n             self.used = true;\n         } else {\n@@ -1764,7 +1764,7 @@ struct VarVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n-    fn check(&mut self, idx: &'tcx Expr, seqexpr: &'tcx Expr, expr: &'tcx Expr) -> bool {\n+    fn check(&mut self, idx: &'tcx Expr<'_>, seqexpr: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n         if_chain! {\n             // the indexed container is referenced by a name\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n@@ -1825,7 +1825,7 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n             if let ExprKind::MethodCall(ref meth, _, ref args) = expr.kind;\n@@ -1873,7 +1873,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                 }\n                 self.visit_expr(expr);\n             },\n-            ExprKind::Call(ref f, ref args) => {\n+            ExprKind::Call(ref f, args) => {\n                 self.visit_expr(f);\n                 for expr in args {\n                     let ty = self.cx.tables.expr_ty_adjusted(expr);\n@@ -1886,7 +1886,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprKind::MethodCall(_, _, ref args) => {\n+            ExprKind::MethodCall(_, _, args) => {\n                 let def_id = self.cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n@@ -1911,7 +1911,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     }\n }\n \n-fn is_used_inside<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr, container: &'tcx Expr) -> bool {\n+fn is_used_inside<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, container: &'tcx Expr<'_>) -> bool {\n     let def_id = match var_def_id(cx, expr) {\n         Some(id) => id,\n         None => return false,\n@@ -1924,7 +1924,7 @@ fn is_used_inside<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr, con\n     false\n }\n \n-fn is_iterator_used_after_while_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, iter_expr: &'tcx Expr) -> bool {\n+fn is_iterator_used_after_while_let<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, iter_expr: &'tcx Expr<'_>) -> bool {\n     let def_id = match var_def_id(cx, iter_expr) {\n         Some(id) => id,\n         None => return false,\n@@ -1951,7 +1951,7 @@ struct VarUsedAfterLoopVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.past_while_let {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n                 self.var_used_after_while_let = true;\n@@ -1969,7 +1969,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n /// Returns `true` if the type of expr is one that provides `IntoIterator` impls\n /// for `&T` and `&mut T`, such as `Vec`.\n #[rustfmt::skip]\n-fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n+fn is_ref_iterable_type(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n     // no walk_ptrs_ty: calling iter() on a reference can make sense because it\n     // will allow further borrows afterwards\n     let ty = cx.tables.expr_ty(e);\n@@ -2000,12 +2000,12 @@ fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'_, 'tcx>) -> bool {\n \n /// If a block begins with a statement (possibly a `let` binding) and has an\n /// expression, return it.\n-fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n+fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if block.stmts.is_empty() {\n         return None;\n     }\n     if let StmtKind::Local(ref local) = block.stmts[0].kind {\n-        if let Some(ref expr) = local.init {\n+        if let Some(expr) = local.init {\n             Some(expr)\n         } else {\n             None\n@@ -2016,7 +2016,7 @@ fn extract_expr_from_first_stmt(block: &Block) -> Option<&Expr> {\n }\n \n /// If a block begins with an expression (with or without semicolon), return it.\n-fn extract_first_expr(block: &Block) -> Option<&Expr> {\n+fn extract_first_expr<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     match block.expr {\n         Some(ref expr) if block.stmts.is_empty() => Some(expr),\n         None if !block.stmts.is_empty() => match block.stmts[0].kind {\n@@ -2030,7 +2030,7 @@ fn extract_first_expr(block: &Block) -> Option<&Expr> {\n /// Returns `true` if expr contains a single break expr without destination label\n /// and\n /// passed expression. The expression may be within a block.\n-fn is_simple_break_expr(expr: &Expr) -> bool {\n+fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Break(dest, ref passed_expr) if dest.label.is_none() && passed_expr.is_none() => true,\n         ExprKind::Block(ref b, _) => extract_first_expr(b).map_or(false, |subexpr| is_simple_break_expr(subexpr)),\n@@ -2059,7 +2059,7 @@ struct IncrementVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.done {\n             return;\n         }\n@@ -2109,7 +2109,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n /// Checks whether a variable is initialized to zero at the start of a loop.\n struct InitializeVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n-    end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n+    end_expr: &'tcx Expr<'tcx>,    // the for loop. Stop scanning here.\n     var_id: HirId,\n     state: VarState,\n     name: Option<Name>,\n@@ -2118,7 +2118,7 @@ struct InitializeVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         // Look for declarations of the variable\n         if let StmtKind::Local(ref local) = stmt.kind {\n             if local.pat.hir_id == self.var_id {\n@@ -2140,7 +2140,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         walk_stmt(self, stmt);\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n@@ -2196,7 +2196,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.kind {\n         let path_res = qpath_res(cx, qpath, expr.hir_id);\n         if let Res::Local(node_id) = path_res {\n@@ -2206,21 +2206,21 @@ fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n     None\n }\n \n-fn is_loop(expr: &Expr) -> bool {\n+fn is_loop(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Loop(..) => true,\n         _ => false,\n     }\n }\n \n-fn is_conditional(expr: &Expr) -> bool {\n+fn is_conditional(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Match(..) => true,\n         _ => false,\n     }\n }\n \n-fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n     if_chain! {\n         if let Some(loop_block) = get_enclosing_block(cx, match_expr.hir_id);\n         let parent_node = cx.tcx.hir().get_parent_node(loop_block.hir_id);\n@@ -2232,7 +2232,7 @@ fn is_nested(cx: &LateContext<'_, '_>, match_expr: &Expr, iter_expr: &Expr) -> b\n     false\n }\n \n-fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr, iter_expr: &Expr) -> bool {\n+fn is_loop_nested(cx: &LateContext<'_, '_>, loop_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {\n     let mut id = loop_expr.hir_id;\n     let iter_name = if let Some(name) = path_name(iter_expr) {\n         name\n@@ -2286,15 +2286,15 @@ struct LoopNestVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         if stmt.hir_id == self.hir_id {\n             self.nesting = LookFurther;\n         } else if self.nesting == Unknown {\n             walk_stmt(self, stmt);\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.nesting != Unknown {\n             return;\n         }\n@@ -2312,7 +2312,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n         }\n     }\n \n-    fn visit_pat(&mut self, pat: &'tcx Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx Pat<'_>) {\n         if self.nesting != Unknown {\n             return;\n         }\n@@ -2330,7 +2330,7 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-fn path_name(e: &Expr) -> Option<Name> {\n+fn path_name(e: &Expr<'_>) -> Option<Name> {\n     if let ExprKind::Path(QPath::Resolved(_, ref path)) = e.kind {\n         let segments = &path.segments;\n         if segments.len() == 1 {\n@@ -2340,7 +2340,7 @@ fn path_name(e: &Expr) -> Option<Name> {\n     None\n }\n \n-fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, expr: &'tcx Expr) {\n+fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n     if constant(cx, cx.tables, cond).is_some() {\n         // A pure constant condition (e.g., `while false`) is not linted.\n         return;\n@@ -2393,7 +2393,7 @@ struct HasBreakOrReturnVisitor {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.has_break_or_return {\n             return;\n         }\n@@ -2426,7 +2426,7 @@ struct VarCollectorVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n-    fn insert_def_id(&mut self, ex: &'tcx Expr) {\n+    fn insert_def_id(&mut self, ex: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Path(ref qpath) = ex.kind;\n             if let QPath::Resolved(None, _) = *qpath;\n@@ -2448,7 +2448,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &'tcx Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n         match ex.kind {\n             ExprKind::Path(_) => self.insert_def_id(ex),\n             // If there is any function/method call\u2026 we just stop analysis\n@@ -2465,7 +2465,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n-fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) {\n+fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, 'tcx>) {\n     if_chain! {\n         if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n         if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].kind;\n@@ -2525,7 +2525,7 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>\n     }\n }\n \n-fn shorten_needless_collect_span(expr: &Expr) -> Span {\n+fn shorten_needless_collect_span(expr: &Expr<'_>) -> Span {\n     if_chain! {\n         if let ExprKind::MethodCall(_, _, ref args) = expr.kind;\n         if let ExprKind::MethodCall(_, ref span, _) = args[0].kind;"}, {"sha": "affa20c885f57ff24f6c35f2bc1ec3246fe57dd2", "filename": "clippy_lints/src/main_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmain_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmain_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmain_recursion.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -45,7 +45,7 @@ impl LateLintPass<'_, '_> for MainRecursion {\n         });\n     }\n \n-    fn check_expr_post(&mut self, cx: &LateContext<'_, '_>, expr: &Expr) {\n+    fn check_expr_post(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if self.has_no_std_attr {\n             return;\n         }"}, {"sha": "755794a5f112c5e38104b34021c2cbf93cea5638", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MapClone => [MAP_CLONE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -98,7 +98,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n     }\n }\n \n-fn ident_eq(name: Ident, path: &hir::Expr) -> bool {\n+fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n     if let hir::ExprKind::Path(hir::QPath::Resolved(None, ref path)) = path.kind {\n         path.segments.len() == 1 && path.segments[0].ident == name\n     } else {"}, {"sha": "bedce8d9c893cd1f957c9c5054e9d4989641aece", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -102,7 +102,7 @@ fn is_unit_type(ty: Ty<'_>) -> bool {\n     }\n }\n \n-fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n+fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n     let ty = cx.tables.expr_ty(expr);\n \n     if let ty::FnDef(id, _) = ty.kind {\n@@ -113,15 +113,15 @@ fn is_unit_function(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n     false\n }\n \n-fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> bool {\n+fn is_unit_expression(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> bool {\n     is_unit_type(cx.tables.expr_ty(expr))\n }\n \n /// The expression inside a closure may or may not have surrounding braces and\n /// semicolons, which causes problems when generating a suggestion. Given an\n /// expression that evaluates to '()' or '!', recursively remove useless braces\n /// and semi-colons until is suitable for including in the suggestion template\n-fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) -> Option<Span> {\n+fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr<'_>) -> Option<Span> {\n     if !is_unit_expression(cx, expr) {\n         return None;\n     }\n@@ -164,8 +164,8 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr) ->\n \n fn unit_closure<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'a hir::Expr,\n-) -> Option<(&'tcx hir::Param, &'a hir::Expr)> {\n+    expr: &'a hir::Expr<'a>,\n+) -> Option<(&'tcx hir::Param<'tcx>, &'a hir::Expr<'a>)> {\n     if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind {\n         let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;\n@@ -188,7 +188,7 @@ fn unit_closure<'a, 'tcx>(\n /// `y` => `_y`\n ///\n /// Anything else will return `_`.\n-fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr) -> String {\n+fn let_binding_name(cx: &LateContext<'_, '_>, var_arg: &hir::Expr<'_>) -> String {\n     match &var_arg.kind {\n         hir::ExprKind::Field(_, _) => snippet(cx, var_arg.span, \"_\").replace(\".\", \"_\"),\n         hir::ExprKind::Path(_) => format!(\"_{}\", snippet(cx, var_arg.span, \"\")),\n@@ -204,7 +204,7 @@ fn suggestion_msg(function_type: &str, map_type: &str) -> String {\n     )\n }\n \n-fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr, map_args: &[hir::Expr]) {\n+fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>, expr: &hir::Expr<'_>, map_args: &[hir::Expr<'_>]) {\n     let var_arg = &map_args[0];\n \n     let (map_type, variant, lint) = if match_type(cx, cx.tables.expr_ty(var_arg), &paths::OPTION) {\n@@ -261,7 +261,7 @@ fn lint_map_unit_fn(cx: &LateContext<'_, '_>, stmt: &hir::Stmt, expr: &hir::Expr\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapUnit {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n         if stmt.span.from_expansion() {\n             return;\n         }"}, {"sha": "b0d38d179b5c945bdab6c881e4a33f4def2c9350", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -235,7 +235,7 @@ declare_lint_pass!(Matches => [\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Matches {\n }\n \n #[rustfmt::skip]\n-fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n         if let PatKind::Or(..) = arms[0].pat.kind {\n             // don't lint for or patterns for now, this makes\n@@ -281,10 +281,10 @@ fn check_single_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n \n fn check_single_match_single_pattern(\n     cx: &LateContext<'_, '_>,\n-    ex: &Expr,\n-    arms: &[Arm],\n-    expr: &Expr,\n-    els: Option<&Expr>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n ) {\n     if is_wild(&arms[1].pat) {\n         report_single_match_single_pattern(cx, ex, arms, expr, els);\n@@ -293,10 +293,10 @@ fn check_single_match_single_pattern(\n \n fn report_single_match_single_pattern(\n     cx: &LateContext<'_, '_>,\n-    ex: &Expr,\n-    arms: &[Arm],\n-    expr: &Expr,\n-    els: Option<&Expr>,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n+    els: Option<&Expr<'_>>,\n ) {\n     let lint = if els.is_some() { SINGLE_MATCH_ELSE } else { SINGLE_MATCH };\n     let els_str = els.map_or(String::new(), |els| {\n@@ -322,11 +322,11 @@ fn report_single_match_single_pattern(\n \n fn check_single_match_opt_like(\n     cx: &LateContext<'_, '_>,\n-    ex: &Expr,\n-    arms: &[Arm],\n-    expr: &Expr,\n+    ex: &Expr<'_>,\n+    arms: &[Arm<'_>],\n+    expr: &Expr<'_>,\n     ty: Ty<'_>,\n-    els: Option<&Expr>,\n+    els: Option<&Expr<'_>>,\n ) {\n     // list of candidate `Enum`s we know will never get any more members\n     let candidates = &[\n@@ -359,7 +359,7 @@ fn check_single_match_opt_like(\n     }\n }\n \n-fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     // Type of expression is `bool`.\n     if cx.tables.expr_ty(ex).kind == ty::Bool {\n         span_lint_and_then(\n@@ -419,7 +419,7 @@ fn check_match_bool(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Ex\n     }\n }\n \n-fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr, arms: &'tcx [Arm]) {\n+fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr<'_>, arms: &'tcx [Arm<'_>]) {\n     if arms.len() >= 2 && cx.tables.expr_ty(ex).is_integral() {\n         let ranges = all_ranges(cx, arms);\n         let type_ranges = type_ranges(&ranges);\n@@ -438,14 +438,14 @@ fn check_overlapping_arms<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ex: &'tcx Expr,\n     }\n }\n \n-fn is_wild(pat: &impl std::ops::Deref<Target = Pat>) -> bool {\n+fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n     match pat.kind {\n         PatKind::Wild => true,\n         _ => false,\n     }\n }\n \n-fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n+fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ex_ty = walk_ptrs_ty(cx.tables.expr_ty(ex));\n     if match_type(cx, ex_ty, &paths::RESULT) {\n         for arm in arms {\n@@ -472,7 +472,7 @@ fn check_wild_err_arm(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n     }\n }\n \n-fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n+fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>]) {\n     let ty = cx.tables.expr_ty(ex);\n     if !ty.is_enum() {\n         // If there isn't a nice closed set of possible values that can be conveniently enumerated,\n@@ -565,7 +565,7 @@ fn check_wild_enum_match(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm]) {\n }\n \n // If the block contains only a `panic!` macro (as expression or statement)\n-fn is_panic_block(block: &Block) -> bool {\n+fn is_panic_block(block: &Block<'_>) -> bool {\n     match (&block.expr, block.stmts.len(), block.stmts.first()) {\n         (&Some(ref exp), 0, _) => {\n             is_expn_of(exp.span, \"panic\").is_some() && is_expn_of(exp.span, \"unreachable\").is_none()\n@@ -577,7 +577,7 @@ fn is_panic_block(block: &Block) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if has_only_ref_pats(arms) {\n         let mut suggs = Vec::new();\n         let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n@@ -612,7 +612,7 @@ fn check_match_ref_pats(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr:\n     }\n }\n \n-fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if arms.len() == 2 && arms[0].guard.is_none() && arms[1].guard.is_none() {\n         let arm_ref: Option<BindingAnnotation> = if is_none_arm(&arms[0]) {\n             is_ref_some_arm(&arms[1])\n@@ -665,7 +665,7 @@ fn check_match_as_ref(cx: &LateContext<'_, '_>, ex: &Expr, arms: &[Arm], expr: &\n }\n \n /// Gets all arms that are unbounded `PatRange`s.\n-fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm]) -> Vec<SpannedRange<Constant>> {\n+fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm<'_>]) -> Vec<SpannedRange<Constant>> {\n     arms.iter()\n         .flat_map(|arm| {\n             if let Arm {\n@@ -730,7 +730,7 @@ fn type_ranges(ranges: &[SpannedRange<Constant>]) -> TypedRanges {\n         .collect()\n }\n \n-fn is_unit_expr(expr: &Expr) -> bool {\n+fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Tup(ref v) if v.is_empty() => true,\n         ExprKind::Block(ref b, _) if b.stmts.is_empty() && b.expr.is_none() => true,\n@@ -739,15 +739,15 @@ fn is_unit_expr(expr: &Expr) -> bool {\n }\n \n // Checks if arm has the form `None => None`\n-fn is_none_arm(arm: &Arm) -> bool {\n+fn is_none_arm(arm: &Arm<'_>) -> bool {\n     match arm.pat.kind {\n         PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n         _ => false,\n     }\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n-fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n+fn is_ref_some_arm(arm: &Arm<'_>) -> Option<BindingAnnotation> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref path, ref pats, _) = arm.pat.kind;\n         if pats.len() == 1 && match_qpath(path, &paths::OPTION_SOME);\n@@ -766,7 +766,7 @@ fn is_ref_some_arm(arm: &Arm) -> Option<BindingAnnotation> {\n     None\n }\n \n-fn has_only_ref_pats(arms: &[Arm]) -> bool {\n+fn has_only_ref_pats(arms: &[Arm<'_>]) -> bool {\n     let mapped = arms\n         .iter()\n         .map(|a| {"}, {"sha": "881ade8cd3fc10ca1f34b89c66d200a429a7b698", "filename": "clippy_lints/src/mem_discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmem_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_discriminant.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -31,7 +31,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MemDiscriminant => [MEM_DISCRIMINANT_NON_ENUM]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemDiscriminant {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;\n             // is `mem::discriminant`"}, {"sha": "4c3ba21e4f9da120a962daebe231a7ab6d5001d9", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -27,7 +27,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MemForget => [MEM_FORGET]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Call(ref path_expr, ref args) = e.kind {\n             if let ExprKind::Path(ref qpath) = path_expr.kind {\n                 if let Some(def_id) = qpath_res(cx, qpath, path_expr.hir_id).opt_def_id() {"}, {"sha": "b7b0538cbaee9dc92839b27fa73af97c743160dc", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -71,7 +71,7 @@ declare_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Check that `expr` is a call to `mem::replace()`\n             if let ExprKind::Call(ref func, ref func_args) = expr.kind;"}, {"sha": "47a77b011e451624afee7c70f01e0cce792050fc", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::{self, Ty};\n use rustc_errors::Applicability;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn lint<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'tcx>) {\n+pub fn lint<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n     if_chain! {\n         if let Some(to_string_meth_did) = cx.tables.type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);"}, {"sha": "e6ffa3328820e0b6fe533fe8a3749908841dbd3e", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::Applicability;\n use rustc_target::abi::LayoutOf;\n use syntax::ast;\n \n-pub fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[&[hir::Expr]], arith: &str) {\n+pub fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[&[hir::Expr<'_>]], arith: &str) {\n     let unwrap_arg = &args[0][1];\n     let arith_lhs = &args[1][0];\n     let arith_rhs = &args[1][1];\n@@ -82,7 +82,7 @@ enum MinMax {\n     Max,\n }\n \n-fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr) -> Option<MinMax> {\n+fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr<'_>) -> Option<MinMax> {\n     // `T::max_value()` `T::min_value()` inherent methods\n     if_chain! {\n         if let hir::ExprKind::Call(func, args) = &expr.kind;\n@@ -125,7 +125,7 @@ fn is_min_or_max<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &hir::Expr) -> Option<M\n         (0, if bits == 128 { !0 } else { (1 << bits) - 1 })\n     };\n \n-    let check_lit = |expr: &hir::Expr, check_min: bool| {\n+    let check_lit = |expr: &hir::Expr<'_>, check_min: bool| {\n         if let hir::ExprKind::Lit(lit) = &expr.kind {\n             if let ast::LitKind::Int(value, _) = lit.node {\n                 if value == maxval {\n@@ -160,7 +160,7 @@ enum Sign {\n     Neg,\n }\n \n-fn lit_sign(expr: &hir::Expr) -> Option<Sign> {\n+fn lit_sign(expr: &hir::Expr<'_>) -> Option<Sign> {\n     if let hir::ExprKind::Unary(hir::UnNeg, inner) = &expr.kind {\n         if let hir::ExprKind::Lit(..) = &inner.kind {\n             return Some(Sign::Neg);"}, {"sha": "56c958bdc88ccb0b92118bfb8d6d2cdecb259592", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 107, "deletions": 71, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -1152,7 +1152,7 @@ declare_lint_pass!(Methods => [\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n     #[allow(clippy::cognitive_complexity)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if in_macro(expr.span) {\n             return;\n         }\n@@ -1370,10 +1370,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n #[allow(clippy::too_many_lines)]\n fn lint_or_fun_call<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     method_span: Span,\n     name: &str,\n-    args: &'tcx [hir::Expr],\n+    args: &'tcx [hir::Expr<'_>],\n ) {\n     // Searches an expression for method calls or function calls that aren't ctors\n     struct FunCallFinder<'a, 'tcx> {\n@@ -1382,7 +1382,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n     }\n \n     impl<'a, 'tcx> intravisit::Visitor<'tcx> for FunCallFinder<'a, 'tcx> {\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n             let call_found = match &expr.kind {\n                 // ignore enum and struct constructors\n                 hir::ExprKind::Call(..) => !is_ctor_or_promotable_const_function(self.cx, expr),\n@@ -1408,9 +1408,9 @@ fn lint_or_fun_call<'a, 'tcx>(\n     fn check_unwrap_or_default(\n         cx: &LateContext<'_, '_>,\n         name: &str,\n-        fun: &hir::Expr,\n-        self_expr: &hir::Expr,\n-        arg: &hir::Expr,\n+        fun: &hir::Expr<'_>,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &hir::Expr<'_>,\n         or_has_args: bool,\n         span: Span,\n     ) -> bool {\n@@ -1453,8 +1453,8 @@ fn lint_or_fun_call<'a, 'tcx>(\n         name: &str,\n         method_span: Span,\n         fun_span: Span,\n-        self_expr: &hir::Expr,\n-        arg: &'tcx hir::Expr,\n+        self_expr: &hir::Expr<'_>,\n+        arg: &'tcx hir::Expr<'_>,\n         or_has_args: bool,\n         span: Span,\n     ) {\n@@ -1534,10 +1534,16 @@ fn lint_or_fun_call<'a, 'tcx>(\n \n /// Checks for the `EXPECT_FUN_CALL` lint.\n #[allow(clippy::too_many_lines)]\n-fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span: Span, name: &str, args: &[hir::Expr]) {\n+fn lint_expect_fun_call(\n+    cx: &LateContext<'_, '_>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    name: &str,\n+    args: &[hir::Expr<'_>],\n+) {\n     // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n     // `&str`\n-    fn get_arg_root<'a>(cx: &LateContext<'_, '_>, arg: &'a hir::Expr) -> &'a hir::Expr {\n+    fn get_arg_root<'a>(cx: &LateContext<'_, '_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n         let mut arg_root = arg;\n         loop {\n             arg_root = match &arg_root.kind {\n@@ -1564,7 +1570,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n \n     // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n     // converted to string.\n-    fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr) -> bool {\n+    fn requires_to_string(cx: &LateContext<'_, '_>, arg: &hir::Expr<'_>) -> bool {\n         let arg_ty = cx.tables.expr_ty(arg);\n         if match_type(cx, arg_ty, &paths::STRING) {\n             return false;\n@@ -1579,7 +1585,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n \n     fn generate_format_arg_snippet(\n         cx: &LateContext<'_, '_>,\n-        a: &hir::Expr,\n+        a: &hir::Expr<'_>,\n         applicability: &mut Applicability,\n     ) -> Vec<String> {\n         if_chain! {\n@@ -1598,7 +1604,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         }\n     }\n \n-    fn is_call(node: &hir::ExprKind) -> bool {\n+    fn is_call(node: &hir::ExprKind<'_>) -> bool {\n         match node {\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n                 is_call(&expr.kind)\n@@ -1681,7 +1687,7 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty<'_>) {\n+fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n     let ty = cx.tables.expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind {\n         if let ty::Ref(_, innermost, _) = inner.kind {\n@@ -1774,7 +1780,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Exp\n     }\n }\n \n-fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::Expr) {\n+fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(arg));\n \n     if let ty::Adt(_, subst) = obj_ty.kind {\n@@ -1805,7 +1811,7 @@ fn lint_clone_on_ref_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, arg: &hir::\n     }\n }\n \n-fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let arg = &args[1];\n     if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n         let target = &arglists[0][0];\n@@ -1836,14 +1842,14 @@ fn lint_string_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::E\n     }\n }\n \n-fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_extend(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n     if match_type(cx, obj_ty, &paths::STRING) {\n         lint_string_extend(cx, expr, args);\n     }\n }\n \n-fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, source: &hir::Expr, unwrap: &hir::Expr) {\n+fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, source: &hir::Expr<'_>, unwrap: &hir::Expr<'_>) {\n     if_chain! {\n         let source_type = cx.tables.expr_ty(source);\n         if let ty::Adt(def, substs) = source_type.kind;\n@@ -1863,7 +1869,11 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, source: &hir:\n     }\n }\n \n-fn lint_iter_cloned_collect<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr]) {\n+fn lint_iter_cloned_collect<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &hir::Expr<'_>,\n+    iter_args: &'tcx [hir::Expr<'_>],\n+) {\n     if_chain! {\n         if is_type_diagnostic_item(cx, cx.tables.expr_ty(expr), Symbol::intern(\"vec_type\"));\n         if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0]));\n@@ -1884,11 +1894,11 @@ fn lint_iter_cloned_collect<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Ex\n     }\n }\n \n-fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args: &[hir::Expr], fold_span: Span) {\n+fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, fold_args: &[hir::Expr<'_>], fold_span: Span) {\n     fn check_fold_with_op(\n         cx: &LateContext<'_, '_>,\n-        expr: &hir::Expr,\n-        fold_args: &[hir::Expr],\n+        expr: &hir::Expr<'_>,\n+        fold_args: &[hir::Expr<'_>],\n         fold_span: Span,\n         op: hir::BinOpKind,\n         replacement_method_name: &str,\n@@ -1971,7 +1981,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     }\n }\n \n-fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, args: &'tcx [hir::Expr]) {\n+fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr<'_>, args: &'tcx [hir::Expr<'_>]) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         use crate::consts::{constant, Constant};\n         if let Some((Constant::Int(0), _)) = constant(cx, cx.tables, &args[1]) {\n@@ -1985,7 +1995,12 @@ fn lint_step_by<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, args: &'\n     }\n }\n \n-fn lint_iter_nth<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr], is_mut: bool) {\n+fn lint_iter_nth<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &hir::Expr<'_>,\n+    iter_args: &'tcx [hir::Expr<'_>],\n+    is_mut: bool,\n+) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -2008,7 +2023,12 @@ fn lint_iter_nth<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_ar\n     );\n }\n \n-fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_args: &'tcx [hir::Expr], is_mut: bool) {\n+fn lint_get_unwrap<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &hir::Expr<'_>,\n+    get_args: &'tcx [hir::Expr<'_>],\n+    is_mut: bool,\n+) {\n     // Note: we don't want to lint `get_mut().unwrap` for `HashMap` or `BTreeMap`,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n@@ -2081,7 +2101,7 @@ fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_a\n     );\n }\n \n-fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n+fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n     // lint if caller of skip is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         span_lint(\n@@ -2095,9 +2115,9 @@ fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n \n fn derefs_to_slice<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'tcx>,\n     ty: Ty<'tcx>,\n-) -> Option<&'tcx hir::Expr> {\n+) -> Option<&'tcx hir::Expr<'tcx>> {\n     fn may_slice<'a>(cx: &LateContext<'_, 'a>, ty: Ty<'a>) -> bool {\n         match ty.kind {\n             ty::Slice(_) => true,\n@@ -2132,7 +2152,7 @@ fn derefs_to_slice<'a, 'tcx>(\n }\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::Expr]) {\n+fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, unwrap_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -2159,7 +2179,7 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::E\n }\n \n /// lint use of `expect()` for `Option`s and `Result`s\n-fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, expect_args: &[hir::Expr]) {\n+fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, expect_args: &[hir::Expr<'_>]) {\n     let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&expect_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -2184,7 +2204,7 @@ fn lint_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, expect_args: &[hir::E\n }\n \n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n+fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, ok_args: &[hir::Expr<'_>]) {\n     if_chain! {\n         // lint if the caller of `ok()` is a `Result`\n         if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT);\n@@ -2204,7 +2224,7 @@ fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Ex\n }\n \n /// lint use of `map().flatten()` for `Iterators`\n-fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_args: &'tcx [hir::Expr]) {\n+fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>, map_args: &'tcx [hir::Expr<'_>]) {\n     // lint if caller of `.map().flatten()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `map(..).flatten()` on an `Iterator`. \\\n@@ -2226,9 +2246,9 @@ fn lint_map_flatten<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n /// lint use of `map().unwrap_or_else()` for `Option`s and `Result`s\n fn lint_map_unwrap_or_else<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    map_args: &'tcx [hir::Expr],\n-    unwrap_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    map_args: &'tcx [hir::Expr<'_>],\n+    unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n     let is_option = match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION);\n@@ -2294,7 +2314,11 @@ fn lint_map_unwrap_or_else<'a, 'tcx>(\n }\n \n /// lint use of `_.map_or(None, _)` for `Option`s\n-fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, map_or_args: &'tcx [hir::Expr]) {\n+fn lint_map_or_none<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    map_or_args: &'tcx [hir::Expr<'_>],\n+) {\n     if match_type(cx, cx.tables.expr_ty(&map_or_args[0]), &paths::OPTION) {\n         // check if the first non-self argument to map_or() is None\n         let map_or_arg_is_none = if let hir::ExprKind::Path(ref qpath) = map_or_args[1].kind {\n@@ -2323,7 +2347,7 @@ fn lint_map_or_none<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n }\n \n /// Lint use of `_.and_then(|x| Some(y))` for `Option`s\n-fn lint_option_and_then_some(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn lint_option_and_then_some(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     const LINT_MSG: &str = \"using `Option.and_then(|x| Some(y))`, which is more succinctly expressed as `map(|x| y)`\";\n     const NO_OP_MSG: &str = \"using `Option.and_then(Some)`, which is a no-op\";\n \n@@ -2390,7 +2414,11 @@ fn lint_option_and_then_some(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &\n }\n \n /// lint use of `filter().next()` for `Iterators`\n-fn lint_filter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, filter_args: &'tcx [hir::Expr]) {\n+fn lint_filter_next<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_args: &'tcx [hir::Expr<'_>],\n+) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n@@ -2415,9 +2443,9 @@ fn lint_filter_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n /// lint use of `filter().map()` for `Iterators`\n fn lint_filter_map<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n@@ -2428,7 +2456,11 @@ fn lint_filter_map<'a, 'tcx>(\n }\n \n /// lint use of `filter_map().next()` for `Iterators`\n-fn lint_filter_map_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, filter_args: &'tcx [hir::Expr]) {\n+fn lint_filter_map_next<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx hir::Expr<'_>,\n+    filter_args: &'tcx [hir::Expr<'_>],\n+) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter_map(p).next()` on an `Iterator`. This is more succinctly expressed by calling \\\n                    `.find_map(p)` instead.\";\n@@ -2451,9 +2483,9 @@ fn lint_filter_map_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::E\n /// lint use of `find().map()` for `Iterators`\n fn lint_find_map<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _find_args: &'tcx [hir::Expr],\n-    map_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    _find_args: &'tcx [hir::Expr<'_>],\n+    map_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, &map_args[0], &paths::ITERATOR) {\n@@ -2466,9 +2498,9 @@ fn lint_find_map<'a, 'tcx>(\n /// lint use of `filter_map().map()` for `Iterators`\n fn lint_filter_map_map<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if caller of `.filter().map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n@@ -2481,9 +2513,9 @@ fn lint_filter_map_map<'a, 'tcx>(\n /// lint use of `filter().flat_map()` for `Iterators`\n fn lint_filter_flat_map<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n@@ -2497,9 +2529,9 @@ fn lint_filter_flat_map<'a, 'tcx>(\n /// lint use of `filter_map().flat_map()` for `Iterators`\n fn lint_filter_map_flat_map<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    _filter_args: &'tcx [hir::Expr],\n-    _map_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    _filter_args: &'tcx [hir::Expr<'_>],\n+    _map_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n@@ -2513,8 +2545,8 @@ fn lint_filter_map_flat_map<'a, 'tcx>(\n /// lint use of `flat_map` for `Iterators` where `flatten` would be sufficient\n fn lint_flat_map_identity<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n-    flat_map_args: &'tcx [hir::Expr],\n+    expr: &'tcx hir::Expr<'_>,\n+    flat_map_args: &'tcx [hir::Expr<'_>],\n     flat_map_span: Span,\n ) {\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n@@ -2562,10 +2594,10 @@ fn lint_flat_map_identity<'a, 'tcx>(\n /// lint searching an Iterator followed by `is_some()`\n fn lint_search_is_some<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'_>,\n     search_method: &str,\n-    search_args: &'tcx [hir::Expr],\n-    is_some_args: &'tcx [hir::Expr],\n+    search_args: &'tcx [hir::Expr<'_>],\n+    is_some_args: &'tcx [hir::Expr<'_>],\n     method_span: Span,\n ) {\n     // lint if caller of search is an Iterator\n@@ -2618,9 +2650,9 @@ fn lint_search_is_some<'a, 'tcx>(\n /// Used for `lint_binary_expr_with_method_call`.\n #[derive(Copy, Clone)]\n struct BinaryExprInfo<'a> {\n-    expr: &'a hir::Expr,\n-    chain: &'a hir::Expr,\n-    other: &'a hir::Expr,\n+    expr: &'a hir::Expr<'a>,\n+    chain: &'a hir::Expr<'a>,\n+    other: &'a hir::Expr<'a>,\n     eq: bool,\n }\n \n@@ -2751,7 +2783,11 @@ fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &\n }\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx hir::Expr, arg: &'tcx hir::Expr) {\n+fn lint_single_char_pattern<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    _expr: &'tcx hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n+) {\n     if_chain! {\n         if let hir::ExprKind::Lit(lit) = &arg.kind;\n         if let ast::LitKind::Str(r, style) = lit.node;\n@@ -2782,7 +2818,7 @@ fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, _expr: &'tcx h\n }\n \n /// Checks for the `USELESS_ASREF` lint.\n-fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr, call_name: &str, as_ref_args: &[hir::Expr]) {\n+fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, call_name: &str, as_ref_args: &[hir::Expr<'_>]) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n     if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n@@ -2831,7 +2867,7 @@ fn ty_has_iter_method(cx: &LateContext<'_, '_>, self_ref_ty: Ty<'_>) -> Option<(\n     })\n }\n \n-fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_>, method_span: Span) {\n+fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n     if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n         return;\n     }\n@@ -2852,7 +2888,7 @@ fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_\n }\n \n /// lint for `MaybeUninit::uninit().assume_init()` (we already have the latter)\n-fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr, outer: &hir::Expr) {\n+fn lint_maybe_uninit(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, outer: &hir::Expr<'_>) {\n     if_chain! {\n         if let hir::ExprKind::Call(ref callee, ref args) = expr.kind;\n         if args.is_empty();\n@@ -2882,7 +2918,7 @@ fn is_maybe_uninit_ty_valid(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n     }\n }\n \n-fn lint_suspicious_map(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n+fn lint_suspicious_map(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n     span_help_and_lint(\n         cx,\n         SUSPICIOUS_MAP,\n@@ -3095,13 +3131,13 @@ fn is_bool(ty: &hir::Ty) -> bool {\n }\n \n // Returns `true` if `expr` contains a return expression\n-fn contains_return(expr: &hir::Expr) -> bool {\n+fn contains_return(expr: &hir::Expr<'_>) -> bool {\n     struct RetCallFinder {\n         found: bool,\n     }\n \n     impl<'tcx> intravisit::Visitor<'tcx> for RetCallFinder {\n-        fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n             if self.found {\n                 return;\n             }\n@@ -3122,7 +3158,7 @@ fn contains_return(expr: &hir::Expr) -> bool {\n     visitor.found\n }\n \n-fn check_pointer_offset(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+fn check_pointer_offset(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if_chain! {\n         if args.len() == 2;\n         if let ty::RawPtr(ty::TypeAndMut { ref ty, .. }) = cx.tables.expr_ty(&args[0]).kind;"}, {"sha": "b1647b032504da4494c89d2f7c968b5888dd426c", "filename": "clippy_lints/src/methods/option_map_unwrap_or.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_unwrap_or.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -11,9 +11,9 @@ use super::OPTION_MAP_UNWRAP_OR;\n /// lint use of `map().unwrap_or()` for `Option`s\n pub(super) fn lint<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &hir::Expr,\n-    map_args: &'tcx [hir::Expr],\n-    unwrap_args: &'tcx [hir::Expr],\n+    expr: &hir::Expr<'_>,\n+    map_args: &'tcx [hir::Expr<'_>],\n+    unwrap_args: &'tcx [hir::Expr<'_>],\n ) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tables.expr_ty(&map_args[0]), &paths::OPTION) {"}, {"sha": "567b3db1e82c4d597aea0e798050d9d75595ca88", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -10,7 +10,7 @@ use if_chain::if_chain;\n \n use super::UNNECESSARY_FILTER_MAP;\n \n-pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     if !match_trait_method(cx, expr, &paths::ITERATOR) {\n         return;\n     }\n@@ -54,7 +54,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n fn check_expression<'a, 'tcx>(\n     cx: &'a LateContext<'a, 'tcx>,\n     arg_id: hir::HirId,\n-    expr: &'tcx hir::Expr,\n+    expr: &'tcx hir::Expr<'_>,\n ) -> (bool, bool) {\n     match &expr.kind {\n         hir::ExprKind::Call(ref func, ref args) => {\n@@ -87,10 +87,10 @@ fn check_expression<'a, 'tcx>(\n                 (false, false)\n             }\n         },\n-        hir::ExprKind::Match(_, ref arms, _) => {\n+        hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n-            for arm in arms {\n+            for arm in *arms {\n                 let (m, f) = check_expression(cx, arg_id, &arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> ReturnVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         if let hir::ExprKind::Ret(Some(expr)) = &expr.kind {\n             let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n             self.found_mapping |= found_mapping;"}, {"sha": "a838bb0f3d89b9ddf256620eed7b57c5b2801e0a", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -29,7 +29,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MinMaxPass => [MIN_MAX]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n             if let Some((inner_max, inner_c, ie)) = min_max(cx, oe) {\n                 if outer_max == inner_max {\n@@ -60,7 +60,7 @@ enum MinMax {\n     Max,\n }\n \n-fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if let ExprKind::Call(ref path, ref args) = expr.kind {\n         if let ExprKind::Path(ref qpath) = path.kind {\n             cx.tables.qpath_res(qpath, path.hir_id).opt_def_id().and_then(|def_id| {\n@@ -80,7 +80,11 @@ fn min_max<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(MinMax, Cons\n     }\n }\n \n-fn fetch_const<'a>(cx: &LateContext<'_, '_>, args: &'a [Expr], m: MinMax) -> Option<(MinMax, Constant, &'a Expr)> {\n+fn fetch_const<'a>(\n+    cx: &LateContext<'_, '_>,\n+    args: &'a [Expr<'a>],\n+    m: MinMax,\n+) -> Option<(MinMax, Constant, &'a Expr<'a>)> {\n     if args.len() != 2 {\n         return None;\n     }"}, {"sha": "295794e8c38f3cf9807ed6da25d6a8b238df6952", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n         if_chain! {\n             if let StmtKind::Local(ref local) = stmt.kind;\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n         };\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n             ExprKind::Cast(ref e, ref ty) => {\n                 check_cast(cx, expr.span, e, ty);\n@@ -440,7 +440,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MiscLints {\n     }\n }\n \n-fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr, cmp_expr: &Expr) {\n+fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n         if let Some((value, _)) = constant(cx, cx.tables, expr);\n@@ -463,15 +463,15 @@ fn check_nan(cx: &LateContext<'_, '_>, expr: &Expr, cmp_expr: &Expr) {\n     }\n }\n \n-fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n+fn is_named_constant<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     if let Some((_, res)) = constant(cx, cx.tables, expr) {\n         res\n     } else {\n         false\n     }\n }\n \n-fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n+fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> bool {\n     match constant(cx, cx.tables, expr) {\n         Some((Constant::F32(f), _)) => f == 0.0 || f.is_infinite(),\n         Some((Constant::F64(f), _)) => f == 0.0 || f.is_infinite(),\n@@ -480,7 +480,7 @@ fn is_allowed<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n }\n \n // Return true if `expr` is the result of `signum()` invoked on a float value.\n-fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     // The negation of a signum is still a signum\n     if let ExprKind::Unary(UnNeg, ref child_expr) = expr.kind {\n         return is_signum(cx, &child_expr);\n@@ -498,11 +498,11 @@ fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n     false\n }\n \n-fn is_float(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn is_float(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).kind, ty::Float(_))\n }\n \n-fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n+fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n@@ -587,7 +587,7 @@ fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr, other: &Expr) {\n /// Heuristic to see if an expression is used. Should be compatible with\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n-fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn is_used(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     if let Some(parent) = get_parent_expr(cx, expr) {\n         match parent.kind {\n             ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => {\n@@ -602,7 +602,7 @@ fn is_used(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n \n /// Tests whether an expression is in a macro expansion (e.g., something\n /// generated by `#[derive(...)]` or the like).\n-fn in_attributes_expansion(expr: &Expr) -> bool {\n+fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use syntax_pos::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n@@ -626,7 +626,7 @@ fn non_macro_local(cx: &LateContext<'_, '_>, res: def::Res) -> bool {\n     }\n }\n \n-fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr, ty: &Ty) {\n+fn check_cast(cx: &LateContext<'_, '_>, span: Span, e: &Expr<'_>, ty: &Ty) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n         if let ExprKind::Lit(ref lit) = e.kind;"}, {"sha": "d62cea7cdb2981b55ce56f1aadbf21b2777070a6", "filename": "clippy_lints/src/mul_add.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmul_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmul_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmul_add.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -44,12 +44,15 @@ declare_clippy_lint! {\n \n declare_lint_pass!(MulAddCheck => [MANUAL_MUL_ADD]);\n \n-fn is_float<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr) -> bool {\n+fn is_float<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n     cx.tables.expr_ty(expr).is_floating_point()\n }\n \n // Checks whether expression is multiplication of two floats\n-fn is_float_mult_expr<'a, 'tcx, 'b>(cx: &LateContext<'a, 'tcx>, expr: &'b Expr) -> Option<(&'b Expr, &'b Expr)> {\n+fn is_float_mult_expr<'a, 'tcx, 'b>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'b Expr<'b>,\n+) -> Option<(&'b Expr<'b>, &'b Expr<'b>)> {\n     if let ExprKind::Binary(op, lhs, rhs) = &expr.kind {\n         if let BinOpKind::Mul = op.node {\n             if is_float(cx, &lhs) && is_float(cx, &rhs) {\n@@ -62,7 +65,7 @@ fn is_float_mult_expr<'a, 'tcx, 'b>(cx: &LateContext<'a, 'tcx>, expr: &'b Expr)\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MulAddCheck {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(op, lhs, rhs) = &expr.kind {\n             if let BinOpKind::Add = op.node {\n                 //Converts mult_lhs * mult_rhs + rhs to mult_lhs.mult_add(mult_rhs, rhs)"}, {"sha": "03f9d522f0a4081830e2f82e0b49c8eaf8a95a28", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableKeyType {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &hir::Local) {\n+    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &hir::Local<'_>) {\n         if let hir::PatKind::Wild = local.pat.kind {\n             return;\n         }"}, {"sha": "99c37c82ad5831144f9045bcdb44044071520c52", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -28,7 +28,7 @@ declare_clippy_lint! {\n declare_lint_pass!(MutMut => [MUT_MUT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutMut {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block<'_>) {\n         intravisit::walk_block(&mut MutVisitor { cx }, block);\n     }\n \n@@ -44,7 +44,7 @@ pub struct MutVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         if in_external_macro(self.cx.sess(), expr.span) {\n             return;\n         }"}, {"sha": "6e5c5102a4ce00c9956b699702af0c0150a73110", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -27,7 +27,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UnnecessaryMutPassed => [UNNECESSARY_MUT_PASSED]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         match e.kind {\n             ExprKind::Call(ref fn_expr, ref arguments) => {\n                 if let ExprKind::Path(ref path) = fn_expr.kind {\n@@ -50,7 +50,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     }\n }\n \n-fn check_arguments<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arguments: &[Expr], type_definition: Ty<'tcx>, name: &str) {\n+fn check_arguments<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    arguments: &[Expr<'_>],\n+    type_definition: Ty<'tcx>,\n+    name: &str,\n+) {\n     match type_definition.kind {\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let parameters = type_definition.fn_sig(cx.tcx).skip_binder().inputs();"}, {"sha": "5844de136b9106a80ba315c934d0df726295b00b", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -36,7 +36,7 @@ declare_lint_pass!(DebugAssertWithMutCall => [DEBUG_ASSERT_WITH_MUT_CALL]);\n const DEBUG_MACRO_NAMES: [&str; 3] = [\"debug_assert\", \"debug_assert_eq\", \"debug_assert_ne\"];\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DebugAssertWithMutCall {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         for dmn in &DEBUG_MACRO_NAMES {\n             if is_direct_expn_of(e.span, dmn).is_some() {\n                 if let Some(span) = extract_call(cx, e) {\n@@ -54,7 +54,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DebugAssertWithMutCall {\n \n //HACK(hellow554): remove this when #4694 is implemented\n #[allow(clippy::cognitive_complexity)]\n-fn extract_call<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<Span> {\n+fn extract_call<'a, 'tcx>(cx: &'a LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) -> Option<Span> {\n     if_chain! {\n         if let ExprKind::Block(ref block, _) = e.kind;\n         if block.stmts.len() == 1;\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> MutArgVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         match expr.kind {\n             ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, _) => {\n                 self.found = true;"}, {"sha": "08c94be54ff2aab4fa1d433ca7f80247d36dbb05", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -56,7 +56,7 @@ declare_clippy_lint! {\n declare_lint_pass!(Mutex => [MUTEX_ATOMIC, MUTEX_INTEGER]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Mutex {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         let ty = cx.tables.expr_ty(expr);\n         if let ty::Adt(_, subst) = ty.kind {\n             if match_type(cx, ty, &paths::MUTEX) {"}, {"sha": "a9fc033f7245244db35091e7d7f9feb988ad70d0", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -62,7 +62,7 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessBool => [NEEDLESS_BOOL]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         use self::Expression::*;\n         if let Some((ref pred, ref then_block, Some(ref else_expr))) = higher::if_block(&e) {\n             let reduce = |ret, not| {\n@@ -122,7 +122,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n declare_lint_pass!(BoolComparison => [BOOL_COMPARISON]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() {\n             return;\n         }\n@@ -185,7 +185,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n \n fn check_comparison<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    e: &'tcx Expr,\n+    e: &'tcx Expr<'_>,\n     left_true: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n     left_false: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n     right_true: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n@@ -232,8 +232,8 @@ fn check_comparison<'a, 'tcx>(\n \n fn suggest_bool_comparison<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    e: &'tcx Expr,\n-    expr: &Expr,\n+    e: &'tcx Expr<'_>,\n+    expr: &Expr<'_>,\n     mut applicability: Applicability,\n     message: &str,\n     conv_hint: impl FnOnce(Sugg<'a>) -> Sugg<'a>,\n@@ -256,7 +256,7 @@ enum Expression {\n     Other,\n }\n \n-fn fetch_bool_block(block: &Block) -> Expression {\n+fn fetch_bool_block(block: &Block<'_>) -> Expression {\n     match (&*block.stmts, block.expr.as_ref()) {\n         (&[], Some(e)) => fetch_bool_expr(&**e),\n         (&[ref e], None) => {\n@@ -274,7 +274,7 @@ fn fetch_bool_block(block: &Block) -> Expression {\n     }\n }\n \n-fn fetch_bool_expr(expr: &Expr) -> Expression {\n+fn fetch_bool_expr(expr: &Expr<'_>) -> Expression {\n     match expr.kind {\n         ExprKind::Block(ref block, _) => fetch_bool_block(block),\n         ExprKind::Lit(ref lit_ptr) => {"}, {"sha": "a74b6dbf317c4775a480c8ae222628432a35939c", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -38,7 +38,7 @@ pub struct NeedlessBorrow {\n impl_lint_pass!(NeedlessBorrow => [NEEDLESS_BORROW]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if e.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n             }\n         }\n     }\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n         if pat.span.from_expansion() || self.derived_item.is_some() {\n             return;\n         }"}, {"sha": "bf7e44a1fcc3e9400671cf830e958b61cba023cd", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -54,7 +54,7 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessBorrowedRef => [NEEDLESS_BORROWED_REFERENCE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrowedRef {\n-    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat<'_>) {\n         if pat.span.from_expansion() {\n             // OK, simple enough, lints doesn't check in macro.\n             return;"}, {"sha": "dfcba290421532f50a21973266b8bf15cab2274b", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -36,7 +36,7 @@ declare_clippy_lint! {\n declare_lint_pass!(NeedlessUpdate => [NEEDLESS_UPDATE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessUpdate {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Struct(_, ref fields, Some(ref base)) = expr.kind {\n             let ty = cx.tables.expr_ty(expr);\n             if let ty::Adt(def, _) = ty.kind {"}, {"sha": "4e6bcc6f1d9180a758fb32842094e0e5173b301c", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -46,7 +46,7 @@ declare_clippy_lint! {\n declare_lint_pass!(NoNegCompOpForPartialOrd => [NEG_CMP_OP_ON_PARTIAL_ORD]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoNegCompOpForPartialOrd {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n \n             if !in_external_macro(cx.sess(), expr.span);"}, {"sha": "fbdf5d8c132b572a585eb90aab70e10f17987396", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -28,7 +28,7 @@ declare_lint_pass!(NegMultiply => [NEG_MULTIPLY]);\n \n #[allow(clippy::match_same_arms)]\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref op, ref left, ref right) = e.kind {\n             if BinOpKind::Mul == op.node {\n                 match (&left.kind, &right.kind) {\n@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n     }\n }\n \n-fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr, exp: &Expr) {\n+fn check_mul(cx: &LateContext<'_, '_>, span: Span, lit: &Expr<'_>, exp: &Expr<'_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref l) = lit.kind;\n         if let Constant::Int(1) = consts::lit_to_constant(&l.node, cx.tables.expr_ty_opt(lit));"}, {"sha": "afd0be851d8a6abd74fe801fb7965af181c8c6f2", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n     \"outer expressions with no effect\"\n }\n \n-fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n     }\n@@ -89,7 +89,7 @@ fn has_no_effect(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n declare_lint_pass!(NoEffect => [NO_EFFECT, UNNECESSARY_OPERATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoEffect {\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Semi(ref expr) = stmt.kind {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n@@ -120,7 +120,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NoEffect {\n     }\n }\n \n-fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<Vec<&'a Expr>> {\n+fn reduce_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'a>) -> Option<Vec<&'a Expr<'a>>> {\n     if expr.span.from_expansion() {\n         return None;\n     }"}, {"sha": "b454cfbac67162dfec93e0258084fb42d65b035b", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Path(qpath) = &expr.kind {\n             // Only lint if we use the const item inside a function.\n             if in_constant(cx, expr.hir_id) {"}, {"sha": "e02cc395d810d448b3772d228902f914f8e88cff", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -38,7 +38,7 @@ declare_clippy_lint! {\n declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n             if let ExprKind::Match(ref op, ref body, ref source) = expr.kind; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let"}, {"sha": "545def3567e05d49f768ebbafe61fe051fa28fb0", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -29,7 +29,7 @@ declare_clippy_lint! {\n declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OpenOptions {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref arguments) = e.kind {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n@@ -57,7 +57,7 @@ enum OpenOption {\n     Append,\n }\n \n-fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr, options: &mut Vec<(OpenOption, Argument)>) {\n+fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n     if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.kind {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n "}, {"sha": "4c67539f62b322b60260ac4715b11e63a6a3b1af", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -28,7 +28,7 @@ declare_lint_pass!(OverflowCheckConditional => [OVERFLOW_CHECK_CONDITIONAL]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         let eq = |l, r| SpanlessEq::new(cx).eq_path_segment(l, r);\n         if_chain! {\n             if let ExprKind::Binary(ref op, ref first, ref second) = expr.kind;"}, {"sha": "e63bfd0135fb1a41a164d23d47f27fed0bcb97b6", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -93,7 +93,7 @@ declare_clippy_lint! {\n declare_lint_pass!(PanicUnimplemented => [PANIC_PARAMS, UNIMPLEMENTED, UNREACHABLE, TODO, PANIC]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PanicUnimplemented {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Block(ref block, _) = expr.kind;\n             if let Some(ref ex) = block.expr;\n@@ -123,7 +123,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PanicUnimplemented {\n     }\n }\n \n-fn get_outer_span(expr: &Expr) -> Span {\n+fn get_outer_span(expr: &Expr<'_>) -> Span {\n     if_chain! {\n         if expr.span.from_expansion();\n         let first = expr.span.ctxt().outer_expn_data();\n@@ -137,7 +137,7 @@ fn get_outer_span(expr: &Expr) -> Span {\n     }\n }\n \n-fn match_panic(params: &[Expr], expr: &Expr, cx: &LateContext<'_, '_>) {\n+fn match_panic(params: &[Expr<'_>], expr: &Expr<'_>, cx: &LateContext<'_, '_>) {\n     if_chain! {\n         if let ExprKind::Lit(ref lit) = params[0].kind;\n         if is_direct_expn_of(expr.span, \"panic\").is_some();"}, {"sha": "2a9d31ec937ecf337905158a4cc784bd65257238", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathBufPushOverwrite {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n             if path.ident.name == sym!(push);"}, {"sha": "609b3bbc1c2c5c44c78704f5c35fb06d41f49b8a", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ptr {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref op, ref l, ref r) = expr.kind {\n             if (op.node == BinOpKind::Eq || op.node == BinOpKind::Ne) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(\n@@ -293,7 +293,7 @@ fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n     }\n }\n \n-fn is_null_path(expr: &Expr) -> bool {\n+fn is_null_path(expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(ref pathexp, ref args) = expr.kind {\n         if args.is_empty() {\n             if let ExprKind::Path(ref path) = pathexp.kind {"}, {"sha": "f7c42c356bee49c2732fec4d2b851853aac7be59", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -45,7 +45,7 @@ declare_clippy_lint! {\n declare_lint_pass!(PtrOffsetWithCast => [PTR_OFFSET_WITH_CAST]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PtrOffsetWithCast {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // Check if the expressions is a ptr.offset or ptr.wrapping_offset method call\n         let (receiver_expr, arg_expr, method) = match expr_as_ptr_offset_call(cx, expr) {\n             Some(call_arg) => call_arg,\n@@ -76,7 +76,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PtrOffsetWithCast {\n }\n \n // If the given expression is a cast from a usize, return the lhs of the cast\n-fn expr_as_cast_from_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<&'tcx Expr> {\n+fn expr_as_cast_from_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n     if let ExprKind::Cast(ref cast_lhs_expr, _) = expr.kind {\n         if is_expr_ty_usize(cx, &cast_lhs_expr) {\n             return Some(cast_lhs_expr);\n@@ -89,8 +89,8 @@ fn expr_as_cast_from_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Exp\n // receiver, the arg of the method call, and the method.\n fn expr_as_ptr_offset_call<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-) -> Option<(&'tcx Expr, &'tcx Expr, Method)> {\n+    expr: &'tcx Expr<'_>,\n+) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n     if let ExprKind::MethodCall(ref path_segment, _, ref args) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n             if path_segment.ident.name == sym!(offset) {\n@@ -105,20 +105,20 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n }\n \n // Is the type of the expression a usize?\n-fn is_expr_ty_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr) -> bool {\n+fn is_expr_ty_usize<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n     cx.tables.expr_ty(expr) == cx.tcx.types.usize\n }\n \n // Is the type of the expression a raw pointer?\n-fn is_expr_ty_raw_ptr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr) -> bool {\n+fn is_expr_ty_raw_ptr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr<'_>) -> bool {\n     cx.tables.expr_ty(expr).is_unsafe_ptr()\n }\n \n fn build_suggestion<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     method: Method,\n-    receiver_expr: &Expr,\n-    cast_lhs_expr: &Expr,\n+    receiver_expr: &Expr<'_>,\n+    cast_lhs_expr: &Expr<'_>,\n ) -> Option<String> {\n     let receiver = utils::snippet_opt(cx, receiver_expr.span)?;\n     let cast_lhs = utils::snippet_opt(cx, cast_lhs_expr.span)?;"}, {"sha": "cd06dad3a813b9bb66fba13d7f2a479b5e9f70dc", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -1,7 +1,6 @@\n use if_chain::if_chain;\n use rustc::declare_lint_pass;\n use rustc::hir::def::{DefKind, Res};\n-use rustc::hir::ptr::P;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc_errors::Applicability;\n@@ -47,7 +46,7 @@ impl QuestionMark {\n     /// ```\n     ///\n     /// If it matches, it will suggest to use the question mark operator instead\n-    fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr) {\n+    fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some((if_expr, body, else_)) = higher::if_block(&expr);\n             if let ExprKind::MethodCall(segment, _, args) = &if_expr.kind;\n@@ -62,7 +61,7 @@ impl QuestionMark {\n                 if let Some(else_) = else_ {\n                     if_chain! {\n                         if let ExprKind::Block(block, None) = &else_.kind;\n-                        if block.stmts.len() == 0;\n+                        if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n                         if SpanlessEq::new(cx).ignore_fn().eq_expr(subject, block_expr);\n                         then {\n@@ -95,19 +94,19 @@ impl QuestionMark {\n         }\n     }\n \n-    fn moves_by_default(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n+    fn moves_by_default(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n         !expr_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, expression.span)\n     }\n \n-    fn is_option(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n+    fn is_option(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n         let expr_ty = cx.tables.expr_ty(expression);\n \n         match_type(cx, expr_ty, &OPTION)\n     }\n \n-    fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr) -> bool {\n+    fn expression_returns_none(cx: &LateContext<'_, '_>, expression: &Expr<'_>) -> bool {\n         match expression.kind {\n             ExprKind::Block(ref block, _) => {\n                 if let Some(return_expression) = Self::return_expression(block) {\n@@ -130,14 +129,14 @@ impl QuestionMark {\n         }\n     }\n \n-    fn return_expression(block: &Block) -> Option<&P<Expr>> {\n+    fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         // Check if last expression is a return statement. Then, return the expression\n         if_chain! {\n             if block.stmts.len() == 1;\n             if let Some(expr) = block.stmts.iter().last();\n             if let StmtKind::Semi(ref expr) = expr.kind;\n-            if let ExprKind::Ret(ref ret_expr) = expr.kind;\n-            if let &Some(ref ret_expr) = ret_expr;\n+            if let ExprKind::Ret(ret_expr) = expr.kind;\n+            if let Some(ret_expr) = ret_expr;\n \n             then {\n                 return Some(ret_expr);\n@@ -146,7 +145,7 @@ impl QuestionMark {\n \n         // Check for `return` without a semicolon.\n         if_chain! {\n-            if block.stmts.len() == 0;\n+            if block.stmts.is_empty();\n             if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.kind);\n             then {\n                 return Some(ret_expr);\n@@ -158,7 +157,7 @@ impl QuestionMark {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for QuestionMark {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         Self::check_is_none_and_early_return_none(cx, expr);\n     }\n }"}, {"sha": "11cb1d39850336d38d30942f8f888d7ceedfbcae", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -88,7 +88,7 @@ declare_lint_pass!(Ranges => [\n ]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind {\n             let name = path.ident.as_str();\n             if name == \"zip\" && args.len() == 2 {\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n }\n \n // exclusive range plus one: `x..(y+1)`\n-fn check_exclusive_range_plus_one(cx: &LateContext<'_, '_>, expr: &Expr) {\n+fn check_exclusive_range_plus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some(higher::Range {\n             start,\n@@ -174,7 +174,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_, '_>, expr: &Expr) {\n }\n \n // inclusive range minus one: `x..=(y-1)`\n-fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr) {\n+fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if_chain! {\n         if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(cx, expr);\n         if let Some(y) = y_minus_one(cx, end);\n@@ -199,7 +199,7 @@ fn check_inclusive_range_minus_one(cx: &LateContext<'_, '_>, expr: &Expr) {\n     }\n }\n \n-fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr) -> Option<&'t Expr> {\n+fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n     match expr.kind {\n         ExprKind::Binary(\n             Spanned {\n@@ -220,7 +220,7 @@ fn y_plus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr) -> Option<&'t Expr>\n     }\n }\n \n-fn y_minus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr) -> Option<&'t Expr> {\n+fn y_minus_one<'t>(cx: &LateContext<'_, '_>, expr: &'t Expr<'_>) -> Option<&'t Expr<'t>> {\n     match expr.kind {\n         ExprKind::Binary(\n             Spanned {"}, {"sha": "cd0d6c8cda7724189af19f8d84655de721372d6c", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -1,6 +1,5 @@\n use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n use rustc::declare_lint_pass;\n-use rustc::hir::ptr::P;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc_errors::Applicability;\n@@ -46,8 +45,8 @@ declare_clippy_lint! {\n declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPatternMatching {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Match(ref op, ref arms, ref match_source) = expr.kind {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n             match match_source {\n                 MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n                 MatchSource::IfLetDesugar { contains_else_clause } => {\n@@ -61,9 +60,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantPatternMatching {\n \n fn find_sugg_for_if_let<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n-    op: &P<Expr>,\n-    arms: &HirVec<Arm>,\n+    expr: &'tcx Expr<'_>,\n+    op: &Expr<'_>,\n+    arms: &[Arm<'_>],\n     has_else: bool,\n ) {\n     let good_method = match arms[0].pat.kind {\n@@ -107,7 +106,7 @@ fn find_sugg_for_if_let<'a, 'tcx>(\n     );\n }\n \n-fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, op: &P<Expr>, arms: &HirVec<Arm>) {\n+fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n     if arms.len() == 2 {\n         let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n \n@@ -172,7 +171,7 @@ fn find_sugg_for_match<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, o\n }\n \n fn find_good_method_for_match<'a>(\n-    arms: &HirVec<Arm>,\n+    arms: &[Arm<'_>],\n     path_left: &QPath,\n     path_right: &QPath,\n     expected_left: &[&str],"}, {"sha": "76a317d7505a030e59881735e82d281f1d664cc1", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n         self.spans.clear();\n     }\n \n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n         if_chain! {\n             if self.last.is_none();\n             if let Some(ref expr) = block.expr;\n@@ -99,13 +99,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Regex {\n         }\n     }\n \n-    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n+    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n         if self.last.map_or(false, |id| block.hir_id == id) {\n             self.last = None;\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref fun, ref args) = expr.kind;\n             if let ExprKind::Path(ref qpath) = fun.kind;\n@@ -138,7 +138,7 @@ fn str_span(base: Span, c: regex_syntax::ast::Span, offset: u16) -> Span {\n     Span::new(start, end, base.ctxt())\n }\n \n-fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) -> Option<String> {\n+fn const_str<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) -> Option<String> {\n     constant(cx, cx.tables, e).and_then(|(c, _)| match c {\n         Constant::Str(s) => Some(s),\n         _ => None,\n@@ -184,10 +184,10 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n     }\n }\n \n-fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n+fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n     if_chain! {\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref expr) = expr.kind;\n-        if let ExprKind::Array(ref exprs) = expr.kind;\n+        if let ExprKind::Array(exprs) = expr.kind;\n         then {\n             for expr in exprs {\n                 check_regex(cx, expr, utf8);\n@@ -196,7 +196,7 @@ fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool)\n     }\n }\n \n-fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n+fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, utf8: bool) {\n     let mut parser = regex_syntax::ParserBuilder::new()\n         .unicode(utf8)\n         .allow_invalid_utf8(!utf8)"}, {"sha": "b1224eaa7a4320ef9a76ed43cdaa29b7ac6c2af3", "filename": "clippy_lints/src/replace_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Freplace_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Freplace_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freplace_consts.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -35,7 +35,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ReplaceConsts => [REPLACE_CONSTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ReplaceConsts {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::Path(ref qp) = expr.kind;\n             if let Res::Def(DefKind::Const, def_id) = cx.tables.qpath_res(qp, expr.hir_id);"}, {"sha": "f1a10a4ae840e1619932e4ed1e02c24231849af2", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -110,9 +110,9 @@ fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: &'tc\n     check_expr(cx, &body.value, &mut bindings);\n }\n \n-fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n-    for stmt in &block.stmts {\n+    for stmt in block.stmts {\n         match stmt.kind {\n             StmtKind::Local(ref local) => check_local(cx, local, bindings),\n             StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => check_expr(cx, e, bindings),\n@@ -125,7 +125,7 @@ fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, binding\n     bindings.truncate(len);\n }\n \n-fn check_local<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, local: &'tcx Local, bindings: &mut Vec<(Name, Span)>) {\n+fn check_local<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx.sess(), local.span) {\n         return;\n     }\n@@ -160,8 +160,8 @@ fn is_binding(cx: &LateContext<'_, '_>, pat_id: HirId) -> bool {\n \n fn check_pat<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    pat: &'tcx Pat,\n-    init: Option<&'tcx Expr>,\n+    pat: &'tcx Pat<'_>,\n+    init: Option<&'tcx Expr<'_>>,\n     span: Span,\n     bindings: &mut Vec<(Name, Span)>,\n ) {\n@@ -187,7 +187,7 @@ fn check_pat<'a, 'tcx>(\n                 check_pat(cx, p, init, span, bindings);\n             }\n         },\n-        PatKind::Struct(_, ref pfields, _) => {\n+        PatKind::Struct(_, pfields, _) => {\n             if let Some(init_struct) = init {\n                 if let ExprKind::Struct(_, ref efields, _) = init_struct.kind {\n                     for field in pfields {\n@@ -208,7 +208,7 @@ fn check_pat<'a, 'tcx>(\n                 }\n             }\n         },\n-        PatKind::Tuple(ref inner, _) => {\n+        PatKind::Tuple(inner, _) => {\n             if let Some(init_tup) = init {\n                 if let ExprKind::Tup(ref tup) = init_tup.kind {\n                     for (i, p) in inner.iter().enumerate() {\n@@ -247,7 +247,7 @@ fn lint_shadow<'a, 'tcx>(\n     name: Name,\n     span: Span,\n     pattern_span: Span,\n-    init: Option<&'tcx Expr>,\n+    init: Option<&'tcx Expr<'_>>,\n     prev_span: Span,\n ) {\n     if let Some(expr) = init {\n@@ -309,7 +309,7 @@ fn lint_shadow<'a, 'tcx>(\n     }\n }\n \n-fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx.sess(), expr.span) {\n         return;\n     }\n@@ -321,12 +321,12 @@ fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings:\n         ExprKind::Block(ref block, _) | ExprKind::Loop(ref block, _, _) => check_block(cx, block, bindings),\n         // ExprKind::Call\n         // ExprKind::MethodCall\n-        ExprKind::Array(ref v) | ExprKind::Tup(ref v) => {\n+        ExprKind::Array(v) | ExprKind::Tup(v) => {\n             for e in v {\n                 check_expr(cx, e, bindings)\n             }\n         },\n-        ExprKind::Match(ref init, ref arms, _) => {\n+        ExprKind::Match(ref init, arms, _) => {\n             check_expr(cx, init, bindings);\n             let len = bindings.len();\n             for arm in arms {\n@@ -365,7 +365,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n     }\n }\n \n-fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n+fn is_self_shadow(name: Name, expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Box(ref inner) | ExprKind::AddrOf(_, _, ref inner) => is_self_shadow(name, inner),\n         ExprKind::Block(ref block, _) => {"}, {"sha": "03becd1c7c102e002d1448e97a35e445859f4dc8", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -43,24 +43,24 @@ struct VecAllocation<'tcx> {\n     variable_name: Symbol,\n \n     /// Reference to the expression which allocates the vector\n-    allocation_expr: &'tcx Expr,\n+    allocation_expr: &'tcx Expr<'tcx>,\n \n     /// Reference to the expression used as argument on `with_capacity` call. This is used\n     /// to only match slow zero-filling idioms of the same length than vector initialization.\n-    len_expr: &'tcx Expr,\n+    len_expr: &'tcx Expr<'tcx>,\n }\n \n /// Type of slow initialization\n enum InitializationType<'tcx> {\n     /// Extend is a slow initialization with the form `vec.extend(repeat(0).take(..))`\n-    Extend(&'tcx Expr),\n+    Extend(&'tcx Expr<'tcx>),\n \n     /// Resize is a slow initialization with the form `vec.resize(.., 0)`\n-    Resize(&'tcx Expr),\n+    Resize(&'tcx Expr<'tcx>),\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // Matches initialization on reassignements. For example: `vec = Vec::with_capacity(100)`\n         if_chain! {\n             if let ExprKind::Assign(ref left, ref right, _) = expr.kind;\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n         // Matches statements which initializes vectors. For example: `let mut vec = Vec::with_capacity(10)`\n         if_chain! {\n             if let StmtKind::Local(ref local) = stmt.kind;\n@@ -108,7 +108,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SlowVectorInit {\n impl SlowVectorInit {\n     /// Checks if the given expression is `Vec::with_capacity(..)`. It will return the expression\n     /// of the first argument of `with_capacity` call if it matches or `None` if it does not.\n-    fn is_vec_with_capacity(expr: &Expr) -> Option<&Expr> {\n+    fn is_vec_with_capacity<'tcx>(expr: &Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n         if_chain! {\n             if let ExprKind::Call(ref func, ref args) = expr.kind;\n             if let ExprKind::Path(ref path) = func.kind;\n@@ -163,7 +163,7 @@ impl SlowVectorInit {\n \n     fn emit_lint<'tcx>(\n         cx: &LateContext<'_, 'tcx>,\n-        slow_fill: &Expr,\n+        slow_fill: &Expr<'_>,\n         vec_alloc: &VecAllocation<'_>,\n         msg: &str,\n         lint: &'static Lint,\n@@ -198,7 +198,7 @@ struct VectorInitializationVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Checks if the given expression is extending a vector with `repeat(0).take(..)`\n-    fn search_slow_extend_filling(&mut self, expr: &'tcx Expr) {\n+    fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n@@ -215,7 +215,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     }\n \n     /// Checks if the given expression is resizing a vector with 0\n-    fn search_slow_resize_filling(&mut self, expr: &'tcx Expr) {\n+    fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     }\n \n     /// Returns `true` if give expression is `repeat(0).take(...)`\n-    fn is_repeat_take(&self, expr: &Expr) -> bool {\n+    fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n             if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.kind;\n             if take_path.ident.name == sym!(take);\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     }\n \n     /// Returns `true` if given expression is `repeat(0)`\n-    fn is_repeat_zero(expr: &Expr) -> bool {\n+    fn is_repeat_zero(expr: &Expr<'_>) -> bool {\n         if_chain! {\n             if let ExprKind::Call(ref fn_expr, ref repeat_args) = expr.kind;\n             if let ExprKind::Path(ref qpath_repeat) = fn_expr.kind;\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n-    fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         if self.initialization_found {\n             match stmt.kind {\n                 StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => {\n@@ -295,7 +295,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_block(&mut self, block: &'tcx Block) {\n+    fn visit_block(&mut self, block: &'tcx Block<'_>) {\n         if self.initialization_found {\n             if let Some(ref s) = block.stmts.get(0) {\n                 self.visit_stmt(s)\n@@ -307,7 +307,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VectorInitializationVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         // Skip all the expressions previous to the vector initialization\n         if self.vec_alloc.allocation_expr.hir_id == expr.hir_id {\n             self.initialization_found = true;"}, {"sha": "46c3e50140f0321d9abf5b5ebdf95017c725d165", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -79,7 +79,7 @@ declare_clippy_lint! {\n declare_lint_pass!(StringAdd => [STRING_ADD, STRING_ADD_ASSIGN]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), e.span) {\n             return;\n         }\n@@ -125,11 +125,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n     }\n }\n \n-fn is_string(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n+fn is_string(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n     match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(e)), &paths::STRING)\n }\n \n-fn is_add(cx: &LateContext<'_, '_>, src: &Expr, target: &Expr) -> bool {\n+fn is_add(cx: &LateContext<'_, '_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n     match src.kind {\n         ExprKind::Binary(\n             Spanned {\n@@ -151,7 +151,7 @@ const MAX_LENGTH_BYTE_STRING_LIT: usize = 32;\n declare_lint_pass!(StringLitAsBytes => [STRING_LIT_AS_BYTES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         use crate::utils::{snippet, snippet_with_applicability};\n         use syntax::ast::LitKind;\n "}, {"sha": "94ecb14591574b4a6d2b56adf693bab2c1f05fb0", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -53,7 +53,7 @@ declare_clippy_lint! {\n declare_lint_pass!(SuspiciousImpl => [SUSPICIOUS_ARITHMETIC_IMPL, SUSPICIOUS_OP_ASSIGN_IMPL]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if let hir::ExprKind::Binary(binop, _, _) = expr.kind {\n             match binop.node {\n                 hir::BinOpKind::Eq\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n \n fn check_binop(\n     cx: &LateContext<'_, '_>,\n-    expr: &hir::Expr,\n+    expr: &hir::Expr<'_>,\n     binop: hir::BinOpKind,\n     traits: &[&'static str],\n     expected_ops: &[hir::BinOpKind],\n@@ -185,7 +185,7 @@ struct BinaryExprVisitor {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for BinaryExprVisitor {\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n         match expr.kind {\n             hir::ExprKind::Binary(..)\n             | hir::ExprKind::Unary(hir::UnOp::UnNot, _)"}, {"sha": "c4282dde585e0d5fd21bd16edcccc0997f310163", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -69,14 +69,14 @@ declare_clippy_lint! {\n declare_lint_pass!(Swap => [MANUAL_SWAP, ALMOST_SWAPPED]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n-    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block<'_>) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n     }\n }\n \n /// Implementation of the `MANUAL_SWAP` lint.\n-fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block) {\n+fn check_manual_swap(cx: &LateContext<'_, '_>, block: &Block<'_>) {\n     for w in block.stmts.windows(3) {\n         if_chain! {\n             // let t = foo();\n@@ -176,7 +176,7 @@ enum Slice<'a> {\n     /// // can be written as\n     /// a.swap(0, 1);\n     /// ```\n-    Swappable(&'a Expr, &'a Expr, &'a Expr),\n+    Swappable(&'a Expr<'a>, &'a Expr<'a>, &'a Expr<'a>),\n     /// The `swap` function cannot be used.\n     ///\n     /// ## Example\n@@ -193,7 +193,7 @@ enum Slice<'a> {\n }\n \n /// Checks if both expressions are index operations into \"slice-like\" types.\n-fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr, lhs2: &'a Expr) -> Slice<'a> {\n+fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr<'_>, lhs2: &'a Expr<'_>) -> Slice<'a> {\n     if let ExprKind::Index(ref lhs1, ref idx1) = lhs1.kind {\n         if let ExprKind::Index(ref lhs2, ref idx2) = lhs2.kind {\n             if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n@@ -216,7 +216,7 @@ fn check_for_slice<'a>(cx: &LateContext<'_, '_>, lhs1: &'a Expr, lhs2: &'a Expr)\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n-fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block) {\n+fn check_suspicious_swap(cx: &LateContext<'_, '_>, block: &Block<'_>) {\n     for w in block.stmts.windows(2) {\n         if_chain! {\n             if let StmtKind::Semi(ref first) = w[0].kind;"}, {"sha": "c7ae7b941144fd73744a1809c9daeb4109d37f09", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     \"assignments to temporaries\"\n }\n \n-fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n         ExprKind::Path(qpath) => {\n@@ -41,7 +41,7 @@ fn is_temporary(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n declare_lint_pass!(TemporaryAssignment => [TEMPORARY_ASSIGNMENT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TemporaryAssignment {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Assign(target, ..) = &expr.kind {\n             let mut base = target;\n             while let ExprKind::Field(f, _) | ExprKind::Index(f, _) = &base.kind {"}, {"sha": "ad8a4460953c22703e9de607bd249557220809bf", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -33,7 +33,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ToDigitIsSome {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n             if let hir::ExprKind::MethodCall(is_some_path, _, is_some_args) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";"}, {"sha": "637ed0746620702084435090b7a0c47f7d3997dd", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -292,7 +292,7 @@ static COLLECTIONS: &[&[&str]] = &[\n ];\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref path_expr, ref args) = e.kind;\n             if let ExprKind::Path(ref qpath) = path_expr.kind;"}, {"sha": "6438c79f99e8a1ec343ebb4f875c52f4bcb92387", "filename": "clippy_lints/src/transmuting_null.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftransmuting_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmuting_null.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -30,7 +30,7 @@ declare_lint_pass!(TransmutingNull => [TRANSMUTING_NULL]);\n const LINT_MSG: &str = \"transmuting a known null pointer into a reference.\";\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n@@ -72,7 +72,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TransmutingNull {\n                     if let ExprKind::Call(ref func1, ref args1) = args[0].kind;\n                     if let ExprKind::Path(ref path1) = func1.kind;\n                     if match_qpath(path1, &paths::STD_PTR_NULL);\n-                    if args1.len() == 0;\n+                    if args1.is_empty();\n                     then {\n                         span_lint(cx, TRANSMUTING_NULL, expr.span, LINT_MSG)\n                     }"}, {"sha": "ef3c4b546c621ce54826b3c3e5010c882a54a7da", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -44,7 +44,7 @@ declare_clippy_lint! {\n declare_lint_pass!(TryErr => [TRY_ERR]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TryErr {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // Looks for a structure like this:\n         // match ::std::ops::Try::into_result(Err(5)) {\n         //     ::std::result::Result::Err(err) =>\n@@ -97,7 +97,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TryErr {\n // In order to determine whether to suggest `.into()` or not, we need to find the error type the\n // function returns. To do that, we look for the From::from call (see tree above), and capture\n // its output type.\n-fn find_err_return_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx ExprKind) -> Option<Ty<'tcx>> {\n+fn find_err_return_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx ExprKind<'_>) -> Option<Ty<'tcx>> {\n     if let ExprKind::Match(_, ref arms, MatchSource::TryDesugar) = expr {\n         arms.iter().find_map(|ty| find_err_return_type_arm(cx, ty))\n     } else {\n@@ -106,7 +106,7 @@ fn find_err_return_type<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx ExprKi\n }\n \n // Check for From::from in one of the match arms.\n-fn find_err_return_type_arm<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arm: &'tcx Arm) -> Option<Ty<'tcx>> {\n+fn find_err_return_type_arm<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arm: &'tcx Arm<'_>) -> Option<Ty<'tcx>> {\n     if_chain! {\n         if let ExprKind::Ret(Some(ref err_ret)) = arm.body.kind;\n         if let ExprKind::Call(ref from_error_path, ref from_error_args) = err_ret.kind;"}, {"sha": "b435a95a4f8e9d9c6542bf9d000f33c324f7eb98", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -193,7 +193,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Types {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext<'_, '_>, local: &Local<'_>) {\n         if let Some(ref ty) = local.ty {\n             check_ty(cx, ty, true);\n         }\n@@ -462,7 +462,7 @@ declare_clippy_lint! {\n declare_lint_pass!(LetUnitValue => [LET_UNIT_VALUE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetUnitValue {\n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt<'_>) {\n         if let StmtKind::Local(ref local) = stmt.kind {\n             if is_unit(cx.tables.pat_ty(&local.pat)) {\n                 if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n@@ -537,7 +537,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UnitCmp => [UNIT_CMP]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         if expr.span.from_expansion() {\n             if let Some(callee) = expr.span.source_callee() {\n                 if let ExpnKind::Macro(MacroKind::Bang, symbol) = callee.kind {\n@@ -610,7 +610,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UnitArg => [UNIT_ARG]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -633,7 +633,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n         }\n \n         match expr.kind {\n-            ExprKind::Call(_, ref args) | ExprKind::MethodCall(_, _, ref args) => {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n                 for arg in args {\n                     if is_unit(cx.tables.expr_ty(arg)) && !is_unit_literal(arg) {\n                         if let ExprKind::Match(.., match_source) = &arg.kind {\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n     }\n }\n \n-fn is_questionmark_desugar_marked_call(expr: &Expr) -> bool {\n+fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n     use syntax_pos::hygiene::DesugaringKind;\n     if let ExprKind::Call(ref callee, _) = expr.kind {\n         callee.span.is_desugaring(DesugaringKind::QuestionMark)\n@@ -675,7 +675,7 @@ fn is_unit(ty: Ty<'_>) -> bool {\n     }\n }\n \n-fn is_unit_literal(expr: &Expr) -> bool {\n+fn is_unit_literal(expr: &Expr<'_>) -> bool {\n     match expr.kind {\n         ExprKind::Tup(ref slice) if slice.is_empty() => true,\n         _ => false,\n@@ -929,7 +929,7 @@ fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -956,7 +956,7 @@ fn span_precision_loss_lint(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty\n     );\n }\n \n-fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n+fn should_strip_parens(op: &Expr<'_>, snip: &str) -> bool {\n     if let ExprKind::Binary(_, _, _) = op.kind {\n         if snip.starts_with('(') && snip.ends_with(')') {\n             return true;\n@@ -965,7 +965,7 @@ fn should_strip_parens(op: &Expr, snip: &str) -> bool {\n     false\n }\n \n-fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn span_lossless_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     // Do not suggest using From in consts/statics until it is valid to do so (see #2267).\n     if in_constant(cx, expr.hir_id) {\n         return;\n@@ -1005,7 +1005,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     if !cast_from.is_signed() || cast_to.is_signed() {\n         return;\n     }\n@@ -1049,7 +1049,7 @@ fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_fro\n     );\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -1120,7 +1120,7 @@ fn check_truncation_and_wrapping(cx: &LateContext<'_, '_>, expr: &Expr, cast_fro\n     }\n }\n \n-fn check_lossless(cx: &LateContext<'_, '_>, expr: &Expr, op: &Expr, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n+fn check_lossless(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>, cast_from: Ty<'_>, cast_to: Ty<'_>) {\n     let cast_signed_to_unsigned = cast_from.is_signed() && !cast_to.is_signed();\n     let from_nbits = int_ty_to_nbits(cast_from, cx.tcx);\n     let to_nbits = int_ty_to_nbits(cast_to, cx.tcx);\n@@ -1169,7 +1169,7 @@ fn fp_ty_mantissa_nbits(typ: Ty<'_>) -> u32 {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n             return;\n         }\n@@ -1223,8 +1223,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Casts {\n \n fn lint_numeric_casts<'tcx>(\n     cx: &LateContext<'_, 'tcx>,\n-    expr: &Expr,\n-    cast_expr: &Expr,\n+    expr: &Expr<'tcx>,\n+    cast_expr: &Expr<'_>,\n     cast_from: Ty<'tcx>,\n     cast_to: Ty<'tcx>,\n ) {\n@@ -1280,7 +1280,7 @@ fn lint_numeric_casts<'tcx>(\n     }\n }\n \n-fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n+fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n     if_chain! {\n         if let ty::RawPtr(from_ptr_ty) = &cast_from.kind;\n         if let ty::RawPtr(to_ptr_ty) = &cast_to.kind;\n@@ -1310,8 +1310,8 @@ fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'_, 'tcx>, expr: &Expr, cast_f\n \n fn lint_fn_to_numeric_cast(\n     cx: &LateContext<'_, '_>,\n-    expr: &Expr,\n-    cast_expr: &Expr,\n+    expr: &Expr<'_>,\n+    cast_expr: &Expr<'_>,\n     cast_from: Ty<'_>,\n     cast_to: Ty<'_>,\n ) {\n@@ -1432,7 +1432,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexity {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local<'_>) {\n         if let Some(ref ty) = local.ty {\n             self.check_type(cx, ty);\n         }\n@@ -1548,7 +1548,7 @@ declare_clippy_lint! {\n declare_lint_pass!(CharLitAsU8 => [CHAR_LIT_AS_U8]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();\n             if let ExprKind::Cast(e, _) = &expr.kind;\n@@ -1619,7 +1619,7 @@ enum ExtremeType {\n \n struct ExtremeExpr<'a> {\n     which: ExtremeType,\n-    expr: &'a Expr,\n+    expr: &'a Expr<'a>,\n }\n \n enum AbsurdComparisonResult {\n@@ -1628,7 +1628,7 @@ enum AbsurdComparisonResult {\n     InequalityImpossible,\n }\n \n-fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> bool {\n+fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n         let precast_ty = cx.tables.expr_ty(cast_exp);\n         let cast_ty = cx.tables.expr_ty(expr);\n@@ -1642,8 +1642,8 @@ fn is_cast_between_fixed_and_target<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr:\n fn detect_absurd_comparison<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     op: BinOpKind,\n-    lhs: &'tcx Expr,\n-    rhs: &'tcx Expr,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n ) -> Option<(ExtremeExpr<'tcx>, AbsurdComparisonResult)> {\n     use crate::types::AbsurdComparisonResult::*;\n     use crate::types::ExtremeType::*;\n@@ -1691,7 +1691,7 @@ fn detect_absurd_comparison<'a, 'tcx>(\n     })\n }\n \n-fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<ExtremeExpr<'tcx>> {\n+fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<ExtremeExpr<'tcx>> {\n     use crate::types::ExtremeType::*;\n \n     let ty = cx.tables.expr_ty(expr);\n@@ -1720,7 +1720,7 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         use crate::types::AbsurdComparisonResult::*;\n         use crate::types::ExtremeType::*;\n \n@@ -1828,7 +1828,7 @@ impl Ord for FullInt {\n     }\n }\n \n-fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n+fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>) -> Option<(FullInt, FullInt)> {\n     use std::*;\n \n     if let ExprKind::Cast(ref cast_exp, _) = expr.kind {\n@@ -1892,7 +1892,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) ->\n     }\n }\n \n-fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<FullInt> {\n+fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) -> Option<FullInt> {\n     let val = constant(cx, cx.tables, expr)?.0;\n     if let Constant::Int(const_int) = val {\n         match cx.tables.expr_ty(expr).kind {\n@@ -1905,7 +1905,7 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr, always: bool) {\n+fn err_upcast_comparison(cx: &LateContext<'_, '_>, span: Span, expr: &Expr<'_>, always: bool) {\n     if let ExprKind::Cast(ref cast_val, _) = expr.kind {\n         span_lint(\n             cx,\n@@ -1925,8 +1925,8 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n     span: Span,\n     rel: comparisons::Rel,\n     lhs_bounds: Option<(FullInt, FullInt)>,\n-    lhs: &'tcx Expr,\n-    rhs: &'tcx Expr,\n+    lhs: &'tcx Expr<'_>,\n+    rhs: &'tcx Expr<'_>,\n     invert: bool,\n ) {\n     use crate::utils::comparisons::*;\n@@ -1979,7 +1979,7 @@ fn upcast_comparison_bounds_err<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref cmp, ref lhs, ref rhs) = expr.kind {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n             let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n@@ -2298,7 +2298,7 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 't\n         self.body = prev_body;\n     }\n \n-    fn visit_expr(&mut self, e: &'tcx Expr) {\n+    fn visit_expr(&mut self, e: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref fun, ref args) = e.kind;\n             if let ExprKind::Path(QPath::TypeRelative(ref ty, ref method)) = fun.kind;\n@@ -2383,7 +2383,7 @@ declare_clippy_lint! {\n declare_lint_pass!(RefToMut => [CAST_REF_TO_MUT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RefToMut {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Unary(UnOp::UnDeref, e) = &expr.kind;\n             if let ExprKind::Cast(e, t) = &e.kind;"}, {"sha": "992b8d80c20ddf60eb1a82f63fbd2dc89fd373f7", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -67,7 +67,7 @@ declare_clippy_lint! {\n declare_lint_pass!(Unicode => [ZERO_WIDTH_SPACE, NON_ASCII_LITERAL, UNICODE_NOT_NFC]);\n \n impl LateLintPass<'_, '_> for Unicode {\n-    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &'_ Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &'_ Expr<'_>) {\n         if let ExprKind::Lit(ref lit) = expr.kind {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span, expr.hir_id)"}, {"sha": "db1e61b4edd8aefedb6a5db5c771568da787a4a3", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -34,7 +34,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UnusedIoAmount => [UNUSED_IO_AMOUNT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n-    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         let expr = match s.kind {\n             hir::StmtKind::Semi(ref expr) | hir::StmtKind::Expr(ref expr) => &**expr,\n             _ => return,\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n     }\n }\n \n-fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr, expr: &hir::Expr) {\n+fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n     if let hir::ExprKind::MethodCall(ref path, _, _) = call.kind {\n         let symbol = &*path.ident.as_str();\n         if match_trait_method(cx, call, &paths::IO_READ) && symbol == \"read\" {"}, {"sha": "37a6a2859b552a3a7f12c51ac8e070154499e8fe", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -72,7 +72,7 @@ struct UnwrapInfo<'tcx> {\n     /// The variable that is checked\n     ident: &'tcx Path,\n     /// The check, like `x.is_ok()`\n-    check: &'tcx Expr,\n+    check: &'tcx Expr<'tcx>,\n     /// Whether `is_some()` or `is_ok()` was called (as opposed to `is_err()` or `is_none()`).\n     safe_to_unwrap: bool,\n }\n@@ -81,7 +81,7 @@ struct UnwrapInfo<'tcx> {\n /// The `invert` argument tells us whether the condition is negated.\n fn collect_unwrap_info<'a, 'tcx>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n+    expr: &'tcx Expr<'_>,\n     invert: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n@@ -119,7 +119,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n }\n \n impl<'a, 'tcx> UnwrappableVariablesVisitor<'a, 'tcx> {\n-    fn visit_branch(&mut self, cond: &'tcx Expr, branch: &'tcx Expr, else_branch: bool) {\n+    fn visit_branch(&mut self, cond: &'tcx Expr<'_>, branch: &'tcx Expr<'_>, else_branch: bool) {\n         let prev_len = self.unwrappables.len();\n         for unwrap_info in collect_unwrap_info(self.cx, cond, else_branch) {\n             if is_potentially_mutated(unwrap_info.ident, cond, self.cx)\n@@ -136,7 +136,7 @@ impl<'a, 'tcx> UnwrappableVariablesVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if let Some((cond, then, els)) = if_block(&expr) {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);"}, {"sha": "1169fce05ab506fe77a81df33caf3d073031c433", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n@@ -118,7 +118,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm<'_>) {\n         if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n@@ -127,7 +127,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Author {\n         done();\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n         if !has_attr(cx.sess(), stmt.kind.attrs()) {\n             return;\n         }\n@@ -189,7 +189,7 @@ struct PrintVisitor {\n \n impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     #[allow(clippy::too_many_lines)]\n-    fn visit_expr(&mut self, expr: &Expr) {\n+    fn visit_expr(&mut self, expr: &Expr<'_>) {\n         // handle if desugarings\n         // TODO add more desugarings here\n         if let Some((cond, then, opt_else)) = higher::if_block(&expr) {\n@@ -508,7 +508,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         }\n     }\n \n-    fn visit_block(&mut self, block: &Block) {\n+    fn visit_block(&mut self, block: &Block<'_>) {\n         let trailing_pat = self.next(\"trailing_expr\");\n         println!(\"    if let Some({}) = &{}.expr;\", trailing_pat, self.current);\n         println!(\"    if {}.stmts.len() == {};\", self.current, block.stmts.len());\n@@ -520,7 +520,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n \n     #[allow(clippy::too_many_lines)]\n-    fn visit_pat(&mut self, pat: &Pat) {\n+    fn visit_pat(&mut self, pat: &Pat<'_>) {\n         print!(\"    if let PatKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match pat.kind {\n@@ -646,7 +646,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         }\n     }\n \n-    fn visit_stmt(&mut self, s: &Stmt) {\n+    fn visit_stmt(&mut self, s: &Stmt<'_>) {\n         print!(\"    if let StmtKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match s.kind {"}, {"sha": "33c6bcc66d03a2baac127d65dc117200922ed495", "filename": "clippy_lints/src/utils/comparisons.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcomparisons.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -19,7 +19,11 @@ pub enum Rel {\n \n /// Put the expression in the form  `lhs < rhs`, `lhs <= rhs`, `lhs == rhs` or\n /// `lhs != rhs`.\n-pub fn normalize_comparison<'a>(op: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(Rel, &'a Expr, &'a Expr)> {\n+pub fn normalize_comparison<'a>(\n+    op: BinOpKind,\n+    lhs: &'a Expr<'a>,\n+    rhs: &'a Expr<'a>,\n+) -> Option<(Rel, &'a Expr<'a>, &'a Expr<'a>)> {\n     match op {\n         BinOpKind::Lt => Some((Rel::Lt, lhs, rhs)),\n         BinOpKind::Le => Some((Rel::Le, lhs, rhs)),"}, {"sha": "37d37a94d0e857e6ee39c18aca373543662af24b", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -38,18 +38,18 @@ pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n #[derive(Debug, Copy, Clone)]\n pub struct Range<'a> {\n     /// The lower bound of the range, or `None` for ranges such as `..X`.\n-    pub start: Option<&'a hir::Expr>,\n+    pub start: Option<&'a hir::Expr<'a>>,\n     /// The upper bound of the range, or `None` for ranges such as `X..`.\n-    pub end: Option<&'a hir::Expr>,\n+    pub end: Option<&'a hir::Expr<'a>>,\n     /// Whether the interval is open or closed.\n     pub limits: ast::RangeLimits,\n }\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> Option<Range<'b>> {\n+pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr<'_>) -> Option<Range<'b>> {\n     /// Finds the field named `name` in the field. Always return `Some` for\n     /// convenience.\n-    fn get_field<'c>(name: &str, fields: &'c [hir::Field]) -> Option<&'c hir::Expr> {\n+    fn get_field<'c>(name: &str, fields: &'c [hir::Field<'_>]) -> Option<&'c hir::Expr<'c>> {\n         let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n \n         Some(expr)\n@@ -150,7 +150,7 @@ pub fn range<'a, 'b, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'b hir::Expr) -> O\n }\n \n /// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local) -> bool {\n+pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n     // This will detect plain for-loops without an actual variable binding:\n     //\n     // ```\n@@ -183,7 +183,9 @@ pub fn is_from_for_desugar(local: &hir::Local) -> bool {\n \n /// Recover the essential nodes of a desugared for loop:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n-pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n+pub fn for_loop<'tcx>(\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if_chain! {\n         if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n         if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n@@ -202,7 +204,7 @@ pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)>\n \n /// Recover the essential nodes of a desugared while loop:\n /// `while cond { body }` becomes `(cond, body)`.\n-pub fn while_loop(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr)> {\n+pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n     if_chain! {\n         if let hir::ExprKind::Loop(block, _, hir::LoopSource::While) = &expr.kind;\n         if let hir::Block { expr: Some(expr), .. } = &**block;\n@@ -219,7 +221,13 @@ pub fn while_loop(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr)> {\n \n /// Recover the essential nodes of a desugared if block\n /// `if cond { then } else { els }` becomes `(cond, then, Some(els))`\n-pub fn if_block(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr, Option<&hir::Expr>)> {\n+pub fn if_block<'tcx>(\n+    expr: &'tcx hir::Expr<'tcx>,\n+) -> Option<(\n+    &'tcx hir::Expr<'tcx>,\n+    &'tcx hir::Expr<'tcx>,\n+    Option<&'tcx hir::Expr<'tcx>>,\n+)> {\n     if let hir::ExprKind::Match(ref cond, ref arms, hir::MatchSource::IfDesugar { contains_else_clause }) = expr.kind {\n         let cond = if let hir::ExprKind::DropTemps(ref cond) = cond.kind {\n             cond\n@@ -241,14 +249,14 @@ pub fn if_block(expr: &hir::Expr) -> Option<(&hir::Expr, &hir::Expr, Option<&hir\n /// Represent the pre-expansion arguments of a `vec!` invocation.\n pub enum VecArgs<'a> {\n     /// `vec![elem; len]`\n-    Repeat(&'a hir::Expr, &'a hir::Expr),\n+    Repeat(&'a hir::Expr<'a>, &'a hir::Expr<'a>),\n     /// `vec![a, b, c]`\n-    Vec(&'a [hir::Expr]),\n+    Vec(&'a [hir::Expr<'a>]),\n }\n \n /// Returns the arguments of the `vec!` macro if this expression was expanded\n /// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n+pub fn vec_macro<'e>(cx: &LateContext<'_, '_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n     if_chain! {\n         if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let hir::ExprKind::Path(ref qpath) = fun.kind;"}, {"sha": "1227c813f1cbc8b5db999c756eb9590e79023ab8", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -1,6 +1,5 @@\n use crate::consts::{constant_context, constant_simple};\n use crate::utils::differing_macro_contexts;\n-use rustc::hir::ptr::P;\n use rustc::hir::*;\n use rustc::ich::StableHashingContextProvider;\n use rustc::lint::LateContext;\n@@ -42,7 +41,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Checks whether two statements are the same.\n-    pub fn eq_stmt(&mut self, left: &Stmt, right: &Stmt) -> bool {\n+    pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n                 self.eq_pat(&l.pat, &r.pat)\n@@ -57,13 +56,13 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Checks whether two blocks are the same.\n-    pub fn eq_block(&mut self, left: &Block, right: &Block) -> bool {\n+    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_expr(&mut self, left: &Expr, right: &Expr) -> bool {\n+    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n         if self.ignore_fn && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n@@ -102,7 +101,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n-            (&ExprKind::Call(ref l_fun, ref l_args), &ExprKind::Call(ref r_fun, ref r_args)) => {\n+            (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n                 !self.ignore_fn && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n@@ -128,7 +127,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                             && self.eq_pat(&l.pat, &r.pat)\n                     })\n             },\n-            (&ExprKind::MethodCall(ref l_path, _, ref l_args), &ExprKind::MethodCall(ref r_path, _, ref r_args)) => {\n+            (&ExprKind::MethodCall(l_path, _, l_args), &ExprKind::MethodCall(r_path, _, r_args)) => {\n                 !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n@@ -146,23 +145,23 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                     && both(lo, ro, |l, r| self.eq_expr(l, r))\n                     && over(lf, rf, |l, r| self.eq_field(l, r))\n             },\n-            (&ExprKind::Tup(ref l_tup), &ExprKind::Tup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n+            (&ExprKind::Tup(l_tup), &ExprKind::Tup(r_tup)) => self.eq_exprs(l_tup, r_tup),\n             (&ExprKind::Unary(l_op, ref le), &ExprKind::Unary(r_op, ref re)) => l_op == r_op && self.eq_expr(le, re),\n-            (&ExprKind::Array(ref l), &ExprKind::Array(ref r)) => self.eq_exprs(l, r),\n+            (&ExprKind::Array(l), &ExprKind::Array(r)) => self.eq_exprs(l, r),\n             (&ExprKind::DropTemps(ref le), &ExprKind::DropTemps(ref re)) => self.eq_expr(le, re),\n             _ => false,\n         }\n     }\n \n-    fn eq_exprs(&mut self, left: &P<[Expr]>, right: &P<[Expr]>) -> bool {\n+    fn eq_exprs(&mut self, left: &[Expr<'_>], right: &[Expr<'_>]) -> bool {\n         over(left, right, |l, r| self.eq_expr(l, r))\n     }\n \n-    fn eq_field(&mut self, left: &Field, right: &Field) -> bool {\n+    fn eq_field(&mut self, left: &Field<'_>, right: &Field<'_>) -> bool {\n         left.ident.name == right.ident.name && self.eq_expr(&left.expr, &right.expr)\n     }\n \n-    fn eq_guard(&mut self, left: &Guard, right: &Guard) -> bool {\n+    fn eq_guard(&mut self, left: &Guard<'_>, right: &Guard<'_>) -> bool {\n         match (left, right) {\n             (Guard::If(l), Guard::If(r)) => self.eq_expr(l, r),\n         }\n@@ -181,7 +180,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Checks whether two patterns are the same.\n-    pub fn eq_pat(&mut self, left: &Pat, right: &Pat) -> bool {\n+    pub fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n@@ -299,7 +298,11 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n }\n \n-fn swap_binop<'a>(binop: BinOpKind, lhs: &'a Expr, rhs: &'a Expr) -> Option<(BinOpKind, &'a Expr, &'a Expr)> {\n+fn swap_binop<'a>(\n+    binop: BinOpKind,\n+    lhs: &'a Expr<'a>,\n+    rhs: &'a Expr<'a>,\n+) -> Option<(BinOpKind, &'a Expr<'a>, &'a Expr<'a>)> {\n     match binop {\n         BinOpKind::Add\n         | BinOpKind::Mul\n@@ -365,8 +368,8 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         self.s.finish()\n     }\n \n-    pub fn hash_block(&mut self, b: &Block) {\n-        for s in &b.stmts {\n+    pub fn hash_block(&mut self, b: &Block<'_>) {\n+        for s in b.stmts {\n             self.hash_stmt(s);\n         }\n \n@@ -384,7 +387,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n     }\n \n     #[allow(clippy::many_single_char_names, clippy::too_many_lines)]\n-    pub fn hash_expr(&mut self, e: &Expr) {\n+    pub fn hash_expr(&mut self, e: &Expr<'_>) {\n         let simple_const = constant_simple(self.cx, self.tables, e);\n \n         // const hashing may result in the same hash as some unrelated node, so add a sort of\n@@ -442,7 +445,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Box(ref e) | ExprKind::DropTemps(ref e) | ExprKind::Yield(ref e, _) => {\n                 self.hash_expr(e);\n             },\n-            ExprKind::Call(ref fun, ref args) => {\n+            ExprKind::Call(ref fun, args) => {\n                 self.hash_expr(fun);\n                 self.hash_exprs(args);\n             },\n@@ -477,7 +480,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_name(i.ident.name);\n                 }\n             },\n-            ExprKind::Match(ref e, ref arms, ref s) => {\n+            ExprKind::Match(ref e, arms, ref s) => {\n                 self.hash_expr(e);\n \n                 for arm in arms {\n@@ -490,7 +493,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(ref path, ref _tys, ref args) => {\n+            ExprKind::MethodCall(ref path, ref _tys, args) => {\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n@@ -506,7 +509,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n             ExprKind::Path(ref qpath) => {\n                 self.hash_qpath(qpath);\n             },\n-            ExprKind::Struct(ref path, ref fields, ref expr) => {\n+            ExprKind::Struct(ref path, fields, ref expr) => {\n                 self.hash_qpath(path);\n \n                 for f in fields {\n@@ -518,10 +521,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             },\n-            ExprKind::Tup(ref tup) => {\n+            ExprKind::Tup(tup) => {\n                 self.hash_exprs(tup);\n             },\n-            ExprKind::Array(ref v) => {\n+            ExprKind::Array(v) => {\n                 self.hash_exprs(v);\n             },\n             ExprKind::Unary(lop, ref le) => {\n@@ -531,7 +534,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_exprs(&mut self, e: &P<[Expr]>) {\n+    pub fn hash_exprs(&mut self, e: &[Expr<'_>]) {\n         for e in e {\n             self.hash_expr(e);\n         }\n@@ -560,7 +563,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_stmt(&mut self, b: &Stmt) {\n+    pub fn hash_stmt(&mut self, b: &Stmt<'_>) {\n         std::mem::discriminant(&b.kind).hash(&mut self.s);\n \n         match &b.kind {\n@@ -576,7 +579,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_guard(&mut self, g: &Guard) {\n+    pub fn hash_guard(&mut self, g: &Guard<'_>) {\n         match g {\n             Guard::If(ref expr) => {\n                 self.hash_expr(expr);"}, {"sha": "87ef4c7799e9c1db7e87d121eb04df558ea54294", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -91,14 +91,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n     // }\n     //\n \n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), &expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n+    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm<'_>) {\n         if !has_attr(cx.sess(), &arm.attrs) {\n             return;\n         }\n@@ -111,7 +111,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n         print_expr(cx, &arm.body, 1);\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n         if !has_attr(cx.sess(), stmt.kind.attrs()) {\n             return;\n         }\n@@ -144,7 +144,7 @@ fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n \n #[allow(clippy::similar_names)]\n #[allow(clippy::too_many_lines)]\n-fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n+fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     println!(\"{}ty: {}\", ind, cx.tables.expr_ty(expr));\n@@ -154,13 +154,13 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n             println!(\"{}Box\", ind);\n             print_expr(cx, e, indent + 1);\n         },\n-        hir::ExprKind::Array(ref v) => {\n+        hir::ExprKind::Array(v) => {\n             println!(\"{}Array\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Call(ref func, ref args) => {\n+        hir::ExprKind::Call(ref func, args) => {\n             println!(\"{}Call\", ind);\n             println!(\"{}function:\", ind);\n             print_expr(cx, func, indent + 1);\n@@ -169,14 +169,14 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::MethodCall(ref path, _, ref args) => {\n+        hir::ExprKind::MethodCall(ref path, _, args) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::Tup(ref v) => {\n+        hir::ExprKind::Tup(v) => {\n             println!(\"{}Tup\", ind);\n             for e in v {\n                 print_expr(cx, e, indent + 1);\n@@ -297,7 +297,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, e, indent + 1);\n             }\n         },\n-        hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n+        hir::ExprKind::Struct(ref path, fields, ref base) => {\n             println!(\"{}Struct\", ind);\n             println!(\"{}path: {:?}\", ind, path);\n             for field in fields {\n@@ -400,7 +400,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n \n #[allow(clippy::similar_names)]\n #[allow(clippy::too_many_lines)]\n-fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n+fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match pat.kind {\n@@ -414,13 +414,13 @@ fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n                 print_pat(cx, inner, indent + 1);\n             }\n         },\n-        hir::PatKind::Or(ref fields) => {\n+        hir::PatKind::Or(fields) => {\n             println!(\"{}Or\", ind);\n             for field in fields {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Struct(ref path, ref fields, ignore) => {\n+        hir::PatKind::Struct(ref path, fields, ignore) => {\n             println!(\"{}Struct\", ind);\n             println!(\n                 \"{}name: {}\",\n@@ -437,7 +437,7 @@ fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n                 print_pat(cx, &field.pat, indent + 1);\n             }\n         },\n-        hir::PatKind::TupleStruct(ref path, ref fields, opt_dots_position) => {\n+        hir::PatKind::TupleStruct(ref path, fields, opt_dots_position) => {\n             println!(\"{}TupleStruct\", ind);\n             println!(\n                 \"{}path: {}\",\n@@ -459,7 +459,7 @@ fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n             println!(\"{}Relative Path, {:?}\", ind, ty);\n             println!(\"{}seg: {:?}\", ind, seg);\n         },\n-        hir::PatKind::Tuple(ref pats, opt_dots_position) => {\n+        hir::PatKind::Tuple(pats, opt_dots_position) => {\n             println!(\"{}Tuple\", ind);\n             if let Some(dot_position) = opt_dots_position {\n                 println!(\"{}dot position: {}\", ind, dot_position);\n@@ -490,7 +490,7 @@ fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n                 hir::RangeEnd::Excluded => println!(\"{} end excluded\", ind),\n             }\n         },\n-        hir::PatKind::Slice(ref first_pats, ref range, ref last_pats) => {\n+        hir::PatKind::Slice(first_pats, ref range, last_pats) => {\n             println!(\"{}Slice [a, b, ..i, y, z]\", ind);\n             println!(\"[a, b]:\");\n             for pat in first_pats {\n@@ -508,7 +508,7 @@ fn print_pat(cx: &LateContext<'_, '_>, pat: &hir::Pat, indent: usize) {\n     }\n }\n \n-fn print_guard(cx: &LateContext<'_, '_>, guard: &hir::Guard, indent: usize) {\n+fn print_guard(cx: &LateContext<'_, '_>, guard: &hir::Guard<'_>, indent: usize) {\n     let ind = \"  \".repeat(indent);\n     println!(\"{}+\", ind);\n     match guard {"}, {"sha": "83f1864bff701e96c1c6ee4f0ee7554d447daffb", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -239,7 +239,7 @@ struct LintCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         walk_expr(self, expr);\n     }\n \n@@ -274,7 +274,7 @@ impl CompilerLintFunctions {\n impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n             let fn_name = path.ident;\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OuterExpnDataPass {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         let (method_names, arg_lists, spans) = method_calls(expr, 2);\n         let method_names: Vec<SymbolStr> = method_names.iter().map(|s| s.as_str()).collect();\n         let method_names: Vec<&str> = method_names.iter().map(|s| &**s).collect();"}, {"sha": "8988a87b7b45dc82952192b70e0439f424547bb6", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -142,7 +142,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_, '_>, ty: Ty<'_>, diag_item:\n }\n \n /// Checks if the method call given in `expr` belongs to the given trait.\n-pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str]) -> bool {\n+pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n     if let Some(trt_id) = trt_id {\n@@ -153,7 +153,7 @@ pub fn match_trait_method(cx: &LateContext<'_, '_>, expr: &Expr, path: &[&str])\n }\n \n /// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr, var: Name) -> bool {\n+pub fn match_var(expr: &Expr<'_>, var: Name) -> bool {\n     if let ExprKind::Path(QPath::Resolved(None, ref path)) = expr.kind {\n         if path.segments.len() == 1 && path.segments[0].ident.name == var {\n             return true;\n@@ -362,7 +362,10 @@ pub fn has_drop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n \n /// Returns the method names and argument list of nested method call expressions that make up\n /// `expr`. method/span lists are sorted with the most recent call first.\n-pub fn method_calls(expr: &Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&[Expr]>, Vec<Span>) {\n+pub fn method_calls<'tcx>(\n+    expr: &'tcx Expr<'tcx>,\n+    max_depth: usize,\n+) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n     let mut method_names = Vec::with_capacity(max_depth);\n     let mut arg_lists = Vec::with_capacity(max_depth);\n     let mut spans = Vec::with_capacity(max_depth);\n@@ -391,7 +394,7 @@ pub fn method_calls(expr: &Expr, max_depth: usize) -> (Vec<Symbol>, Vec<&[Expr]>\n /// `matched_method_chain(expr, &[\"bar\", \"baz\"])` will return a `Vec`\n /// containing the `Expr`s for\n /// `.bar()` and `.baz()`\n-pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a [Expr]>> {\n+pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec<&'a [Expr<'a>]>> {\n     let mut current = expr;\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n@@ -423,7 +426,7 @@ pub fn is_entrypoint_fn(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n }\n \n /// Gets the name of the item the expression is in, if available.\n-pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n+pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<Name> {\n     let parent_id = cx.tcx.hir().get_parent_item(expr.hir_id);\n     match cx.tcx.hir().find(parent_id) {\n         Some(Node::Item(&Item { ref ident, .. })) => Some(ident.name),\n@@ -435,7 +438,7 @@ pub fn get_item_name(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<Name> {\n }\n \n /// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat) -> Option<Name> {\n+pub fn get_pat_name(pat: &Pat<'_>) -> Option<Name> {\n     match pat.kind {\n         PatKind::Binding(.., ref spname, _) => Some(spname.name),\n         PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n@@ -461,7 +464,7 @@ impl<'tcx> Visitor<'tcx> for ContainsName {\n }\n \n /// Checks if an `Expr` contains a certain name.\n-pub fn contains_name(name: Name, expr: &Expr) -> bool {\n+pub fn contains_name(name: Name, expr: &Expr<'_>) -> bool {\n     let mut cn = ContainsName { name, result: false };\n     cn.visit_expr(expr);\n     cn.result\n@@ -554,7 +557,12 @@ pub fn last_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, T: LintContext>(\n+    cx: &T,\n+    expr: &Expr<'_>,\n+    option: Option<String>,\n+    default: &'a str,\n+) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n     if expr.span.from_expansion() {\n@@ -610,7 +618,7 @@ fn trim_multiline_inner(s: Cow<'_, str>, ignore_first: bool, ch: char) -> Cow<'_\n }\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c Expr> {\n+pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr<'_>) -> Option<&'c Expr<'c>> {\n     let map = &cx.tcx.hir();\n     let hir_id = e.hir_id;\n     let parent_id = map.get_parent_node(hir_id);\n@@ -626,7 +634,7 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext<'_, '_>, e: &Expr) -> Option<&'c\n     })\n }\n \n-pub fn get_enclosing_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, hir_id: HirId) -> Option<&'tcx Block> {\n+pub fn get_enclosing_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {\n     let map = &cx.tcx.hir();\n     let enclosing_node = map\n         .get_enclosing_scope(hir_id)\n@@ -682,7 +690,7 @@ pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n \n /// Checks whether the given expression is a constant integer of the given value.\n /// unlike `is_integer_literal`, this version does const folding\n-pub fn is_integer_const(cx: &LateContext<'_, '_>, e: &Expr, value: u128) -> bool {\n+pub fn is_integer_const(cx: &LateContext<'_, '_>, e: &Expr<'_>, value: u128) -> bool {\n     if is_integer_literal(e, value) {\n         return true;\n     }\n@@ -699,7 +707,7 @@ pub fn is_integer_const(cx: &LateContext<'_, '_>, e: &Expr, value: u128) -> bool\n }\n \n /// Checks whether the given expression is a constant literal of the given value.\n-pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n+pub fn is_integer_literal(expr: &Expr<'_>, value: u128) -> bool {\n     // FIXME: use constant folding\n     if let ExprKind::Lit(ref spanned) = expr.kind {\n         if let LitKind::Int(v, _) = spanned.node {\n@@ -716,7 +724,7 @@ pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n ///\n /// See `rustc::ty::adjustment::Adjustment` and `rustc_typeck::check::coercion` for more\n /// information on adjustments and coercions.\n-pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr) -> bool {\n+pub fn is_adjusted(cx: &LateContext<'_, '_>, e: &Expr<'_>) -> bool {\n     cx.tables.adjustments().get(e.hir_id).is_some()\n }\n \n@@ -802,7 +810,7 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Checks if an expression is constructing a tuple-like enum variant or struct\n-pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     if let ExprKind::Call(ref fun, _) = expr.kind {\n         if let ExprKind::Path(ref qp) = fun.kind {\n             let res = cx.tables.qpath_res(qp, fun.hir_id);\n@@ -817,15 +825,15 @@ pub fn is_ctor_or_promotable_const_function(cx: &LateContext<'_, '_>, expr: &Exp\n }\n \n /// Returns `true` if a pattern is refutable.\n-pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat) -> bool {\n+pub fn is_refutable(cx: &LateContext<'_, '_>, pat: &Pat<'_>) -> bool {\n     fn is_enum_variant(cx: &LateContext<'_, '_>, qpath: &QPath, id: HirId) -> bool {\n         matches!(\n             cx.tables.qpath_res(qpath, id),\n             def::Res::Def(DefKind::Variant, ..) | Res::Def(DefKind::Ctor(def::CtorOf::Variant, _), _)\n         )\n     }\n \n-    fn are_refutable<'a, I: Iterator<Item = &'a Pat>>(cx: &LateContext<'_, '_>, mut i: I) -> bool {\n+    fn are_refutable<'a, I: Iterator<Item = &'a Pat<'a>>>(cx: &LateContext<'_, '_>, mut i: I) -> bool {\n         i.any(|pat| is_refutable(cx, pat))\n     }\n \n@@ -865,7 +873,7 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n ///\n /// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n /// themselves.\n-pub fn remove_blocks(expr: &Expr) -> &Expr {\n+pub fn remove_blocks<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if let ExprKind::Block(ref block, _) = expr.kind {\n         if block.stmts.is_empty() {\n             if let Some(ref expr) = block.expr {\n@@ -876,7 +884,7 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n     expr\n }\n \n-pub fn is_self(slf: &Param) -> bool {\n+pub fn is_self(slf: &Param<'_>) -> bool {\n     if let PatKind::Binding(.., name, _) = slf.pat.kind {\n         name.name == kw::SelfLower\n     } else {\n@@ -896,14 +904,14 @@ pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     false\n }\n \n-pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param> {\n+pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body<'_>) -> impl Iterator<Item = &'tcx Param<'tcx>> {\n     (0..decl.inputs.len()).map(move |i| &body.params[i])\n }\n \n /// Checks if a given expression is a match expression expanded from the `?`\n /// operator or the `try` macro.\n-pub fn is_try(expr: &Expr) -> Option<&Expr> {\n-    fn is_ok(arm: &Arm) -> bool {\n+pub fn is_try<'tcx>(expr: &'tcx Expr<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n+    fn is_ok(arm: &Arm<'_>) -> bool {\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pat.kind;\n             if match_qpath(path, &paths::RESULT_OK[1..]);\n@@ -918,7 +926,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n         false\n     }\n \n-    fn is_err(arm: &Arm) -> bool {\n+    fn is_err(arm: &Arm<'_>) -> bool {\n         if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n             match_qpath(path, &paths::RESULT_ERR[1..])\n         } else {\n@@ -954,7 +962,7 @@ pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> b\n     cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n-pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n+pub fn get_arg_name(pat: &Pat<'_>) -> Option<ast::Name> {\n     match pat.kind {\n         PatKind::Binding(.., ident, None) => Some(ident.name),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n@@ -1088,9 +1096,9 @@ pub fn has_iter_method(cx: &LateContext<'_, '_>, probably_ref_ty: Ty<'_>) -> Opt\n /// ```\n pub fn match_function_call<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    expr: &'tcx Expr,\n+    expr: &'tcx Expr<'_>,\n     path: &[&str],\n-) -> Option<&'tcx [Expr]> {\n+) -> Option<&'tcx [Expr<'tcx>]> {\n     if_chain! {\n         if let ExprKind::Call(ref fun, ref args) = expr.kind;\n         if let ExprKind::Path(ref qpath) = fun.kind;\n@@ -1193,9 +1201,11 @@ pub fn match_def_path<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, did: DefId, syms: &[\n /// sequence of `if/else`.\n /// E.g., this returns `([a, b], [c, d, e])` for the expression\n /// `if a { c } else if b { d } else { e }`.\n-pub fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block; 1]>) {\n+pub fn if_sequence<'tcx>(\n+    mut expr: &'tcx Expr<'tcx>,\n+) -> (SmallVec<[&'tcx Expr<'tcx>; 1]>, SmallVec<[&'tcx Block<'tcx>; 1]>) {\n     let mut conds = SmallVec::new();\n-    let mut blocks: SmallVec<[&Block; 1]> = SmallVec::new();\n+    let mut blocks: SmallVec<[&Block<'_>; 1]> = SmallVec::new();\n \n     while let Some((ref cond, ref then_expr, ref else_expr)) = higher::if_block(&expr) {\n         conds.push(&**cond);\n@@ -1222,7 +1232,7 @@ pub fn if_sequence(mut expr: &Expr) -> (SmallVec<[&Expr; 1]>, SmallVec<[&Block;\n     (conds, blocks)\n }\n \n-pub fn parent_node_is_if_expr<'a, 'b>(expr: &Expr, cx: &LateContext<'a, 'b>) -> bool {\n+pub fn parent_node_is_if_expr<'a, 'b>(expr: &Expr<'_>, cx: &LateContext<'a, 'b>) -> bool {\n     let map = cx.tcx.hir();\n     let parent_id = map.get_parent_node(expr.hir_id);\n     let parent_node = map.get(parent_id);\n@@ -1280,7 +1290,7 @@ pub fn is_must_use_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> boo\n }\n \n // check if expr is calling method or function with #[must_use] attribyte\n-pub fn is_must_use_func_call(cx: &LateContext<'_, '_>, expr: &Expr) -> bool {\n+pub fn is_must_use_func_call(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     let did = match expr.kind {\n         ExprKind::Call(ref path, _) => if_chain! {\n             if let ExprKind::Path(ref qpath) = path.kind;"}, {"sha": "206ce7b4521f86836c2b7675cca0e6535c68635a", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -52,7 +52,7 @@ struct PtrCloneVisitor<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if self.abort {\n             return;\n         }\n@@ -80,6 +80,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n     }\n }\n \n-fn get_binding_name(arg: &Param) -> Option<Name> {\n+fn get_binding_name(arg: &Param<'_>) -> Option<Name> {\n     get_pat_name(&arg.pat)\n }"}, {"sha": "94e09e95f73d1b19783b7798f82f0f795137239e", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -43,7 +43,7 @@ impl Display for Sugg<'_> {\n #[allow(clippy::wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n-    pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr) -> Option<Self> {\n+    pub fn hir_opt(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) -> Option<Self> {\n         snippet_opt(cx, expr.span).map(|snippet| {\n             let snippet = Cow::Owned(snippet);\n             Self::hir_from_snippet(cx, expr, snippet)\n@@ -52,7 +52,7 @@ impl<'a> Sugg<'a> {\n \n     /// Convenience function around `hir_opt` for suggestions with a default\n     /// text.\n-    pub fn hir(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n+    pub fn hir(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n         Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n     }\n \n@@ -65,7 +65,7 @@ impl<'a> Sugg<'a> {\n     /// `HasPlaceholders`\n     pub fn hir_with_applicability(\n         cx: &LateContext<'_, '_>,\n-        expr: &hir::Expr,\n+        expr: &hir::Expr<'_>,\n         default: &'a str,\n         applicability: &mut Applicability,\n     ) -> Self {\n@@ -81,15 +81,15 @@ impl<'a> Sugg<'a> {\n     }\n \n     /// Same as `hir`, but will use the pre expansion span if the `expr` was in a macro.\n-    pub fn hir_with_macro_callsite(cx: &LateContext<'_, '_>, expr: &hir::Expr, default: &'a str) -> Self {\n+    pub fn hir_with_macro_callsite(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, default: &'a str) -> Self {\n         let snippet = snippet_with_macro_callsite(cx, expr.span, default);\n \n         Self::hir_from_snippet(cx, expr, snippet)\n     }\n \n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n-    fn hir_from_snippet(cx: &LateContext<'_, '_>, expr: &hir::Expr, snippet: Cow<'a, str>) -> Self {\n+    fn hir_from_snippet(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n         if let Some(range) = higher::range(cx, expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,"}, {"sha": "576fc51aec0d37c89d04c415c28d5571aa954c68", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_typeck::expr_use_visitor::*;\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n-pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n+pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n     let mut delegate = MutVarsDelegate {\n         used_mutably: FxHashSet::default(),\n         skip: false,\n@@ -22,7 +22,11 @@ pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tc\n     Some(delegate.used_mutably)\n }\n \n-pub fn is_potentially_mutated<'a, 'tcx>(variable: &'tcx Path, expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> bool {\n+pub fn is_potentially_mutated<'a, 'tcx>(\n+    variable: &'tcx Path,\n+    expr: &'tcx Expr<'_>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+) -> bool {\n     if let Res::Local(id) = variable.res {\n         mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n     } else {"}, {"sha": "091be3bc2936b010744487d03b32a08dfbdd905e", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -29,7 +29,7 @@ declare_clippy_lint! {\n declare_lint_pass!(UselessVec => [USELESS_VEC]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessVec {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.tables.expr_ty_adjusted(expr).kind;"}, {"sha": "06d4aa00f6b032b72c9f2804eafd03ec3ac7ba6a", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fcb5304e27a747267276cdbac720f4bd2672172/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=0fcb5304e27a747267276cdbac720f4bd2672172", "patch": "@@ -26,7 +26,7 @@ declare_clippy_lint! {\n declare_lint_pass!(ZeroDiv => [ZERO_DIVIDED_BY_ZERO]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ZeroDiv {\n-    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         // check for instances of 0.0/0.0\n         if_chain! {\n             if let ExprKind::Binary(ref op, ref left, ref right) = expr.kind;"}]}