{"sha": "08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZGQzMGQ5ZWI2ODVmMjliODJmYWFlNjZiNWZkYjlmYzQ3NjJhOTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-19T13:10:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-19T13:10:37Z"}, "message": "Auto merge of #23498 - pcwalton:inline-police, r=cmr\n\nr? @cmr", "tree": {"sha": "e82b7453d6dee8668d51f2208e1574c7c8f1afb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e82b7453d6dee8668d51f2208e1574c7c8f1afb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "html_url": "https://github.com/rust-lang/rust/commit/08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5408f376f93123a043845b69d467d4b7686ae86", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5408f376f93123a043845b69d467d4b7686ae86", "html_url": "https://github.com/rust-lang/rust/commit/d5408f376f93123a043845b69d467d4b7686ae86"}, {"sha": "01c125e548181f6045a63374beec944453ebddff", "url": "https://api.github.com/repos/rust-lang/rust/commits/01c125e548181f6045a63374beec944453ebddff", "html_url": "https://github.com/rust-lang/rust/commit/01c125e548181f6045a63374beec944453ebddff"}], "stats": {"total": 458, "additions": 450, "deletions": 8}, "files": [{"sha": "8528be2860cca2624f820c46349daaf942ac4445", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "patch": "@@ -210,6 +210,21 @@ impl<T> Arc<T> {\n         // contents.\n         unsafe { &**self._ptr }\n     }\n+\n+    // Non-inlined part of `drop`.\n+    #[inline(never)]\n+    unsafe fn drop_slow(&mut self) {\n+        let ptr = *self._ptr;\n+\n+        // Destroy the data at this time, even though we may not free the box allocation itself\n+        // (there may still be weak pointers lying around).\n+        drop(ptr::read(&self.inner().data));\n+\n+        if self.inner().weak.fetch_sub(1, Release) == 1 {\n+            atomic::fence(Acquire);\n+            deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(), min_align_of::<ArcInner<T>>())\n+        }\n+    }\n }\n \n /// Get the number of weak references to this value.\n@@ -325,6 +340,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     ///\n     /// } // implicit drop\n     /// ```\n+    #[inline]\n     fn drop(&mut self) {\n         // This structure has #[unsafe_no_drop_flag], so this drop glue may run more than once (but\n         // it is guaranteed to be zeroed after the first if it's run more than once)\n@@ -353,14 +369,8 @@ impl<T: Sync + Send> Drop for Arc<T> {\n         // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)\n         atomic::fence(Acquire);\n \n-        // Destroy the data at this time, even though we may not free the box allocation itself\n-        // (there may still be weak pointers lying around).\n-        unsafe { drop(ptr::read(&self.inner().data)); }\n-\n-        if self.inner().weak.fetch_sub(1, Release) == 1 {\n-            atomic::fence(Acquire);\n-            unsafe { deallocate(ptr as *mut u8, size_of::<ArcInner<T>>(),\n-                                min_align_of::<ArcInner<T>>()) }\n+        unsafe {\n+            self.drop_slow()\n         }\n     }\n }"}, {"sha": "e24ade58a5224e36f33d440f00d19038b6ad1020", "filename": "src/libunicode/char.rs", "status": "modified", "additions": 432, "deletions": 0, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/src%2Flibunicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08dd30d9eb685f29b82faae66b5fdb9fc4762a91/src%2Flibunicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fchar.rs?ref=08dd30d9eb685f29b82faae66b5fdb9fc4762a91", "patch": "@@ -41,6 +41,426 @@ pub use normalize::{decompose_canonical, decompose_compatible, compose};\n pub use tables::normalization::canonical_combining_class;\n pub use tables::UNICODE_VERSION;\n \n+#[cfg(stage0)]\n+/// Functionality for manipulating `char`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait CharExt {\n+    /// Checks if a `char` parses as a numeric digit in the given radix.\n+    ///\n+    /// Compared to `is_numeric()`, this function only recognizes the characters\n+    /// `0-9`, `a-z` and `A-Z`.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns `true` if `c` is a valid digit under `radix`, and `false`\n+    /// otherwise.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix > 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert!(c.is_digit(10));\n+    ///\n+    /// assert!('f'.is_digit(16));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_digit(self, radix: u32) -> bool;\n+\n+    /// Converts a character to the corresponding digit.\n+    ///\n+    /// # Return value\n+    ///\n+    /// If `c` is between '0' and '9', the corresponding value between 0 and\n+    /// 9. If `c` is 'a' or 'A', 10. If `c` is 'b' or 'B', 11, etc. Returns\n+    /// none if the character does not refer to a digit in the given radix.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix outside the range [0..36].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let c = '1';\n+    ///\n+    /// assert_eq!(c.to_digit(10), Some(1));\n+    ///\n+    /// assert_eq!('f'.to_digit(16), Some(15));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n+\n+    /// Returns an iterator that yields the hexadecimal Unicode escape of a\n+    /// character, as `char`s.\n+    ///\n+    /// All characters are escaped with Rust syntax of the form `\\\\u{NNNN}`\n+    /// where `NNNN` is the shortest hexadecimal representation of the code\n+    /// point.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\u2764'.escape_unicode() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// u\n+    /// {\n+    /// 2\n+    /// 7\n+    /// 6\n+    /// 4\n+    /// }\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let heart: String = '\u2764'.escape_unicode().collect();\n+    ///\n+    /// assert_eq!(heart, r\"\\u{2764}\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn escape_unicode(self) -> EscapeUnicode;\n+\n+    /// Returns an iterator that yields the 'default' ASCII and\n+    /// C++11-like literal escape of a character, as `char`s.\n+    ///\n+    /// The default is chosen with a bias toward producing literals that are\n+    /// legal in a variety of languages, including C++11 and similar C-family\n+    /// languages. The exact rules are:\n+    ///\n+    /// * Tab, CR and LF are escaped as '\\t', '\\r' and '\\n' respectively.\n+    /// * Single-quote, double-quote and backslash chars are backslash-\n+    ///   escaped.\n+    /// * Any other chars in the range [0x20,0x7e] are not escaped.\n+    /// * Any other chars are given hex Unicode escapes; see `escape_unicode`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// for i in '\"'.escape_default() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    /// ```\n+    ///\n+    /// This prints:\n+    ///\n+    /// ```text\n+    /// \\\n+    /// \"\n+    /// ```\n+    ///\n+    /// Collecting into a `String`:\n+    ///\n+    /// ```\n+    /// let quote: String = '\"'.escape_default().collect();\n+    ///\n+    /// assert_eq!(quote, \"\\\\\\\"\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn escape_default(self) -> EscapeDefault;\n+\n+    /// Returns the number of bytes this character would need if encoded in\n+    /// UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf8();\n+    ///\n+    /// assert_eq!(n, 2);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn len_utf8(self) -> usize;\n+\n+    /// Returns the number of 16-bit code units this character would need if\n+    /// encoded in UTF-16.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let n = '\u00df'.len_utf16();\n+    ///\n+    /// assert_eq!(n, 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn len_utf16(self) -> usize;\n+\n+    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n+    /// returns the number of bytes written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length four is large enough to\n+    /// encode any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes two bytes to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 2];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(2));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n+\n+    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n+    /// then returns the number of `u16`s written.\n+    ///\n+    /// If the buffer is not large enough, nothing will be written into it and a\n+    /// `None` will be returned. A buffer of length 2 is large enough to encode\n+    /// any `char`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// In both of these examples, '\u00df' takes one `u16` to encode.\n+    ///\n+    /// ```\n+    /// let mut b = [0; 1];\n+    ///\n+    /// let result = '\u00df'.encode_utf16(&mut b);\n+    ///\n+    /// assert_eq!(result, Some(1));\n+    /// ```\n+    ///\n+    /// A buffer that's too small:\n+    ///\n+    /// ```\n+    /// let mut b = [0; 0];\n+    ///\n+    /// let result = '\u00df'.encode_utf8(&mut b);\n+    ///\n+    /// assert_eq!(result, None);\n+    /// ```\n+    #[unstable(feature = \"unicode\",\n+               reason = \"pending decision about Iterator/Writer/Reader\")]\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n+\n+    /// Returns whether the specified character is considered a Unicode\n+    /// alphabetic code point.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_alphabetic(self) -> bool;\n+\n+    /// Returns whether the specified character satisfies the 'XID_Start'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Start' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to ID_Start but modified for closure under NFKx.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"mainly needed for compiler internals\")]\n+    fn is_xid_start(self) -> bool;\n+\n+    /// Returns whether the specified `char` satisfies the 'XID_Continue'\n+    /// Unicode property.\n+    ///\n+    /// 'XID_Continue' is a Unicode Derived Property specified in\n+    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n+    /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"mainly needed for compiler internals\")]\n+    fn is_xid_continue(self) -> bool;\n+\n+    /// Indicates whether a character is in lowercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Lowercase`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_lowercase(self) -> bool;\n+\n+    /// Indicates whether a character is in uppercase.\n+    ///\n+    /// This is defined according to the terms of the Unicode Derived Core\n+    /// Property `Uppercase`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_uppercase(self) -> bool;\n+\n+    /// Indicates whether a character is whitespace.\n+    ///\n+    /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_whitespace(self) -> bool;\n+\n+    /// Indicates whether a character is alphanumeric.\n+    ///\n+    /// Alphanumericness is defined in terms of the Unicode General Categories\n+    /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_alphanumeric(self) -> bool;\n+\n+    /// Indicates whether a character is a control code point.\n+    ///\n+    /// Control code points are defined in terms of the Unicode General\n+    /// Category `Cc`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_control(self) -> bool;\n+\n+    /// Indicates whether the character is numeric (Nd, Nl, or No).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn is_numeric(self) -> bool;\n+\n+    /// Converts a character to its lowercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping. See\n+    /// `to_uppercase()` for references and more information.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// lowercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_lowercase(self) -> ToLowercase;\n+\n+    /// Converts a character to its uppercase equivalent.\n+    ///\n+    /// The case-folding performed is the common or simple mapping: it maps\n+    /// one Unicode codepoint to its uppercase equivalent according to the\n+    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n+    /// considered here, but the iterator returned will soon support this form\n+    /// of case folding.\n+    ///\n+    /// A full reference can be found here [2].\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// uppercase equivalent of the character. If no conversion is possible then\n+    /// the input character is returned.\n+    ///\n+    /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    ///\n+    /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    ///\n+    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn to_uppercase(self) -> ToUppercase;\n+\n+    /// Returns this character's displayed width in columns, or `None` if it is a\n+    /// control character other than `'\\x00'`.\n+    ///\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n+    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n+    /// In CJK contexts, `is_cjk` should be `true`, else it should be `false`.\n+    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n+    /// recommends that these characters be treated as 1 column (i.e.,\n+    /// `is_cjk` = `false`) if the context cannot be reliably determined.\n+    #[unstable(feature = \"unicode\",\n+               reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n+    fn width(self, is_cjk: bool) -> Option<usize>;\n+}\n+\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl CharExt for char {\n+    #[inline]\n+    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n+    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n+    fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n+    fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n+    fn len_utf8(self) -> usize { C::len_utf8(self) }\n+    fn len_utf16(self) -> usize { C::len_utf16(self) }\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n+\n+    #[inline]\n+    fn is_alphabetic(self) -> bool {\n+        match self {\n+            'a' ... 'z' | 'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Alphabetic(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n+\n+    #[inline]\n+    fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n+\n+    #[inline]\n+    fn is_lowercase(self) -> bool {\n+        match self {\n+            'a' ... 'z' => true,\n+            c if c > '\\x7f' => derived_property::Lowercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_uppercase(self) -> bool {\n+        match self {\n+            'A' ... 'Z' => true,\n+            c if c > '\\x7f' => derived_property::Uppercase(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_whitespace(self) -> bool {\n+        match self {\n+            ' ' | '\\x09' ... '\\x0d' => true,\n+            c if c > '\\x7f' => property::White_Space(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_alphanumeric(self) -> bool {\n+        self.is_alphabetic() || self.is_numeric()\n+    }\n+\n+    #[inline]\n+    fn is_control(self) -> bool { general_category::Cc(self) }\n+\n+    #[inline]\n+    fn is_numeric(self) -> bool {\n+        match self {\n+            '0' ... '9' => true,\n+            c if c > '\\x7f' => general_category::N(c),\n+            _ => false\n+        }\n+    }\n+\n+    #[inline]\n+    fn to_lowercase(self) -> ToLowercase {\n+        ToLowercase(Some(conversions::to_lower(self)))\n+    }\n+\n+    #[inline]\n+    fn to_uppercase(self) -> ToUppercase {\n+        ToUppercase(Some(conversions::to_upper(self)))\n+    }\n+\n+    #[inline]\n+    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n+}\n+\n /// An iterator over the lowercase mapping of a given character, returned from\n /// the `lowercase` method on characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -90,6 +510,7 @@ impl char {\n     /// assert!('f'.is_digit(16));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n \n     /// Converts a character to the corresponding digit.\n@@ -285,6 +706,7 @@ impl char {\n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_alphabetic(self) -> bool {\n         match self {\n             'a' ... 'z' | 'A' ... 'Z' => true,\n@@ -301,6 +723,7 @@ impl char {\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n     #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n+    #[inline]\n     pub fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n     /// Returns whether the specified `char` satisfies the 'XID_Continue'\n@@ -311,13 +734,15 @@ impl char {\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n     #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n+    #[inline]\n     pub fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n     /// Indicates whether a character is in lowercase.\n     ///\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Lowercase`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_lowercase(self) -> bool {\n         match self {\n             'a' ... 'z' => true,\n@@ -331,6 +756,7 @@ impl char {\n     /// This is defined according to the terms of the Unicode Derived Core\n     /// Property `Uppercase`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_uppercase(self) -> bool {\n         match self {\n             'A' ... 'Z' => true,\n@@ -343,6 +769,7 @@ impl char {\n     ///\n     /// Whitespace is defined in terms of the Unicode Property `White_Space`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09' ... '\\x0d' => true,\n@@ -356,6 +783,7 @@ impl char {\n     /// Alphanumericness is defined in terms of the Unicode General Categories\n     /// 'Nd', 'Nl', 'No' and the Derived Core Property 'Alphabetic'.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_alphanumeric(self) -> bool {\n         self.is_alphabetic() || self.is_numeric()\n     }\n@@ -365,10 +793,12 @@ impl char {\n     /// Control code points are defined in terms of the Unicode General\n     /// Category `Cc`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_control(self) -> bool { general_category::Cc(self) }\n \n     /// Indicates whether the character is numeric (Nd, Nl, or No).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn is_numeric(self) -> bool {\n         match self {\n             '0' ... '9' => true,\n@@ -388,6 +818,7 @@ impl char {\n     /// lowercase equivalent of the character. If no conversion is possible then\n     /// the input character is returned.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n         ToLowercase(Some(conversions::to_lower(self)))\n     }\n@@ -414,6 +845,7 @@ impl char {\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n     pub fn to_uppercase(self) -> ToUppercase {\n         ToUppercase(Some(conversions::to_upper(self)))\n     }"}]}