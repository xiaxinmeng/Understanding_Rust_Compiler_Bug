{"sha": "a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTExNmZiZmExMWNhZDRlMDNiOGIzMWY4ZDQ0OThmM2RkZDVkOWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T16:20:06Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-09T16:20:06Z"}, "message": "Simplify", "tree": {"sha": "c2c3a0bbd12b08198c2d730eb9fa7e92b0a3aa37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2c3a0bbd12b08198c2d730eb9fa7e92b0a3aa37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "html_url": "https://github.com/rust-lang/rust/commit/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56c8581b901427ee3e63052c531f3ba3b1ec112d", "url": "https://api.github.com/repos/rust-lang/rust/commits/56c8581b901427ee3e63052c531f3ba3b1ec112d", "html_url": "https://github.com/rust-lang/rust/commit/56c8581b901427ee3e63052c531f3ba3b1ec112d"}], "stats": {"total": 39, "additions": 13, "deletions": 26}, "files": [{"sha": "c7df15662e58f86cf796091819ef2a25e066751b", "filename": "crates/ra_syntax/src/ast/extensions.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fextensions.rs?ref=a95116fbfa11cad4e03b8b31f8d4498f3ddd5d9e", "patch": "@@ -2,16 +2,14 @@\n //! Extensions for various expressions live in a sibling `expr_extensions` module.\n \n use itertools::Itertools;\n+use ra_parser::SyntaxKind;\n \n use crate::{\n     ast::{\n         self, child_opt, children, support, AstNode, AstToken, AttrInput, NameOwner, SyntaxNode,\n     },\n-    SmolStr, SyntaxElement,\n-    SyntaxKind::*,\n-    SyntaxToken, T,\n+    SmolStr, SyntaxElement, SyntaxToken, T,\n };\n-use ra_parser::SyntaxKind;\n \n impl ast::Name {\n     pub fn text(&self) -> &SmolStr {\n@@ -25,13 +23,11 @@ impl ast::NameRef {\n     }\n \n     pub fn as_tuple_field(&self) -> Option<usize> {\n-        self.syntax().children_with_tokens().find_map(|c| {\n-            if c.kind() == SyntaxKind::INT_NUMBER {\n-                c.as_token().and_then(|tok| tok.text().as_str().parse().ok())\n-            } else {\n-                None\n-            }\n-        })\n+        if let Some(ast::NameRefToken::IntNumber(token)) = self.name_ref_token() {\n+            token.text().as_str().parse().ok()\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -142,10 +138,7 @@ impl ast::Path {\n \n impl ast::Module {\n     pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == T![;],\n-        }\n+        self.semi().is_some()\n     }\n }\n \n@@ -181,7 +174,7 @@ impl ast::ImplDef {\n     }\n \n     pub fn is_negative(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|t| t.kind() == T![!])\n+        self.excl().is_some()\n     }\n }\n \n@@ -225,14 +218,11 @@ impl ast::EnumVariant {\n \n impl ast::FnDef {\n     pub fn semicolon_token(&self) -> Option<SyntaxToken> {\n-        self.syntax()\n-            .last_child_or_token()\n-            .and_then(|it| it.into_token())\n-            .filter(|it| it.kind() == T![;])\n+        Some(self.semi()?.syntax().clone())\n     }\n \n     pub fn is_async(&self) -> bool {\n-        self.syntax().children_with_tokens().any(|it| it.kind() == T![async])\n+        self.async_kw().is_some()\n     }\n }\n \n@@ -245,16 +235,13 @@ impl ast::LetStmt {\n     }\n \n     pub fn eq_token(&self) -> Option<SyntaxToken> {\n-        self.syntax().children_with_tokens().find(|t| t.kind() == EQ).and_then(|it| it.into_token())\n+        Some(self.eq()?.syntax().clone())\n     }\n }\n \n impl ast::ExprStmt {\n     pub fn has_semi(&self) -> bool {\n-        match self.syntax().last_child_or_token() {\n-            None => false,\n-            Some(node) => node.kind() == T![;],\n-        }\n+        self.semi().is_some()\n     }\n }\n "}]}