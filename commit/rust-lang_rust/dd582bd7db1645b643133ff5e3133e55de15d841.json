{"sha": "dd582bd7db1645b643133ff5e3133e55de15d841", "node_id": "C_kwDOAAsO6NoAKGRkNTgyYmQ3ZGIxNjQ1YjY0MzEzM2ZmNWUzMTMzZTU1ZGUxNWQ4NDE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-13T21:08:15Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-27T19:25:16Z"}, "message": "Implement checked Shl/Shr at MIR building.", "tree": {"sha": "516292e2dedd19a5ffac425bdd2b221bead3c3dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/516292e2dedd19a5ffac425bdd2b221bead3c3dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd582bd7db1645b643133ff5e3133e55de15d841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd582bd7db1645b643133ff5e3133e55de15d841", "html_url": "https://github.com/rust-lang/rust/commit/dd582bd7db1645b643133ff5e3133e55de15d841", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd582bd7db1645b643133ff5e3133e55de15d841/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "43ee4d15bf201f72c36abd7f02961df87dead441", "url": "https://api.github.com/repos/rust-lang/rust/commits/43ee4d15bf201f72c36abd7f02961df87dead441", "html_url": "https://github.com/rust-lang/rust/commit/43ee4d15bf201f72c36abd7f02961df87dead441"}], "stats": {"total": 216, "additions": 109, "deletions": 107}, "files": [{"sha": "fbecdab158c8e392a3d4fbdea74cec3792fb2bb4", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -170,14 +170,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     in_lhs: CValue<'tcx>,\n     in_rhs: CValue<'tcx>,\n ) -> CValue<'tcx> {\n-    if bin_op != BinOp::Shl && bin_op != BinOp::Shr {\n-        assert_eq!(\n-            in_lhs.layout().ty,\n-            in_rhs.layout().ty,\n-            \"checked int binop requires lhs and rhs of same type\"\n-        );\n-    }\n-\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n@@ -271,21 +263,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n                 _ => unreachable!(\"invalid non-integer type {}\", ty),\n             }\n         }\n-        BinOp::Shl => {\n-            let val = fx.bcx.ins().ishl(lhs, rhs);\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n-        BinOp::Shr => {\n-            let val =\n-                if !signed { fx.bcx.ins().ushr(lhs, rhs) } else { fx.bcx.ins().sshr(lhs, rhs) };\n-            let ty = fx.bcx.func.dfg.value_type(val);\n-            let max_shift = i64::from(ty.bits()) - 1;\n-            let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n-            (val, has_overflow)\n-        }\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n "}, {"sha": "13c4fa132d877ffa98f2b2e1b64b8409126755c8", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -663,17 +663,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 bx.checked_binop(oop, input_ty, lhs, rhs)\n             }\n-            mir::BinOp::Shl | mir::BinOp::Shr => {\n-                let lhs_llty = bx.cx().val_ty(lhs);\n-                let rhs_llty = bx.cx().val_ty(rhs);\n-                let invert_mask = common::shift_mask_val(bx, lhs_llty, rhs_llty, true);\n-                let outer_bits = bx.and(rhs, invert_mask);\n-\n-                let of = bx.icmp(IntPredicate::IntNE, outer_bits, bx.cx().const_null(rhs_llty));\n-                let val = self.codegen_scalar_binop(bx, op, lhs, rhs, input_ty);\n-\n-                (val, of)\n-            }\n             _ => bug!(\"Operator `{:?}` is not a checkable operator\", op),\n         };\n "}, {"sha": "785dde93e31ac4b01d29ee5fb886654cce286e25", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -553,15 +553,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    Shl | Shr => {\n-                        for x in [a, b] {\n-                            check_kinds!(\n-                                x,\n-                                \"Cannot perform checked shift on non-integer type {:?}\",\n-                                ty::Uint(..) | ty::Int(..)\n-                            )\n-                        }\n-                    }\n                     _ => self.fail(location, format!(\"There is no checked version of {:?}\", op)),\n                 }\n             }"}, {"sha": "754b6efd692d8be3a5c767abd09fa7c063f45063", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -59,22 +59,13 @@ impl<'tcx> fmt::Display for Discr<'tcx> {\n     }\n }\n \n-fn int_size_and_signed<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> (Size, bool) {\n-    let (int, signed) = match *ty.kind() {\n-        ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n-        ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n-        _ => bug!(\"non integer discriminant\"),\n-    };\n-    (int.size(), signed)\n-}\n-\n impl<'tcx> Discr<'tcx> {\n     /// Adds `1` to the value and wraps around if the maximum for the type is reached.\n     pub fn wrap_incr(self, tcx: TyCtxt<'tcx>) -> Self {\n         self.checked_add(tcx, 1).0\n     }\n     pub fn checked_add(self, tcx: TyCtxt<'tcx>, n: u128) -> (Self, bool) {\n-        let (size, signed) = int_size_and_signed(tcx, self.ty);\n+        let (size, signed) = self.ty.int_size_and_signed(tcx);\n         let (val, oflo) = if signed {\n             let min = size.signed_int_min();\n             let max = size.signed_int_max();\n@@ -922,12 +913,21 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for OpaqueTypeExpander<'tcx> {\n }\n \n impl<'tcx> Ty<'tcx> {\n+    pub fn int_size_and_signed(self, tcx: TyCtxt<'tcx>) -> (Size, bool) {\n+        let (int, signed) = match *self.kind() {\n+            ty::Int(ity) => (Integer::from_int_ty(&tcx, ity), true),\n+            ty::Uint(uty) => (Integer::from_uint_ty(&tcx, uty), false),\n+            _ => bug!(\"non integer discriminant\"),\n+        };\n+        (int.size(), signed)\n+    }\n+\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n     pub fn numeric_max_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n-                let (size, signed) = int_size_and_signed(tcx, self);\n+                let (size, signed) = self.int_size_and_signed(tcx);\n                 let val =\n                     if signed { size.signed_int_max() as u128 } else { size.unsigned_int_max() };\n                 Some(val)\n@@ -948,7 +948,7 @@ impl<'tcx> Ty<'tcx> {\n     pub fn numeric_min_val(self, tcx: TyCtxt<'tcx>) -> Option<ty::Const<'tcx>> {\n         let val = match self.kind() {\n             ty::Int(_) | ty::Uint(_) => {\n-                let (size, signed) = int_size_and_signed(tcx, self);\n+                let (size, signed) = self.int_size_and_signed(tcx);\n                 let val = if signed { size.truncate(size.signed_int_min() as u128) } else { 0 };\n                 Some(val)\n             }"}, {"sha": "259e0f8f75c1b4423050bc6089a4a008758454d6", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 63, "deletions": 22, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -9,6 +9,7 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n@@ -519,30 +520,68 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ) -> BlockAnd<Rvalue<'tcx>> {\n         let source_info = self.source_info(span);\n         let bool_ty = self.tcx.types.bool;\n-        if self.check_overflow && op.is_checkable() && ty.is_integral() {\n-            let result_tup = self.tcx.mk_tup(&[ty, bool_ty]);\n-            let result_value = self.temp(result_tup, span);\n+        let rvalue = match op {\n+            BinOp::Add | BinOp::Sub | BinOp::Mul if self.check_overflow && ty.is_integral() => {\n+                let result_tup = self.tcx.mk_tup(&[ty, bool_ty]);\n+                let result_value = self.temp(result_tup, span);\n \n-            self.cfg.push_assign(\n-                block,\n-                source_info,\n-                result_value,\n-                Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n-            );\n-            let val_fld = Field::new(0);\n-            let of_fld = Field::new(1);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    result_value,\n+                    Rvalue::CheckedBinaryOp(op, Box::new((lhs.to_copy(), rhs.to_copy()))),\n+                );\n+                let val_fld = Field::new(0);\n+                let of_fld = Field::new(1);\n+\n+                let tcx = self.tcx;\n+                let val = tcx.mk_place_field(result_value, val_fld, ty);\n+                let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n \n-            let tcx = self.tcx;\n-            let val = tcx.mk_place_field(result_value, val_fld, ty);\n-            let of = tcx.mk_place_field(result_value, of_fld, bool_ty);\n+                let err = AssertKind::Overflow(op, lhs, rhs);\n+                block = self.assert(block, Operand::Move(of), false, err, span);\n \n-            let err = AssertKind::Overflow(op, lhs, rhs);\n+                Rvalue::Use(Operand::Move(val))\n+            }\n+            BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n+                // Consider that the shift overflows if `rhs < 0` or `rhs >= bits`.\n+                // This can be encoded as a single operation as `(rhs & -bits) != 0`.\n+                let (size, _) = ty.int_size_and_signed(self.tcx);\n+                let bits = size.bits();\n+                debug_assert!(bits.is_power_of_two());\n+                let mask = !((bits - 1) as u128);\n+\n+                let rhs_ty = rhs.ty(&self.local_decls, self.tcx);\n+                let (rhs_size, _) = rhs_ty.int_size_and_signed(self.tcx);\n+                let mask = Operand::const_from_scalar(\n+                    self.tcx,\n+                    rhs_ty,\n+                    Scalar::from_uint(rhs_size.truncate(mask), rhs_size),\n+                    span,\n+                );\n \n-            block = self.assert(block, Operand::Move(of), false, err, span);\n+                let outer_bits = self.temp(rhs_ty, span);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    outer_bits,\n+                    Rvalue::BinaryOp(BinOp::BitAnd, Box::new((rhs.to_copy(), mask))),\n+                );\n \n-            block.and(Rvalue::Use(Operand::Move(val)))\n-        } else {\n-            if ty.is_integral() && (op == BinOp::Div || op == BinOp::Rem) {\n+                let overflows = self.temp(bool_ty, span);\n+                let zero = self.zero_literal(span, rhs_ty);\n+                self.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    overflows,\n+                    Rvalue::BinaryOp(BinOp::Ne, Box::new((Operand::Move(outer_bits), zero))),\n+                );\n+\n+                let overflow_err = AssertKind::Overflow(op, lhs.to_copy(), rhs.to_copy());\n+                block = self.assert(block, Operand::Move(overflows), false, overflow_err, span);\n+                Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n+            }\n+            BinOp::Div | BinOp::Rem if ty.is_integral() => {\n                 // Checking division and remainder is more complex, since we 1. always check\n                 // and 2. there are two possible failure cases, divide-by-zero and overflow.\n \n@@ -601,10 +640,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                     block = self.assert(block, Operand::Move(of), false, overflow_err, span);\n                 }\n-            }\n \n-            block.and(Rvalue::BinaryOp(op, Box::new((lhs, rhs))))\n-        }\n+                Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n+            }\n+            _ => Rvalue::BinaryOp(op, Box::new((lhs, rhs))),\n+        };\n+        block.and(rvalue)\n     }\n \n     fn build_zero_repeat("}, {"sha": "fb0b3866e696baf062c0265ee1d5fb87a954bdf2", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -12,13 +12,14 @@\n       let mut _7: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n       let mut _8: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _9: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:33: +1:39\n-      let mut _10: (u32, bool);            // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      let mut _11: (u32, bool);            // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _10: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _11: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _12: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:14:5: 14:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n-          let mut _12: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n-          let mut _13: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n-          let mut _14: (u32, bool);        // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n+          let mut _14: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:27\n+          let mut _15: u32;                // in scope 1 at $DIR/issue_101973.rs:7:12: 7:20\n           scope 2 {\n               debug out => _4;             // in scope 2 at $DIR/issue_101973.rs:6:9: 6:16\n           }\n@@ -32,43 +33,46 @@\n           StorageLive(_2);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65\n           StorageLive(_3);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:58\n           StorageLive(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:5: +1:17\n-          StorageLive(_12);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n-          StorageLive(_13);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          _14 = CheckedShr(_1, const 0_i32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          assert(!move (_14.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 0_i32) -> bb3; // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          StorageLive(_14);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n+          StorageLive(_15);                // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _15 = Shr(_1, const 0_i32);      // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n+          _14 = BitAnd(move _15, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n+          StorageDead(_15);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          _4 = BitOr(const 0_u32, move _14); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n+          StorageDead(_14);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n+          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+          StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n+          StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _10 = BitAnd(const 8_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _11 = Ne(move _10, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         assert(!move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _10 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _11 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         assert(!const false, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb1: {\n-          _8 = move (_10.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+          _8 = Shr(_1, const 8_i32);       // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageDead(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:51: +1:52\n-          _11 = CheckedShl(_7, const 1_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-          assert(!move (_11.1: bool), \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _12 = BitAnd(const 1_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _13 = Ne(move _12, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         assert(!move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _12 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _13 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         assert(!const false, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       }\n   \n       bb2: {\n-          _6 = move (_11.0: u32);          // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+          _6 = Shl(move _7, const 1_i32);  // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageDead(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:56: +1:57\n-          _3 = rotate_right::<u32>(_4, _6) -> bb4; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n+          _3 = rotate_right::<u32>(_4, _6) -> bb3; // scope 3 at $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/num/uint_macros.rs:LL:COL\n                                            // + literal: Const { ty: extern \"rust-intrinsic\" fn(u32, u32) -> u32 {rotate_right::<u32>}, val: Value(<ZST>) }\n       }\n   \n       bb3: {\n-          _13 = move (_14.0: u32);         // scope 2 at $DIR/issue_101973.rs:7:12: 7:20\n-          _12 = BitAnd(move _13, const 255_u32); // scope 2 at $DIR/issue_101973.rs:7:12: 7:27\n-          StorageDead(_13);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          _4 = BitOr(const 0_u32, move _12); // scope 2 at $DIR/issue_101973.rs:7:5: 7:27\n-          StorageDead(_12);                // scope 2 at $DIR/issue_101973.rs:7:26: 7:27\n-          StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-          StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n-          StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-          _10 = CheckedShr(_1, const 8_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-          assert(!move (_10.1: bool), \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      }\n-  \n-      bb4: {\n           StorageDead(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           StorageDead(_4);                 // scope 0 at $DIR/issue_101973.rs:+1:57: +1:58\n           _2 = move _3 as i32 (IntToInt);  // scope 0 at $DIR/issue_101973.rs:+1:5: +1:65"}, {"sha": "6530084a5857dd27f7346292dc67e58514971dff", "filename": "tests/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dd582bd7db1645b643133ff5e3133e55de15d841/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dd582bd7db1645b643133ff5e3133e55de15d841/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=dd582bd7db1645b643133ff5e3133e55de15d841", "patch": "@@ -39,19 +39,19 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc17 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc20 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc23 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:79:14"}]}