{"sha": "290da6f016f602337222ac0a09b6b84bde0baf9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MGRhNmYwMTZmNjAyMzM3MjIyYWMwYTA5YjZiODRiZGUwYmFmOWI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T21:55:31Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-18T21:55:31Z"}, "message": "Remove the 30 minute intro\n\nFixes #24569.", "tree": {"sha": "9314bfd584b1b8ef0a3c850fc97be84c7f031d29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9314bfd584b1b8ef0a3c850fc97be84c7f031d29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/290da6f016f602337222ac0a09b6b84bde0baf9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/290da6f016f602337222ac0a09b6b84bde0baf9b", "html_url": "https://github.com/rust-lang/rust/commit/290da6f016f602337222ac0a09b6b84bde0baf9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/290da6f016f602337222ac0a09b6b84bde0baf9b/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a81ce5f991148b3c701c6b4276cdcafe366cd8f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a81ce5f991148b3c701c6b4276cdcafe366cd8f4", "html_url": "https://github.com/rust-lang/rust/commit/a81ce5f991148b3c701c6b4276cdcafe366cd8f4"}], "stats": {"total": 585, "additions": 2, "deletions": 583}, "files": [{"sha": "48712d8d49b55f3f70c5134247dfc54ce46744e2", "filename": "src/doc/intro.md", "status": "modified", "additions": 2, "deletions": 583, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/290da6f016f602337222ac0a09b6b84bde0baf9b/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/290da6f016f602337222ac0a09b6b84bde0baf9b/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=290da6f016f602337222ac0a09b6b84bde0baf9b", "patch": "@@ -1,586 +1,5 @@\n % A 30-minute Introduction to Rust\n \n-Rust is a modern systems programming language focusing on safety and speed. It\n-accomplishes these goals by being memory safe without using garbage collection.\n+This introduction is now deprecated. Please see [the introduction to the book][intro].\n \n-This introduction will give you a rough idea of what Rust is like, eliding many\n-details. It does not require prior experience with systems programming, but you\n-may find the syntax easier if you've used a \"curly brace\" programming language\n-before, like C or JavaScript. The concepts are more important than the syntax,\n-so don't worry if you don't get every last detail: you can read [The\n-Rust Programming Language](book/index.html) to get a more complete explanation.\n-\n-Because this is about high-level concepts, you don't need to actually install\n-Rust to follow along. If you'd like to anyway, check out [the\n-homepage](http://rust-lang.org) for explanation.\n-\n-To show off Rust, let's talk about how easy it is to get started with Rust.\n-Then, we'll talk about Rust's most interesting feature, *ownership*, and\n-then discuss how it makes concurrency easier to reason about. Finally,\n-we'll talk about how Rust breaks down the perceived dichotomy between speed\n-and safety.\n-\n-# Tools\n-\n-Getting started on a new Rust project is incredibly easy, thanks to Rust's\n-package manager, [Cargo](https://crates.io/).\n-\n-To start a new project with Cargo, use `cargo new`:\n-\n-```{bash}\n-$ cargo new hello_world --bin\n-```\n-\n-We're passing `--bin` because we're making a binary program: if we\n-were making a library, we'd leave it off.\n-\n-Let's check out what Cargo has generated for us:\n-\n-```{bash}\n-$ cd hello_world\n-$ tree .\n-.\n-\u251c\u2500\u2500 Cargo.toml\n-\u2514\u2500\u2500 src\n-    \u2514\u2500\u2500 main.rs\n-\n-1 directory, 2 files\n-```\n-\n-This is all we need to get started. First, let's check out `Cargo.toml`:\n-\n-```{toml}\n-[package]\n-\n-name = \"hello_world\"\n-version = \"0.0.1\"\n-authors = [\"Your Name <you@example.com>\"]\n-```\n-\n-This is called a *manifest*, and it contains all of the metadata that Cargo\n-needs to compile your project.\n-\n-Here's what's in `src/main.rs`:\n-\n-```{rust}\n-fn main() {\n-    println!(\"Hello, world!\");\n-}\n-```\n-\n-Cargo generated a \"Hello World\" for us. We'll talk more about the syntax here\n-later, but that's what Rust code looks like! Let's compile and run it:\n-\n-```{bash}\n-$ cargo run\n-   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n-     Running `target/hello_world`\n-Hello, world!\n-```\n-\n-Using an external dependency in Rust is incredibly easy. You add a line to\n-your `Cargo.toml`:\n-\n-```{toml}\n-[package]\n-\n-name = \"hello_world\"\n-version = \"0.0.1\"\n-authors = [\"Your Name <someone@example.com>\"]\n-\n-[dependencies.semver]\n-\n-git = \"https://github.com/rust-lang/semver.git\"\n-```\n-\n-You added the `semver` library, which parses version numbers and compares them\n-according to the [SemVer specification](http://semver.org/).\n-\n-Now, you can pull in that library using `extern crate` in\n-`main.rs`.\n-\n-```{rust,ignore}\n-extern crate semver;\n-\n-use semver::Version;\n-\n-fn main() {\n-    assert!(Version::parse(\"1.2.3\") == Ok(Version {\n-        major: 1u64,\n-        minor: 2u64,\n-        patch: 3u64,\n-        pre: vec!(),\n-        build: vec!(),\n-    }));\n-\n-    println!(\"Versions compared successfully!\");\n-}\n-```\n-\n-Again, we'll discuss the exact details of all of this syntax soon. For now,\n-let's compile and run it:\n-\n-```{bash}\n-$ cargo run\n-    Updating git repository `https://github.com/rust-lang/semver.git`\n-   Compiling semver v0.0.1 (https://github.com/rust-lang/semver.git#bf739419)\n-   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-     Running `target/hello_world`\n-Versions compared successfully!\n-```\n-\n-Because we only specified a repository without a version, if someone else were\n-to try out our project at a later date, when `semver` was updated, they would\n-get a different, possibly incompatible version. To solve this problem, Cargo\n-produces a file, `Cargo.lock`, which records the versions of any dependencies.\n-This gives us repeatable builds.\n-\n-There is a lot more here, and this is a whirlwind tour, but you should feel\n-right at home if you've used tools like [Bundler](http://bundler.io/),\n-[npm](https://www.npmjs.org/), or [pip](https://pip.pypa.io/en/latest/).\n-There's no `Makefile`s or endless `autotools` output here. (Rust's tooling does\n-[play nice with external libraries written in those\n-tools](http://doc.crates.io/build-script.html), if you need to.)\n-\n-Enough about tools, let's talk code!\n-\n-# Ownership\n-\n-Rust's defining feature is \"memory safety without garbage collection\". Let's\n-take a moment to talk about what that means. *Memory safety* means that the\n-programming language eliminates certain kinds of bugs, such as [buffer\n-overflows](https://en.wikipedia.org/wiki/Buffer_overflow) and [dangling\n-pointers](https://en.wikipedia.org/wiki/Dangling_pointer). These problems occur\n-when you have unrestricted access to memory. As an example, here's some Ruby\n-code:\n-\n-```{ruby}\n-v = []\n-\n-v.push(\"Hello\")\n-\n-x = v[0]\n-\n-v.push(\"world\")\n-\n-puts x\n-```\n-\n-We make an array, `v`, and then call `push` on it. `push` is a method which\n-adds an element to the end of an array.\n-\n-Next, we make a new variable, `x`, that's equal to the first element of\n-the array. Simple, but this is where the \"bug\" will appear.\n-\n-Let's keep going. We then call `push` again, pushing \"world\" onto the\n-end of the array. `v` now is `[\"Hello\", \"world\"]`.\n-\n-Finally, we print `x` with the `puts` method. This prints \"Hello.\"\n-\n-All good? Let's go over a similar, but subtly different example, in C++:\n-\n-```{cpp}\n-#include<iostream>\n-#include<vector>\n-#include<string>\n-\n-int main() {\n-    std::vector<std::string> v;\n-\n-    v.push_back(\"Hello\");\n-\n-    std::string& x = v[0];\n-\n-    v.push_back(\"world\");\n-\n-    std::cout << x;\n-}\n-```\n-\n-It's a little more verbose due to the static typing, but it's almost the same\n-thing. We make a `std::vector` of `std::string`s, we call `push_back` (same as\n-`push`) on it, take a reference to the first element of the vector, call\n-`push_back` again, and then print out the reference.\n-\n-There's two big differences here: one, they're not _exactly_ the same thing,\n-and two...\n-\n-```{bash}\n-$ g++ hello.cpp -Wall -Werror\n-$ ./a.out\n-Segmentation fault (core dumped)\n-```\n-\n-A crash! (Note that this is actually system-dependent. Because referring to an\n-invalid reference is undefined behavior, the compiler can do anything,\n-including the right thing!) Even though we compiled with flags to give us as\n-many warnings as possible, and to treat those warnings as errors, we got no\n-errors. When we ran the program, it crashed.\n-\n-Why does this happen? When we append to an array, its length changes. Since\n-its length changes, we may need to allocate more memory. In Ruby, this happens\n-as well, we just don't think about it very often. So why does the C++ version\n-segfault when we allocate more memory?\n-\n-The answer is that in the C++ version, `x` is a *reference* to the memory\n-location where the first element of the array is stored. But in Ruby, `x` is a\n-standalone value, not connected to the underlying array at all. Let's dig into\n-the details for a moment. Your program has access to memory, provided to it by\n-the operating system. Each location in memory has an address.  So when we make\n-our vector, `v`, it's stored in a memory location somewhere:\n-\n-| location | name | value |\n-|----------|------|-------|\n-| 0x30     | v    |       |\n-\n-(Address numbers made up, and in hexadecimal. Those of you with deep C++\n-knowledge, there are some simplifications going on here, like the lack of an\n-allocated length for the vector. This is an introduction.)\n-\n-When we push our first string onto the array, we allocate some memory,\n-and `v` refers to it:\n-\n-| location | name | value    |\n-|----------|------|----------|\n-| 0x30     | v    | 0x18     |\n-| 0x18     |      | \"Hello\"  |\n-\n-We then make a reference to that first element. A reference is a variable\n-that points to a memory location, so its value is the memory location of\n-the `\"Hello\"` string:\n-\n-| location | name | value    |\n-|----------|------|----------|\n-| 0x30     | v    | 0x18     |\n-| 0x18     |      | \"Hello\"  |\n-| 0x14     | x    | 0x18     |\n-\n-When we push `\"world\"` onto the vector with `push_back`, there's no room:\n-we only allocated one element. So, we need to allocate two elements,\n-copy the `\"Hello\"` string over, and update the reference. Like this:\n-\n-| location | name | value    |\n-|----------|------|----------|\n-| 0x30     | v    | 0x08     |\n-| 0x18     |      | GARBAGE  |\n-| 0x14     | x    | 0x18     |\n-| 0x08     |      | \"Hello\"  |\n-| 0x04     |      | \"world\"  |\n-\n-Note that `v` now refers to the new list, which has two elements. It's all\n-good. But our `x` didn't get updated! It still points at the old location,\n-which isn't valid anymore. In fact, [the documentation for `push_back` mentions\n-this](http://en.cppreference.com/w/cpp/container/vector/push_back):\n-\n-> If the new `size()` is greater than `capacity()` then all iterators and\n-> references (including the past-the-end iterator) are invalidated.\n-\n-Finding where these iterators and references are is a difficult problem, and\n-even in this simple case, `g++` can't help us here. While the bug is obvious in\n-this case, in real code, it can be difficult to track down the source of the\n-error.\n-\n-Before we talk about this solution, why didn't our Ruby code have this problem?\n-The semantics are a little more complicated, and explaining Ruby's internals is\n-out of the scope of a guide to Rust. But in a nutshell, Ruby's garbage\n-collector keeps track of references, and makes sure that everything works as\n-you might expect. This comes at an efficiency cost, and the internals are more\n-complex.  If you'd really like to dig into the details, [this\n-article](http://patshaughnessy.net/2012/1/18/seeing-double-how-ruby-shares-string-values)\n-can give you more information.\n-\n-Garbage collection is a valid approach to memory safety, but Rust chooses a\n-different path.  Let's examine what the Rust version of this looks like:\n-\n-```{rust,ignore}\n-fn main() {\n-    let mut v = vec![];\n-\n-    v.push(\"Hello\");\n-\n-    let x = &v[0];\n-\n-    v.push(\"world\");\n-\n-    println!(\"{}\", x);\n-}\n-```\n-\n-This looks like a bit of both: fewer type annotations, but we do create new\n-variables with `let`. The method name is `push`, some other stuff is different,\n-but it's pretty close. So what happens when we compile this code?  Does Rust\n-print `\"Hello\"`, or does Rust crash?\n-\n-Neither. It refuses to compile:\n-\n-```bash\n-$ cargo run\n-   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n-main.rs:8:5: 8:6 error: cannot borrow `v` as mutable because it is also borrowed as immutable\n-main.rs:8     v.push(\"world\");\n-              ^\n-main.rs:6:14: 6:15 note: previous borrow of `v` occurs here; the immutable borrow prevents subsequent moves or mutable borrows of `v` until the borrow ends\n-main.rs:6     let x = &v[0];\n-                       ^\n-main.rs:11:2: 11:2 note: previous borrow ends here\n-main.rs:1 fn main() {\n-...\n-main.rs:11 }\n-           ^\n-error: aborting due to previous error\n-```\n-\n-When we try to mutate the array by `push`ing it the second time, Rust throws\n-an error. It says that we \"cannot borrow v as mutable because it is also\n-borrowed as immutable.\" What does it mean by \"borrowed\"?\n-\n-In Rust, the type system encodes the notion of *ownership*. The variable `v`\n-is an *owner* of the vector. When we make a reference to `v`, we let that\n-variable (in this case, `x`) *borrow* it for a while. Just like if you own a\n-book, and you lend it to me, I'm borrowing the book.\n-\n-So, when I try to modify the vector with the second call to `push`, I need\n-to be owning it. But `x` is borrowing it. You can't modify something that\n-you've lent to someone. And so Rust throws an error.\n-\n-So how do we fix this problem? Well, we can make a copy of the element:\n-\n-\n-```{rust}\n-fn main() {\n-    let mut v = vec![];\n-\n-    v.push(\"Hello\");\n-\n-    let x = v[0].clone();\n-\n-    v.push(\"world\");\n-\n-    println!(\"{}\", x);\n-}\n-```\n-\n-Note the addition of `clone()`. This creates a copy of the element, leaving\n-the original untouched. Now, we no longer have two references to the same\n-memory, and so the compiler is happy. Let's give that a try:\n-\n-```{bash}\n-$ cargo run\n-   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n-     Running `target/hello_world`\n-Hello\n-```\n-\n-Same result. Now, making a copy can be inefficient, so this solution may not be\n-acceptable. There are other ways to get around this problem, but this is a toy\n-example, and because we're in an introduction, we'll leave that for later.\n-\n-The point is, the Rust compiler and its notion of ownership has saved us from a\n-bug that would crash the program. We've achieved safety, at compile time,\n-without needing to rely on a garbage collector to handle our memory.\n-\n-# Concurrency\n-\n-Rust's ownership model can help in other ways, as well. For example, take\n-concurrency. Concurrency is a big topic, and an important one for any modern\n-programming language. Let's take a look at how ownership can help you write\n-safe concurrent programs.\n-\n-Here's an example of a concurrent Rust program:\n-\n-```{rust}\n-# #![feature(scoped)]\n-use std::thread;\n-\n-fn main() {\n-    let guards: Vec<_> = (0..10).map(|_| {\n-        thread::scoped(|| {\n-            println!(\"Hello, world!\");\n-        })\n-    }).collect();\n-}\n-```\n-\n-This program creates ten threads, which all print `Hello, world!`. The `scoped`\n-function takes one argument, a closure, indicated by the double bars `||`. This\n-closure is executed in a new thread created by `scoped`. The method is called\n-`scoped` because it returns a 'join guard', which will automatically join the\n-child thread when it goes out of scope. Because we `collect` these guards into\n-a `Vec<T>`, and that vector goes out of scope at the end of our program, our\n-program will wait for every thread to finish before finishing.\n-\n-One common form of problem in concurrent programs is a *data race*.\n-This occurs when two different threads attempt to access the same\n-location in memory in a non-synchronized way, where at least one of\n-them is a write. If one thread is attempting to read, and one thread\n-is attempting to write, you cannot be sure that your data will not be\n-corrupted. Note the first half of that requirement: two threads that\n-attempt to access the same location in memory. Rust's ownership model\n-can track which pointers own which memory locations, which solves this\n-problem.\n-\n-Let's see an example. This Rust code will not compile:\n-\n-```{rust,ignore}\n-# #![feature(scoped)]\n-use std::thread;\n-\n-fn main() {\n-    let mut numbers = vec![1, 2, 3];\n-\n-    let guards: Vec<_> = (0..3).map(|i| {\n-        thread::scoped(move || {\n-            numbers[i] += 1;\n-            println!(\"numbers[{}] is {}\", i, numbers[i]);\n-        })\n-    }).collect();\n-}\n-```\n-\n-It gives us this error:\n-\n-```text\n-7:25: 10:6 error: cannot move out of captured outer variable in an `FnMut` closure\n-7     thread::scoped(move || {\n-8       numbers[i] += 1;\n-9       println!(\"numbers[{}] is {}\", i, numbers[i]);\n-10     })\n-error: aborting due to previous error\n-```\n-\n-This is a little confusing because there are two closures here: the one passed\n-to `map`, and the one passed to `thread::scoped`. In this case, the closure for\n-`thread::scoped` is attempting to reference `numbers`, a `Vec<i32>`. This\n-closure is a `FnOnce` closure, as that\u2019s what `thread::scoped` takes as an\n-argument. `FnOnce` closures take ownership of their environment. That\u2019s fine,\n-but there\u2019s one detail: because of `map`, we\u2019re going to make three of these\n-closures. And since all three try to take ownership of `numbers`, that would be\n-a problem. That\u2019s what it means by \u2018cannot move out of captured outer\n-variable\u2019: our `thread::scoped` closure wants to take ownership, and it can\u2019t,\n-because the closure for `map` won\u2019t let it.\n-\n-What to do here? Rust has a type that helps us: `Mutex<T>`. Because the threads\n-are scoped, it is possible to use an _immutable_ reference to `numbers` inside\n-of the closure. However, Rust prevents us from having multiple _mutable_\n-references to the same object, so we need a `Mutex` to be able to modify what\n-we're sharing. A Mutex will synchronize our accesses, so that we can ensure\n-that our mutation doesn't cause a data race.\n-\n-Here's what using a Mutex looks like:\n-\n-```{rust}\n-# #![feature(scoped)]\n-use std::thread;\n-use std::sync::Mutex;\n-\n-fn main() {\n-    let numbers = &Mutex::new(vec![1, 2, 3]);\n-\n-    let guards: Vec<_> = (0..3).map(|i| {\n-        thread::scoped(move || {\n-            let mut array = numbers.lock().unwrap();\n-            array[i] += 1;\n-            println!(\"numbers[{}] is {}\", i, array[i]);\n-        })\n-    }).collect();\n-}\n-```\n-\n-We first have to `use` the appropriate library, and then we wrap our vector in\n-a `Mutex` with the call to `Mutex::new()`. Inside of the loop, the `lock()`\n-call will return us a reference to the value inside the Mutex, and block any\n-other calls to `lock()` until said reference goes out of scope.\n-\n-We can compile and run this program without error, and in fact, see the\n-non-deterministic aspect:\n-\n-```{shell}\n-$ cargo run\n-   Compiling hello_world v0.0.1 (file:///Users/you/src/hello_world)\n-     Running `target/hello_world`\n-numbers[1] is 3\n-numbers[0] is 2\n-numbers[2] is 4\n-$ cargo run\n-     Running `target/hello_world`\n-numbers[2] is 4\n-numbers[1] is 3\n-numbers[0] is 2\n-```\n-\n-Each time, we can get a slightly different output because the threads are not\n-guaranteed to run in any set order. If you get the same order every time it is\n-because each of these threads are very small and complete too fast for their\n-indeterminate behavior to surface.\n-\n-The important part here is that the Rust compiler was able to use ownership to\n-give us assurance _at compile time_ that we weren't doing something incorrect\n-with regards to concurrency. In order to share ownership, we were forced to be\n-explicit and use a mechanism to ensure that it would be properly handled.\n-\n-# Safety _and_ Speed\n-\n-Safety and speed are always presented as a continuum. At one end of the spectrum,\n-you have maximum speed, but no safety. On the other end, you have absolute safety\n-with no speed. Rust seeks to break out of this paradigm by introducing safety at\n-compile time, ensuring that you haven't done anything wrong, while compiling to\n-the same low-level code you'd expect without the safety.\n-\n-As an example, Rust's ownership system is _entirely_ at compile time. The\n-safety check that makes this an error about moved values:\n-\n-```{rust,ignore}\n-# #![feature(scoped)]\n-use std::thread;\n-\n-fn main() {\n-    let numbers = vec![1, 2, 3];\n-\n-    let guards: Vec<_> = (0..3).map(|i| {\n-        thread::scoped(move || {\n-            println!(\"{}\", numbers[i]);\n-        })\n-    }).collect();\n-}\n-```\n-\n-carries no runtime penalty. And while some of Rust's safety features do have\n-a run-time cost, there's often a way to write your code in such a way that\n-you can remove it. As an example, this is a poor way to iterate through\n-a vector:\n-\n-```{rust}\n-let vec = vec![1, 2, 3];\n-\n-for i in 0..vec.len() {\n-     println!(\"{}\", vec[i]);\n-}\n-```\n-\n-The reason is that the access of `vec[i]` does bounds checking, to ensure\n-that we don't try to access an invalid index. However, we can remove this\n-while retaining safety. The answer is iterators:\n-\n-```{rust}\n-let vec = vec![1, 2, 3];\n-\n-for x in &vec {\n-    println!(\"{}\", x);\n-}\n-```\n-\n-This version uses an iterator that yields each element of the vector in turn.\n-Because we have a reference to the element, rather than the whole vector itself,\n-there's no array access bounds to check.\n-\n-# Learning More\n-\n-I hope that this taste of Rust has given you an idea if Rust is the right\n-language for you. We talked about Rust's tooling, how encoding ownership into\n-the type system helps you find bugs, how Rust can help you write correct\n-concurrent code, and how you don't have to pay a speed cost for much of this\n-safety.\n-\n-To continue your Rustic education, read [The Rust Programming\n-Language](book/index.html) for a more in-depth exploration of Rust's syntax and\n-concepts.\n+[intro]: book/README.html"}]}