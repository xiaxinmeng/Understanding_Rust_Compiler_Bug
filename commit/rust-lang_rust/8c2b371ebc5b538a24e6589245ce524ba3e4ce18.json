{"sha": "8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMmIzNzFlYmM1YjUzOGEyNGU2NTg5MjQ1Y2U1MjRiYTNlNGNlMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-27T22:56:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-27T22:56:15Z"}, "message": "Auto merge of #53227 - nivkner:pin_move, r=RalfJung\n\nmove the Pin API into its own module for centralized documentation\n\nThis implements the change proposed by @withoutboats in #49150, as suggested by @RalfJung in the review of #53104,\nalong with the documentation that was originally in it, that was deemed more appropriate in module-level documentation.\n\nr? @RalfJung", "tree": {"sha": "e9c467bbb78a1a28afed4a33c395a2dd2a613aff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c467bbb78a1a28afed4a33c395a2dd2a613aff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "html_url": "https://github.com/rust-lang/rust/commit/8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7202e40f49d2b29635f095a3270a7214e25ce8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7202e40f49d2b29635f095a3270a7214e25ce8b", "html_url": "https://github.com/rust-lang/rust/commit/f7202e40f49d2b29635f095a3270a7214e25ce8b"}, {"sha": "83ca347343f5783779b908c264c9470634d3758c", "url": "https://api.github.com/repos/rust-lang/rust/commits/83ca347343f5783779b908c264c9470634d3758c", "html_url": "https://github.com/rust-lang/rust/commit/83ca347343f5783779b908c264c9470634d3758c"}], "stats": {"total": 861, "additions": 496, "deletions": 365}, "files": [{"sha": "c25f3eb8f17504776b8da2abb6f448e53309661d", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 202, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -64,12 +64,14 @@ use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n use core::hash::{Hash, Hasher};\n use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n-use core::mem::{self, PinMut};\n+use core::mem;\n+use core::pin::PinMut;\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{Context, Poll, Spawn, SpawnErrorKind, SpawnObjError};\n \n use raw_vec::RawVec;\n+use pin::PinBox;\n use str::from_boxed_utf8_unchecked;\n \n /// A pointer type for heap allocation.\n@@ -758,166 +760,6 @@ impl<T> Generator for Box<T>\n     }\n }\n \n-/// A pinned, heap allocated reference.\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-#[fundamental]\n-#[repr(transparent)]\n-pub struct PinBox<T: ?Sized> {\n-    inner: Box<T>,\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T> PinBox<T> {\n-    /// Allocate memory on the heap, move the data into it and pin it.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn new(data: T) -> PinBox<T> {\n-        PinBox { inner: Box::new(data) }\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> PinBox<T> {\n-    /// Get a pinned reference to the data in this PinBox.\n-    #[inline]\n-    pub fn as_pin_mut<'a>(&'a mut self) -> PinMut<'a, T> {\n-        unsafe { PinMut::new_unchecked(&mut *self.inner) }\n-    }\n-\n-    /// Constructs a `PinBox` from a raw pointer.\n-    ///\n-    /// After calling this function, the raw pointer is owned by the\n-    /// resulting `PinBox`. Specifically, the `PinBox` destructor will call\n-    /// the destructor of `T` and free the allocated memory. Since the\n-    /// way `PinBox` allocates and releases memory is unspecified, the\n-    /// only valid pointer to pass to this function is the one taken\n-    /// from another `PinBox` via the [`PinBox::into_raw`] function.\n-    ///\n-    /// This function is unsafe because improper use may lead to\n-    /// memory problems. For example, a double-free may occur if the\n-    /// function is called twice on the same raw pointer.\n-    ///\n-    /// [`PinBox::into_raw`]: struct.PinBox.html#method.into_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(pin)]\n-    /// use std::boxed::PinBox;\n-    /// let x = PinBox::new(5);\n-    /// let ptr = PinBox::into_raw(x);\n-    /// let x = unsafe { PinBox::from_raw(ptr) };\n-    /// ```\n-    #[inline]\n-    pub unsafe fn from_raw(raw: *mut T) -> Self {\n-        PinBox { inner: Box::from_raw(raw) }\n-    }\n-\n-    /// Consumes the `PinBox`, returning the wrapped raw pointer.\n-    ///\n-    /// After calling this function, the caller is responsible for the\n-    /// memory previously managed by the `PinBox`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `PinBox` with the [`PinBox::from_raw`] function.\n-    ///\n-    /// Note: this is an associated function, which means that you have\n-    /// to call it as `PinBox::into_raw(b)` instead of `b.into_raw()`. This\n-    /// is so that there is no conflict with a method on the inner type.\n-    ///\n-    /// [`PinBox::from_raw`]: struct.PinBox.html#method.from_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(pin)]\n-    /// use std::boxed::PinBox;\n-    /// let x = PinBox::new(5);\n-    /// let ptr = PinBox::into_raw(x);\n-    /// ```\n-    #[inline]\n-    pub fn into_raw(b: PinBox<T>) -> *mut T {\n-        Box::into_raw(b.inner)\n-    }\n-\n-    /// Get a mutable reference to the data inside this PinBox.\n-    ///\n-    /// This function is unsafe. Users must guarantee that the data is never\n-    /// moved out of this reference.\n-    #[inline]\n-    pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n-        &mut *this.inner\n-    }\n-\n-    /// Convert this PinBox into an unpinned Box.\n-    ///\n-    /// This function is unsafe. Users must guarantee that the data is never\n-    /// moved out of the box.\n-    #[inline]\n-    pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n-        this.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> From<Box<T>> for PinBox<T> {\n-    fn from(boxed: Box<T>) -> PinBox<T> {\n-        PinBox { inner: boxed }\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: Unpin + ?Sized> From<PinBox<T>> for Box<T> {\n-    fn from(pinned: PinBox<T>) -> Box<T> {\n-        pinned.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> Deref for PinBox<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &*self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: Unpin + ?Sized> DerefMut for PinBox<T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut *self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: fmt::Display + ?Sized> fmt::Display for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&*self.inner, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: fmt::Debug + ?Sized> fmt::Debug for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&*self.inner, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // It's not possible to extract the inner Uniq directly from the Box,\n-        // instead we cast it to a *const which aliases the Unique\n-        let ptr: *const T = &*self.inner;\n-        fmt::Pointer::fmt(&ptr, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<T: ?Sized> Unpin for PinBox<T> {}\n-\n #[unstable(feature = \"futures_api\", issue = \"50547\")]\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n@@ -927,15 +769,6 @@ impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<F: ?Sized + Future> Future for PinBox<F> {\n-    type Output = F::Output;\n-\n-    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n-        self.as_pin_mut().poll(cx)\n-    }\n-}\n-\n #[unstable(feature = \"futures_api\", issue = \"50547\")]\n unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for Box<F>\n     where F: Future<Output = T> + 'a\n@@ -955,25 +788,6 @@ unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for Box<F>\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinBox<F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        PinBox::into_raw(self) as *mut ()\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        let ptr = ptr as *mut F;\n-        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n-        pin.poll(cx)\n-    }\n-\n-    unsafe fn drop(ptr: *mut ()) {\n-        drop(PinBox::from_raw(ptr as *mut F))\n-    }\n-}\n-\n #[unstable(feature = \"futures_api\", issue = \"50547\")]\n impl<Sp> Spawn for Box<Sp>\n     where Sp: Spawn + ?Sized\n@@ -990,13 +804,6 @@ impl<Sp> Spawn for Box<Sp>\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + Send + 'a> From<PinBox<F>> for FutureObj<'a, ()> {\n-    fn from(boxed: PinBox<F>) -> Self {\n-        FutureObj::new(boxed)\n-    }\n-}\n-\n #[unstable(feature = \"futures_api\", issue = \"50547\")]\n impl<'a, F: Future<Output = ()> + Send + 'a> From<Box<F>> for FutureObj<'a, ()> {\n     fn from(boxed: Box<F>) -> Self {\n@@ -1005,15 +812,15 @@ impl<'a, F: Future<Output = ()> + Send + 'a> From<Box<F>> for FutureObj<'a, ()>\n }\n \n #[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + 'a> From<PinBox<F>> for LocalFutureObj<'a, ()> {\n-    fn from(boxed: PinBox<F>) -> Self {\n+impl<'a, F: Future<Output = ()> + 'a> From<Box<F>> for LocalFutureObj<'a, ()> {\n+    fn from(boxed: Box<F>) -> Self {\n         LocalFutureObj::new(boxed)\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-impl<'a, F: Future<Output = ()> + 'a> From<Box<F>> for LocalFutureObj<'a, ()> {\n-    fn from(boxed: Box<F>) -> Self {\n-        LocalFutureObj::new(boxed)\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: Unpin + ?Sized> From<PinBox<T>> for Box<T> {\n+    fn from(pinned: PinBox<T>) -> Box<T> {\n+        unsafe { PinBox::unpin(pinned) }\n     }\n }"}, {"sha": "676c977514f320299f06087a34521b7f5312f9d8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -160,6 +160,7 @@ pub mod collections;\n pub mod sync;\n pub mod rc;\n pub mod raw_vec;\n+pub mod pin;\n pub mod prelude;\n pub mod borrow;\n pub mod fmt;"}, {"sha": "17bbc9882d976d95c2992060f80cc08dede994ce", "filename": "src/liballoc/pin.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Fliballoc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Fliballoc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fpin.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -0,0 +1,302 @@\n+//! Types which pin data to its location in memory\n+//!\n+//! It is sometimes useful to have objects that are guaranteed to not move,\n+//! in the sense that their placement in memory does not change, and can thus be relied upon.\n+//!\n+//! A prime example of such a scenario would be building self-referencial structs,\n+//! since moving an object with pointers to itself will invalidate them,\n+//! which could cause undefined behavior.\n+//!\n+//! In order to prevent objects from moving, they must be *pinned*,\n+//! by wrapping the data in pinning pointer types, such as [`PinMut`] and [`PinBox`],\n+//! which are otherwise equivalent to `& mut` and [`Box`], respectively.\n+//!\n+//! First of all, these are pointer types because pinned data mustn't be passed around by value\n+//! (that would change its location in memory).\n+//! Secondly, since data can be moved out of `&mut` and [`Box`] with functions such as [`swap`],\n+//! which causes their contents to swap places in memory,\n+//! we need dedicated types that prohibit such operations.\n+//!\n+//! However, these restrictions are usually not necessary,\n+//! so most types implement the [`Unpin`] auto-trait,\n+//! which indicates that the type can be moved out safely.\n+//! Doing so removes the limitations of pinning types,\n+//! making them the same as their non-pinning counterparts.\n+//!\n+//! [`PinMut`]: struct.PinMut.html\n+//! [`PinBox`]: struct.PinBox.html\n+//! [`Unpin`]: trait.Unpin.html\n+//! [`swap`]: ../../std/mem/fn.swap.html\n+//! [`Box`]: ../boxed/struct.Box.html\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! #![feature(pin)]\n+//!\n+//! use std::pin::PinBox;\n+//! use std::marker::Pinned;\n+//! use std::ptr::NonNull;\n+//!\n+//! // This is a self referencial struct since the slice field points to the data field.\n+//! // We cannot inform the compiler about that with a normal reference,\n+//! // since this pattern cannot be described with the usual borrowing rules.\n+//! // Instead we use a raw pointer, though one which is known to not be null,\n+//! // since we know it's pointing at the string.\n+//! struct Unmovable {\n+//!     data: String,\n+//!     slice: NonNull<String>,\n+//!     _pin: Pinned,\n+//! }\n+//!\n+//! impl Unmovable {\n+//!     // To ensure the data doesn't move when the function returns,\n+//!     // we place it in the heap where it will stay for the lifetime of the object,\n+//!     // and the only way to access it would be through a pointer to it.\n+//!     fn new(data: String) -> PinBox<Self> {\n+//!         let res = Unmovable {\n+//!             data,\n+//!             // we only create the pointer once the data is in place\n+//!             // otherwise it will have already moved before we even started\n+//!             slice: NonNull::dangling(),\n+//!             _pin: Pinned,\n+//!         };\n+//!         let mut boxed = PinBox::new(res);\n+//!\n+//!         let slice = NonNull::from(&boxed.data);\n+//!         // we know this is safe because modifying a field doesn't move the whole struct\n+//!         unsafe { PinBox::get_mut(&mut boxed).slice = slice };\n+//!         boxed\n+//!     }\n+//! }\n+//!\n+//! let unmoved = Unmovable::new(\"hello\".to_string());\n+//! // The pointer should point to the correct location,\n+//! // so long as the struct hasn't moved.\n+//! // Meanwhile, we are free to move the pointer around.\n+//! # #[allow(unused_mut)]\n+//! let mut still_unmoved = unmoved;\n+//! assert_eq!(still_unmoved.slice, NonNull::from(&still_unmoved.data));\n+//!\n+//! // Since our type doesn't implement Unpin, this will fail to compile:\n+//! // let new_unmoved = Unmovable::new(\"world\".to_string());\n+//! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n+//! ```\n+\n+#![unstable(feature = \"pin\", issue = \"49150\")]\n+\n+pub use core::pin::*;\n+pub use core::marker::Unpin;\n+\n+use core::convert::From;\n+use core::fmt;\n+use core::future::{Future, FutureObj, LocalFutureObj, UnsafeFutureObj};\n+use core::marker::Unsize;\n+use core::ops::{CoerceUnsized, Deref, DerefMut};\n+use core::task::{Context, Poll};\n+\n+use boxed::Box;\n+\n+/// A pinned, heap allocated reference.\n+///\n+/// This type is similar to [`Box`], except that it pins its value,\n+/// which prevents it from moving out of the reference, unless it implements [`Unpin`].\n+///\n+/// See the [module documentation] for furthur explaination on pinning.\n+///\n+/// [`Box`]: ../boxed/struct.Box.html\n+/// [`Unpin`]: ../../std/marker/trait.Unpin.html\n+/// [module documentation]: index.html\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[fundamental]\n+#[repr(transparent)]\n+pub struct PinBox<T: ?Sized> {\n+    inner: Box<T>,\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T> PinBox<T> {\n+    /// Allocate memory on the heap, move the data into it and pin it.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn new(data: T) -> PinBox<T> {\n+        PinBox { inner: Box::new(data) }\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> PinBox<T> {\n+    /// Get a pinned reference to the data in this PinBox.\n+    #[inline]\n+    pub fn as_pin_mut<'a>(&'a mut self) -> PinMut<'a, T> {\n+        unsafe { PinMut::new_unchecked(&mut *self.inner) }\n+    }\n+\n+    /// Constructs a `PinBox` from a raw pointer.\n+    ///\n+    /// After calling this function, the raw pointer is owned by the\n+    /// resulting `PinBox`. Specifically, the `PinBox` destructor will call\n+    /// the destructor of `T` and free the allocated memory. Since the\n+    /// way `PinBox` allocates and releases memory is unspecified, the\n+    /// only valid pointer to pass to this function is the one taken\n+    /// from another `PinBox` via the [`PinBox::into_raw`] function.\n+    ///\n+    /// This function is unsafe because improper use may lead to\n+    /// memory problems. For example, a double-free may occur if the\n+    /// function is called twice on the same raw pointer.\n+    ///\n+    /// [`PinBox::into_raw`]: struct.PinBox.html#method.into_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(pin)]\n+    /// use std::pin::PinBox;\n+    /// let x = PinBox::new(5);\n+    /// let ptr = PinBox::into_raw(x);\n+    /// let x = unsafe { PinBox::from_raw(ptr) };\n+    /// ```\n+    #[inline]\n+    pub unsafe fn from_raw(raw: *mut T) -> Self {\n+        PinBox { inner: Box::from_raw(raw) }\n+    }\n+\n+    /// Consumes the `PinBox`, returning the wrapped raw pointer.\n+    ///\n+    /// After calling this function, the caller is responsible for the\n+    /// memory previously managed by the `PinBox`. In particular, the\n+    /// caller should properly destroy `T` and release the memory. The\n+    /// proper way to do so is to convert the raw pointer back into a\n+    /// `PinBox` with the [`PinBox::from_raw`] function.\n+    ///\n+    /// Note: this is an associated function, which means that you have\n+    /// to call it as `PinBox::into_raw(b)` instead of `b.into_raw()`. This\n+    /// is so that there is no conflict with a method on the inner type.\n+    ///\n+    /// [`PinBox::from_raw`]: struct.PinBox.html#method.from_raw\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(pin)]\n+    /// use std::pin::PinBox;\n+    /// let x = PinBox::new(5);\n+    /// let ptr = PinBox::into_raw(x);\n+    /// ```\n+    #[inline]\n+    pub fn into_raw(b: PinBox<T>) -> *mut T {\n+        Box::into_raw(b.inner)\n+    }\n+\n+    /// Get a mutable reference to the data inside this PinBox.\n+    ///\n+    /// This function is unsafe. Users must guarantee that the data is never\n+    /// moved out of this reference.\n+    #[inline]\n+    pub unsafe fn get_mut<'a>(this: &'a mut PinBox<T>) -> &'a mut T {\n+        &mut *this.inner\n+    }\n+\n+    /// Convert this PinBox into an unpinned Box.\n+    ///\n+    /// This function is unsafe. Users must guarantee that the data is never\n+    /// moved out of the box.\n+    #[inline]\n+    pub unsafe fn unpin(this: PinBox<T>) -> Box<T> {\n+        this.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> From<Box<T>> for PinBox<T> {\n+    fn from(boxed: Box<T>) -> PinBox<T> {\n+        PinBox { inner: boxed }\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> Deref for PinBox<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: Unpin + ?Sized> DerefMut for PinBox<T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut *self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: fmt::Display + ?Sized> fmt::Display for PinBox<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&*self.inner, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: fmt::Debug + ?Sized> fmt::Debug for PinBox<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&*self.inner, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> fmt::Pointer for PinBox<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // It's not possible to extract the inner Uniq directly from the Box,\n+        // instead we cast it to a *const which aliases the Unique\n+        let ptr: *const T = &*self.inner;\n+        fmt::Pointer::fmt(&ptr, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinBox<U>> for PinBox<T> {}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<T: ?Sized> Unpin for PinBox<T> {}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<F: ?Sized + Future> Future for PinBox<F> {\n+    type Output = F::Output;\n+\n+    fn poll(mut self: PinMut<Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        self.as_pin_mut().poll(cx)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinBox<F>\n+    where F: Future<Output = T> + 'a\n+{\n+    fn into_raw(self) -> *mut () {\n+        PinBox::into_raw(self) as *mut ()\n+    }\n+\n+    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n+        let ptr = ptr as *mut F;\n+        let pin: PinMut<F> = PinMut::new_unchecked(&mut *ptr);\n+        pin.poll(cx)\n+    }\n+\n+    unsafe fn drop(ptr: *mut ()) {\n+        drop(PinBox::from_raw(ptr as *mut F))\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + Send + 'a> From<PinBox<F>> for FutureObj<'a, ()> {\n+    fn from(boxed: PinBox<F>) -> Self {\n+        FutureObj::new(boxed)\n+    }\n+}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+impl<'a, F: Future<Output = ()> + 'a> From<PinBox<F>> for LocalFutureObj<'a, ()> {\n+    fn from(boxed: PinBox<F>) -> Self {\n+        LocalFutureObj::new(boxed)\n+    }\n+}"}, {"sha": "520b6ebbbaaa59a072eda6529d6f22acd1e4249e", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -12,7 +12,7 @@\n             reason = \"futures in libcore are unstable\",\n             issue = \"50547\")]\n \n-use mem::PinMut;\n+use pin::PinMut;\n use marker::Unpin;\n use task::{self, Poll};\n "}, {"sha": "68fe461aeae86ebcb1e570a9796737fd5b034e6a", "filename": "src/libcore/future/future_obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture_obj.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -15,7 +15,7 @@\n use fmt;\n use future::Future;\n use marker::{PhantomData, Unpin};\n-use mem::PinMut;\n+use pin::PinMut;\n use task::{Context, Poll};\n \n /// A custom trait object for polling futures, roughly akin to"}, {"sha": "2aa3226af8960b553dcd05ed3a7568021ce5af7d", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -191,6 +191,7 @@ pub mod cell;\n pub mod char;\n pub mod panic;\n pub mod panicking;\n+pub mod pin;\n pub mod iter;\n pub mod option;\n pub mod raw;"}, {"sha": "dd57d2dd00910c4eee3062bc09ac6c20d626dc42", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -611,6 +611,7 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n /// Instead it can be used to prevent moves through the type system,\n /// by controlling the behavior of special pointer types like [`PinMut`],\n /// which \"pin\" the type in place by not allowing it to be moved out of them.\n+/// See the [`pin module`] documentation for more information on pinning.\n ///\n /// Implementing this trait lifts the restrictions of pinning off a type,\n /// which then allows it to move out with functions such as [`replace`].\n@@ -619,7 +620,8 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n ///\n /// ```rust\n /// #![feature(pin)]\n-/// use std::mem::{PinMut, replace};\n+/// use std::mem::replace;\n+/// use std::pin::PinMut;\n ///\n /// let mut string = \"this\".to_string();\n /// let mut pinned_string = PinMut::new(&mut string);\n@@ -630,8 +632,9 @@ unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n ///\n /// This trait is automatically implemented for almost every type.\n ///\n-/// [`PinMut`]: ../mem/struct.PinMut.html\n-/// [`replace`]: ../mem/fn.replace.html\n+/// [`replace`]: ../../std/mem/fn.replace.html\n+/// [`PinMut`]: ../pin/struct.PinMut.html\n+/// [`pin module`]: ../../std/pin/index.html\n #[unstable(feature = \"pin\", issue = \"49150\")]\n pub auto trait Unpin {}\n "}, {"sha": "f2852d98282b7be7df5cecdc89b52bbaa4523398", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 147, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -18,13 +18,11 @@\n use clone;\n use cmp;\n use fmt;\n-use future::{Future, UnsafeFutureObj};\n use hash;\n use intrinsics;\n-use marker::{Copy, PhantomData, Sized, Unpin, Unsize};\n+use marker::{Copy, PhantomData, Sized};\n use ptr;\n-use task::{Context, Poll};\n-use ops::{Deref, DerefMut, CoerceUnsized};\n+use ops::{Deref, DerefMut};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n@@ -992,146 +990,3 @@ impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n         &mut self.value\n     }\n }\n-\n-/// A pinned reference.\n-///\n-/// A pinned reference is a lot like a mutable reference, except that it is not\n-/// safe to move a value out of a pinned reference unless the type of that\n-/// value implements the `Unpin` trait.\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-#[fundamental]\n-pub struct PinMut<'a, T: ?Sized + 'a> {\n-    inner: &'a mut T,\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unpin> PinMut<'a, T> {\n-    /// Construct a new `PinMut` around a reference to some data of a type that\n-    /// implements `Unpin`.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn new(reference: &'a mut T) -> PinMut<'a, T> {\n-        PinMut { inner: reference }\n-    }\n-\n-    /// Get a mutable reference to the data inside of this `PinMut`.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn get_mut(this: PinMut<'a, T>) -> &'a mut T {\n-        this.inner\n-    }\n-}\n-\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> PinMut<'a, T> {\n-    /// Construct a new `PinMut` around a reference to some data of a type that\n-    /// may or may not implement `Unpin`.\n-    ///\n-    /// This constructor is unsafe because we do not know what will happen with\n-    /// that data after the reference ends. If you cannot guarantee that the\n-    /// data will never move again, calling this constructor is invalid.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn new_unchecked(reference: &'a mut T) -> PinMut<'a, T> {\n-        PinMut { inner: reference }\n-    }\n-\n-    /// Reborrow a `PinMut` for a shorter lifetime.\n-    ///\n-    /// For example, `PinMut::get_mut(x.reborrow())` (unsafely) returns a\n-    /// short-lived mutable reference reborrowing from `x`.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn reborrow<'b>(&'b mut self) -> PinMut<'b, T> {\n-        PinMut { inner: self.inner }\n-    }\n-\n-    /// Get a mutable reference to the data inside of this `PinMut`.\n-    ///\n-    /// This function is unsafe. You must guarantee that you will never move\n-    /// the data out of the mutable reference you receive when you call this\n-    /// function.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn get_mut_unchecked(this: PinMut<'a, T>) -> &'a mut T {\n-        this.inner\n-    }\n-\n-    /// Construct a new pin by mapping the interior value.\n-    ///\n-    /// For example, if you  wanted to get a `PinMut` of a field of something,\n-    /// you could use this to get access to that field in one line of code.\n-    ///\n-    /// This function is unsafe. You must guarantee that the data you return\n-    /// will not move so long as the argument value does not move (for example,\n-    /// because it is one of the fields of that value), and also that you do\n-    /// not move out of the argument you receive to the interior function.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub unsafe fn map_unchecked<U, F>(this: PinMut<'a, T>, f: F) -> PinMut<'a, U> where\n-        F: FnOnce(&mut T) -> &mut U\n-    {\n-        PinMut { inner: f(this.inner) }\n-    }\n-\n-    /// Assign a new value to the memory behind the pinned reference.\n-    #[unstable(feature = \"pin\", issue = \"49150\")]\n-    pub fn set(this: PinMut<'a, T>, value: T)\n-        where T: Sized,\n-    {\n-        *this.inner = value;\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Deref for PinMut<'a, T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &*self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unpin> DerefMut for PinMut<'a, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        self.inner\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: fmt::Debug + ?Sized> fmt::Debug for PinMut<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&**self, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: fmt::Display + ?Sized> fmt::Display for PinMut<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&**self, f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> fmt::Pointer for PinMut<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&(&*self.inner as *const T), f)\n-    }\n-}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinMut<'a, U>> for PinMut<'a, T> {}\n-\n-#[unstable(feature = \"pin\", issue = \"49150\")]\n-impl<'a, T: ?Sized> Unpin for PinMut<'a, T> {}\n-\n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n-unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinMut<'a, F>\n-    where F: Future<Output = T> + 'a\n-{\n-    fn into_raw(self) -> *mut () {\n-        unsafe { PinMut::get_mut_unchecked(self) as *mut F as *mut () }\n-    }\n-\n-    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n-        PinMut::new_unchecked(&mut *(ptr as *mut F)).poll(cx)\n-    }\n-\n-    unsafe fn drop(_ptr: *mut ()) {}\n-}"}, {"sha": "3879abb0af973d7084c911f93c660cc686288d08", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -147,7 +147,7 @@\n \n use iter::{FromIterator, FusedIterator, TrustedLen};\n use {hint, mem, ops::{self, Deref}};\n-use mem::PinMut;\n+use pin::PinMut;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of"}, {"sha": "e9001f86b3526b2648654d2d7191915d7372e104", "filename": "src/libcore/pin.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -0,0 +1,160 @@\n+//! Types which pin data to its location in memory\n+//!\n+//! See the [standard library module] for more information.\n+//!\n+//! [standard library module]: ../../std/pin/index.html\n+\n+#![unstable(feature = \"pin\", issue = \"49150\")]\n+\n+use fmt;\n+use future::{Future, UnsafeFutureObj};\n+use marker::{Sized, Unpin, Unsize};\n+use task::{Context, Poll};\n+use ops::{Deref, DerefMut, CoerceUnsized};\n+\n+/// A pinned reference.\n+///\n+/// This type is similar to a mutable reference, except that it pins its value,\n+/// which prevents it from moving out of the reference, unless it implements [`Unpin`].\n+///\n+/// See the [`pin` module] documentation for furthur explanation on pinning.\n+///\n+/// [`Unpin`]: ../../std/marker/trait.Unpin.html\n+/// [`pin` module]: ../../std/pin/index.html\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+#[fundamental]\n+pub struct PinMut<'a, T: ?Sized + 'a> {\n+    inner: &'a mut T,\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized + Unpin> PinMut<'a, T> {\n+    /// Construct a new `PinMut` around a reference to some data of a type that\n+    /// implements `Unpin`.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn new(reference: &'a mut T) -> PinMut<'a, T> {\n+        PinMut { inner: reference }\n+    }\n+\n+    /// Get a mutable reference to the data inside of this `PinMut`.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn get_mut(this: PinMut<'a, T>) -> &'a mut T {\n+        this.inner\n+    }\n+}\n+\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> PinMut<'a, T> {\n+    /// Construct a new `PinMut` around a reference to some data of a type that\n+    /// may or may not implement `Unpin`.\n+    ///\n+    /// This constructor is unsafe because we do not know what will happen with\n+    /// that data after the lifetime of the reference ends. If you cannot guarantee that the\n+    /// data will never move again, calling this constructor is invalid.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn new_unchecked(reference: &'a mut T) -> PinMut<'a, T> {\n+        PinMut { inner: reference }\n+    }\n+\n+    /// Reborrow a `PinMut` for a shorter lifetime.\n+    ///\n+    /// For example, `PinMut::get_mut(x.reborrow())` (unsafely) returns a\n+    /// short-lived mutable reference reborrowing from `x`.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn reborrow<'b>(&'b mut self) -> PinMut<'b, T> {\n+        PinMut { inner: self.inner }\n+    }\n+\n+    /// Get a mutable reference to the data inside of this `PinMut`.\n+    ///\n+    /// This function is unsafe. You must guarantee that you will never move\n+    /// the data out of the mutable reference you receive when you call this\n+    /// function.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn get_mut_unchecked(this: PinMut<'a, T>) -> &'a mut T {\n+        this.inner\n+    }\n+\n+    /// Construct a new pin by mapping the interior value.\n+    ///\n+    /// For example, if you  wanted to get a `PinMut` of a field of something,\n+    /// you could use this to get access to that field in one line of code.\n+    ///\n+    /// This function is unsafe. You must guarantee that the data you return\n+    /// will not move so long as the argument value does not move (for example,\n+    /// because it is one of the fields of that value), and also that you do\n+    /// not move out of the argument you receive to the interior function.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub unsafe fn map_unchecked<U, F>(this: PinMut<'a, T>, f: F) -> PinMut<'a, U> where\n+        F: FnOnce(&mut T) -> &mut U\n+    {\n+        PinMut { inner: f(this.inner) }\n+    }\n+\n+    /// Assign a new value to the memory behind the pinned reference.\n+    #[unstable(feature = \"pin\", issue = \"49150\")]\n+    pub fn set(this: PinMut<'a, T>, value: T)\n+        where T: Sized,\n+    {\n+        *this.inner = value;\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> Deref for PinMut<'a, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized + Unpin> DerefMut for PinMut<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: fmt::Debug + ?Sized> fmt::Debug for PinMut<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: fmt::Display + ?Sized> fmt::Display for PinMut<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> fmt::Pointer for PinMut<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&(&*self.inner as *const T), f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<PinMut<'a, U>> for PinMut<'a, T> {}\n+\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, T: ?Sized> Unpin for PinMut<'a, T> {}\n+\n+#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+unsafe impl<'a, T, F> UnsafeFutureObj<'a, T> for PinMut<'a, F>\n+    where F: Future<Output = T> + 'a\n+{\n+    fn into_raw(self) -> *mut () {\n+        unsafe { PinMut::get_mut_unchecked(self) as *mut F as *mut () }\n+    }\n+\n+    unsafe fn poll(ptr: *mut (), cx: &mut Context) -> Poll<T> {\n+        PinMut::new_unchecked(&mut *(ptr as *mut F)).poll(cx)\n+    }\n+\n+    unsafe fn drop(_ptr: *mut ()) {}\n+}"}, {"sha": "d9657f691c79fdc59a4b07445cd3c79876494423", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -12,7 +12,7 @@\n \n use core::cell::Cell;\n use core::marker::Unpin;\n-use core::mem::PinMut;\n+use core::pin::PinMut;\n use core::option::Option;\n use core::ptr::NonNull;\n use core::task::{self, Poll};"}, {"sha": "310475d31fdede876081aef27c22295a16135f70", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -435,6 +435,8 @@ pub use alloc_crate::borrow;\n pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::format;\n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+pub use alloc_crate::pin;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use alloc_crate::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "6945a41a5e73bef0e94cb7614a0a1af936ce621a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -230,7 +230,7 @@ macro_rules! await {\n         loop {\n             if let $crate::task::Poll::Ready(x) =\n                 $crate::future::poll_in_task_cx(unsafe {\n-                    $crate::mem::PinMut::new_unchecked(&mut pinned)\n+                    $crate::pin::PinMut::new_unchecked(&mut pinned)\n                 })\n             {\n                 break x;"}, {"sha": "47547aedcbdec8e0269d5a5d716ef7f1f475f911", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -16,7 +16,7 @@ use any::Any;\n use cell::UnsafeCell;\n use fmt;\n use future::Future;\n-use mem::PinMut;\n+use pin::PinMut;\n use ops::{Deref, DerefMut};\n use panicking;\n use ptr::{Unique, NonNull};"}, {"sha": "46f228459079a25806ebd417e607754e52dac171", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -12,8 +12,8 @@\n \n #![feature(arbitrary_self_types, async_await, await_macro, futures_api, pin)]\n \n-use std::boxed::PinBox;\n-use std::mem::PinMut;\n+use std::pin::PinBox;\n+use std::pin::PinMut;\n use std::future::Future;\n use std::sync::{\n     Arc,"}, {"sha": "69a04437691dd3f0a7e4c8654c0954b46fcf0529", "filename": "src/test/run-pass/futures-api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frun-pass%2Ffutures-api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffutures-api.rs?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -11,9 +11,9 @@\n #![feature(arbitrary_self_types, futures_api, pin)]\n #![allow(unused)]\n \n-use std::boxed::PinBox;\n+use std::pin::PinBox;\n use std::future::Future;\n-use std::mem::PinMut;\n+use std::pin::PinMut;\n use std::rc::Rc;\n use std::sync::{\n     Arc,"}, {"sha": "55842dc8e45e66d36001e10298f724236b22be0a", "filename": "src/test/rustdoc-js/pinbox-new.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frustdoc-js%2Fpinbox-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frustdoc-js%2Fpinbox-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fpinbox-new.js?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -14,7 +14,7 @@ const QUERY = 'pinbox::new';\n \n const EXPECTED = {\n     'others': [\n-        { 'path': 'std::boxed::PinBox', 'name': 'new' },\n-        { 'path': 'alloc::boxed::PinBox', 'name': 'new' },\n+        { 'path': 'std::pin::PinBox', 'name': 'new' },\n+        { 'path': 'alloc::pin::PinBox', 'name': 'new' },\n     ],\n };"}, {"sha": "4a654ccb1350351e13fb47a3579fe7d5b3301a66", "filename": "src/test/rustdoc-js/vec-new.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frustdoc-js%2Fvec-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/8c2b371ebc5b538a24e6589245ce524ba3e4ce18/src%2Ftest%2Frustdoc-js%2Fvec-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fvec-new.js?ref=8c2b371ebc5b538a24e6589245ce524ba3e4ce18", "patch": "@@ -14,6 +14,6 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'std::vec::Vec', 'name': 'new' },\n         { 'path': 'std::vec::Vec', 'name': 'ne' },\n-        { 'path': 'std::boxed::PinBox', 'name': 'new' },\n+        { 'path': 'std::pin::PinBox', 'name': 'new' },\n     ],\n };"}]}