{"sha": "11909e3588319235e28e99294e17cca11db1d7e2", "node_id": "C_kwDOAAsO6NoAKDExOTA5ZTM1ODgzMTkyMzVlMjhlOTkyOTRlMTdjY2ExMWRiMWQ3ZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-29T12:49:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-29T12:49:03Z"}, "message": "Auto merge of #95096 - GuillaumeGomez:rm-header-fn-field, r=camelid\n\nRemove header field from clean::Function\n\nFixes https://github.com/rust-lang/rust/issues/89673.\n\nThis is another take on https://github.com/rust-lang/rust/issues/89673 (compared to https://github.com/rust-lang/rust/pull/91217) but very different on the approach: I moved the header call in one place but still require to have the `clean::Item` so I can use the `DefId` to get what is missing.\n\ncc `@jyn514` (you reviewed the original so maybe you want to take a look?)\nr? `@camelid`", "tree": {"sha": "87b405abf60210044785f568e7f1f95e7d671b3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87b405abf60210044785f568e7f1f95e7d671b3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11909e3588319235e28e99294e17cca11db1d7e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11909e3588319235e28e99294e17cca11db1d7e2", "html_url": "https://github.com/rust-lang/rust/commit/11909e3588319235e28e99294e17cca11db1d7e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11909e3588319235e28e99294e17cca11db1d7e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2301ca54320659835467072f37201591db959b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2301ca54320659835467072f37201591db959b5", "html_url": "https://github.com/rust-lang/rust/commit/e2301ca54320659835467072f37201591db959b5"}, {"sha": "8071332d833073fca42ee128d25f49ee140229eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8071332d833073fca42ee128d25f49ee140229eb", "html_url": "https://github.com/rust-lang/rust/commit/8071332d833073fca42ee128d25f49ee140229eb"}], "stats": {"total": 213, "additions": 100, "deletions": 113}, "files": [{"sha": "b681df3a99a6774df58266bc7819db72ae4f1561", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -221,21 +221,14 @@ crate fn build_external_trait(cx: &mut DocContext<'_>, did: DefId) -> clean::Tra\n fn build_external_function(cx: &mut DocContext<'_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n-    let constness =\n-        if cx.tcx.is_const_fn_raw(did) { hir::Constness::Const } else { hir::Constness::NotConst };\n-    let asyncness = cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, |cx| {\n         // NOTE: generics need to be cleaned before the decl!\n         let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n         let decl = clean_fn_decl_from_did_and_sig(cx, Some(did), sig);\n         (generics, decl)\n     });\n-    clean::Function {\n-        decl,\n-        generics,\n-        header: hir::FnHeader { unsafety: sig.unsafety(), abi: sig.abi(), constness, asyncness },\n-    }\n+    clean::Function { decl, generics }\n }\n \n fn build_enum(cx: &mut DocContext<'_>, did: DefId) -> clean::Enum {"}, {"sha": "37c24738a2a1baf16093c2bc7097a6e1150f087d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 74, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -12,7 +12,6 @@ crate mod utils;\n \n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_const_eval::const_eval::is_unstable_const_fn;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n@@ -26,8 +25,6 @@ use rustc_middle::{bug, span_bug};\n use rustc_span::hygiene::{AstPass, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, ExpnKind};\n-use rustc_target::spec::abi::Abi;\n-use rustc_typeck::check::intrinsic::intrinsic_operation_unsafety;\n use rustc_typeck::hir_ty_to_ty;\n \n use std::assert_matches::assert_matches;\n@@ -813,13 +810,6 @@ fn clean_fn_or_proc_macro(\n         }\n         None => {\n             let mut func = clean_function(cx, sig, generics, body_id);\n-            let def_id = item.def_id.to_def_id();\n-            func.header.constness =\n-                if cx.tcx.is_const_fn(def_id) && is_unstable_const_fn(cx.tcx, def_id).is_none() {\n-                    hir::Constness::Const\n-                } else {\n-                    hir::Constness::NotConst\n-                };\n             clean_fn_decl_legacy_const_generics(&mut func, attrs);\n             FunctionItem(func)\n         }\n@@ -869,7 +859,7 @@ fn clean_function(\n         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n         (generics, decl)\n     });\n-    Function { decl, generics, header: sig.header }\n+    Function { decl, generics }\n }\n \n fn clean_args_from_types_and_names(\n@@ -998,12 +988,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                     AssocConstItem(ty.clean(cx), default)\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                    let mut m = clean_function(cx, sig, &self.generics, body);\n-                    if m.header.constness == hir::Constness::Const\n-                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                    {\n-                        m.header.constness = hir::Constness::NotConst;\n-                    }\n+                    let m = clean_function(cx, sig, &self.generics, body);\n                     MethodItem(m, None)\n                 }\n                 hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n@@ -1014,13 +999,7 @@ impl Clean<Item> for hir::TraitItem<'_> {\n                         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n                         (generics, decl)\n                     });\n-                    let mut t = Function { header: sig.header, decl, generics };\n-                    if t.header.constness == hir::Constness::Const\n-                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                    {\n-                        t.header.constness = hir::Constness::NotConst;\n-                    }\n-                    TyMethodItem(t)\n+                    TyMethodItem(Function { decl, generics })\n                 }\n                 hir::TraitItemKind::Type(bounds, ref default) => {\n                     let generics = enter_impl_trait(cx, |cx| self.generics.clean(cx));\n@@ -1047,12 +1026,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                     AssocConstItem(ty.clean(cx), default)\n                 }\n                 hir::ImplItemKind::Fn(ref sig, body) => {\n-                    let mut m = clean_function(cx, sig, &self.generics, body);\n-                    if m.header.constness == hir::Constness::Const\n-                        && is_unstable_const_fn(cx.tcx, local_did).is_some()\n-                    {\n-                        m.header.constness = hir::Constness::NotConst;\n-                    }\n+                    let m = clean_function(cx, sig, &self.generics, body);\n                     let defaultness = cx.tcx.associated_item(self.def_id).defaultness;\n                     MethodItem(m, Some(defaultness))\n                 }\n@@ -1127,40 +1101,13 @@ impl Clean<Item> for ty::AssocItem {\n                     ty::TraitContainer(_) => self.defaultness.has_value(),\n                 };\n                 if provided {\n-                    let constness = if tcx.is_const_fn_raw(self.def_id) {\n-                        hir::Constness::Const\n-                    } else {\n-                        hir::Constness::NotConst\n-                    };\n-                    let asyncness = tcx.asyncness(self.def_id);\n                     let defaultness = match self.container {\n                         ty::ImplContainer(_) => Some(self.defaultness),\n                         ty::TraitContainer(_) => None,\n                     };\n-                    MethodItem(\n-                        Function {\n-                            generics,\n-                            decl,\n-                            header: hir::FnHeader {\n-                                unsafety: sig.unsafety(),\n-                                abi: sig.abi(),\n-                                constness,\n-                                asyncness,\n-                            },\n-                        },\n-                        defaultness,\n-                    )\n+                    MethodItem(Function { generics, decl }, defaultness)\n                 } else {\n-                    TyMethodItem(Function {\n-                        generics,\n-                        decl,\n-                        header: hir::FnHeader {\n-                            unsafety: sig.unsafety(),\n-                            abi: sig.abi(),\n-                            constness: hir::Constness::NotConst,\n-                            asyncness: hir::IsAsync::NotAsync,\n-                        },\n-                    })\n+                    TyMethodItem(Function { generics, decl })\n                 }\n             }\n             ty::AssocKind::Type => {\n@@ -2192,28 +2139,14 @@ fn clean_maybe_renamed_foreign_item(\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n             hir::ForeignItemKind::Fn(decl, names, ref generics) => {\n-                let abi = cx.tcx.hir().get_foreign_abi(item.hir_id());\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n                     let generics = generics.clean(cx);\n                     let args = clean_args_from_types_and_names(cx, decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, decl, args);\n                     (generics, decl)\n                 });\n-                ForeignFunctionItem(Function {\n-                    decl,\n-                    generics,\n-                    header: hir::FnHeader {\n-                        unsafety: if abi == Abi::RustIntrinsic {\n-                            intrinsic_operation_unsafety(item.ident.name)\n-                        } else {\n-                            hir::Unsafety::Unsafe\n-                        },\n-                        abi,\n-                        constness: hir::Constness::NotConst,\n-                        asyncness: hir::IsAsync::NotAsync,\n-                    },\n-                })\n+                ForeignFunctionItem(Function { decl, generics })\n             }\n             hir::ForeignItemKind::Static(ref ty, mutability) => {\n                 ForeignStaticItem(Static { type_: ty.clean(cx), mutability, expr: None })"}, {"sha": "957faec30e1fc1a38c4fca76dcae34f3cd9ece50", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -13,6 +13,7 @@ use rustc_ast::attr;\n use rustc_ast::util::comments::beautify_doc_string;\n use rustc_ast::{self as ast, AttrStyle};\n use rustc_attr::{ConstStability, Deprecation, Stability, StabilityLevel};\n+use rustc_const_eval::const_eval::is_unstable_const_fn;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n@@ -29,6 +30,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, FileName, Loc};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n+use rustc_typeck::check::intrinsic::intrinsic_operation_unsafety;\n \n use crate::clean::cfg::Cfg;\n use crate::clean::external_path;\n@@ -641,6 +643,48 @@ impl Item {\n             _ => false,\n         }\n     }\n+\n+    /// Returns a `FnHeader` if `self` is a function item, otherwise returns `None`.\n+    crate fn fn_header(&self, tcx: TyCtxt<'_>) -> Option<hir::FnHeader> {\n+        fn build_fn_header(\n+            def_id: DefId,\n+            tcx: TyCtxt<'_>,\n+            asyncness: hir::IsAsync,\n+        ) -> hir::FnHeader {\n+            let sig = tcx.fn_sig(def_id);\n+            let constness =\n+                if tcx.is_const_fn(def_id) && is_unstable_const_fn(tcx, def_id).is_none() {\n+                    hir::Constness::Const\n+                } else {\n+                    hir::Constness::NotConst\n+                };\n+            hir::FnHeader { unsafety: sig.unsafety(), abi: sig.abi(), constness, asyncness }\n+        }\n+        let header = match *self.kind {\n+            ItemKind::ForeignFunctionItem(_) => {\n+                let abi = tcx.fn_sig(self.def_id.as_def_id().unwrap()).abi();\n+                hir::FnHeader {\n+                    unsafety: if abi == Abi::RustIntrinsic {\n+                        intrinsic_operation_unsafety(self.name.unwrap())\n+                    } else {\n+                        hir::Unsafety::Unsafe\n+                    },\n+                    abi,\n+                    constness: hir::Constness::NotConst,\n+                    asyncness: hir::IsAsync::NotAsync,\n+                }\n+            }\n+            ItemKind::FunctionItem(_) | ItemKind::MethodItem(_, _) => {\n+                let def_id = self.def_id.as_def_id().unwrap();\n+                build_fn_header(def_id, tcx, tcx.asyncness(def_id))\n+            }\n+            ItemKind::TyMethodItem(_) => {\n+                build_fn_header(self.def_id.as_def_id().unwrap(), tcx, hir::IsAsync::NotAsync)\n+            }\n+            _ => return None,\n+        };\n+        Some(header)\n+    }\n }\n \n #[derive(Clone, Debug)]\n@@ -1253,7 +1297,6 @@ crate struct Generics {\n crate struct Function {\n     crate decl: FnDecl,\n     crate generics: Generics,\n-    crate header: hir::FnHeader,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]"}, {"sha": "93b33b0d6091262082b3bb7f8147dafcdb0920fb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -48,7 +48,6 @@ use std::string::ToString;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{ConstStability, Deprecation, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n@@ -806,14 +805,14 @@ fn assoc_type(\n fn assoc_method(\n     w: &mut Buffer,\n     meth: &clean::Item,\n-    header: hir::FnHeader,\n     g: &clean::Generics,\n     d: &clean::FnDecl,\n     link: AssocItemLink<'_>,\n     parent: ItemType,\n     cx: &Context<'_>,\n     render_mode: RenderMode,\n ) {\n+    let header = meth.fn_header(cx.tcx()).expect(\"Trying to get header from a non-function item\");\n     let name = meth.name.as_ref().unwrap();\n     let href = match link {\n         AssocItemLink::Anchor(Some(ref id)) => Some(format!(\"#{}\", id)),\n@@ -972,10 +971,10 @@ fn render_assoc_item(\n     match *item.kind {\n         clean::StrippedItem(..) => {}\n         clean::TyMethodItem(ref m) => {\n-            assoc_method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n+            assoc_method(w, item, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n         clean::MethodItem(ref m, _) => {\n-            assoc_method(w, item, m.header, &m.generics, &m.decl, link, parent, cx, render_mode)\n+            assoc_method(w, item, &m.generics, &m.decl, link, parent, cx, render_mode)\n         }\n         clean::AssocConstItem(ref ty, _) => {\n             assoc_const(w, item, ty, link, if parent == ItemType::Trait { \"    \" } else { \"\" }, cx)"}, {"sha": "6c9a5a955d76ec3b4e5fa830a4bb0ee0831ec04e", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -365,8 +365,9 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n                 }\n \n                 let unsafety_flag = match *myitem.kind {\n-                    clean::FunctionItem(ref func) | clean::ForeignFunctionItem(ref func)\n-                        if func.header.unsafety == hir::Unsafety::Unsafe =>\n+                    clean::FunctionItem(_) | clean::ForeignFunctionItem(_)\n+                        if myitem.fn_header(cx.tcx()).unwrap().unsafety\n+                            == hir::Unsafety::Unsafe =>\n                     {\n                         \"<a title=\\\"unsafe function\\\" href=\\\"#\\\"><sup>\u26a0</sup></a>\"\n                     }\n@@ -462,16 +463,17 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n }\n \n fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::Function) {\n-    let vis = it.visibility.print_with_space(it.def_id, cx).to_string();\n-    let constness = print_constness_with_space(&f.header.constness, it.const_stability(cx.tcx()));\n-    let asyncness = f.header.asyncness.print_with_space();\n-    let unsafety = f.header.unsafety.print_with_space();\n-    let abi = print_abi_with_space(f.header.abi).to_string();\n+    let header = it.fn_header(cx.tcx()).expect(\"printing a function which isn't a function\");\n+    let constness = print_constness_with_space(&header.constness, it.const_stability(cx.tcx()));\n+    let unsafety = header.unsafety.print_with_space().to_string();\n+    let abi = print_abi_with_space(header.abi).to_string();\n+    let asyncness = header.asyncness.print_with_space();\n+    let visibility = it.visibility.print_with_space(it.def_id, cx).to_string();\n     let name = it.name.unwrap();\n \n     let generics_len = format!(\"{:#}\", f.generics.print(cx)).len();\n     let header_len = \"fn \".len()\n-        + vis.len()\n+        + visibility.len()\n         + constness.len()\n         + asyncness.len()\n         + unsafety.len()\n@@ -487,15 +489,15 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n                 w,\n                 \"{vis}{constness}{asyncness}{unsafety}{abi}fn \\\n                  {name}{generics}{decl}{notable_traits}{where_clause}\",\n-                vis = vis,\n+                vis = visibility,\n                 constness = constness,\n                 asyncness = asyncness,\n                 unsafety = unsafety,\n                 abi = abi,\n                 name = name,\n                 generics = f.generics.print(cx),\n                 where_clause = print_where_clause(&f.generics, cx, 0, true),\n-                decl = f.decl.full_print(header_len, 0, f.header.asyncness, cx),\n+                decl = f.decl.full_print(header_len, 0, header.asyncness, cx),\n                 notable_traits = notable_traits_decl(&f.decl, cx),\n             );\n         });"}, {"sha": "bc638200533fd88075384a5b7bac7960ba704a2c", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -199,6 +199,8 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n     use clean::ItemKind::*;\n     let name = item.name;\n     let is_crate = item.is_crate();\n+    let header = item.fn_header(tcx);\n+\n     match *item.kind {\n         ModuleItem(m) => ItemEnum::Module(Module { is_crate, items: ids(m.items) }),\n         ImportItem(i) => ItemEnum::Import(i.into_tcx(tcx)),\n@@ -207,12 +209,12 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n         StructFieldItem(f) => ItemEnum::StructField(f.into_tcx(tcx)),\n         EnumItem(e) => ItemEnum::Enum(e.into_tcx(tcx)),\n         VariantItem(v) => ItemEnum::Variant(v.into_tcx(tcx)),\n-        FunctionItem(f) => ItemEnum::Function(f.into_tcx(tcx)),\n-        ForeignFunctionItem(f) => ItemEnum::Function(f.into_tcx(tcx)),\n+        FunctionItem(f) => ItemEnum::Function(from_function(f, header.unwrap(), tcx)),\n+        ForeignFunctionItem(f) => ItemEnum::Function(from_function(f, header.unwrap(), tcx)),\n         TraitItem(t) => ItemEnum::Trait(t.into_tcx(tcx)),\n         TraitAliasItem(t) => ItemEnum::TraitAlias(t.into_tcx(tcx)),\n-        MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true, tcx)),\n-        TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false, tcx)),\n+        MethodItem(m, _) => ItemEnum::Method(from_function_method(m, true, header.unwrap(), tcx)),\n+        TyMethodItem(m) => ItemEnum::Method(from_function_method(m, false, header.unwrap(), tcx)),\n         ImplItem(i) => ItemEnum::Impl(i.into_tcx(tcx)),\n         StaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n         ForeignStaticItem(s) => ItemEnum::Static(s.into_tcx(tcx)),\n@@ -300,17 +302,6 @@ fn convert_abi(a: RustcAbi) -> Abi {\n     }\n }\n \n-impl FromWithTcx<clean::Function> for Function {\n-    fn from_tcx(function: clean::Function, tcx: TyCtxt<'_>) -> Self {\n-        let clean::Function { decl, generics, header } = function;\n-        Function {\n-            decl: decl.into_tcx(tcx),\n-            generics: generics.into_tcx(tcx),\n-            header: from_fn_header(&header),\n-        }\n-    }\n-}\n-\n impl FromWithTcx<clean::Generics> for Generics {\n     fn from_tcx(generics: clean::Generics, tcx: TyCtxt<'_>) -> Self {\n         Generics {\n@@ -555,12 +546,26 @@ impl FromWithTcx<clean::Impl> for Impl {\n     }\n }\n \n+crate fn from_function(\n+    function: clean::Function,\n+    header: rustc_hir::FnHeader,\n+    tcx: TyCtxt<'_>,\n+) -> Function {\n+    let clean::Function { decl, generics } = function;\n+    Function {\n+        decl: decl.into_tcx(tcx),\n+        generics: generics.into_tcx(tcx),\n+        header: from_fn_header(&header),\n+    }\n+}\n+\n crate fn from_function_method(\n     function: clean::Function,\n     has_body: bool,\n+    header: rustc_hir::FnHeader,\n     tcx: TyCtxt<'_>,\n ) -> Method {\n-    let clean::Function { header, decl, generics } = function;\n+    let clean::Function { decl, generics } = function;\n     Method {\n         decl: decl.into_tcx(tcx),\n         generics: generics.into_tcx(tcx),"}, {"sha": "6e1dc453982d93948d85bf49d37219cba28541f3", "filename": "src/test/rustdoc/reexport-dep-foreign-fn.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11909e3588319235e28e99294e17cca11db1d7e2/src%2Ftest%2Frustdoc%2Freexport-dep-foreign-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11909e3588319235e28e99294e17cca11db1d7e2/src%2Ftest%2Frustdoc%2Freexport-dep-foreign-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Freexport-dep-foreign-fn.rs?ref=11909e3588319235e28e99294e17cca11db1d7e2", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:all-item-types.rs\n+\n+// This test is to ensure there is no problem on handling foreign functions\n+// coming from a dependency.\n+\n+#![crate_name = \"foo\"]\n+\n+extern crate all_item_types;\n+\n+// @has 'foo/fn.foo_ffn.html'\n+// @has - '//*[@class=\"docblock item-decl\"]//code' 'pub unsafe extern \"C\" fn foo_ffn()'\n+pub use all_item_types::foo_ffn;"}]}