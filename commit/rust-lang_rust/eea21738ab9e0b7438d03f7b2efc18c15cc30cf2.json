{"sha": "eea21738ab9e0b7438d03f7b2efc18c15cc30cf2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYTIxNzM4YWI5ZTBiNzQzOGQwM2Y3YjJlZmMxOGMxNWNjMzBjZjI=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-02T10:20:39Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-05-02T10:20:39Z"}, "message": "Add unwrap block assist #4156\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "374eeda78a349801ccffc2e39368cfb26a53445a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/374eeda78a349801ccffc2e39368cfb26a53445a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eea21738ab9e0b7438d03f7b2efc18c15cc30cf2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eea21738ab9e0b7438d03f7b2efc18c15cc30cf2", "html_url": "https://github.com/rust-lang/rust/commit/eea21738ab9e0b7438d03f7b2efc18c15cc30cf2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eea21738ab9e0b7438d03f7b2efc18c15cc30cf2/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df7899e47a83fb5544d09d2db9405762d3ce29b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/df7899e47a83fb5544d09d2db9405762d3ce29b7", "html_url": "https://github.com/rust-lang/rust/commit/df7899e47a83fb5544d09d2db9405762d3ce29b7"}], "stats": {"total": 89, "additions": 13, "deletions": 76}, "files": [{"sha": "8912ce6451194fcf18613b71a81680d471dad70d", "filename": "crates/ra_assists/src/handlers/unwrap_block.rs", "status": "modified", "additions": 13, "deletions": 76, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eea21738ab9e0b7438d03f7b2efc18c15cc30cf2/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eea21738ab9e0b7438d03f7b2efc18c15cc30cf2/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=eea21738ab9e0b7438d03f7b2efc18c15cc30cf2", "patch": "@@ -1,8 +1,8 @@\n use crate::{Assist, AssistCtx, AssistId};\n \n-use ast::{BlockExpr, Expr, LoopBodyOwner};\n+use ast::{BlockExpr, Expr, ForExpr, IfExpr, LoopBodyOwner, LoopExpr, WhileExpr};\n use ra_fmt::unwrap_trivial_block;\n-use ra_syntax::{ast, AstNode, TextRange};\n+use ra_syntax::{ast, AstNode, TextRange, T};\n \n // Assist: unwrap_block\n //\n@@ -22,15 +22,11 @@ use ra_syntax::{ast, AstNode, TextRange};\n // }\n // ```\n pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n-    let res = if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n+    let l_curly_token = ctx.find_token_at_offset(T!['{'])?;\n+\n+    let res = if let Some(if_expr) = l_curly_token.ancestors().find_map(IfExpr::cast) {\n         // if expression\n-        let mut expr_to_unwrap: Option<ast::Expr> = None;\n-        for block_expr in if_expr.blocks() {\n-            if let Some(expr) = excract_expr(ctx.frange.range, block_expr) {\n-                expr_to_unwrap = Some(expr);\n-                break;\n-            }\n-        }\n+        let expr_to_unwrap = if_expr.blocks().find_map(|expr| extract_expr(ctx.frange.range, expr));\n         let expr_to_unwrap = expr_to_unwrap?;\n         // Find if we are in a else if block\n         let ancestor = if_expr.syntax().ancestors().skip(1).find_map(ast::IfExpr::cast);\n@@ -40,20 +36,20 @@ pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n         } else {\n             Some((ast::Expr::IfExpr(if_expr), expr_to_unwrap))\n         }\n-    } else if let Some(for_expr) = ctx.find_node_at_offset::<ast::ForExpr>() {\n+    } else if let Some(for_expr) = l_curly_token.ancestors().find_map(ForExpr::cast) {\n         // for expression\n         let block_expr = for_expr.loop_body()?;\n-        excract_expr(ctx.frange.range, block_expr)\n+        extract_expr(ctx.frange.range, block_expr)\n             .map(|expr_to_unwrap| (ast::Expr::ForExpr(for_expr), expr_to_unwrap))\n-    } else if let Some(while_expr) = ctx.find_node_at_offset::<ast::WhileExpr>() {\n+    } else if let Some(while_expr) = l_curly_token.ancestors().find_map(WhileExpr::cast) {\n         // while expression\n         let block_expr = while_expr.loop_body()?;\n-        excract_expr(ctx.frange.range, block_expr)\n+        extract_expr(ctx.frange.range, block_expr)\n             .map(|expr_to_unwrap| (ast::Expr::WhileExpr(while_expr), expr_to_unwrap))\n-    } else if let Some(loop_expr) = ctx.find_node_at_offset::<ast::LoopExpr>() {\n+    } else if let Some(loop_expr) = l_curly_token.ancestors().find_map(LoopExpr::cast) {\n         // loop expression\n         let block_expr = loop_expr.loop_body()?;\n-        excract_expr(ctx.frange.range, block_expr)\n+        extract_expr(ctx.frange.range, block_expr)\n             .map(|expr_to_unwrap| (ast::Expr::LoopExpr(loop_expr), expr_to_unwrap))\n     } else {\n         None\n@@ -80,7 +76,7 @@ pub(crate) fn unwrap_block(ctx: AssistCtx) -> Option<Assist> {\n     })\n }\n \n-fn excract_expr(cursor_range: TextRange, block_expr: BlockExpr) -> Option<Expr> {\n+fn extract_expr(cursor_range: TextRange, block_expr: BlockExpr) -> Option<Expr> {\n     let block = block_expr.block()?;\n     let cursor_in_range = block.l_curly_token()?.text_range().contains_range(cursor_range);\n \n@@ -200,65 +196,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn issue_example_with_if() {\n-        check_assist(\n-            unwrap_block,\n-            r#\"\n-            fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &Type) {\n-                if let Some(ty) = &ctx.expected_type {<|>\n-                    if let Some(Adt::Enum(enum_data)) = ty.as_adt() {\n-                        let variants = enum_data.variants(ctx.db);\n-\n-                        let module = if let Some(module) = ctx.scope().module() {\n-                            // Compute path from the completion site if available.\n-                            module\n-                        } else {\n-                            // Otherwise fall back to the enum's definition site.\n-                            enum_data.module(ctx.db)\n-                        };\n-\n-                        for variant in variants {\n-                            if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n-                                // Variants with trivial paths are already added by the existing completion logic,\n-                                // so we should avoid adding these twice\n-                                if path.segments.len() > 1 {\n-                                    acc.add_enum_variant(ctx, variant, Some(path.to_string()));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &Type) {\n-                <|>if let Some(Adt::Enum(enum_data)) = ty.as_adt() {\n-                    let variants = enum_data.variants(ctx.db);\n-\n-                    let module = if let Some(module) = ctx.scope().module() {\n-                        // Compute path from the completion site if available.\n-                        module\n-                    } else {\n-                        // Otherwise fall back to the enum's definition site.\n-                        enum_data.module(ctx.db)\n-                    };\n-\n-                    for variant in variants {\n-                        if let Some(path) = module.find_use_path(ctx.db, ModuleDef::from(variant)) {\n-                            // Variants with trivial paths are already added by the existing completion logic,\n-                            // so we should avoid adding these twice\n-                            if path.segments.len() > 1 {\n-                                acc.add_enum_variant(ctx, variant, Some(path.to_string()));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            \"#,\n-        );\n-    }\n-\n     #[test]\n     fn simple_for() {\n         check_assist("}]}