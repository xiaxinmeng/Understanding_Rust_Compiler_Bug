{"sha": "4ac438bfed36c1de307cac0f86d8d4938157ac50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYzQzOGJmZWQzNmMxZGUzMDdjYWMwZjg2ZDhkNDkzODE1N2FjNTA=", "commit": {"author": {"name": "Yusuke Tanaka", "email": "yusuktan@maguro.dev", "date": "2021-02-10T14:15:06Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-03-02T09:37:30Z"}, "message": "Add transmute/utils.rs", "tree": {"sha": "40e1a909401e5867c669d49336cb80cf7ecb6f7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40e1a909401e5867c669d49336cb80cf7ecb6f7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ac438bfed36c1de307cac0f86d8d4938157ac50", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmA+B1oACgkQHKDfKvWd\naKWb9g//UMond8Ujwe+0U43w25PY0Al/7aHEZEjWOwliAB1i4X7iiVUF+6mj+22+\n7cvRuj+AH/hHSQrsgzP2+dSi2358v4iVlcBf970eC5+am6pW6ehxQ9hLxZwcmoQl\nhmz6TR/q7i658/jXRCU92Ncgl4jg7kVG7rl5+pTX2xwa55T1p8IsT+2c8WJSngbj\nr7cOiFQ5wFnS5Ce/K2iKNNIUuUFCgc+H4hzQXS3z9p6cBv5WbuZcIQJ5nfltnkhH\nNg1575wNNC8LiGbJD0ynL7nXaRTP8DtiTCamnLSbqSKTQaLSEfL+5M9uXtMpbC1u\nNNqckeFMH60yla3VE2t+JnzGczCAV2mxrBm9m5qnLnt95UzPbpxeII24dS49HeMp\nfqfG55lGAmtDSWS71tDbu94NZI64Vq4o8KN1k5rIn8hEIV2pSqQ9FdW6AWoSVh5h\nVzrNBPfkel9CZXiQHnQZ5vqyOKrrKM522bWEh3r3vNKv2mQA7k90aDlbV2XeG5z1\n4bHZVUeaniFDHztkp87pW+rbZ63i2/QcJ1PvdOxnjE1yvG3igHrwYym7RnDCNZRW\ngHOuyODNowsAMSzet3+Ro6/+RTMCYiF99DWyNudlmKRNnKqz4upapu3FT4cHbLvN\nRhgNUMe1NG5uoMS3uZTITlebH5Wu2zdpevujrFIzvysuiTqnZ5I=\n=a0Nq\n-----END PGP SIGNATURE-----", "payload": "tree 40e1a909401e5867c669d49336cb80cf7ecb6f7d\nparent 306545ff9653a8e1d00c4f381c8e609d3ad49adb\nauthor Yusuke Tanaka <yusuktan@maguro.dev> 1612966506 +0900\ncommitter flip1995 <philipp.krones@embecosm.com> 1614677850 +0100\n\nAdd transmute/utils.rs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac438bfed36c1de307cac0f86d8d4938157ac50", "html_url": "https://github.com/rust-lang/rust/commit/4ac438bfed36c1de307cac0f86d8d4938157ac50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ac438bfed36c1de307cac0f86d8d4938157ac50/comments", "author": {"login": "magurotuna", "id": 23649474, "node_id": "MDQ6VXNlcjIzNjQ5NDc0", "avatar_url": "https://avatars.githubusercontent.com/u/23649474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/magurotuna", "html_url": "https://github.com/magurotuna", "followers_url": "https://api.github.com/users/magurotuna/followers", "following_url": "https://api.github.com/users/magurotuna/following{/other_user}", "gists_url": "https://api.github.com/users/magurotuna/gists{/gist_id}", "starred_url": "https://api.github.com/users/magurotuna/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/magurotuna/subscriptions", "organizations_url": "https://api.github.com/users/magurotuna/orgs", "repos_url": "https://api.github.com/users/magurotuna/repos", "events_url": "https://api.github.com/users/magurotuna/events{/privacy}", "received_events_url": "https://api.github.com/users/magurotuna/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "306545ff9653a8e1d00c4f381c8e609d3ad49adb", "url": "https://api.github.com/repos/rust-lang/rust/commits/306545ff9653a8e1d00c4f381c8e609d3ad49adb", "html_url": "https://github.com/rust-lang/rust/commit/306545ff9653a8e1d00c4f381c8e609d3ad49adb"}], "stats": {"total": 219, "additions": 116, "deletions": 103}, "files": [{"sha": "0258244a07bad0ce28117390c8a0337c5aa8f897", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 7, "deletions": 103, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/4ac438bfed36c1de307cac0f86d8d4938157ac50/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac438bfed36c1de307cac0f86d8d4938157ac50/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=4ac438bfed36c1de307cac0f86d8d4938157ac50", "patch": "@@ -1,16 +1,16 @@\n+mod utils;\n+use utils::*;\n+\n use crate::utils::{\n-    in_constant, is_normalizable, last_path_segment, match_def_path, paths, snippet, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, sugg,\n+    in_constant, match_def_path, paths, snippet, span_lint, span_lint_and_sugg, span_lint_and_then, sugg,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, GenericArg, Mutability, QPath, TyKind, UnOp};\n+use rustc_hir::{Expr, ExprKind, Mutability, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, cast::CastKind, Ty};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::DUMMY_SP;\n-use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -326,6 +326,7 @@ static COLLECTIONS: &[&[&str]] = &[\n     &paths::HASHSET,\n     &paths::HASHMAP,\n ];\n+\n impl<'tcx> LateLintPass<'tcx> for Transmute {\n     #[allow(clippy::similar_names, clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n@@ -664,100 +665,3 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n         }\n     }\n }\n-\n-/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n-/// not available , use\n-/// the type's `ToString` implementation. In weird cases it could lead to types\n-/// with invalid `'_`\n-/// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n-    let seg = last_path_segment(path);\n-    if_chain! {\n-        if let Some(ref params) = seg.args;\n-        if !params.parenthesized;\n-        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        }).nth(1);\n-        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n-        then {\n-            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n-        }\n-    }\n-\n-    to_ref_ty.to_string()\n-}\n-\n-// check if the component types of the transmuted collection and the result have different ABI,\n-// size or alignment\n-fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n-    let empty_param_env = ty::ParamEnv::empty();\n-    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n-    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n-        return false;\n-    }\n-    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n-    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n-    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n-        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n-    } else {\n-        // no idea about layout, so don't lint\n-        false\n-    }\n-}\n-\n-/// Check if the type conversion can be expressed as a pointer cast, instead of\n-/// a transmute. In certain cases, including some invalid casts from array\n-/// references to pointers, this may cause additional errors to be emitted and/or\n-/// ICE error messages. This function will panic if that occurs.\n-fn can_be_expressed_as_pointer_cast<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    from_ty: Ty<'tcx>,\n-    to_ty: Ty<'tcx>,\n-) -> bool {\n-    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n-    matches!(\n-        check_cast(cx, e, from_ty, to_ty),\n-        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n-    )\n-}\n-\n-/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n-/// the cast. In certain cases, including some invalid casts from array references\n-/// to pointers, this may cause additional errors to be emitted and/or ICE error\n-/// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n-    let hir_id = e.hir_id;\n-    let local_def_id = hir_id.owner;\n-\n-    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n-\n-        // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(\n-            !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n-        );\n-\n-        if let Ok(check) = CastCheck::new(\n-            &fn_ctxt, e, from_ty, to_ty,\n-            // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP, DUMMY_SP,\n-        ) {\n-            let res = check.do_check(&fn_ctxt);\n-\n-            // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returing Err in some cases. Those cases\n-            // should be filtered out before getting here.\n-            assert!(\n-                !fn_ctxt.errors_reported_since_creation(),\n-                \"`fn_ctxt` contained errors after cast check!\"\n-            );\n-\n-            res.ok()\n-        } else {\n-            None\n-        }\n-    })\n-}"}, {"sha": "734a92d50d2ada5f1a852b7ea15cfaeb83045391", "filename": "clippy_lints/src/transmute/utils.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4ac438bfed36c1de307cac0f86d8d4938157ac50/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac438bfed36c1de307cac0f86d8d4938157ac50/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=4ac438bfed36c1de307cac0f86d8d4938157ac50", "patch": "@@ -0,0 +1,109 @@\n+use crate::utils::{is_normalizable, last_path_segment, snippet};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, cast::CastKind, Ty};\n+use rustc_span::DUMMY_SP;\n+use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n+\n+/// Gets the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is\n+/// not available , use\n+/// the type's `ToString` implementation. In weird cases it could lead to types\n+/// with invalid `'_`\n+/// lifetime, but it should be rare.\n+pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty: Ty<'_>) -> String {\n+    let seg = last_path_segment(path);\n+    if_chain! {\n+        if let Some(ref params) = seg.args;\n+        if !params.parenthesized;\n+        if let Some(to_ty) = params.args.iter().filter_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        }).nth(1);\n+        if let TyKind::Rptr(_, ref to_ty) = to_ty.kind;\n+        then {\n+            return snippet(cx, to_ty.ty.span, &to_ref_ty.to_string()).to_string();\n+        }\n+    }\n+\n+    to_ref_ty.to_string()\n+}\n+\n+// check if the component types of the transmuted collection and the result have different ABI,\n+// size or alignment\n+pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n+    let empty_param_env = ty::ParamEnv::empty();\n+    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n+    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n+        return false;\n+    }\n+    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n+    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n+    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n+        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n+    } else {\n+        // no idea about layout, so don't lint\n+        false\n+    }\n+}\n+\n+/// Check if the type conversion can be expressed as a pointer cast, instead of\n+/// a transmute. In certain cases, including some invalid casts from array\n+/// references to pointers, this may cause additional errors to be emitted and/or\n+/// ICE error messages. This function will panic if that occurs.\n+pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> bool {\n+    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n+    matches!(\n+        check_cast(cx, e, from_ty, to_ty),\n+        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n+    )\n+}\n+\n+/// If a cast from `from_ty` to `to_ty` is valid, returns an Ok containing the kind of\n+/// the cast. In certain cases, including some invalid casts from array references\n+/// to pointers, this may cause additional errors to be emitted and/or ICE error\n+/// messages. This function will panic if that occurs.\n+pub(super) fn check_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> Option<CastKind> {\n+    let hir_id = e.hir_id;\n+    let local_def_id = hir_id.owner;\n+\n+    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n+        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n+\n+        // If we already have errors, we can't be sure we can pointer cast.\n+        assert!(\n+            !fn_ctxt.errors_reported_since_creation(),\n+            \"Newly created FnCtxt contained errors\"\n+        );\n+\n+        if let Ok(check) = CastCheck::new(\n+            &fn_ctxt, e, from_ty, to_ty,\n+            // We won't show any error to the user, so we don't care what the span is here.\n+            DUMMY_SP, DUMMY_SP,\n+        ) {\n+            let res = check.do_check(&fn_ctxt);\n+\n+            // do_check's documentation says that it might return Ok and create\n+            // errors in the fcx instead of returing Err in some cases. Those cases\n+            // should be filtered out before getting here.\n+            assert!(\n+                !fn_ctxt.errors_reported_since_creation(),\n+                \"`fn_ctxt` contained errors after cast check!\"\n+            );\n+\n+            res.ok()\n+        } else {\n+            None\n+        }\n+    })\n+}"}]}