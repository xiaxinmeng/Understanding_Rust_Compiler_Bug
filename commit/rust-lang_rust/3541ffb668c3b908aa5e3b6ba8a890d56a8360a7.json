{"sha": "3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NDFmZmI2NjhjM2I5MDhhYTVlM2I2YmE4YTg5MGQ1NmE4MzYwYTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-17T20:08:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-10-18T14:01:29Z"}, "message": "rustc: Add `_imp_` symbols later in compilation\n\nOn MSVC targets rustc will add symbols prefixed with `_imp_` to LLVM modules to\n\"emulate\" dllexported statics as that workaround is still in place after #27438\nhasn't been solved otherwise. These statics, however, were getting gc'd by\nThinLTO accidentally which later would cause linking failures.\n\nThis commit updates the location we add such symbols to happen just before\ncodegen to ensure that (a) they're not eliminated by the optimizer and (b) the\noptimizer doesn't even worry about them.\n\nCloses #45347", "tree": {"sha": "e6b61b7c8dedf19f3b4cdfa8ee7fcb6b0d8f518d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6b61b7c8dedf19f3b4cdfa8ee7fcb6b0d8f518d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "html_url": "https://github.com/rust-lang/rust/commit/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0be6863a15f5aacacb287ca490823ab3b7ceb302", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be6863a15f5aacacb287ca490823ab3b7ceb302", "html_url": "https://github.com/rust-lang/rust/commit/0be6863a15f5aacacb287ca490823ab3b7ceb302"}], "stats": {"total": 165, "additions": 115, "deletions": 50}, "files": [{"sha": "f8dbe68dba9be011ab80dc5992b9474eb6f04fff", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "patch": "@@ -12,6 +12,8 @@ use back::lto;\n use back::link::{self, get_linker, remove};\n use back::linker::LinkerInfo;\n use back::symbol_export::ExportedSymbols;\n+use base;\n+use consts;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n@@ -35,12 +37,13 @@ use syntax::attr;\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n+use type_::Type;\n use context::{is_pie_binary, get_reloc_model};\n use jobserver::{Client, Acquired};\n use rustc_demangle;\n \n use std::any::Any;\n-use std::ffi::CString;\n+use std::ffi::{CString, CStr};\n use std::fs;\n use std::io;\n use std::io::Write;\n@@ -315,6 +318,8 @@ pub struct CodegenContext {\n     metadata_module_config: Arc<ModuleConfig>,\n     allocator_module_config: Arc<ModuleConfig>,\n     pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n+    pub msvc_imps_needed: bool,\n+    pub target_pointer_width: String,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -586,6 +591,10 @@ unsafe fn codegen(cgcx: &CodegenContext,\n     let module_name = Some(&module_name[..]);\n     let handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n+    if cgcx.msvc_imps_needed {\n+        create_msvc_imps(cgcx, llcx, llmod);\n+    }\n+\n     // A codegen-specific pass manager is used to generate object\n     // files for an LLVM module.\n     //\n@@ -1300,6 +1309,8 @@ fn start_executing_work(tcx: TyCtxt,\n         allocator_module_config: allocator_config,\n         tm_factory: target_machine_factory(tcx.sess),\n         total_cgus,\n+        msvc_imps_needed: msvc_imps_needed(tcx),\n+        target_pointer_width: tcx.sess.target.target.target_pointer_width.clone(),\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n@@ -2133,3 +2144,51 @@ pub fn submit_translated_module_to_llvm(tcx: TyCtxt,\n         cost,\n     })));\n }\n+\n+fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n+    tcx.sess.target.target.options.is_like_msvc &&\n+        tcx.sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib)\n+}\n+\n+// Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n+// This is required to satisfy `dllimport` references to static data in .rlibs\n+// when using MSVC linker.  We do this only for data, as linker can fix up\n+// code references on its own.\n+// See #26591, #27438\n+fn create_msvc_imps(cgcx: &CodegenContext, llcx: ContextRef, llmod: ModuleRef) {\n+    if !cgcx.msvc_imps_needed {\n+        return\n+    }\n+    // The x86 ABI seems to require that leading underscores are added to symbol\n+    // names, so we need an extra underscore on 32-bit. There's also a leading\n+    // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n+    // underscores added in front).\n+    let prefix = if cgcx.target_pointer_width == \"32\" {\n+        \"\\x01__imp__\"\n+    } else {\n+        \"\\x01__imp_\"\n+    };\n+    unsafe {\n+        let i8p_ty = Type::i8p_llcx(llcx);\n+        let globals = base::iter_globals(llmod)\n+            .filter(|&val| {\n+                llvm::LLVMRustGetLinkage(val) == llvm::Linkage::ExternalLinkage &&\n+                    llvm::LLVMIsDeclaration(val) == 0\n+            })\n+            .map(move |val| {\n+                let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+                let mut imp_name = prefix.as_bytes().to_vec();\n+                imp_name.extend(name.to_bytes());\n+                let imp_name = CString::new(imp_name).unwrap();\n+                (imp_name, val)\n+            })\n+            .collect::<Vec<_>>();\n+        for (imp_name, val) in globals {\n+            let imp = llvm::LLVMAddGlobal(llmod,\n+                                          i8p_ty.to_ref(),\n+                                          imp_name.as_ptr() as *const _);\n+            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n+            llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n+        }\n+    }\n+}"}, {"sha": "7bc33a88956556856d7a61c4a0eab391866d43bf", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "patch": "@@ -78,7 +78,7 @@ use rustc::util::nodemap::{NodeSet, FxHashMap, FxHashSet, DefIdSet};\n use CrateInfo;\n \n use std::any::Any;\n-use std::ffi::{CStr, CString};\n+use std::ffi::CString;\n use std::str;\n use std::sync::Arc;\n use std::time::{Instant, Duration};\n@@ -812,47 +812,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     return (metadata_llcx, metadata_llmod, metadata, hashes);\n }\n \n-// Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n-// This is required to satisfy `dllimport` references to static data in .rlibs\n-// when using MSVC linker.  We do this only for data, as linker can fix up\n-// code references on its own.\n-// See #26591, #27438\n-fn create_imps(sess: &Session,\n-               llvm_module: &ModuleLlvm) {\n-    // The x86 ABI seems to require that leading underscores are added to symbol\n-    // names, so we need an extra underscore on 32-bit. There's also a leading\n-    // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n-    // underscores added in front).\n-    let prefix = if sess.target.target.target_pointer_width == \"32\" {\n-        \"\\x01__imp__\"\n-    } else {\n-        \"\\x01__imp_\"\n-    };\n-    unsafe {\n-        let exported: Vec<_> = iter_globals(llvm_module.llmod)\n-                                   .filter(|&val| {\n-                                       llvm::LLVMRustGetLinkage(val) ==\n-                                       llvm::Linkage::ExternalLinkage &&\n-                                       llvm::LLVMIsDeclaration(val) == 0\n-                                   })\n-                                   .collect();\n-\n-        let i8p_ty = Type::i8p_llcx(llvm_module.llcx);\n-        for val in exported {\n-            let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-            let mut imp_name = prefix.as_bytes().to_vec();\n-            imp_name.extend(name.to_bytes());\n-            let imp_name = CString::new(imp_name).unwrap();\n-            let imp = llvm::LLVMAddGlobal(llvm_module.llmod,\n-                                          i8p_ty.to_ref(),\n-                                          imp_name.as_ptr() as *const _);\n-            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n-            llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n-        }\n-    }\n-}\n-\n-struct ValueIter {\n+pub struct ValueIter {\n     cur: ValueRef,\n     step: unsafe extern \"C\" fn(ValueRef) -> ValueRef,\n }\n@@ -871,7 +831,7 @@ impl Iterator for ValueIter {\n     }\n }\n \n-fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n+pub fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n     unsafe {\n         ValueIter {\n             cur: llvm::LLVMGetFirstGlobal(llmod),\n@@ -1437,12 +1397,6 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tm: create_target_machine(ccx.sess()),\n             };\n \n-            // Adjust exported symbols for MSVC dllimport\n-            if ccx.sess().target.target.options.is_like_msvc &&\n-               ccx.sess().crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-                create_imps(ccx.sess(), &llvm_module);\n-            }\n-\n             ModuleTranslation {\n                 name: cgu_name,\n                 source: ModuleSource::Translated(llvm_module),"}, {"sha": "eff7802a2451934dd329fc69c52607d478c46ddb", "filename": "src/test/run-pass/thinlto/auxiliary/msvc-imp-present.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Ftest%2Frun-pass%2Fthinlto%2Fauxiliary%2Fmsvc-imp-present.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Ftest%2Frun-pass%2Fthinlto%2Fauxiliary%2Fmsvc-imp-present.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fauxiliary%2Fmsvc-imp-present.rs?ref=3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+// compile-flags: -Z thinlto -C codegen-units=8 -C prefer-dynamic\n+\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+\n+pub static A: u32 = 43;\n+\n+pub mod a {\n+    pub static A: u32 = 43;\n+}"}, {"sha": "8329c7032f1b695b04ffaff630c8c1e87804e76e", "filename": "src/test/run-pass/thinlto/msvc-imp-present.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Ftest%2Frun-pass%2Fthinlto%2Fmsvc-imp-present.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3541ffb668c3b908aa5e3b6ba8a890d56a8360a7/src%2Ftest%2Frun-pass%2Fthinlto%2Fmsvc-imp-present.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fmsvc-imp-present.rs?ref=3541ffb668c3b908aa5e3b6ba8a890d56a8360a7", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:msvc-imp-present.rs\n+// compile-flags: -Z thinlto -C codegen-units=8\n+// min-llvm-version: 4.0\n+// no-prefer-dynamic\n+\n+// On MSVC we have a \"hack\" where we emit symbols that look like `_imp_$name`\n+// for all exported statics. This is done because we apply `dllimport` to all\n+// imported constants and this allows everything to actually link correctly.\n+//\n+// The ThinLTO passes aggressively remove symbols if they can, and this test\n+// asserts that the ThinLTO passes don't remove these compiler-generated\n+// `_imp_*` symbols. The external library that we link in here is compiled with\n+// ThinLTO and multiple codegen units and has a few exported constants. Note\n+// that we also namely compile the library as both a dylib and an rlib, but we\n+// link the rlib to ensure that we assert those generated symbols exist.\n+\n+extern crate msvc_imp_present as bar;\n+\n+fn main() {\n+    println!(\"{}\", bar::A);\n+}"}]}