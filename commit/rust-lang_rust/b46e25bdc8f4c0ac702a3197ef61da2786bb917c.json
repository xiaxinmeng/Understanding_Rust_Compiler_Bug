{"sha": "b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NmUyNWJkYzhmNGMwYWM3MDJhMzE5N2VmNjFkYTI3ODZiYjkxN2M=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-18T20:16:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-18T20:22:59Z"}, "message": "Merge commit 'erickt/incoming^' into kind-names", "tree": {"sha": "1b8a930525b91f26bfd1ca32e1af0485dc89eb34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8a930525b91f26bfd1ca32e1af0485dc89eb34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "html_url": "https://github.com/rust-lang/rust/commit/b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "807ce6216974dd860ae6390cd2f06c6d7dcfd4bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/807ce6216974dd860ae6390cd2f06c6d7dcfd4bc", "html_url": "https://github.com/rust-lang/rust/commit/807ce6216974dd860ae6390cd2f06c6d7dcfd4bc"}, {"sha": "85bb1fc2c4e2060bc9b9800743c840c261e47fb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/85bb1fc2c4e2060bc9b9800743c840c261e47fb3", "html_url": "https://github.com/rust-lang/rust/commit/85bb1fc2c4e2060bc9b9800743c840c261e47fb3"}], "stats": {"total": 219, "additions": 113, "deletions": 106}, "files": [{"sha": "eed439823fcf766f3166a23fd5297b11e301f8be", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -98,12 +98,12 @@ impl T: iter::Times {\n         will execute the given function exactly x times. If we assume that \\\n         `x` is an int, this is functionally equivalent to \\\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n-    pure fn times(it: fn() -> bool) {\n-        if self < 0 {\n+    pure fn times(&self, it: fn() -> bool) {\n+        if *self < 0 {\n             fail fmt!(\"The .times method expects a nonnegative number, \\\n                        but found %?\", self);\n         }\n-        let mut i = self;\n+        let mut i = *self;\n         while i > 0 {\n             if !it() { break }\n             i -= 1;"}, {"sha": "644a0fd76b75491d95d4ab0be593bb8f0a5123f5", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -20,46 +20,53 @@ use cmp::{Eq, Ord};\n use self::inst::{IMPL_T, EACH, SIZE_HINT};\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool) { EACH(&self, blk) }\n-    pure fn size_hint() -> Option<uint> { SIZE_HINT(&self) }\n+    pure fn each(&self, blk: fn(v: &A) -> bool) { EACH(self, blk) }\n+    pure fn size_hint(&self) -> Option<uint> { SIZE_HINT(self) }\n }\n \n impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool) { iter::eachi(&self, blk) }\n-    pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n-    pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(&self, move b0, blk)\n+    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n     }\n-    pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n-        iter::position(&self, f)\n+    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n     }\n+    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, move b0, blk)\n+    }\n+    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n+    }\n+    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n+    }\n+\n }\n \n impl<A: Eq> IMPL_T<A>: iter::EqIter<A> {\n-    pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n-    pure fn count(x: &A) -> uint { iter::count(&self, x) }\n+    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> IMPL_T<A>: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(&self, pred)\n+    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n-        iter::map_to_vec(&self, op)\n+    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+        iter::find(self, f)\n     }\n-    pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n-\n-    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(a: A) -> IB)\n-        -> ~[B] {\n-        iter::flat_map_to_vec(&self, op)\n-    }\n-\n-    pure fn find(p: fn(a: A) -> bool) -> Option<A> { iter::find(&self, p) }\n }\n \n impl<A: Copy Ord> IMPL_T<A>: iter::CopyableOrderedIter<A> {\n-    pure fn min() -> A { iter::min(&self) }\n-    pure fn max() -> A { iter::max(&self) }\n+    pure fn min(&self) -> A { iter::min(self) }\n+    pure fn max(&self) -> A { iter::max(self) }\n }\n "}, {"sha": "a9b3401aa6f2dfc6765f523146b9442e6d4e0387", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -23,38 +23,39 @@ use cmp::{Eq, Ord};\n pub type InitOp<T> = &fn(uint) -> T;\n \n pub trait BaseIter<A> {\n-    pure fn each(blk: fn(v: &A) -> bool);\n-    pure fn size_hint() -> Option<uint>;\n+    pure fn each(&self, blk: fn(v: &A) -> bool);\n+    pure fn size_hint(&self) -> Option<uint>;\n }\n \n pub trait ExtendedIter<A> {\n-    pure fn eachi(blk: fn(uint, v: &A) -> bool);\n-    pure fn all(blk: fn(&A) -> bool) -> bool;\n-    pure fn any(blk: fn(&A) -> bool) -> bool;\n-    pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B;\n-    pure fn position(f: fn(&A) -> bool) -> Option<uint>;\n+    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool);\n+    pure fn all(&self, blk: fn(&A) -> bool) -> bool;\n+    pure fn any(&self, blk: fn(&A) -> bool) -> bool;\n+    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B;\n+    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint>;\n+    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B];\n+    pure fn flat_map_to_vec<B,IB: BaseIter<B>>(&self, op: fn(&A) -> IB)\n+        -> ~[B];\n }\n \n pub trait EqIter<A:Eq> {\n-    pure fn contains(x: &A) -> bool;\n-    pure fn count(x: &A) -> uint;\n+    pure fn contains(&self, x: &A) -> bool;\n+    pure fn count(&self, x: &A) -> uint;\n }\n \n pub trait Times {\n-    pure fn times(it: fn() -> bool);\n+    pure fn times(&self, it: fn() -> bool);\n }\n \n pub trait CopyableIter<A:Copy> {\n-    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A];\n-    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B];\n-    pure fn flat_map_to_vec<B:Copy,IB: BaseIter<B>>(op: fn(A) -> IB) -> ~[B];\n-    pure fn to_vec() -> ~[A];\n-    pure fn find(p: fn(a: A) -> bool) -> Option<A>;\n+    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A];\n+    pure fn to_vec(&self) -> ~[A];\n+    pure fn find(&self, p: fn(&A) -> bool) -> Option<A>;\n }\n \n pub trait CopyableOrderedIter<A:Copy Ord> {\n-    pure fn min() -> A;\n-    pure fn max() -> A;\n+    pure fn min(&self) -> A;\n+    pure fn max(&self) -> A;\n }\n \n pub trait CopyableNonstrictIter<A:Copy> {\n@@ -81,11 +82,11 @@ pub trait Buildable<A> {\n      *             onto the sequence being constructed.\n      */\n      static pure fn build_sized(size: uint,\n-                                builder: fn(push: pure fn(v: A))) -> self;\n+                                builder: fn(push: pure fn(A))) -> self;\n }\n \n pub pure fn eachi<A,IA:BaseIter<A>>(self: &IA,\n-                                    blk: fn(uint, v: &A) -> bool) {\n+                                    blk: fn(uint, &A) -> bool) {\n     let mut i = 0;\n     for self.each |a| {\n         if !blk(i, a) { break; }\n@@ -110,30 +111,30 @@ pub pure fn any<A,IA:BaseIter<A>>(self: &IA,\n }\n \n pub pure fn filter_to_vec<A:Copy,IA:BaseIter<A>>(\n-    self: &IA, prd: fn(a: A) -> bool) -> ~[A] {\n+    self: &IA, prd: fn(&A) -> bool) -> ~[A] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n-            if prd(*a) { push(*a); }\n+            if prd(a) { push(*a); }\n         }\n     }\n }\n \n-pub pure fn map_to_vec<A:Copy,B,IA:BaseIter<A>>(self: &IA,\n-                                                op: fn(v: A) -> B)\n+pub pure fn map_to_vec<A,B,IA:BaseIter<A>>(self: &IA,\n+                                           op: fn(&A) -> B)\n     -> ~[B] {\n     do vec::build_sized_opt(self.size_hint()) |push| {\n         for self.each |a| {\n-            push(op(*a));\n+            push(op(a));\n         }\n     }\n }\n \n-pub pure fn flat_map_to_vec<A:Copy,B:Copy,IA:BaseIter<A>,IB:BaseIter<B>>(\n-    self: &IA, op: fn(a: A) -> IB) -> ~[B] {\n+pub pure fn flat_map_to_vec<A,B,IA:BaseIter<A>,IB:BaseIter<B>>(\n+    self: &IA, op: fn(&A) -> IB) -> ~[B] {\n     do vec::build |push| {\n         for self.each |a| {\n-            for op(*a).each |b| {\n-                push(*b);\n+            for op(a).each |&b| {\n+                push(b);\n             }\n         }\n     }\n@@ -222,9 +223,9 @@ pub pure fn max<A:Copy Ord,IA:BaseIter<A>>(self: &IA) -> A {\n }\n \n pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n-                                     p: fn(a: A) -> bool) -> Option<A> {\n+                                   f: fn(&A) -> bool) -> Option<A> {\n     for self.each |i| {\n-        if p(*i) { return Some(*i) }\n+        if f(i) { return Some(*i) }\n     }\n     return None;\n }\n@@ -242,7 +243,7 @@ pub pure fn find<A: Copy,IA:BaseIter<A>>(self: &IA,\n  *             onto the sequence being constructed.\n  */\n #[inline(always)]\n-pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(v: A)))\n+pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(A)))\n     -> B {\n     Buildable::build_sized(4, builder)\n }\n@@ -263,7 +264,7 @@ pub pure fn build<A,B: Buildable<A>>(builder: fn(push: pure fn(v: A)))\n #[inline(always)]\n pub pure fn build_sized_opt<A,B: Buildable<A>>(\n     size: Option<uint>,\n-    builder: fn(push: pure fn(v: A))) -> B {\n+    builder: fn(push: pure fn(A))) -> B {\n \n     Buildable::build_sized(size.get_default(4), builder)\n }"}, {"sha": "1a9bca92d1faa111aba8e763628b30fedbdd0e81", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -92,8 +92,8 @@ impl T: iter::Times {\n         will execute the given function exactly x times. If we assume that \\\n         `x` is an int, this is functionally equivalent to \\\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n-    pure fn times(it: fn() -> bool) {\n-        let mut i = self;\n+    pure fn times(&self, it: fn() -> bool) {\n+        let mut i = *self;\n         while i > 0 {\n             if !it() { break }\n             i -= 1;"}, {"sha": "c091f48728f98324f01f7e1c514bf8c14c57c04f", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 31, "deletions": 28, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -2013,57 +2013,60 @@ pub mod bytes {\n // required in the slice.\n \n impl<A> &[A]: iter::BaseIter<A> {\n-    pub pure fn each(blk: fn(v: &A) -> bool) {\n+    pub pure fn each(&self, blk: fn(v: &A) -> bool) {\n         // FIXME(#2263)---should be able to call each(self, blk)\n-        for each(self) |e| {\n+        for each(*self) |e| {\n             if (!blk(e)) {\n                 return;\n             }\n         }\n     }\n-    pure fn size_hint() -> Option<uint> { Some(len(self)) }\n+    pure fn size_hint(&self) -> Option<uint> { Some(len(*self)) }\n }\n \n impl<A> &[A]: iter::ExtendedIter<A> {\n-    pub pure fn eachi(blk: fn(uint, v: &A) -> bool) {\n-        iter::eachi(&self, blk)\n+    pub pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n+        iter::eachi(self, blk)\n     }\n-    pub pure fn all(blk: fn(&A) -> bool) -> bool { iter::all(&self, blk) }\n-    pub pure fn any(blk: fn(&A) -> bool) -> bool { iter::any(&self, blk) }\n-    pub pure fn foldl<B>(b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(&self, b0, blk)\n+    pub pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::all(self, blk)\n     }\n-    pub pure fn position(f: fn(&A) -> bool) -> Option<uint> {\n-        iter::position(&self, f)\n+    pub pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n+        iter::any(self, blk)\n+    }\n+    pub pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n+        iter::foldl(self, b0, blk)\n+    }\n+    pub pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n+        iter::position(self, f)\n+    }\n+    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n+        iter::map_to_vec(self, op)\n+    }\n+    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n+        -> ~[B] {\n+        iter::flat_map_to_vec(self, op)\n     }\n }\n \n impl<A: Eq> &[A]: iter::EqIter<A> {\n-    pub pure fn contains(x: &A) -> bool { iter::contains(&self, x) }\n-    pub pure fn count(x: &A) -> uint { iter::count(&self, x) }\n+    pub pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n+    pub pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n }\n \n impl<A: Copy> &[A]: iter::CopyableIter<A> {\n-    pure fn filter_to_vec(pred: fn(a: A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(&self, pred)\n+    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n+        iter::filter_to_vec(self, pred)\n     }\n-    pure fn map_to_vec<B>(op: fn(v: A) -> B) -> ~[B] {\n-        iter::map_to_vec(&self, op)\n-    }\n-    pure fn to_vec() -> ~[A] { iter::to_vec(&self) }\n-\n-    pure fn flat_map_to_vec<B:Copy,IB:BaseIter<B>>(op: fn(A) -> IB) -> ~[B] {\n-        iter::flat_map_to_vec(&self, op)\n-    }\n-\n-    pub pure fn find(p: fn(a: A) -> bool) -> Option<A> {\n-        iter::find(&self, p)\n+    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n+    pub pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n+        iter::find(self, f)\n     }\n }\n \n impl<A: Copy Ord> &[A]: iter::CopyableOrderedIter<A> {\n-    pure fn min() -> A { iter::min(&self) }\n-    pure fn max() -> A { iter::max(&self) }\n+    pure fn min(&self) -> A { iter::min(self) }\n+    pure fn max(&self) -> A { iter::max(self) }\n }\n \n impl<A:Copy> &[A] : iter::CopyableNonstrictIter<A> {"}, {"sha": "e9b820d30db087a6ec86b109df3cb1a49b22e7d3", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -70,7 +70,7 @@ fn warn_if_multiple_versions(e: env, diag: span_handler,\n     if crate_cache.len() != 0u {\n         let name = loader::crate_name_from_metas(*crate_cache.last().metas);\n         let (matches, non_matches) =\n-            partition(crate_cache.map_to_vec(|entry| {\n+            partition(crate_cache.map_to_vec(|&entry| {\n                 let othername = loader::crate_name_from_metas(*entry.metas);\n                 if name == othername {\n                     Left(entry)"}, {"sha": "765bf0cfdff4d3eecde5e9edba3757f76cc6afd1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -861,7 +861,7 @@ impl LookupContext {\n         -> Option<method_map_entry>\n     {\n         let relevant_candidates =\n-            candidates.filter_to_vec(|c| self.is_relevant(self_ty, &c));\n+            candidates.filter_to_vec(|c| self.is_relevant(self_ty, c));\n \n         let relevant_candidates = self.merge_candidates(relevant_candidates);\n "}, {"sha": "1a46b924147eea66ba9a456aa1137ecc55508061", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -115,7 +115,7 @@ fn parse_desc_should_parse_simple_doc_attributes() {\n \n pub fn parse_hidden(+attrs: ~[ast::attribute]) -> bool {\n     do doc_metas(attrs).find |meta| {\n-        match attr::get_meta_item_list(meta) {\n+        match attr::get_meta_item_list(*meta) {\n           Some(metas) => {\n             let hiddens = attr::find_meta_items_by_name(metas, ~\"hidden\");\n             vec::is_not_empty(hiddens)"}, {"sha": "b00a2aab69f13d50b970e12b42990fc5b69351c6", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -218,8 +218,8 @@ fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     proto: protocol, visitor: V) -> Tproto {\n \n     // the copy keywords prevent recursive use of dvec\n-    let states = do (copy proto.states).map_to_vec |s| {\n-        let messages = do (copy s.messages).map_to_vec |m| {\n+    let states = do (copy proto.states).map_to_vec |&s| {\n+        let messages = do (copy s.messages).map_to_vec |&m| {\n             let message(name, span, tys, this, next) = m;\n             visitor.visit_message(name, span, tys, this, next)\n         };"}, {"sha": "36d019058ae792f47d177950974fe0316eb8e525", "filename": "src/test/compile-fail/alt-vec-illegal-tail-element-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-element-loan.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -1,7 +1,7 @@\n fn a() -> &int {\n     let vec = [1, 2, 3, 4];\n     let tail = match vec {\n-        [a, ..tail] => &tail[0], //~ ERROR illegal borrow\n+        [_a, ..tail] => &tail[0], //~ ERROR illegal borrow\n         _ => fail ~\"foo\"\n     };\n     move tail"}, {"sha": "29c1d2a78a39384a6d44b23652b0b78507c29a68", "filename": "src/test/compile-fail/alt-vec-illegal-tail-loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-vec-illegal-tail-loan.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -1,7 +1,7 @@\n fn a() -> &[int] {\n     let vec = [1, 2, 3, 4];\n     let tail = match vec {\n-        [a, ..tail] => tail, //~ ERROR illegal borrow\n+        [_a, ..tail] => tail, //~ ERROR illegal borrow\n         _ => fail ~\"foo\"\n     };\n     move tail"}, {"sha": "0a8bd250bb55186ec1bb9d0652b24f07ba23e844", "filename": "src/test/run-pass/issue-2611.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -8,17 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-fast\n-#[legacy_modes];\n-\n use iter::BaseIter;\n \n trait FlatMapToVec<A> {\n-  fn flat_map_to_vec<B:Copy, IB:BaseIter<B>>(op: fn(+a: A) -> IB) -> ~[B];\n+  fn flat_map_to_vec<B, IB:BaseIter<B>>(op: fn(&A) -> IB) -> ~[B];\n }\n \n impl<A:Copy> BaseIter<A>: FlatMapToVec<A> {\n-   fn flat_map_to_vec<B:Copy, IB:BaseIter<B>>(op: fn(+a: A) -> IB) -> ~[B] {\n+   fn flat_map_to_vec<B, IB:BaseIter<B>>(op: fn(&A) -> IB) -> ~[B] {\n      iter::flat_map_to_vec(&self, op)\n    }\n }"}, {"sha": "2177066a0337426fe3d1cea8c6b29b6ee3cfc740", "filename": "src/test/run-pass/iter-flat-map-to-vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b46e25bdc8f4c0ac702a3197ef61da2786bb917c/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiter-flat-map-to-vec.rs?ref=b46e25bdc8f4c0ac702a3197ef61da2786bb917c", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n // xfail-test -- flat_map_to_vec currently disable\n+fn repeat(x: &uint) -> ~[uint] { ~[x, x] }\n \n-fn repeat(&&x: uint) -> ~[uint] { ~[x, x] }\n-\n-fn incd_if_even(&&x: uint) -> option<uint> {\n+fn incd_if_even(x: &uint) -> option<uint> {\n     if (x % 2u) == 0u {some(x + 1u)} else {none}\n }\n \n@@ -28,4 +27,4 @@ fn main() {\n     assert none.flat_map_to_vec(incd_if_even) == ~[];\n     assert some(1u).flat_map_to_vec(incd_if_even) == ~[];\n     assert some(2u).flat_map_to_vec(incd_if_even) == ~[3u];\n-}\n\\ No newline at end of file\n+}"}]}