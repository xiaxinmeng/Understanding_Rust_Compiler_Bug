{"sha": "adce35acd481d6ecc087c5957601b0a680e936a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkY2UzNWFjZDQ4MWQ2ZWNjMDg3YzU5NTc2MDFiMGE2ODBlOTM2YTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-10T19:55:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-10T21:35:12Z"}, "message": "rustc: Use polymorphic logging", "tree": {"sha": "372b8b1a985ce9ac10bffaf159867743ad22c3ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/372b8b1a985ce9ac10bffaf159867743ad22c3ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adce35acd481d6ecc087c5957601b0a680e936a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adce35acd481d6ecc087c5957601b0a680e936a8", "html_url": "https://github.com/rust-lang/rust/commit/adce35acd481d6ecc087c5957601b0a680e936a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adce35acd481d6ecc087c5957601b0a680e936a8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ae704ff2fc419c162527345bad63dd06394afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ae704ff2fc419c162527345bad63dd06394afe", "html_url": "https://github.com/rust-lang/rust/commit/40ae704ff2fc419c162527345bad63dd06394afe"}], "stats": {"total": 247, "additions": 117, "deletions": 130}, "files": [{"sha": "fc84dd4fefee7a3a83b4778a80557edd04db5712", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=adce35acd481d6ecc087c5957601b0a680e936a8", "patch": "@@ -26,11 +26,6 @@ import lib::llvm::llvm::TypeRef;\n \n type upcalls =\n     {grow_task: ValueRef,\n-     log_int: ValueRef,\n-     log_float: ValueRef,\n-     log_double: ValueRef,\n-     log_str: ValueRef,\n-     log_istr: ValueRef,\n      trace_word: ValueRef,\n      trace_str: ValueRef,\n      new_port: ValueRef,\n@@ -67,7 +62,8 @@ type upcalls =\n      ivec_spill: ValueRef,\n      ivec_resize_shared: ValueRef,\n      ivec_spill_shared: ValueRef,\n-     cmp_type: ValueRef};\n+     cmp_type: ValueRef,\n+     log_type: ValueRef};\n \n fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n                    taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n@@ -89,11 +85,6 @@ fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n \n     let empty_vec: [TypeRef] = ~[];\n     ret @{grow_task: dv(\"grow_task\", ~[T_size_t()]),\n-          log_int: dv(\"log_int\", ~[T_i32(), T_i32()]),\n-          log_float: dv(\"log_float\", ~[T_i32(), T_f32()]),\n-          log_double: dv(\"log_double\", ~[T_i32(), T_ptr(T_f64())]),\n-          log_str: dv(\"log_str\", ~[T_i32(), T_ptr(T_str())]),\n-          log_istr: dv(\"log_istr\", ~[T_i32(), T_ptr(T_ivec(T_i8()))]),\n           trace_word: dv(\"trace_word\", ~[T_int()]),\n           trace_str: dv(\"trace_str\", ~[T_ptr(T_i8())]),\n           new_port: d(\"new_port\", ~[T_size_t()], T_opaque_port_ptr()),\n@@ -159,6 +150,10 @@ fn declare_upcalls(tn: type_names, tydesc_type: TypeRef,\n               dr(\"cmp_type\", ~[T_ptr(T_i1()), taskptr_type,\n                  T_ptr(tydesc_type), T_ptr(T_ptr(tydesc_type)),\n                  T_ptr(T_i8()), T_ptr(T_i8()), T_i8()],\n+                 T_void()),\n+          log_type:\n+              dr(\"log_type\", ~[taskptr_type, T_ptr(tydesc_type),\n+                 T_ptr(T_i8()), T_i32()],\n                  T_void())};\n }\n //"}, {"sha": "6167bbcbe73250d1e1d98275f8a79b7b3b4e8b05", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 10, "deletions": 40, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=adce35acd481d6ecc087c5957601b0a680e936a8", "patch": "@@ -5190,48 +5190,18 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n     let sub = trans_expr(log_cx, e);\n     let e_ty = ty::expr_ty(bcx_tcx(cx), e);\n     let log_bcx = sub.bcx;\n-    if ty::type_is_fp(bcx_tcx(cx), e_ty) {\n-        let tr: TypeRef;\n-        let is32bit: bool = false;\n-        alt ty::struct(bcx_tcx(cx), e_ty) {\n-          ty::ty_machine(ast::ty_f32.) { tr = T_f32(); is32bit = true; }\n-          ty::ty_machine(ast::ty_f64.) { tr = T_f64(); }\n-          _ { tr = T_float(); }\n-        }\n-        if is32bit {\n-            log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_float,\n-                               ~[log_bcx.fcx.lltaskptr, C_int(lvl), sub.val]);\n-        } else {\n-            // FIXME: Eliminate this level of indirection.\n \n-            let tmp = alloca(log_bcx, tr);\n-            sub.bcx.build.Store(sub.val, tmp);\n-            log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_double,\n-                               ~[log_bcx.fcx.lltaskptr, C_int(lvl), tmp]);\n-        }\n-    } else if (ty::type_is_integral(bcx_tcx(cx), e_ty) ||\n-                   ty::type_is_bool(bcx_tcx(cx), e_ty)) {\n-        // FIXME: Handle signedness properly.\n-\n-        let llintval =\n-            int_cast(log_bcx, T_int(), val_ty(sub.val), sub.val, false);\n-        log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_int,\n-                           ~[log_bcx.fcx.lltaskptr, C_int(lvl), llintval]);\n-    } else {\n-        alt ty::struct(bcx_tcx(cx), e_ty) {\n-          ty::ty_str. {\n-            log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_str,\n-                               ~[log_bcx.fcx.lltaskptr, C_int(lvl), sub.val]);\n-          }\n-          _ {\n-            // FIXME: Support these types.\n+    let ti = none[@tydesc_info];\n+    let r = get_tydesc(log_bcx, e_ty, false, ti);\n+    log_bcx = r.bcx;\n+\n+    // Call the polymorphic log function.\n+    let llvalptr = spill_if_immediate(log_bcx, sub.val, e_ty);\n+    let llval_i8 = log_bcx.build.PointerCast(llvalptr, T_ptr(T_i8()));\n+\n+    log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_type,\n+                       ~[log_bcx.fcx.lltaskptr, r.val, llval_i8, C_int(lvl)]);\n \n-            bcx_ccx(cx).sess.span_fatal(e.span,\n-                                        \"log called on unsupported type \" +\n-                                            ty_to_str(bcx_tcx(cx), e_ty));\n-          }\n-        }\n-    }\n     log_bcx = trans_block_cleanups(log_bcx, log_cx);\n     log_bcx.build.Br(after_cx.llbb);\n     ret rslt(after_cx, C_nil());"}, {"sha": "80590466c031c1f883743afe082bda6dd929121d", "filename": "src/comp/middle/trans_dps.rs", "status": "modified", "additions": 10, "deletions": 54, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_dps.rs?ref=adce35acd481d6ecc087c5957601b0a680e936a8", "patch": "@@ -343,36 +343,6 @@ fn trans_log(cx: &@block_ctxt, sp: &span, level: int, expr: &@ast::expr) ->\n         ret lllevelptr;\n     }\n \n-    tag upcall_style { us_imm; us_imm_i32_zext; us_alias; us_alias_istr; }\n-    fn get_upcall(ccx: &@crate_ctxt, sp: &span, t: ty::t) ->\n-       {val: ValueRef, st: upcall_style} {\n-        alt ty::struct(ccx_tcx(ccx), t) {\n-          ty::ty_machine(ast::ty_f32.) {\n-            ret {val: ccx.upcalls.log_float, st: us_imm};\n-          }\n-          ty::ty_machine(ast::ty_f64.) | ty::ty_float. {\n-            // TODO: We have to spill due to legacy calling conventions that\n-            // should probably be modernized.\n-            ret {val: ccx.upcalls.log_double, st: us_alias};\n-          }\n-          ty::ty_bool. | ty::ty_machine(ast::ty_i8.) |\n-          ty::ty_machine(ast::ty_i16.) | ty::ty_machine(ast::ty_u8.) |\n-          ty::ty_machine(ast::ty_u16.) {\n-            ret {val: ccx.upcalls.log_int, st: us_imm_i32_zext};\n-          }\n-          ty::ty_int. | ty::ty_machine(ast::ty_i32.) |\n-          ty::ty_machine(ast::ty_u32.) {\n-            ret {val: ccx.upcalls.log_int, st: us_imm};\n-          }\n-          ty::ty_istr. { ret {val: ccx.upcalls.log_istr, st: us_alias_istr}; }\n-          _ {\n-            ccx.sess.span_unimpl(sp,\n-                                 \"logging for values of type \" +\n-                                     ppaux::ty_to_str(ccx_tcx(ccx), t));\n-          }\n-        }\n-    }\n-\n     let bcx = cx;\n \n     let lllevelptr = trans_log_level(bcx_lcx(bcx));\n@@ -386,34 +356,20 @@ fn trans_log(cx: &@block_ctxt, sp: &span, level: int, expr: &@ast::expr) ->\n     bcx.build.CondBr(should_log, log_bcx.llbb, next_bcx.llbb);\n \n     let expr_t = ty::expr_ty(bcx_tcx(log_bcx), expr);\n-    let r = get_upcall(bcx_ccx(bcx), sp, expr_t);\n-    let llupcall = r.val;\n-    let style = r.st;\n-\n-    let arg_dest;\n-    alt style {\n-      us_imm. | us_imm_i32_zext. {\n-        arg_dest = dest_imm(bcx_tcx(log_bcx), expr_t);\n-      }\n-      us_alias. | us_alias_istr. {\n-        arg_dest = dest_alias(bcx_tcx(log_bcx), expr_t);\n-      }\n-    }\n+    let arg_dest = dest_alias(bcx_tcx(log_bcx), expr_t);\n     log_bcx = trans_expr(log_bcx, arg_dest, expr);\n \n     let llarg = dest_llval(arg_dest);\n-    alt style {\n-      us_imm. | us_alias. {/* no-op */ }\n-      us_imm_i32_zext. { llarg = log_bcx.build.ZExt(llarg, tc::T_i32()); }\n-      us_alias_istr. {\n-        llarg =\n-            log_bcx.build.PointerCast(llarg,\n-                                      tc::T_ptr(tc::T_ivec(tc::T_i8())));\n-      }\n-    }\n+    let llarg_i8 = bcx.build.PointerCast(llarg, T_ptr(T_i8()));\n+\n+    let ti = none;\n+    let r2 = trans::get_tydesc(bcx, expr_t, false, ti);\n+    bcx = r2.bcx;\n+    let lltydesc = r2.val;\n \n-    log_bcx.build.Call(llupcall,\n-                       ~[bcx_fcx(bcx).lltaskptr, tc::C_int(level), llarg]);\n+    log_bcx.build.Call(bcx_ccx(log_bcx).upcalls.log_type,\n+                       ~[bcx_fcx(bcx).lltaskptr, lltydesc, llarg_i8,\n+                         tc::C_int(level)]);\n \n     log_bcx =\n         trans::trans_block_cleanups(log_bcx, tc::find_scope_cx(log_bcx));"}, {"sha": "a32b3c296eb8efabf89dcc41db3132810884ac76", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 90, "deletions": 25, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=adce35acd481d6ecc087c5957601b0a680e936a8", "patch": "@@ -3,6 +3,7 @@\n \n #include <algorithm>\n #include <iostream>\n+#include <sstream>\n #include <utility>\n #include <cassert>\n #include <cstdio>\n@@ -76,20 +77,6 @@ align_to(T size, size_t alignment) {\n     return x;\n }\n \n-template<typename T>\n-static inline T\n-bump_dp(uint8_t *&dp) {\n-    T x = *((T *)dp);\n-    dp += sizeof(T);\n-    return x;\n-}\n-\n-template<typename T>\n-static inline T\n-get_dp(uint8_t *dp) {\n-    return *((T *)dp);\n-}\n-\n // Utility classes\n \n struct size_align {\n@@ -220,6 +207,52 @@ get_dp(ptr_pair &ptr) {\n     return data;\n }\n \n+// Pointer wrappers for data traversals\n+\n+class ptr {\n+private:\n+    uint8_t *p;\n+\n+public:\n+    template<typename T>\n+    struct data { typedef T t; };\n+\n+    ptr(uint8_t *in_p)\n+    : p(in_p) {}\n+\n+    ptr(uintptr_t in_p)\n+    : p((uint8_t *)in_p) {}\n+\n+    inline ptr operator+(const size_t amount) const {\n+        return make(p + amount);\n+    }\n+    inline ptr &operator+=(const size_t amount) { p += amount; return *this; }\n+\n+    template<typename T>\n+    inline operator T *() { return (T *)p; }\n+\n+    inline operator uintptr_t() { return (uintptr_t)p; }\n+\n+    static inline ptr make(uint8_t *in_p) {\n+        ptr self(in_p);\n+        return self;\n+    }\n+};\n+\n+template<typename T>\n+static inline T\n+bump_dp(ptr &dp) {\n+    T x = *((T *)dp);\n+    dp += sizeof(T);\n+    return x;\n+}\n+\n+template<typename T>\n+static inline T\n+get_dp(ptr dp) {\n+    return *((T *)dp);\n+}\n+\n \n // Contexts\n \n@@ -852,8 +885,8 @@ class data : public ctxt< data<T,U> > {\n protected:\n     void walk_variant(bool align, tag_info &tinfo, uint32_t variant);\n \n-    static std::pair<uint8_t *,uint8_t *> get_evec_data_range(uint8_t *dp);\n-    static std::pair<uint8_t *,uint8_t *> get_ivec_data_range(uint8_t *dp);\n+    static std::pair<uint8_t *,uint8_t *> get_evec_data_range(ptr dp);\n+    static std::pair<uint8_t *,uint8_t *> get_ivec_data_range(ptr dp);\n     static std::pair<ptr_pair,ptr_pair> get_evec_data_range(ptr_pair &dp);\n     static std::pair<ptr_pair,ptr_pair> get_ivec_data_range(ptr_pair &dp);\n \n@@ -924,14 +957,14 @@ data<T,U>::walk_variant(bool align, tag_info &tinfo, uint32_t variant_id) {\n \n template<typename T,typename U>\n std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_evec_data_range(uint8_t *dp) {\n+data<T,U>::get_evec_data_range(ptr dp) {\n     rust_vec *vp = bump_dp<rust_vec *>(dp);\n     return std::make_pair(vp->data, vp->data + vp->fill);\n }\n \n template<typename T,typename U>\n std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_ivec_data_range(uint8_t *dp) {\n+data<T,U>::get_ivec_data_range(ptr dp) {\n     size_t fill = bump_dp<size_t>(dp);\n     bump_dp<size_t>(dp);    // Skip over alloc.\n     uint8_t *payload_dp = dp;\n@@ -1009,6 +1042,8 @@ data<T,U>::walk_tag(bool align, tag_info &tinfo) {\n         tag_variant = 0;\n \n     static_cast<T *>(this)->walk_tag(align, tinfo, tag_variant);\n+\n+    dp = end_dp;\n }\n \n \n@@ -1187,13 +1222,20 @@ cmp::walk_variant(bool align, tag_info &tinfo, uint32_t variant_id,\n \n // Polymorphic logging, for convenience\n \n-class log : public data<log,uint8_t *> {\n-    friend class data<log,uint8_t *>;\n+class log : public data<log,ptr> {\n+    friend class data<log,ptr>;\n \n private:\n     std::ostream &out;\n     bool in_string;\n \n+    log(log &other,\n+        const uint8_t *in_sp,\n+        const type_param *in_params,\n+        const rust_shape_tables *in_tables)\n+    : data<log,ptr>(other.task, in_sp, in_params, in_tables, other.dp),\n+      out(other.out) {}\n+\n     void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n         walk_vec(align, is_pod, get_evec_data_range(dp));\n     }\n@@ -1202,8 +1244,14 @@ class log : public data<log,uint8_t *> {\n         walk_vec(align, is_pod, get_ivec_data_range(dp));\n     }\n \n-    void walk_vec(bool align, bool is_pod,\n-                  const std::pair<uint8_t *,uint8_t *> &data);\n+    void walk_tag(bool align, tag_info &tinfo, uint32_t tag_variant) {\n+        out << \"tag\" << tag_variant;\n+        // TODO: Print insides.\n+    }\n+\n+    void walk_subcontext(bool align, log &sub) { sub.walk(align); }\n+\n+    void walk_vec(bool align, bool is_pod, const std::pair<ptr,ptr> &data);\n \n     template<typename T>\n     void walk_number() { out << get_dp<T>(dp); }\n@@ -1215,13 +1263,12 @@ class log : public data<log,uint8_t *> {\n         const rust_shape_tables *in_tables,\n         uint8_t *in_data,\n         std::ostream &in_out)\n-    : data<log,uint8_t *>(in_task, in_sp, in_params, in_tables, in_data),\n+    : data<log,ptr>(in_task, in_sp, in_params, in_tables, in_data),\n       out(in_out) {}\n };\n \n void\n-log::walk_vec(bool align, bool is_pod,\n-              const std::pair<uint8_t *,uint8_t *> &data) {\n+log::walk_vec(bool align, bool is_pod, const std::pair<ptr,ptr> &data) {\n     // TODO: Check to see whether this is a string (contains u8). If so,\n     // write the vector \"\"-style; otherwise [ ... , ... ] style.\n }\n@@ -1245,3 +1292,21 @@ upcall_cmp_type(int8_t *result, rust_task *task, type_desc *tydesc,\n     }\n }\n \n+extern \"C\" void\n+upcall_log_type(rust_task *task, type_desc *tydesc, uint8_t *data,\n+                uint32_t level) {\n+    if (task->sched->log_lvl < level)\n+        return;     // TODO: Don't evaluate at all?\n+\n+    shape::arena arena;\n+    shape::type_param *params = shape::type_param::make(tydesc, arena);\n+\n+    std::stringstream ss;\n+    shape::log log(task, tydesc->shape, params, tydesc->shape_tables, data,\n+                   ss);\n+\n+    log.walk(true);\n+\n+    task->sched->log(task, level, \"%s\", ss.str().c_str());\n+}\n+"}, {"sha": "87c86c129b88e0d4bbb36a1745a9e6d881aaba63", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/adce35acd481d6ecc087c5957601b0a680e936a8/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=adce35acd481d6ecc087c5957601b0a680e936a8", "patch": "@@ -97,6 +97,7 @@ upcall_log_float\n upcall_log_int\n upcall_log_istr\n upcall_log_str\n+upcall_log_type\n upcall_malloc\n upcall_mark\n upcall_new_chan"}]}