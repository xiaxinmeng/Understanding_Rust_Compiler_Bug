{"sha": "554efc013481b45b8336299074a86491e4ef436e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NGVmYzAxMzQ4MWI0NWI4MzM2Mjk5MDc0YTg2NDkxZTRlZjQzNmU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-31T05:48:36Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-07-31T14:11:35Z"}, "message": "last of the emphasis cleanup", "tree": {"sha": "0c9841cc37ac9f1736aa3469e685b4f1ce7ddb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c9841cc37ac9f1736aa3469e685b4f1ce7ddb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/554efc013481b45b8336299074a86491e4ef436e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/554efc013481b45b8336299074a86491e4ef436e", "html_url": "https://github.com/rust-lang/rust/commit/554efc013481b45b8336299074a86491e4ef436e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/554efc013481b45b8336299074a86491e4ef436e/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b33a1e2de89c8b1c302da245b224653e8041d67", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b33a1e2de89c8b1c302da245b224653e8041d67", "html_url": "https://github.com/rust-lang/rust/commit/7b33a1e2de89c8b1c302da245b224653e8041d67"}], "stats": {"total": 173, "additions": 89, "deletions": 84}, "files": [{"sha": "28b52e9bb3b79154a4e30726eddf91aa6dee049d", "filename": "src/doc/tarpl/races.md", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fraces.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -12,11 +12,13 @@ it's impossible to alias a mutable reference, so it's impossible to perform a\n data race. Interior mutability makes this more complicated, which is largely why\n we have the Send and Sync traits (see below).\n \n-However Rust *does not* prevent general race conditions. This is\n-pretty fundamentally impossible, and probably honestly undesirable. Your hardware\n-is racy, your OS is racy, the other programs on your computer are racy, and the\n-world this all runs in is racy. Any system that could genuinely claim to prevent\n-*all* race conditions would be pretty awful to use, if not just incorrect.\n+**However Rust does not prevent general race conditions.**\n+\n+This is pretty fundamentally impossible, and probably honestly undesirable. Your\n+hardware is racy, your OS is racy, the other programs on your computer are racy,\n+and the world this all runs in is racy. Any system that could genuinely claim to\n+prevent *all* race conditions would be pretty awful to use, if not just\n+incorrect.\n \n So it's perfectly \"fine\" for a Safe Rust program to get deadlocked or do\n something incredibly stupid with incorrect synchronization. Obviously such a\n@@ -46,7 +48,7 @@ thread::spawn(move || {\n });\n \n // Index with the value loaded from the atomic. This is safe because we\n-// read the atomic memory only once, and then pass a *copy* of that value\n+// read the atomic memory only once, and then pass a copy of that value\n // to the Vec's indexing implementation. This indexing will be correctly\n // bounds checked, and there's no chance of the value getting changed\n // in the middle. However our program may panic if the thread we spawned\n@@ -75,7 +77,7 @@ thread::spawn(move || {\n \n if idx.load(Ordering::SeqCst) < data.len() {\n     unsafe {\n-        // Incorrectly loading the idx *after* we did the bounds check.\n+        // Incorrectly loading the idx after we did the bounds check.\n         // It could have changed. This is a race condition, *and dangerous*\n         // because we decided to do `get_unchecked`, which is `unsafe`.\n         println!(\"{}\", data.get_unchecked(idx.load(Ordering::SeqCst)));"}, {"sha": "9073495c517670594e3baadd90eb49b8f3110a3b", "filename": "src/doc/tarpl/repr-rust.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Frepr-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Frepr-rust.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -70,7 +70,7 @@ struct B {\n Rust *does* guarantee that two instances of A have their data laid out in\n exactly the same way. However Rust *does not* guarantee that an instance of A\n has the same field ordering or padding as an instance of B (in practice there's\n-no *particular* reason why they wouldn't, other than that its not currently\n+no particular reason why they wouldn't, other than that its not currently\n guaranteed).\n \n With A and B as written, this is basically nonsensical, but several other\n@@ -88,9 +88,9 @@ struct Foo<T, U> {\n ```\n \n Now consider the monomorphizations of `Foo<u32, u16>` and `Foo<u16, u32>`. If\n-Rust lays out the fields in the order specified, we expect it to *pad* the\n-values in the struct to satisfy their *alignment* requirements. So if Rust\n-didn't reorder fields, we would expect Rust to produce the following:\n+Rust lays out the fields in the order specified, we expect it to pad the\n+values in the struct to satisfy their alignment requirements. So if Rust\n+didn't reorder fields, we would expect it to produce the following:\n \n ```rust,ignore\n struct Foo<u16, u32> {\n@@ -112,7 +112,7 @@ The latter case quite simply wastes space. An optimal use of space therefore\n requires different monomorphizations to have *different field orderings*.\n \n **Note: this is a hypothetical optimization that is not yet implemented in Rust\n-**1.0\n+1.0**\n \n Enums make this consideration even more complicated. Naively, an enum such as:\n \n@@ -128,8 +128,8 @@ would be laid out as:\n \n ```rust\n struct FooRepr {\n-    data: u64, // this is *really* either a u64, u32, or u8 based on `tag`\n-    tag: u8, // 0 = A, 1 = B, 2 = C\n+    data: u64, // this is either a u64, u32, or u8 based on `tag`\n+    tag: u8,   // 0 = A, 1 = B, 2 = C\n }\n ```\n "}, {"sha": "2f15b7050e362018f3701b63805e673fea109806", "filename": "src/doc/tarpl/safe-unsafe-meaning.md", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsafe-unsafe-meaning.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -5,7 +5,7 @@ So what's the relationship between Safe and Unsafe Rust? How do they interact?\n Rust models the separation between Safe and Unsafe Rust with the `unsafe`\n keyword, which can be thought as a sort of *foreign function interface* (FFI)\n between Safe and Unsafe Rust. This is the magic behind why we can say Safe Rust\n-is a safe language: all the scary unsafe bits are relegated *exclusively* to FFI\n+is a safe language: all the scary unsafe bits are relegated exclusively to FFI\n *just like every other safe language*.\n \n However because one language is a subset of the other, the two can be cleanly\n@@ -61,50 +61,50 @@ The need for unsafe traits boils down to the fundamental property of safe code:\n **No matter how completely awful Safe code is, it can't cause Undefined\n Behaviour.**\n \n-This means that Unsafe, **the royal vanguard of Undefined Behaviour**, has to be\n-*super paranoid* about generic safe code. Unsafe is free to trust *specific* safe\n-code (or else you would degenerate into infinite spirals of paranoid despair).\n-It is generally regarded as ok to trust the standard library to be correct, as\n-`std` is effectively an extension of the language (and you *really* just have\n-to trust the language). If `std` fails to uphold the guarantees it declares,\n-then it's basically a language bug.\n+This means that Unsafe Rust, **the royal vanguard of Undefined Behaviour**, has to be\n+*super paranoid* about generic safe code. To be clear, Unsafe Rust is totally free to trust\n+specific safe code. Anything else would degenerate into infinite spirals of\n+paranoid despair. In particular it's generally regarded as ok to trust the standard library\n+to be correct. `std` is effectively an extension of the language, and you\n+really just have to trust the language. If `std` fails to uphold the\n+guarantees it declares, then it's basically a language bug.\n \n That said, it would be best to minimize *needlessly* relying on properties of\n concrete safe code. Bugs happen! Of course, I must reinforce that this is only\n a concern for Unsafe code. Safe code can blindly trust anyone and everyone\n as far as basic memory-safety is concerned.\n \n On the other hand, safe traits are free to declare arbitrary contracts, but because\n-implementing them is Safe, Unsafe can't trust those contracts to actually\n+implementing them is safe, unsafe code can't trust those contracts to actually\n be upheld. This is different from the concrete case because *anyone* can\n randomly implement the interface. There is something fundamentally different\n-about trusting a *particular* piece of code to be correct, and trusting *all the\n+about trusting a particular piece of code to be correct, and trusting *all the\n code that will ever be written* to be correct.\n \n For instance Rust has `PartialOrd` and `Ord` traits to try to differentiate\n between types which can \"just\" be compared, and those that actually implement a\n-*total* ordering. Pretty much every API that wants to work with data that can be\n-compared *really* wants Ord data. For instance, a sorted map like BTreeMap\n+total ordering. Pretty much every API that wants to work with data that can be\n+compared wants Ord data. For instance, a sorted map like BTreeMap\n *doesn't even make sense* for partially ordered types. If you claim to implement\n Ord for a type, but don't actually provide a proper total ordering, BTreeMap will\n get *really confused* and start making a total mess of itself. Data that is\n inserted may be impossible to find!\n \n But that's okay. BTreeMap is safe, so it guarantees that even if you give it a\n-*completely* garbage Ord implementation, it will still do something *safe*. You\n-won't start reading uninitialized memory or unallocated memory. In fact, BTreeMap\n+completely garbage Ord implementation, it will still do something *safe*. You\n+won't start reading uninitialized or unallocated memory. In fact, BTreeMap\n manages to not actually lose any of your data. When the map is dropped, all the\n destructors will be successfully called! Hooray!\n \n-However BTreeMap is implemented using a modest spoonful of Unsafe (most collections\n-are). That means that it is not necessarily *trivially true* that a bad Ord\n-implementation will make BTreeMap behave safely. Unsafe must be sure not to rely\n-on Ord *where safety is at stake*. Ord is provided by Safe, and safety is not\n-Safe's responsibility to uphold.\n+However BTreeMap is implemented using a modest spoonful of Unsafe Rust (most collections\n+are). That means that it's not necessarily *trivially true* that a bad Ord\n+implementation will make BTreeMap behave safely. BTreeMap must be sure not to rely\n+on Ord *where safety is at stake*. Ord is provided by safe code, and safety is not\n+safe code's responsibility to uphold.\n \n-But wouldn't it be grand if there was some way for Unsafe to trust *some* trait\n+But wouldn't it be grand if there was some way for Unsafe to trust some trait\n contracts *somewhere*? This is the problem that unsafe traits tackle: by marking\n-*the trait itself* as unsafe *to implement*, Unsafe can trust the implementation\n+*the trait itself* as unsafe to implement, unsafe code can trust the implementation\n to uphold the trait's contract. Although the trait implementation may be\n incorrect in arbitrary other ways.\n \n@@ -126,7 +126,7 @@ But it's probably not the implementation you want.\n \n Rust has traditionally avoided making traits unsafe because it makes Unsafe\n pervasive, which is not desirable. Send and Sync are unsafe is because thread\n-safety is a *fundamental property* that Unsafe cannot possibly hope to defend\n+safety is a *fundamental property* that unsafe code cannot possibly hope to defend\n against in the same way it would defend against a bad Ord implementation. The\n only way to possibly defend against thread-unsafety would be to *not use\n threading at all*. Making every load and store atomic isn't even sufficient,\n@@ -135,10 +135,10 @@ in memory. For instance, the pointer and capacity of a Vec must be in sync.\n \n Even concurrent paradigms that are traditionally regarded as Totally Safe like\n message passing implicitly rely on some notion of thread safety -- are you\n-really message-passing if you pass a *pointer*? Send and Sync therefore require\n-some *fundamental* level of trust that Safe code can't provide, so they must be\n+really message-passing if you pass a pointer? Send and Sync therefore require\n+some fundamental level of trust that Safe code can't provide, so they must be\n unsafe to implement. To help obviate the pervasive unsafety that this would\n-introduce, Send (resp. Sync) is *automatically* derived for all types composed only\n+introduce, Send (resp. Sync) is automatically derived for all types composed only\n of Send (resp. Sync) values. 99% of types are Send and Sync, and 99% of those\n never actually say it (the remaining 1% is overwhelmingly synchronization\n primitives)."}, {"sha": "af8fb43f2e9133fcfeea1914347710732d4938e0", "filename": "src/doc/tarpl/send-and-sync.md", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsend-and-sync.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -8,20 +8,19 @@ captures this with through the `Send` and `Sync` traits.\n * A type is Send if it is safe to send it to another thread. A type is Sync if\n * it is safe to share between threads (`&T` is Send).\n \n-Send and Sync are *very* fundamental to Rust's concurrency story. As such, a\n+Send and Sync are fundamental to Rust's concurrency story. As such, a\n substantial amount of special tooling exists to make them work right. First and\n-foremost, they're *unsafe traits*. This means that they are unsafe *to\n-implement*, and other unsafe code can *trust* that they are correctly\n+foremost, they're [unsafe traits][]. This means that they are unsafe to\n+implement, and other unsafe code can  that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic\n properties an implementor should have. Incorrectly implementing Send or Sync can\n cause Undefined Behaviour.\n \n-Send and Sync are also what Rust calls *opt-in builtin traits*. This means that,\n-unlike every other trait, they are *automatically* derived: if a type is\n-composed entirely of Send or Sync types, then it is Send or Sync. Almost all\n-primitives are Send and Sync, and as a consequence pretty much all types you'll\n-ever interact with are Send and Sync.\n+Send and Sync are also automatically derived traits. This means that, unlike\n+every other trait, if a type is composed entirely of Send or Sync types, then it\n+is Send or Sync. Almost all primitives are Send and Sync, and as a consequence\n+pretty much all types you'll ever interact with are Send and Sync.\n \n Major exceptions include:\n \n@@ -37,13 +36,12 @@ sense, one could argue that it would be \"fine\" for them to be marked as thread\n safe.\n \n However it's important that they aren't thread safe to prevent types that\n-*contain them* from being automatically marked as thread safe. These types have\n+contain them from being automatically marked as thread safe. These types have\n non-trivial untracked ownership, and it's unlikely that their author was\n necessarily thinking hard about thread safety. In the case of Rc, we have a nice\n-example of a type that contains a `*mut` that is *definitely* not thread safe.\n+example of a type that contains a `*mut` that is definitely not thread safe.\n \n-Types that aren't automatically derived can *opt-in* to Send and Sync by simply\n-implementing them:\n+Types that aren't automatically derived can simply implement them if desired:\n \n ```rust\n struct MyBox(*mut u8);\n@@ -52,12 +50,13 @@ unsafe impl Send for MyBox {}\n unsafe impl Sync for MyBox {}\n ```\n \n-In the *incredibly rare* case that a type is *inappropriately* automatically\n-derived to be Send or Sync, then one can also *unimplement* Send and Sync:\n+In the *incredibly rare* case that a type is inappropriately automatically\n+derived to be Send or Sync, then one can also unimplement Send and Sync:\n \n ```rust\n #![feature(optin_builtin_traits)]\n \n+// I have some magic semantics for some synchronization primitive!\n struct SpecialThreadToken(u8);\n \n impl !Send for SpecialThreadToken {}\n@@ -77,3 +76,5 @@ largely behave like an `&` or `&mut` into the collection.\n \n TODO: better explain what can or can't be Send or Sync. Sufficient to appeal\n only to data races?\n+\n+[unsafe traits]: safe-unsafe-meaning.html"}, {"sha": "3c57297f323cc7ad69f2545c148886a5e1d1a50a", "filename": "src/doc/tarpl/subtyping.md", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fsubtyping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fsubtyping.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -1,14 +1,14 @@\n % Subtyping and Variance\n \n Although Rust doesn't have any notion of structural inheritance, it *does*\n-include subtyping. In Rust, subtyping derives entirely from *lifetimes*. Since\n+include subtyping. In Rust, subtyping derives entirely from lifetimes. Since\n lifetimes are scopes, we can partially order them based on the *contains*\n (outlives) relationship. We can even express this as a generic bound.\n \n-Subtyping on lifetimes in terms of that relationship: if `'a: 'b` (\"a contains\n+Subtyping on lifetimes is in terms of that relationship: if `'a: 'b` (\"a contains\n b\" or \"a outlives b\"), then `'a` is a subtype of `'b`. This is a large source of\n confusion, because it seems intuitively backwards to many: the bigger scope is a\n-*sub type* of the smaller scope.\n+*subtype* of the smaller scope.\n \n This does in fact make sense, though. The intuitive reason for this is that if\n you expect an `&'a u8`, then it's totally fine for me to hand you an `&'static\n@@ -72,7 +72,7 @@ to be able to pass `&&'static str` where an `&&'a str` is expected. The\n additional level of indirection does not change the desire to be able to pass\n longer lived things where shorted lived things are expected.\n \n-However this logic *does not* apply to `&mut`. To see why `&mut` should\n+However this logic doesn't apply to `&mut`. To see why `&mut` should\n be invariant over T, consider the following code:\n \n ```rust,ignore\n@@ -109,7 +109,7 @@ between `'a` and T is that `'a` is a property of the reference itself,\n while T is something the reference is borrowing. If you change T's type, then\n the source still remembers the original type. However if you change the\n lifetime's type, no one but the reference knows this information, so it's fine.\n-Put another way, `&'a mut T` owns `'a`, but only *borrows* T.\n+Put another way: `&'a mut T` owns `'a`, but only *borrows* T.\n \n `Box` and `Vec` are interesting cases because they're variant, but you can\n definitely store values in them! This is where Rust gets really clever: it's\n@@ -118,15 +118,15 @@ in them *via a mutable reference*! The mutable reference makes the whole type\n invariant, and therefore prevents you from smuggling a short-lived type into\n them.\n \n-Being variant *does* allows `Box` and `Vec` to be weakened when shared\n+Being variant allows `Box` and `Vec` to be weakened when shared\n immutably. So you can pass a `&Box<&'static str>` where a `&Box<&'a str>` is\n expected.\n \n However what should happen when passing *by-value* is less obvious. It turns out\n that, yes, you can use subtyping when passing by-value. That is, this works:\n \n ```rust\n-fn get_box<'a>(str: &'a u8) -> Box<&'a str> {\n+fn get_box<'a>(str: &'a str) -> Box<&'a str> {\n     // string literals are `&'static str`s\n     Box::new(\"hello\")\n }\n@@ -150,7 +150,7 @@ signature:\n fn foo(&'a str) -> usize;\n ```\n \n-This signature claims that it can handle any `&str` that lives *at least* as\n+This signature claims that it can handle any `&str` that lives at least as\n long as `'a`. Now if this signature was variant over `&'a str`, that\n would mean\n \n@@ -159,10 +159,12 @@ fn foo(&'static str) -> usize;\n ```\n \n could be provided in its place, as it would be a subtype. However this function\n-has a *stronger* requirement: it says that it can *only* handle `&'static str`s,\n-and nothing else. Therefore functions are not variant over their arguments.\n+has a stronger requirement: it says that it can only handle `&'static str`s,\n+and nothing else. Giving `&'a str`s to it would be unsound, as it's free to\n+assume that what it's given lives forever. Therefore functions are not variant\n+over their arguments.\n \n-To see why `Fn(T) -> U` should be *variant* over U, consider the following\n+To see why `Fn(T) -> U` should be variant over U, consider the following\n function signature:\n \n ```rust,ignore\n@@ -177,7 +179,7 @@ therefore completely reasonable to provide\n fn foo(usize) -> &'static str;\n ```\n \n-in its place. Therefore functions *are* variant over their return type.\n+in its place. Therefore functions are variant over their return type.\n \n `*const` has the exact same semantics as `&`, so variance follows. `*mut` on the\n other hand can dereference to an `&mut` whether shared or not, so it is marked"}, {"sha": "3ad95dde39deda47fc61395384af3915a6221097", "filename": "src/doc/tarpl/unwinding.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Funwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Funwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Funwinding.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -31,12 +31,12 @@ panics can only be caught by the parent thread. This means catching a panic\n requires spinning up an entire OS thread! This unfortunately stands in conflict\n to Rust's philosophy of zero-cost abstractions.\n \n-There is an *unstable* API called `catch_panic` that enables catching a panic\n+There is an unstable API called `catch_panic` that enables catching a panic\n without spawning a thread. Still, we would encourage you to only do this\n sparingly. In particular, Rust's current unwinding implementation is heavily\n optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n should be no runtime cost for the program being *ready* to unwind. As a\n-consequence, *actually* unwinding will be more expensive than in e.g. Java.\n+consequence, actually unwinding will be more expensive than in e.g. Java.\n Don't build your programs to unwind under normal circumstances. Ideally, you\n should only panic for programming errors or *extreme* problems.\n "}, {"sha": "fc7feba2356d5a4fb742a5b9ea06a99d32e86085", "filename": "src/doc/tarpl/vec-alloc.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-alloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-alloc.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -60,7 +60,7 @@ of memory at once (e.g. half the theoretical address space). As such it's\n like the standard library as much as possible, so we'll just kill the whole\n program.\n \n-We said we don't want to use intrinsics, so doing *exactly* what `std` does is\n+We said we don't want to use intrinsics, so doing exactly what `std` does is\n out. Instead, we'll call `std::process::exit` with some random number.\n \n ```rust\n@@ -84,7 +84,7 @@ But Rust's only supported allocator API is so low level that we'll need to do a\n fair bit of extra work. We also need to guard against some special\n conditions that can occur with really large allocations or empty allocations.\n \n-In particular, `ptr::offset` will cause us *a lot* of trouble, because it has\n+In particular, `ptr::offset` will cause us a lot of trouble, because it has\n the semantics of LLVM's GEP inbounds instruction. If you're fortunate enough to\n not have dealt with this instruction, here's the basic story with GEP: alias\n analysis, alias analysis, alias analysis. It's super important to an optimizing\n@@ -102,7 +102,7 @@ As a simple example, consider the following fragment of code:\n If the compiler can prove that `x` and `y` point to different locations in\n memory, the two operations can in theory be executed in parallel (by e.g.\n loading them into different registers and working on them independently).\n-However in *general* the compiler can't do this because if x and y point to\n+However the compiler can't do this in general because if x and y point to\n the same location in memory, the operations need to be done to the same value,\n and they can't just be merged afterwards.\n \n@@ -118,7 +118,7 @@ possible.\n So that's what GEP's about, how can it cause us trouble?\n \n The first problem is that we index into arrays with unsigned integers, but\n-GEP (and as a consequence `ptr::offset`) takes a *signed integer*. This means\n+GEP (and as a consequence `ptr::offset`) takes a signed integer. This means\n that half of the seemingly valid indices into an array will overflow GEP and\n actually go in the wrong direction! As such we must limit all allocations to\n `isize::MAX` elements. This actually means we only need to worry about\n@@ -138,7 +138,7 @@ However since this is a tutorial, we're not going to be particularly optimal\n here, and just unconditionally check, rather than use clever platform-specific\n `cfg`s.\n \n-The other corner-case we need to worry about is *empty* allocations. There will\n+The other corner-case we need to worry about is empty allocations. There will\n be two kinds of empty allocations we need to worry about: `cap = 0` for all T,\n and `cap > 0` for zero-sized types.\n \n@@ -165,9 +165,9 @@ protected from being allocated anyway (a whole 4k, on many platforms).\n \n However what about for positive-sized types? That one's a bit trickier. In\n principle, you can argue that offsetting by 0 gives LLVM no information: either\n-there's an element before the address, or after it, but it can't know which.\n+there's an element before the address or after it, but it can't know which.\n However we've chosen to conservatively assume that it may do bad things. As\n-such we *will* guard against this case explicitly.\n+such we will guard against this case explicitly.\n \n *Phew*\n "}, {"sha": "4521bbdd05e6b0456df7e86f38f548f67c20cfc3", "filename": "src/doc/tarpl/vec-drain.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-drain.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-drain.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -130,7 +130,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n impl<T> Vec<T> {\n     pub fn drain(&mut self) -> Drain<T> {\n         // this is a mem::forget safety thing. If Drain is forgotten, we just\n-        // leak the whole Vec's contents. Also we need to do this *eventually*\n+        // leak the whole Vec's contents. Also we need to do this eventually\n         // anyway, so why not do it now?\n         self.len = 0;\n "}, {"sha": "0a37170c52ca34bf39bef5bd96a80dbec6492f1f", "filename": "src/doc/tarpl/vec-insert-remove.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-insert-remove.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -10,7 +10,7 @@ handling the case where the source and destination overlap (which will\n definitely happen here).\n \n If we insert at index `i`, we want to shift the `[i .. len]` to `[i+1 .. len+1]`\n-using the *old* len.\n+using the old len.\n \n ```rust,ignore\n pub fn insert(&mut self, index: usize, elem: T) {"}, {"sha": "ebb0a79bb651ac05a83f24bfcf68633a636ba97e", "filename": "src/doc/tarpl/vec-into-iter.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-into-iter.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -21,8 +21,8 @@ read out the value pointed to at that end and move the pointer over by one. When\n the two pointers are equal, we know we're done.\n \n Note that the order of read and offset are reversed for `next` and `next_back`\n-For `next_back` the pointer is always *after* the element it wants to read next,\n-while for `next` the pointer is always *at* the element it wants to read next.\n+For `next_back` the pointer is always after the element it wants to read next,\n+while for `next` the pointer is always at the element it wants to read next.\n To see why this is, consider the case where every element but one has been\n yielded.\n \n@@ -124,7 +124,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n ```\n \n Because IntoIter takes ownership of its allocation, it needs to implement Drop\n-to free it. However it *also* wants to implement Drop to drop any elements it\n+to free it. However it also wants to implement Drop to drop any elements it\n contains that weren't yielded.\n \n "}, {"sha": "b518e8aa48ffb1beb82b0b796cce45d60e6192f3", "filename": "src/doc/tarpl/vec-push-pop.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-push-pop.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -32,14 +32,14 @@ pub fn push(&mut self, elem: T) {\n \n Easy! How about `pop`? Although this time the index we want to access is\n initialized, Rust won't just let us dereference the location of memory to move\n-the value out, because that *would* leave the memory uninitialized! For this we\n+the value out, because that would leave the memory uninitialized! For this we\n need `ptr::read`, which just copies out the bits from the target address and\n intrprets it as a value of type T. This will leave the memory at this address\n-*logically* uninitialized, even though there is in fact a perfectly good instance\n+logically uninitialized, even though there is in fact a perfectly good instance\n of T there.\n \n For `pop`, if the old len is 1, we want to read out of the 0th index. So we\n-should offset by the *new* len.\n+should offset by the new len.\n \n ```rust,ignore\n pub fn pop(&mut self) -> Option<T> {"}, {"sha": "72e8a34488bae73751aa6306d60613d32321bbdc", "filename": "src/doc/tarpl/vec-zsts.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/554efc013481b45b8336299074a86491e4ef436e/src%2Fdoc%2Ftarpl%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftarpl%2Fvec-zsts.md?ref=554efc013481b45b8336299074a86491e4ef436e", "patch": "@@ -2,7 +2,7 @@\n \n It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n *never* needs to care about this, but Vec is very intensive on raw pointers and\n-raw allocations, which are exactly the *only* two things that care about\n+raw allocations, which are exactly the two things that care about\n zero-sized types. We need to be careful of two things:\n \n * The raw allocator API has undefined behaviour if you pass in 0 for an\n@@ -22,7 +22,7 @@ So if the allocator API doesn't support zero-sized allocations, what on earth\n do we store as our allocation? Why, `heap::EMPTY` of course! Almost every operation\n with a ZST is a no-op since ZSTs have exactly one value, and therefore no state needs\n to be considered to store or load them. This actually extends to `ptr::read` and\n-`ptr::write`: they won't actually look at the pointer at all. As such we *never* need\n+`ptr::write`: they won't actually look at the pointer at all. As such we never need\n to change the pointer.\n \n Note however that our previous reliance on running out of memory before overflow is"}]}