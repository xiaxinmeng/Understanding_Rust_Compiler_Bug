{"sha": "f6d897d7d97c6f75126d487da196084aaafde659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2ZDg5N2Q3ZDk3YzZmNzUxMjZkNDg3ZGExOTYwODRhYWFmZGU2NTk=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-20T04:57:47Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:57Z"}, "message": "std: rt::io::file::FileStream fleshed out.. needs more work.. see extended\n\n- change all uses of Path in fn args to &P\n- FileStream.read assumptions were wrong (libuv file io is non-positional)\n- the above will mean that we \"own\" Seek impl info .. should probably\n  push it in UvFileDescriptor..\n- needs more tests", "tree": {"sha": "33b71a8ad866a355aaad3e04b40c6f87ed4dfc21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33b71a8ad866a355aaad3e04b40c6f87ed4dfc21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6d897d7d97c6f75126d487da196084aaafde659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d897d7d97c6f75126d487da196084aaafde659", "html_url": "https://github.com/rust-lang/rust/commit/f6d897d7d97c6f75126d487da196084aaafde659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6d897d7d97c6f75126d487da196084aaafde659/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47f0e91689403c8472dc63e58e735f42251427ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/47f0e91689403c8472dc63e58e735f42251427ab", "html_url": "https://github.com/rust-lang/rust/commit/47f0e91689403c8472dc63e58e735f42251427ab"}], "stats": {"total": 167, "additions": 127, "deletions": 40}, "files": [{"sha": "0e972206ea747e0c47b86b29429514b5fd3de96d", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 94, "deletions": 15, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=f6d897d7d97c6f75126d487da196084aaafde659", "patch": "@@ -12,6 +12,11 @@ use prelude::*;\n use super::support::PathLike;\n use super::{Reader, Writer, Seek};\n use super::SeekStyle;\n+use rt::rtio::{RtioFileDescriptor, IoFactory, IoFactoryObject};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::local::Local;\n+use libc::{O_RDWR, O_RDONLY, O_WRONLY, S_IWUSR, S_IRUSR,\n+           O_CREAT, O_TRUNC, O_APPEND};\n \n /// # FIXME #7785\n /// * Ugh, this is ridiculous. What is the best way to represent these options?\n@@ -36,29 +41,85 @@ enum FileAccess {\n     ReadWrite\n }\n \n-pub struct FileStream;\n+pub struct FileStream {\n+    fd: ~RtioFileDescriptor,\n+    last_nread: int\n+}\n \n impl FileStream {\n-    pub fn open<P: PathLike>(_path: &P,\n-                             _mode: FileMode,\n-                             _access: FileAccess\n+    pub fn open<P: PathLike>(path: &P,\n+                             mode: FileMode,\n+                             access: FileAccess\n                             ) -> Option<FileStream> {\n-        fail!()\n+        let open_result = unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let mut flags = match mode {\n+                Open => 0,\n+                Create => O_CREAT,\n+                OpenOrCreate => O_CREAT,\n+                Append => O_APPEND,\n+                Truncate => O_TRUNC,\n+                CreateOrTruncate => O_TRUNC | O_CREAT\n+            };\n+            flags = match access {\n+                Read => flags | O_RDONLY,\n+                Write => flags | O_WRONLY,\n+                ReadWrite => flags | O_RDWR\n+            };\n+            let create_mode = match mode {\n+                Create|OpenOrCreate|CreateOrTruncate =>\n+                    S_IRUSR | S_IWUSR,\n+                _ => 0\n+            };\n+            (*io).fs_open(path, flags as int, create_mode as int)\n+        };\n+        match open_result {\n+            Ok(fd) => Some(FileStream {\n+                fd: fd,\n+                last_nread: -1\n+            }),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                None\n+            }\n+        }\n     }\n }\n \n impl Reader for FileStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> {\n-        fail!()\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        match self.fd.read(buf, 0) {\n+            Ok(read) => {\n+                self.last_nread = read;\n+                match read {\n+                    0 => None,\n+                    _ => Some(read as uint)\n+                }\n+            },\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                return None;\n+            }\n+        }\n     }\n \n     fn eof(&mut self) -> bool {\n-        fail!()\n+        self.last_nread == 0\n     }\n }\n \n impl Writer for FileStream {\n-    fn write(&mut self, _v: &[u8]) { fail!() }\n+    fn write(&mut self, buf: &[u8]) {\n+        match self.fd.write(buf, 0) {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n \n     fn flush(&mut self) { fail!() }\n }\n@@ -69,11 +130,29 @@ impl Seek for FileStream {\n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n+fn file_test_smoke_test_impl() {\n+    use rt::test::*;\n+    do run_in_newsched_task {\n+        let message = \"it's alright. have a good time\";\n+        let filename = &Path(\"rt_io_file_test.txt\");\n+        {\n+            let mut write_stream = FileStream::open(filename, Create, ReadWrite).unwrap();\n+            write_stream.write(message.as_bytes());\n+        }\n+        {\n+            use str;\n+            let mut read_stream = FileStream::open(filename, Open, Read).unwrap();\n+            let mut read_buf = [0, .. 1028];\n+            let read_str = match read_stream.read(read_buf).unwrap() {\n+                -1|0 => fail!(\"shouldn't happen\"),\n+                n => str::from_bytes(read_buf.slice_to(n))\n+            };\n+            assert!(read_str == message.to_owned());\n+        }\n+    }\n+}\n+\n #[test]\n-#[ignore]\n-fn super_simple_smoke_test_lets_go_read_some_files_and_have_a_good_time() {\n-    let message = \"it's alright. have a good time\";\n-    let filename = &Path(\"test.txt\");\n-    let mut outstream = FileStream::open(filename, Create, Read).unwrap();\n-    outstream.write(message.as_bytes());\n+fn file_test_smoke_test() {\n+    file_test_smoke_test_impl();\n }"}, {"sha": "fedffa3284443438dee2334b60f89a8dcf822990", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=f6d897d7d97c6f75126d487da196084aaafde659", "patch": "@@ -16,6 +16,7 @@ use rt::io::IoError;\n use super::io::net::ip::{IpAddr, SocketAddr};\n use rt::uv::uvio;\n use path::Path;\n+use super::io::support::PathLike;\n \n // XXX: ~object doesn't work currently so these are some placeholder\n // types to use instead\n@@ -66,9 +67,9 @@ pub trait IoFactory {\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError>;\n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError>;\n     fn fs_from_raw_fd(&mut self, fd: c_int, close_on_drop: bool) -> ~RtioFileDescriptor;\n-    fn fs_open(&mut self, path: Path, flags: int, mode:int)\n+    fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode:int)\n         -> Result<~RtioFileDescriptor, IoError>;\n-    fn fs_unlink(&mut self, path: Path) -> Result<(), IoError>;\n+    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError>;\n }\n \n pub trait RtioTcpListener : RtioSocket {"}, {"sha": "056250ba968e665b09d41db7321ee60509aad8c6", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=f6d897d7d97c6f75126d487da196084aaafde659", "patch": "@@ -15,7 +15,7 @@ use rt::uv::{Request, NativeHandle, Loop, FsCallback, Buf,\n              status_to_maybe_uv_error_with_loop};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n-use path::Path;\n+use super::super::io::support::PathLike;\n use cast::transmute;\n use libc::{c_int};\n use option::{None, Some, Option};\n@@ -97,47 +97,52 @@ impl FileDescriptor {\n         FileDescriptor::new(req.get_result())\n     }\n \n-    fn open_common(loop_: Loop, path: Path, flags: int, mode: int,\n+    fn open_common<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n                cb: Option<FsCallback>) -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb,\n             None => 0 as *u8\n         };\n         let is_sync = cb.is_none();\n         let req = FsRequest::new(cb);\n-        let result = path.to_str().to_c_str().with_ref(|p| unsafe {\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n             uvll::fs_open(loop_.native_handle(),\n                           req.native_handle(), p, flags, mode, complete_cb_ptr) as int\n+            })\n         });\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn open(loop_: Loop, path: Path, flags: int, mode: int,\n+    pub fn open<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n                cb: FsCallback) -> int {\n         FileDescriptor::open_common(loop_, path, flags, mode, Some(cb))\n     }\n-    pub fn open_sync(loop_: Loop, path: Path, flags: int, mode: int) -> int {\n+\n+    pub fn open_sync<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int) -> int {\n         FileDescriptor::open_common(loop_, path, flags, mode, None)\n     }\n \n-    fn unlink_common(loop_: Loop, path: Path, cb: Option<FsCallback>) -> int {\n+    fn unlink_common<P: PathLike>(loop_: Loop, path: &P, cb: Option<FsCallback>) -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb,\n             None => 0 as *u8\n         };\n         let is_sync = cb.is_none();\n         let req = FsRequest::new(cb);\n-        let result = path.to_str().to_c_str().with_ref(|p| unsafe {\n-            uvll::fs_unlink(loop_.native_handle(),\n-                          req.native_handle(), p, complete_cb_ptr) as int\n+        let result = path.path_as_str(|p| {\n+            p.to_c_str().with_ref(|p| unsafe {\n+                uvll::fs_unlink(loop_.native_handle(),\n+                              req.native_handle(), p, complete_cb_ptr) as int\n+            })\n         });\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn unlink(loop_: Loop, path: Path, cb: FsCallback) -> int {\n+    pub fn unlink<P: PathLike>(loop_: Loop, path: &P, cb: FsCallback) -> int {\n         FileDescriptor::unlink_common(loop_, path, Some(cb))\n     }\n-    pub fn unlink_sync(loop_: Loop, path: Path) -> int {\n+    pub fn unlink_sync<P: PathLike>(loop_: Loop, path: &P) -> int {\n         FileDescriptor::unlink_common(loop_, path, None)\n     }\n \n@@ -284,7 +289,8 @@ mod test {\n             let read_mem = vec::from_elem(read_buf_len, 0u8);\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n-            do FileDescriptor::open(loop_, Path(path_str), create_flags as int, mode as int)\n+            let p = Path(path_str);\n+            do FileDescriptor::open(loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n                 let loop_ = req.get_loop();\n                 assert!(uverr.is_none());\n@@ -296,7 +302,7 @@ mod test {\n                     do fd.close(loop_) |req, _| {\n                         let loop_ = req.get_loop();\n                         assert!(uverr.is_none());\n-                        do FileDescriptor::open(loop_, Path(path_str), read_flags as int,0)\n+                        do FileDescriptor::open(loop_, &Path(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n@@ -319,7 +325,7 @@ mod test {\n                                     assert!(read_str == ~\"hello\");\n                                     do FileDescriptor(raw_fd).close(loop_) |_,uverr| {\n                                         assert!(uverr.is_none());\n-                                        do FileDescriptor::unlink(loop_, Path(path_str))\n+                                        do FileDescriptor::unlink(loop_, &Path(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n                                         };\n@@ -350,7 +356,7 @@ mod test {\n             let write_val = \"hello\".as_bytes().to_owned();\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n-            let result = FileDescriptor::open_sync(loop_, Path(path_str),\n+            let result = FileDescriptor::open_sync(loop_, &Path(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n@@ -364,7 +370,7 @@ mod test {\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n             // re-open\n-            let result = FileDescriptor::open_sync(loop_, Path(path_str),\n+            let result = FileDescriptor::open_sync(loop_, &Path(path_str),\n                                                    read_flags as int,0);\n             assert!(status_to_maybe_uv_error_with_loop(\n                 loop_.native_handle(), result as i32).is_none());\n@@ -388,7 +394,7 @@ mod test {\n                 assert!(status_to_maybe_uv_error_with_loop(\n                     loop_.native_handle(), result as i32).is_none());\n                 // unlink\n-                let result = FileDescriptor::unlink_sync(loop_, Path(path_str));\n+                let result = FileDescriptor::unlink_sync(loop_, &Path(path_str));\n                 assert!(status_to_maybe_uv_error_with_loop(\n                     loop_.native_handle(), result as i32).is_none());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }"}, {"sha": "2acf2cccfeae91e0f01249e8fe5da72272630c90", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6d897d7d97c6f75126d487da196084aaafde659/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=f6d897d7d97c6f75126d487da196084aaafde659", "patch": "@@ -18,7 +18,6 @@ use ops::Drop;\n use option::*;\n use ptr;\n use str;\n-use path::Path;\n use result::*;\n use rt::io::IoError;\n use rt::io::net::ip::{SocketAddr, IpAddr};\n@@ -31,6 +30,7 @@ use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use unstable::sync::Exclusive;\n+use super::super::io::support::PathLike;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use unstable::run_in_bare_thread;\n@@ -466,7 +466,7 @@ impl IoFactory for UvIoFactory {\n         } as ~RtioFileDescriptor\n     }\n \n-    fn fs_open(&mut self, path: Path, flags: int, mode: int)\n+    fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode: int)\n         -> Result<~RtioFileDescriptor, IoError> {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let result_cell = Cell::new_empty();\n@@ -497,7 +497,7 @@ impl IoFactory for UvIoFactory {\n         return result_cell.take();\n     }\n \n-    fn fs_unlink(&mut self, path: Path) -> Result<(), IoError> {\n+    fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n         let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n@@ -1636,6 +1636,7 @@ fn file_test_uvio_full_simple_impl() {\n     use str::StrSlice; // why does this have to be explicitly imported to work?\n                        // compiler was complaining about no trait for str that\n                        // does .as_bytes() ..\n+    use path::Path;\n     unsafe {\n         let io = Local::unsafe_borrow::<IoFactoryObject>();\n         let create_flags = O_RDWR | O_CREAT;\n@@ -1644,18 +1645,18 @@ fn file_test_uvio_full_simple_impl() {\n         let mode = S_IWUSR | S_IRUSR;\n         let path = \"./file_test_uvio_full.txt\";\n         {\n-            let mut fd = (*io).fs_open(Path(path), create_flags as int, mode as int).unwrap();\n+            let mut fd = (*io).fs_open(&Path(path), create_flags as int, mode as int).unwrap();\n             let write_buf = write_val.as_bytes();\n             fd.write(write_buf, 0);\n         }\n         {\n-            let mut fd = (*io).fs_open(Path(path), ro_flags as int, mode as int).unwrap();\n+            let mut fd = (*io).fs_open(&Path(path), ro_flags as int, mode as int).unwrap();\n             let mut read_vec = [0, .. 1028];\n             let nread = fd.read(read_vec, 0).unwrap();\n             let read_val = str::from_bytes(read_vec.slice(0, nread as uint));\n             assert!(read_val == write_val.to_owned());\n         }\n-        (*io).fs_unlink(Path(path));\n+        (*io).fs_unlink(&Path(path));\n     }\n }\n "}]}