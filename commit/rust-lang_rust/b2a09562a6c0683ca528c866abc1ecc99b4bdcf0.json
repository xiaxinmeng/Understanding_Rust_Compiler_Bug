{"sha": "b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYTA5NTYyYTZjMDY4M2NhNTI4Yzg2NmFiYzFlY2M5OWI0YmRjZjA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-24T23:54:55Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-24T23:55:10Z"}, "message": "Factor crate expr evaluator out of parser, expand to simple scalars and ops, if, alt.", "tree": {"sha": "9af4389c4f5b857890575954e247c07fb6f5b536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9af4389c4f5b857890575954e247c07fb6f5b536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "html_url": "https://github.com/rust-lang/rust/commit/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd65fac199d3caac4b1019304ef5e1b480f31ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd65fac199d3caac4b1019304ef5e1b480f31ff", "html_url": "https://github.com/rust-lang/rust/commit/dcd65fac199d3caac4b1019304ef5e1b480f31ff"}], "stats": {"total": 535, "additions": 453, "deletions": 82}, "files": [{"sha": "f5c03bd7e74e1463898900dbc2390fd06ced8e70", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "patch": "@@ -46,7 +46,10 @@ type crate_ = rec(_mod module);\n \n tag crate_directive_ {\n     cdir_expr(@expr);\n-    cdir_const(@item);\n+    // FIXME: cdir_let should be eliminated\n+    // and redirected to the use of const stmt_decls inside\n+    // crate directive blocks.\n+    cdir_let(ident, @expr, vec[@crate_directive]);\n     cdir_src_mod(ident, option.t[filename]);\n     cdir_dir_mod(ident, option.t[filename], vec[@crate_directive]);\n     cdir_view_item(@view_item);\n@@ -137,6 +140,8 @@ type stmt = spanned[stmt_];\n tag stmt_ {\n     stmt_decl(@decl);\n     stmt_expr(@expr);\n+    // These only exist in crate-level blocks.\n+    stmt_crate_directive(@crate_directive);\n }\n \n type local = rec(option.t[@ty] ty,\n@@ -175,7 +180,6 @@ tag expr_ {\n     expr_do_while(block, @expr, ann);\n     expr_alt(@expr, vec[arm], ann);\n     expr_block(block, ann);\n-    expr_crate_directive_block(vec[crate_directive_]);\n     expr_assign(@expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_assign_op(binop, @expr /* TODO: @expr|is_lval */, @expr, ann);\n     expr_field(@expr, ident, ann);"}, {"sha": "7275e55711e881e99702f654346ff65205f6f51c", "filename": "src/comp/front/eval.rs", "status": "added", "additions": 443, "deletions": 0, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "patch": "@@ -0,0 +1,443 @@\n+import std._vec;\n+import std._str;\n+import std.option;\n+import std.option.some;\n+import std.option.none;\n+import std.map.hashmap;\n+\n+import driver.session;\n+import ast.ident;\n+import front.parser.parser;\n+import front.parser.spanned;\n+import front.parser.new_parser;\n+import front.parser.parse_mod_items;\n+import util.common;\n+import util.common.filename;\n+import util.common.append;\n+import util.common.span;\n+import util.common.new_str_hash;\n+\n+\n+// Simple dynamic-typed value type for eval_expr.\n+tag val {\n+    val_bool(bool);\n+    val_int(int);\n+    val_str(str);\n+}\n+\n+type env = vec[tup(ident, val)];\n+\n+fn mk_env() -> env {\n+    let env e = vec();\n+    ret e;\n+}\n+\n+fn val_is_bool(val v) -> bool {\n+    alt (v) {\n+        case (val_bool(_)) { ret true; }\n+        case (_) { }\n+    }\n+    ret false;\n+}\n+\n+fn val_is_int(val v) -> bool {\n+    alt (v) {\n+        case (val_bool(_)) { ret true; }\n+        case (_) { }\n+    }\n+    ret false;\n+}\n+\n+fn val_is_str(val v) -> bool {\n+    alt (v) {\n+        case (val_str(_)) { ret true; }\n+        case (_) { }\n+    }\n+    ret false;\n+}\n+\n+fn val_as_bool(val v) -> bool {\n+    alt (v) {\n+        case (val_bool(?b)) { ret b; }\n+        case (_) { }\n+    }\n+    fail;\n+}\n+\n+fn val_as_int(val v) -> int {\n+    alt (v) {\n+        case (val_int(?i)) { ret i; }\n+        case (_) { }\n+    }\n+    fail;\n+}\n+\n+fn val_as_str(val v) -> str {\n+    alt (v) {\n+        case (val_str(?s)) { ret s; }\n+        case (_) { }\n+    }\n+    fail;\n+}\n+\n+fn lookup(session.session sess, env e, span sp, ident i) -> val {\n+    for (tup(ident, val) pair in e) {\n+        if (_str.eq(i, pair._0)) {\n+            ret pair._1;\n+        }\n+    }\n+    sess.span_err(sp, \"unknown variable: \" + i);\n+    fail;\n+}\n+\n+fn eval_lit(session.session sess, env e, span sp, @ast.lit lit) -> val {\n+    alt (lit.node) {\n+        case (ast.lit_bool(?b)) { ret val_bool(b); }\n+        case (ast.lit_int(?i)) { ret val_int(i); }\n+        case (ast.lit_str(?s)) { ret val_str(s); }\n+        case (_) {\n+            sess.span_err(sp, \"evaluating unsupported literal\");\n+        }\n+    }\n+    fail;\n+}\n+\n+fn eval_expr(session.session sess, env e, @ast.expr x) -> val {\n+    alt (x.node) {\n+        case (ast.expr_path(?pth, _, _)) {\n+            if (_vec.len[ident](pth.node.idents) == 1u &&\n+                _vec.len[@ast.ty](pth.node.types) == 0u) {\n+                ret lookup(sess, e, x.span, pth.node.idents.(0));\n+            }\n+            sess.span_err(x.span, \"evaluating structured path-name\");\n+        }\n+\n+        case (ast.expr_lit(?lit, _)) {\n+            ret eval_lit(sess, e, x.span, lit);\n+        }\n+\n+        case (ast.expr_unary(?op, ?a, _)) {\n+            auto av = eval_expr(sess, e, a);\n+            alt (op) {\n+                case (ast.not) {\n+                    if (val_is_bool(av)) {\n+                        ret val_bool(!val_as_bool(av));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '!' expression\");\n+                }\n+                case (_) {\n+                    sess.span_err(x.span, \"evaluating unsupported unop\");\n+                }\n+            }\n+        }\n+\n+        case (ast.expr_binary(?op, ?a, ?b, _)) {\n+            auto av = eval_expr(sess, e, a);\n+            auto bv = eval_expr(sess, e, b);\n+            alt (op) {\n+                case (ast.add) {\n+                    if (val_is_int(av) && val_is_int(bv)) {\n+                        ret val_int(val_as_int(av) + val_as_int(bv));\n+                    }\n+                    if (val_is_str(av) && val_is_str(bv)) {\n+                        ret val_str(val_as_str(av) + val_as_str(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '+' expression\");\n+                }\n+\n+                case (ast.sub) {\n+                    if (val_is_int(av) && val_is_int(bv)) {\n+                        ret val_int(val_as_int(av) - val_as_int(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '-' expression\");\n+                }\n+\n+                case (ast.mul) {\n+                    if (val_is_int(av) && val_is_int(bv)) {\n+                        ret val_int(val_as_int(av) * val_as_int(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '*' expression\");\n+                }\n+\n+                case (ast.div) {\n+                    if (val_is_int(av) && val_is_int(bv)) {\n+                        ret val_int(val_as_int(av) / val_as_int(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '/' expression\");\n+                }\n+\n+                case (ast.rem) {\n+                    if (val_is_int(av) && val_is_int(bv)) {\n+                        ret val_int(val_as_int(av) % val_as_int(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '%' expression\");\n+                }\n+\n+                case (ast.and) {\n+                    if (val_is_bool(av) && val_is_bool(bv)) {\n+                        ret val_bool(val_as_bool(av) && val_as_bool(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '&&' expression\");\n+                }\n+\n+                case (ast.or) {\n+                    if (val_is_bool(av) && val_is_bool(bv)) {\n+                        ret val_bool(val_as_bool(av) || val_as_bool(bv));\n+                    }\n+                    sess.span_err(x.span, \"bad types in '||' expression\");\n+                }\n+\n+                case (ast.eq) {\n+                    ret val_bool(val_eq(sess, x.span, av, bv));\n+                }\n+\n+                case (ast.ne) {\n+                    ret val_bool(! val_eq(sess, x.span, av, bv));\n+                }\n+\n+                case (_) {\n+                    sess.span_err(x.span, \"evaluating unsupported binop\");\n+                }\n+            }\n+        }\n+        case (_) {\n+            sess.span_err(x.span, \"evaluating unsupported expression\");\n+        }\n+    }\n+    fail;\n+}\n+\n+fn val_eq(session.session sess, span sp, val av, val bv) -> bool {\n+    if (val_is_bool(av) && val_is_bool(bv)) {\n+        ret val_as_bool(av) == val_as_bool(bv);\n+    }\n+    if (val_is_int(av) && val_is_int(bv)) {\n+        ret val_as_int(av) == val_as_int(bv);\n+    }\n+    if (val_is_str(av) && val_is_str(bv)) {\n+        ret _str.eq(val_as_str(av),\n+                    val_as_str(bv));\n+    }\n+    sess.span_err(sp, \"bad types in comparison\");\n+    fail;\n+}\n+\n+impure fn eval_crate_directives(parser p,\n+                                env e,\n+                                vec[@ast.crate_directive] cdirs,\n+                                str prefix,\n+                                &mutable vec[@ast.view_item] view_items,\n+                                &mutable vec[@ast.item] items,\n+                                hashmap[ast.ident,\n+                                        ast.mod_index_entry] index) {\n+\n+    for (@ast.crate_directive sub_cdir in cdirs) {\n+        eval_crate_directive(p, e, sub_cdir, prefix,\n+                             view_items, items, index);\n+    }\n+}\n+\n+\n+impure fn eval_crate_directives_to_mod(parser p,\n+                                       env e,\n+                                       vec[@ast.crate_directive] cdirs,\n+                                       str prefix) -> ast._mod {\n+    let vec[@ast.view_item] view_items = vec();\n+    let vec[@ast.item] items = vec();\n+    auto index = new_str_hash[ast.mod_index_entry]();\n+\n+    eval_crate_directives(p, e, cdirs, prefix,\n+                          view_items, items, index);\n+\n+    ret rec(view_items=view_items, items=items, index=index);\n+}\n+\n+\n+impure fn eval_crate_directive_block(parser p,\n+                                     env e,\n+                                     &ast.block blk,\n+                                     str prefix,\n+                                     &mutable vec[@ast.view_item] view_items,\n+                                     &mutable vec[@ast.item] items,\n+                                     hashmap[ast.ident,\n+                                             ast.mod_index_entry] index) {\n+\n+    for (@ast.stmt s in blk.node.stmts) {\n+        alt (s.node) {\n+            case (ast.stmt_crate_directive(?cdir)) {\n+                eval_crate_directive(p, e, cdir, prefix,\n+                                     view_items, items, index);\n+            }\n+            case (_) {\n+                auto sess = p.get_session();\n+                sess.span_err(s.span,\n+                              \"unsupported stmt in crate-directive block\");\n+            }\n+        }\n+    }\n+}\n+\n+impure fn eval_crate_directive_expr(parser p,\n+                                    env e,\n+                                    @ast.expr x,\n+                                    str prefix,\n+                                    &mutable vec[@ast.view_item] view_items,\n+                                    &mutable vec[@ast.item] items,\n+                                    hashmap[ast.ident,\n+                                            ast.mod_index_entry] index) {\n+    auto sess = p.get_session();\n+\n+    alt (x.node) {\n+\n+        case (ast.expr_if(?cond, ?thn, ?elifs, ?elopt, _)) {\n+            auto cv = eval_expr(sess, e, cond);\n+            if (!val_is_bool(cv)) {\n+                sess.span_err(x.span, \"bad cond type in 'if'\");\n+            }\n+\n+            if (val_as_bool(cv)) {\n+                ret eval_crate_directive_block(p, e, thn, prefix,\n+                                               view_items, items,\n+                                               index);\n+            }\n+\n+            for (tup(@ast.expr, ast.block) elif in elifs) {\n+                auto cv = eval_expr(sess, e, elif._0);\n+                if (!val_is_bool(cv)) {\n+                    sess.span_err(x.span, \"bad cond type in 'else if'\");\n+                }\n+\n+                if (val_as_bool(cv)) {\n+                    ret eval_crate_directive_block(p, e, elif._1, prefix,\n+                                                   view_items, items,\n+                                                   index);\n+                }\n+            }\n+\n+            alt (elopt) {\n+                case (some[ast.block](?els)) {\n+                    ret eval_crate_directive_block(p, e, els, prefix,\n+                                                   view_items, items,\n+                                                   index);\n+                }\n+                case (_) {\n+                    // Absent-else is ok.\n+                }\n+            }\n+        }\n+\n+        case (ast.expr_alt(?v, ?arms, _)) {\n+            auto vv = eval_expr(sess, e, v);\n+            for (ast.arm arm in arms) {\n+                alt (arm.pat.node) {\n+                    case (ast.pat_lit(?lit, _)) {\n+                        auto pv = eval_lit(sess, e,\n+                                           arm.pat.span, lit);\n+                        if (val_eq(sess, arm.pat.span, vv, pv)) {\n+                            ret eval_crate_directive_block\n+                                (p, e, arm.block, prefix,\n+                                 view_items, items, index);\n+                        }\n+                    }\n+                    case (ast.pat_wild(_)) {\n+                        ret eval_crate_directive_block\n+                            (p, e, arm.block, prefix,\n+                             view_items, items, index);\n+                    }\n+                    case (_) {\n+                        sess.span_err(arm.pat.span,\n+                                      \"bad pattern type in 'alt'\");\n+                    }\n+                }\n+            }\n+            sess.span_err(x.span, \"no cases matched in 'alt'\");\n+        }\n+\n+        case (_) {\n+            sess.span_err(x.span, \"unsupported expr type\");\n+        }\n+    }\n+}\n+\n+impure fn eval_crate_directive(parser p,\n+                               env e,\n+                               @ast.crate_directive cdir,\n+                               str prefix,\n+                               &mutable vec[@ast.view_item] view_items,\n+                               &mutable vec[@ast.item] items,\n+                               hashmap[ast.ident,\n+                                       ast.mod_index_entry] index) {\n+    alt (cdir.node) {\n+\n+        case (ast.cdir_let(?id, ?x, ?cdirs)) {\n+            auto v = eval_expr(p.get_session(), e, x);\n+            auto e0 = vec(tup(id, v)) + e;\n+            eval_crate_directives(p, e0, cdirs, prefix,\n+                                  view_items, items, index);\n+        }\n+\n+        case (ast.cdir_expr(?x)) {\n+            eval_crate_directive_expr(p, e, x, prefix,\n+                                      view_items, items, index);\n+        }\n+\n+        case (ast.cdir_src_mod(?id, ?file_opt)) {\n+\n+            auto file_path = id + \".rs\";\n+            alt (file_opt) {\n+                case (some[filename](?f)) {\n+                    file_path = f;\n+                }\n+                case (none[filename]) {}\n+            }\n+\n+            auto full_path = prefix + std.os.path_sep() + file_path;\n+\n+            auto p0 = new_parser(p.get_session(), 0, full_path);\n+            auto m0 = parse_mod_items(p0, token.EOF);\n+            auto im = ast.item_mod(id, m0, p.next_def_id());\n+            auto i = @spanned(cdir.span, cdir.span, im);\n+            ast.index_item(index, i);\n+            append[@ast.item](items, i);\n+        }\n+\n+        case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n+\n+            auto path = id;\n+            alt (dir_opt) {\n+                case (some[filename](?d)) {\n+                    path = d;\n+                }\n+                case (none[filename]) {}\n+            }\n+\n+            auto full_path = prefix + std.os.path_sep() + path;\n+            auto m0 = eval_crate_directives_to_mod(p, e, cdirs, path);\n+            auto im = ast.item_mod(id, m0, p.next_def_id());\n+            auto i = @spanned(cdir.span, cdir.span, im);\n+            ast.index_item(index, i);\n+            append[@ast.item](items, i);\n+        }\n+\n+        case (ast.cdir_view_item(?vi)) {\n+            append[@ast.view_item](view_items, vi);\n+            ast.index_view_item(index, vi);\n+        }\n+\n+        case (ast.cdir_meta(?mi)) {}\n+        case (ast.cdir_syntax(?pth)) {}\n+        case (ast.cdir_auth(?pth, ?eff)) {}\n+    }\n+}\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "3579a3a087fc439781d2fdc2314dc5d1ce4ebf60", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 3, "deletions": 79, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "patch": "@@ -2111,80 +2111,6 @@ impure fn parse_crate_from_source_file(parser p) -> @ast.crate {\n //\n // Each directive imperatively extends its environment with 0 or more items.\n \n-impure fn eval_crate_directives(parser p,\n-                                vec[@ast.crate_directive] cdirs,\n-                                str prefix) -> ast._mod {\n-    let vec[@ast.item] items = vec();\n-    auto index = new_str_hash[ast.mod_index_entry]();\n-    auto view_items = parse_view(p, index);\n-\n-    for (@ast.crate_directive sub_cdir in cdirs) {\n-        eval_crate_directive(p, sub_cdir, prefix,\n-                             view_items, items, index);\n-    }\n-\n-    ret rec(view_items=view_items, items=items, index=index);\n-}\n-\n-impure fn eval_crate_directive(parser p,\n-                               @ast.crate_directive cdir,\n-                               str prefix,\n-                               &mutable vec[@ast.view_item] view_items,\n-                               &mutable vec[@ast.item] items,\n-                               hashmap[ast.ident,ast.mod_index_entry] index) {\n-    alt (cdir.node) {\n-        case (ast.cdir_expr(?e)) {}\n-        case (ast.cdir_const(?i)) {}\n-\n-        case (ast.cdir_src_mod(?id, ?file_opt)) {\n-\n-            auto file_path = id + \".rs\";\n-            alt (file_opt) {\n-                case (some[filename](?f)) {\n-                    file_path = f;\n-                }\n-                case (none[filename]) {}\n-            }\n-\n-            auto full_path = prefix + std.os.path_sep() + file_path;\n-\n-            auto p0 = new_parser(p.get_session(), 0, full_path);\n-            auto m0 = parse_mod_items(p0, token.EOF);\n-            auto im = ast.item_mod(id, m0, p.next_def_id());\n-            auto i = @spanned(cdir.span, cdir.span, im);\n-            ast.index_item(index, i);\n-            append[@ast.item](items, i);\n-        }\n-\n-        case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n-\n-            auto path = id;\n-            alt (dir_opt) {\n-                case (some[filename](?d)) {\n-                    path = d;\n-                }\n-                case (none[filename]) {}\n-            }\n-\n-            auto full_path = prefix + std.os.path_sep() + path;\n-            auto m0 = eval_crate_directives(p, cdirs, path);\n-            auto im = ast.item_mod(id, m0, p.next_def_id());\n-            auto i = @spanned(cdir.span, cdir.span, im);\n-            ast.index_item(index, i);\n-            append[@ast.item](items, i);\n-        }\n-\n-        case (ast.cdir_view_item(?vi)) {\n-            append[@ast.view_item](view_items, vi);\n-            ast.index_view_item(index, vi);\n-        }\n-\n-        case (ast.cdir_meta(?mi)) {}\n-        case (ast.cdir_syntax(?pth)) {}\n-        case (ast.cdir_auth(?pth, ?eff)) {}\n-    }\n-}\n-\n impure fn parse_crate_directive(parser p) -> ast.crate_directive\n {\n     auto lo = p.get_span();\n@@ -2201,10 +2127,7 @@ impure fn parse_crate_directive(parser p) -> ast.crate_directive\n             expect(p, token.SEMI);\n             ret spanned(lo, hi, ast.cdir_auth(n, e));\n         }\n-        case (token.CONST) {\n-            auto c = parse_item_const(p);\n-            ret spanned(c.span, c.span, ast.cdir_const(c));\n-         }\n+\n         case (token.MOD) {\n             p.bump();\n             auto id = parse_ident(p);\n@@ -2267,7 +2190,8 @@ impure fn parse_crate_from_crate_file(parser p) -> @ast.crate {\n     auto hi = lo;\n     auto prefix = std.path.dirname(lo.filename);\n     auto cdirs = parse_crate_directives(p, token.EOF);\n-    auto m = eval_crate_directives(p, cdirs, prefix);\n+    auto m = eval.eval_crate_directives_to_mod(p, eval.mk_env(),\n+                                               cdirs, prefix);\n     hi = p.get_span();\n     expect(p, token.EOF);\n     ret @spanned(lo, hi, rec(module=m));"}, {"sha": "bc4aaa52c1aefc6fd3ad89b7b9df887a8d06a26b", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b2a09562a6c0683ca528c866abc1ecc99b4bdcf0/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=b2a09562a6c0683ca528c866abc1ecc99b4bdcf0", "patch": "@@ -8,6 +8,7 @@ mod front {\n     mod lexer;\n     mod parser;\n     mod token;\n+    mod eval;\n }\n \n mod middle {\n@@ -38,7 +39,6 @@ auth middle.trans.copy_args_to_allocas = impure;\n auth middle.trans.trans_block = impure;\n auth lib.llvm = unsafe;\n \n-\n mod lib {\n     alt (target_os) {\n         case (\"win32\") {"}]}