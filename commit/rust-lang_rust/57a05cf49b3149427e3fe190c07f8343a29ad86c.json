{"sha": "57a05cf49b3149427e3fe190c07f8343a29ad86c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YTA1Y2Y0OWIzMTQ5NDI3ZTNmZTE5MGMwN2Y4MzQzYTI5YWQ4NmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-30T23:17:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-30T23:17:20Z"}, "message": "auto merge of #17634 : jakub-/rust/if_let, r=kballard\n\nContinuation of https://github.com/rust-lang/rust/pull/16741.", "tree": {"sha": "e936d71b10c6f881337d44a960e1b8901cd50b38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e936d71b10c6f881337d44a960e1b8901cd50b38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57a05cf49b3149427e3fe190c07f8343a29ad86c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57a05cf49b3149427e3fe190c07f8343a29ad86c", "html_url": "https://github.com/rust-lang/rust/commit/57a05cf49b3149427e3fe190c07f8343a29ad86c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57a05cf49b3149427e3fe190c07f8343a29ad86c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d1a22f76a774b2df3c904ceb54c86e58a859c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d1a22f76a774b2df3c904ceb54c86e58a859c3", "html_url": "https://github.com/rust-lang/rust/commit/88d1a22f76a774b2df3c904ceb54c86e58a859c3"}, {"sha": "e723051a2eb840a710f2b79afc1b42b0b707d0e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e723051a2eb840a710f2b79afc1b42b0b707d0e4", "html_url": "https://github.com/rust-lang/rust/commit/e723051a2eb840a710f2b79afc1b42b0b707d0e4"}], "stats": {"total": 439, "additions": 402, "deletions": 37}, "files": [{"sha": "14fc1d8d73d6869b1d280a215bf646b30e7a835e", "filename": "src/doc/reference.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -2441,6 +2441,8 @@ The currently implemented features of the reference compiler are:\n * `default_type_params` - Allows use of default type parameters. The future of\n                           this feature is uncertain.\n \n+* `if_let` - Allows use of the `if let` syntax.\n+\n * `intrinsics` - Allows use of the \"rust-intrinsics\" ABI. Compiler intrinsics\n                  are inherently unstable and no promise about them is made.\n \n@@ -3229,7 +3231,7 @@ for i in range(0u, 256) {\n if_expr : \"if\" no_struct_literal_expr '{' block '}'\n           else_tail ? ;\n \n-else_tail : \"else\" [ if_expr\n+else_tail : \"else\" [ if_expr | if_let_expr\n                    | '{' block '}' ] ;\n ```\n \n@@ -3434,6 +3436,19 @@ let message = match maybe_digit {\n };\n ```\n \n+### If let expressions\n+\n+```{.ebnf .gram}\n+if_let_expr : \"if\" \"let\" pat '=' expr '{' block '}'\n+               else_tail ? ;\n+else_tail : \"else\" [ if_expr | if_let_expr | '{' block '}' ] ;\n+```\n+\n+An `if let` expression is semantically identical to an `if` expression but in place\n+of a condition expression it expects a refutable let statement. If the value of the\n+expression on the right hand side of the let statement matches the pattern, the corresponding\n+block will execute, otherwise flow proceeds to the first `else` block that follows.\n+\n ### Return expressions\n \n ```{.ebnf .gram}"}, {"sha": "0e85d7cc0752d8e33b8eb4c6991581ef84d21c7e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -151,5 +151,6 @@ register_diagnostics!(\n     E0157,\n     E0158,\n     E0159,\n-    E0161\n+    E0161,\n+    E0162\n )"}, {"sha": "277ecfc686b4d4e0e78371db95342417243cf478", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -1092,7 +1092,10 @@ impl LintPass for UnnecessaryParens {\n         let (value, msg, struct_lit_needs_parens) = match e.node {\n             ast::ExprIf(ref cond, _, _) => (cond, \"`if` condition\", true),\n             ast::ExprWhile(ref cond, _, _) => (cond, \"`while` condition\", true),\n-            ast::ExprMatch(ref head, _) => (head, \"`match` head expression\", true),\n+            ast::ExprMatch(ref head, _, source) => match source {\n+                ast::MatchNormal => (head, \"`match` head expression\", true),\n+                ast::MatchIfLetDesugar => (head, \"`if let` head expression\", true)\n+            },\n             ast::ExprRet(Some(ref value)) => (value, \"`return` value\", false),\n             ast::ExprAssign(_, ref value) => (value, \"assigned value\", false),\n             ast::ExprAssignOp(_, _, ref value) => (value, \"assigned value\", false),\n@@ -1242,7 +1245,7 @@ impl LintPass for UnusedMut {\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n-            ast::ExprMatch(_, ref arms) => {\n+            ast::ExprMatch(_, ref arms, _) => {\n                 for a in arms.iter() {\n                     self.check_unused_mut_pat(cx, a.pats.as_slice())\n                 }"}, {"sha": "a9a3981ab5fc8687c5006e267a53eedc062e1e40", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -222,6 +222,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.add_node(expr.id, [then_exit, else_exit])           // 4, 5\n             }\n \n+            ast::ExprIfLet(..) => {\n+                self.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+            }\n+\n             ast::ExprWhile(ref cond, ref body, _) => {\n                 //\n                 //         [pred]\n@@ -322,7 +326,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            ast::ExprMatch(ref discr, ref arms) => {\n+            ast::ExprMatch(ref discr, ref arms, _) => {\n                 //\n                 //     [pred]\n                 //       |"}, {"sha": "de9125ec44918419319650d7fac240e9a0c44f74", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -147,7 +147,7 @@ pub fn check_crate(tcx: &ty::ctxt) {\n fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n     visit::walk_expr(cx, ex);\n     match ex.node {\n-        ExprMatch(ref scrut, ref arms) => {\n+        ExprMatch(ref scrut, ref arms, source) => {\n             // First, check legality of move bindings.\n             for arm in arms.iter() {\n                 check_legality_of_move_bindings(cx,\n@@ -184,7 +184,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms.as_slice());\n+            check_arms(cx, inlined_arms.as_slice(), source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -252,13 +252,31 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pats: &[P<Pat>]) {\n }\n \n // Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)]) {\n+fn check_arms(cx: &MatchCheckCtxt, arms: &[(Vec<P<Pat>>, Option<&Expr>)], source: MatchSource) {\n     let mut seen = Matrix(vec![]);\n+    let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms.iter() {\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n+\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n-                NotUseful => span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\"),\n+                NotUseful => {\n+                    if source == MatchIfLetDesugar {\n+                        if printed_if_let_err {\n+                            // we already printed an irrefutable if-let pattern error.\n+                            // We don't want two, that's just confusing.\n+                        } else {\n+                            // find the first arm pattern so we can use its span\n+                            let &(ref first_arm_pats, _) = &arms[0];\n+                            let first_pat = first_arm_pats.get(0);\n+                            let span = first_pat.span;\n+                            span_err!(cx.tcx.sess, span, E0162, \"irrefutable if-let pattern\");\n+                            printed_if_let_err = true;\n+                        }\n+                    } else {\n+                        span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\");\n+                    }\n+                }\n                 Useful => (),\n                 UsefulWithWitness(_) => unreachable!()\n             }"}, {"sha": "51cdbfcf2514c17298ed9e49356780d805d82989", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -374,7 +374,11 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n                 }\n             }\n \n-            ast::ExprMatch(ref discr, ref arms) => {\n+            ast::ExprIfLet(..) => {\n+                self.tcx().sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+            }\n+\n+            ast::ExprMatch(ref discr, ref arms, _) => {\n                 let discr_cmt = return_if_err!(self.mc.cat_expr(&**discr));\n                 self.borrow_expr(&**discr, ty::ReEmpty, ty::ImmBorrow, MatchDiscriminant);\n "}, {"sha": "2176cd565894375db7a36c1b7f1c2ab4d2d6ca58", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -481,6 +481,9 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n+      ExprIfLet(..) => {\n+          ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+      }\n       ExprForLoop(ref pat, _, _, _) => {\n         pat_util::pat_bindings(&ir.tcx.def_map, &**pat, |bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from for loop with bm {:?}\",\n@@ -1011,6 +1014,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_expr(&**cond, ln)\n           }\n \n+          ExprIfLet(..) => {\n+              self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+          }\n+\n           ExprWhile(ref cond, ref blk, _) => {\n             self.propagate_through_loop(expr, WhileLoop(&**cond), &**blk, succ)\n           }\n@@ -1026,7 +1033,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_loop(expr, LoopLoop, &**blk, succ)\n           }\n \n-          ExprMatch(ref e, ref arms) => {\n+          ExprMatch(ref e, ref arms, _) => {\n             //\n             //      (e)\n             //       |\n@@ -1470,6 +1477,9 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprPath(..) | ExprBox(..) => {\n         visit::walk_expr(this, expr);\n       }\n+      ExprIfLet(..) => {\n+        this.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+      }\n     }\n }\n "}, {"sha": "115432873ff9aac9334b390f06a9bd9873bcd805", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -505,6 +505,10 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           ast::ExprForLoop(..) => {\n             Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n           }\n+\n+          ast::ExprIfLet(..) => {\n+            self.tcx().sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+          }\n         }\n     }\n "}, {"sha": "aada90d260e8f2f2b283d44907a78ef714b73235", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -3576,6 +3576,11 @@ fn populate_scope_map(cx: &CrateContext,\n                 }\n             }\n \n+            ast::ExprIfLet(..) => {\n+                cx.sess().span_bug(exp.span, \"debuginfo::populate_scope_map() - \\\n+                                              Found unexpanded if-let.\");\n+            }\n+\n             ast::ExprWhile(ref cond_exp, ref loop_body, _) => {\n                 walk_expr(cx, &**cond_exp, scope_stack, scope_map);\n \n@@ -3654,7 +3659,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 }\n             }\n \n-            ast::ExprMatch(ref discriminant_exp, ref arms) => {\n+            ast::ExprMatch(ref discriminant_exp, ref arms, _) => {\n                 walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n \n                 // For each arm we have to first walk the pattern as these might"}, {"sha": "eeea10e8eb0a5576855f0872ecccdace14d2122c", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -1013,7 +1013,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprIf(ref cond, ref thn, ref els) => {\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n-        ast::ExprMatch(ref discr, ref arms) => {\n+        ast::ExprMatch(ref discr, ref arms, _) => {\n             _match::trans_match(bcx, expr, &**discr, arms.as_slice(), dest)\n         }\n         ast::ExprBlock(ref blk) => {"}, {"sha": "2c11f60caf6fb19bf00b46dce79c0fa85f7a2f52", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -3635,6 +3635,10 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             RvalueDpsExpr\n         }\n \n+        ast::ExprIfLet(..) => {\n+            tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+        }\n+\n         ast::ExprLit(ref lit) if lit_is_str(&**lit) => {\n             RvalueDpsExpr\n         }"}, {"sha": "dd7b8a7e6241394db708d2df31dbf52bb37e5477", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -4106,6 +4106,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         check_then_else(fcx, &**cond, &**then_blk, opt_else_expr.as_ref().map(|e| &**e),\n                         id, expr.span, expected);\n       }\n+      ast::ExprIfLet(..) => {\n+        tcx.sess.span_bug(expr.span, \"non-desugared ExprIfLet\");\n+      }\n       ast::ExprWhile(ref cond, ref body, _) => {\n         check_expr_has_type(fcx, &**cond, ty::mk_bool());\n         check_block_no_value(fcx, &**body);\n@@ -4143,7 +4146,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprMatch(ref discrim, ref arms) => {\n+      ast::ExprMatch(ref discrim, ref arms, _) => {\n         _match::check_match(fcx, expr, &**discrim, arms.as_slice());\n       }\n       ast::ExprFnBlock(_, ref decl, ref body) => {"}, {"sha": "9e20028569bf497146335c4f758e0ef3e7a77f17", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -725,7 +725,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprMatch(ref discr, ref arms) => {\n+        ast::ExprMatch(ref discr, ref arms, _) => {\n             link_match(rcx, &**discr, arms.as_slice());\n \n             visit::walk_expr(rcx, expr);"}, {"sha": "638aea10e37952fa1bc9306ffce827e83d27b6db", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -92,6 +92,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n               ast::ExprMethodCall(..) => {\n                 explain_span(cx, \"method call\", expr.span)\n               },\n+              ast::ExprMatch(_, _, ast::MatchIfLetDesugar) => explain_span(cx, \"if let\", expr.span),\n               ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n               _ => explain_span(cx, \"expression\", expr.span)\n             }"}, {"sha": "394833372a62a71e29443b9bf5c05045ae4617be", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -293,6 +293,7 @@ mod svh_visitor {\n             ExprForLoop(..)          => SawExprForLoop,\n \n             // just syntactic artifacts, expanded away by time of SVH.\n+            ExprIfLet(..)            => unreachable!(),\n             ExprMac(..)              => unreachable!(),\n         }\n     }"}, {"sha": "59c824d0eae772d865e769504837e4a330c66916", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -521,14 +521,15 @@ pub enum Expr_ {\n     ExprLit(P<Lit>),\n     ExprCast(P<Expr>, P<Ty>),\n     ExprIf(P<Expr>, P<Block>, Option<P<Expr>>),\n+    ExprIfLet(P<Pat>, P<Expr>, P<Block>, Option<P<Expr>>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprWhile(P<Expr>, P<Block>, Option<Ident>),\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprForLoop(P<Pat>, P<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n-    ExprMatch(P<Expr>, Vec<Arm>),\n+    ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n     ExprFnBlock(CaptureClause, P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n     ExprUnboxedFn(CaptureClause, UnboxedClosureKind, P<FnDecl>, P<Block>),\n@@ -576,6 +577,12 @@ pub struct QPath {\n     pub item_name: Ident,\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum MatchSource {\n+    MatchNormal,\n+    MatchIfLetDesugar\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum CaptureClause {\n     CaptureByValue,"}, {"sha": "41b7218da0c526cdae3f308f13646a754676a80d", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -210,10 +210,10 @@ fn fold_expr(cx: &mut Context, expr: P<ast::Expr>) -> P<ast::Expr> {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n-                ast::ExprMatch(m, arms) => {\n+                ast::ExprMatch(m, arms, source) => {\n                     ast::ExprMatch(m, arms.into_iter()\n                                         .filter(|a| (cx.in_cfg)(a.attrs.as_slice()))\n-                                        .collect())\n+                                        .collect(), source)\n                 }\n                 _ => node\n             },"}, {"sha": "f2b806f43ccbbb6822fbcf0e9b37ea7a9fd18eb0", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -845,7 +845,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_match(&self, span: Span, arg: P<ast::Expr>, arms: Vec<ast::Arm>) -> P<Expr> {\n-        self.expr(span, ast::ExprMatch(arg, arms))\n+        self.expr(span, ast::ExprMatch(arg, arms, ast::MatchNormal))\n     }\n \n     fn expr_if(&self, span: Span, cond: P<ast::Expr>,"}, {"sha": "fa3ccc8cf326e369bcec8fc5845ba3dfde6b14ae", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 92, "deletions": 1, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -39,7 +39,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n-        ExprMac(mac) => {\n+        ast::ExprMac(mac) => {\n             let expanded_expr = match expand_mac_invoc(mac, span,\n                                                        |r| r.make_expr(),\n                                                        mark_expr, fld) {\n@@ -67,6 +67,97 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n         }\n \n+        // Desugar ExprIfLet\n+        // From: `if let <pat> = <expr> <body> [<elseopt>]`\n+        ast::ExprIfLet(pat, expr, body, mut elseopt) => {\n+            // to:\n+            //\n+            //   match <expr> {\n+            //     <pat> => <body>,\n+            //     [_ if <elseopt_if_cond> => <elseopt_if_body>,]\n+            //     _ => [<elseopt> | ()]\n+            //   }\n+\n+            // `<pat> => <body>`\n+            let pat_arm = {\n+                let body_expr = fld.cx.expr_block(body);\n+                fld.cx.arm(pat.span, vec![pat], body_expr)\n+            };\n+\n+            // `[_ if <elseopt_if_cond> => <elseopt_if_body>,]`\n+            let else_if_arms = {\n+                let mut arms = vec![];\n+                loop {\n+                    let elseopt_continue = elseopt\n+                        .and_then(|els| els.and_then(|els| match els.node {\n+                        // else if\n+                        ast::ExprIf(cond, then, elseopt) => {\n+                            let pat_under = fld.cx.pat_wild(span);\n+                            arms.push(ast::Arm {\n+                                attrs: vec![],\n+                                pats: vec![pat_under],\n+                                guard: Some(cond),\n+                                body: fld.cx.expr_block(then)\n+                            });\n+                            elseopt.map(|elseopt| (elseopt, true))\n+                        }\n+                        _ => Some((P(els), false))\n+                    }));\n+                    match elseopt_continue {\n+                        Some((e, true)) => {\n+                            elseopt = Some(e);\n+                        }\n+                        Some((e, false)) => {\n+                            elseopt = Some(e);\n+                            break;\n+                        }\n+                        None => {\n+                            elseopt = None;\n+                            break;\n+                        }\n+                    }\n+                }\n+                arms\n+            };\n+\n+            // `_ => [<elseopt> | ()]`\n+            let else_arm = {\n+                let pat_under = fld.cx.pat_wild(span);\n+                let else_expr = elseopt.unwrap_or_else(|| fld.cx.expr_lit(span, ast::LitNil));\n+                fld.cx.arm(span, vec![pat_under], else_expr)\n+            };\n+\n+            let mut arms = Vec::with_capacity(else_if_arms.len() + 2);\n+            arms.push(pat_arm);\n+            arms.push_all_move(else_if_arms);\n+            arms.push(else_arm);\n+\n+            let match_expr = fld.cx.expr(span, ast::ExprMatch(expr, arms, ast::MatchIfLetDesugar));\n+            fld.fold_expr(match_expr)\n+        }\n+\n+        // Desugar support for ExprIfLet in the ExprIf else position\n+        ast::ExprIf(cond, blk, elseopt) => {\n+            let elseopt = elseopt.map(|els| els.and_then(|els| match els.node {\n+                ast::ExprIfLet(..) => {\n+                    // wrap the if-let expr in a block\n+                    let span = els.span;\n+                    let blk = P(ast::Block {\n+                        view_items: vec![],\n+                        stmts: vec![],\n+                        expr: Some(P(els)),\n+                        id: ast::DUMMY_NODE_ID,\n+                        rules: ast::DefaultBlock,\n+                        span: span\n+                    });\n+                    fld.cx.expr_block(blk)\n+                }\n+                _ => P(els)\n+            }));\n+            let if_expr = fld.cx.expr(span, ast::ExprIf(cond, blk, elseopt));\n+            if_expr.map(|e| noop_fold_expr(e, fld))\n+        }\n+\n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))"}, {"sha": "ca6d488772c613b520e641fb0f7887c63250c577", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -71,6 +71,8 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"associated_types\", Active),\n     (\"visible_private_types\", Active),\n \n+    (\"if_let\", Active),\n+\n     // if you change this list without updating src/doc/rust.md, cmr will be sad\n \n     // A temporary feature gate used to enable parser extensions needed\n@@ -356,6 +358,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                   e.span,\n                                   \"tuple indexing is experimental\");\n             }\n+            ast::ExprIfLet(..) => {\n+                self.gate_feature(\"if_let\", e.span,\n+                                  \"`if let` syntax is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "31bec58a4daa6f24afd9b9c3e151fb686108c0a1", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -1205,6 +1205,12 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                        folder.fold_block(tr),\n                        fl.map(|x| folder.fold_expr(x)))\n             }\n+            ExprIfLet(pat, expr, tr, fl) => {\n+                ExprIfLet(folder.fold_pat(pat),\n+                          folder.fold_expr(expr),\n+                          folder.fold_block(tr),\n+                          fl.map(|x| folder.fold_expr(x)))\n+            }\n             ExprWhile(cond, body, opt_ident) => {\n                 ExprWhile(folder.fold_expr(cond),\n                           folder.fold_block(body),\n@@ -1220,9 +1226,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprLoop(folder.fold_block(body),\n                         opt_ident.map(|i| folder.fold_ident(i)))\n             }\n-            ExprMatch(expr, arms) => {\n+            ExprMatch(expr, arms, source) => {\n                 ExprMatch(folder.fold_expr(expr),\n-                        arms.move_map(|x| folder.fold_arm(x)))\n+                        arms.move_map(|x| folder.fold_arm(x)),\n+                        source)\n             }\n             ExprFnBlock(capture_clause, decl, body) => {\n                 ExprFnBlock(capture_clause,"}, {"sha": "cb57318445e4164c600d512ec01c5af24a8a9436", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -24,6 +24,7 @@ use ast;\n pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n     match e.node {\n         ast::ExprIf(..)\n+        | ast::ExprIfLet(..)\n         | ast::ExprMatch(..)\n         | ast::ExprBlock(_)\n         | ast::ExprWhile(..)"}, {"sha": "0780e68a06294aa67c03c2a82e142be79b964401", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -23,7 +23,7 @@ use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, Explicit\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n use ast::{ExprBreak, ExprCall, ExprCast};\n-use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIndex, ExprSlice};\n+use ast::{ExprField, ExprTupField, ExprFnBlock, ExprIf, ExprIfLet, ExprIndex, ExprSlice};\n use ast::{ExprLit, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary, ExprUnboxedFn};\n@@ -38,7 +38,7 @@ use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitNil, LitStr, LitInt, Local, LocalLet};\n-use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal};\n+use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, Matcher, MatchNonterminal, MatchNormal};\n use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n@@ -576,12 +576,11 @@ impl<'a> Parser<'a> {\n     /// If the next token is the given keyword, eat it and return\n     /// true. Otherwise, return false.\n     pub fn eat_keyword(&mut self, kw: keywords::Keyword) -> bool {\n-        match self.token {\n-            token::IDENT(sid, false) if kw.to_name() == sid.name => {\n-                self.bump();\n-                true\n-            }\n-            _ => false\n+        if self.is_keyword(kw) {\n+            self.bump();\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -2860,8 +2859,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse an 'if' expression ('if' token already eaten)\n+    /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n     pub fn parse_if_expr(&mut self) -> P<Expr> {\n+        if self.is_keyword(keywords::Let) {\n+            return self.parse_if_let_expr();\n+        }\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr_res(RestrictionNoStructLiteral);\n         let thn = self.parse_block();\n@@ -2875,6 +2877,23 @@ impl<'a> Parser<'a> {\n         self.mk_expr(lo, hi, ExprIf(cond, thn, els))\n     }\n \n+    /// Parse an 'if let' expression ('if' token already eaten)\n+    pub fn parse_if_let_expr(&mut self) -> P<Expr> {\n+        let lo = self.last_span.lo;\n+        self.expect_keyword(keywords::Let);\n+        let pat = self.parse_pat();\n+        self.expect(&token::EQ);\n+        let expr = self.parse_expr_res(RestrictionNoStructLiteral);\n+        let thn = self.parse_block();\n+        let (hi, els) = if self.eat_keyword(keywords::Else) {\n+            let expr = self.parse_else_expr();\n+            (expr.span.hi, Some(expr))\n+        } else {\n+            (thn.span.hi, None)\n+        };\n+        self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els))\n+    }\n+\n     // `|args| expr`\n     pub fn parse_lambda_expr(&mut self, capture_clause: CaptureClause)\n                              -> P<Expr> {\n@@ -2956,7 +2975,7 @@ impl<'a> Parser<'a> {\n         }\n         let hi = self.span.hi;\n         self.bump();\n-        return self.mk_expr(lo, hi, ExprMatch(discriminant, arms));\n+        return self.mk_expr(lo, hi, ExprMatch(discriminant, arms, MatchNormal));\n     }\n \n     pub fn parse_arm(&mut self) -> Arm {"}, {"sha": "a8e99b4e85f2bd36db5ca49e4e866962d6fb4ea3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -1307,6 +1307,19 @@ impl<'a> State<'a> {\n                         try!(self.print_block(&**then));\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n+                    // \"another else-if-let\"\n+                    ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n+                        try!(self.cbox(indent_unit - 1u));\n+                        try!(self.ibox(0u));\n+                        try!(word(&mut self.s, \" else if let \"));\n+                        try!(self.print_pat(&**pat));\n+                        try!(space(&mut self.s));\n+                        try!(self.word_space(\"=\"));\n+                        try!(self.print_expr(&**expr));\n+                        try!(space(&mut self.s));\n+                        try!(self.print_block(&**then));\n+                        self.print_else(e.as_ref().map(|e| &**e))\n+                    }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n                         try!(self.cbox(indent_unit - 1u));\n@@ -1325,15 +1338,26 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_if(&mut self, test: &ast::Expr, blk: &ast::Block,\n-                    elseopt: Option<&ast::Expr>, chk: bool) -> IoResult<()> {\n+                    elseopt: Option<&ast::Expr>) -> IoResult<()> {\n         try!(self.head(\"if\"));\n-        if chk { try!(self.word_nbsp(\"check\")); }\n         try!(self.print_expr(test));\n         try!(space(&mut self.s));\n         try!(self.print_block(blk));\n         self.print_else(elseopt)\n     }\n \n+    pub fn print_if_let(&mut self, pat: &ast::Pat, expr: &ast::Expr, blk: &ast::Block,\n+                        elseopt: Option<&ast::Expr>) -> IoResult<()> {\n+        try!(self.head(\"if let\"));\n+        try!(self.print_pat(pat));\n+        try!(space(&mut self.s));\n+        try!(self.word_space(\"=\"));\n+        try!(self.print_expr(expr));\n+        try!(space(&mut self.s));\n+        try!(self.print_block(blk));\n+        self.print_else(elseopt)\n+    }\n+\n     pub fn print_mac(&mut self, m: &ast::Mac) -> IoResult<()> {\n         match m.node {\n             // I think it's reasonable to hide the ctxt here:\n@@ -1474,7 +1498,10 @@ impl<'a> State<'a> {\n                 try!(self.print_type(&**ty));\n             }\n             ast::ExprIf(ref test, ref blk, ref elseopt) => {\n-                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e), false));\n+                try!(self.print_if(&**test, &**blk, elseopt.as_ref().map(|e| &**e)));\n+            }\n+            ast::ExprIfLet(ref pat, ref expr, ref blk, ref elseopt) => {\n+                try!(self.print_if_let(&**pat, &**expr, &** blk, elseopt.as_ref().map(|e| &**e)));\n             }\n             ast::ExprWhile(ref test, ref blk, opt_ident) => {\n                 for ident in opt_ident.iter() {\n@@ -1508,7 +1535,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.print_block(&**blk));\n             }\n-            ast::ExprMatch(ref expr, ref arms) => {\n+            ast::ExprMatch(ref expr, ref arms, _) => {\n                 try!(self.cbox(indent_unit));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));"}, {"sha": "6fc79e2c42ab9f2bff799a8e5fbabe2c96c5bd4d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -730,13 +730,19 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(&**subexpression);\n             visitor.visit_block(&**block)\n         }\n+        ExprIfLet(ref pattern, ref subexpression, ref if_block, ref optional_else) => {\n+            visitor.visit_pat(&**pattern);\n+            visitor.visit_expr(&**subexpression);\n+            visitor.visit_block(&**if_block);\n+            walk_expr_opt(visitor, optional_else);\n+        }\n         ExprForLoop(ref pattern, ref subexpression, ref block, _) => {\n             visitor.visit_pat(&**pattern);\n             visitor.visit_expr(&**subexpression);\n             visitor.visit_block(&**block)\n         }\n         ExprLoop(ref block, _) => visitor.visit_block(&**block),\n-        ExprMatch(ref subexpression, ref arms) => {\n+        ExprMatch(ref subexpression, ref arms, _) => {\n             visitor.visit_expr(&**subexpression);\n             for arm in arms.iter() {\n                 visitor.visit_arm(arm)"}, {"sha": "b82fb7a94c95f2e062cb5b8ada5f961854b7aec2", "filename": "src/test/compile-fail/if-let.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Ftest%2Fcompile-fail%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Ftest%2Fcompile-fail%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-let.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(macro_rules,if_let)]\n+\n+fn macros() {\n+    macro_rules! foo{\n+        ($p:pat, $e:expr, $b:block) => {{\n+            if let $p = $e $b\n+        }}\n+    }\n+    macro_rules! bar{\n+        ($p:pat, $e:expr, $b:block) => {{\n+            foo!($p, $e, $b)\n+        }}\n+    }\n+\n+    foo!(a, 1i, { //~ ERROR irrefutable if-let\n+        println!(\"irrefutable pattern\");\n+    });\n+    bar!(a, 1i, { //~ ERROR irrefutable if-let\n+        println!(\"irrefutable pattern\");\n+    });\n+}\n+\n+pub fn main() {\n+    if let a = 1i { //~ ERROR irrefutable if-let\n+        println!(\"irrefutable pattern\");\n+    }\n+\n+    if let a = 1i { //~ ERROR irrefutable if-let\n+        println!(\"irrefutable pattern\");\n+    } else if true {\n+        println!(\"else-if in irrefutable if-let\");\n+    } else {\n+        println!(\"else in irrefutable if-let\");\n+    }\n+\n+    if let 1i = 2i {\n+        println!(\"refutable pattern\");\n+    } else if let a = 1i { //~ ERROR irrefutable if-let\n+        println!(\"irrefutable pattern\");\n+    }\n+\n+    if true {\n+        println!(\"if\");\n+    } else if let a = 1i { //~ ERROR irrefutable if-let\n+        println!(\"irrefutable pattern\");\n+    }\n+}"}, {"sha": "3c962ebf21670190f429673cffe059865a093622", "filename": "src/test/compile-fail/lint-unnecessary-parens.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-parens.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![deny(unnecessary_parens)]\n+#![feature(if_let)]\n \n #[deriving(Eq, PartialEq)]\n struct X { y: bool }\n@@ -32,6 +33,7 @@ fn main() {\n     match (true) { //~ ERROR unnecessary parentheses around `match` head expression\n         _ => {}\n     }\n+    if let 1i = (1i) {} //~ ERROR unnecessary parentheses around `if let` head expression\n     let v = X { y: false };\n     // struct lits needs parens, so these shouldn't warn.\n     if (v == X { y: true }) {}"}, {"sha": "4bf3a85677c7216f13b9161f5c66f409fa006ad9", "filename": "src/test/run-pass/if-let.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Ftest%2Frun-pass%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57a05cf49b3149427e3fe190c07f8343a29ad86c/src%2Ftest%2Frun-pass%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-let.rs?ref=57a05cf49b3149427e3fe190c07f8343a29ad86c", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(if_let)]\n+\n+pub fn main() {\n+    let x = Some(3i);\n+    if let Some(y) = x {\n+        assert_eq!(y, 3i);\n+    } else {\n+        fail!(\"if-let failed\");\n+    }\n+    let mut worked = false;\n+    if let Some(_) = x {\n+        worked = true;\n+    }\n+    assert!(worked);\n+    let clause: uint;\n+    if let None = Some(\"test\") {\n+        clause = 1;\n+    } else if 4u > 5 {\n+        clause = 2;\n+    } else if let Ok(()) = Err::<(),&'static str>(\"test\") {\n+        clause = 3;\n+    } else {\n+        clause = 4;\n+    }\n+    assert_eq!(clause, 4u);\n+\n+    if 3i > 4 {\n+        fail!(\"bad math\");\n+    } else if let 1 = 2i {\n+        fail!(\"bad pattern match\");\n+    }\n+\n+    enum Foo {\n+        One,\n+        Two(uint),\n+        Three(String, int)\n+    }\n+\n+    let foo = Three(\"three\".to_string(), 42i);\n+    if let One = foo {\n+        fail!(\"bad pattern match\");\n+    } else if let Two(_x) = foo {\n+        fail!(\"bad pattern match\");\n+    } else if let Three(s, _) = foo {\n+        assert_eq!(s.as_slice(), \"three\");\n+    } else {\n+        fail!(\"bad else\");\n+    }\n+\n+    if false {\n+        fail!(\"wat\");\n+    } else if let a@Two(_) = Two(42u) {\n+        if let Two(b) = a {\n+            assert_eq!(b, 42u);\n+        } else {\n+            fail!(\"fail in nested if-let\");\n+        }\n+    }\n+}"}]}