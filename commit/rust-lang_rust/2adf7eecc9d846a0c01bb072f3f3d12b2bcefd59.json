{"sha": "2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZGY3ZWVjYzlkODQ2YTBjMDFiYjA3MmYzZjNkMTJiMmJjZWZkNTk=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-10-27T19:32:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-27T19:32:47Z"}, "message": "Merge pull request #2091 from topecongiro/issue-2056\n\nAdd local dependencies to targets", "tree": {"sha": "119765b1321b10f6ad3757708a2f02e023ca5936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/119765b1321b10f6ad3757708a2f02e023ca5936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJZ84nfCRBK7hj4Ov3rIwAAdHIIABzhOZsEyvkaikaCyPNASCXj\nCIo5DDy7d8vMJ+uzxwf2EXsWVvRdWQi6ySpWj9TeW9QAhPXixC5E6EH+gozDPhkT\njwFm/v7ORDdU+wESsH7kYep+Uz+RRcXPOJxVC3H2L962jvZVWVrEpnACs6OeNgxL\nVMEJyVC4AgerYYLVHnEuSpKCxWMR+gbS+ZwmwWOakz7PRs/2M/nDwxMae7hzbWNT\n7KdTvmaThjW54BAxuhMDh/aPAwLfnbCIRiVcbran2VUWgGDNjHjrq4hOuXj2JYFx\nneab3BIcN7jVOqVqQpvo6LbZAB/9X8ytC3TBevrxJxnpPePj4My830+CU2jM8PE=\n=uVqC\n-----END PGP SIGNATURE-----\n", "payload": "tree 119765b1321b10f6ad3757708a2f02e023ca5936\nparent 90b3222adb2c6e9980225a142236fbe687d0817a\nparent d10df701388dead9c46a1fc0714b4b2b578db4ec\nauthor Nick Cameron <nrc@ncameron.org> 1509132767 +1300\ncommitter GitHub <noreply@github.com> 1509132767 +1300\n\nMerge pull request #2091 from topecongiro/issue-2056\n\nAdd local dependencies to targets"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59", "html_url": "https://github.com/rust-lang/rust/commit/2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90b3222adb2c6e9980225a142236fbe687d0817a", "url": "https://api.github.com/repos/rust-lang/rust/commits/90b3222adb2c6e9980225a142236fbe687d0817a", "html_url": "https://github.com/rust-lang/rust/commit/90b3222adb2c6e9980225a142236fbe687d0817a"}, {"sha": "d10df701388dead9c46a1fc0714b4b2b578db4ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10df701388dead9c46a1fc0714b4b2b578db4ec", "html_url": "https://github.com/rust-lang/rust/commit/d10df701388dead9c46a1fc0714b4b2b578db4ec"}], "stats": {"total": 242, "additions": 149, "deletions": 93}, "files": [{"sha": "10d08ff7d19d6fba89a7fa6dab13620c910aabce", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 149, "deletions": 93, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=2adf7eecc9d846a0c01bb072f3f3d12b2bcefd59", "patch": "@@ -17,7 +17,7 @@ extern crate getopts;\n extern crate serde_json as json;\n \n use std::env;\n-use std::io::Write;\n+use std::io::{self, Write};\n use std::path::PathBuf;\n use std::process::{Command, ExitStatus};\n use std::str;\n@@ -126,7 +126,7 @@ pub enum Verbosity {\n fn format_crate(\n     verbosity: Verbosity,\n     workspace_hitlist: &WorkspaceHitlist,\n-) -> Result<ExitStatus, std::io::Error> {\n+) -> Result<ExitStatus, io::Error> {\n     let targets = get_targets(workspace_hitlist)?;\n \n     // Currently only bin and lib files get formatted\n@@ -180,6 +180,29 @@ pub struct Target {\n     kind: TargetKind,\n }\n \n+impl Target {\n+    pub fn from_json(json_val: &Value) -> Option<Self> {\n+        let jtarget = json_val.as_object()?;\n+        let path = PathBuf::from(jtarget.get(\"src_path\")?.as_str()?);\n+        let kinds = jtarget.get(\"kind\")?.as_array()?;\n+        let kind = match kinds[0].as_str()? {\n+            \"bin\" => TargetKind::Bin,\n+            \"lib\" | \"dylib\" | \"staticlib\" | \"cdylib\" | \"rlib\" => TargetKind::Lib,\n+            \"test\" => TargetKind::Test,\n+            \"example\" => TargetKind::Example,\n+            \"bench\" => TargetKind::Bench,\n+            \"custom-build\" => TargetKind::CustomBuild,\n+            \"proc-macro\" => TargetKind::ProcMacro,\n+            _ => TargetKind::Other,\n+        };\n+\n+        Some(Target {\n+            path: path,\n+            kind: kind,\n+        })\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq)]\n pub enum WorkspaceHitlist {\n     All,\n@@ -205,121 +228,154 @@ impl WorkspaceHitlist {\n     }\n }\n \n-// Returns a vector of all compile targets of a crate\n-fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, std::io::Error> {\n+fn get_cargo_metadata_from_utf8(v: &[u8]) -> Option<Value> {\n+    json::from_str(str::from_utf8(v).ok()?).ok()\n+}\n+\n+fn get_json_array_with<'a>(v: &'a Value, key: &str) -> Option<&'a Vec<Value>> {\n+    v.as_object()?.get(key)?.as_array()\n+}\n+\n+// `cargo metadata --no-deps | jq '.[\"packages\"]'`\n+fn get_packages(v: &[u8]) -> Result<Vec<Value>, io::Error> {\n+    let e = io::Error::new(\n+        io::ErrorKind::NotFound,\n+        String::from(\"`cargo metadata` returned json without a 'packages' key\"),\n+    );\n+    match get_cargo_metadata_from_utf8(v) {\n+        Some(ref json_obj) => get_json_array_with(json_obj, \"packages\").cloned().ok_or(e),\n+        None => Err(e),\n+    }\n+}\n+\n+fn extract_target_from_package(package: &Value) -> Option<Vec<Target>> {\n+    let jtargets = get_json_array_with(package, \"targets\")?;\n     let mut targets: Vec<Target> = vec![];\n-    if *workspace_hitlist == WorkspaceHitlist::None {\n-        let output = Command::new(\"cargo\").arg(\"read-manifest\").output()?;\n-        if output.status.success() {\n-            // None of the unwraps should fail if output of `cargo read-manifest` is correct\n-            let data = &String::from_utf8(output.stdout).unwrap();\n-            let json: Value = json::from_str(data).unwrap();\n-            let json_obj = json.as_object().unwrap();\n-            let jtargets = json_obj.get(\"targets\").unwrap().as_array().unwrap();\n-            for jtarget in jtargets {\n-                targets.push(target_from_json(jtarget));\n-            }\n+    for jtarget in jtargets {\n+        targets.push(Target::from_json(&jtarget)?);\n+    }\n+    Some(targets)\n+}\n \n-            return Ok(targets);\n+fn filter_packages_with_hitlist<'a>(\n+    packages: Vec<Value>,\n+    workspace_hitlist: &'a WorkspaceHitlist,\n+) -> Result<Vec<Value>, &'a String> {\n+    if *workspace_hitlist == WorkspaceHitlist::All {\n+        return Ok(packages);\n+    }\n+    let mut hitlist: HashSet<&String> = workspace_hitlist\n+        .get_some()\n+        .map_or(HashSet::new(), HashSet::from_iter);\n+    let members: Vec<Value> = packages\n+        .into_iter()\n+        .filter(|member| {\n+            member\n+                .as_object()\n+                .and_then(|member_obj| {\n+                    member_obj\n+                        .get(\"name\")\n+                        .and_then(Value::as_str)\n+                        .map(|member_name| {\n+                            hitlist.take(&member_name.to_string()).is_some()\n+                        })\n+                })\n+                .unwrap_or(false)\n+        })\n+        .collect();\n+    if hitlist.is_empty() {\n+        Ok(members)\n+    } else {\n+        Err(hitlist.into_iter().next().unwrap())\n+    }\n+}\n+\n+fn get_dependencies_from_package(package: &Value) -> Option<Vec<PathBuf>> {\n+    let jdependencies = get_json_array_with(package, \"dependencies\")?;\n+    let root_path = env::current_dir().ok()?;\n+    let mut dependencies: Vec<PathBuf> = vec![];\n+    for jdep in jdependencies {\n+        let jdependency = jdep.as_object()?;\n+        if !jdependency.get(\"source\")?.is_null() {\n+            continue;\n         }\n-        return Err(std::io::Error::new(\n-            std::io::ErrorKind::NotFound,\n-            str::from_utf8(&output.stderr).unwrap(),\n-        ));\n+        let name = jdependency.get(\"name\")?.as_str()?;\n+        let mut path = root_path.clone();\n+        path.push(&name);\n+        dependencies.push(path);\n     }\n-    // This happens when cargo-fmt is not used inside a crate or\n-    // is used inside a workspace.\n-    // To ensure backward compatability, we only use `cargo metadata` for workspaces.\n-    // TODO: Is it possible only use metadata or read-manifest\n+    Some(dependencies)\n+}\n+\n+// Returns a vector of local dependencies under this crate\n+fn get_path_to_local_dependencies(packages: &[Value]) -> Vec<PathBuf> {\n+    let mut local_dependencies: Vec<PathBuf> = vec![];\n+    for package in packages {\n+        if let Some(mut d) = get_dependencies_from_package(package) {\n+            local_dependencies.append(&mut d);\n+        }\n+    }\n+    local_dependencies\n+}\n+\n+// Returns a vector of all compile targets of a crate\n+fn get_targets(workspace_hitlist: &WorkspaceHitlist) -> Result<Vec<Target>, io::Error> {\n     let output = Command::new(\"cargo\")\n-        .arg(\"metadata\")\n-        .arg(\"--no-deps\")\n+        .args(&[\"metadata\", \"--no-deps\", \"--format-version=1\"])\n         .output()?;\n     if output.status.success() {\n-        let data = &String::from_utf8(output.stdout).unwrap();\n-        let json: Value = json::from_str(data).unwrap();\n-        let json_obj = json.as_object().unwrap();\n-        let mut hitlist: HashSet<&String> = if *workspace_hitlist != WorkspaceHitlist::All {\n-            HashSet::from_iter(workspace_hitlist.get_some().unwrap())\n-        } else {\n-            HashSet::new() // Unused\n-        };\n-        let members: Vec<&Value> = json_obj\n-            .get(\"packages\")\n-            .unwrap()\n-            .as_array()\n-            .unwrap()\n-            .into_iter()\n-            .filter(|member| if *workspace_hitlist == WorkspaceHitlist::All {\n-                true\n-            } else {\n-                let member_obj = member.as_object().unwrap();\n-                let member_name = member_obj.get(\"name\").unwrap().as_str().unwrap();\n-                hitlist.take(&member_name.to_string()).is_some()\n-            })\n-            .collect();\n-        if !hitlist.is_empty() {\n-            // Mimick cargo of only outputting one <package> spec.\n-            return Err(std::io::Error::new(\n-                std::io::ErrorKind::InvalidInput,\n-                format!(\n-                    \"package `{}` is not a member of the workspace\",\n-                    hitlist.iter().next().unwrap()\n-                ),\n-            ));\n+        let cur_dir = env::current_dir()?;\n+        let mut targets: Vec<Target> = vec![];\n+        let packages = get_packages(&output.stdout)?;\n+\n+        // If we can find any local dependencies, we will try to get targets from those as well.\n+        for path in get_path_to_local_dependencies(&packages) {\n+            env::set_current_dir(path)?;\n+            targets.append(&mut get_targets(workspace_hitlist)?);\n         }\n-        for member in members {\n-            let member_obj = member.as_object().unwrap();\n-            let jtargets = member_obj.get(\"targets\").unwrap().as_array().unwrap();\n-            for jtarget in jtargets {\n-                targets.push(target_from_json(jtarget));\n+\n+        env::set_current_dir(cur_dir)?;\n+        match filter_packages_with_hitlist(packages, workspace_hitlist) {\n+            Ok(packages) => {\n+                for package in packages {\n+                    if let Some(mut target) = extract_target_from_package(&package) {\n+                        targets.append(&mut target);\n+                    }\n+                }\n+                Ok(targets)\n+            }\n+            Err(package) => {\n+                // Mimick cargo of only outputting one <package> spec.\n+                Err(io::Error::new(\n+                    io::ErrorKind::InvalidInput,\n+                    format!(\"package `{}` is not a member of the workspace\", package),\n+                ))\n             }\n         }\n-        return Ok(targets);\n-    }\n-    Err(std::io::Error::new(\n-        std::io::ErrorKind::NotFound,\n-        str::from_utf8(&output.stderr).unwrap(),\n-    ))\n-}\n-\n-fn target_from_json(jtarget: &Value) -> Target {\n-    let jtarget = jtarget.as_object().unwrap();\n-    let path = PathBuf::from(jtarget.get(\"src_path\").unwrap().as_str().unwrap());\n-    let kinds = jtarget.get(\"kind\").unwrap().as_array().unwrap();\n-    let kind = match kinds[0].as_str().unwrap() {\n-        \"bin\" => TargetKind::Bin,\n-        \"lib\" | \"dylib\" | \"staticlib\" | \"cdylib\" | \"rlib\" => TargetKind::Lib,\n-        \"test\" => TargetKind::Test,\n-        \"example\" => TargetKind::Example,\n-        \"bench\" => TargetKind::Bench,\n-        \"custom-build\" => TargetKind::CustomBuild,\n-        \"proc-macro\" => TargetKind::ProcMacro,\n-        _ => TargetKind::Other,\n-    };\n-\n-    Target {\n-        path: path,\n-        kind: kind,\n+    } else {\n+        Err(io::Error::new(\n+            io::ErrorKind::NotFound,\n+            str::from_utf8(&output.stderr).unwrap(),\n+        ))\n     }\n }\n \n fn format_files(\n     files: &[PathBuf],\n     fmt_args: &[String],\n     verbosity: Verbosity,\n-) -> Result<ExitStatus, std::io::Error> {\n+) -> Result<ExitStatus, io::Error> {\n     let stdout = if verbosity == Verbosity::Quiet {\n         std::process::Stdio::null()\n     } else {\n         std::process::Stdio::inherit()\n     };\n     if verbosity == Verbosity::Verbose {\n         print!(\"rustfmt\");\n-        for a in fmt_args.iter() {\n+        for a in fmt_args {\n             print!(\" {}\", a);\n         }\n-        for f in files.iter() {\n+        for f in files {\n             print!(\" {}\", f.display());\n         }\n         println!(\"\");\n@@ -330,8 +386,8 @@ fn format_files(\n         .args(fmt_args)\n         .spawn()\n         .map_err(|e| match e.kind() {\n-            std::io::ErrorKind::NotFound => std::io::Error::new(\n-                std::io::ErrorKind::Other,\n+            io::ErrorKind::NotFound => io::Error::new(\n+                io::ErrorKind::Other,\n                 \"Could not run rustfmt, please make sure it is in your PATH.\",\n             ),\n             _ => e,"}]}