{"sha": "594b05dd9786c09c916745c1b1c281a3c54cdbd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NGIwNWRkOTc4NmMwOWM5MTY3NDVjMWIxYzI4MWEzYzU0Y2RiZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-17T09:48:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-17T09:48:10Z"}, "message": "Auto merge of #51425 - QuietMisdreavus:thats-def-a-namespace-there, r=petrochenkov\n\nrefactor: create multiple HIR items for imports\n\nWhen lowering `use` statements into HIR, they get a `Def` of the thing they're pointing at. This is great for things that need to know what was just pulled into scope. However, this is a bit misleading, because a `use` statement can pull things from multiple namespaces if their names collide. This is a problem for rustdoc, because if there are a module and a function with the same name (for example) then it will only document the module import, because that's that the lowered `use` statement points to.\n\nThe current version of this PR does the following:\n\n* Whenever the resolver comes across a `use` statement, it loads the definitions into a new `import_map` instead of the existing `def_map`. This keeps the resolutions per-namespace so that all the target definitions are available.\n* When lowering `use` statements, it looks up the resolutions in the `import_map` and creates multiple `Item`s if there is more than one resolution.\n* To ensure the `NodeId`s are properly tracked in the lowered module, they need to be created in the AST, and pulled out as needed if multiple resolutions are available.\n\nFixes https://github.com/rust-lang/rust/issues/34843", "tree": {"sha": "2b277ef34c86f1d97de5494eb492218c26fa5c25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b277ef34c86f1d97de5494eb492218c26fa5c25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/594b05dd9786c09c916745c1b1c281a3c54cdbd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/594b05dd9786c09c916745c1b1c281a3c54cdbd1", "html_url": "https://github.com/rust-lang/rust/commit/594b05dd9786c09c916745c1b1c281a3c54cdbd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/594b05dd9786c09c916745c1b1c281a3c54cdbd1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/aec00f97e1cdcea2b079e209a7e759201ba6ca7c", "html_url": "https://github.com/rust-lang/rust/commit/aec00f97e1cdcea2b079e209a7e759201ba6ca7c"}, {"sha": "903e2c8afe6907b8828202345f2677a8e14f78fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/903e2c8afe6907b8828202345f2677a8e14f78fa", "html_url": "https://github.com/rust-lang/rust/commit/903e2c8afe6907b8828202345f2677a8e14f78fa"}], "stats": {"total": 287, "additions": 220, "deletions": 67}, "files": [{"sha": "fd14be592be303fe0749b57b9f3e41cd600c2da0", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -16,6 +16,8 @@ use syntax_pos::Span;\n use hir;\n use ty;\n \n+use self::Namespace::*;\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum CtorKind {\n     /// Constructor function automatically created by a tuple struct/variant.\n@@ -116,13 +118,83 @@ impl PathResolution {\n     }\n }\n \n+/// Different kinds of symbols don't influence each other.\n+///\n+/// Therefore, they have a separate universe (namespace).\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum Namespace {\n+    TypeNS,\n+    ValueNS,\n+    MacroNS,\n+}\n+\n+/// Just a helper \u2012 separate structure for each namespace.\n+#[derive(Copy, Clone, Default, Debug)]\n+pub struct PerNS<T> {\n+    pub value_ns: T,\n+    pub type_ns: T,\n+    pub macro_ns: T,\n+}\n+\n+impl<T> PerNS<T> {\n+    pub fn map<U, F: FnMut(T) -> U>(self, mut f: F) -> PerNS<U> {\n+        PerNS {\n+            value_ns: f(self.value_ns),\n+            type_ns: f(self.type_ns),\n+            macro_ns: f(self.macro_ns),\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n+    type Output = T;\n+    fn index(&self, ns: Namespace) -> &T {\n+        match ns {\n+            ValueNS => &self.value_ns,\n+            TypeNS => &self.type_ns,\n+            MacroNS => &self.macro_ns,\n+        }\n+    }\n+}\n+\n+impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n+    fn index_mut(&mut self, ns: Namespace) -> &mut T {\n+        match ns {\n+            ValueNS => &mut self.value_ns,\n+            TypeNS => &mut self.type_ns,\n+            MacroNS => &mut self.macro_ns,\n+        }\n+    }\n+}\n+\n+impl<T> PerNS<Option<T>> {\n+    /// Returns whether all the items in this collection are `None`.\n+    pub fn is_empty(&self) -> bool {\n+        self.type_ns.is_none() && self.value_ns.is_none() && self.macro_ns.is_none()\n+    }\n+\n+    /// Returns an iterator over the items which are `Some`.\n+    pub fn present_items(self) -> impl Iterator<Item=T> {\n+        use std::iter::once;\n+\n+        once(self.type_ns)\n+            .chain(once(self.value_ns))\n+            .chain(once(self.macro_ns))\n+            .filter_map(|it| it)\n+    }\n+}\n+\n /// Definition mapping\n pub type DefMap = NodeMap<PathResolution>;\n \n /// This is the replacement export map. It maps a module to all of the exports\n /// within.\n pub type ExportMap = DefIdMap<Vec<Export>>;\n \n+/// Map used to track the `use` statements within a scope, matching it with all the items in every\n+/// namespace.\n+pub type ImportMap = NodeMap<PerNS<Option<PathResolution>>>;\n+\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Export {\n     /// The name of the target."}, {"sha": "f31af7785a55bb4678acfcb778f3bf6b9259111d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 85, "deletions": 10, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -45,7 +45,7 @@ use hir;\n use hir::HirVec;\n use hir::map::{DefKey, DefPathData, Definitions};\n use hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use hir::def::{Def, PathResolution};\n+use hir::def::{Def, PathResolution, PerNS};\n use lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES};\n use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -152,6 +152,9 @@ pub trait Resolver {\n     /// Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n+    /// Obtain the possible resolutions for the given `use` statement.\n+    fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>>;\n+\n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     /// This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n@@ -571,6 +574,15 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n+    fn expect_full_def_from_use(&mut self, id: NodeId) -> impl Iterator<Item=Def> {\n+        self.resolver.get_import(id).present_items().map(|pr| {\n+            if pr.unresolved_segments() != 0 {\n+                bug!(\"path not fully resolved: {:?}\", pr);\n+            }\n+            pr.base_def()\n+        })\n+    }\n+\n     fn diagnostic(&self) -> &errors::Handler {\n         self.sess.diagnostic()\n     }\n@@ -1532,13 +1544,13 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_path_extra(\n         &mut self,\n-        id: NodeId,\n+        def: Def,\n         p: &Path,\n         name: Option<Name>,\n         param_mode: ParamMode,\n     ) -> hir::Path {\n         hir::Path {\n-            def: self.expect_full_def(id),\n+            def,\n             segments: p.segments\n                 .iter()\n                 .map(|segment| {\n@@ -1558,7 +1570,8 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path {\n-        self.lower_path_extra(id, p, None, param_mode)\n+        let def = self.expect_full_def(id);\n+        self.lower_path_extra(def, p, None, param_mode)\n     }\n \n     fn lower_path_segment(\n@@ -2363,7 +2376,7 @@ impl<'a> LoweringContext<'a> {\n         let path = &tree.prefix;\n \n         match tree.kind {\n-            UseTreeKind::Simple(rename) => {\n+            UseTreeKind::Simple(rename, id1, id2) => {\n                 *name = tree.ident().name;\n \n                 // First apply the prefix to the path\n@@ -2387,7 +2400,58 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n \n-                let path = P(self.lower_path(id, &path, ParamMode::Explicit));\n+                let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n+                let mut defs = self.expect_full_def_from_use(id);\n+                // we want to return *something* from this function, so hang onto the first item\n+                // for later\n+                let mut ret_def = defs.next().unwrap_or(Def::Err);\n+\n+                for (def, &new_node_id) in defs.zip([id1, id2].iter()) {\n+                    let vis = vis.clone();\n+                    let name = name.clone();\n+                    let span = path.span;\n+                    self.resolver.definitions().create_def_with_parent(\n+                        parent_def_index,\n+                        new_node_id,\n+                        DefPathData::Misc,\n+                        DefIndexAddressSpace::High,\n+                        Mark::root(),\n+                        span);\n+                    self.allocate_hir_id_counter(new_node_id, &path);\n+\n+                    self.with_hir_id_owner(new_node_id, |this| {\n+                        let new_id = this.lower_node_id(new_node_id);\n+                        let path = this.lower_path_extra(def, &path, None, ParamMode::Explicit);\n+                        let item = hir::ItemUse(P(path), hir::UseKind::Single);\n+                        let vis = match vis {\n+                            hir::Visibility::Public => hir::Visibility::Public,\n+                            hir::Visibility::Crate(sugar) => hir::Visibility::Crate(sugar),\n+                            hir::Visibility::Inherited => hir::Visibility::Inherited,\n+                            hir::Visibility::Restricted { ref path, id: _ } => {\n+                                hir::Visibility::Restricted {\n+                                    path: path.clone(),\n+                                    // We are allocating a new NodeId here\n+                                    id: this.next_id().node_id,\n+                                }\n+                            }\n+                        };\n+\n+                        this.items.insert(\n+                            new_id.node_id,\n+                            hir::Item {\n+                                id: new_id.node_id,\n+                                hir_id: new_id.hir_id,\n+                                name: name,\n+                                attrs: attrs.clone(),\n+                                node: item,\n+                                vis,\n+                                span,\n+                            },\n+                        );\n+                    });\n+                }\n+\n+                let path = P(self.lower_path_extra(ret_def, &path, None, ParamMode::Explicit));\n                 hir::ItemUse(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n@@ -2654,7 +2718,7 @@ impl<'a> LoweringContext<'a> {\n         match i.node {\n             ItemKind::Use(ref use_tree) => {\n                 let mut vec = SmallVector::one(hir::ItemId { id: i.id });\n-                self.lower_item_id_use_tree(use_tree, &mut vec);\n+                self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n                 return vec;\n             }\n             ItemKind::MacroDef(..) => return SmallVector::new(),\n@@ -2663,14 +2727,25 @@ impl<'a> LoweringContext<'a> {\n         SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n-    fn lower_item_id_use_tree(&self, tree: &UseTree, vec: &mut SmallVector<hir::ItemId>) {\n+    fn lower_item_id_use_tree(&mut self,\n+                              tree: &UseTree,\n+                              base_id: NodeId,\n+                              vec: &mut SmallVector<hir::ItemId>)\n+    {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => for &(ref nested, id) in nested_vec {\n                 vec.push(hir::ItemId { id });\n-                self.lower_item_id_use_tree(nested, vec);\n+                self.lower_item_id_use_tree(nested, id, vec);\n             },\n             UseTreeKind::Glob => {}\n-            UseTreeKind::Simple(..) => {}\n+            UseTreeKind::Simple(_, id1, id2) => {\n+                for (_, &id) in self.expect_full_def_from_use(base_id)\n+                                    .skip(1)\n+                                    .zip([id1, id2].iter())\n+                {\n+                    vec.push(hir::ItemId { id });\n+                }\n+            },\n         }\n     }\n "}, {"sha": "81b4ae3f6e8dbeda758eb2f66bc4a2071a2986c3", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -393,7 +393,7 @@ impl UnusedImportBraces {\n             // Trigger the lint if the nested item is a non-self single item\n             let node_ident;\n             match items[0].0.kind {\n-                ast::UseTreeKind::Simple(rename) => {\n+                ast::UseTreeKind::Simple(rename, ..) => {\n                     let orig_ident = items[0].0.prefix.segments.last().unwrap().ident;\n                     if orig_ident.name == keywords::SelfValue.name() {\n                         return;"}, {"sha": "af7678aa06f7e5e90e69fc584b81496d7098e53d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -118,7 +118,7 @@ impl<'a> Resolver<'a> {\n             .collect();\n \n         match use_tree.kind {\n-            ast::UseTreeKind::Simple(rename) => {\n+            ast::UseTreeKind::Simple(rename, ..) => {\n                 let mut ident = use_tree.ident();\n                 let mut source = module_path.pop().unwrap();\n                 let mut type_ns_only = false;"}, {"sha": "2471430798e3c752f791195bd6eeb87dd8cc5ff1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -27,7 +27,8 @@ extern crate arena;\n extern crate rustc;\n extern crate rustc_data_structures;\n \n-use self::Namespace::*;\n+pub use rustc::hir::def::{Namespace, PerNS};\n+\n use self::TypeParameters::*;\n use self::RibKind::*;\n \n@@ -37,6 +38,7 @@ use rustc::middle::cstore::{CrateStore, CrateLoader};\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::*;\n+use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n@@ -614,45 +616,6 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n-/// Different kinds of symbols don't influence each other.\n-///\n-/// Therefore, they have a separate universe (namespace).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub enum Namespace {\n-    TypeNS,\n-    ValueNS,\n-    MacroNS,\n-}\n-\n-/// Just a helper \u2012 separate structure for each namespace.\n-#[derive(Clone, Default, Debug)]\n-pub struct PerNS<T> {\n-    value_ns: T,\n-    type_ns: T,\n-    macro_ns: T,\n-}\n-\n-impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n-    type Output = T;\n-    fn index(&self, ns: Namespace) -> &T {\n-        match ns {\n-            ValueNS => &self.value_ns,\n-            TypeNS => &self.type_ns,\n-            MacroNS => &self.macro_ns,\n-        }\n-    }\n-}\n-\n-impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n-    fn index_mut(&mut self, ns: Namespace) -> &mut T {\n-        match ns {\n-            ValueNS => &mut self.value_ns,\n-            TypeNS => &mut self.type_ns,\n-            MacroNS => &mut self.macro_ns,\n-        }\n-    }\n-}\n-\n struct UsePlacementFinder {\n     target_module: NodeId,\n     span: Option<Span>,\n@@ -1346,6 +1309,7 @@ pub struct Resolver<'a> {\n     primitive_type_table: PrimitiveTypeTable,\n \n     def_map: DefMap,\n+    import_map: ImportMap,\n     pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap,\n@@ -1518,6 +1482,10 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         self.def_map.get(&id).cloned()\n     }\n \n+    fn get_import(&mut self, id: NodeId) -> PerNS<Option<PathResolution>> {\n+        self.import_map.get(&id).cloned().unwrap_or_default()\n+    }\n+\n     fn definitions(&mut self) -> &mut Definitions {\n         &mut self.definitions\n     }\n@@ -1665,6 +1633,7 @@ impl<'a> Resolver<'a> {\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: NodeMap(),\n+            import_map: NodeMap(),\n             freevars: NodeMap(),\n             freevars_seen: NodeMap(),\n             export_map: FxHashMap(),\n@@ -2215,7 +2184,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            ast::UseTreeKind::Simple(_) => {},\n+            ast::UseTreeKind::Simple(..) => {},\n             ast::UseTreeKind::Glob => {},\n         }\n     }"}, {"sha": "8ac5e248dade4db5da31745e32d3ab44259d47f3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -918,7 +918,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n         self.per_ns(|this, ns| if let Some(binding) = result[ns].get().ok() {\n-            this.def_map.entry(directive.id).or_insert(PathResolution::new(binding.def()));\n+            let mut import = this.import_map.entry(directive.id).or_default();\n+            import[ns] = Some(PathResolution::new(binding.def()));\n         });\n \n         debug!(\"(resolving single import) successfully resolved import\");"}, {"sha": "44b41439511f7eac6ff9fbd22dd239771894592e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -365,6 +365,11 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 });\n                 true\n             }\n+            hir_map::NodeStructCtor(_) if !glob => {\n+                // struct constructors always show up alongside their struct definitions, we've\n+                // already processed that so just discard this\n+                true\n+            }\n             _ => false,\n         };\n         self.view_item_stack.remove(&def_node_id);"}, {"sha": "76fa463a63134a494b49b05e191a487d2b5361c8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -1860,7 +1860,10 @@ pub type Variant = Spanned<Variant_>;\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum UseTreeKind {\n     /// `use prefix` or `use prefix as rename`\n-    Simple(Option<Ident>),\n+    ///\n+    /// The extra `NodeId`s are for HIR lowering, when additional statements are created for each\n+    /// namespace.\n+    Simple(Option<Ident>, NodeId, NodeId),\n     /// `use prefix::{...}`\n     Nested(Vec<(UseTree, NodeId)>),\n     /// `use prefix::*`\n@@ -1879,8 +1882,8 @@ pub struct UseTree {\n impl UseTree {\n     pub fn ident(&self) -> Ident {\n         match self.kind {\n-            UseTreeKind::Simple(Some(rename)) => rename,\n-            UseTreeKind::Simple(None) =>\n+            UseTreeKind::Simple(Some(rename), ..) => rename,\n+            UseTreeKind::Simple(None, ..) =>\n                 self.prefix.segments.last().expect(\"empty prefix in a simple import\").ident,\n             _ => panic!(\"`UseTree::ident` can only be used on a simple import\"),\n         }"}, {"sha": "4a6f06dcc17ba712e79543f7f3a419d508b59bf2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -1175,7 +1175,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item_use(sp, vis, P(ast::UseTree {\n             span: sp,\n             prefix: path,\n-            kind: ast::UseTreeKind::Simple(rename),\n+            kind: ast::UseTreeKind::Simple(rename, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n         }))\n     }\n \n@@ -1185,7 +1185,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             (ast::UseTree {\n                 span: sp,\n                 prefix: self.path(sp, vec![*id]),\n-                kind: ast::UseTreeKind::Simple(None),\n+                kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n             }, ast::DUMMY_NODE_ID)\n         }).collect();\n "}, {"sha": "a2ea6a214841e71ca1d883b252a8114ec1f852d8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -1545,7 +1545,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_use_tree(&mut self, use_tree: &'a ast::UseTree, id: NodeId, _nested: bool) {\n-        if let ast::UseTreeKind::Simple(Some(ident)) = use_tree.kind {\n+        if let ast::UseTreeKind::Simple(Some(ident), ..) = use_tree.kind {\n             if ident.name == \"_\" {\n                 gate_feature_post!(&self, underscore_imports, use_tree.span,\n                                    \"renaming imports with `_` is unstable\");"}, {"sha": "8544ef330dc33bb21ba046390c2a761561d842c0", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -315,8 +315,9 @@ pub fn noop_fold_use_tree<T: Folder>(use_tree: UseTree, fld: &mut T) -> UseTree\n         span: fld.new_span(use_tree.span),\n         prefix: fld.fold_path(use_tree.prefix),\n         kind: match use_tree.kind {\n-            UseTreeKind::Simple(rename) =>\n-                UseTreeKind::Simple(rename.map(|ident| fld.fold_ident(ident))),\n+            UseTreeKind::Simple(rename, id1, id2) =>\n+                UseTreeKind::Simple(rename.map(|ident| fld.fold_ident(ident)),\n+                                    fld.new_id(id1), fld.new_id(id2)),\n             UseTreeKind::Glob => UseTreeKind::Glob,\n             UseTreeKind::Nested(items) => UseTreeKind::Nested(items.move_map(|(tree, id)| {\n                 (fld.fold_use_tree(tree), fld.new_id(id))"}, {"sha": "85759e7ae8fe9bb04130a0239b0517e1dc835514", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -7157,7 +7157,7 @@ impl<'a> Parser<'a> {\n                     UseTreeKind::Nested(self.parse_use_tree_list()?)\n                 }\n             } else {\n-                UseTreeKind::Simple(self.parse_rename()?)\n+                UseTreeKind::Simple(self.parse_rename()?, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID)\n             }\n         };\n "}, {"sha": "87edfd69e2bd6fda7480f904b6ac68826f337cba", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -2958,7 +2958,7 @@ impl<'a> State<'a> {\n \n     pub fn print_use_tree(&mut self, tree: &ast::UseTree) -> io::Result<()> {\n         match tree.kind {\n-            ast::UseTreeKind::Simple(rename) => {\n+            ast::UseTreeKind::Simple(rename, ..) => {\n                 self.print_path(&tree.prefix, false, 0)?;\n                 if let Some(rename) = rename {\n                     self.s.space()?;"}, {"sha": "da7deb3c4cfe7856df02dbb981c61d663dc79b2a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -492,7 +492,7 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         (ast::ItemKind::Use(P(ast::UseTree {\n             span: DUMMY_SP,\n             prefix: path_node(vec![id_test]),\n-            kind: ast::UseTreeKind::Simple(None),\n+            kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n         })),\n          ast::VisibilityKind::Public, keywords::Invalid.ident())\n     } else {\n@@ -588,7 +588,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         let use_path = ast::UseTree {\n             span: DUMMY_SP,\n             prefix: path_node(vec![mod_ident, Ident::from_str(\"main\")]),\n-            kind: ast::UseTreeKind::Simple(Some(rename)),\n+            kind: ast::UseTreeKind::Simple(Some(rename), ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n         };\n \n         expander.fold_item(P(ast::Item {"}, {"sha": "adda39c62ed0e2b4c3b9c6be026c84c9bd7ff7ce", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -356,7 +356,8 @@ pub fn walk_use_tree<'a, V: Visitor<'a>>(\n ) {\n     visitor.visit_path(&use_tree.prefix, id);\n     match use_tree.kind {\n-        UseTreeKind::Simple(rename) => {\n+        UseTreeKind::Simple(rename, ..) => {\n+            // the extra IDs are handled during HIR lowering\n             if let Some(rename) = rename {\n                 visitor.visit_ident(rename);\n             }"}, {"sha": "ec1bc359ab0281114b6d8654aeebf5cecb7abd6b", "filename": "src/test/rustdoc/namespaces.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Ftest%2Frustdoc%2Fnamespaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/594b05dd9786c09c916745c1b1c281a3c54cdbd1/src%2Ftest%2Frustdoc%2Fnamespaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fnamespaces.rs?ref=594b05dd9786c09c916745c1b1c281a3c54cdbd1", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// issue #34843: rustdoc prioritises documenting reexports from the type namespace\n+\n+mod inner {\n+    pub mod sync {\n+        pub struct SomeStruct;\n+    }\n+\n+    pub fn sync() {}\n+}\n+\n+// @has namespaces/sync/index.html\n+// @has namespaces/fn.sync.html\n+// @has namespaces/index.html '//a/@href' 'sync/index.html'\n+// @has - '//a/@href' 'fn.sync.html'\n+#[doc(inline)]\n+pub use inner::sync;"}]}