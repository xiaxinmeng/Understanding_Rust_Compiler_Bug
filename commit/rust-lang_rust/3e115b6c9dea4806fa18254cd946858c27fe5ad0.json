{"sha": "3e115b6c9dea4806fa18254cd946858c27fe5ad0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMTE1YjZjOWRlYTQ4MDZmYTE4MjU0Y2Q5NDY4NThjMjdmZTVhZDA=", "commit": {"author": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2020-02-04T22:54:16Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-02-08T23:47:41Z"}, "message": "Remove problematic specialization from RangeInclusive", "tree": {"sha": "cea51c7848ac8a7e01ab47e0b6e1b0395a2f1eb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cea51c7848ac8a7e01ab47e0b6e1b0395a2f1eb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e115b6c9dea4806fa18254cd946858c27fe5ad0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e115b6c9dea4806fa18254cd946858c27fe5ad0", "html_url": "https://github.com/rust-lang/rust/commit/3e115b6c9dea4806fa18254cd946858c27fe5ad0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e115b6c9dea4806fa18254cd946858c27fe5ad0/comments", "author": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ffd44d3d86214fc06be4add039e26f85261a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ffd44d3d86214fc06be4add039e26f85261a2b", "html_url": "https://github.com/rust-lang/rust/commit/85ffd44d3d86214fc06be4add039e26f85261a2b"}], "stats": {"total": 79, "additions": 26, "deletions": 53}, "files": [{"sha": "28fbd00f36b33558e8f05ccf06632f9d299cf8fb", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e115b6c9dea4806fa18254cd946858c27fe5ad0/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e115b6c9dea4806fa18254cd946858c27fe5ad0/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=3e115b6c9dea4806fa18254cd946858c27fe5ad0", "patch": "@@ -341,16 +341,15 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.start.add_one();\n             mem::replace(&mut self.start, n)\n         } else {\n+            self.exhausted = true;\n             self.start.clone()\n         })\n     }\n@@ -369,8 +368,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -379,21 +377,20 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.is_empty = Some(false);\n                     self.start = plus_n.add_one();\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n                     self.start = plus_n.clone();\n+                    self.exhausted = true;\n                     return Some(plus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n         self.start = self.end.clone();\n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n         None\n     }\n \n@@ -404,8 +401,6 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -418,7 +413,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;\n@@ -447,24 +442,22 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n         let is_iterating = self.start < self.end;\n-        self.is_empty = Some(!is_iterating);\n         Some(if is_iterating {\n             let n = self.end.sub_one();\n             mem::replace(&mut self.end, n)\n         } else {\n+            self.exhausted = true;\n             self.end.clone()\n         })\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        self.compute_is_empty();\n-        if self.is_empty.unwrap_or_default() {\n+        if self.is_empty() {\n             return None;\n         }\n \n@@ -473,21 +466,20 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.is_empty = Some(false);\n                     self.end = minus_n.sub_one();\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n-                    self.is_empty = Some(true);\n                     self.end = minus_n.clone();\n+                    self.exhausted = true;\n                     return Some(minus_n);\n                 }\n                 _ => {}\n             }\n         }\n \n         self.end = self.start.clone();\n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n         None\n     }\n \n@@ -498,8 +490,6 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         F: FnMut(B, Self::Item) -> R,\n         R: Try<Ok = B>,\n     {\n-        self.compute_is_empty();\n-\n         if self.is_empty() {\n             return Try::from_ok(init);\n         }\n@@ -512,7 +502,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             accum = f(accum, n)?;\n         }\n \n-        self.is_empty = Some(true);\n+        self.exhausted = true;\n \n         if self.start == self.end {\n             accum = f(accum, self.start.clone())?;"}, {"sha": "8ffad82b69d7c688816b15d7157586701f9ede7b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 14, "deletions": 31, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3e115b6c9dea4806fa18254cd946858c27fe5ad0/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e115b6c9dea4806fa18254cd946858c27fe5ad0/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=3e115b6c9dea4806fa18254cd946858c27fe5ad0", "patch": "@@ -340,24 +340,21 @@ pub struct RangeInclusive<Idx> {\n     // support that mode.\n     pub(crate) start: Idx,\n     pub(crate) end: Idx,\n-    pub(crate) is_empty: Option<bool>,\n+\n     // This field is:\n-    //  - `None` when next() or next_back() was never called\n-    //  - `Some(false)` when `start < end`\n-    //  - `Some(true)` when `end < start`\n-    //  - `Some(false)` when `start == end` and the range hasn't yet completed iteration\n-    //  - `Some(true)` when `start == end` and the range has completed iteration\n-    // The field cannot be a simple `bool` because the `..=` constructor can\n-    // accept non-PartialOrd types, also we want the constructor to be const.\n+    //  - `false` upon construction\n+    //  - `false` when iteration has yielded an element and the iterator is not exhausted\n+    //  - `true` when iteration has been used to exhaust the iterator\n+    //\n+    // This is required to support PartialEq and Hash without a PartialOrd bound or specialization.\n+    pub(crate) exhausted: bool,\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: PartialEq> PartialEq for RangeInclusive<Idx> {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n-        self.start == other.start\n-            && self.end == other.end\n-            && self.is_exhausted() == other.is_exhausted()\n+        self.start == other.start && self.end == other.end && self.exhausted == other.exhausted\n     }\n }\n \n@@ -369,8 +366,7 @@ impl<Idx: Hash> Hash for RangeInclusive<Idx> {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         self.start.hash(state);\n         self.end.hash(state);\n-        // Ideally we would hash `is_exhausted` here as well, but there's no\n-        // way for us to call it.\n+        self.exhausted.hash(state);\n     }\n }\n \n@@ -389,7 +385,7 @@ impl<Idx> RangeInclusive<Idx> {\n     #[rustc_promotable]\n     #[rustc_const_stable(feature = \"const_range_new\", since = \"1.32.0\")]\n     pub const fn new(start: Idx, end: Idx) -> Self {\n-        Self { start, end, is_empty: None }\n+        Self { start, end, exhausted: false }\n     }\n \n     /// Returns the lower bound of the range (inclusive).\n@@ -465,18 +461,13 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n         self.start.fmt(fmt)?;\n         write!(fmt, \"..=\")?;\n         self.end.fmt(fmt)?;\n+        if self.exhausted {\n+            write!(fmt, \" (exhausted)\")?;\n+        }\n         Ok(())\n     }\n }\n \n-impl<Idx: PartialEq<Idx>> RangeInclusive<Idx> {\n-    // Returns true if this is a range that started non-empty, and was iterated\n-    // to exhaustion.\n-    fn is_exhausted(&self) -> bool {\n-        Some(true) == self.is_empty && self.start == self.end\n-    }\n-}\n-\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -544,15 +535,7 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     #[unstable(feature = \"range_is_empty\", reason = \"recently added\", issue = \"48111\")]\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n-        self.is_empty.unwrap_or_else(|| !(self.start <= self.end))\n-    }\n-\n-    // If this range's `is_empty` is field is unknown (`None`), update it to be a concrete value.\n-    #[inline]\n-    pub(crate) fn compute_is_empty(&mut self) {\n-        if self.is_empty.is_none() {\n-            self.is_empty = Some(!(self.start <= self.end));\n-        }\n+        self.exhausted || !(self.start <= self.end)\n     }\n }\n "}]}