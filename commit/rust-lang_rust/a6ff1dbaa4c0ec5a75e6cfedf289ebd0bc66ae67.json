{"sha": "a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZmYxZGJhYTRjMGVjNWE3NWU2Y2ZlZGYyODllYmQwYmM2NmFlNjc=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-02-14T22:17:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-14T22:17:53Z"}, "message": "Rollup merge of #69164 - GuillaumeGomez:update-pulldown-cmark, r=Dylan-DPC\n\nUpdate pulldown-cmark dependency\n\nr? @kinnison\n\ncc @ollie27\n\nReopening of  #65894.", "tree": {"sha": "cd8c73ec7d96d1e594897bbfcf28c86369b26e85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd8c73ec7d96d1e594897bbfcf28c86369b26e85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeRxySCRBK7hj4Ov3rIwAAdHIIAGWlspr20i1D46q4ayQXpxjM\n0+VZ0BxGJ57Je0+Ua8BsOjsXrNvngAYBxm/dXhZCvKawrkM6aeaAieFEVCq4njxp\nEpdwRxckRMe+aALwYj69zB2imC/PcGZt17a+TIW57+Qm9sgBPKpchILPd/+lZS2I\nfNNtXVNQHqaov2oRL+t7L3AR7Qv42t7Ps2gd/LTaFAWQKRTbZTXFBccsR/PXNpmY\nrYbnyAhPsrGXD5TEmbBsaf6cEGIPj8ekiYrMadDAZft6Xwn1atjZq8O63uG+4cGH\n64VArBW6XTgt5jwMzqezrZtIiEqM3gIsihV/7WceM9PPVXFY8IsDmLmaxbGTRuo=\n=Xp98\n-----END PGP SIGNATURE-----\n", "payload": "tree cd8c73ec7d96d1e594897bbfcf28c86369b26e85\nparent 72def9a3f559b5c4611d924540407896b9819d20\nparent d8589de1f05fdf84016ad8b6fa1d14a076385b90\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1581718673 +0900\ncommitter GitHub <noreply@github.com> 1581718673 +0900\n\nRollup merge of #69164 - GuillaumeGomez:update-pulldown-cmark, r=Dylan-DPC\n\nUpdate pulldown-cmark dependency\n\nr? @kinnison\n\ncc @ollie27\n\nReopening of  #65894.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "html_url": "https://github.com/rust-lang/rust/commit/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72def9a3f559b5c4611d924540407896b9819d20", "url": "https://api.github.com/repos/rust-lang/rust/commits/72def9a3f559b5c4611d924540407896b9819d20", "html_url": "https://github.com/rust-lang/rust/commit/72def9a3f559b5c4611d924540407896b9819d20"}, {"sha": "d8589de1f05fdf84016ad8b6fa1d14a076385b90", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8589de1f05fdf84016ad8b6fa1d14a076385b90", "html_url": "https://github.com/rust-lang/rust/commit/d8589de1f05fdf84016ad8b6fa1d14a076385b90"}], "stats": {"total": 202, "additions": 108, "deletions": 94}, "files": [{"sha": "2847e3cfb04b1007dc4668ad71caa75f6ce08e4b", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "patch": "@@ -1564,7 +1564,7 @@ dependencies = [\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n- \"version_check 0.9.1\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -2014,9 +2014,9 @@ dependencies = [\n \n [[package]]\n name = \"memchr\"\n-version = \"2.2.0\"\n+version = \"2.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2efc7bc57c883d4a4d6e3246905283d8dae951bb3bd32f49d6ef297f546e1c39\"\n+checksum = \"53445de381a1f436797497c61d851644d0e8e88e6140f22872ad33a704933978\"\n \n [[package]]\n name = \"memmap\"\n@@ -2604,23 +2604,23 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.5.3\"\n+version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"77043da1282374688ee212dc44b3f37ff929431de9c9adc3053bd3cee5630357\"\n+checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n dependencies = [\n  \"bitflags\",\n+ \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.6.1\"\n+version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1c205cc82214f3594e2d50686730314f817c67ffa80fe800cf0db78c3c2b9d9e\"\n+checksum = \"2c2d7fd131800e0d63df52aff46201acaab70b431a4a1ec6f0343fe8e64f35a4\"\n dependencies = [\n  \"bitflags\",\n- \"getopts\",\n  \"memchr\",\n  \"unicase\",\n ]\n@@ -4160,7 +4160,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n  \"minifier\",\n- \"pulldown-cmark 0.5.3\",\n+ \"pulldown-cmark 0.7.0\",\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\",\n@@ -5160,11 +5160,11 @@ checksum = \"535c204ee4d8434478593480b8f86ab45ec9aae0e83c568ca81abf0fd0e88f86\"\n \n [[package]]\n name = \"unicase\"\n-version = \"2.5.1\"\n+version = \"2.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n+checksum = \"50f37be617794602aabbeee0be4f259dc1778fabe05e2d67ee8f79326d5cb4f6\"\n dependencies = [\n- \"version_check 0.1.5\",\n+ \"version_check\",\n ]\n \n [[package]]\n@@ -5334,12 +5334,6 @@ dependencies = [\n  \"failure\",\n ]\n \n-[[package]]\n-name = \"version_check\"\n-version = \"0.1.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\"\n-\n [[package]]\n name = \"version_check\"\n version = \"0.9.1\""}, {"sha": "4af13e4cd587aee30ef424b670b3f209f16045ec", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "patch": "@@ -9,7 +9,7 @@ name = \"rustdoc\"\n path = \"lib.rs\"\n \n [dependencies]\n-pulldown-cmark = { version = \"0.5.3\", default-features = false }\n+pulldown-cmark = { version = \"0.7\", default-features = false }\n minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n serde = { version = \"1.0\", features = [\"derive\"] }"}, {"sha": "07c092a511c04611181071497b20170384e6bbe0", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 95, "deletions": 75, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a6ff1dbaa4c0ec5a75e6cfedf289ebd0bc66ae67", "patch": "@@ -33,7 +33,7 @@ use crate::html::highlight;\n use crate::html::toc::TocBuilder;\n use crate::test;\n \n-use pulldown_cmark::{html, CowStr, Event, Options, Parser, Tag};\n+use pulldown_cmark::{html, CodeBlockKind, CowStr, Event, Options, Parser, Tag};\n \n #[cfg(test)]\n mod tests;\n@@ -189,10 +189,15 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n         let compile_fail;\n         let ignore;\n         let edition;\n-        if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n-            let parse_result = LangString::parse(&lang, self.check_error_codes, false);\n+        if let Some(Event::Start(Tag::CodeBlock(kind))) = event {\n+            let parse_result = match kind {\n+                CodeBlockKind::Fenced(ref lang) => {\n+                    LangString::parse(&lang, self.check_error_codes, false)\n+                }\n+                CodeBlockKind::Indented => LangString::all_false(),\n+            };\n             if !parse_result.rust {\n-                return Some(Event::Start(Tag::CodeBlock(lang)));\n+                return Some(Event::Start(Tag::CodeBlock(kind)));\n             }\n             compile_fail = parse_result.compile_fail;\n             ignore = parse_result.ignore;\n@@ -370,11 +375,11 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n         }\n \n         let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Header(level))) = event {\n+        if let Some(Event::Start(Tag::Heading(level))) = event {\n             let mut id = String::new();\n             for event in &mut self.inner {\n                 match &event {\n-                    Event::End(Tag::Header(..)) => break,\n+                    Event::End(Tag::Heading(..)) => break,\n                     Event::Text(text) | Event::Code(text) => {\n                         id.extend(text.chars().filter_map(slugify));\n                     }\n@@ -391,18 +396,18 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n                 let mut html_header = String::new();\n                 html::push_html(&mut html_header, self.buf.iter().cloned());\n                 let sec = builder.push(level as u32, html_header, id.clone());\n-                self.buf.push_front(Event::InlineHtml(format!(\"{} \", sec).into()));\n+                self.buf.push_front(Event::Html(format!(\"{} \", sec).into()));\n             }\n \n-            self.buf.push_back(Event::InlineHtml(format!(\"</a></h{}>\", level).into()));\n+            self.buf.push_back(Event::Html(format!(\"</a></h{}>\", level).into()));\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n                     <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );\n-            return Some(Event::InlineHtml(start_tags.into()));\n+            return Some(Event::Html(start_tags.into()));\n         }\n         event\n     }\n@@ -556,40 +561,44 @@ pub fn find_testable_code<T: test::Tester>(\n     error_codes: ErrorCodes,\n     enable_per_target_ignores: bool,\n ) {\n-    let mut parser = Parser::new(doc);\n+    let mut parser = Parser::new(doc).into_offset_iter();\n     let mut prev_offset = 0;\n     let mut nb_lines = 0;\n     let mut register_header = None;\n-    while let Some(event) = parser.next() {\n+    while let Some((event, offset)) = parser.next() {\n         match event {\n-            Event::Start(Tag::CodeBlock(s)) => {\n-                let offset = parser.get_offset();\n-\n-                let block_info = if s.is_empty() {\n-                    LangString::all_false()\n-                } else {\n-                    LangString::parse(&*s, error_codes, enable_per_target_ignores)\n+            Event::Start(Tag::CodeBlock(kind)) => {\n+                let block_info = match kind {\n+                    CodeBlockKind::Fenced(ref lang) => {\n+                        if lang.is_empty() {\n+                            LangString::all_false()\n+                        } else {\n+                            LangString::parse(lang, error_codes, enable_per_target_ignores)\n+                        }\n+                    }\n+                    CodeBlockKind::Indented => LangString::all_false(),\n                 };\n                 if !block_info.rust {\n                     continue;\n                 }\n+\n                 let mut test_s = String::new();\n \n-                while let Some(Event::Text(s)) = parser.next() {\n+                while let Some((Event::Text(s), _)) = parser.next() {\n                     test_s.push_str(&s);\n                 }\n-\n                 let text = test_s\n                     .lines()\n                     .map(|l| map_line(l).for_code())\n                     .collect::<Vec<Cow<'_, str>>>()\n                     .join(\"\\n\");\n-                nb_lines += doc[prev_offset..offset].lines().count();\n-                let line = tests.get_line() + nb_lines;\n+\n+                nb_lines += doc[prev_offset..offset.start].lines().count();\n+                let line = tests.get_line() + nb_lines + 1;\n                 tests.add_test(text, block_info, line);\n-                prev_offset = offset;\n+                prev_offset = offset.start;\n             }\n-            Event::Start(Tag::Header(level)) => {\n+            Event::Start(Tag::Heading(level)) => {\n                 register_header = Some(level as u32);\n             }\n             Event::Text(ref s) if register_header.is_some() => {\n@@ -783,7 +792,7 @@ impl MarkdownHtml<'_> {\n \n         // Treat inline HTML as plain text.\n         let p = p.map(|event| match event {\n-            Event::Html(text) | Event::InlineHtml(text) => Event::Text(text),\n+            Event::Html(text) => Event::Text(text),\n             _ => event,\n         });\n \n@@ -842,10 +851,10 @@ pub fn plain_summary_line(md: &str) -> String {\n             let next_event = next_event.unwrap();\n             let (ret, is_in) = match next_event {\n                 Event::Start(Tag::Paragraph) => (None, 1),\n-                Event::Start(Tag::Header(_)) => (None, 1),\n+                Event::Start(Tag::Heading(_)) => (None, 1),\n                 Event::Code(code) => (Some(format!(\"`{}`\", code)), 0),\n                 Event::Text(ref s) if self.is_in > 0 => (Some(s.as_ref().to_owned()), 0),\n-                Event::End(Tag::Paragraph) | Event::End(Tag::Header(_)) => (None, -1),\n+                Event::End(Tag::Paragraph) | Event::End(Tag::Heading(_)) => (None, -1),\n                 _ => (None, 0),\n             };\n             if is_in > 0 || (is_in < 0 && self.is_in > 0) {\n@@ -940,68 +949,79 @@ crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n         return code_blocks;\n     }\n \n-    let mut p = Parser::new_ext(md, opts());\n-\n-    let mut code_block_start = 0;\n-    let mut code_start = 0;\n-    let mut is_fenced = false;\n-    let mut previous_offset = 0;\n-    let mut in_rust_code_block = false;\n-    while let Some(event) = p.next() {\n-        let offset = p.get_offset();\n+    let mut p = Parser::new_ext(md, opts()).into_offset_iter();\n \n+    while let Some((event, offset)) = p.next() {\n         match event {\n             Event::Start(Tag::CodeBlock(syntax)) => {\n-                let lang_string = if syntax.is_empty() {\n-                    LangString::all_false()\n-                } else {\n-                    LangString::parse(&*syntax, ErrorCodes::Yes, false)\n-                };\n-\n-                if lang_string.rust {\n-                    in_rust_code_block = true;\n-\n-                    code_start = offset;\n-                    code_block_start = match md[previous_offset..offset].find(\"```\") {\n-                        Some(fence_idx) => {\n-                            is_fenced = true;\n-                            previous_offset + fence_idx\n+                let (syntax, code_start, code_end, range, is_fenced) = match syntax {\n+                    CodeBlockKind::Fenced(syntax) => {\n+                        let syntax = syntax.as_ref();\n+                        let lang_string = if syntax.is_empty() {\n+                            LangString::all_false()\n+                        } else {\n+                            LangString::parse(&*syntax, ErrorCodes::Yes, false)\n+                        };\n+                        if !lang_string.rust {\n+                            continue;\n                         }\n-                        None => {\n-                            is_fenced = false;\n-                            offset\n+                        let syntax = if syntax.is_empty() { None } else { Some(syntax.to_owned()) };\n+                        let (code_start, mut code_end) = match p.next() {\n+                            Some((Event::Text(_), offset)) => (offset.start, offset.end),\n+                            Some((_, sub_offset)) => {\n+                                let code = Range { start: sub_offset.start, end: sub_offset.start };\n+                                code_blocks.push(RustCodeBlock {\n+                                    is_fenced: true,\n+                                    range: offset,\n+                                    code,\n+                                    syntax,\n+                                });\n+                                continue;\n+                            }\n+                            None => {\n+                                let code = Range { start: offset.end, end: offset.end };\n+                                code_blocks.push(RustCodeBlock {\n+                                    is_fenced: true,\n+                                    range: offset,\n+                                    code,\n+                                    syntax,\n+                                });\n+                                continue;\n+                            }\n+                        };\n+                        while let Some((Event::Text(_), offset)) = p.next() {\n+                            code_end = offset.end;\n                         }\n-                    };\n-                }\n-            }\n-            Event::End(Tag::CodeBlock(syntax)) if in_rust_code_block => {\n-                in_rust_code_block = false;\n-\n-                let code_block_end = if is_fenced {\n-                    let fence_str = &md[previous_offset..offset].chars().rev().collect::<String>();\n-                    fence_str\n-                        .find(\"```\")\n-                        .map(|fence_idx| offset - fence_idx)\n-                        .unwrap_or_else(|| offset)\n-                } else if md.as_bytes().get(offset).map(|b| *b == b'\\n').unwrap_or_default() {\n-                    offset - 1\n-                } else {\n-                    offset\n+                        (syntax, code_start, code_end, offset, true)\n+                    }\n+                    CodeBlockKind::Indented => {\n+                        // The ending of the offset goes too far sometime so we reduce it by one in\n+                        // these cases.\n+                        if offset.end > offset.start\n+                            && md.get(offset.end..=offset.end) == Some(&\"\\n\")\n+                        {\n+                            (\n+                                None,\n+                                offset.start,\n+                                offset.end,\n+                                Range { start: offset.start, end: offset.end - 1 },\n+                                false,\n+                            )\n+                        } else {\n+                            (None, offset.start, offset.end, offset, false)\n+                        }\n+                    }\n                 };\n \n-                let code_end = if is_fenced { previous_offset } else { code_block_end };\n-\n                 code_blocks.push(RustCodeBlock {\n                     is_fenced,\n-                    range: Range { start: code_block_start, end: code_block_end },\n+                    range,\n                     code: Range { start: code_start, end: code_end },\n-                    syntax: if !syntax.is_empty() { Some(syntax.into_string()) } else { None },\n+                    syntax,\n                 });\n             }\n             _ => (),\n         }\n-\n-        previous_offset = offset;\n     }\n \n     code_blocks"}]}