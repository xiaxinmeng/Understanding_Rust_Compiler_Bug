{"sha": "55f3d04101c214a13f7d47fbdb140c5c1126c41b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ZjNkMDQxMDFjMjE0YTEzZjdkNDdmYmRiMTQwYzVjMTEyNmM0MWI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-06T22:05:43Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-08-07T03:54:24Z"}, "message": "vec: use `offset_inbounds` for iterators\n\nThis allows LLVM to optimize vector iterators to an `getelementptr` and\n`icmp` pair, instead of `getelementptr` and *two* comparisons.\n\nCode snippet:\n\n~~~\nfn foo(xs: &mut [f64]) {\n    for x in xs.mut_iter() {\n        *x += 10.0;\n    }\n}\n~~~\n\nLLVM IR at stage0:\n\n~~~\n; Function Attrs: noinline uwtable\ndefine void @\"_ZN3foo17_68e1b25bca131dba7_0$x2e0E\"({ i64, %tydesc*, i8*, i8*, i8 }* nocapture, { double*, i64 }* nocapture) #1 {\n\"function top level\":\n  %2 = getelementptr inbounds { double*, i64 }* %1, i64 0, i32 0\n  %3 = load double** %2, align 8\n  %4 = getelementptr inbounds { double*, i64 }* %1, i64 0, i32 1\n  %5 = load i64* %4, align 8\n  %6 = ptrtoint double* %3 to i64\n  %7 = and i64 %5, -8\n  %8 = add i64 %7, %6\n  %9 = inttoptr i64 %8 to double*\n  %10 = icmp eq double* %3, %9\n  %11 = icmp eq double* %3, null\n  %or.cond6 = or i1 %10, %11\n  br i1 %or.cond6, label %match_case, label %match_else\n\nmatch_else:                                       ; preds = %\"function top level\", %match_else\n  %12 = phi double* [ %13, %match_else ], [ %3, %\"function top level\" ]\n  %13 = getelementptr double* %12, i64 1\n  %14 = load double* %12, align 8\n  %15 = fadd double %14, 1.000000e+01\n  store double %15, double* %12, align 8\n  %16 = icmp eq double* %13, %9\n  %17 = icmp eq double* %13, null\n  %or.cond = or i1 %16, %17\n  br i1 %or.cond, label %match_case, label %match_else\n\nmatch_case:                                       ; preds = %match_else, %\"function top level\"\n  ret void\n}\n~~~\n\nOptimized LLVM IR at stage1/stage2:\n\n~~~\n; Function Attrs: noinline uwtable\ndefine void @\"_ZN3foo17_68e1b25bca131dba7_0$x2e0E\"({ i64, %tydesc*, i8*, i8*, i8 }* nocapture, { double*, i64 }* nocapture) #1 {\n\"function top level\":\n  %2 = getelementptr inbounds { double*, i64 }* %1, i64 0, i32 0\n  %3 = load double** %2, align 8\n  %4 = getelementptr inbounds { double*, i64 }* %1, i64 0, i32 1\n  %5 = load i64* %4, align 8\n  %6 = lshr i64 %5, 3\n  %7 = getelementptr inbounds double* %3, i64 %6\n  %8 = icmp eq i64 %6, 0\n  %9 = icmp eq double* %3, null\n  %or.cond6 = or i1 %8, %9\n  br i1 %or.cond6, label %match_case, label %match_else\n\nmatch_else:                                       ; preds = %\"function top level\", %match_else\n  %.sroa.0.0.in7 = phi double* [ %10, %match_else ], [ %3, %\"function top level\" ]\n  %10 = getelementptr inbounds double* %.sroa.0.0.in7, i64 1\n  %11 = load double* %.sroa.0.0.in7, align 8\n  %12 = fadd double %11, 1.000000e+01\n  store double %12, double* %.sroa.0.0.in7, align 8\n  %13 = icmp eq double* %10, %7\n  br i1 %13, label %match_case, label %match_else\n\nmatch_case:                                       ; preds = %match_else, %\"function top level\"\n  ret void\n}\n~~~", "tree": {"sha": "ca17a95c009009c7420d7d19414de9a6267aa774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca17a95c009009c7420d7d19414de9a6267aa774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55f3d04101c214a13f7d47fbdb140c5c1126c41b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55f3d04101c214a13f7d47fbdb140c5c1126c41b", "html_url": "https://github.com/rust-lang/rust/commit/55f3d04101c214a13f7d47fbdb140c5c1126c41b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55f3d04101c214a13f7d47fbdb140c5c1126c41b/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d115c94205dd4b937d29c77d1704aa3f801869e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d115c94205dd4b937d29c77d1704aa3f801869e", "html_url": "https://github.com/rust-lang/rust/commit/7d115c94205dd4b937d29c77d1704aa3f801869e"}], "stats": {"total": 29, "additions": 24, "deletions": 5}, "files": [{"sha": "5a2bd0c4de9cea8e88cd256c87100c1eb42650d0", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/55f3d04101c214a13f7d47fbdb140c5c1126c41b/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f3d04101c214a13f7d47fbdb140c5c1126c41b/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=55f3d04101c214a13f7d47fbdb140c5c1126c41b", "patch": "@@ -272,7 +272,6 @@ pub trait RawPtr<T> {\n     fn is_not_null(&self) -> bool;\n     unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: int) -> Self;\n-    #[cfg(not(stage0))]\n     unsafe fn offset_inbounds(self, count: int) -> Self;\n }\n \n@@ -307,6 +306,14 @@ impl<T> RawPtr<T> for *T {\n     #[inline]\n     fn offset(&self, count: int) -> *T { offset(*self, count) }\n \n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end.\n+    #[inline]\n+    #[cfg(stage0)]\n+    unsafe fn offset_inbounds(self, count: int) -> *T {\n+        intrinsics::offset(self, count)\n+    }\n+\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.\n     #[inline]\n@@ -347,6 +354,18 @@ impl<T> RawPtr<T> for *mut T {\n     #[inline]\n     fn offset(&self, count: int) -> *mut T { mut_offset(*self, count) }\n \n+    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n+    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n+    /// undefined behaviour.\n+    ///\n+    /// This method should be preferred over `offset` when the guarantee can be\n+    /// satisfied, to enable better optimization.\n+    #[inline]\n+    #[cfg(stage0)]\n+    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n+        intrinsics::offset(self as *T, count) as *mut T\n+    }\n+\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n     /// undefined behaviour."}, {"sha": "36201dc5e82665ab4a6c2abc2b03306cb594147a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/55f3d04101c214a13f7d47fbdb140c5c1126c41b/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f3d04101c214a13f7d47fbdb140c5c1126c41b/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=55f3d04101c214a13f7d47fbdb140c5c1126c41b", "patch": "@@ -855,7 +855,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n                             lifetime: cast::transmute(p)}\n             } else {\n                 VecIterator{ptr: p,\n-                            end: p.offset(self.len() as int),\n+                            end: p.offset_inbounds(self.len() as int),\n                             lifetime: cast::transmute(p)}\n             }\n         }\n@@ -1837,7 +1837,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n                                lifetime: cast::transmute(p)}\n             } else {\n                 VecMutIterator{ptr: p,\n-                               end: p.offset(self.len() as int),\n+                               end: p.offset_inbounds(self.len() as int),\n                                lifetime: cast::transmute(p)}\n             }\n         }\n@@ -2193,7 +2193,7 @@ macro_rules! iterator {\n                             // same pointer.\n                             cast::transmute(self.ptr as uint + 1)\n                         } else {\n-                            self.ptr.offset(1)\n+                            self.ptr.offset_inbounds(1)\n                         };\n \n                         Some(cast::transmute(old))\n@@ -2225,7 +2225,7 @@ macro_rules! double_ended_iterator {\n                             // See above for why 'ptr.offset' isn't used\n                             cast::transmute(self.end as uint - 1)\n                         } else {\n-                            self.end.offset(-1)\n+                            self.end.offset_inbounds(-1)\n                         };\n                         Some(cast::transmute(self.end))\n                     }"}]}