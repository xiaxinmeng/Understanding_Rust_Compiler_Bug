{"sha": "69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZjE3ZDFhMGEzYzg2MGUzZjVkN2U2NDNhNmMzZjhhYTJiNjM4YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-07T09:23:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-07T09:23:33Z"}, "message": "Auto merge of #47177 - michaelwoerister:erase-invalid-spans-during-metadata-encoding, r=alexcrichton\n\nMap invalid Spans to DUMMY_SP during crate metadata encoding.\n\nThis mirrors what we do for stabilizing the incr. comp. cache and is necessary for reproducible builds. For the incr. comp. cache, we *have* to do this because the encoding there cannot represent broken Spans. Metadata encoding has to be in sync with that as not to get unexpected interactions when compiling incrementally.\n\nThis should help with fixing issue https://github.com/rust-lang/rust/issues/47066.\n\nr? @alexcrichton", "tree": {"sha": "60befa13b9566a333a83f8b3228a78be2de2bc9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60befa13b9566a333a83f8b3228a78be2de2bc9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "html_url": "https://github.com/rust-lang/rust/commit/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2148bcd5fa508d44c2c3517dccf8450a5984e315", "url": "https://api.github.com/repos/rust-lang/rust/commits/2148bcd5fa508d44c2c3517dccf8450a5984e315", "html_url": "https://github.com/rust-lang/rust/commit/2148bcd5fa508d44c2c3517dccf8450a5984e315"}, {"sha": "30d921fb1e0ea920fc85af6fa46c2be3317568c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/30d921fb1e0ea920fc85af6fa46c2be3317568c3", "html_url": "https://github.com/rust-lang/rust/commit/30d921fb1e0ea920fc85af6fa46c2be3317568c3"}], "stats": {"total": 73, "additions": 55, "deletions": 18}, "files": [{"sha": "91703425017f83ea7a97a5e832371129269b295a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "patch": "@@ -270,19 +270,17 @@ impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let lo = BytePos::decode(self)?;\n-        let hi = BytePos::decode(self)?;\n+        let tag = u8::decode(self)?;\n \n-        if lo == BytePos(0) && hi == BytePos(0) {\n-            // Don't try to rebase DUMMY_SP. Otherwise it will look like a valid\n-            // Span again.\n+        if tag == TAG_INVALID_SPAN {\n             return Ok(DUMMY_SP)\n         }\n \n-        if hi < lo {\n-            // Consistently map invalid spans to DUMMY_SP.\n-            return Ok(DUMMY_SP)\n-        }\n+        debug_assert_eq!(tag, TAG_VALID_SPAN);\n+\n+        let lo = BytePos::decode(self)?;\n+        let len = BytePos::decode(self)?;\n+        let hi = lo + len;\n \n         let sess = if let Some(sess) = self.sess {\n             sess\n@@ -297,9 +295,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             let last_filemap = &imported_filemaps[self.last_filemap_index];\n \n             if lo >= last_filemap.original_start_pos &&\n-               lo <= last_filemap.original_end_pos &&\n-               hi >= last_filemap.original_start_pos &&\n-               hi <= last_filemap.original_end_pos {\n+               lo <= last_filemap.original_end_pos {\n                 last_filemap\n             } else {\n                 let mut a = 0;\n@@ -323,11 +319,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         debug_assert!(lo >= filemap.original_start_pos &&\n                       lo <= filemap.original_end_pos);\n \n-        if hi < filemap.original_start_pos || hi > filemap.original_end_pos {\n-            // `hi` points to a different FileMap than `lo` which is invalid.\n-            // Again, map invalid Spans to DUMMY_SP.\n-            return Ok(DUMMY_SP)\n-        }\n+        // Make sure we correctly filtered out invalid spans during encoding\n+        debug_assert!(hi >= filemap.original_start_pos &&\n+                      hi <= filemap.original_end_pos);\n \n         let lo = (lo + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n         let hi = (hi + filemap.translated_filemap.start_pos) - filemap.original_start_pos;"}, {"sha": "a42c8be9c20aada1ace4be23db4731ac25674924", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "patch": "@@ -41,7 +41,7 @@ use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n-use syntax_pos::{self, FileName};\n+use syntax_pos::{self, FileName, FileMap, Span, DUMMY_SP};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -57,6 +57,9 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+\n+    // This is used to speed up Span encoding.\n+    filemap_cache: Rc<FileMap>,\n }\n \n macro_rules! encoder_methods {\n@@ -140,6 +143,41 @@ impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n+    fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n+        if *span == DUMMY_SP {\n+            return TAG_INVALID_SPAN.encode(self)\n+        }\n+\n+        let span = span.data();\n+\n+        // The Span infrastructure should make sure that this invariant holds:\n+        debug_assert!(span.lo <= span.hi);\n+\n+        if !self.filemap_cache.contains(span.lo) {\n+            let codemap = self.tcx.sess.codemap();\n+            let filemap_index = codemap.lookup_filemap_idx(span.lo);\n+            self.filemap_cache = codemap.files()[filemap_index].clone();\n+        }\n+\n+        if !self.filemap_cache.contains(span.hi) {\n+            // Unfortunately, macro expansion still sometimes generates Spans\n+            // that malformed in this way.\n+            return TAG_INVALID_SPAN.encode(self)\n+        }\n+\n+        TAG_VALID_SPAN.encode(self)?;\n+        span.lo.encode(self)?;\n+\n+        // Encode length which is usually less than span.hi and profits more\n+        // from the variable-length integer encoding that we use.\n+        let len = span.hi - span.lo;\n+        len.encode(self)\n+\n+        // Don't encode the expansion context.\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n@@ -1648,6 +1686,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             lazy_state: LazyState::NoNode,\n             type_shorthands: Default::default(),\n             predicate_shorthands: Default::default(),\n+            filemap_cache: tcx.sess.codemap().files()[0].clone(),\n         };\n \n         // Encode the rustc version string in a predictable location."}, {"sha": "5510d66b55bfb7a2c9160e44cb64dc7550f22805", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=69f17d1a0a3c860e3f5d7e643a6c3f8aa2b638a6", "patch": "@@ -521,3 +521,7 @@ pub struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,\n }\n impl_stable_hash_for!(struct GeneratorData<'tcx> { layout });\n+\n+// Tags used for encoding Spans:\n+pub const TAG_VALID_SPAN: u8 = 0;\n+pub const TAG_INVALID_SPAN: u8 = 1;"}]}