{"sha": "a9dc2796cac8d49f67f6055d3fe3561a13f604b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZGMyNzk2Y2FjOGQ0OWY2N2Y2MDU1ZDNmZTM1NjFhMTNmNjA0Yjc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-28T07:23:01Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-28T07:23:01Z"}, "message": "Move get/set_at_offset helpers to global helpers file", "tree": {"sha": "0a5e23d31cdb318bc6d8163e4ca94c91bcb9c447", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a5e23d31cdb318bc6d8163e4ca94c91bcb9c447"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9dc2796cac8d49f67f6055d3fe3561a13f604b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9dc2796cac8d49f67f6055d3fe3561a13f604b7", "html_url": "https://github.com/rust-lang/rust/commit/a9dc2796cac8d49f67f6055d3fe3561a13f604b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9dc2796cac8d49f67f6055d3fe3561a13f604b7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e54619b5e18ce9781faed975f5101db621608ea0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e54619b5e18ce9781faed975f5101db621608ea0", "html_url": "https://github.com/rust-lang/rust/commit/e54619b5e18ce9781faed975f5101db621608ea0"}], "stats": {"total": 115, "additions": 45, "deletions": 70}, "files": [{"sha": "c1eaf4eb4865dddd381ca01468fc8b112675209c", "filename": "src/helpers.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9dc2796cac8d49f67f6055d3fe3561a13f604b7/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9dc2796cac8d49f67f6055d3fe3561a13f604b7/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=a9dc2796cac8d49f67f6055d3fe3561a13f604b7", "patch": "@@ -467,6 +467,37 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n         }\n     }\n+    \n+    fn read_scalar_at_offset(\n+        &self,\n+        op: OpTy<'tcx, Tag>,\n+        offset: u64,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+        let this = self.eval_context_ref();\n+        let op_place = this.deref_operand(op)?;\n+        let offset = Size::from_bytes(offset);\n+        // Ensure that the following read at an offset is within bounds\n+        assert!(op_place.layout.size >= offset + layout.size);\n+        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        this.read_scalar(value_place.into())\n+    }\n+\n+    fn write_scalar_at_offset(\n+        &mut self,\n+        op: OpTy<'tcx, Tag>,\n+        offset: u64,\n+        value: impl Into<ScalarMaybeUninit<Tag>>,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> InterpResult<'tcx, ()> {\n+        let this = self.eval_context_mut();\n+        let op_place = this.deref_operand(op)?;\n+        let offset = Size::from_bytes(offset);\n+        // Ensure that the following read at an offset is within bounds\n+        assert!(op_place.layout.size >= offset + layout.size);\n+        let value_place = op_place.offset(offset, MemPlaceMeta::None, layout, this)?;\n+        this.write_scalar(value, value_place.into())\n+    }\n }\n \n /// Check that the number of args is what we expect."}, {"sha": "bc4be56557a49dbb040711bab76bdf5da2dacb5f", "filename": "src/shims/posix/sync.rs", "status": "modified", "additions": 14, "deletions": 70, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a9dc2796cac8d49f67f6055d3fe3561a13f604b7/src%2Fshims%2Fposix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9dc2796cac8d49f67f6055d3fe3561a13f604b7/src%2Fshims%2Fposix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Fsync.rs?ref=a9dc2796cac8d49f67f6055d3fe3561a13f604b7", "patch": "@@ -2,57 +2,11 @@ use std::convert::TryInto;\n use std::time::{Duration, SystemTime};\n use std::ops::Not;\n \n-use rustc_middle::ty::{layout::TyAndLayout, TyKind, TypeAndMut};\n-use rustc_target::abi::{LayoutOf, Size};\n-\n use crate::*;\n use stacked_borrows::Tag;\n use thread::Time;\n \n \n-fn assert_ptr_target_min_size<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n-    operand: OpTy<'tcx, Tag>,\n-    min_size: u64,\n-) -> InterpResult<'tcx, ()> {\n-    let target_ty = match operand.layout.ty.kind {\n-        TyKind::RawPtr(TypeAndMut { ty, mutbl: _ }) => ty,\n-        _ => panic!(\"Argument to pthread function was not a raw pointer\"),\n-    };\n-    let target_layout = ecx.layout_of(target_ty)?;\n-    assert!(target_layout.size.bytes() >= min_size);\n-    Ok(())\n-}\n-\n-fn get_at_offset<'mir, 'tcx: 'mir>(\n-    ecx: &MiriEvalContext<'mir, 'tcx>,\n-    op: OpTy<'tcx, Tag>,\n-    offset: u64,\n-    layout: TyAndLayout<'tcx>,\n-    min_size: u64,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    // Ensure that the following read at an offset to the attr pointer is within bounds\n-    assert_ptr_target_min_size(ecx, op, min_size)?;\n-    let op_place = ecx.deref_operand(op)?;\n-    let value_place = op_place.offset(Size::from_bytes(offset), MemPlaceMeta::None, layout, ecx)?;\n-    ecx.read_scalar(value_place.into())\n-}\n-\n-fn set_at_offset<'mir, 'tcx: 'mir>(\n-    ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    op: OpTy<'tcx, Tag>,\n-    offset: u64,\n-    value: impl Into<ScalarMaybeUninit<Tag>>,\n-    layout: TyAndLayout<'tcx>,\n-    min_size: u64,\n-) -> InterpResult<'tcx, ()> {\n-    // Ensure that the following write at an offset to the attr pointer is within bounds\n-    assert_ptr_target_min_size(ecx, op, min_size)?;\n-    let op_place = ecx.deref_operand(op)?;\n-    let value_place = op_place.offset(Size::from_bytes(offset), MemPlaceMeta::None, layout, ecx)?;\n-    ecx.write_scalar(value.into(), value_place.into())\n-}\n-\n // pthread_mutexattr_t is either 4 or 8 bytes, depending on the platform.\n \n // Our chosen memory layout for emulation (does not have to match the platform layout!):\n@@ -66,8 +20,6 @@ fn set_at_offset<'mir, 'tcx: 'mir>(\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n-const PTHREAD_MUTEXATTR_T_MIN_SIZE: u64 = 4;\n-\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     kind: Scalar<Tag>,\n@@ -88,15 +40,15 @@ fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, attr_op, 0, ecx.machine.layouts.i32, PTHREAD_MUTEXATTR_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, attr_op, 0, kind, ecx.machine.layouts.i32, PTHREAD_MUTEXATTR_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(attr_op, 0, kind, ecx.machine.layouts.i32)\n }\n \n // pthread_mutex_t is between 24 and 48 bytes, depending on the platform.\n@@ -108,14 +60,12 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n-const PTHREAD_MUTEX_T_MIN_SIZE: u64 = 24;\n-\n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    get_at_offset(ecx, mutex_op, offset, ecx.machine.layouts.i32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(mutex_op, offset, ecx.machine.layouts.i32)\n }\n \n fn mutex_set_kind<'mir, 'tcx: 'mir>(\n@@ -124,22 +74,22 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     kind: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    set_at_offset(ecx, mutex_op, offset, kind, ecx.machine.layouts.i32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(mutex_op, offset, kind, ecx.machine.layouts.i32)\n }\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, mutex_op, 4, ecx.machine.layouts.u32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(mutex_op, 4, ecx.machine.layouts.u32)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     mutex_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, mutex_op, 4, id, ecx.machine.layouts.u32, PTHREAD_MUTEX_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(mutex_op, 4, id, ecx.machine.layouts.u32)\n }\n \n fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n@@ -165,21 +115,19 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n // (need to avoid this because it is set by static initializer macros)\n // bytes 4-7: rwlock id as u32 or 0 if id is not assigned yet.\n \n-const PTHREAD_RWLOCK_T_MIN_SIZE: u64 = 32;\n-\n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, rwlock_op, 4, ecx.machine.layouts.u32, PTHREAD_RWLOCK_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(rwlock_op, 4, ecx.machine.layouts.u32)\n }\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     rwlock_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, rwlock_op, 4, id, ecx.machine.layouts.u32, PTHREAD_RWLOCK_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(rwlock_op, 4, id, ecx.machine.layouts.u32)\n }\n \n fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n@@ -204,21 +152,19 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n // store an i32 in the first four bytes equal to the corresponding libc clock id constant\n // (e.g. CLOCK_REALTIME).\n \n-const PTHREAD_CONDATTR_T_MIN_SIZE: u64 = 4;\n-\n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, attr_op, 0, ecx.machine.layouts.i32, PTHREAD_CONDATTR_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     attr_op: OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, attr_op, 0, clock_id, ecx.machine.layouts.i32, PTHREAD_CONDATTR_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(attr_op, 0, clock_id, ecx.machine.layouts.i32)\n }\n \n // pthread_cond_t\n@@ -230,21 +176,19 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n // bytes 4-7: the conditional variable id as u32 or 0 if id is not assigned yet.\n // bytes 8-11: the clock id constant as i32\n \n-const PTHREAD_COND_T_MIN_SIZE: u64 = 12;\n-\n fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, cond_op, 4, ecx.machine.layouts.u32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(cond_op, 4, ecx.machine.layouts.u32)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n     id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, cond_op, 4, id, ecx.machine.layouts.u32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(cond_op, 4, id, ecx.machine.layouts.u32)\n }\n \n fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n@@ -267,15 +211,15 @@ fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n-    get_at_offset(ecx, cond_op, 8, ecx.machine.layouts.i32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n     cond_op: OpTy<'tcx, Tag>,\n     clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n ) -> InterpResult<'tcx, ()> {\n-    set_at_offset(ecx, cond_op, 8, clock_id, ecx.machine.layouts.i32, PTHREAD_COND_T_MIN_SIZE)\n+    ecx.write_scalar_at_offset(cond_op, 8, clock_id, ecx.machine.layouts.i32)\n }\n \n /// Try to reacquire the mutex associated with the condition variable after we"}]}