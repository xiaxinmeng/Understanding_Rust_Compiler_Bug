{"sha": "9dcb674525c5169a8649475699e60e0cbaed8c0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkY2I2NzQ1MjVjNTE2OWE4NjQ5NDc1Njk5ZTYwZTBjYmFlZDhjMGE=", "commit": {"author": {"name": "Kevin Atkinson", "email": "kevina@cs.utah.edu", "date": "2012-01-25T21:22:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-04T01:48:17Z"}, "message": "Add function to get a code snippet from a span,\nand also to get the byte offset within a string from a span chpos.", "tree": {"sha": "a528f94c03d41bfbf8426d429183c78d379c13c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a528f94c03d41bfbf8426d429183c78d379c13c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dcb674525c5169a8649475699e60e0cbaed8c0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dcb674525c5169a8649475699e60e0cbaed8c0a", "html_url": "https://github.com/rust-lang/rust/commit/9dcb674525c5169a8649475699e60e0cbaed8c0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dcb674525c5169a8649475699e60e0cbaed8c0a/comments", "author": {"login": "kevina", "id": 1271492, "node_id": "MDQ6VXNlcjEyNzE0OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1271492?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kevina", "html_url": "https://github.com/kevina", "followers_url": "https://api.github.com/users/kevina/followers", "following_url": "https://api.github.com/users/kevina/following{/other_user}", "gists_url": "https://api.github.com/users/kevina/gists{/gist_id}", "starred_url": "https://api.github.com/users/kevina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kevina/subscriptions", "organizations_url": "https://api.github.com/users/kevina/orgs", "repos_url": "https://api.github.com/users/kevina/repos", "events_url": "https://api.github.com/users/kevina/events{/privacy}", "received_events_url": "https://api.github.com/users/kevina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e127bf680f8a133f339901e05a44ac20b5faed3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e127bf680f8a133f339901e05a44ac20b5faed3e", "html_url": "https://github.com/rust-lang/rust/commit/e127bf680f8a133f339901e05a44ac20b5faed3e"}], "stats": {"total": 43, "additions": 40, "deletions": 3}, "files": [{"sha": "b9251d6d3d5d38999c4f4cc9e4eb427472a3af56", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 40, "deletions": 3, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9dcb674525c5169a8649475699e60e0cbaed8c0a/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dcb674525c5169a8649475699e60e0cbaed8c0a/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=9dcb674525c5169a8649475699e60e0cbaed8c0a", "patch": "@@ -34,7 +34,9 @@ fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n \n type lookup_fn = fn@(file_pos) -> uint;\n \n-fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n+fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n+    -> option::t<{fm: filemap, line: uint}>\n+{\n     let len = vec::len(map.files);\n     let a = 0u;\n     let b = len;\n@@ -43,7 +45,7 @@ fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n         if lookup(map.files[m].start_pos) > pos { b = m; } else { a = m; }\n     }\n     if (a >= len) {\n-        ret { filename: \"-\", line: 0u, col: 0u };\n+        ret none;\n     }\n     let f = map.files[a];\n     a = 0u;\n@@ -52,7 +54,18 @@ fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n         let m = (a + b) / 2u;\n         if lookup(f.lines[m]) > pos { b = m; } else { a = m; }\n     }\n-    ret {filename: f.name, line: a + 1u, col: pos - lookup(f.lines[a])};\n+    ret some({fm: f, line: a});\n+}\n+\n+fn lookup_pos(map: codemap, pos: uint, lookup: lookup_fn) -> loc {\n+    alt lookup_line(map, pos, lookup) {\n+      some({fm: f, line: a}) {\n+        {filename: f.name, line: a + 1u, col: pos - lookup(f.lines[a])}\n+      }\n+      none {\n+        { filename: \"-\", line: 0u, col: 0u }\n+      }\n+    }\n }\n \n fn lookup_char_pos(map: codemap, pos: uint) -> loc {\n@@ -125,6 +138,30 @@ fn get_line(fm: filemap, line: int) -> str unsafe {\n     ret str::unsafe::slice_bytes(*fm.src, begin, end);\n }\n \n+fn lookup_byte_offset(cm: codemap::codemap, chpos: uint)\n+    -> {fm: filemap, pos: uint}\n+{\n+    fn lookup(pos: file_pos) -> uint { ret pos.ch; }\n+    let {fm,line} = option::get(lookup_line(cm,chpos,lookup));\n+    let line_offset = fm.lines[line].byte;\n+    let col = chpos - fm.lines[line].ch;\n+    let col_offset = str::byte_len_range(*fm.src, line_offset, col);\n+    ret {fm: fm, pos: line_offset + col_offset};\n+}\n+\n+fn span_to_snippet(sp: span, cm: codemap::codemap) -> str {\n+    let begin = lookup_byte_offset(cm,sp.lo);\n+    let end   = lookup_byte_offset(cm,sp.hi);\n+    assert begin.fm == end.fm;\n+    ret str::slice(*begin.fm.src, begin.pos, end.pos);\n+}\n+\n+fn get_snippet(cm: codemap::codemap, fidx: uint, lo: uint, hi: uint) -> str\n+{\n+    let fm = cm.files[fidx];\n+    ret str::slice(*fm.src, lo, hi)\n+}\n+\n fn get_filemap(cm: codemap, filename: str) -> filemap {\n     for fm: filemap in cm.files { if fm.name == filename { ret fm; } }\n     //XXjdm the following triggers a mismatched type bug"}]}