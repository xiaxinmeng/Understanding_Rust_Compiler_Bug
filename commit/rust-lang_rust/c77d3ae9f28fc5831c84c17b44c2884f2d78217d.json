{"sha": "c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3N2QzYWU5ZjI4ZmM1ODMxYzg0YzE3YjQ0YzI4ODRmMmQ3ODIxN2Q=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-15T19:21:51Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T11:17:01Z"}, "message": "Separate bootstrap module", "tree": {"sha": "afce47b3ebf5ae80ce63f8d3b50bd2ccb84dde10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afce47b3ebf5ae80ce63f8d3b50bd2ccb84dde10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "html_url": "https://github.com/rust-lang/rust/commit/c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c77d3ae9f28fc5831c84c17b44c2884f2d78217d/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68", "html_url": "https://github.com/rust-lang/rust/commit/c2a57c88ea61de4bc4fbb480f704deb6b01e4d68"}], "stats": {"total": 1315, "additions": 657, "deletions": 658}, "files": [{"sha": "2e9df48d0000296456892ada00ed2be69d916cdb", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 658, "changes": 659, "blob_url": "https://github.com/rust-lang/rust/blob/c77d3ae9f28fc5831c84c17b44c2884f2d78217d/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77d3ae9f28fc5831c84c17b44c2884f2d78217d/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "patch": "@@ -1327,661 +1327,4 @@ impl<'a> Builder<'a> {\n }\n \n #[cfg(test)]\n-mod __test {\n-    use super::*;\n-    use crate::config::Config;\n-    use std::thread;\n-\n-    use pretty_assertions::assert_eq;\n-\n-    fn configure(host: &[&str], target: &[&str]) -> Config {\n-        let mut config = Config::default_opts();\n-        // don't save toolstates\n-        config.save_toolstates = None;\n-        config.skip_only_host_steps = false;\n-        config.dry_run = true;\n-        // try to avoid spurious failures in dist where we create/delete each others file\n-        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n-            &thread::current()\n-                .name()\n-                .unwrap_or(\"unknown\")\n-                .replace(\":\", \"-\"),\n-        );\n-        t!(fs::create_dir_all(&dir));\n-        config.out = dir;\n-        config.build = INTERNER.intern_str(\"A\");\n-        config.hosts = vec![config.build]\n-            .clone()\n-            .into_iter()\n-            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config.targets = config\n-            .hosts\n-            .clone()\n-            .into_iter()\n-            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config\n-    }\n-\n-    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n-        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n-    }\n-\n-    #[test]\n-    fn dist_baseline() {\n-        let build = Build::new(configure(&[], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[dist::Docs { host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_targets() {\n-        let build = Build::new(configure(&[], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_only_cross_host() {\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let mut build = Build::new(configure(&[\"B\"], &[]));\n-        build.config.docs = false;\n-        build.config.extended = true;\n-        build.hosts = vec![b];\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn dist_with_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-                dist::Docs { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.skip_only_host_steps = true; // as-if --target=C was passed\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-                dist::Docs { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n-    }\n-\n-    #[test]\n-    fn dist_with_same_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n-            &[\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_default() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.skip_only_host_steps = true;\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_with_no_doc_stage0() {\n-        let mut config = configure(&[], &[]);\n-        config.stage = Some(0);\n-        config.cmd = Subcommand::Test {\n-            paths: vec![\"src/libstd\".into()],\n-            test_args: vec![],\n-            rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-        };\n-\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-\n-        let host = INTERNER.intern_str(\"A\");\n-\n-        builder.run_step_descriptions(\n-            &[StepDescription::from::<test::Crate>()],\n-            &[\"src/libstd\".into()],\n-        );\n-\n-        // Ensure we don't build any compiler artifacts.\n-        assert!(!builder.cache.contains::<compile::Rustc>());\n-        assert_eq!(\n-            first(builder.cache.all::<test::Crate>()),\n-            &[test::Crate {\n-                compiler: Compiler { host, stage: 0 },\n-                target: host,\n-                mode: Mode::Std,\n-                test_kind: test::TestKind::Test,\n-                krate: INTERNER.intern_str(\"std\"),\n-            },]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_exclude() {\n-        let mut config = configure(&[], &[]);\n-        config.exclude = vec![\n-            \"src/test/run-pass\".into(),\n-            \"src/tools/tidy\".into(),\n-        ];\n-        config.cmd = Subcommand::Test {\n-            paths: Vec::new(),\n-            test_args: Vec::new(),\n-            rustc_args: Vec::new(),\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-        };\n-\n-        let build = Build::new(config);\n-        let builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-        // Ensure we have really excluded run-pass & tidy\n-        assert!(!builder.cache.contains::<test::RunPass>());\n-        assert!(!builder.cache.contains::<test::Tidy>());\n-\n-        // Ensure other tests are not affected.\n-        assert!(builder.cache.contains::<test::RunPassFullDeps>());\n-        assert!(builder.cache.contains::<test::RustdocUi>());\n-    }\n-}\n+mod tests;"}, {"sha": "46c58d118f7437e089aaba9ba93490e029a49a84", "filename": "src/bootstrap/builder/tests.rs", "status": "added", "additions": 656, "deletions": 0, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/c77d3ae9f28fc5831c84c17b44c2884f2d78217d/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c77d3ae9f28fc5831c84c17b44c2884f2d78217d/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=c77d3ae9f28fc5831c84c17b44c2884f2d78217d", "patch": "@@ -0,0 +1,656 @@\n+use super::*;\n+use crate::config::Config;\n+use std::thread;\n+\n+use pretty_assertions::assert_eq;\n+\n+fn configure(host: &[&str], target: &[&str]) -> Config {\n+    let mut config = Config::default_opts();\n+    // don't save toolstates\n+    config.save_toolstates = None;\n+    config.skip_only_host_steps = false;\n+    config.dry_run = true;\n+    // try to avoid spurious failures in dist where we create/delete each others file\n+    let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+        &thread::current()\n+            .name()\n+            .unwrap_or(\"unknown\")\n+            .replace(\":\", \"-\"),\n+    );\n+    t!(fs::create_dir_all(&dir));\n+    config.out = dir;\n+    config.build = INTERNER.intern_str(\"A\");\n+    config.hosts = vec![config.build]\n+        .clone()\n+        .into_iter()\n+        .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config.targets = config\n+        .hosts\n+        .clone()\n+        .into_iter()\n+        .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config\n+}\n+\n+fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+    v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+}\n+\n+#[test]\n+fn dist_baseline() {\n+    let build = Build::new(configure(&[], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[dist::Docs { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[dist::Std {\n+            compiler: Compiler { host: a, stage: 1 },\n+            target: a,\n+        },]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_targets() {\n+    let build = Build::new(configure(&[], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_only_cross_host() {\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let mut build = Build::new(configure(&[\"B\"], &[]));\n+    build.config.docs = false;\n+    build.config.extended = true;\n+    build.hosts = vec![b];\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn dist_with_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true; // as-if --target=C was passed\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+}\n+\n+#[test]\n+fn dist_with_same_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_default() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_with_no_doc_stage0() {\n+    let mut config = configure(&[], &[]);\n+    config.stage = Some(0);\n+    config.cmd = Subcommand::Test {\n+        paths: vec![\"src/libstd\".into()],\n+        test_args: vec![],\n+        rustc_args: vec![],\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+    };\n+\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+\n+    let host = INTERNER.intern_str(\"A\");\n+\n+    builder.run_step_descriptions(\n+        &[StepDescription::from::<test::Crate>()],\n+        &[\"src/libstd\".into()],\n+    );\n+\n+    // Ensure we don't build any compiler artifacts.\n+    assert!(!builder.cache.contains::<compile::Rustc>());\n+    assert_eq!(\n+        first(builder.cache.all::<test::Crate>()),\n+        &[test::Crate {\n+            compiler: Compiler { host, stage: 0 },\n+            target: host,\n+            mode: Mode::Std,\n+            test_kind: test::TestKind::Test,\n+            krate: INTERNER.intern_str(\"std\"),\n+        },]\n+    );\n+}\n+\n+#[test]\n+fn test_exclude() {\n+    let mut config = configure(&[], &[]);\n+    config.exclude = vec![\n+        \"src/test/run-pass\".into(),\n+        \"src/tools/tidy\".into(),\n+    ];\n+    config.cmd = Subcommand::Test {\n+        paths: Vec::new(),\n+        test_args: Vec::new(),\n+        rustc_args: Vec::new(),\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+    };\n+\n+    let build = Build::new(config);\n+    let builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+\n+    // Ensure we have really excluded run-pass & tidy\n+    assert!(!builder.cache.contains::<test::RunPass>());\n+    assert!(!builder.cache.contains::<test::Tidy>());\n+\n+    // Ensure other tests are not affected.\n+    assert!(builder.cache.contains::<test::RunPassFullDeps>());\n+    assert!(builder.cache.contains::<test::RustdocUi>());\n+}"}]}