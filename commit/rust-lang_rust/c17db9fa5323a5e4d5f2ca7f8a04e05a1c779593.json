{"sha": "c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "node_id": "C_kwDOAAsO6NoAKGMxN2RiOWZhNTMyM2E1ZTRkNWYyY2E3ZjhhMDRlMDVhMWM3Nzk1OTM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-08T09:05:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-08T09:05:09Z"}, "message": "Merge #11107\n\n11107: Fix generic type substitution in impl trait with assoc type r=pnevyk a=pnevyk\n\nFixes #11045 \r\n\r\nThe path transform now detects if a type parameter that is being substituted has an associated type. In that case it is necessary (or safe in general case) to fully qualify the substitution with a trait which the associated type belongs to.\r\n\r\nThis PR also fixes the previous wrong behavior of the substitution that could create an invalid tree `PATH_TYPE -> PATH_TYPE -> ...`.\n\nCo-authored-by: Petr Nevyho\u0161t\u011bn\u00fd <petr.nevyhosteny@gmail.com>", "tree": {"sha": "cf274785657368e15b49d28bc15a1f36394ce966", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf274785657368e15b49d28bc15a1f36394ce966"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh2VPFCRBK7hj4Ov3rIwAA1AEIAJvQoiR293auJRXIPwwNSRY8\n3RMBGF5nGBgO5OKIHkUKXVIj+i/PaOxpxfsGfvgIXQ2Tw3GsCZgzzDCjJOY1xS3j\nqGw7apAT/7VonNcWeE2CXpIhgjEWAJu2Bm5sRubnOeZaIhN7LycU93/XWVUjzwIk\no+QMKaNzqKFuWPoGYCfSUn1QsQxwjjQF+cduwG79//hf9zIS5EZt5a2D+CeRr1zt\nunieaxgX9su0Iy54uJwpQjFPeuvsePQ84zpaMe0djze80MCKR9GgqrAMcuTXG1Yn\nn+CmLY2DdByXtcNQ9BYsT50Z1NXB+gxhPzXvpziv84w1EzQSZ53i6ClclKPea50=\n=+f2r\n-----END PGP SIGNATURE-----\n", "payload": "tree cf274785657368e15b49d28bc15a1f36394ce966\nparent 54c999893396434725c284fdcfeeb4d47340d53f\nparent a710b87b1bb86602e9acccbb098039f66e27d80d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641632709 +0000\ncommitter GitHub <noreply@github.com> 1641632709 +0000\n\nMerge #11107\n\n11107: Fix generic type substitution in impl trait with assoc type r=pnevyk a=pnevyk\n\nFixes #11045 \r\n\r\nThe path transform now detects if a type parameter that is being substituted has an associated type. In that case it is necessary (or safe in general case) to fully qualify the substitution with a trait which the associated type belongs to.\r\n\r\nThis PR also fixes the previous wrong behavior of the substitution that could create an invalid tree `PATH_TYPE -> PATH_TYPE -> ...`.\n\nCo-authored-by: Petr Nevyho\u0161t\u011bn\u00fd <petr.nevyhosteny@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "html_url": "https://github.com/rust-lang/rust/commit/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54c999893396434725c284fdcfeeb4d47340d53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/54c999893396434725c284fdcfeeb4d47340d53f", "html_url": "https://github.com/rust-lang/rust/commit/54c999893396434725c284fdcfeeb4d47340d53f"}, {"sha": "a710b87b1bb86602e9acccbb098039f66e27d80d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a710b87b1bb86602e9acccbb098039f66e27d80d", "html_url": "https://github.com/rust-lang/rust/commit/a710b87b1bb86602e9acccbb098039f66e27d80d"}], "stats": {"total": 479, "additions": 468, "deletions": 11}, "files": [{"sha": "3105b28911647ec74d578f35afd6a90e08920eca", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "patch": "@@ -942,4 +942,366 @@ impl FooB for Foo {\n \"#,\n         )\n     }\n+\n+    #[test]\n+    fn test_assoc_type_when_trait_with_same_name_in_scope() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Foo {}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl<T: Types> Behavior<T> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Foo {}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl<T: Types> Behavior<T> for Impl {\n+    fn reproduce(&self, foo: <T as Types>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as Types>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_qualified() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for std::string::String {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<std::string::String> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for std::string::String {\n+    type Foo = bool;\n+}\n+\n+pub trait Behavior<T: Types> {\n+    fn reproduce(&self, foo: T::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<std::string::String> for Impl {\n+    fn reproduce(&self, foo: <std::string::String as Types>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_multi_option_ambiguous() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Foo = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: <T as Types2>::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Foo = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: <T as Types2>::Foo);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as Types2>::Foo) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_multi_option() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Bar;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Types {\n+    type Foo;\n+}\n+\n+pub trait Types2 {\n+    type Bar;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as Types2>::Bar) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_assoc_type_on_concrete_type_multi_option_foreign() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+mod bar {\n+    pub trait Types2 {\n+        type Bar;\n+    }\n+}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl bar::Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + bar::Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl { $0 }\"#,\n+            r#\"\n+mod bar {\n+    pub trait Types2 {\n+        type Bar;\n+    }\n+}\n+\n+pub trait Types {\n+    type Foo;\n+}\n+\n+impl Types for u32 {\n+    type Foo = bool;\n+}\n+\n+impl bar::Types2 for u32 {\n+    type Bar = String;\n+}\n+\n+pub trait Behavior<T: Types + bar::Types2> {\n+    fn reproduce(&self, foo: T::Bar);\n+}\n+\n+pub struct Impl;\n+\n+impl Behavior<u32> for Impl {\n+    fn reproduce(&self, foo: <u32 as bar::Types2>::Bar) {\n+        ${0:todo!()}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_transform_path_in_path_expr() {\n+        check_assist(\n+            add_missing_default_members,\n+            r#\"\n+pub trait Const {\n+    const FOO: u32;\n+}\n+\n+pub trait Trait<T: Const> {\n+    fn foo() -> bool {\n+        match T::FOO {\n+            0 => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Const for u32 {\n+    const FOO: u32 = 1;\n+}\n+\n+struct Impl;\n+\n+impl Trait<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Const {\n+    const FOO: u32;\n+}\n+\n+pub trait Trait<T: Const> {\n+    fn foo() -> bool {\n+        match T::FOO {\n+            0 => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Const for u32 {\n+    const FOO: u32 = 1;\n+}\n+\n+struct Impl;\n+\n+impl Trait<u32> for Impl {\n+    $0fn foo() -> bool {\n+        match <u32 as Const>::FOO {\n+            0 => true,\n+            _ => false,\n+        }\n+    }\n+}\"#,\n+        );\n+    }\n }"}, {"sha": "524af7fe8f01f43a7f7fc343cd39ea6a0d2a5dc2", "filename": "crates/ide_db/src/path_transform.rs", "status": "modified", "additions": 96, "deletions": 9, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "patch": "@@ -118,14 +118,20 @@ struct Ctx<'a> {\n \n impl<'a> Ctx<'a> {\n     fn apply(&self, item: &SyntaxNode) {\n-        for event in item.preorder() {\n-            let node = match event {\n-                syntax::WalkEvent::Enter(_) => continue,\n-                syntax::WalkEvent::Leave(it) => it,\n-            };\n-            if let Some(path) = ast::Path::cast(node.clone()) {\n-                self.transform_path(path);\n-            }\n+        // `transform_path` may update a node's parent and that would break the\n+        // tree traversal. Thus all paths in the tree are collected into a vec\n+        // so that such operation is safe.\n+        let paths = item\n+            .preorder()\n+            .filter_map(|event| match event {\n+                syntax::WalkEvent::Enter(_) => None,\n+                syntax::WalkEvent::Leave(node) => Some(node),\n+            })\n+            .filter_map(ast::Path::cast)\n+            .collect::<Vec<_>>();\n+\n+        for path in paths {\n+            self.transform_path(path);\n         }\n     }\n     fn transform_path(&self, path: ast::Path) -> Option<()> {\n@@ -145,10 +151,60 @@ impl<'a> Ctx<'a> {\n         match resolution {\n             hir::PathResolution::TypeParam(tp) => {\n                 if let Some(subst) = self.substs.get(&tp) {\n-                    ted::replace(path.syntax(), subst.clone_subtree().clone_for_update().syntax())\n+                    let parent = path.syntax().parent()?;\n+                    if let Some(parent) = ast::Path::cast(parent.clone()) {\n+                        // Path inside path means that there is an associated\n+                        // type/constant on the type parameter. It is necessary\n+                        // to fully qualify the type with `as Trait`. Even\n+                        // though it might be unnecessary if `subst` is generic\n+                        // type, always fully qualifying the path is safer\n+                        // because of potential clash of associated types from\n+                        // multiple traits\n+\n+                        let trait_ref = find_trait_for_assoc_item(\n+                            self.source_scope,\n+                            tp,\n+                            parent.segment()?.name_ref()?,\n+                        )\n+                        .and_then(|trait_ref| {\n+                            let found_path = self.target_module.find_use_path(\n+                                self.source_scope.db.upcast(),\n+                                hir::ModuleDef::Trait(trait_ref),\n+                            )?;\n+                            match ast::make::ty_path(mod_path_to_ast(&found_path)) {\n+                                ast::Type::PathType(path_ty) => Some(path_ty),\n+                                _ => None,\n+                            }\n+                        });\n+\n+                        let segment = ast::make::path_segment_ty(subst.clone(), trait_ref);\n+                        let qualified =\n+                            ast::make::path_from_segments(std::iter::once(segment), false);\n+                        ted::replace(path.syntax(), qualified.clone_for_update().syntax());\n+                    } else if let Some(path_ty) = ast::PathType::cast(parent) {\n+                        ted::replace(\n+                            path_ty.syntax(),\n+                            subst.clone_subtree().clone_for_update().syntax(),\n+                        );\n+                    } else {\n+                        ted::replace(\n+                            path.syntax(),\n+                            subst.clone_subtree().clone_for_update().syntax(),\n+                        );\n+                    }\n                 }\n             }\n             hir::PathResolution::Def(def) => {\n+                if let hir::ModuleDef::Trait(_) = def {\n+                    if matches!(path.segment()?.kind()?, ast::PathSegmentKind::Type { .. }) {\n+                        // `speculative_resolve` resolves segments like `<T as\n+                        // Trait>` into `Trait`, but just the trait name should\n+                        // not be used as the replacement of the original\n+                        // segment.\n+                        return None;\n+                    }\n+                }\n+\n                 let found_path =\n                     self.target_module.find_use_path(self.source_scope.db.upcast(), def)?;\n                 let res = mod_path_to_ast(&found_path).clone_for_update();\n@@ -195,3 +251,34 @@ fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<\n \n     Some(result)\n }\n+\n+fn find_trait_for_assoc_item(\n+    scope: &SemanticsScope,\n+    type_param: hir::TypeParam,\n+    assoc_item: ast::NameRef,\n+) -> Option<hir::Trait> {\n+    let db = scope.db;\n+    let trait_bounds = type_param.trait_bounds(db);\n+\n+    let assoc_item_name = assoc_item.text();\n+\n+    for trait_ in trait_bounds {\n+        let names = trait_.items(db).into_iter().filter_map(|item| match item {\n+            hir::AssocItem::TypeAlias(ta) => Some(ta.name(db)),\n+            hir::AssocItem::Const(cst) => cst.name(db),\n+            _ => None,\n+        });\n+\n+        for name in names {\n+            if assoc_item_name.as_str() == name.as_text()?.as_str() {\n+                // It is fine to return the first match because in case of\n+                // multiple possibilities, the exact trait must be disambiguated\n+                // in the definition of trait being implemented, so this search\n+                // should not be needed.\n+                return Some(trait_);\n+            }\n+        }\n+    }\n+\n+    None\n+}"}, {"sha": "f80c5e382c102b8b4b664c1f9f83845c4f796ae6", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=c17db9fa5323a5e4d5f2ca7f8a04e05a1c779593", "patch": "@@ -188,6 +188,14 @@ pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n     ast_from_text(&format!(\"use {};\", name_ref))\n }\n \n+pub fn path_segment_ty(type_ref: ast::Type, trait_ref: Option<ast::PathType>) -> ast::PathSegment {\n+    let text = match trait_ref {\n+        Some(trait_ref) => format!(\"fn f(x: <{} as {}>) {{}}\", type_ref, trait_ref),\n+        None => format!(\"fn f(x: <{}>) {{}}\", type_ref),\n+    };\n+    ast_from_text(&text)\n+}\n+\n pub fn path_segment_self() -> ast::PathSegment {\n     ast_from_text(\"use self;\")\n }\n@@ -218,9 +226,9 @@ pub fn path_from_segments(\n ) -> ast::Path {\n     let segments = segments.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n     ast_from_text(&if is_abs {\n-        format!(\"use ::{};\", segments)\n+        format!(\"fn f(x: ::{}) {{}}\", segments)\n     } else {\n-        format!(\"use {};\", segments)\n+        format!(\"fn f(x: {}) {{}}\", segments)\n     })\n }\n "}]}