{"sha": "e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "node_id": "C_kwDOAAsO6NoAKGU4ZTMyZTQ4YzRjNTJhNTNkMDg4NWRkZDhlYjk3MjgyOWJiZGE4ZTU", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-01-13T20:07:12Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-01-13T20:07:12Z"}, "message": "Ignore static lifetimes for GATs outlives lint", "tree": {"sha": "3489fa2412f458dfcaefab47bd1cf0166dc8cd4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3489fa2412f458dfcaefab47bd1cf0166dc8cd4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "html_url": "https://github.com/rust-lang/rust/commit/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e012a191d768adeda1ee36a99ef8b92d51920154", "url": "https://api.github.com/repos/rust-lang/rust/commits/e012a191d768adeda1ee36a99ef8b92d51920154", "html_url": "https://github.com/rust-lang/rust/commit/e012a191d768adeda1ee36a99ef8b92d51920154"}], "stats": {"total": 107, "additions": 61, "deletions": 46}, "files": [{"sha": "fbc446e3ea42e9cacd4c0ecd2019b04059f1658f", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 48, "deletions": 46, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "patch": "@@ -14,8 +14,9 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::outlives::obligations::TypeOutlives;\n-use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::infer::{self, RegionckMode, SubregionOrigin};\n+use rustc_infer::infer::region_constraints::GenericKind;\n+use rustc_infer::infer::{self, RegionckMode};\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n@@ -332,6 +333,12 @@ fn check_gat_where_clauses(\n         // outlives relationship (`Self: 'a`), then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (region, region_idx) in &regions {\n+            // Ignore `'static` lifetimes for the purpose of this lint: it's\n+            // because we know it outlives everything and so doesn't give meaninful\n+            // clues\n+            if let ty::ReStatic = region {\n+                continue;\n+            }\n             for (ty, ty_idx) in &types {\n                 // In our example, requires that Self: 'a\n                 if ty_known_to_outlive(tcx, id, param_env, &wf_tys, *ty, *region) {\n@@ -371,10 +378,19 @@ fn check_gat_where_clauses(\n         // outlives relationship, then we want to ensure that is\n         // reflected in a where clause on the GAT itself.\n         for (region_a, region_a_idx) in &regions {\n+            // Ignore `'static` lifetimes for the purpose of this lint: it's\n+            // because we know it outlives everything and so doesn't give meaninful\n+            // clues\n+            if let ty::ReStatic = region_a {\n+                continue;\n+            }\n             for (region_b, region_b_idx) in &regions {\n                 if region_a == region_b {\n                     continue;\n                 }\n+                if let ty::ReStatic = region_b {\n+                    continue;\n+                }\n \n                 if region_known_to_outlive(tcx, id, param_env, &wf_tys, *region_a, *region_b) {\n                     debug!(?region_a_idx, ?region_b_idx);\n@@ -502,8 +518,6 @@ fn check_gat_where_clauses(\n     }\n }\n \n-// FIXME(jackh726): refactor some of the shared logic between the two functions below\n-\n /// Given a known `param_env` and a set of well formed types, can we prove that\n /// `ty` outlives `region`.\n fn ty_known_to_outlive<'tcx>(\n@@ -514,54 +528,49 @@ fn ty_known_to_outlive<'tcx>(\n     ty: Ty<'tcx>,\n     region: ty::Region<'tcx>,\n ) -> bool {\n-    // Unfortunately, we have to use a new `InferCtxt` each call, because\n-    // region constraints get added and solved there and we need to test each\n-    // call individually.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut outlives_environment = OutlivesEnvironment::new(param_env);\n-        outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n-        outlives_environment.save_implied_bounds(id);\n-        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n-\n-        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-        let sup_type = ty;\n-        let sub_region = region;\n-\n-        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-            infer::RelateParamBound(cause.span, sup_type, None)\n-        });\n-\n+    resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |infcx, region_bound_pairs| {\n+        let origin = infer::RelateParamBound(DUMMY_SP, ty, None);\n         let outlives = &mut TypeOutlives::new(\n-            &infcx,\n+            infcx,\n             tcx,\n-            &region_bound_pairs,\n+            region_bound_pairs,\n             Some(infcx.tcx.lifetimes.re_root_empty),\n             param_env,\n         );\n-        outlives.type_must_outlive(origin, sup_type, sub_region);\n-\n-        let errors = infcx.resolve_regions(\n-            id.expect_owner().to_def_id(),\n-            &outlives_environment,\n-            RegionckMode::default(),\n-        );\n-\n-        debug!(?errors, \"errors\");\n-\n-        // If we were able to prove that the type outlives the region without\n-        // an error, it must be because of the implied or explicit bounds...\n-        errors.is_empty()\n+        outlives.type_must_outlive(origin, ty, region);\n     })\n }\n \n+/// Given a known `param_env` and a set of well formed types, can we prove that\n+/// `region_a` outlives `region_b`\n fn region_known_to_outlive<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     id: hir::HirId,\n     param_env: ty::ParamEnv<'tcx>,\n     wf_tys: &FxHashSet<Ty<'tcx>>,\n     region_a: ty::Region<'tcx>,\n     region_b: ty::Region<'tcx>,\n+) -> bool {\n+    resolve_regions_with_wf_tys(tcx, id, param_env, &wf_tys, |mut infcx, _| {\n+        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n+        let origin = infer::RelateRegionParamBound(DUMMY_SP);\n+        // `region_a: region_b` -> `region_b <= region_a`\n+        infcx.push_sub_region_constraint(origin, region_b, region_a);\n+    })\n+}\n+\n+/// Given a known `param_env` and a set of well formed types, set up an\n+/// `InferCtxt`, call the passed function (to e.g. set up region constraints\n+/// to be tested), then resolve region and return errors\n+fn resolve_regions_with_wf_tys<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    id: hir::HirId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    wf_tys: &FxHashSet<Ty<'tcx>>,\n+    add_constraints: impl for<'a> FnOnce(\n+        &'a InferCtxt<'a, 'tcx>,\n+        &'a Vec<(&'tcx ty::RegionKind, GenericKind<'tcx>)>,\n+    ),\n ) -> bool {\n     // Unfortunately, we have to use a new `InferCtxt` each call, because\n     // region constraints get added and solved there and we need to test each\n@@ -570,16 +579,9 @@ fn region_known_to_outlive<'tcx>(\n         let mut outlives_environment = OutlivesEnvironment::new(param_env);\n         outlives_environment.add_implied_bounds(&infcx, wf_tys.clone(), id, DUMMY_SP);\n         outlives_environment.save_implied_bounds(id);\n+        let region_bound_pairs = outlives_environment.region_bound_pairs_map().get(&id).unwrap();\n \n-        let cause = ObligationCause::new(DUMMY_SP, id, ObligationCauseCode::MiscObligation);\n-\n-        let origin = SubregionOrigin::from_obligation_cause(&cause, || {\n-            infer::RelateRegionParamBound(cause.span)\n-        });\n-\n-        use rustc_infer::infer::outlives::obligations::TypeOutlivesDelegate;\n-        // `region_a: region_b` -> `region_b <= region_a`\n-        (&infcx).push_sub_region_constraint(origin, region_b, region_a);\n+        add_constraints(&infcx, region_bound_pairs);\n \n         let errors = infcx.resolve_regions(\n             id.expect_owner().to_def_id(),"}, {"sha": "fcc53b4ede0cb65ceacc59a96c18bcdfdf0214d8", "filename": "src/test/ui/generic-associated-types/self-outlives-lint.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8e32e48c4c52a53d0885ddd8eb972829bbda8e5/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fself-outlives-lint.rs?ref=e8e32e48c4c52a53d0885ddd8eb972829bbda8e5", "patch": "@@ -189,4 +189,17 @@ trait Trait: 'static {\n     fn make_assoc(_: &u32) -> Self::Assoc<'_>;\n }\n \n+// We ignore `'static` lifetimes for any lints\n+trait StaticReturn<'a> {\n+    type Y<'b>;\n+    fn foo(&self) -> Self::Y<'static>;\n+}\n+\n+// Same as above, but with extra method that takes GAT - just make sure this works\n+trait StaticReturnAndTakes<'a> {\n+    type Y<'b>;\n+    fn foo(&self) -> Self::Y<'static>;\n+    fn bar<'b>(&self, arg: Self::Y<'b>);\n+}\n+\n fn main() {}"}]}