{"sha": "49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "node_id": "C_kwDOAAsO6NoAKDQ5ZDdlZDFkYmVmNjc0NGNkOWEyN2ZkYWUwODZjOWI4MGZiNGVkNDY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-02-19T13:47:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-19T13:47:55Z"}, "message": "Rollup merge of #107766 - GuillaumeGomez:fix-json-reexports-of-different-items-with-same-name, r=aDotInTheVoid\n\nFix json reexports of different items with same name\n\nFixes  #107677.\n\nI renamed `from_item_id*` functions into `id_from_item` instead because it makes more sense now. I also simplified the logic around it a bit so that the `ids` function will now directly pass `&clean::Item` to `id_from_item` and the ID will be consistently generated (it caused an issue when I updated the ID for imports).\n\nSo now, the big change of this PR: I changed how imports' ID is generated: it now includes the target item's ID at the end of the ID. It's to prevent two reexported items with the same name (but different types).\n\nr? `@aDotInTheVoid`", "tree": {"sha": "f9bc490bde2f48a91785d79ebc4910ed40029d89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9bc490bde2f48a91785d79ebc4910ed40029d89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj8iiLCRBK7hj4Ov3rIwAA5i0IAKSQZ6CzWGOGV01Fxz0ISPFA\n5S3+lHPei1z6JUruvqoKQlLASI+Z87dT/G7o91Q4R9jzlRvksnsRyz1sJ2NKFw7k\n9DyPo2Qpztx+5MySKWkri17capLrvpf3dwevLDFMEq7iCsza6yz20dzRlDmaoGmJ\nDX3JRwLactEY6VE4W20vR6P7Lcy+mEph3cOKEFW4Adg+s4/68oB7ZKOgjqe5DYKS\naj64OxdspBTwutqoRMOWzq87BrNfz6m/ZR5fyKKr73Qmv6cW8h75ALX0EHAhSSCu\ngv7T30RYiTidsnJNwZlQGExgGk7JU6sXgPPHH0C+zXrade55sBbrvbUYCyE8UNQ=\n=AzjA\n-----END PGP SIGNATURE-----\n", "payload": "tree f9bc490bde2f48a91785d79ebc4910ed40029d89\nparent eebdfb55fce148676c24555505aebf648123b2de\nparent 1ae875f0a30b7a71755fac43a8c6fe00dd205d33\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1676814475 +0100\ncommitter GitHub <noreply@github.com> 1676814475 +0100\n\nRollup merge of #107766 - GuillaumeGomez:fix-json-reexports-of-different-items-with-same-name, r=aDotInTheVoid\n\nFix json reexports of different items with same name\n\nFixes  #107677.\n\nI renamed `from_item_id*` functions into `id_from_item` instead because it makes more sense now. I also simplified the logic around it a bit so that the `ids` function will now directly pass `&clean::Item` to `id_from_item` and the ID will be consistently generated (it caused an issue when I updated the ID for imports).\n\nSo now, the big change of this PR: I changed how imports' ID is generated: it now includes the target item's ID at the end of the ID. It's to prevent two reexported items with the same name (but different types).\n\nr? `@aDotInTheVoid`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "html_url": "https://github.com/rust-lang/rust/commit/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eebdfb55fce148676c24555505aebf648123b2de", "url": "https://api.github.com/repos/rust-lang/rust/commits/eebdfb55fce148676c24555505aebf648123b2de", "html_url": "https://github.com/rust-lang/rust/commit/eebdfb55fce148676c24555505aebf648123b2de"}, {"sha": "1ae875f0a30b7a71755fac43a8c6fe00dd205d33", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae875f0a30b7a71755fac43a8c6fe00dd205d33", "html_url": "https://github.com/rust-lang/rust/commit/1ae875f0a30b7a71755fac43a8c6fe00dd205d33"}], "stats": {"total": 139, "additions": 98, "deletions": 41}, "files": [{"sha": "d5e9010eb4ed98682e08976810fd35edad3fd0a6", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 67, "deletions": 32, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "patch": "@@ -38,7 +38,7 @@ impl JsonRenderer<'_> {\n                     Some(UrlFragment::UserWritten(_)) | None => *page_id,\n                 };\n \n-                (link.clone(), from_item_id(id.into(), self.tcx))\n+                (link.clone(), id_from_item_default(id.into(), self.tcx))\n             })\n             .collect();\n         let docs = item.attrs.collapsed_doc_value();\n@@ -50,7 +50,8 @@ impl JsonRenderer<'_> {\n             .collect();\n         let span = item.span(self.tcx);\n         let visibility = item.visibility(self.tcx);\n-        let clean::Item { name, attrs: _, kind: _, item_id, cfg: _, .. } = item;\n+        let clean::Item { name, item_id, .. } = item;\n+        let id = id_from_item(&item, self.tcx);\n         let inner = match *item.kind {\n             clean::KeywordItem => return None,\n             clean::StrippedItem(ref inner) => {\n@@ -69,7 +70,7 @@ impl JsonRenderer<'_> {\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n-            id: from_item_id_with_name(item_id, self.tcx, name),\n+            id,\n             crate_id: item_id.krate().as_u32(),\n             name: name.map(|sym| sym.to_string()),\n             span: span.and_then(|span| self.convert_span(span)),\n@@ -107,7 +108,7 @@ impl JsonRenderer<'_> {\n             Some(ty::Visibility::Public) => Visibility::Public,\n             Some(ty::Visibility::Restricted(did)) if did.is_crate_root() => Visibility::Crate,\n             Some(ty::Visibility::Restricted(did)) => Visibility::Restricted {\n-                parent: from_item_id(did.into(), self.tcx),\n+                parent: id_from_item_default(did.into(), self.tcx),\n                 path: self.tcx.def_path(did).to_string_no_crate_verbose(),\n             },\n         }\n@@ -204,21 +205,42 @@ impl FromWithTcx<clean::TypeBindingKind> for TypeBindingKind {\n     }\n }\n \n-/// It generates an ID as follows:\n-///\n-/// `CRATE_ID:ITEM_ID[:NAME_ID]` (if there is no name, NAME_ID is not generated).\n-pub(crate) fn from_item_id(item_id: ItemId, tcx: TyCtxt<'_>) -> Id {\n-    from_item_id_with_name(item_id, tcx, None)\n+#[inline]\n+pub(crate) fn id_from_item_default(item_id: ItemId, tcx: TyCtxt<'_>) -> Id {\n+    id_from_item_inner(item_id, tcx, None, None)\n }\n \n-// FIXME: this function (and appending the name at the end of the ID) should be removed when\n-// reexports are not inlined anymore for json format. It should be done in #93518.\n-pub(crate) fn from_item_id_with_name(item_id: ItemId, tcx: TyCtxt<'_>, name: Option<Symbol>) -> Id {\n-    struct DisplayDefId<'a>(DefId, TyCtxt<'a>, Option<Symbol>);\n+/// It generates an ID as follows:\n+///\n+/// `CRATE_ID:ITEM_ID[:NAME_ID][-EXTRA]`:\n+///   * If there is no `name`, `NAME_ID` is not generated.\n+///   * If there is no `extra`, `EXTRA` is not generated.\n+///\n+/// * `name` is the item's name if available (it's not for impl blocks for example).\n+/// * `extra` is used for reexports: it contains the ID of the reexported item. It is used to allow\n+///   to have items with the same name but different types to both appear in the generated JSON.\n+pub(crate) fn id_from_item_inner(\n+    item_id: ItemId,\n+    tcx: TyCtxt<'_>,\n+    name: Option<Symbol>,\n+    extra: Option<&Id>,\n+) -> Id {\n+    struct DisplayDefId<'a, 'b>(DefId, TyCtxt<'a>, Option<&'b Id>, Option<Symbol>);\n \n-    impl<'a> fmt::Display for DisplayDefId<'a> {\n+    impl<'a, 'b> fmt::Display for DisplayDefId<'a, 'b> {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            let DisplayDefId(def_id, tcx, name) = self;\n+            let DisplayDefId(def_id, tcx, extra, name) = self;\n+            // We need this workaround because primitive types' DefId actually refers to\n+            // their parent module, which isn't present in the output JSON items. So\n+            // instead, we directly get the primitive symbol and convert it to u32 to\n+            // generate the ID.\n+            let s;\n+            let extra = if let Some(e) = extra {\n+                s = format!(\"-{}\", e.0);\n+                &s\n+            } else {\n+                \"\"\n+            };\n             let name = match name {\n                 Some(name) => format!(\":{}\", name.as_u32()),\n                 None => {\n@@ -240,18 +262,33 @@ pub(crate) fn from_item_id_with_name(item_id: ItemId, tcx: TyCtxt<'_>, name: Opt\n                     }\n                 }\n             };\n-            write!(f, \"{}:{}{}\", self.0.krate.as_u32(), u32::from(self.0.index), name)\n+            write!(f, \"{}:{}{name}{extra}\", def_id.krate.as_u32(), u32::from(def_id.index))\n         }\n     }\n \n     match item_id {\n-        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did, tcx, name))),\n-        ItemId::Blanket { for_, impl_id } => {\n-            Id(format!(\"b:{}-{}\", DisplayDefId(impl_id, tcx, None), DisplayDefId(for_, tcx, name)))\n-        }\n-        ItemId::Auto { for_, trait_ } => {\n-            Id(format!(\"a:{}-{}\", DisplayDefId(trait_, tcx, None), DisplayDefId(for_, tcx, name)))\n+        ItemId::DefId(did) => Id(format!(\"{}\", DisplayDefId(did, tcx, extra, name))),\n+        ItemId::Blanket { for_, impl_id } => Id(format!(\n+            \"b:{}-{}\",\n+            DisplayDefId(impl_id, tcx, None, None),\n+            DisplayDefId(for_, tcx, extra, name)\n+        )),\n+        ItemId::Auto { for_, trait_ } => Id(format!(\n+            \"a:{}-{}\",\n+            DisplayDefId(trait_, tcx, None, None),\n+            DisplayDefId(for_, tcx, extra, name)\n+        )),\n+    }\n+}\n+\n+pub(crate) fn id_from_item(item: &clean::Item, tcx: TyCtxt<'_>) -> Id {\n+    match *item.kind {\n+        clean::ItemKind::ImportItem(ref import) => {\n+            let extra =\n+                import.source.did.map(ItemId::from).map(|i| id_from_item_inner(i, tcx, None, None));\n+            id_from_item_inner(item.item_id, tcx, item.name, extra.as_ref())\n         }\n+        _ => id_from_item_inner(item.item_id, tcx, item.name, None),\n     }\n }\n \n@@ -525,7 +562,7 @@ impl FromWithTcx<clean::Path> for Path {\n     fn from_tcx(path: clean::Path, tcx: TyCtxt<'_>) -> Path {\n         Path {\n             name: path.whole_name(),\n-            id: from_item_id(path.def_id().into(), tcx),\n+            id: id_from_item_default(path.def_id().into(), tcx),\n             args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n         }\n     }\n@@ -702,7 +739,7 @@ impl FromWithTcx<clean::Import> for Import {\n         Import {\n             source: import.source.path.whole_name(),\n             name,\n-            id: import.source.did.map(ItemId::from).map(|i| from_item_id(i, tcx)),\n+            id: import.source.did.map(ItemId::from).map(|i| id_from_item_default(i, tcx)),\n             glob,\n         }\n     }\n@@ -791,7 +828,7 @@ fn ids(items: impl IntoIterator<Item = clean::Item>, tcx: TyCtxt<'_>) -> Vec<Id>\n     items\n         .into_iter()\n         .filter(|x| !x.is_stripped() && !x.is_keyword())\n-        .map(|i| from_item_id_with_name(i.item_id, tcx, i.name))\n+        .map(|i| id_from_item(&i, tcx))\n         .collect()\n }\n \n@@ -801,12 +838,10 @@ fn ids_keeping_stripped(\n ) -> Vec<Option<Id>> {\n     items\n         .into_iter()\n-        .map(|i| {\n-            if !i.is_stripped() && !i.is_keyword() {\n-                Some(from_item_id_with_name(i.item_id, tcx, i.name))\n-            } else {\n-                None\n-            }\n-        })\n+        .map(\n+            |i| {\n+                if !i.is_stripped() && !i.is_keyword() { Some(id_from_item(&i, tcx)) } else { None }\n+            },\n+        )\n         .collect()\n }"}, {"sha": "08bceb59cfde683c686bae3e66eb7b6baaf2872f", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "patch": "@@ -28,7 +28,7 @@ use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n use crate::formats::FormatRenderer;\n-use crate::json::conversions::{from_item_id, from_item_id_with_name, IntoWithTcx};\n+use crate::json::conversions::{id_from_item, id_from_item_default, IntoWithTcx};\n use crate::{clean, try_err};\n \n #[derive(Clone)]\n@@ -58,7 +58,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                     .map(|i| {\n                         let item = &i.impl_item;\n                         self.item(item.clone()).unwrap();\n-                        from_item_id_with_name(item.item_id, self.tcx, item.name)\n+                        id_from_item(&item, self.tcx)\n                     })\n                     .collect()\n             })\n@@ -89,7 +89,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n \n                         if item.item_id.is_local() || is_primitive_impl {\n                             self.item(item.clone()).unwrap();\n-                            Some(from_item_id_with_name(item.item_id, self.tcx, item.name))\n+                            Some(id_from_item(&item, self.tcx))\n                         } else {\n                             None\n                         }\n@@ -150,7 +150,6 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n \n-        let name = item.name;\n         let item_id = item.item_id;\n         if let Some(mut new_item) = self.convert_item(item) {\n             let can_be_ignored = match new_item.inner {\n@@ -193,10 +192,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 | types::ItemEnum::Macro(_)\n                 | types::ItemEnum::ProcMacro(_) => false,\n             };\n-            let removed = self\n-                .index\n-                .borrow_mut()\n-                .insert(from_item_id_with_name(item_id, self.tcx, name), new_item.clone());\n+            let removed = self.index.borrow_mut().insert(new_item.id.clone(), new_item.clone());\n \n             // FIXME(adotinthevoid): Currently, the index is duplicated. This is a sanity check\n             // to make sure the items are unique. The main place this happens is when an item, is\n@@ -207,6 +203,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 if !can_be_ignored {\n                     assert_eq!(old_item, new_item);\n                 }\n+                trace!(\"replaced {:?}\\nwith {:?}\", old_item, new_item);\n             }\n         }\n \n@@ -246,7 +243,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                 .chain(&self.cache.external_paths)\n                 .map(|(&k, &(ref path, kind))| {\n                     (\n-                        from_item_id(k.into(), self.tcx),\n+                        id_from_item_default(k.into(), self.tcx),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n                             path: path.iter().map(|s| s.to_string()).collect(),"}, {"sha": "2314a4eb90940368e3f31b9abf188e3f10fb0c44", "filename": "tests/rustdoc-json/reexport/same_name_different_types.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/tests%2Frustdoc-json%2Freexport%2Fsame_name_different_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46/tests%2Frustdoc-json%2Freexport%2Fsame_name_different_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-json%2Freexport%2Fsame_name_different_types.rs?ref=49d7ed1dbef6744cd9a27fdae086c9b80fb4ed46", "patch": "@@ -0,0 +1,25 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/107677>.\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+pub mod nested {\n+    // @set foo_struct = \"$.index[*][?(@.docs == 'Foo the struct')].id\"\n+\n+    /// Foo the struct\n+    pub struct Foo {}\n+\n+    // @set foo_fn = \"$.index[*][?(@.docs == 'Foo the function')].id\"\n+\n+    #[allow(non_snake_case)]\n+    /// Foo the function\n+    pub fn Foo() {}\n+}\n+\n+// @ismany \"$.index[*][?(@.inner.name == 'Foo' && @.kind == 'import')].inner.id\" $foo_fn $foo_struct\n+// @ismany \"$.index[*][?(@.inner.name == 'Bar' && @.kind == 'import')].inner.id\" $foo_fn $foo_struct\n+\n+// @count \"$.index[*][?(@.inner.name == 'Foo' && @.kind == 'import')]\" 2\n+pub use nested::Foo;\n+// @count \"$.index[*][?(@.inner.name == 'Bar' && @.kind == 'import')]\" 2\n+pub use Foo as Bar;"}]}