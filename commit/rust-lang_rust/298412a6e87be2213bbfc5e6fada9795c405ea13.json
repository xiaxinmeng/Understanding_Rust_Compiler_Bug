{"sha": "298412a6e87be2213bbfc5e6fada9795c405ea13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODQxMmE2ZTg3YmUyMjEzYmJmYzVlNmZhZGE5Nzk1YzQwNWVhMTM=", "commit": {"author": {"name": "Yehuda Katz", "email": "wycats@gmail.com", "date": "2014-06-03T19:33:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-13T20:53:34Z"}, "message": "Improve error messages for io::fs", "tree": {"sha": "a70139027f7f9f64cf1581815f6810b84f8ee108", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a70139027f7f9f64cf1581815f6810b84f8ee108"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298412a6e87be2213bbfc5e6fada9795c405ea13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298412a6e87be2213bbfc5e6fada9795c405ea13", "html_url": "https://github.com/rust-lang/rust/commit/298412a6e87be2213bbfc5e6fada9795c405ea13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298412a6e87be2213bbfc5e6fada9795c405ea13/comments", "author": {"login": "wycats", "id": 4, "node_id": "MDQ6VXNlcjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wycats", "html_url": "https://github.com/wycats", "followers_url": "https://api.github.com/users/wycats/followers", "following_url": "https://api.github.com/users/wycats/following{/other_user}", "gists_url": "https://api.github.com/users/wycats/gists{/gist_id}", "starred_url": "https://api.github.com/users/wycats/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wycats/subscriptions", "organizations_url": "https://api.github.com/users/wycats/orgs", "repos_url": "https://api.github.com/users/wycats/repos", "events_url": "https://api.github.com/users/wycats/events{/privacy}", "received_events_url": "https://api.github.com/users/wycats/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ed473487323bb4e5a600a3318e0981981214210", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ed473487323bb4e5a600a3318e0981981214210", "html_url": "https://github.com/rust-lang/rust/commit/2ed473487323bb4e5a600a3318e0981981214210"}], "stats": {"total": 308, "additions": 244, "deletions": 64}, "files": [{"sha": "1ac6fdc5ab122800b9d4a565bf7f9442064752fa", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 201, "deletions": 56, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/298412a6e87be2213bbfc5e6fada9795c405ea13/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298412a6e87be2213bbfc5e6fada9795c405ea13/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=298412a6e87be2213bbfc5e6fada9795c405ea13", "patch": "@@ -56,9 +56,9 @@ use io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use io::{IoResult, IoError, FileStat, SeekStyle, Seek, Writer, Reader};\n use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n use io;\n+use io;\n use iter::Iterator;\n use kinds::Send;\n-use libc;\n use option::{Some, None, Option};\n use owned::Box;\n use path::{Path, GenericPath};\n@@ -138,15 +138,19 @@ impl File {\n             Write => rtio::Write,\n             ReadWrite => rtio::ReadWrite,\n         };\n-        LocalIo::maybe_raise(|io| {\n+        let err = LocalIo::maybe_raise(|io| {\n             io.fs_open(&path.to_c_str(), mode, access).map(|fd| {\n                 File {\n                     path: path.clone(),\n                     fd: fd,\n                     last_nread: -1\n                 }\n             })\n-        }).map_err(IoError::from_rtio_error)\n+        }).map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't open file\", |e| {\n+            format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n+                mode_string(mode), access_string(access))\n+        })\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -185,6 +189,7 @@ impl File {\n     /// ```\n     pub fn create(path: &Path) -> IoResult<File> {\n         File::open_mode(path, Truncate, Write)\n+            .update_desc(\"couldn't create file\")\n     }\n \n     /// Returns the original path which was used to open this file.\n@@ -196,15 +201,19 @@ impl File {\n     /// device. This will flush any internal buffers necessary to perform this\n     /// operation.\n     pub fn fsync(&mut self) -> IoResult<()> {\n-        self.fd.fsync().map_err(IoError::from_rtio_error)\n+        let err = self.fd.fsync().map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't fsync file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n     /// file metadata to the filesystem. This is intended for use case which\n     /// must synchronize content, but don't need the metadata on disk. The goal\n     /// of this method is to reduce disk operations.\n     pub fn datasync(&mut self) -> IoResult<()> {\n-        self.fd.datasync().map_err(IoError::from_rtio_error)\n+        let err = self.fd.datasync().map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't datasync file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -216,7 +225,10 @@ impl File {\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        self.fd.truncate(size).map_err(IoError::from_rtio_error)\n+        let err = self.fd.truncate(size).map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't truncate file\", |e| {\n+            format!(\"{}; path={}; size={}\", e, self.path.display(), size)\n+        })\n     }\n \n     /// Tests whether this stream has reached EOF.\n@@ -229,10 +241,12 @@ impl File {\n \n     /// Queries information about the underlying file.\n     pub fn stat(&mut self) -> IoResult<FileStat> {\n-        match self.fd.fstat() {\n+        let err = match self.fd.fstat() {\n             Ok(s) => Ok(from_rtio(s)),\n             Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        };\n+        err.update_err(\"couldn't fstat file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -258,9 +272,11 @@ impl File {\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n pub fn unlink(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_unlink(&path.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't unlink path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -285,10 +301,12 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n /// to perform a `stat` call on the given path or if there is no entry in the\n /// filesystem at the provided path.\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n+    let err = match LocalIo::maybe_raise(|io| io.fs_stat(&path.to_c_str())) {\n         Ok(s) => Ok(from_rtio(s)),\n         Err(e) => Err(IoError::from_rtio_error(e)),\n-    }\n+    };\n+    err.update_err(\"couldn't stat path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -300,10 +318,12 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n+    let err = match LocalIo::maybe_raise(|io| io.fs_lstat(&path.to_c_str())) {\n         Ok(s) => Ok(from_rtio(s)),\n         Err(e) => Err(IoError::from_rtio_error(e)),\n-    }\n+    };\n+    err.update_err(\"couldn't lstat path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n fn from_rtio(s: rtio::FileStat) -> FileStat {\n@@ -359,9 +379,12 @@ fn from_rtio(s: rtio::FileStat) -> FileStat {\n /// permissions to view the contents, or if some other intermittent I/O error\n /// occurs.\n pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't rename path\", |e| {\n+        format!(\"{}; from={}; to={}\", e, from.display(), to.display())\n+    })\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -393,12 +416,17 @@ pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n /// ensured to not exist, there is nothing preventing the destination from\n /// being created and then destroyed by this operation.\n pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n+    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n+        result.update_err(\"couldn't copy path\",\n+            |e| format!(\"{}; from={}; to={}\", e, from.display(), to.display()))\n+    }\n+\n     if !from.is_file() {\n-        return Err(IoError {\n+        return update_err(Err(IoError {\n             kind: io::MismatchedFileTypeForOperation,\n             desc: \"the source path is not an existing file\",\n-            detail: None,\n-        })\n+            detail: None\n+        }), from, to)\n     }\n \n     let mut reader = try!(File::open(from));\n@@ -409,12 +437,12 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n         let amt = match reader.read(buf) {\n             Ok(n) => n,\n             Err(ref e) if e.kind == io::EndOfFile => { break }\n-            Err(e) => return Err(e)\n+            Err(e) => return update_err(Err(e), from, to)\n         };\n         try!(writer.write(buf.slice_to(amt)));\n     }\n \n-    chmod(to, try!(from.stat()).perm)\n+    chmod(to, try!(update_err(from.stat(), from, to)).perm)\n }\n \n /// Changes the permission mode bits found on a file or a directory. This\n@@ -439,33 +467,45 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n /// Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_chmod(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't chmod path\", |e| {\n+        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n+    })\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_chown(&path.to_c_str(), uid, gid)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't chown path\", |e| {\n+        format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid)\n+    })\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n /// link pointing to the `src` path. Note that systems often require these\n /// two paths to both be located on the same filesystem.\n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_link(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't link path\", |e| {\n+        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n+    })\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n /// symlink pointing to the `src` path.\n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_symlink(&src.to_c_str(), &dst.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't symlink path\", |e| {\n+        format!(\"{}; src={}; dest={}\", e, src.display(), dst.display())\n+    })\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -475,9 +515,11 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file which is not a symlink.\n pub fn readlink(path: &Path) -> IoResult<Path> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         Ok(Path::new(try!(io.fs_readlink(&path.to_c_str()))))\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't resolve symlink for path\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -498,9 +540,12 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n /// This call will return an error if the user lacks permissions to make a new\n /// directory at the provided path, or if the directory already exists.\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_mkdir(&path.to_c_str(), mode.bits() as uint)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't create directory\", |e| {\n+        format!(\"{}; path={}; mode={}\", e, path.display(), mode)\n+    })\n }\n \n /// Remove an existing, empty directory\n@@ -520,9 +565,11 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This call will return an error if the user lacks permissions to remove the\n /// directory at the provided path, or if the directory isn't empty.\n pub fn rmdir(path: &Path) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_rmdir(&path.to_c_str())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't remove directory\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -557,19 +604,25 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n /// permissions to view the contents or if the `path` points at a non-directory\n /// file\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         Ok(try!(io.fs_readdir(&path.to_c_str(), 0)).move_iter().map(|a| {\n             Path::new(a)\n         }).collect())\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't read directory\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n /// rooted at `path`. The path given will not be iterated over, and this will\n /// perform iteration in some top-down order.  The contents of unreadable\n /// subdirectories are ignored.\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n-    Ok(Directories { stack: try!(readdir(path)) })\n+    Ok(Directories {\n+        stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n+                                             |e| format!(\"{}; path={}\",\n+                                                         e, path.display())))\n+    })\n }\n \n /// An iterator which walks over a directory\n@@ -582,7 +635,12 @@ impl Iterator<Path> for Directories {\n         match self.stack.pop() {\n             Some(path) => {\n                 if path.is_dir() {\n-                    match readdir(&path) {\n+                    let result = readdir(&path)\n+                        .update_err(\"couldn't advance Directories iterator\",\n+                                    |e| format!(\"{}; path={}\",\n+                                                e, path.display()));\n+\n+                    match result {\n                         Ok(dirs) => { self.stack.push_all_move(dirs); }\n                         Err(..) => {}\n                     }\n@@ -614,7 +672,11 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     for c in comps {\n         curpath.push(c);\n \n-        match mkdir(&curpath, mode) {\n+        let result = mkdir(&curpath, mode)\n+            .update_err(\"couldn't recursively mkdir\",\n+                        |e| format!(\"{}; path={}\", e, path.display()));\n+\n+        match result {\n             Err(mkdir_err) => {\n                 // already exists ?\n                 if try!(stat(&curpath)).kind != io::TypeDirectory {\n@@ -639,26 +701,38 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n     let mut rm_stack = Vec::new();\n     rm_stack.push(path.clone());\n \n+    fn rmdir_failed(err: &IoError, path: &Path) -> String {\n+        format!(\"rmdir_recursive failed; path={}; cause={}\",\n+                path.display(), err)\n+    }\n+\n+    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> {\n+        err.update_err(\"couldn't recursively rmdir\",\n+                       |e| rmdir_failed(e, path))\n+    }\n+\n     while !rm_stack.is_empty() {\n-        let children = try!(readdir(rm_stack.last().unwrap()));\n+        let children = try!(readdir(rm_stack.last().unwrap())\n+            .update_detail(|e| rmdir_failed(e, path)));\n+\n         let mut has_child_dir = false;\n \n         // delete all regular files in the way and push subdirs\n         // on the stack\n         for child in children.move_iter() {\n             // FIXME(#12795) we should use lstat in all cases\n             let child_type = match cfg!(windows) {\n-                true => try!(stat(&child)).kind,\n-                false => try!(lstat(&child)).kind\n+                true => try!(update_err(stat(&child), path)),\n+                false => try!(update_err(lstat(&child), path))\n             };\n \n-            if child_type == io::TypeDirectory {\n+            if child_type.kind == io::TypeDirectory {\n                 rm_stack.push(child);\n                 has_child_dir = true;\n             } else {\n                 // we can carry on safely if the file is already gone\n                 // (eg: deleted by someone else since readdir)\n-                match unlink(&child) {\n+                match update_err(unlink(&child), path) {\n                     Ok(()) => (),\n                     Err(ref e) if e.kind == io::FileNotFound => (),\n                     Err(e) => return Err(e)\n@@ -668,7 +742,8 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n \n         // if no subdir was found, let's pop and delete\n         if !has_child_dir {\n-            match rmdir(&rm_stack.pop().unwrap()) {\n+            let result = update_err(rmdir(&rm_stack.pop().unwrap()), path);\n+            match result {\n                 Ok(()) => (),\n                 Err(ref e) if e.kind == io::FileNotFound => (),\n                 Err(e) => return Err(e)\n@@ -685,18 +760,28 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n /// be in milliseconds.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    LocalIo::maybe_raise(|io| {\n+    let err = LocalIo::maybe_raise(|io| {\n         io.fs_utime(&path.to_c_str(), atime, mtime)\n-    }).map_err(IoError::from_rtio_error)\n+    }).map_err(IoError::from_rtio_error);\n+    err.update_err(\"couldn't change_file_times\",\n+                   |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n impl Reader for File {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n-        match self.fd.read(buf) {\n+        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n+            result.update_err(\"couldn't read file\",\n+                              |e| format!(\"{}; path={}\",\n+                                          e, file.path.display()))\n+        }\n+\n+        let result: IoResult<int> = update_err(self.fd.read(buf), self);\n+\n+        match result {\n             Ok(read) => {\n                 self.last_nread = read;\n                 match read {\n-                    0 => Err(io::standard_error(io::EndOfFile)),\n+                    0 => update_err(Err(standard_error(io::EndOfFile)), self),\n                     _ => Ok(read as uint)\n                 }\n             },\n@@ -707,13 +792,17 @@ impl Reader for File {\n \n impl Writer for File {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.fd.write(buf).map_err(IoError::from_rtio_error)\n+        let err = self.fd.write(buf).map_err(IoError::from_rtio_error)\n+        err.update_err(\"couldn't write to file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n-        self.fd.tell().map_err(IoError::from_rtio_error)\n+        let err = self.fd.tell().map_err(IoError::from_rtio_error);\n+        err.update_err(\"couldn't retrieve file cursor (`tell`)\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n@@ -722,14 +811,16 @@ impl Seek for File {\n             SeekCur => rtio::SeekCur,\n             SeekEnd => rtio::SeekEnd,\n         };\n-        match self.fd.seek(pos, style) {\n+        let err = match self.fd.seek(pos, style) {\n             Ok(_) => {\n                 // successful seek resets EOF indicator\n                 self.last_nread = -1;\n                 Ok(())\n             }\n             Err(e) => Err(IoError::from_rtio_error(e)),\n-        }\n+        };\n+        err.update_err(\"couldn't seek in file\",\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -779,6 +870,22 @@ impl path::Path {\n     }\n }\n \n+fn mode_string(mode: FileMode) -> &'static str {\n+    match mode {\n+        super::Open => \"open\",\n+        super::Append => \"append\",\n+        super::Truncate => \"truncate\"\n+    }\n+}\n+\n+fn access_string(access: FileAccess) -> &'static str {\n+    match access {\n+        super::Read => \"read\",\n+        super::Write => \"write\",\n+        super::ReadWrite => \"readwrite\"\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(unused_imports)]\n mod test {\n@@ -801,6 +908,14 @@ mod test {\n         }\n     ) )\n \n+    macro_rules! error( ($e:expr, $s:expr) => (\n+        match $e {\n+            Ok(val) => fail!(\"Should have been an error, was {:?}\", val),\n+            Err(ref err) => assert!(err.to_str().as_slice().contains($s.as_slice()),\n+                                    format!(\"`{}` did not contain `{}`\", err, $s))\n+        }\n+    ) )\n+\n     struct TempDir(Path);\n \n     impl TempDir {\n@@ -856,13 +971,21 @@ mod test {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let result = File::open_mode(filename, Open, Read);\n-        assert!(result.is_err());\n+\n+        error!(result, \"couldn't open file\");\n+        error!(result, \"no such file or directory\");\n+        error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n     })\n \n     iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-        assert!(unlink(filename).is_err());\n+\n+        let result = unlink(filename);\n+\n+        error!(result, \"couldn't unlink path\");\n+        error!(result, \"no such file or directory\");\n+        error!(result, format!(\"path={}\", filename.display()));\n     })\n \n     iotest!(fn file_test_io_non_positional_read() {\n@@ -1091,6 +1214,22 @@ mod test {\n         assert!(dir.is_dir())\n     })\n \n+    iotest!(fn recursive_mkdir_failure() {\n+        let tmpdir = tmpdir();\n+        let dir = tmpdir.join(\"d1\");\n+        let file = dir.join(\"f1\");\n+\n+        check!(mkdir_recursive(&dir, io::UserRWX));\n+        check!(File::create(&file));\n+\n+        let result = mkdir_recursive(&file, io::UserRWX);\n+\n+        error!(result, \"couldn't recursively mkdir\");\n+        error!(result, \"couldn't create directory\");\n+        error!(result, \"mode=FilePermission { bits: 448 }\");\n+        error!(result, format!(\"path={}\", file.display()));\n+    })\n+\n     iotest!(fn recursive_mkdir_slash() {\n         check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n     })\n@@ -1147,6 +1286,12 @@ mod test {\n     iotest!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n+\n+        error!(copy(&from, &to),\n+            format!(\"couldn't copy path (the source path is not an \\\n+                    existing file; from={}; to={})\",\n+                    from.display(), to.display()));\n+\n         match copy(&from, &to) {\n             Ok(..) => fail!(),\n             Err(..) => {"}, {"sha": "a7f84899a622e1703858bab178a2fe3059a6bdbc", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/298412a6e87be2213bbfc5e6fada9795c405ea13/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298412a6e87be2213bbfc5e6fada9795c405ea13/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=298412a6e87be2213bbfc5e6fada9795c405ea13", "patch": "@@ -232,7 +232,7 @@ use owned::Box;\n use result::{Ok, Err, Result};\n use rt::rtio;\n use slice::{Vector, MutableVector, ImmutableVector};\n-use str::{StrSlice, StrAllocating};\n+use str::{Str, StrSlice, StrAllocating};\n use str;\n use string::String;\n use uint;\n@@ -309,6 +309,7 @@ impl IoError {\n     /// struct is filled with an allocated string describing the error\n     /// in more detail, retrieved from the operating system.\n     pub fn from_errno(errno: uint, detail: bool) -> IoError {\n+\n         #[cfg(windows)]\n         fn get_err(errno: i32) -> (IoErrorKind, &'static str) {\n             match errno {\n@@ -388,8 +389,8 @@ impl IoError {\n         IoError {\n             kind: kind,\n             desc: desc,\n-            detail: if detail {\n-                Some(os::error_string(errno))\n+            detail: if detail && kind == OtherIoError {\n+                Some(os::error_string(errno).as_slice().chars().map(|c| c.to_lowercase()).collect())\n             } else {\n                 None\n             },\n@@ -420,10 +421,13 @@ impl IoError {\n \n impl fmt::Show for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"{}\", self.desc));\n-        match self.detail {\n-            Some(ref s) => write!(fmt, \" ({})\", *s),\n-            None => Ok(())\n+        match *self {\n+            IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail) } =>\n+                write!(fmt, \"{}\", detail),\n+            IoError { detail: None, desc, .. } =>\n+                write!(fmt, \"{}\", desc),\n+            IoError { detail: Some(ref detail), desc, .. } =>\n+                write!(fmt, \"{} ({})\", desc, detail)\n         }\n     }\n }\n@@ -484,6 +488,37 @@ pub enum IoErrorKind {\n     NoProgress,\n }\n \n+/// A trait that lets you add a `detail` to an IoError easily\n+trait UpdateIoError<T> {\n+    /// Returns an IoError with updated description and detail\n+    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> Self;\n+\n+    /// Returns an IoError with updated detail\n+    fn update_detail(self, detail: |&IoError| -> String) -> Self;\n+\n+    /// Returns an IoError with update description\n+    fn update_desc(self, desc: &'static str) -> Self;\n+}\n+\n+impl<T> UpdateIoError<T> for IoResult<T> {\n+    fn update_err(self, desc: &'static str, detail: |&IoError| -> String) -> IoResult<T> {\n+        self.map_err(|mut e| {\n+            let detail = detail(&e);\n+            e.desc = desc;\n+            e.detail = Some(detail);\n+            e\n+        })\n+    }\n+\n+    fn update_detail(self, detail: |&IoError| -> String) -> IoResult<T> {\n+        self.map_err(|mut e| { e.detail = Some(detail(&e)); e })\n+    }\n+\n+    fn update_desc(self, desc: &'static str) -> IoResult<T> {\n+        self.map_err(|mut e| { e.desc = desc; e })\n+    }\n+}\n+\n static NO_PROGRESS_LIMIT: uint = 1000;\n \n /// A trait for objects which are byte-oriented streams. Readers are defined by\n@@ -1577,7 +1612,7 @@ pub fn standard_error(kind: IoErrorKind) -> IoError {\n         ConnectionAborted => \"connection aborted\",\n         NotConnected => \"not connected\",\n         BrokenPipe => \"broken pipe\",\n-        PathAlreadyExists => \"file exists\",\n+        PathAlreadyExists => \"file already exists\",\n         PathDoesntExist => \"no such file\",\n         MismatchedFileTypeForOperation => \"mismatched file type\",\n         ResourceUnavailable => \"resource unavailable\","}]}