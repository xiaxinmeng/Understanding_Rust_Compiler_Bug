{"sha": "ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiN2I0YThiZjVlYzY2YzJiMThhNWEyMzJhYmM0MDMxMGQ2Y2ZiNzU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-03-02T01:12:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-03-02T01:12:33Z"}, "message": "Revert \"Remove rustfmt and cargo-fmt\"\n\nThis reverts commit 9d2229f2fdf59b1cc80aea8851e14db81c55c82f.\n\nAnd `cargo updates`", "tree": {"sha": "d843b97a4dc134144ca8c3b369045d7b7333cc13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d843b97a4dc134144ca8c3b369045d7b7333cc13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "html_url": "https://github.com/rust-lang/rust/commit/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f377d1f59ce66b33a6a9677795a98cec6943a710", "url": "https://api.github.com/repos/rust-lang/rust/commits/f377d1f59ce66b33a6a9677795a98cec6943a710", "html_url": "https://github.com/rust-lang/rust/commit/f377d1f59ce66b33a6a9677795a98cec6943a710"}], "stats": {"total": 1086, "additions": 1075, "deletions": 11}, "files": [{"sha": "9d8eddd102c9e6aed63959e7adf7fac33cf17eca", "filename": "Cargo.lock", "status": "modified", "additions": 119, "deletions": 4, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -16,11 +16,58 @@ dependencies = [\n  \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace-sys 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"backtrace-sys\"\n+version = \"0.1.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"cc 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"libc 0.2.37 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"cargo-fmt\"\n+version = \"0.4.0\"\n+dependencies = [\n+ \"cargo_metadata 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"cfg-if\"\n version = \"0.1.2\"\n@@ -45,6 +92,15 @@ name = \"dtoa\"\n version = \"0.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"env_logger\"\n+version = \"0.4.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"env_logger\"\n version = \"0.5.4\"\n@@ -57,6 +113,14 @@ dependencies = [\n  \"termcolor 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"fuchsia-zircon\"\n version = \"0.3.3\"\n@@ -145,7 +209,7 @@ dependencies = [\n \n [[package]]\n name = \"num-traits\"\n-version = \"0.2.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -292,9 +356,36 @@ dependencies = [\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[[package]]\n+name = \"rustfmt-bin\"\n+version = \"0.4.0\"\n+dependencies = [\n+ \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-config 0.4.0\",\n+ \"rustfmt-core 0.4.0\",\n+]\n+\n+[[package]]\n+name = \"rustfmt-config\"\n+version = \"0.4.0\"\n+dependencies = [\n+ \"rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"rustfmt-config\"\n version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -316,7 +407,7 @@ dependencies = [\n  \"regex 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-rustc_errors 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-config 0.4.0\",\n+ \"rustfmt-config 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -335,6 +426,20 @@ dependencies = [\n  \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"semver\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"serde\"\n version = \"1.0.27\"\n@@ -366,7 +471,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"itoa 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"num-traits 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num-traits 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -515,12 +620,18 @@ dependencies = [\n [metadata]\n \"checksum aho-corasick 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6531d44de723825aa81398a6415283229725a00fa30713812ab9323faa82fc4\"\n \"checksum atty 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8352656fd42c30a0c3c89d26dea01e3b77c0ab2af18230835c15e2e13cd51859\"\n+\"checksum backtrace 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ebbbf59b1c43eefa8c3ede390fcc36820b4999f7914104015be25025e0d62af2\"\n+\"checksum backtrace-sys 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44585761d6161b0f57afc49482ab6bd067e4edef48c12a152c237eb0203f7661\"\n \"checksum bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3c30d3802dfb7281680d6285f2ccdaa8c2d8fee41f93805dba5c4cf50dc23cf\"\n+\"checksum cargo_metadata 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f410f43295c912ae1328de55e5c050dbef882c17b836f5ed41cc8b96c40d6cc5\"\n+\"checksum cc 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"deaf9ec656256bb25b404c51ef50097207b9cbb29c933d31f92cae5a8a0ffee0\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n \"checksum derive-new 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"415f627ab054041c3eb748c2e1da0ef751989f5f0c386b63a098e545854a98ba\"\n \"checksum diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n \"checksum dtoa 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"09c3753c3db574d215cba4ea76018483895d7bff25a31b49ba45db21c48e50ab\"\n+\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum env_logger 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f3cc21490995c841d68e00276eba02071ebb269ec24011d5728bd00eabd39e31\"\n+\"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum fuchsia-zircon 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2e9763c69ebaae630ba35f74888db465e49e259ba1bc0eda7d06f4a067615d82\"\n \"checksum fuchsia-zircon-sys 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3dcaa9ae7725d12cdb85b3ad99a434db70b468c09ded17e012d86b5c1010f7a7\"\n \"checksum getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b900c08c1939860ce8b54dc6a89e26e00c04c380fd0e09796799bd7f12861e05\"\n@@ -532,7 +643,7 @@ dependencies = [\n \"checksum log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e19e8d5c34a3e0e2223db8e060f9e8264aeeb5c5fc64a4ee9965c062211c024b\"\n \"checksum log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"89f010e843f2b1a31dbd316b3b8d443758bc634bed37aabade59c686d644e0a2\"\n \"checksum memchr 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"796fba70e76612589ed2ce7f45282f5af869e0fdd7cc6199fa1aa1f1d591ba9d\"\n-\"checksum num-traits 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e7de20f146db9d920c45ee8ed8f71681fd9ade71909b48c3acbd766aa504cf10\"\n+\"checksum num-traits 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0b3c2bd9b9d21e48e956b763c9f37134dc62d9e95da6edb3f672cacb6caf3cd3\"\n \"checksum owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cdf84f41639e037b484f93433aa3897863b561ed65c6e59c7073d7c561710f37\"\n \"checksum parking_lot 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9fd9d732f2de194336fb02fe11f9eed13d9e76f13f4315b4d88a14ca411750cd\"\n \"checksum parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"538ef00b7317875071d5e00f603f24d16f0b474c1a5fc0ccb8b454ca72eafa79\"\n@@ -549,6 +660,10 @@ dependencies = [\n \"checksum rustc-ap-serialize 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e0745fa445ff41c4b6699936cf35ce3ca49502377dd7b3929c829594772c3a7b\"\n \"checksum rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82efedabe30f393161e11214a9130edfa01ad476372d1c6f3fec1f8d30488c9d\"\n \"checksum rustc-ap-syntax_pos 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db9de2e927e280c75b8efab9c5f591ad31082d5d2c4c562c68fdba2ee77286b0\"\n+\"checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb\"\n+\"checksum rustfmt-config 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2bb115c177399885a8bd398940f1553476273ea9475038a0a9ef73e7cc9c8663\"\n+\"checksum semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bee2bc909ab2d8d60dab26e8cad85b25d795b14603a0dcb627b78b9d30b6454b\"\n+\"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db99f3919e20faa51bb2996057f5031d8685019b5a06139b1ce761da671b8526\"\n \"checksum serde_derive 1.0.27 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f4ba7591cfe93755e89eeecdbcc668885624829b020050e6aec99c2a03bd3fd0\"\n \"checksum serde_derive_internals 0.19.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6e03f1c9530c3fb0a0a5c9b826bdd9246a5921ae995d75f512ac917fc4dd55b5\""}, {"sha": "63d3c534221942fd62f4db4adc66ef9668e1f476", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -1,11 +1,9 @@\n [workspace]\n members = [\n+    \"cargo-fmt\",\n     \"git-rustfmt\",\n+    \"rustfmt-bin\",\n     \"rustfmt-config\",\n     \"rustfmt-core\",\n     \"rustfmt-format-diff\",\n ]\n-\n-[patch.crates-io]\n-rustfmt-config = { path = \"rustfmt-config\" }\n-rustfmt-core = { path = \"rustfmt-core\" }"}, {"sha": "5e4e1da9204bcd5c36ca63915469da18f8aef2de", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -146,7 +146,9 @@ script:\n \n `cargo test` to run all tests.\n \n-To run Rustfmt, you'll need the binaries repo: https://github.com/rust-lang-nursery/rustfmt-bin\n+To run rustfmt after this, use `cargo run --bin rustfmt -- filename`. See the\n+notes above on running rustfmt.\n+\n \n ## Configuring Rustfmt\n "}, {"sha": "8714265723161798766a043632d25ade8b7a220b", "filename": "cargo-fmt/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/cargo-fmt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/cargo-fmt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-fmt%2FCargo.toml?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+name = \"cargo-fmt\"\n+version = \"0.4.0\"\n+authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n+description = \"Cargo frontend for rustfmt\"\n+repository = \"https://github.com/rust-lang-nursery/rustfmt\"\n+readme = \"README.md\"\n+license = \"Apache-2.0/MIT\"\n+categories = [\"development-tools\"]\n+\n+[[bin]]\n+name = \"cargo-fmt\"\n+\n+[dependencies]\n+cargo_metadata = \"0.4\"\n+getopts = \"0.2\"\n+serde_json = \"1.0\""}, {"sha": "1acad99688a25cc8563813acd7cbc505e7fdb1eb", "filename": "cargo-fmt/src/main.rs", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/cargo-fmt%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/cargo-fmt%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-fmt%2Fsrc%2Fmain.rs?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -0,0 +1,373 @@\n+// Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Inspired by Paul Woolcock's cargo-fmt (https://github.com/pwoolcoc/cargo-fmt/)\n+\n+#![cfg(not(test))]\n+#![deny(warnings)]\n+\n+extern crate cargo_metadata;\n+extern crate getopts;\n+extern crate serde_json as json;\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::fs;\n+use std::hash::{Hash, Hasher};\n+use std::io::{self, Write};\n+use std::iter::FromIterator;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, ExitStatus};\n+use std::str;\n+\n+use getopts::{Matches, Options};\n+\n+fn main() {\n+    let exit_status = execute();\n+    std::io::stdout().flush().unwrap();\n+    std::process::exit(exit_status);\n+}\n+\n+const SUCCESS: i32 = 0;\n+const FAILURE: i32 = 1;\n+\n+fn execute() -> i32 {\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+    opts.optflag(\"q\", \"quiet\", \"no output printed to stdout\");\n+    opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n+    opts.optmulti(\n+        \"p\",\n+        \"package\",\n+        \"specify package to format (only usable in workspaces)\",\n+        \"<package>\",\n+    );\n+    opts.optflag(\"\", \"version\", \"print rustfmt version and exit\");\n+    opts.optflag(\"\", \"all\", \"format all packages (only usable in workspaces)\");\n+\n+    // If there is any invalid argument passed to `cargo fmt`, return without formatting.\n+    let mut is_package_arg = false;\n+    for arg in env::args().skip(2).take_while(|a| a != \"--\") {\n+        if arg.starts_with('-') {\n+            is_package_arg = arg.starts_with(\"--package\");\n+        } else if !is_package_arg {\n+            print_usage_to_stderr(&opts, &format!(\"Invalid argument: `{}`.\", arg));\n+            return FAILURE;\n+        } else {\n+            is_package_arg = false;\n+        }\n+    }\n+\n+    let matches = match opts.parse(env::args().skip(1).take_while(|a| a != \"--\")) {\n+        Ok(m) => m,\n+        Err(e) => {\n+            print_usage_to_stderr(&opts, &e.to_string());\n+            return FAILURE;\n+        }\n+    };\n+\n+    let verbosity = match (matches.opt_present(\"v\"), matches.opt_present(\"q\")) {\n+        (false, false) => Verbosity::Normal,\n+        (false, true) => Verbosity::Quiet,\n+        (true, false) => Verbosity::Verbose,\n+        (true, true) => {\n+            print_usage_to_stderr(&opts, \"quiet mode and verbose mode are not compatible\");\n+            return FAILURE;\n+        }\n+    };\n+\n+    if matches.opt_present(\"h\") {\n+        print_usage_to_stdout(&opts, \"\");\n+        return SUCCESS;\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        return handle_command_status(get_version(verbosity), &opts);\n+    }\n+\n+    let strategy = CargoFmtStrategy::from_matches(&matches);\n+    handle_command_status(format_crate(verbosity, &strategy), &opts)\n+}\n+\n+macro_rules! print_usage {\n+    ($print: ident, $opts: ident, $reason: expr) => {{\n+        let msg = format!(\"{}\\nusage: cargo fmt [options]\", $reason);\n+        $print!(\n+            \"{}\\nThis utility formats all bin and lib files of the current crate using rustfmt. \\\n+             Arguments after `--` are passed to rustfmt.\",\n+            $opts.usage(&msg)\n+        );\n+    }};\n+}\n+\n+fn print_usage_to_stdout(opts: &Options, reason: &str) {\n+    print_usage!(println, opts, reason);\n+}\n+\n+fn print_usage_to_stderr(opts: &Options, reason: &str) {\n+    print_usage!(eprintln, opts, reason);\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum Verbosity {\n+    Verbose,\n+    Normal,\n+    Quiet,\n+}\n+\n+fn handle_command_status(status: Result<ExitStatus, io::Error>, opts: &getopts::Options) -> i32 {\n+    match status {\n+        Err(e) => {\n+            print_usage_to_stderr(opts, &e.to_string());\n+            FAILURE\n+        }\n+        Ok(status) => {\n+            if status.success() {\n+                SUCCESS\n+            } else {\n+                status.code().unwrap_or(FAILURE)\n+            }\n+        }\n+    }\n+}\n+\n+fn get_version(verbosity: Verbosity) -> Result<ExitStatus, io::Error> {\n+    run_rustfmt(&[], &[String::from(\"--version\")], verbosity)\n+}\n+\n+fn format_crate(\n+    verbosity: Verbosity,\n+    strategy: &CargoFmtStrategy,\n+) -> Result<ExitStatus, io::Error> {\n+    let rustfmt_args = get_fmt_args();\n+    let targets = if rustfmt_args.iter().any(|s| s == \"--dump-default-config\") {\n+        HashSet::new()\n+    } else {\n+        get_targets(strategy)?\n+    };\n+\n+    // Currently only bin and lib files get formatted\n+    let files: Vec<_> = targets\n+        .into_iter()\n+        .inspect(|t| {\n+            if verbosity == Verbosity::Verbose {\n+                println!(\"[{}] {:?}\", t.kind, t.path)\n+            }\n+        })\n+        .map(|t| t.path)\n+        .collect();\n+\n+    run_rustfmt(&files, &rustfmt_args, verbosity)\n+}\n+\n+fn get_fmt_args() -> Vec<String> {\n+    // All arguments after -- are passed to rustfmt\n+    env::args().skip_while(|a| a != \"--\").skip(1).collect()\n+}\n+\n+/// Target uses a `path` field for equality and hashing.\n+#[derive(Debug)]\n+pub struct Target {\n+    /// A path to the main source file of the target.\n+    path: PathBuf,\n+    /// A kind of target (e.g. lib, bin, example, ...).\n+    kind: String,\n+}\n+\n+impl Target {\n+    pub fn from_target(target: &cargo_metadata::Target) -> Self {\n+        let path = PathBuf::from(&target.src_path);\n+        let canonicalized = fs::canonicalize(&path).unwrap_or(path);\n+\n+        Target {\n+            path: canonicalized,\n+            kind: target.kind[0].clone(),\n+        }\n+    }\n+}\n+\n+impl PartialEq for Target {\n+    fn eq(&self, other: &Target) -> bool {\n+        self.path == other.path\n+    }\n+}\n+\n+impl Eq for Target {}\n+\n+impl Hash for Target {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.path.hash(state);\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum CargoFmtStrategy {\n+    /// Format every packages and dependencies.\n+    All,\n+    /// Format pacakges that are specified by the command line argument.\n+    Some(Vec<String>),\n+    /// Format the root packages only.\n+    Root,\n+}\n+\n+impl CargoFmtStrategy {\n+    pub fn from_matches(matches: &Matches) -> CargoFmtStrategy {\n+        match (matches.opt_present(\"all\"), matches.opt_present(\"p\")) {\n+            (false, false) => CargoFmtStrategy::Root,\n+            (true, _) => CargoFmtStrategy::All,\n+            (false, true) => CargoFmtStrategy::Some(matches.opt_strs(\"p\")),\n+        }\n+    }\n+}\n+\n+/// Based on the specified `CargoFmtStrategy`, returns a set of main source files.\n+fn get_targets(strategy: &CargoFmtStrategy) -> Result<HashSet<Target>, io::Error> {\n+    let mut targets = HashSet::new();\n+\n+    match *strategy {\n+        CargoFmtStrategy::Root => get_targets_root_only(&mut targets)?,\n+        CargoFmtStrategy::All => get_targets_recursive(None, &mut targets, &mut HashSet::new())?,\n+        CargoFmtStrategy::Some(ref hitlist) => get_targets_with_hitlist(hitlist, &mut targets)?,\n+    }\n+\n+    if targets.is_empty() {\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"Failed to find targets\".to_owned(),\n+        ))\n+    } else {\n+        Ok(targets)\n+    }\n+}\n+\n+fn get_targets_root_only(targets: &mut HashSet<Target>) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n+\n+    for package in metadata.packages {\n+        for target in package.targets {\n+            targets.insert(Target::from_target(&target));\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn get_targets_recursive(\n+    manifest_path: Option<&Path>,\n+    mut targets: &mut HashSet<Target>,\n+    visited: &mut HashSet<String>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path)?;\n+\n+    for package in metadata.packages {\n+        add_targets(&package.targets, &mut targets);\n+\n+        // Look for local dependencies.\n+        for dependency in package.dependencies {\n+            if dependency.source.is_some() || visited.contains(&dependency.name) {\n+                continue;\n+            }\n+\n+            let mut manifest_path = PathBuf::from(&package.manifest_path);\n+\n+            manifest_path.pop();\n+            manifest_path.push(&dependency.name);\n+            manifest_path.push(\"Cargo.toml\");\n+\n+            if manifest_path.exists() {\n+                visited.insert(dependency.name);\n+                get_targets_recursive(Some(&manifest_path), &mut targets, visited)?;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn get_targets_with_hitlist(\n+    hitlist: &[String],\n+    targets: &mut HashSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n+\n+    let mut workspace_hitlist: HashSet<&String> = HashSet::from_iter(hitlist);\n+\n+    for package in metadata.packages {\n+        if workspace_hitlist.remove(&package.name) {\n+            for target in package.targets {\n+                targets.insert(Target::from_target(&target));\n+            }\n+        }\n+    }\n+\n+    if workspace_hitlist.is_empty() {\n+        Ok(())\n+    } else {\n+        let package = workspace_hitlist.iter().next().unwrap();\n+        Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            format!(\"package `{}` is not a member of the workspace\", package),\n+        ))\n+    }\n+}\n+\n+fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut HashSet<Target>) {\n+    for target in target_paths {\n+        targets.insert(Target::from_target(target));\n+    }\n+}\n+\n+fn run_rustfmt(\n+    files: &[PathBuf],\n+    fmt_args: &[String],\n+    verbosity: Verbosity,\n+) -> Result<ExitStatus, io::Error> {\n+    let stdout = if verbosity == Verbosity::Quiet {\n+        std::process::Stdio::null()\n+    } else {\n+        std::process::Stdio::inherit()\n+    };\n+\n+    if verbosity == Verbosity::Verbose {\n+        print!(\"rustfmt\");\n+        for a in fmt_args {\n+            print!(\" {}\", a);\n+        }\n+        for f in files {\n+            print!(\" {}\", f.display());\n+        }\n+        println!();\n+    }\n+\n+    let mut command = Command::new(\"rustfmt\")\n+        .stdout(stdout)\n+        .args(files)\n+        .args(fmt_args)\n+        .spawn()\n+        .map_err(|e| match e.kind() {\n+            io::ErrorKind::NotFound => io::Error::new(\n+                io::ErrorKind::Other,\n+                \"Could not run rustfmt, please make sure it is in your PATH.\",\n+            ),\n+            _ => e,\n+        })?;\n+\n+    command.wait()\n+}\n+\n+fn get_cargo_metadata(manifest_path: Option<&Path>) -> Result<cargo_metadata::Metadata, io::Error> {\n+    match cargo_metadata::metadata(manifest_path) {\n+        Ok(metadata) => Ok(metadata),\n+        Err(..) => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"`cargo manifest` failed.\",\n+        )),\n+    }\n+}"}, {"sha": "5bebeff2c84b6ecd6cfdb0d573e92fa23446e89b", "filename": "git-rustfmt/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/git-rustfmt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/git-rustfmt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/git-rustfmt%2FCargo.toml?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -15,5 +15,5 @@ name = \"git-rustfmt\"\n env_logger = \"0.5\"\n getopts = \"0.2\"\n log = \"0.3\"\n-rustfmt-config = \"0.4.0\"\n-rustfmt-core = \"0.4.0\"\n+rustfmt-config = { path = \"../rustfmt-config\" }\n+rustfmt-core = { path = \"../rustfmt-core\" }\n\\ No newline at end of file"}, {"sha": "c07146dcb01967b57a035d90453f5f6cd5e7701b", "filename": "rustfmt-bin/Cargo.toml", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/rustfmt-bin%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/rustfmt-bin%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-bin%2FCargo.toml?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -0,0 +1,20 @@\n+[package]\n+name = \"rustfmt-bin\"\n+version = \"0.4.0\"\n+authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n+description = \"Tool to find and fix Rust formatting issues\"\n+repository = \"https://github.com/rust-lang-nursery/rustfmt\"\n+readme = \"README.md\"\n+license = \"Apache-2.0/MIT\"\n+build = \"build.rs\"\n+categories = [\"development-tools\"]\n+\n+[[bin]]\n+name = \"rustfmt\"\n+path = \"src/main.rs\"\n+\n+[dependencies]\n+env_logger = \"0.4\"\n+getopts = \"0.2\"\n+rustfmt-config = { path = \"../rustfmt-config\" }\n+rustfmt-core = { path = \"../rustfmt-core\" }\n\\ No newline at end of file"}, {"sha": "d72b44eb7f36426b4ccf2903a758b049d8616e9a", "filename": "rustfmt-bin/build.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/rustfmt-bin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/rustfmt-bin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-bin%2Fbuild.rs?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::fs::File;\n+use std::io::Write;\n+use std::path::PathBuf;\n+use std::process::Command;\n+\n+fn main() {\n+    let out_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+\n+    File::create(out_dir.join(\"commit-info.txt\"))\n+        .unwrap()\n+        .write_all(commit_info().as_bytes())\n+        .unwrap();\n+}\n+\n+// Try to get hash and date of the last commit on a best effort basis. If anything goes wrong\n+// (git not installed or if this is not a git repository) just return an empty string.\n+fn commit_info() -> String {\n+    match (channel(), commit_hash(), commit_date()) {\n+        (channel, Some(hash), Some(date)) => {\n+            format!(\"{} ({} {})\", channel, hash.trim_right(), date)\n+        }\n+        _ => String::new(),\n+    }\n+}\n+\n+fn channel() -> String {\n+    if let Ok(channel) = env::var(\"CFG_RELEASE_CHANNEL\") {\n+        channel\n+    } else {\n+        \"nightly\".to_owned()\n+    }\n+}\n+\n+fn commit_hash() -> Option<String> {\n+    Command::new(\"git\")\n+        .args(&[\"rev-parse\", \"--short\", \"HEAD\"])\n+        .output()\n+        .ok()\n+        .and_then(|r| String::from_utf8(r.stdout).ok())\n+}\n+\n+fn commit_date() -> Option<String> {\n+    Command::new(\"git\")\n+        .args(&[\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n+        .output()\n+        .ok()\n+        .and_then(|r| String::from_utf8(r.stdout).ok())\n+}"}, {"sha": "a058887a696f92125ab9f210603f35505833e6a1", "filename": "rustfmt-bin/src/main.rs", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/rustfmt-bin%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75/rustfmt-bin%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-bin%2Fsrc%2Fmain.rs?ref=ab7b4a8bf5ec66c2b18a5a232abc40310d6cfb75", "patch": "@@ -0,0 +1,480 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(not(test))]\n+\n+extern crate env_logger;\n+extern crate getopts;\n+extern crate rustfmt_config as config;\n+extern crate rustfmt_core as rustfmt;\n+\n+use std::{env, error};\n+use std::fs::File;\n+use std::io::{self, Read, Write};\n+use std::path::{Path, PathBuf};\n+\n+use getopts::{Matches, Options};\n+\n+use config::{get_toml_path, Color, Config, WriteMode};\n+use config::file_lines::FileLines;\n+use rustfmt::{run, FileName, Input, Summary};\n+\n+use std::str::FromStr;\n+\n+type FmtError = Box<error::Error + Send + Sync>;\n+type FmtResult<T> = std::result::Result<T, FmtError>;\n+\n+/// Rustfmt operations.\n+enum Operation {\n+    /// Format files and their child modules.\n+    Format {\n+        files: Vec<PathBuf>,\n+        config_path: Option<PathBuf>,\n+        minimal_config_path: Option<String>,\n+    },\n+    /// Print the help message.\n+    Help,\n+    // Print version information\n+    Version,\n+    /// Print detailed configuration help.\n+    ConfigHelp,\n+    /// Output default config to a file, or stdout if None\n+    ConfigOutputDefault {\n+        path: Option<String>,\n+    },\n+    /// No file specified, read from stdin\n+    Stdin {\n+        input: String,\n+        config_path: Option<PathBuf>,\n+    },\n+}\n+\n+/// Parsed command line options.\n+#[derive(Clone, Debug, Default)]\n+struct CliOptions {\n+    skip_children: bool,\n+    verbose: bool,\n+    write_mode: Option<WriteMode>,\n+    color: Option<Color>,\n+    file_lines: FileLines, // Default is all lines in all files.\n+    unstable_features: bool,\n+    error_on_unformatted: bool,\n+}\n+\n+impl CliOptions {\n+    fn from_matches(matches: &Matches) -> FmtResult<CliOptions> {\n+        let mut options = CliOptions::default();\n+        options.skip_children = matches.opt_present(\"skip-children\");\n+        options.verbose = matches.opt_present(\"verbose\");\n+        let unstable_features = matches.opt_present(\"unstable-features\");\n+        let rust_nightly = option_env!(\"CFG_RELEASE_CHANNEL\")\n+            .map(|c| c == \"nightly\")\n+            .unwrap_or(false);\n+        if unstable_features && !rust_nightly {\n+            return Err(FmtError::from(\n+                \"Unstable features are only available on Nightly channel\",\n+            ));\n+        } else {\n+            options.unstable_features = unstable_features;\n+        }\n+\n+        if let Some(ref write_mode) = matches.opt_str(\"write-mode\") {\n+            if let Ok(write_mode) = WriteMode::from_str(write_mode) {\n+                options.write_mode = Some(write_mode);\n+            } else {\n+                return Err(FmtError::from(format!(\n+                    \"Invalid write-mode: {}\",\n+                    write_mode\n+                )));\n+            }\n+        }\n+\n+        if let Some(ref color) = matches.opt_str(\"color\") {\n+            match Color::from_str(color) {\n+                Ok(color) => options.color = Some(color),\n+                _ => return Err(FmtError::from(format!(\"Invalid color: {}\", color))),\n+            }\n+        }\n+\n+        if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n+            options.file_lines = file_lines.parse()?;\n+        }\n+\n+        if matches.opt_present(\"error-on-unformatted\") {\n+            options.error_on_unformatted = true;\n+        }\n+\n+        Ok(options)\n+    }\n+\n+    fn apply_to(self, config: &mut Config) {\n+        config.set().skip_children(self.skip_children);\n+        config.set().verbose(self.verbose);\n+        config.set().file_lines(self.file_lines);\n+        config.set().unstable_features(self.unstable_features);\n+        config.set().error_on_unformatted(self.error_on_unformatted);\n+        if let Some(write_mode) = self.write_mode {\n+            config.set().write_mode(write_mode);\n+        }\n+        if let Some(color) = self.color {\n+            config.set().color(color);\n+        }\n+    }\n+}\n+\n+/// read the given config file path recursively if present else read the project file path\n+fn match_cli_path_or_file(\n+    config_path: Option<PathBuf>,\n+    input_file: &Path,\n+) -> FmtResult<(Config, Option<PathBuf>)> {\n+    if let Some(config_file) = config_path {\n+        let toml = Config::from_toml_path(config_file.as_ref())?;\n+        return Ok((toml, Some(config_file)));\n+    }\n+    Config::from_resolved_toml_path(input_file).map_err(FmtError::from)\n+}\n+\n+fn make_opts() -> Options {\n+    let mut opts = Options::new();\n+\n+    // Sorted in alphabetical order.\n+    opts.optopt(\n+        \"\",\n+        \"color\",\n+        \"Use colored output (if supported)\",\n+        \"[always|never|auto]\",\n+    );\n+    opts.optflag(\n+        \"\",\n+        \"config-help\",\n+        \"Show details of rustfmt configuration options\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"config-path\",\n+        \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+         found reverts to the input file path\",\n+        \"[Path for the configuration file]\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"dump-default-config\",\n+        \"Dumps default configuration to PATH. PATH defaults to stdout, if omitted.\",\n+        \"PATH\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"dump-minimal-config\",\n+        \"Dumps configuration options that were checked during formatting to a file.\",\n+        \"PATH\",\n+    );\n+    opts.optflag(\n+        \"\",\n+        \"error-on-unformatted\",\n+        \"Error if unable to get comments or string literals within max_width, \\\n+         or they are left with trailing whitespaces\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"file-lines\",\n+        \"Format specified line ranges. See README for more detail on the JSON format.\",\n+        \"JSON\",\n+    );\n+    opts.optflag(\"h\", \"help\", \"Show this message\");\n+    opts.optflag(\"\", \"skip-children\", \"Don't reformat child modules\");\n+    opts.optflag(\n+        \"\",\n+        \"unstable-features\",\n+        \"Enables unstable features. Only available on nightly channel\",\n+    );\n+    opts.optflag(\"v\", \"verbose\", \"Print verbose output\");\n+    opts.optflag(\"V\", \"version\", \"Show version information\");\n+    opts.optopt(\n+        \"\",\n+        \"write-mode\",\n+        \"How to write output (not usable when piping from stdin)\",\n+        \"[replace|overwrite|display|plain|diff|coverage|checkstyle]\",\n+    );\n+\n+    opts\n+}\n+\n+fn execute(opts: &Options) -> FmtResult<Summary> {\n+    let matches = opts.parse(env::args().skip(1))?;\n+\n+    match determine_operation(&matches)? {\n+        Operation::Help => {\n+            print_usage_to_stdout(opts, \"\");\n+            Summary::print_exit_codes();\n+            Ok(Summary::default())\n+        }\n+        Operation::Version => {\n+            print_version();\n+            Ok(Summary::default())\n+        }\n+        Operation::ConfigHelp => {\n+            Config::print_docs();\n+            Ok(Summary::default())\n+        }\n+        Operation::ConfigOutputDefault { path } => {\n+            let toml = Config::default().all_options().to_toml()?;\n+            if let Some(path) = path {\n+                let mut file = File::create(path)?;\n+                file.write_all(toml.as_bytes())?;\n+            } else {\n+                io::stdout().write_all(toml.as_bytes())?;\n+            }\n+            Ok(Summary::default())\n+        }\n+        Operation::Stdin { input, config_path } => {\n+            // try to read config from local directory\n+            let (mut config, _) =\n+                match_cli_path_or_file(config_path, &env::current_dir().unwrap())?;\n+\n+            // write_mode is always Plain for Stdin.\n+            config.set().write_mode(WriteMode::Plain);\n+\n+            // parse file_lines\n+            if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n+                config.set().file_lines(file_lines.parse()?);\n+                for f in config.file_lines().files() {\n+                    match *f {\n+                        FileName::Custom(ref f) if f == \"stdin\" => {}\n+                        _ => eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f),\n+                    }\n+                }\n+            }\n+\n+            let mut error_summary = Summary::default();\n+            if config.version_meets_requirement(&mut error_summary) {\n+                error_summary.add(run(Input::Text(input), &config));\n+            }\n+\n+            Ok(error_summary)\n+        }\n+        Operation::Format {\n+            files,\n+            config_path,\n+            minimal_config_path,\n+        } => {\n+            let options = CliOptions::from_matches(&matches)?;\n+\n+            for f in options.file_lines.files() {\n+                match *f {\n+                    FileName::Real(ref f) if files.contains(f) => {}\n+                    FileName::Real(_) => {\n+                        eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n+                    }\n+                    _ => eprintln!(\"Warning: Not a file '{}'\", f),\n+                }\n+            }\n+\n+            let mut config = Config::default();\n+            // Load the config path file if provided\n+            if let Some(config_file) = config_path.as_ref() {\n+                config = Config::from_toml_path(config_file.as_ref())?;\n+            };\n+\n+            if options.verbose {\n+                if let Some(path) = config_path.as_ref() {\n+                    println!(\"Using rustfmt config file {}\", path.display());\n+                }\n+            }\n+\n+            let mut error_summary = Summary::default();\n+            for file in files {\n+                if !file.exists() {\n+                    eprintln!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n+                    error_summary.add_operational_error();\n+                } else if file.is_dir() {\n+                    eprintln!(\"Error: `{}` is a directory\", file.to_str().unwrap());\n+                    error_summary.add_operational_error();\n+                } else {\n+                    // Check the file directory if the config-path could not be read or not provided\n+                    if config_path.is_none() {\n+                        let (config_tmp, path_tmp) =\n+                            Config::from_resolved_toml_path(file.parent().unwrap())?;\n+                        if options.verbose {\n+                            if let Some(path) = path_tmp.as_ref() {\n+                                println!(\n+                                    \"Using rustfmt config file {} for {}\",\n+                                    path.display(),\n+                                    file.display()\n+                                );\n+                            }\n+                        }\n+                        config = config_tmp;\n+                    }\n+\n+                    if !config.version_meets_requirement(&mut error_summary) {\n+                        break;\n+                    }\n+\n+                    options.clone().apply_to(&mut config);\n+                    error_summary.add(run(Input::File(file), &config));\n+                }\n+            }\n+\n+            // If we were given a path via dump-minimal-config, output any options\n+            // that were used during formatting as TOML.\n+            if let Some(path) = minimal_config_path {\n+                let mut file = File::create(path)?;\n+                let toml = config.used_options().to_toml()?;\n+                file.write_all(toml.as_bytes())?;\n+            }\n+\n+            Ok(error_summary)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let _ = env_logger::init();\n+\n+    let opts = make_opts();\n+\n+    let exit_code = match execute(&opts) {\n+        Ok(summary) => {\n+            if summary.has_operational_errors() {\n+                1\n+            } else if summary.has_parsing_errors() {\n+                2\n+            } else if summary.has_formatting_errors() {\n+                3\n+            } else if summary.has_diff {\n+                // should only happen in diff mode\n+                4\n+            } else {\n+                assert!(summary.has_no_errors());\n+                0\n+            }\n+        }\n+        Err(e) => {\n+            eprintln!(\"{}\", e.to_string());\n+            1\n+        }\n+    };\n+    // Make sure standard output is flushed before we exit.\n+    std::io::stdout().flush().unwrap();\n+\n+    // Exit with given exit code.\n+    //\n+    // NOTE: This immediately terminates the process without doing any cleanup,\n+    // so make sure to finish all necessary cleanup before this is called.\n+    std::process::exit(exit_code);\n+}\n+\n+fn print_usage_to_stdout(opts: &Options, reason: &str) {\n+    let sep = if reason.is_empty() {\n+        String::new()\n+    } else {\n+        format!(\"{}\\n\\n\", reason)\n+    };\n+    let msg = format!(\n+        \"{}Format Rust code\\n\\nusage: {} [options] <file>...\",\n+        sep,\n+        env::args_os().next().unwrap().to_string_lossy()\n+    );\n+    println!(\"{}\", opts.usage(&msg));\n+}\n+\n+fn print_version() {\n+    let version_info = format!(\n+        \"{}{}{}\",\n+        option_env!(\"CARGO_PKG_VERSION\").unwrap_or(\"unknown\"),\n+        \"-\",\n+        include_str!(concat!(env!(\"OUT_DIR\"), \"/commit-info.txt\"))\n+    );\n+\n+    println!(\"rustfmt {}\", version_info);\n+}\n+\n+fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n+    if matches.opt_present(\"h\") {\n+        return Ok(Operation::Help);\n+    }\n+\n+    if matches.opt_present(\"config-help\") {\n+        return Ok(Operation::ConfigHelp);\n+    }\n+\n+    if matches.opt_present(\"dump-default-config\") {\n+        // NOTE for some reason when configured with HasArg::Maybe + Occur::Optional opt_default\n+        // doesn't recognize `--foo bar` as a long flag with an argument but as a long flag with no\n+        // argument *plus* a free argument. Thus we check for that case in this branch -- this is\n+        // required for backward compatibility.\n+        if let Some(path) = matches.free.get(0) {\n+            return Ok(Operation::ConfigOutputDefault {\n+                path: Some(path.clone()),\n+            });\n+        } else {\n+            return Ok(Operation::ConfigOutputDefault {\n+                path: matches.opt_str(\"dump-default-config\"),\n+            });\n+        }\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        return Ok(Operation::Version);\n+    }\n+\n+    let config_path_not_found = |path: &str| -> FmtResult<Operation> {\n+        Err(FmtError::from(format!(\n+            \"Error: unable to find a config file for the given path: `{}`\",\n+            path\n+        )))\n+    };\n+\n+    // Read the config_path and convert to parent dir if a file is provided.\n+    // If a config file cannot be found from the given path, return error.\n+    let config_path: Option<PathBuf> = match matches.opt_str(\"config-path\").map(PathBuf::from) {\n+        Some(ref path) if !path.exists() => return config_path_not_found(path.to_str().unwrap()),\n+        Some(ref path) if path.is_dir() => {\n+            let config_file_path = get_toml_path(path)?;\n+            if config_file_path.is_some() {\n+                config_file_path\n+            } else {\n+                return config_path_not_found(path.to_str().unwrap());\n+            }\n+        }\n+        path => path,\n+    };\n+\n+    // If no path is given, we won't output a minimal config.\n+    let minimal_config_path = matches.opt_str(\"dump-minimal-config\");\n+\n+    // if no file argument is supplied, read from stdin\n+    if matches.free.is_empty() {\n+        let mut buffer = String::new();\n+        io::stdin().read_to_string(&mut buffer)?;\n+\n+        return Ok(Operation::Stdin {\n+            input: buffer,\n+            config_path,\n+        });\n+    }\n+\n+    let files: Vec<_> = matches\n+        .free\n+        .iter()\n+        .map(|s| {\n+            let p = PathBuf::from(s);\n+            // we will do comparison later, so here tries to canonicalize first\n+            // to get the expected behavior.\n+            p.canonicalize().unwrap_or(p)\n+        })\n+        .collect();\n+\n+    Ok(Operation::Format {\n+        files,\n+        config_path,\n+        minimal_config_path,\n+    })\n+}"}]}