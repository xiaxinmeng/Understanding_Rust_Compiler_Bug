{"sha": "9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllZTk2ZGNmNGEyYjQ3YTZkZjBlM2VhMzc5ZDM2YWVjMmU2ZTE3ODQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-02T08:34:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-02T08:34:03Z"}, "message": "Merge #3816\n\n3816: vscode: add goto ast node definition from rust source code r=Veetaha a=Veetaha\n\nBy holding the `Ctrl` key you can now goto-definition of the appropriate syntax token in the syntax tree read-only editor. But actually going to the definition is not very convenient, since it opens the new editor, you'd rather just hold the `Ctrl` and look at the syntax tree because it is automatically scrolled to the proper node and the node itself is enclosed with text selection.\r\n\r\nUnfortunately, the algorithm is very simple (because we don't do any elaborate parsing of the syntax tree text received from the server), but it is enough to debug not very large source files.\r\nI tested the performance and in a bad case (rust source file with 5K lines of code) it takes `1.3` seconds to build the `rust -> ast` mapping index (lazily once on the first goto definition request) and each lookup in this worst-case is approx `20-120` ms. I think this is good enough. In the simple case where the file is < 100 lines of code, it is instant.\r\n\r\nOne peculiarity that I've noticed is that vscode doesn't trigger the goto-definition provider when the user triggers it on some punctuation characters (i.e. it doesn't underline them and invoke te goto-definition provider), but if you explicitly click `Ctrl+LMB` it will only then invoke the provider and navigate to the definition in a new editor. I think this is fine ;D\r\n\r\n![rust2ast](https://user-images.githubusercontent.com/36276403/78198718-24d1d500-7492-11ea-91f6-2687cedf26ee.gif)\r\n\r\n\r\nRelated: #3682 \n\nCo-authored-by: veetaha <veetaha2@gmail.com>", "tree": {"sha": "672f5ebda7447c06ff28556515e41b13cef261e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/672f5ebda7447c06ff28556515e41b13cef261e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehaN7CRBK7hj4Ov3rIwAAdHIIADdmcvEgKyAPFjRPPjyHeTd6\nrpOlnM4DCuGjGB4owvbpIYEMmzyiIsIntm3udlvHXOMa3XzhQmPCE8ptPShURWPU\ne7AMrMoF70GJNQS1iVk+NfOvbgMnJ4tnhjwJdaGKro9VAjDxru6ggM2TAAuPXHDS\nQpNPmV6/iAY14lkSNsM7WbOffzEYP5V7c17cABvguRnLGisBTmlElY++kufn2v4m\n+JdCaslFkG4PJwvVD/G9Sa8DYMLIeZZuUCkzGQH9AmulaJtqmaXtOHe0fDa53QL4\nbpjfu/GQu2xkxYxE9XNaXRyOOsU1OWUri8wHeqfi4diJhpgEQ1Uk4eugTWpanJc=\n=kdQM\n-----END PGP SIGNATURE-----\n", "payload": "tree 672f5ebda7447c06ff28556515e41b13cef261e1\nparent 98f7842e408587fdaca3d15d8eda677b689a035a\nparent dd5e4d4870b4e59bc82d285c481bb6971d016912\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585816443 +0000\ncommitter GitHub <noreply@github.com> 1585816443 +0000\n\nMerge #3816\n\n3816: vscode: add goto ast node definition from rust source code r=Veetaha a=Veetaha\n\nBy holding the `Ctrl` key you can now goto-definition of the appropriate syntax token in the syntax tree read-only editor. But actually going to the definition is not very convenient, since it opens the new editor, you'd rather just hold the `Ctrl` and look at the syntax tree because it is automatically scrolled to the proper node and the node itself is enclosed with text selection.\r\n\r\nUnfortunately, the algorithm is very simple (because we don't do any elaborate parsing of the syntax tree text received from the server), but it is enough to debug not very large source files.\r\nI tested the performance and in a bad case (rust source file with 5K lines of code) it takes `1.3` seconds to build the `rust -> ast` mapping index (lazily once on the first goto definition request) and each lookup in this worst-case is approx `20-120` ms. I think this is good enough. In the simple case where the file is < 100 lines of code, it is instant.\r\n\r\nOne peculiarity that I've noticed is that vscode doesn't trigger the goto-definition provider when the user triggers it on some punctuation characters (i.e. it doesn't underline them and invoke te goto-definition provider), but if you explicitly click `Ctrl+LMB` it will only then invoke the provider and navigate to the definition in a new editor. I think this is fine ;D\r\n\r\n![rust2ast](https://user-images.githubusercontent.com/36276403/78198718-24d1d500-7492-11ea-91f6-2687cedf26ee.gif)\r\n\r\n\r\nRelated: #3682 \n\nCo-authored-by: veetaha <veetaha2@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "html_url": "https://github.com/rust-lang/rust/commit/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98f7842e408587fdaca3d15d8eda677b689a035a", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f7842e408587fdaca3d15d8eda677b689a035a", "html_url": "https://github.com/rust-lang/rust/commit/98f7842e408587fdaca3d15d8eda677b689a035a"}, {"sha": "dd5e4d4870b4e59bc82d285c481bb6971d016912", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd5e4d4870b4e59bc82d285c481bb6971d016912", "html_url": "https://github.com/rust-lang/rust/commit/dd5e4d4870b4e59bc82d285c481bb6971d016912"}], "stats": {"total": 116, "additions": 96, "deletions": 20}, "files": [{"sha": "f230dc1db1a4fdd8abe7ee7cf8587c747c8c05c4", "filename": "docs/dev/README.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "patch": "@@ -155,6 +155,16 @@ There's also two VS Code commands which might be of interest:\n \n * `Rust Analyzer: Syntax Tree` shows syntax tree of the current file/selection.\n \n+  You can hover over syntax nodes in the opened text file to see the appropriate\n+  rust code that it refers to and the rust editor will also highlight the proper\n+  text range.\n+\n+  If you press <kbd>Ctrl</kbd> (i.e. trigger goto definition) in the inspected\n+  Rust source file the syntax tree read-only editor should scroll to and select the\n+  appropriate syntax node token.\n+\n+  ![demo](https://user-images.githubusercontent.com/36276403/78225773-6636a480-74d3-11ea-9d9f-1c9d42da03b0.png)\n+\n # Profiling\n \n We have a built-in hierarchical profiler, you can enable it by using `RA_PROFILE` env-var:"}, {"sha": "56d2969fd43e480d5a62af28c7c10a3fc8b1609a", "filename": "docs/user/features.md", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "patch": "@@ -81,12 +81,6 @@ Join selected lines into one, smartly fixing up whitespace and trailing commas.\n Shows the parse tree of the current file. It exists mostly for debugging\n rust-analyzer itself.\n \n-You can hover over syntax nodes in the opened text file to see the appropriate\n-rust code that it refers to and the rust editor will also highlight the proper\n-text range.\n-\n-<img src=\"https://user-images.githubusercontent.com/36276403/78043783-7425e180-737c-11ea-8653-b02b773c5aa1.png\" alt=\"demo\" height=\"200px\" >\n-\n #### Expand Macro Recursively\n \n Shows the full macro expansion of the macro at current cursor."}, {"sha": "b7a397414ebdcacd84a2d85bfd30ad058a93d486", "filename": "editors/code/src/commands/syntax_tree.ts", "status": "modified", "additions": 86, "deletions": 14, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts", "raw_url": "https://github.com/rust-lang/rust/raw/9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts?ref=9ee96dcf4a2b47a6df0e3ea379d36aec2e6e1784", "patch": "@@ -82,18 +82,41 @@ class TextDocumentContentProvider implements vscode.TextDocumentContentProvider\n \n // FIXME: consider implementing this via the Tree View API?\n // https://code.visualstudio.com/api/extension-guides/tree-view\n-class AstInspector implements vscode.HoverProvider, Disposable {\n-    private static readonly astDecorationType = vscode.window.createTextEditorDecorationType({\n+class AstInspector implements vscode.HoverProvider, vscode.DefinitionProvider, Disposable {\n+    private readonly astDecorationType = vscode.window.createTextEditorDecorationType({\n         borderColor: new vscode.ThemeColor('rust_analyzer.syntaxTreeBorder'),\n         borderStyle: \"solid\",\n         borderWidth: \"2px\",\n \n     });\n     private rustEditor: undefined | RustEditor;\n \n+    // Lazy rust token range -> syntax tree file range.\n+    private readonly rust2Ast = new Lazy(() => {\n+        const astEditor = this.findAstTextEditor();\n+        if (!this.rustEditor || !astEditor) return undefined;\n+\n+        const buf: [vscode.Range, vscode.Range][] = [];\n+        for (let i = 0; i < astEditor.document.lineCount; ++i) {\n+            const astLine = astEditor.document.lineAt(i);\n+\n+            // Heuristically look for nodes with quoted text (which are token nodes)\n+            const isTokenNode = astLine.text.lastIndexOf('\"') >= 0;\n+            if (!isTokenNode) continue;\n+\n+            const rustRange = this.parseRustTextRange(this.rustEditor.document, astLine.text);\n+            if (!rustRange) continue;\n+\n+            buf.push([rustRange, this.findAstNodeRange(astLine)]);\n+        }\n+        return buf;\n+    });\n+\n     constructor(ctx: Ctx) {\n         ctx.pushCleanup(vscode.languages.registerHoverProvider({ scheme: AST_FILE_SCHEME }, this));\n+        ctx.pushCleanup(vscode.languages.registerDefinitionProvider({ language: \"rust\" }, this));\n         vscode.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, ctx.subscriptions);\n+        vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, ctx.subscriptions);\n         vscode.window.onDidChangeVisibleTextEditors(this.onDidChangeVisibleTextEditors, this, ctx.subscriptions);\n \n         ctx.pushCleanup(this);\n@@ -102,45 +125,80 @@ class AstInspector implements vscode.HoverProvider, Disposable {\n         this.setRustEditor(undefined);\n     }\n \n+    private onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent) {\n+        if (this.rustEditor && event.document.uri.toString() === this.rustEditor.document.uri.toString()) {\n+            this.rust2Ast.reset();\n+        }\n+    }\n+\n     private onDidCloseTextDocument(doc: vscode.TextDocument) {\n         if (this.rustEditor && doc.uri.toString() === this.rustEditor.document.uri.toString()) {\n             this.setRustEditor(undefined);\n         }\n     }\n \n     private onDidChangeVisibleTextEditors(editors: vscode.TextEditor[]) {\n-        if (editors.every(suspect => suspect.document.uri.scheme !== AST_FILE_SCHEME)) {\n+        if (!this.findAstTextEditor()) {\n             this.setRustEditor(undefined);\n             return;\n         }\n         this.setRustEditor(editors.find(isRustEditor));\n     }\n \n+    private findAstTextEditor(): undefined | vscode.TextEditor {\n+        return vscode.window.visibleTextEditors.find(it => it.document.uri.scheme === AST_FILE_SCHEME);\n+    }\n+\n     private setRustEditor(newRustEditor: undefined | RustEditor) {\n-        if (newRustEditor !== this.rustEditor) {\n-            this.rustEditor?.setDecorations(AstInspector.astDecorationType, []);\n+        if (this.rustEditor && this.rustEditor !== newRustEditor) {\n+            this.rustEditor.setDecorations(this.astDecorationType, []);\n+            this.rust2Ast.reset();\n         }\n         this.rustEditor = newRustEditor;\n     }\n \n+    // additional positional params are omitted\n+    provideDefinition(doc: vscode.TextDocument, pos: vscode.Position): vscode.ProviderResult<vscode.DefinitionLink[]> {\n+        if (!this.rustEditor || doc.uri.toString() !== this.rustEditor.document.uri.toString()) return;\n+\n+        const astEditor = this.findAstTextEditor();\n+        if (!astEditor) return;\n+\n+        const rust2AstRanges = this.rust2Ast.get()?.find(([rustRange, _]) => rustRange.contains(pos));\n+        if (!rust2AstRanges) return;\n+\n+        const [rustFileRange, astFileRange] = rust2AstRanges;\n+\n+        astEditor.revealRange(astFileRange);\n+        astEditor.selection = new vscode.Selection(astFileRange.start, astFileRange.end);\n+\n+        return [{\n+            targetRange: astFileRange,\n+            targetUri: astEditor.document.uri,\n+            originSelectionRange: rustFileRange,\n+            targetSelectionRange: astFileRange,\n+        }];\n+    }\n+\n+    // additional positional params are omitted\n     provideHover(doc: vscode.TextDocument, hoverPosition: vscode.Position): vscode.ProviderResult<vscode.Hover> {\n         if (!this.rustEditor) return;\n \n-        const astTextLine = doc.lineAt(hoverPosition.line);\n+        const astFileLine = doc.lineAt(hoverPosition.line);\n \n-        const rustTextRange = this.parseRustTextRange(this.rustEditor.document, astTextLine.text);\n-        if (!rustTextRange) return;\n+        const rustFileRange = this.parseRustTextRange(this.rustEditor.document, astFileLine.text);\n+        if (!rustFileRange) return;\n \n-        this.rustEditor.setDecorations(AstInspector.astDecorationType, [rustTextRange]);\n-        this.rustEditor.revealRange(rustTextRange);\n+        this.rustEditor.setDecorations(this.astDecorationType, [rustFileRange]);\n+        this.rustEditor.revealRange(rustFileRange);\n \n-        const rustSourceCode = this.rustEditor.document.getText(rustTextRange);\n-        const astTextRange = this.findAstRange(astTextLine);\n+        const rustSourceCode = this.rustEditor.document.getText(rustFileRange);\n+        const astFileRange = this.findAstNodeRange(astFileLine);\n \n-        return new vscode.Hover([\"```rust\\n\" + rustSourceCode + \"\\n```\"], astTextRange);\n+        return new vscode.Hover([\"```rust\\n\" + rustSourceCode + \"\\n```\"], astFileRange);\n     }\n \n-    private findAstRange(astLine: vscode.TextLine) {\n+    private findAstNodeRange(astLine: vscode.TextLine) {\n         const lineOffset = astLine.range.start;\n         const begin = lineOffset.translate(undefined, astLine.firstNonWhitespaceCharacterIndex);\n         const end = lineOffset.translate(undefined, astLine.text.trimEnd().length);\n@@ -156,3 +214,17 @@ class AstInspector implements vscode.HoverProvider, Disposable {\n         return new vscode.Range(begin, end);\n     }\n }\n+\n+class Lazy<T> {\n+    val: undefined | T;\n+\n+    constructor(private readonly compute: () => undefined | T) { }\n+\n+    get() {\n+        return this.val ?? (this.val = this.compute());\n+    }\n+\n+    reset() {\n+        this.val = undefined;\n+    }\n+}"}]}