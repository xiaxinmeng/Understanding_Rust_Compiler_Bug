{"sha": "963e9698f9ab959de06f42047ef1979bde0aac84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2M2U5Njk4ZjlhYjk1OWRlMDZmNDIwNDdlZjE5NzliZGUwYWFjODQ=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-15T00:21:52Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Generate fresh allocation ids for thread locals in eval_maybe_thread_local_static_const.", "tree": {"sha": "269abe5fd1d5a5d11839ea3898a9f334b154623b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/269abe5fd1d5a5d11839ea3898a9f334b154623b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/963e9698f9ab959de06f42047ef1979bde0aac84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/963e9698f9ab959de06f42047ef1979bde0aac84", "html_url": "https://github.com/rust-lang/rust/commit/963e9698f9ab959de06f42047ef1979bde0aac84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/963e9698f9ab959de06f42047ef1979bde0aac84/comments", "author": null, "committer": null, "parents": [{"sha": "0c4303cd7f903d2c05e70c05800dddefd7ccb7c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c4303cd7f903d2c05e70c05800dddefd7ccb7c6", "html_url": "https://github.com/rust-lang/rust/commit/0c4303cd7f903d2c05e70c05800dddefd7ccb7c6"}], "stats": {"total": 118, "additions": 53, "deletions": 65}, "files": [{"sha": "b7c96dd7e98aac4f2b49aca09b954b63bc336018", "filename": "src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/963e9698f9ab959de06f42047ef1979bde0aac84/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963e9698f9ab959de06f42047ef1979bde0aac84/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=963e9698f9ab959de06f42047ef1979bde0aac84", "patch": "@@ -139,7 +139,7 @@ fn report_msg<'tcx, 'mir>(\n     mut helps: Vec<String>,\n     error: bool,\n ) {\n-    let span = if let Some(frame) = ecx.machine.stack.last() {\n+    let span = if let Some(frame) = ecx.active_thread_stack().last() {\n         frame.current_source_info().unwrap().span\n     } else {\n         DUMMY_SP\n@@ -171,7 +171,7 @@ fn report_msg<'tcx, 'mir>(\n \n     err.emit();\n \n-    for (i, frame) in ecx.machine.stack.iter().enumerate() {\n+    for (i, frame) in ecx.active_thread_stack().iter().enumerate() {\n         trace!(\"-------------------\");\n         trace!(\"Frame {}\", i);\n         trace!(\"    return: {:?}\", frame.return_place.map(|p| *p));"}, {"sha": "a9582f595ff63c16dbe84494687101d06fa7865d", "filename": "src/machine.rs", "status": "modified", "additions": 50, "deletions": 62, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/963e9698f9ab959de06f42047ef1979bde0aac84/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963e9698f9ab959de06f42047ef1979bde0aac84/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=963e9698f9ab959de06f42047ef1979bde0aac84", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::{\n         TyCtxt,\n     },\n };\n-use rustc_span::{def_id::DefId, symbol::{sym, Symbol}};\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{LayoutOf, Size};\n \n use crate::*;\n@@ -331,19 +331,6 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         memory_extra.check_alignment\n     }\n \n-    #[inline(always)]\n-    fn stack<'a>(\n-        ecx: &'a InterpCx<'mir, 'tcx, Self>\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n-        ecx.active_thread_stack()\n-    }\n-\n-    fn stack_mut<'a>(\n-        ecx: &'a mut InterpCx<'mir, 'tcx, Self>\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n-        ecx.active_thread_stack_mut()\n-    }\n-\n     #[inline(always)]\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         ecx.machine.validate\n@@ -434,63 +421,52 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn access_local(\n+    fn eval_maybe_thread_local_static_const(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n-        frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n-        local: mir::Local,\n-    ) -> InterpResult<'tcx, Operand<Self::PointerTag>> {\n-        match frame.body.local_decls[local].local_info {\n-            mir::LocalInfo::StaticRef { def_id, is_thread_local: true } => {\n-                let static_alloc_id = ecx.tcx.alloc_map.lock().create_static_alloc(def_id);\n-                let alloc_id = ecx.memory.extra.tls.get_or_register_allocation(*ecx.memory.tcx, static_alloc_id);\n-                let tag = Self::tag_global_base_pointer(&ecx.memory.extra, alloc_id);\n-                let pointer: Pointer = alloc_id.into();\n-                let pointer = pointer.with_tag(tag);\n-                let scalar: Scalar<_> = pointer.into();\n-                let scalar: ScalarMaybeUndef<_> = scalar.into();\n-                let immediate: Immediate<_> = scalar.into();\n-                Ok(\n-                    Operand::Immediate(immediate)\n-                )\n-            },\n-            _ => frame.locals[local].access(),\n+        mut val: mir::interpret::ConstValue<'tcx>\n+    )-> InterpResult<'tcx, mir::interpret::ConstValue<'tcx>> {\n+        match &mut val {\n+            mir::interpret::ConstValue::Scalar(Scalar::Ptr(ptr)) => {\n+                let alloc_id = ptr.alloc_id;\n+                let alloc = ecx.tcx.alloc_map.lock().get(alloc_id);\n+                match alloc {\n+                    Some(GlobalAlloc::Static(def_id))\n+                        if ecx.tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) => {\n+                        // We have a thread-local static.\n+                        let new_alloc_id = ecx.memory.extra.tls.get_or_register_allocation(\n+                            *ecx.memory.tcx, alloc_id);\n+                        ptr.alloc_id = new_alloc_id;\n+                    },\n+                    _ => {},\n+                }\n+            }\n+            _ => {},\n         }\n+        Ok(val)\n     }\n \n     fn canonical_alloc_id(mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n         let tcx = mem.tcx;\n-        let alloc = tcx.alloc_map.lock().get(id);\n-        fn is_thread_local<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-            tcx.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n-        }\n-        match alloc {\n-            Some(GlobalAlloc::Static(def_id)) if tcx.is_foreign_item(def_id) => {\n-                if is_thread_local(*tcx, def_id) {\n-                    unimplemented!(\"Foreign thread local statics are not supported yet.\");\n-                }\n-                // Figure out if this is an extern static, and if yes, which one.\n-                let attrs = tcx.get_attrs(def_id);\n-                let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n-                    Some(name) => name,\n-                    None => tcx.item_name(def_id),\n-                };\n-                // Check if we know this one.\n-                if let Some(canonical_id) = mem.extra.extern_statics.get(&link_name) {\n-                    trace!(\"canonical_alloc_id: {:?} ({}) -> {:?}\", id, link_name, canonical_id);\n-                    *canonical_id\n-                } else {\n-                    // Return original id; `Memory::get_static_alloc` will throw an error.\n-                    id\n-                }\n-            },\n-            Some(GlobalAlloc::Static(def_id)) if is_thread_local(*tcx, def_id) => {\n-                // We have a thread local, so we need to get a unique allocation id for it.\n-                mem.extra.tls.get_or_register_allocation(*tcx, id)\n-            },\n+        // Figure out if this is an extern static, and if yes, which one.\n+        let def_id = match tcx.alloc_map.lock().get(id) {\n+            Some(GlobalAlloc::Static(def_id)) if tcx.is_foreign_item(def_id) => def_id,\n             _ => {\n                 // No need to canonicalize anything.\n-                id\n+                return id;\n             }\n+        };\n+        let attrs = tcx.get_attrs(def_id);\n+        let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n+            Some(name) => name,\n+            None => tcx.item_name(def_id),\n+        };\n+        // Check if we know this one.\n+        if let Some(canonical_id) = mem.extra.extern_statics.get(&link_name) {\n+            trace!(\"canonical_alloc_id: {:?} ({}) -> {:?}\", id, link_name, canonical_id);\n+            *canonical_id\n+        } else {\n+            // Return original id; `Memory::get_static_alloc` will throw an error.\n+            id\n         }\n     }\n \n@@ -587,6 +563,18 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(frame.with_extra(extra))\n     }\n \n+    fn stack<'a>(\n+        ecx: &'a InterpCx<'mir, 'tcx, Self>\n+    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+        ecx.active_thread_stack()\n+    }\n+\n+    fn stack_mut<'a>(\n+        ecx: &'a mut InterpCx<'mir, 'tcx, Self>\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+        ecx.active_thread_stack_mut()\n+    }\n+\n     #[inline(always)]\n     fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,"}, {"sha": "5cef3871c033fe514601976ddfd0f02b4df3f6df", "filename": "src/shims/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/963e9698f9ab959de06f42047ef1979bde0aac84/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963e9698f9ab959de06f42047ef1979bde0aac84/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=963e9698f9ab959de06f42047ef1979bde0aac84", "patch": "@@ -161,7 +161,7 @@ impl<'tcx> TlsData<'tcx> {\n                 Entry::Occupied(entry) => {\n                     let (thread_id, data_scalar) = entry.remove_entry();\n                     if let Some(dtor) = dtor {\n-                        let ret = Some((dtor, thread_id, data_scalar, key));\n+                        let ret = Some((*dtor, thread_id, data_scalar, key));\n                         return ret;\n                     }\n                 }"}]}