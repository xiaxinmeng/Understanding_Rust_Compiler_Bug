{"sha": "ac6cab088791c497726ccdec24f6f97e709d5a62", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNmNhYjA4ODc5MWM0OTc3MjZjY2RlYzI0ZjZmOTdlNzA5ZDVhNjI=", "commit": {"author": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2015-02-19T03:25:37Z"}, "committer": {"name": "Keegan McAllister", "email": "mcallister.keegan@gmail.com", "date": "2015-02-19T03:54:45Z"}, "message": "borrowck/README.md: Fix display of code on GitHub", "tree": {"sha": "873f2bc90ebcf41d3c81c0781ae03b8711c95bc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/873f2bc90ebcf41d3c81c0781ae03b8711c95bc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac6cab088791c497726ccdec24f6f97e709d5a62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac6cab088791c497726ccdec24f6f97e709d5a62", "html_url": "https://github.com/rust-lang/rust/commit/ac6cab088791c497726ccdec24f6f97e709d5a62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac6cab088791c497726ccdec24f6f97e709d5a62/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "160cf962e7efaca024202421e58a5c83f0d1cbe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/160cf962e7efaca024202421e58a5c83f0d1cbe8", "html_url": "https://github.com/rust-lang/rust/commit/160cf962e7efaca024202421e58a5c83f0d1cbe8"}], "stats": {"total": 36, "additions": 18, "deletions": 18}, "files": [{"sha": "42694a9c8d0a1a1260115be9707f8e067718a299", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ac6cab088791c497726ccdec24f6f97e709d5a62/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ac6cab088791c497726ccdec24f6f97e709d5a62/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=ac6cab088791c497726ccdec24f6f97e709d5a62", "patch": "@@ -53,7 +53,7 @@ Here `x` represents some variable, `LV.f` is a field reference,\n and `*LV` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n-```text\n+```rust\n struct S { f: uint }\n ```\n \n@@ -82,13 +82,13 @@ SD = struct S<'LT...> { (f: TY)... }\n \n Now, imagine we had a program like this:\n \n-```text\n+```rust\n struct Foo { f: uint, g: uint }\n ...\n 'a: {\n-  let mut x: Box<Foo> = ...;\n-  let y = &mut (*x).f;\n-  x = ...;\n+    let mut x: Box<Foo> = ...;\n+    let y = &mut (*x).f;\n+    x = ...;\n }\n ```\n \n@@ -507,7 +507,7 @@ specify that the lifetime of the loan must be less than the lifetime\n of the `&Ty` pointer. In simple cases, this clause is redundant, since\n the `LIFETIME()` function will already enforce the required rule:\n \n-```\n+```rust\n fn foo(point: &'a Point) -> &'static f32 {\n     &point.x // Error\n }\n@@ -517,7 +517,7 @@ The above example fails to compile both because of clause (1) above\n but also by the basic `LIFETIME()` check. However, in more advanced\n examples involving multiple nested pointers, clause (1) is needed:\n \n-```\n+```rust\n fn foo(point: &'a &'b mut Point) -> &'b f32 {\n     &point.x // Error\n }\n@@ -536,7 +536,7 @@ which is only `'a`, not `'b`. Hence this example yields an error.\n As a final twist, consider the case of two nested *immutable*\n pointers, rather than a mutable pointer within an immutable one:\n \n-```\n+```rust\n fn foo(point: &'a &'b Point) -> &'b f32 {\n     &point.x // OK\n }\n@@ -558,7 +558,7 @@ The rules pertaining to `LIFETIME` exist to ensure that we don't\n create a borrowed pointer that outlives the memory it points at. So\n `LIFETIME` prevents a function like this:\n \n-```\n+```rust\n fn get_1<'a>() -> &'a int {\n     let x = 1;\n     &x\n@@ -578,7 +578,7 @@ after we return and hence the remaining code in `'a` cannot possibly\n mutate it. This distinction is important for type checking functions\n like this one:\n \n-```\n+```rust\n fn inc_and_get<'a>(p: &'a mut Point) -> &'a int {\n     p.x += 1;\n     &p.x\n@@ -631,7 +631,7 @@ maximum of `LT'`.\n \n Here is a concrete example of a bug this rule prevents:\n \n-```\n+```rust\n // Test region-reborrow-from-shorter-mut-ref.rs:\n fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n     &mut **p // ERROR due to clause (1)\n@@ -659,7 +659,7 @@ ways to violate the rules is to move the base pointer to a new name\n and access it via that new name, thus bypassing the restrictions on\n the old name. Here is an example:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n fn foo(t0: &mut int) {\n     let p: &int = &*t0; // Freezes `*t0`\n@@ -679,7 +679,7 @@ danger is to mutably borrow the base path. This can lead to two bad\n scenarios. The most obvious is that the mutable borrow itself becomes\n another path to access the same data, as shown here:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-mut-borrow-of-mut-base-ptr.rs\n fn foo<'a>(mut t0: &'a mut int,\n            mut t1: &'a mut int) {\n@@ -700,7 +700,7 @@ of `t0`. Hence the claim `&mut t0` is illegal.\n Another danger with an `&mut` pointer is that we could swap the `t0`\n value away to create a new path:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n fn foo<'a>(mut t0: &'a mut int,\n            mut t1: &'a mut int) {\n@@ -718,7 +718,7 @@ careful to ensure this example is still illegal.\n referent is claimed, even freezing the base pointer can be dangerous,\n as shown in the following example:\n \n-```\n+```rust\n // src/test/compile-fail/borrowck-borrow-of-mut-base-ptr.rs\n fn foo<'a>(mut t0: &'a mut int,\n            mut t1: &'a mut int) {\n@@ -741,7 +741,7 @@ which is clearly unsound.\n However, it is not always unsafe to freeze the base pointer. In\n particular, if the referent is frozen, there is no harm in it:\n \n-```\n+```rust\n // src/test/run-pass/borrowck-borrow-of-mut-base-ptr-safe.rs\n fn foo<'a>(mut t0: &'a mut int,\n            mut t1: &'a mut int) {\n@@ -757,7 +757,7 @@ thing `t2` can be used for is to further freeze `*t0`, which is\n already frozen. In particular, we cannot assign to `*t0` through the\n new alias `t2`, as demonstrated in this test case:\n \n-```\n+```rust\n // src/test/run-pass/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs\n fn foo(t0: & &mut int) {\n     let t1 = t0;\n@@ -830,7 +830,7 @@ moves/uninitializations of the variable that is being used.\n \n Let's look at a simple example:\n \n-```\n+```rust\n fn foo(a: Box<int>) {\n     let b: Box<int>;   // Gen bit 0.\n "}]}