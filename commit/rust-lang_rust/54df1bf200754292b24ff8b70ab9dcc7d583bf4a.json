{"sha": "54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZGYxYmYyMDA3NTQyOTJiMjRmZjhiNzBhYjlkY2M3ZDU4M2JmNGE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-05-17T19:51:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-05-17T19:51:27Z"}, "message": "Rollup merge of #50818 - nnethercote:faster-normalize, r=nikomatsakis\n\nSpeed up `opt_normalize_projection_type`\n\n`opt_normalize_projection_type` is hot in the serde and futures benchmarks in rustc-perf. These two patches speed up the execution of most runs for them by 2--4%.", "tree": {"sha": "57ee502e8d6eaded1a5d777bff73e5b8df3cade8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57ee502e8d6eaded1a5d777bff73e5b8df3cade8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJa/d0/CRBK7hj4Ov3rIwAAdHIIAGfh1dbKa/cs8RAi6vqBWFvt\n/CVteEUA1mW7SjAvHs0czoZXVRqfU/8IHiOpYgyDgyjONqxxEg+nsnU9cPGHHq14\nCmlKrmD+2FX3GlzhTtH+1vmci81TCjMMKzJG+oWgBSEtZzSl3g4VqNrjlqbEh7sN\nkFrE32qdWfDr/DtItm7y61/I2Ip6FS2wR6NKltD1TEbG7uecMacG7dUoq/4VuGEs\n72ZxF1Pc1WHZ0tb3bq60aeHh1Z7pfRIRv7sevakS2SwV9E4+alTf7bDrAkU9hjpE\nhnXBahEMsKKHCf0Wp2KYSH83a+/zbWk4QrGhmgqnyqQXmgnC5zofvgGD/jB3KGA=\n=S1b9\n-----END PGP SIGNATURE-----\n", "payload": "tree 57ee502e8d6eaded1a5d777bff73e5b8df3cade8\nparent f83e4d74076c4ac82cde6abe6abe54a946e7feb8\nparent 47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798\nauthor Mark Simulacrum <mark.simulacrum@gmail.com> 1526586687 -0600\ncommitter GitHub <noreply@github.com> 1526586687 -0600\n\nRollup merge of #50818 - nnethercote:faster-normalize, r=nikomatsakis\n\nSpeed up `opt_normalize_projection_type`\n\n`opt_normalize_projection_type` is hot in the serde and futures benchmarks in rustc-perf. These two patches speed up the execution of most runs for them by 2--4%.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "html_url": "https://github.com/rust-lang/rust/commit/54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83e4d74076c4ac82cde6abe6abe54a946e7feb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83e4d74076c4ac82cde6abe6abe54a946e7feb8", "html_url": "https://github.com/rust-lang/rust/commit/f83e4d74076c4ac82cde6abe6abe54a946e7feb8"}, {"sha": "47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "url": "https://api.github.com/repos/rust-lang/rust/commits/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798", "html_url": "https://github.com/rust-lang/rust/commit/47bc774ab6b23f0e01bf4672d36ed9f8d7e3e798"}], "stats": {"total": 224, "additions": 132, "deletions": 92}, "files": [{"sha": "97ce730c59ec508f76e16a0c824529207e2270d0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "patch": "@@ -203,17 +203,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n                     data);\n-                let normalized = super::normalize_projection_type(\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n                     &mut selcx,\n                     obligation.param_env,\n                     data.projection_ty,\n                     obligation.cause.clone(),\n-                    0\n+                    0,\n+                    &mut obligations\n                 );\n                 if let Err(error) = self.at(&obligation.cause, obligation.param_env)\n-                                        .eq(normalized.value, data.ty) {\n+                                        .eq(normalized_ty, data.ty) {\n                     values = Some(infer::ValuePairs::Types(ExpectedFound {\n-                        expected: normalized.value,\n+                        expected: normalized_ty,\n                         found: data.ty,\n                     }));\n                     err_buf = error;"}, {"sha": "4447a2b6ed14081086f05b13cf1adfea05674f08", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "patch": "@@ -161,19 +161,18 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         // FIXME(#20304) -- cache\n \n         let mut selcx = SelectionContext::new(infcx);\n-        let normalized = project::normalize_projection_type(&mut selcx,\n-                                                            param_env,\n-                                                            projection_ty,\n-                                                            cause,\n-                                                            0);\n-\n-        for obligation in normalized.obligations {\n-            self.register_predicate_obligation(infcx, obligation);\n-        }\n-\n-        debug!(\"normalize_projection_type: result={:?}\", normalized.value);\n-\n-        normalized.value\n+        let mut obligations = vec![];\n+        let normalized_ty = project::normalize_projection_type(&mut selcx,\n+                                                               param_env,\n+                                                               projection_ty,\n+                                                               cause,\n+                                                               0,\n+                                                               &mut obligations);\n+        self.register_predicate_obligations(infcx, obligations);\n+\n+        debug!(\"normalize_projection_type: result={:?}\", normalized_ty);\n+\n+        normalized_ty\n     }\n \n     /// Requires that `ty` must implement the trait with `def_id` in"}, {"sha": "174c35d1d69bfc5bc25b4ec5e9db82c90fd3c9d6", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 90, "deletions": 55, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "patch": "@@ -225,12 +225,14 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n \n-    let Normalized { value: normalized_ty, mut obligations } =\n+    let mut obligations = vec![];\n+    let normalized_ty =\n         match opt_normalize_projection_type(selcx,\n                                             obligation.param_env,\n                                             obligation.predicate.projection_ty,\n                                             obligation.cause.clone(),\n-                                            obligation.recursion_depth) {\n+                                            obligation.recursion_depth,\n+                                            &mut obligations) {\n             Some(n) => n,\n             None => return Ok(None),\n         };\n@@ -386,16 +388,15 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                 // binder). It would be better to normalize in a\n                 // binding-aware fashion.\n \n-                let Normalized { value: normalized_ty, obligations } =\n-                    normalize_projection_type(self.selcx,\n-                                              self.param_env,\n-                                              data.clone(),\n-                                              self.cause.clone(),\n-                                              self.depth);\n-                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?} \\\n-                        with {} add'l obligations\",\n-                       self.depth, ty, normalized_ty, obligations.len());\n-                self.obligations.extend(obligations);\n+                let normalized_ty = normalize_projection_type(self.selcx,\n+                                                              self.param_env,\n+                                                              data.clone(),\n+                                                              self.cause.clone(),\n+                                                              self.depth,\n+                                                              &mut self.obligations);\n+                debug!(\"AssociatedTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n+                        now with {} obligations\",\n+                       self.depth, ty, normalized_ty, self.obligations.len());\n                 normalized_ty\n             }\n \n@@ -471,10 +472,12 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> NormalizedTy<'tcx>\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Ty<'tcx>\n {\n-    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth)\n+    opt_normalize_projection_type(selcx, param_env, projection_ty.clone(), cause.clone(), depth,\n+                                  obligations)\n         .unwrap_or_else(move || {\n             // if we bottom out in ambiguity, create a type variable\n             // and a deferred predicate to resolve this when more type\n@@ -490,24 +493,29 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             });\n             let obligation = Obligation::with_depth(\n                 cause, depth + 1, param_env, projection.to_predicate());\n-            Normalized {\n-                value: ty_var,\n-                obligations: vec![obligation]\n-            }\n+            obligations.push(obligation);\n+            ty_var\n         })\n }\n \n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). Returns `None` in the case of ambiguity,\n /// which indicates that there are unbound type variables.\n+///\n+/// This function used to return `Option<NormalizedTy<'tcx>>`, which contains a\n+/// `Ty<'tcx>` and an obligations vector. But that obligation vector was very\n+/// often immediately appended to another obligations vector. So now this\n+/// function takes an obligations vector and appends to it directly, which is\n+/// slightly uglier but avoids the need for an extra short-lived allocation.\n fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     projection_ty: ty::ProjectionTy<'tcx>,\n     cause: ObligationCause<'tcx>,\n-    depth: usize)\n-    -> Option<NormalizedTy<'tcx>>\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    -> Option<Ty<'tcx>>\n {\n     let infcx = selcx.infcx();\n \n@@ -579,7 +587,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                                                     projection_ty);\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n-        Err(ProjectionCacheEntry::NormalizedTy(mut ty)) => {\n+        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+            // This is the hottest path in this function.\n+            //\n             // If we find the value in the cache, then return it along\n             // with the obligations that went along with it. Note\n             // that, when using a fulfillment context, these\n@@ -596,29 +606,32 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if !infcx.any_unresolved_type_vars(&ty.value) {\n-                infcx.projection_cache.borrow_mut().complete(cache_key);\n-                ty.obligations = vec![];\n+                infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n+                // No need to extend `obligations`.\n+            } else {\n+                obligations.extend(ty.obligations);\n             }\n \n-            push_paranoid_cache_value_obligation(infcx,\n-                                                 param_env,\n-                                                 projection_ty,\n-                                                 cause,\n-                                                 depth,\n-                                                 &mut ty);\n-\n-            return Some(ty);\n+            obligations.push(get_paranoid_cache_value_obligation(infcx,\n+                                                                 param_env,\n+                                                                 projection_ty,\n+                                                                 cause,\n+                                                                 depth));\n+            return Some(ty.value);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n                     found error\");\n-            return Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth));\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            return Some(result.value)\n         }\n     }\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress { ty: projected_ty, mut obligations })) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n+                                            obligations: mut projected_obligations })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n@@ -627,10 +640,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     projected_ty={:?} \\\n                     depth={} \\\n-                    obligations={:?}\",\n+                    projected_obligations={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations);\n+                   projected_obligations);\n \n             let result = if projected_ty.has_projections() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n@@ -644,22 +657,22 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                        normalized_ty,\n                        depth);\n \n-                obligations.extend(normalizer.obligations);\n+                projected_obligations.extend(normalizer.obligations);\n                 Normalized {\n                     value: normalized_ty,\n-                    obligations,\n+                    obligations: projected_obligations,\n                 }\n             } else {\n                 Normalized {\n                     value: projected_ty,\n-                    obligations,\n+                    obligations: projected_obligations,\n                 }\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n             infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n-\n-            Some(result)\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -670,7 +683,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 obligations: vec![]\n             };\n             infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n-            Some(result)\n+            // No need to extend `obligations`.\n+            Some(result.value)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -688,7 +702,9 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n             infcx.projection_cache.borrow_mut()\n                                   .error(cache_key);\n-            Some(normalize_to_error(selcx, param_env, projection_ty, cause, depth))\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n         }\n     }\n }\n@@ -737,7 +753,7 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// may or may not be necessary -- in principle, all the obligations\n /// that must be proven to show that `T: Trait` were also returned\n /// when the cache was first populated. But there are some vague concerns,\n-/// and so we take the precatuionary measure of including `T: Trait` in\n+/// and so we take the precautionary measure of including `T: Trait` in\n /// the result:\n ///\n /// Concern #1. The current setup is fragile. Perhaps someone could\n@@ -754,19 +770,21 @@ fn prune_cache_value_obligations<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx,\n /// that may yet turn out to be wrong.  This *may* lead to some sort\n /// of trouble, though we don't have a concrete example of how that\n /// can occur yet.  But it seems risky at best.\n-fn push_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                                                        param_env: ty::ParamEnv<'tcx>,\n-                                                        projection_ty: ty::ProjectionTy<'tcx>,\n-                                                        cause: ObligationCause<'tcx>,\n-                                                        depth: usize,\n-                                                        result: &mut NormalizedTy<'tcx>)\n+fn get_paranoid_cache_value_obligation<'a, 'gcx, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize)\n+    -> PredicateObligation<'tcx>\n {\n     let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    let trait_obligation = Obligation { cause,\n-                                        recursion_depth: depth,\n-                                        param_env,\n-                                        predicate: trait_ref.to_predicate() };\n-    result.obligations.push(trait_obligation);\n+    Obligation {\n+        cause,\n+        recursion_depth: depth,\n+        param_env,\n+        predicate: trait_ref.to_predicate(),\n+    }\n }\n \n /// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n@@ -1682,6 +1700,23 @@ impl<'tcx> ProjectionCache<'tcx> {\n         }));\n     }\n \n+    /// A specialized version of `complete` for when the key's value is known\n+    /// to be a NormalizedTy.\n+    pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n+        // We want to insert `ty` with no obligations. If the existing value\n+        // already has no obligations (as is common) we can use `insert_noop`\n+        // to do a minimal amount of work -- the HashMap insertion is skipped,\n+        // and minimal changes are made to the undo log.\n+        if ty.obligations.is_empty() {\n+            self.map.insert_noop();\n+        } else {\n+            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(Normalized {\n+                value: ty.value,\n+                obligations: vec![]\n+            }));\n+        }\n+    }\n+\n     /// Indicates that trying to normalize `key` resulted in\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will"}, {"sha": "6ee8c3579f5437c4d0f4602dd5bc339a2abebaee", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "patch": "@@ -67,6 +67,12 @@ impl<K, V> SnapshotMap<K, V>\n         }\n     }\n \n+    pub fn insert_noop(&mut self) {\n+        if !self.undo_log.is_empty() {\n+            self.undo_log.push(UndoLog::Noop);\n+        }\n+    }\n+\n     pub fn remove(&mut self, key: K) -> bool {\n         match self.map.remove(&key) {\n             Some(old_value) => {"}, {"sha": "a9ac53972e4756cad51c3490b767a73936b89b10", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use rustc::infer::canonical::{Canonical, QueryResult};\n-use rustc::traits::{self, FulfillmentContext, Normalized, ObligationCause,\n-                    SelectionContext};\n+use rustc::traits::{self, FulfillmentContext, ObligationCause, SelectionContext};\n use rustc::traits::query::{CanonicalProjectionGoal, NoSolution, normalize::NormalizationResult};\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n@@ -37,10 +36,9 @@ crate fn normalize_projection_ty<'tcx>(\n         let fulfill_cx = &mut FulfillmentContext::new();\n         let selcx = &mut SelectionContext::new(infcx);\n         let cause = ObligationCause::misc(DUMMY_SP, DUMMY_NODE_ID);\n-        let Normalized {\n-            value: answer,\n-            obligations,\n-        } = traits::normalize_projection_type(selcx, param_env, goal, cause, 0);\n+        let mut obligations = vec![];\n+        let answer =\n+            traits::normalize_projection_type(selcx, param_env, goal, cause, 0, &mut obligations);\n         fulfill_cx.register_predicate_obligations(infcx, obligations);\n \n         // Now that we have fulfilled as much as we can, create a solution"}, {"sha": "4274e5c1e1f7562d75d70d54059f5f758b3c68ac", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54df1bf200754292b24ff8b70ab9dcc7d583bf4a/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=54df1bf200754292b24ff8b70ab9dcc7d583bf4a", "patch": "@@ -129,20 +129,20 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         let mut selcx = traits::SelectionContext::new(self.fcx);\n-        let normalized = traits::normalize_projection_type(&mut selcx,\n-                                                           self.fcx.param_env,\n-                                                           ty::ProjectionTy::from_ref_and_name(\n-                                                               tcx,\n-                                                               trait_ref,\n-                                                               Symbol::intern(\"Target\"),\n-                                                           ),\n-                                                           cause,\n-                                                           0);\n-\n-        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized);\n-        self.obligations.extend(normalized.obligations);\n-\n-        Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n+        let normalized_ty = traits::normalize_projection_type(&mut selcx,\n+                                                              self.fcx.param_env,\n+                                                              ty::ProjectionTy::from_ref_and_name(\n+                                                                  tcx,\n+                                                                  trait_ref,\n+                                                                  Symbol::intern(\"Target\"),\n+                                                              ),\n+                                                              cause,\n+                                                              0,\n+                                                              &mut self.obligations);\n+\n+        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized_ty);\n+\n+        Some(self.fcx.resolve_type_vars_if_possible(&normalized_ty))\n     }\n \n     /// Returns the final type, generating an error if it is an"}]}