{"sha": "5e2856122a42a9e148d9d583561f7b07037bd3bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlMjg1NjEyMmE0MmE5ZTE0OGQ5ZDU4MzU2MWY3YjA3MDM3YmQzYmM=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-02-07T19:02:24Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-03-19T03:56:42Z"}, "message": "Properly handle Spans that reference imported SourceFiles\n\nPreviously, metadata encoding used DUMMY_SP to represent any spans that\nreferenced an 'imported' SourceFile - e.g. a SourceFile from an upstream\ndependency. These leads to sub-optimal error messages in certain cases\n(see the included test).\n\nThis PR changes how we encode and decode spans in crate metadata. We\nencode spans in one of two ways:\n\n* 'Local' spans, which reference non-imported SourceFiles, are encoded\n  exactly as before.\n* 'Foreign' spans, which reference imported SourceFiles, are encoded\n  with the CrateNum of their 'originating' crate. Additionally, their\n'lo' and 'high' values are rebased on top of the 'originating' crate,\nwhich allows them to be used with the SourceMap data encoded for that\ncrate.\n\nThe `ExternalSource` enum is renamed to `ExternalSourceKind`. There is\nnow a struct called `ExternalSource`, which holds an\n`ExternalSourceKind` along with the original line number information for\nthe file. This is used during `Span` serialization to rebase spans onto\ntheir 'owning' crate.", "tree": {"sha": "1994fb8f06bf0bb08c3dc451f3da8cda67950f59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1994fb8f06bf0bb08c3dc451f3da8cda67950f59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e2856122a42a9e148d9d583561f7b07037bd3bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl5y7XoACgkQtAh+UQ6Y\nsWSM4Q/+KdHtFSLtMIH1dqgcw7AcfClL3Y2orgG4AlyTmNkGSQ1XqFNZP5L+l41h\nppcNukW7MKmh1L1PZVd+njBhcu17guKJQnkSauNMA6mYrjv+PWEC25oRWYXmU9Sz\nUkuF4h46VheucUz4uBwEBkYpmWW5jVT4aGwtxw4NB9pZmyv3GeIXMAyK0TPB8Bqv\negzWc3J5tByBrBnECBVwVvveNJ/eNr/guXYi6yTOhkvIwCnshpmY3EoAXV5WBmTp\nuUm8/EZmNu2nDJ4hWEXYryYj/tJ0P6p78DXnsZs5r+y1vv0iLpPRa0UCiUEMv3ar\n1zAUjToHB9jJk05YAVA694ijv0CqPjH9QYdOjoP6TJ9IfmzEb3Oy7opmXdcEqMMO\nLHtmYN1V1kaysSqFxjH7wMr/EMrtnFKkrQUu6mQY/WznRaMRTYTlSXFckTYiFblH\n379LRjPAmtzZedFinIeEPF3CSQtSWltvljLjsuAfSyxCGzriQitvBrSusTFgkuWP\nVsDMgBuKbL/E5vcz9jBobKfJxNssSOW7hmvgLiSX8gabPZXU1ZDJYRkjzXU2SqnF\n9qEKw/OCKP4CsyicHaLUCcTFuzzOKolCs24/tL7/p2nK3ly2ORMLOxLqfpMzhs1t\nVqiAbkUfUVWJOiwFNeEsiGiniMfq/y7XTO6xb7RMIAzgH8Gkxjg=\n=gpIS\n-----END PGP SIGNATURE-----", "payload": "tree 1994fb8f06bf0bb08c3dc451f3da8cda67950f59\nparent 57e1da59cd0761330b4ea8d47b16340a78eeafa9\nauthor Aaron Hill <aa1ronham@gmail.com> 1581102144 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1584590202 -0400\n\nProperly handle Spans that reference imported SourceFiles\n\nPreviously, metadata encoding used DUMMY_SP to represent any spans that\nreferenced an 'imported' SourceFile - e.g. a SourceFile from an upstream\ndependency. These leads to sub-optimal error messages in certain cases\n(see the included test).\n\nThis PR changes how we encode and decode spans in crate metadata. We\nencode spans in one of two ways:\n\n* 'Local' spans, which reference non-imported SourceFiles, are encoded\n  exactly as before.\n* 'Foreign' spans, which reference imported SourceFiles, are encoded\n  with the CrateNum of their 'originating' crate. Additionally, their\n'lo' and 'high' values are rebased on top of the 'originating' crate,\nwhich allows them to be used with the SourceMap data encoded for that\ncrate.\n\nThe `ExternalSource` enum is renamed to `ExternalSourceKind`. There is\nnow a struct called `ExternalSource`, which holds an\n`ExternalSourceKind` along with the original line number information for\nthe file. This is used during `Span` serialization to rebase spans onto\ntheir 'owning' crate.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e2856122a42a9e148d9d583561f7b07037bd3bc", "html_url": "https://github.com/rust-lang/rust/commit/5e2856122a42a9e148d9d583561f7b07037bd3bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e2856122a42a9e148d9d583561f7b07037bd3bc/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57e1da59cd0761330b4ea8d47b16340a78eeafa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/57e1da59cd0761330b4ea8d47b16340a78eeafa9", "html_url": "https://github.com/rust-lang/rust/commit/57e1da59cd0761330b4ea8d47b16340a78eeafa9"}], "stats": {"total": 286, "additions": 234, "deletions": 52}, "files": [{"sha": "8b276d0a762c3be214c96d8668a83a094dd28f1c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n-use rustc_hir::def_id::{CrateNum, DefIndex, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefIndex, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -175,7 +175,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             .source_map\n             .files()\n             .iter()\n-            .filter(|source_file| CrateNum::from_u32(source_file.crate_of_origin) == LOCAL_CRATE)\n+            .filter(|source_file| source_file.cnum == LOCAL_CRATE)\n             .map(|source_file| source_file.name_hash)\n             .collect();\n "}, {"sha": "c5a4b53b10df85487663ba4d1bb238ff21aea3ea", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -5,7 +5,6 @@ use crate::ich::StableHashingContext;\n \n use rustc_ast::ast;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_span::SourceFile;\n \n use smallvec::SmallVec;\n@@ -59,7 +58,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n             name_hash,\n             name_was_remapped,\n             unmapped_path: _,\n-            crate_of_origin,\n+            cnum,\n             // Do not hash the source as it is not encoded\n             src: _,\n             src_hash,\n@@ -75,9 +74,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         (name_hash as u64).hash_stable(hcx, hasher);\n         name_was_remapped.hash_stable(hcx, hasher);\n \n-        DefId { krate: CrateNum::from_u32(crate_of_origin), index: CRATE_DEF_INDEX }\n-            .hash_stable(hcx, hasher);\n-\n         src_hash.hash_stable(hcx, hasher);\n \n         // We only hash the relative position within this source_file\n@@ -101,6 +97,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for SourceFile {\n         for &char_pos in normalized_pos.iter() {\n             stable_normalized_pos(char_pos, start_pos).hash_stable(hcx, hasher);\n         }\n+\n+        cnum.hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "9cad086b4e863be8942f3d216c5248511325dd21", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 85, "deletions": 6, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             return Ok(DUMMY_SP);\n         }\n \n-        debug_assert_eq!(tag, TAG_VALID_SPAN);\n+        debug_assert!(tag == TAG_VALID_SPAN_LOCAL || tag == TAG_VALID_SPAN_FOREIGN);\n \n         let lo = BytePos::decode(self)?;\n         let len = BytePos::decode(self)?;\n@@ -398,7 +398,68 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             bug!(\"Cannot decode Span without Session.\")\n         };\n \n-        let imported_source_files = self.cdata().imported_source_files(&sess.source_map());\n+        // There are two possibilities here:\n+        // 1. This is a 'local span', which is located inside a `SourceFile`\n+        // that came from this crate. In this case, we use the source map data\n+        // encoded in this crate. This branch should be taken nearly all of the time.\n+        // 2. This is a 'foreign span', which is located inside a `SourceFile`\n+        // that came from a *different* crate (some crate upstream of the one\n+        // whose metadata we're looking at). For example, consider this dependency graph:\n+        //\n+        // A -> B -> C\n+        //\n+        // Suppose that we're currently compiling crate A, and start deserializing\n+        // metadata from crate B. When we deserialize a Span from crate B's metadata,\n+        // there are two posibilites:\n+        //\n+        // 1. The span references a file from crate B. This makes it a 'local' span,\n+        // which means that we can use crate B's serialized source map information.\n+        // 2. The span references a file from crate C. This makes it a 'foreign' span,\n+        // which means we need to use Crate *C* (not crate B) to determine the source\n+        // map information. We only record source map information for a file in the\n+        // crate that 'owns' it, so deserializing a Span may require us to look at\n+        // a transitive dependency.\n+        //\n+        // When we encode a foreign span, we adjust its 'lo' and 'high' values\n+        // to be based on the *foreign* crate (e.g. crate C), not the crate\n+        // we are writing metadata for (e.g. crate B). This allows us to\n+        // treat the 'local' and 'foreign' cases almost identically during deserialization:\n+        // we can call `imported_source_files` for the proper crate, and binary search\n+        // through the returned slice using our span.\n+        let imported_source_files = if tag == TAG_VALID_SPAN_LOCAL {\n+            self.cdata().imported_source_files(sess.source_map())\n+        } else {\n+            // FIXME: We don't decode dependencies of proc-macros.\n+            // Remove this once #69976 is merged\n+            if self.cdata().root.is_proc_macro_crate() {\n+                debug!(\n+                    \"SpecializedDecoder<Span>::specialized_decode: skipping span for proc-macro crate {:?}\",\n+                    self.cdata().cnum\n+                );\n+                // Decode `CrateNum` as u32 - using `CrateNum::decode` will ICE\n+                // since we don't have `cnum_map` populated.\n+                // This advances the decoder position so that we can continue\n+                // to read metadata.\n+                let _ = u32::decode(self)?;\n+                return Ok(DUMMY_SP);\n+            }\n+            // tag is TAG_VALID_SPAN_FOREIGN, checked by `debug_assert` above\n+            let cnum = CrateNum::decode(self)?;\n+            debug!(\n+                \"SpecializedDecoder<Span>::specialized_decode: loading source files from cnum {:?}\",\n+                cnum\n+            );\n+\n+            // Decoding 'foreign' spans should be rare enough that it's\n+            // not worth it to maintain a per-CrateNum cache for `last_source_file_index`.\n+            // We just set it to 0, to ensure that we don't try to access something out\n+            // of bounds for our initial 'guess'\n+            self.last_source_file_index = 0;\n+\n+            let foreign_data = self.cdata().cstore.get_crate_data(cnum);\n+            foreign_data.imported_source_files(sess.source_map())\n+        };\n+\n         let source_file = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same source_file.\n@@ -412,16 +473,32 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n                     .binary_search_by_key(&lo, |source_file| source_file.original_start_pos)\n                     .unwrap_or_else(|index| index - 1);\n \n-                self.last_source_file_index = index;\n+                // Don't try to cache the index for foreign spans,\n+                // as this would require a map from CrateNums to indices\n+                if tag == TAG_VALID_SPAN_LOCAL {\n+                    self.last_source_file_index = index;\n+                }\n                 &imported_source_files[index]\n             }\n         };\n \n         // Make sure our binary search above is correct.\n-        debug_assert!(lo >= source_file.original_start_pos && lo <= source_file.original_end_pos);\n+        debug_assert!(\n+            lo >= source_file.original_start_pos && lo <= source_file.original_end_pos,\n+            \"Bad binary search: lo={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n+            lo,\n+            source_file.original_start_pos,\n+            source_file.original_end_pos\n+        );\n \n         // Make sure we correctly filtered out invalid spans during encoding\n-        debug_assert!(hi >= source_file.original_start_pos && hi <= source_file.original_end_pos);\n+        debug_assert!(\n+            hi >= source_file.original_start_pos && hi <= source_file.original_end_pos,\n+            \"Bad binary search: hi={:?} source_file.original_start_pos={:?} source_file.original_end_pos={:?}\",\n+            hi,\n+            source_file.original_start_pos,\n+            source_file.original_end_pos\n+        );\n \n         let lo =\n             (lo + source_file.translated_source_file.start_pos) - source_file.original_start_pos;\n@@ -1425,14 +1502,16 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     let local_version = local_source_map.new_imported_source_file(\n                         name,\n                         name_was_remapped,\n-                        self.cnum.as_u32(),\n                         src_hash,\n                         name_hash,\n                         source_length,\n+                        self.cnum,\n                         lines,\n                         multibyte_chars,\n                         non_narrow_chars,\n                         normalized_pos,\n+                        start_pos,\n+                        end_pos,\n                     );\n                     debug!(\n                         \"CrateMetaData::imported_source_files alloc \\"}, {"sha": "98528018d9e8087b985f2e1a41947ae81a7543cb", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 48, "deletions": 13, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -1,6 +1,7 @@\n use crate::rmeta::table::FixedSizeEncoding;\n use crate::rmeta::*;\n \n+use log::{debug, trace};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::map::Map;\n use rustc::middle::cstore::{EncodedMetadata, ForeignModule, LinkagePreference, NativeLibrary};\n@@ -29,9 +30,7 @@ use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::{self, CrateType};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{self, FileName, SourceFile, Span};\n-\n-use log::{debug, trace};\n+use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n use std::path::Path;\n@@ -165,20 +164,56 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n             return TAG_INVALID_SPAN.encode(self);\n         }\n \n-        // HACK(eddyb) there's no way to indicate which crate a Span is coming\n-        // from right now, so decoding would fail to find the SourceFile if\n-        // it's not local to the crate the Span is found in.\n-        if self.source_file_cache.is_imported() {\n-            return TAG_INVALID_SPAN.encode(self);\n-        }\n+        // There are two possible cases here:\n+        // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n+        // crate we are writing metadata for. When the metadata for *this* crate gets\n+        // deserialized, the deserializer will need to know which crate it originally came\n+        // from. We use `TAG_VALID_SPAN_FOREIGN` to indicate that a `CrateNum` should\n+        // be deserialized after the rest of the span data, which tells the deserializer\n+        // which crate contains the source map information.\n+        // 2. This span comes from our own crate. No special hamdling is needed - we just\n+        // write `TAG_VALID_SPAN_LOCAL` to let the deserializer know that it should use\n+        // our own source map information.\n+        let (tag, lo, hi) = if self.source_file_cache.is_imported() {\n+            // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n+            // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n+            // are relative to the source map information for the 'foreign' crate whose CrateNum\n+            // we write into the metadata. This allows `imported_source_files` to binary\n+            // search through the 'foreign' crate's source map information, using the\n+            // deserialized 'lo' and 'hi' values directly.\n+            //\n+            // All of this logic ensures that the final result of deserialization is a 'normal'\n+            // Span that can be used without any additional trouble.\n+            let external_start_pos = {\n+                // Introduce a new scope so that we drop the 'lock()' temporary\n+                match &*self.source_file_cache.external_src.lock() {\n+                    ExternalSource::Foreign { original_start_pos, .. } => *original_start_pos,\n+                    src => panic!(\"Unexpected external source {:?}\", src),\n+                }\n+            };\n+            let lo = (span.lo - self.source_file_cache.start_pos) + external_start_pos;\n+            let hi = (span.hi - self.source_file_cache.start_pos) + external_start_pos;\n \n-        TAG_VALID_SPAN.encode(self)?;\n-        span.lo.encode(self)?;\n+            (TAG_VALID_SPAN_FOREIGN, lo, hi)\n+        } else {\n+            (TAG_VALID_SPAN_LOCAL, span.lo, span.hi)\n+        };\n+\n+        tag.encode(self)?;\n+        lo.encode(self)?;\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n-        let len = span.hi - span.lo;\n-        len.encode(self)\n+        let len = hi - lo;\n+        len.encode(self)?;\n+\n+        if tag == TAG_VALID_SPAN_FOREIGN {\n+            // This needs to be two lines to avoid holding the `self.source_file_cache`\n+            // while calling `cnum.encode(self)`\n+            let cnum = self.source_file_cache.cnum;\n+            cnum.encode(self)?;\n+        }\n+        Ok(())\n \n         // Don't encode the expansion context.\n     }"}, {"sha": "05d834e5dee12b04097f253edf3fd785136c76ac", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -405,5 +405,6 @@ struct GeneratorData<'tcx> {\n }\n \n // Tags used for encoding Spans:\n-const TAG_VALID_SPAN: u8 = 0;\n-const TAG_INVALID_SPAN: u8 = 1;\n+const TAG_VALID_SPAN_LOCAL: u8 = 0;\n+const TAG_VALID_SPAN_FOREIGN: u8 = 1;\n+const TAG_INVALID_SPAN: u8 = 2;"}, {"sha": "dbc180114f1c1dafd90a9f296a057d1023457736", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -27,7 +27,7 @@ pub mod hygiene;\n use hygiene::Transparency;\n pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, MacroKind, SyntaxContext};\n pub mod def_id;\n-use def_id::DefId;\n+use def_id::{CrateNum, DefId, LOCAL_CRATE};\n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n \n@@ -839,30 +839,42 @@ pub struct NormalizedPos {\n     pub diff: u32,\n }\n \n-/// The state of the lazy external source loading mechanism of a `SourceFile`.\n-#[derive(PartialEq, Eq, Clone)]\n+#[derive(PartialEq, Eq, Clone, Debug)]\n pub enum ExternalSource {\n+    /// No external source has to be loaded, since the `SourceFile` represents a local crate.\n+    Unneeded,\n+    Foreign {\n+        kind: ExternalSourceKind,\n+        /// This SourceFile's byte-offset within the source_map of its original crate\n+        original_start_pos: BytePos,\n+        /// The end of this SourceFile within the source_map of its original crate\n+        original_end_pos: BytePos,\n+    },\n+}\n+\n+/// The state of the lazy external source loading mechanism of a `SourceFile`.\n+#[derive(PartialEq, Eq, Clone, Debug)]\n+pub enum ExternalSourceKind {\n     /// The external source has been loaded already.\n     Present(String),\n     /// No attempt has been made to load the external source.\n     AbsentOk,\n     /// A failed attempt has been made to load the external source.\n     AbsentErr,\n-    /// No external source has to be loaded, since the `SourceFile` represents a local crate.\n     Unneeded,\n }\n \n impl ExternalSource {\n     pub fn is_absent(&self) -> bool {\n-        match *self {\n-            ExternalSource::Present(_) => false,\n+        match self {\n+            ExternalSource::Foreign { kind: ExternalSourceKind::Present(_), .. } => false,\n             _ => true,\n         }\n     }\n \n     pub fn get_source(&self) -> Option<&str> {\n-        match *self {\n-            ExternalSource::Present(ref src) => Some(src),\n+        match self {\n+            ExternalSource::Foreign { kind: ExternalSourceKind::Present(ref src), .. } => Some(src),\n             _ => None,\n         }\n     }\n@@ -883,8 +895,6 @@ pub struct SourceFile {\n     /// The unmapped path of the file that the source came from.\n     /// Set to `None` if the `SourceFile` was imported from an external crate.\n     pub unmapped_path: Option<FileName>,\n-    /// Indicates which crate this `SourceFile` was imported from.\n-    pub crate_of_origin: u32,\n     /// The complete source code.\n     pub src: Option<Lrc<String>>,\n     /// The source code's hash.\n@@ -906,6 +916,8 @@ pub struct SourceFile {\n     pub normalized_pos: Vec<NormalizedPos>,\n     /// A hash of the filename, used for speeding up hashing in incremental compilation.\n     pub name_hash: u128,\n+    /// Indicates which crate this `SourceFile` was imported from.\n+    pub cnum: CrateNum,\n }\n \n impl Encodable for SourceFile {\n@@ -972,7 +984,8 @@ impl Encodable for SourceFile {\n             s.emit_struct_field(\"multibyte_chars\", 6, |s| self.multibyte_chars.encode(s))?;\n             s.emit_struct_field(\"non_narrow_chars\", 7, |s| self.non_narrow_chars.encode(s))?;\n             s.emit_struct_field(\"name_hash\", 8, |s| self.name_hash.encode(s))?;\n-            s.emit_struct_field(\"normalized_pos\", 9, |s| self.normalized_pos.encode(s))\n+            s.emit_struct_field(\"normalized_pos\", 9, |s| self.normalized_pos.encode(s))?;\n+            s.emit_struct_field(\"cnum\", 10, |s| self.cnum.encode(s))\n         })\n     }\n }\n@@ -1022,24 +1035,24 @@ impl Decodable for SourceFile {\n             let name_hash: u128 = d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n             let normalized_pos: Vec<NormalizedPos> =\n                 d.read_struct_field(\"normalized_pos\", 9, |d| Decodable::decode(d))?;\n+            let cnum: CrateNum = d.read_struct_field(\"cnum\", 10, |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 name_was_remapped,\n                 unmapped_path: None,\n-                // `crate_of_origin` has to be set by the importer.\n-                // This value matches up with `rustc_hir::def_id::INVALID_CRATE`.\n-                // That constant is not available here, unfortunately.\n-                crate_of_origin: std::u32::MAX - 1,\n                 start_pos,\n                 end_pos,\n                 src: None,\n                 src_hash,\n-                external_src: Lock::new(ExternalSource::AbsentOk),\n+                // Unused - the metadata decoder will construct\n+                // a new SourceFile, filling in `external_src` properly\n+                external_src: Lock::new(ExternalSource::Unneeded),\n                 lines,\n                 multibyte_chars,\n                 non_narrow_chars,\n                 normalized_pos,\n                 name_hash,\n+                cnum,\n             })\n         })\n     }\n@@ -1081,7 +1094,6 @@ impl SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n-            crate_of_origin: 0,\n             src: Some(Lrc::new(src)),\n             src_hash,\n             external_src: Lock::new(ExternalSource::Unneeded),\n@@ -1092,6 +1104,7 @@ impl SourceFile {\n             non_narrow_chars,\n             normalized_pos,\n             name_hash,\n+            cnum: LOCAL_CRATE,\n         }\n     }\n \n@@ -1109,21 +1122,27 @@ impl SourceFile {\n     where\n         F: FnOnce() -> Option<String>,\n     {\n-        if *self.external_src.borrow() == ExternalSource::AbsentOk {\n+        if matches!(\n+            *self.external_src.borrow(),\n+            ExternalSource::Foreign { kind: ExternalSourceKind::AbsentOk, .. }\n+        ) {\n             let src = get_src();\n             let mut external_src = self.external_src.borrow_mut();\n             // Check that no-one else have provided the source while we were getting it\n-            if *external_src == ExternalSource::AbsentOk {\n+            if let ExternalSource::Foreign {\n+                kind: src_kind @ ExternalSourceKind::AbsentOk, ..\n+            } = &mut *external_src\n+            {\n                 if let Some(src) = src {\n                     let mut hasher: StableHasher = StableHasher::new();\n                     hasher.write(src.as_bytes());\n \n                     if hasher.finish::<u128>() == self.src_hash {\n-                        *external_src = ExternalSource::Present(src);\n+                        *src_kind = ExternalSourceKind::Present(src);\n                         return true;\n                     }\n                 } else {\n-                    *external_src = ExternalSource::AbsentErr;\n+                    *src_kind = ExternalSourceKind::AbsentErr;\n                 }\n \n                 false"}, {"sha": "7dd9e2f6316b41631dc899307893836499fe7f73", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -296,14 +296,16 @@ impl SourceMap {\n         &self,\n         filename: FileName,\n         name_was_remapped: bool,\n-        crate_of_origin: u32,\n         src_hash: u128,\n         name_hash: u128,\n         source_len: usize,\n+        cnum: CrateNum,\n         mut file_local_lines: Vec<BytePos>,\n         mut file_local_multibyte_chars: Vec<MultiByteChar>,\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n+        original_start_pos: BytePos,\n+        original_end_pos: BytePos,\n     ) -> Lrc<SourceFile> {\n         let start_pos = self\n             .allocate_address_space(source_len)\n@@ -332,17 +334,21 @@ impl SourceMap {\n             name: filename,\n             name_was_remapped,\n             unmapped_path: None,\n-            crate_of_origin,\n             src: None,\n             src_hash,\n-            external_src: Lock::new(ExternalSource::AbsentOk),\n+            external_src: Lock::new(ExternalSource::Foreign {\n+                kind: ExternalSourceKind::AbsentOk,\n+                original_start_pos,\n+                original_end_pos,\n+            }),\n             start_pos,\n             end_pos,\n             lines: file_local_lines,\n             multibyte_chars: file_local_multibyte_chars,\n             non_narrow_chars: file_local_non_narrow_chars,\n             normalized_pos: file_local_normalized_pos,\n             name_hash,\n+            cnum,\n         });\n \n         let mut files = self.files.borrow_mut();"}, {"sha": "99b51625ac3ec2e041e34742173d133cbdd68290", "filename": "src/test/ui/span/auxiliary/transitive_dep_three.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Fauxiliary%2Ftransitive_dep_three.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Fauxiliary%2Ftransitive_dep_three.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fauxiliary%2Ftransitive_dep_three.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -0,0 +1,9 @@\n+#[macro_export]\n+macro_rules! define_parse_error {\n+    () => {\n+        #[macro_export]\n+        macro_rules! parse_error {\n+            () => { parse error }\n+        }\n+    }\n+}"}, {"sha": "5110c42765b6dae8a9fbb6ab25e205160d843aec", "filename": "src/test/ui/span/auxiliary/transitive_dep_two.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Fauxiliary%2Ftransitive_dep_two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Fauxiliary%2Ftransitive_dep_two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fauxiliary%2Ftransitive_dep_two.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -0,0 +1,3 @@\n+extern crate transitive_dep_three;\n+\n+transitive_dep_three::define_parse_error!();"}, {"sha": "b445d389c561ae9a82bba9a1defbbbd4538c3488", "filename": "src/test/ui/span/transitive-dep-span.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.rs?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -0,0 +1,13 @@\n+// Tests that we properly serialize/deserialize spans from transitive dependencies\n+// (e.g. imported SourceFiles)\n+//\n+// The order of these next lines is important, since we need\n+// transitive_dep_two.rs to be able to reference transitive_dep_three.rs\n+//\n+// aux-build: transitive_dep_three.rs\n+// aux-build: transitive_dep_two.rs\n+// compile-flags: -Z macro-backtrace\n+\n+extern crate transitive_dep_two;\n+\n+transitive_dep_two::parse_error!(); //~ ERROR expected one of"}, {"sha": "68d8911a4351cbbde4250393b16b31a21950eee9", "filename": "src/test/ui/span/transitive-dep-span.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5e2856122a42a9e148d9d583561f7b07037bd3bc/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Ftransitive-dep-span.stderr?ref=5e2856122a42a9e148d9d583561f7b07037bd3bc", "patch": "@@ -0,0 +1,19 @@\n+error: expected one of `!` or `::`, found `error`\n+  --> $DIR/auxiliary/transitive_dep_three.rs:6:27\n+   |\n+LL | /         macro_rules! parse_error {\n+LL | |             () => { parse error }\n+   | |                           ^^^^^ expected one of `!` or `::`\n+LL | |         }\n+   | |_________- in this expansion of `transitive_dep_two::parse_error!`\n+   | \n+  ::: $DIR/transitive-dep-span.rs:13:1\n+   |\n+LL |   transitive_dep_two::parse_error!();\n+   |   -----------------------------------\n+   |   |\n+   |   in this macro invocation\n+   |   in this macro invocation\n+\n+error: aborting due to previous error\n+"}]}