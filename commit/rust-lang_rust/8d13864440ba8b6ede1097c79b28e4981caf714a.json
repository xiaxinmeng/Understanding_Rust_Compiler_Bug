{"sha": "8d13864440ba8b6ede1097c79b28e4981caf714a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkMTM4NjQ0NDBiYThiNmVkZTEwOTdjNzliMjhlNDk4MWNhZjcxNGE=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-21T21:45:27Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-05-21T21:45:27Z"}, "message": "Add an ItemTree pretty-printer", "tree": {"sha": "0213e81d565c20a14800a97033af0caa1c7a5703", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0213e81d565c20a14800a97033af0caa1c7a5703"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d13864440ba8b6ede1097c79b28e4981caf714a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d13864440ba8b6ede1097c79b28e4981caf714a", "html_url": "https://github.com/rust-lang/rust/commit/8d13864440ba8b6ede1097c79b28e4981caf714a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d13864440ba8b6ede1097c79b28e4981caf714a/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01df4c04d12be89d53addca2885221419e56bf31", "url": "https://api.github.com/repos/rust-lang/rust/commits/01df4c04d12be89d53addca2885221419e56bf31", "html_url": "https://github.com/rust-lang/rust/commit/01df4c04d12be89d53addca2885221419e56bf31"}], "stats": {"total": 780, "additions": 780, "deletions": 0}, "files": [{"sha": "528270d49d3e084f730706441c9c327a885ee5c9", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d13864440ba8b6ede1097c79b28e4981caf714a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d13864440ba8b6ede1097c79b28e4981caf714a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=8d13864440ba8b6ede1097c79b28e4981caf714a", "patch": "@@ -1,6 +1,9 @@\n //! A simplified AST that only contains items.\n \n mod lower;\n+mod pretty;\n+#[cfg(test)]\n+mod tests;\n \n use std::{\n     any::type_name,\n@@ -205,6 +208,10 @@ impl ItemTree {\n         }\n     }\n \n+    pub fn pretty_print(&self) -> String {\n+        pretty::print_item_tree(self)\n+    }\n+\n     fn data(&self) -> &ItemTreeData {\n         self.data.as_ref().expect(\"attempted to access data of empty ItemTree\")\n     }\n@@ -776,6 +783,10 @@ impl<T> IdRange<T> {\n     fn new(range: Range<Idx<T>>) -> Self {\n         Self { range: range.start.into_raw().into()..range.end.into_raw().into(), _p: PhantomData }\n     }\n+\n+    fn is_empty(&self) -> bool {\n+        self.range.is_empty()\n+    }\n }\n \n impl<T> Iterator for IdRange<T> {"}, {"sha": "5ec02d1be74c7e4f5ad76a9a33adcb90862af3b5", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/8d13864440ba8b6ede1097c79b28e4981caf714a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d13864440ba8b6ede1097c79b28e4981caf714a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=8d13864440ba8b6ede1097c79b28e4981caf714a", "patch": "@@ -0,0 +1,525 @@\n+//! `ItemTree` debug printer.\n+\n+use std::fmt::{self, Write};\n+\n+use crate::{attr::RawAttrs, visibility::RawVisibility};\n+\n+use super::*;\n+\n+pub(super) fn print_item_tree(tree: &ItemTree) -> String {\n+    let mut p = Printer { tree, buf: String::new(), indent_level: 0, needs_indent: true };\n+\n+    if let Some(attrs) = tree.attrs.get(&AttrOwner::TopLevel) {\n+        p.print_attrs(attrs, true);\n+    }\n+    p.blank();\n+\n+    for item in tree.top_level_items() {\n+        p.print_mod_item(*item);\n+    }\n+\n+    let mut s = p.buf.trim_end_matches('\\n').to_string();\n+    s.push('\\n');\n+    s\n+}\n+\n+macro_rules! w {\n+    ($dst:expr, $($arg:tt)*) => {\n+        drop(write!($dst, $($arg)*))\n+    };\n+}\n+\n+macro_rules! wln {\n+    ($dst:expr) => {\n+        drop(writeln!($dst))\n+    };\n+    ($dst:expr, $($arg:tt)*) => {\n+        drop(writeln!($dst, $($arg)*))\n+    };\n+}\n+\n+struct Printer<'a> {\n+    tree: &'a ItemTree,\n+    buf: String,\n+    indent_level: usize,\n+    needs_indent: bool,\n+}\n+\n+impl<'a> Printer<'a> {\n+    fn indented(&mut self, f: impl FnOnce(&mut Self)) {\n+        self.indent_level += 1;\n+        wln!(self);\n+        f(self);\n+        self.indent_level -= 1;\n+        self.buf = self.buf.trim_end_matches('\\n').to_string();\n+    }\n+\n+    /// Ensures that a blank line is output before the next text.\n+    fn blank(&mut self) {\n+        let mut iter = self.buf.chars().rev().fuse();\n+        match (iter.next(), iter.next()) {\n+            (Some('\\n'), Some('\\n')) | (Some('\\n'), None) | (None, None) => {}\n+            (Some('\\n'), Some(_)) => {\n+                self.buf.push('\\n');\n+            }\n+            (Some(_), _) => {\n+                self.buf.push('\\n');\n+                self.buf.push('\\n');\n+            }\n+            (None, Some(_)) => unreachable!(),\n+        }\n+    }\n+\n+    fn print_attrs(&mut self, attrs: &RawAttrs, inner: bool) {\n+        let inner = if inner { \"!\" } else { \"\" };\n+        for attr in &**attrs {\n+            wln!(\n+                self,\n+                \"#{}[{}{}]  // {:?}\",\n+                inner,\n+                attr.path,\n+                attr.input.as_ref().map(|it| it.to_string()).unwrap_or_default(),\n+                attr.id,\n+            );\n+        }\n+    }\n+\n+    fn print_attrs_of(&mut self, of: impl Into<AttrOwner>) {\n+        if let Some(attrs) = self.tree.attrs.get(&of.into()) {\n+            self.print_attrs(attrs, false);\n+        }\n+    }\n+\n+    fn print_visibility(&mut self, vis: RawVisibilityId) {\n+        match &self.tree[vis] {\n+            RawVisibility::Module(path) => w!(self, \"pub({}) \", path),\n+            RawVisibility::Public => w!(self, \"pub \"),\n+        };\n+    }\n+\n+    fn print_fields(&mut self, fields: &Fields) {\n+        match fields {\n+            Fields::Record(fields) => {\n+                w!(self, \" {{\");\n+                self.indented(|this| {\n+                    for field in fields.clone() {\n+                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        this.print_attrs_of(field);\n+                        this.print_visibility(*visibility);\n+                        w!(this, \"{}: \", name);\n+                        this.print_type_ref(type_ref);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                w!(self, \"}}\");\n+            }\n+            Fields::Tuple(fields) => {\n+                w!(self, \"(\");\n+                self.indented(|this| {\n+                    for field in fields.clone() {\n+                        let Field { visibility, name, type_ref } = &this.tree[field];\n+                        this.print_attrs_of(field);\n+                        this.print_visibility(*visibility);\n+                        w!(this, \"{}: \", name);\n+                        this.print_type_ref(type_ref);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                w!(self, \")\");\n+            }\n+            Fields::Unit => {}\n+        }\n+    }\n+\n+    fn print_mod_item(&mut self, item: ModItem) {\n+        self.print_attrs_of(item);\n+\n+        match item {\n+            ModItem::Import(it) => {\n+                let Import { visibility, path, is_glob, alias, ast_id: _, index } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"use {}\", path);\n+                if *is_glob {\n+                    w!(self, \"::*\");\n+                }\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+                wln!(self, \";  // {}\", index);\n+            }\n+            ModItem::ExternCrate(it) => {\n+                let ExternCrate { name, alias, visibility, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"extern crate {}\", name);\n+                if let Some(alias) = alias {\n+                    w!(self, \" as {}\", alias);\n+                }\n+                wln!(self, \";\");\n+            }\n+            ModItem::ExternBlock(it) => {\n+                let ExternBlock { abi, ast_id: _, children } = &self.tree[it];\n+                w!(self, \"extern \");\n+                if let Some(abi) = abi {\n+                    w!(self, \"\\\"{}\\\" \", abi);\n+                }\n+                w!(self, \"{{\");\n+                self.indented(|this| {\n+                    for child in &**children {\n+                        this.print_mod_item(*child);\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Function(it) => {\n+                let Function {\n+                    name,\n+                    visibility,\n+                    generic_params: _, // FIXME print these somehow\n+                    abi,\n+                    params,\n+                    ret_type,\n+                    ast_id: _,\n+                    flags,\n+                } = &self.tree[it];\n+                if flags.bits != 0 {\n+                    wln!(self, \"// flags = 0x{:X}\", flags.bits);\n+                }\n+                self.print_visibility(*visibility);\n+                if let Some(abi) = abi {\n+                    w!(self, \"extern \\\"{}\\\" \", abi);\n+                }\n+                w!(self, \"fn {}(\", name);\n+                if !params.is_empty() {\n+                    self.indented(|this| {\n+                        for param in params.clone() {\n+                            this.print_attrs_of(param);\n+                            match &this.tree[param] {\n+                                Param::Normal(ty) => {\n+                                    w!(this, \"_: \");\n+                                    this.print_type_ref(ty);\n+                                    wln!(this, \",\");\n+                                }\n+                                Param::Varargs => {\n+                                    wln!(this, \"...\");\n+                                }\n+                            };\n+                        }\n+                    });\n+                }\n+                w!(self, \") -> \");\n+                self.print_type_ref(ret_type);\n+                wln!(self, \";\");\n+            }\n+            ModItem::Struct(it) => {\n+                let Struct { visibility, name, fields, generic_params: _, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"struct {}\", name);\n+                self.print_fields(fields);\n+                if matches!(fields, Fields::Record(_)) {\n+                    wln!(self);\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Union(it) => {\n+                let Union { name, visibility, fields, generic_params: _, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"union {}\", name);\n+                self.print_fields(fields);\n+                if matches!(fields, Fields::Record(_)) {\n+                    wln!(self);\n+                } else {\n+                    wln!(self, \";\");\n+                }\n+            }\n+            ModItem::Enum(it) => {\n+                let Enum { name, visibility, variants, generic_params: _, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"enum {} {{\", name);\n+                self.indented(|this| {\n+                    for variant in variants.clone() {\n+                        let Variant { name, fields } = &this.tree[variant];\n+                        this.print_attrs_of(variant);\n+                        w!(this, \"{}\", name);\n+                        this.print_fields(fields);\n+                        wln!(this, \",\");\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Const(it) => {\n+                let Const { name, visibility, type_ref, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"const \");\n+                match name {\n+                    Some(name) => w!(self, \"{}\", name),\n+                    None => w!(self, \"_\"),\n+                }\n+                w!(self, \": \");\n+                self.print_type_ref(type_ref);\n+                wln!(self, \" = _;\");\n+            }\n+            ModItem::Static(it) => {\n+                let Static { name, visibility, mutable, is_extern, type_ref, ast_id: _ } =\n+                    &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"static \");\n+                if *mutable {\n+                    w!(self, \"mut \");\n+                }\n+                w!(self, \"{}: \", name);\n+                self.print_type_ref(type_ref);\n+                w!(self, \" = _;\");\n+                if *is_extern {\n+                    w!(self, \"  // extern\");\n+                }\n+                wln!(self);\n+            }\n+            ModItem::Trait(it) => {\n+                let Trait {\n+                    name,\n+                    visibility,\n+                    is_auto,\n+                    is_unsafe,\n+                    bounds,\n+                    items,\n+                    generic_params: _,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                if *is_unsafe {\n+                    w!(self, \"unsafe \");\n+                }\n+                if *is_auto {\n+                    w!(self, \"auto \");\n+                }\n+                w!(self, \"trait {}\", name);\n+                if !bounds.is_empty() {\n+                    w!(self, \": \");\n+                    self.print_type_bounds(bounds);\n+                }\n+                w!(self, \" {{\");\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::Impl(it) => {\n+                let Impl {\n+                    target_trait,\n+                    self_ty,\n+                    is_negative,\n+                    items,\n+                    generic_params: _,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                w!(self, \"impl \");\n+                if *is_negative {\n+                    w!(self, \"!\");\n+                }\n+                if let Some(tr) = target_trait {\n+                    self.print_path(&tr.path);\n+                    w!(self, \" for \");\n+                }\n+                self.print_type_ref(self_ty);\n+                w!(self, \" {{\");\n+                self.indented(|this| {\n+                    for item in &**items {\n+                        this.print_mod_item((*item).into());\n+                    }\n+                });\n+                wln!(self, \"}}\");\n+            }\n+            ModItem::TypeAlias(it) => {\n+                let TypeAlias {\n+                    name,\n+                    visibility,\n+                    bounds,\n+                    type_ref,\n+                    is_extern,\n+                    generic_params: _,\n+                    ast_id: _,\n+                } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"type {}\", name);\n+                if !bounds.is_empty() {\n+                    w!(self, \": \");\n+                    self.print_type_bounds(bounds);\n+                }\n+                if let Some(ty) = type_ref {\n+                    w!(self, \" = \");\n+                    self.print_type_ref(ty);\n+                }\n+                w!(self, \";\");\n+                if *is_extern {\n+                    w!(self, \"  // extern\");\n+                }\n+                wln!(self);\n+            }\n+            ModItem::Mod(it) => {\n+                let Mod { name, visibility, kind, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                w!(self, \"mod {}\", name);\n+                match kind {\n+                    ModKind::Inline { items } => {\n+                        w!(self, \" {{\");\n+                        self.indented(|this| {\n+                            for item in &**items {\n+                                this.print_mod_item((*item).into());\n+                            }\n+                        });\n+                        wln!(self, \"}}\");\n+                    }\n+                    ModKind::Outline {} => {\n+                        wln!(self, \";\");\n+                    }\n+                }\n+            }\n+            ModItem::MacroCall(it) => {\n+                let MacroCall { path, ast_id: _, fragment: _ } = &self.tree[it];\n+                wln!(self, \"{}!(...);\", path);\n+            }\n+            ModItem::MacroRules(it) => {\n+                let MacroRules { name, ast_id: _ } = &self.tree[it];\n+                wln!(self, \"macro_rules! {} {{ ... }}\", name);\n+            }\n+            ModItem::MacroDef(it) => {\n+                let MacroDef { name, visibility, ast_id: _ } = &self.tree[it];\n+                self.print_visibility(*visibility);\n+                wln!(self, \"macro {} {{ ... }}\", name);\n+            }\n+        }\n+\n+        self.blank();\n+    }\n+\n+    fn print_type_ref(&mut self, type_ref: &TypeRef) {\n+        // FIXME: deduplicate with `HirDisplay` impl\n+        match type_ref {\n+            TypeRef::Never => w!(self, \"!\"),\n+            TypeRef::Placeholder => w!(self, \"_\"),\n+            TypeRef::Tuple(fields) => {\n+                w!(self, \"(\");\n+                for (i, field) in fields.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_type_ref(field);\n+                }\n+                w!(self, \")\");\n+            }\n+            TypeRef::Path(path) => self.print_path(path),\n+            TypeRef::RawPtr(pointee, mtbl) => {\n+                let mtbl = match mtbl {\n+                    Mutability::Shared => \"*const\",\n+                    Mutability::Mut => \"*mut\",\n+                };\n+                w!(self, \"{} \", mtbl);\n+                self.print_type_ref(pointee);\n+            }\n+            TypeRef::Reference(pointee, lt, mtbl) => {\n+                let mtbl = match mtbl {\n+                    Mutability::Shared => \"\",\n+                    Mutability::Mut => \"mut \",\n+                };\n+                w!(self, \"&\");\n+                if let Some(lt) = lt {\n+                    w!(self, \"{} \", lt.name);\n+                }\n+                w!(self, \"{}\", mtbl);\n+                self.print_type_ref(pointee);\n+            }\n+            TypeRef::Array(elem, len) => {\n+                w!(self, \"[\");\n+                self.print_type_ref(elem);\n+                w!(self, \"; {}]\", len);\n+            }\n+            TypeRef::Slice(elem) => {\n+                w!(self, \"[\");\n+                self.print_type_ref(elem);\n+                w!(self, \"]\");\n+            }\n+            TypeRef::Fn(args_and_ret, varargs) => {\n+                let (ret, args) =\n+                    args_and_ret.split_last().expect(\"TypeRef::Fn is missing return type\");\n+                w!(self, \"fn(\");\n+                for (i, arg) in args.iter().enumerate() {\n+                    if i != 0 {\n+                        w!(self, \", \");\n+                    }\n+                    self.print_type_ref(arg);\n+                }\n+                if *varargs {\n+                    if !args.is_empty() {\n+                        w!(self, \", \");\n+                    }\n+                    w!(self, \"...\");\n+                }\n+                w!(self, \") -> \");\n+                self.print_type_ref(ret);\n+            }\n+            TypeRef::Macro(_ast_id) => {\n+                w!(self, \"<macro>\");\n+            }\n+            TypeRef::Error => drop(write!(self, \"{{unknown}}\")),\n+            TypeRef::ImplTrait(bounds) => {\n+                w!(self, \"impl \");\n+                self.print_type_bounds(bounds);\n+            }\n+            TypeRef::DynTrait(bounds) => {\n+                w!(self, \"dyn \");\n+                self.print_type_bounds(bounds);\n+            }\n+        }\n+    }\n+\n+    fn print_type_bounds(&mut self, bounds: &[TypeBound]) {\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if i != 0 {\n+                w!(self, \" + \");\n+            }\n+\n+            match bound {\n+                TypeBound::Path(path) => self.print_path(path),\n+                TypeBound::Lifetime(lt) => w!(self, \"{}\", lt.name),\n+                TypeBound::Error => w!(self, \"{{unknown}}\"),\n+            }\n+        }\n+    }\n+\n+    fn print_path(&mut self, path: &Path) {\n+        if path.type_anchor().is_none()\n+            && path.segments().iter().all(|seg| seg.args_and_bindings.is_none())\n+        {\n+            w!(self, \"{}\", path.mod_path());\n+        } else {\n+            // too complicated, just use `Debug`\n+            w!(self, \"{:?}\", path);\n+        }\n+    }\n+}\n+\n+impl<'a> Write for Printer<'a> {\n+    fn write_str(&mut self, s: &str) -> fmt::Result {\n+        for line in s.split_inclusive('\\n') {\n+            if self.needs_indent {\n+                match self.buf.chars().last() {\n+                    Some('\\n') | None => {}\n+                    _ => self.buf.push('\\n'),\n+                }\n+                self.buf.push_str(&\"    \".repeat(self.indent_level));\n+                self.needs_indent = false;\n+            }\n+\n+            self.buf.push_str(line);\n+            self.needs_indent = line.ends_with('\\n');\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "100ae9b97a24b49806eeb316bde0d7752c2e0fce", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/8d13864440ba8b6ede1097c79b28e4981caf714a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d13864440ba8b6ede1097c79b28e4981caf714a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=8d13864440ba8b6ede1097c79b28e4981caf714a", "patch": "@@ -0,0 +1,244 @@\n+use base_db::fixture::WithFixture;\n+use expect_test::{expect, Expect};\n+\n+use crate::{db::DefDatabase, test_db::TestDB};\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let item_tree = db.file_item_tree(file_id.into());\n+    let pretty = item_tree.pretty_print();\n+    expect.assert_eq(&pretty);\n+}\n+\n+#[test]\n+fn imports() {\n+    check(\n+        r#\"\n+//! file comment\n+#![no_std]\n+//! another file comment\n+\n+extern crate self as renamed;\n+pub(super) extern crate bli;\n+\n+pub use crate::path::{nested, items as renamed, Trait as _};\n+use globs::*;\n+\n+/// docs on import\n+use crate::{A, B};\n+        \"#,\n+        expect![[r##\"\n+            #![doc = \" file comment\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            #![no_std]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            #![doc = \" another file comment\"]  // AttrId { is_doc_comment: true, ast_index: 1 }\n+\n+            pub(self) extern crate self as renamed;\n+\n+            pub(super) extern crate bli;\n+\n+            pub use crate::path::nested;  // 0\n+\n+            pub use crate::path::items as renamed;  // 1\n+\n+            pub use crate::path::Trait as _;  // 2\n+\n+            pub(self) use globs::*;  // 0\n+\n+            #[doc = \" docs on import\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            pub(self) use crate::A;  // 0\n+\n+            #[doc = \" docs on import\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            pub(self) use crate::B;  // 1\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn extern_blocks() {\n+    check(\n+        r#\"\n+#[on_extern_block]\n+extern \"C\" {\n+    #[on_extern_type]\n+    type ExType;\n+\n+    #[on_extern_static]\n+    static EX_STATIC: u8;\n+\n+    #[on_extern_fn]\n+    fn ex_fn();\n+}\n+        \"#,\n+        expect![[r##\"\n+            #[on_extern_block]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            extern \"C\" {\n+                #[on_extern_type]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                pub(self) type ExType;  // extern\n+\n+                #[on_extern_static]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                pub(self) static EX_STATIC: u8 = _;  // extern\n+\n+                #[on_extern_fn]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                // flags = 0x60\n+                pub(self) fn ex_fn() -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn adts() {\n+    check(\n+        r#\"\n+struct Unit;\n+\n+#[derive(Debug)]\n+struct Struct {\n+    /// fld docs\n+    fld: (),\n+}\n+\n+struct Tuple(#[attr] u8);\n+\n+union Ize {\n+    a: (),\n+    b: (),\n+}\n+\n+enum E {\n+    /// comment on Unit\n+    Unit,\n+    /// comment on Tuple\n+    Tuple(u8),\n+    Struct {\n+        /// comment on a: u8\n+        a: u8,\n+    }\n+}\n+        \"#,\n+        expect![[r##\"\n+            pub(self) struct Unit;\n+\n+            #[derive(Debug)]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            pub(self) struct Struct {\n+                #[doc = \" fld docs\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                pub(self) fld: (),\n+            }\n+\n+            pub(self) struct Tuple(\n+                #[attr]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                pub(self) 0: u8,\n+            );\n+\n+            pub(self) union Ize {\n+                pub(self) a: (),\n+                pub(self) b: (),\n+            }\n+\n+            pub(self) enum E {\n+                #[doc = \" comment on Unit\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                Unit,\n+                #[doc = \" comment on Tuple\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                Tuple(\n+                    pub(self) 0: u8,\n+                ),\n+                Struct {\n+                    #[doc = \" comment on a: u8\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+                    pub(self) a: u8,\n+                },\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn misc() {\n+    check(\n+        r#\"\n+pub static mut ST: () = ();\n+\n+const _: Anon = ();\n+\n+#[attr]\n+fn f(#[attr] arg: u8, _: ()) {\n+    #![inner_attr_in_fn]\n+}\n+\n+trait Tr: SuperTrait + 'lifetime {\n+    type Assoc: AssocBound = Default;\n+    fn method(&self);\n+}\n+        \"#,\n+        expect![[r##\"\n+            pub static mut ST: () = _;\n+\n+            pub(self) const _: Anon = _;\n+\n+            #[attr]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+            #[inner_attr_in_fn]  // AttrId { is_doc_comment: false, ast_index: 1 }\n+            // flags = 0x2\n+            pub(self) fn f(\n+                #[attr]  // AttrId { is_doc_comment: false, ast_index: 0 }\n+                _: u8,\n+                _: (),\n+            ) -> ();\n+\n+            pub(self) trait Tr: SuperTrait + 'lifetime {\n+                pub(self) type Assoc: AssocBound = Default;\n+\n+                // flags = 0x1\n+                pub(self) fn method(\n+                    _: &Self,\n+                ) -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn modules() {\n+    check(\n+        r#\"\n+/// outer\n+mod inline {\n+    //! inner\n+\n+    use super::*;\n+\n+    fn fn_in_module() {}\n+}\n+        \"#,\n+        expect![[r##\"\n+            #[doc = \" outer\"]  // AttrId { is_doc_comment: true, ast_index: 0 }\n+            #[doc = \" inner\"]  // AttrId { is_doc_comment: true, ast_index: 1 }\n+            pub(self) mod inline {\n+                pub(self) use super::*;  // 0\n+\n+                // flags = 0x2\n+                pub(self) fn fn_in_module() -> ();\n+            }\n+        \"##]],\n+    );\n+}\n+\n+#[test]\n+fn macros() {\n+    check(\n+        r#\"\n+macro_rules! m {\n+    () => {};\n+}\n+\n+pub macro m2() {}\n+\n+m!();\n+        \"#,\n+        expect![[r#\"\n+            macro_rules! m { ... }\n+\n+            pub macro m2 { ... }\n+\n+            m!(...);\n+        \"#]],\n+    );\n+}"}]}