{"sha": "bd573becf5f4ca10af7b90d41152ada530cb6b94", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNTczYmVjZjVmNGNhMTBhZjdiOTBkNDExNTJhZGE1MzBjYjZiOTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T04:47:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-24T12:19:44Z"}, "message": "change region scope of call arguments, old one was unsound\n\nimprove error message to describe kind of deref'd ptr using sigil", "tree": {"sha": "5838a6af82422804447f5417f439ef2321d8c2a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5838a6af82422804447f5417f439ef2321d8c2a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd573becf5f4ca10af7b90d41152ada530cb6b94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd573becf5f4ca10af7b90d41152ada530cb6b94", "html_url": "https://github.com/rust-lang/rust/commit/bd573becf5f4ca10af7b90d41152ada530cb6b94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd573becf5f4ca10af7b90d41152ada530cb6b94/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9eb9ee6121b10927de80d32e448691388545b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9eb9ee6121b10927de80d32e448691388545b3e", "html_url": "https://github.com/rust-lang/rust/commit/c9eb9ee6121b10927de80d32e448691388545b3e"}], "stats": {"total": 131, "additions": 81, "deletions": 50}, "files": [{"sha": "7011ea43cc80fd4813d457b2cafcbc0e79aec053", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 35, "deletions": 45, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -162,43 +162,38 @@ type ctxt = {\n     def_map: resolve::def_map,\n     region_map: region_map,\n \n-    // These two fields (parent and closure_parent) specify the parent\n-    // scope of the current expression.  The parent scope is the\n-    // innermost block, call, or alt expression during the execution\n-    // of which the current expression will be evaluated.  Generally\n-    // speaking, the innermost parent scope is also the closest\n-    // suitable ancestor in the AST tree.\n+    // The parent scope is the innermost block, call, or alt\n+    // expression during the execution of which the current expression\n+    // will be evaluated.  Generally speaking, the innermost parent\n+    // scope is also the closest suitable ancestor in the AST tree.\n     //\n-    // However, there are two subtle cases where the parent scope for\n-    // an expression is not strictly derived from the AST. The first\n-    // such exception concerns call arguments and the second concerns\n-    // closures (which, at least today, are always call arguments).\n-    // Consider:\n+    // There is a subtle point concerning call arguments.  Imagine\n+    // you have a call:\n     //\n     // { // block a\n-    //    foo( // call b\n+    //     foo( // call b\n     //        x,\n-    //        y,\n-    //        fn&() {\n-    //          // fn body c\n-    //        })\n+    //        y);\n     // }\n     //\n-    // Here, the parent of the three argument expressions is\n-    // actually the block `a`, not the call `b`, because they will\n-    // be evaluated before the call conceptually takes place.\n-    // However, the body of the closure is parented by the call\n-    // `b` (it cannot be invoked except during that call, after\n-    // all).\n+    // In what lifetime are the expressions `x` and `y` evaluated?  At\n+    // first, I imagine the answer was the block `a`, as the arguments\n+    // are evaluated before the call takes place.  But this turns out\n+    // to be wrong.  The lifetime of the call must encompass the\n+    // argument evaluation as well.\n     //\n-    // To capture these patterns, we use two fields.  The first,\n-    // parent, is the parent scope of a normal expression.  The\n-    // second, closure_parent, is the parent scope that a closure body\n-    // ought to use.  These only differ in the case of calls, where\n-    // the closure parent is the call, but the parent is the container\n-    // of the call.\n-    parent: parent,\n-    closure_parent: parent\n+    // The reason is that evaluation of an earlier argument could\n+    // create a borrow which exists during the evaluation of later\n+    // arguments.  Consider this torture test, for example,\n+    //\n+    // fn test1(x: @mut ~int) {\n+    //     foo(&**x, *x = ~5);\n+    // }\n+    //\n+    // Here, the first argument `&**x` will be a borrow of the `~int`,\n+    // but the second argument overwrites that very value! Bad.\n+    // (This test is borrowck-pure-scope-in-call.rs, btw)\n+    parent: parent\n };\n \n // Returns true if `subscope` is equal to or is lexically nested inside\n@@ -291,8 +286,7 @@ fn resolve_block(blk: ast::blk, cx: ctxt, visitor: visit::vt<ctxt>) {\n     record_parent(cx, blk.node.id);\n \n     // Descend.\n-    let new_cx: ctxt = {parent: some(blk.node.id),\n-                        closure_parent: some(blk.node.id) with cx};\n+    let new_cx: ctxt = {parent: some(blk.node.id) with cx};\n     visit::visit_block(blk, new_cx, visitor);\n }\n \n@@ -325,14 +319,12 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     alt expr.node {\n       ast::expr_call(*) {\n         #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n-        let new_cx = {closure_parent: some(expr.id) with cx};\n+        let new_cx = {parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       ast::expr_alt(subexpr, _, _) {\n         #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n-        let new_cx = {parent: some(expr.id),\n-                      closure_parent: some(expr.id)\n-                      with cx};\n+        let new_cx = {parent: some(expr.id) with cx};\n         visit::visit_expr(expr, new_cx, visitor);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n@@ -358,7 +350,7 @@ fn resolve_local(local: @ast::local, cx: ctxt, visitor: visit::vt<ctxt>) {\n \n fn resolve_item(item: @ast::item, cx: ctxt, visitor: visit::vt<ctxt>) {\n     // Items create a new outer block scope as far as we're concerned.\n-    let new_cx: ctxt = {closure_parent: none, parent: none with cx};\n+    let new_cx: ctxt = {parent: none with cx};\n     visit::visit_item(item, new_cx, visitor);\n }\n \n@@ -370,19 +362,18 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n       visit::fk_item_fn(*) | visit::fk_method(*) | visit::fk_res(*) |\n       visit::fk_ctor(*) | visit::fk_dtor(*) {\n         // Top-level functions are a root scope.\n-        {parent: some(id), closure_parent: some(id) with cx}\n+        {parent: some(id) with cx}\n       }\n \n       visit::fk_anon(*) | visit::fk_fn_block(*) {\n-        // Closures use the closure_parent.\n-        {parent: cx.closure_parent with cx}\n+        // Closures continue with the inherited scope.\n+        cx\n       }\n     };\n \n     #debug[\"visiting fn with body %d. cx.parent: %? \\\n-            cx.closure_parent: %? fn_cx.parent: %?\",\n-           body.node.id, cx.parent,\n-           cx.closure_parent, fn_cx.parent];\n+            fn_cx.parent: %?\",\n+           body.node.id, cx.parent, fn_cx.parent];\n \n     for decl.inputs.each { |input|\n         cx.region_map.insert(input.id, body.node.id);\n@@ -396,8 +387,7 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n                     region_map: map::int_hash(),\n-                    parent: none,\n-                    closure_parent: none};\n+                    parent: none};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,"}, {"sha": "8c5dd361baed2f9ff82e816173af370c234c736f", "filename": "src/test/compile-fail/borrowck-pure-scope-in-call.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-pure-scope-in-call.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -0,0 +1,24 @@\n+// xfail-fast  (compile-flags unsupported on windows)\n+// compile-flags:--borrowck=err\n+\n+pure fn pure_borrow(_x: &int, _y: ()) {}\n+\n+fn test1(x: @mut ~int) {\n+    // Here, evaluating the second argument actually invalidates the\n+    // first borrow, even though it occurs outside of the scope of the\n+    // borrow!\n+    pure_borrow(*x, *x = ~5);  //! ERROR illegal borrow unless pure: unique value in aliasable, mutable location\n+    //!^ NOTE impure due to assigning to dereference of mutable @ pointer\n+}\n+\n+fn test2() {\n+    let mut x = ~1;\n+\n+    // Same, but for loanable data:\n+\n+    pure_borrow(x, x = ~5);  //! ERROR assigning to mutable local variable prohibited due to outstanding loan\n+    //!^ NOTE loan of mutable local variable granted here\n+}\n+\n+fn main() {\n+}\n\\ No newline at end of file"}, {"sha": "d5989822f94b8a55b7bc57c8f0fc79ad41a2ea39", "filename": "src/test/compile-fail/fn-variance-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-3.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -20,5 +20,5 @@ fn main() {\n     // mutability check will fail, because the\n     // type of r has been inferred to be\n     // fn(@const int) -> @const int\n-    *r(@mut 3) = 4; //! ERROR assigning to dereference of const pointer\n+    *r(@mut 3) = 4; //! ERROR assigning to dereference of const @ pointer\n }"}, {"sha": "5b5150b985c3cc36d28b05d8bd3ab81cfa26b547", "filename": "src/test/compile-fail/mutable-huh-box-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fmutable-huh-box-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fmutable-huh-box-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-box-assign.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     fn f(&&v: @const int) {\n-        *v = 1 //! ERROR assigning to dereference of const pointer\n+        *v = 1 //! ERROR assigning to dereference of const @ pointer\n     }\n \n     let v = @0;"}, {"sha": "77ba86d6d6f5f446978a2c5f810419ba67ebc6f3", "filename": "src/test/compile-fail/mutable-huh-ptr-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-ptr-assign.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -2,7 +2,7 @@ use std;\n \n fn main() {\n     unsafe fn f(&&v: *const int) {\n-        *v = 1 //! ERROR assigning to dereference of const pointer\n+        *v = 1 //! ERROR assigning to dereference of const * pointer\n     }\n \n     unsafe {"}, {"sha": "591ea069b0709e4fba3e0300c73ceef4a78bed2b", "filename": "src/test/compile-fail/mutable-huh-unique-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-unique-assign.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     fn f(&&v: ~const int) {\n-        *v = 1 //! ERROR assigning to dereference of const pointer\n+        *v = 1 //! ERROR assigning to dereference of const ~ pointer\n     }\n \n     let v = ~0;"}, {"sha": "08e102af4e8f9a9775549cd39e6563e4ef7fb724", "filename": "src/test/run-pass/borrowck-borrow-from-expr-block.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-borrow-from-expr-block.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -0,0 +1,16 @@\n+fn borrow(x: &int, f: fn(x: &int)) {\n+    f(x)\n+}\n+\n+fn test1(x: @~int) {\n+    // Right now, at least, this induces a copy of the unique pointer:\n+    borrow({*x}) { |p|\n+        let x_a = ptr::addr_of(**x);\n+        assert (x_a as uint) != (p as uint);\n+        assert unsafe{*x_a} == *p;\n+    }\n+}\n+\n+fn main() {\n+    test1(@~22);\n+}\n\\ No newline at end of file"}, {"sha": "5d0407b38513429715b9853b1ce4ce0ca53e4c67", "filename": "src/test/run-pass/regions-addr-of-ret.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd573becf5f4ca10af7b90d41152ada530cb6b94/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-addr-of-ret.rs?ref=bd573becf5f4ca10af7b90d41152ada530cb6b94", "patch": "@@ -3,6 +3,7 @@ fn f(x : &a.int) -> &a.int {\n }\n \n fn main() {\n-    log(error, #fmt(\"%d\", *f(&3)));\n+    let three = &3;\n+    log(error, #fmt(\"%d\", *f(three)));\n }\n "}]}