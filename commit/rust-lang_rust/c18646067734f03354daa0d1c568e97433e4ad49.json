{"sha": "c18646067734f03354daa0d1c568e97433e4ad49", "node_id": "C_kwDOAAsO6NoAKGMxODY0NjA2NzczNGYwMzM1NGRhYTBkMWM1NjhlOTc0MzNlNGFkNDk", "commit": {"author": {"name": "r00ster91", "email": "r00ster91@protonmail.com", "date": "2022-02-19T16:29:51Z"}, "committer": {"name": "r00ster91", "email": "r00ster91@protonmail.com", "date": "2022-02-19T16:29:51Z"}, "message": "Fix some confusing wording and improve slice-search-related docs", "tree": {"sha": "e5c8e9ec3009d9c527552dd0bc8b662c2e7275ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5c8e9ec3009d9c527552dd0bc8b662c2e7275ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c18646067734f03354daa0d1c568e97433e4ad49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c18646067734f03354daa0d1c568e97433e4ad49", "html_url": "https://github.com/rust-lang/rust/commit/c18646067734f03354daa0d1c568e97433e4ad49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c18646067734f03354daa0d1c568e97433e4ad49/comments", "author": {"login": "r00ster91", "id": 35064754, "node_id": "MDQ6VXNlcjM1MDY0NzU0", "avatar_url": "https://avatars.githubusercontent.com/u/35064754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/r00ster91", "html_url": "https://github.com/r00ster91", "followers_url": "https://api.github.com/users/r00ster91/followers", "following_url": "https://api.github.com/users/r00ster91/following{/other_user}", "gists_url": "https://api.github.com/users/r00ster91/gists{/gist_id}", "starred_url": "https://api.github.com/users/r00ster91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/r00ster91/subscriptions", "organizations_url": "https://api.github.com/users/r00ster91/orgs", "repos_url": "https://api.github.com/users/r00ster91/repos", "events_url": "https://api.github.com/users/r00ster91/events{/privacy}", "received_events_url": "https://api.github.com/users/r00ster91/received_events", "type": "User", "site_admin": false}, "committer": {"login": "r00ster91", "id": 35064754, "node_id": "MDQ6VXNlcjM1MDY0NzU0", "avatar_url": "https://avatars.githubusercontent.com/u/35064754?v=4", "gravatar_id": "", "url": "https://api.github.com/users/r00ster91", "html_url": "https://github.com/r00ster91", "followers_url": "https://api.github.com/users/r00ster91/followers", "following_url": "https://api.github.com/users/r00ster91/following{/other_user}", "gists_url": "https://api.github.com/users/r00ster91/gists{/gist_id}", "starred_url": "https://api.github.com/users/r00ster91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/r00ster91/subscriptions", "organizations_url": "https://api.github.com/users/r00ster91/orgs", "repos_url": "https://api.github.com/users/r00ster91/repos", "events_url": "https://api.github.com/users/r00ster91/events{/privacy}", "received_events_url": "https://api.github.com/users/r00ster91/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e08d5693609a659e45025b8ea4dbd9efa342fa68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e08d5693609a659e45025b8ea4dbd9efa342fa68", "html_url": "https://github.com/rust-lang/rust/commit/e08d5693609a659e45025b8ea4dbd9efa342fa68"}], "stats": {"total": 46, "additions": 35, "deletions": 11}, "files": [{"sha": "736b38370ab87929a5b9b60efec2bf5cd2de4142", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c18646067734f03354daa0d1c568e97433e4ad49/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18646067734f03354daa0d1c568e97433e4ad49/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=c18646067734f03354daa0d1c568e97433e4ad49", "patch": "@@ -645,7 +645,7 @@ impl<T> LinkedList<T> {\n     /// Returns `true` if the `LinkedList` contains an element equal to the\n     /// given value.\n     ///\n-    /// This operation should compute in *O*(*n*) time.\n+    /// This operation should compute linearly in *O*(*n*) time.\n     ///\n     /// # Examples\n     ///\n@@ -1569,7 +1569,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// Appends an element to the front of the cursor's parent list. The node\n     /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     // `push_front` continues to point to \"ghost\" when it addes a node to mimic\n     // the behavior of `insert_before` on an empty list.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n@@ -1584,7 +1584,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// Appends an element to the back of the cursor's parent list. The node\n     /// that the cursor points to is unchanged, even if it is the \"ghost\" node.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn push_back(&mut self, elt: T) {\n         // Safety: We know that `push_back` does not change the position in\n@@ -1603,7 +1603,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// unchanged, unless it was pointing to the front element. In that case, it\n     /// points to the new front element.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn pop_front(&mut self) -> Option<T> {\n         // We can't check if current is empty, we must check the list directly.\n@@ -1630,7 +1630,7 @@ impl<'a, T> CursorMut<'a, T> {\n     /// unchanged, unless it was pointing to the back element. In that case, it\n     /// points to the \"ghost\" element.\n     ///\n-    /// This operation should compute in O(1) time.\n+    /// This operation should compute in *O*(1) time.\n     #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n     pub fn pop_back(&mut self) -> Option<T> {\n         if self.list.is_empty() {"}, {"sha": "33b98389702652fe7807dce988407b7a3210b85e", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c18646067734f03354daa0d1c568e97433e4ad49/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18646067734f03354daa0d1c568e97433e4ad49/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=c18646067734f03354daa0d1c568e97433e4ad49", "patch": "@@ -1322,6 +1322,12 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     /// Returns `true` if the deque contains an element equal to the\n     /// given value.\n     ///\n+    /// This operation is *O*(*n*).\n+    ///\n+    /// Note that if you have a sorted `VecDeque`, [`binary_search`] may be faster.\n+    ///\n+    /// [`binary_search`]: VecDeque::binary_search\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2528,7 +2534,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Binary searches the sorted deque for a given element.\n+    /// Binary searches this `VecDeque` for a given element.\n+    /// This behaves similarly to [`contains`] if this `VecDeque` is sorted.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2538,6 +2545,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: VecDeque::contains\n     /// [`binary_search_by`]: VecDeque::binary_search_by\n     /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n     /// [`partition_point`]: VecDeque::partition_point\n@@ -2581,7 +2589,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         self.binary_search_by(|e| e.cmp(x))\n     }\n \n-    /// Binary searches the sorted deque with a comparator function.\n+    /// Binary searches this `VecDeque` with a comparator function.\n+    /// This behaves similarly to [`contains`] if this `VecDeque` is sorted.\n     ///\n     /// The comparator function should implement an order consistent\n     /// with the sort order of the deque, returning an order code that\n@@ -2596,6 +2605,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: VecDeque::contains\n     /// [`binary_search`]: VecDeque::binary_search\n     /// [`binary_search_by_key`]: VecDeque::binary_search_by_key\n     /// [`partition_point`]: VecDeque::partition_point\n@@ -2634,7 +2644,8 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n-    /// Binary searches the sorted deque with a key extraction function.\n+    /// Binary searches this `VecDeque` with a key extraction function.\n+    /// This behaves similarly to [`contains`] if this `VecDeque` is sorted.\n     ///\n     /// Assumes that the deque is sorted by the key, for instance with\n     /// [`make_contiguous().sort_by_key()`] using the same key extraction function.\n@@ -2647,6 +2658,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///\n+    /// [`contains`]: VecDeque::contains\n     /// [`make_contiguous().sort_by_key()`]: VecDeque::make_contiguous\n     /// [`binary_search`]: VecDeque::binary_search\n     /// [`binary_search_by`]: VecDeque::binary_search_by"}, {"sha": "d68982d18e0312d5f6db1dd31359057e7973ec60", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c18646067734f03354daa0d1c568e97433e4ad49/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c18646067734f03354daa0d1c568e97433e4ad49/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c18646067734f03354daa0d1c568e97433e4ad49", "patch": "@@ -2095,6 +2095,12 @@ impl<T> [T] {\n \n     /// Returns `true` if the slice contains an element with the given value.\n     ///\n+    /// This operation is *O*(*n*).\n+    ///\n+    /// Note that if you have a sorted slice, [`binary_search`] may be faster.\n+    ///\n+    /// [`binary_search`]: slice::binary_search\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2251,7 +2257,8 @@ impl<T> [T] {\n         None\n     }\n \n-    /// Binary searches this sorted slice for a given element.\n+    /// Binary searches this slice for a given element.\n+    /// This behaves similary to [`contains`] if this slice is sorted.\n     ///\n     /// If the value is found then [`Result::Ok`] is returned, containing the\n     /// index of the matching element. If there are multiple matches, then any\n@@ -2263,6 +2270,7 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search_by`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: slice::contains\n     /// [`binary_search_by`]: slice::binary_search_by\n     /// [`binary_search_by_key`]: slice::binary_search_by_key\n     /// [`partition_point`]: slice::partition_point\n@@ -2301,7 +2309,8 @@ impl<T> [T] {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    /// Binary searches this sorted slice with a comparator function.\n+    /// Binary searches this slice with a comparator function.\n+    /// This behaves similarly to [`contains`] if this slice is sorted.\n     ///\n     /// The comparator function should implement an order consistent\n     /// with the sort order of the underlying slice, returning an\n@@ -2318,6 +2327,7 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by_key`], and [`partition_point`].\n     ///\n+    /// [`contains`]: slice::contains\n     /// [`binary_search`]: slice::binary_search\n     /// [`binary_search_by_key`]: slice::binary_search_by_key\n     /// [`partition_point`]: slice::partition_point\n@@ -2376,7 +2386,8 @@ impl<T> [T] {\n         Err(left)\n     }\n \n-    /// Binary searches this sorted slice with a key extraction function.\n+    /// Binary searches this slice with a key extraction function.\n+    /// This behaves similarly to [`contains`] if this slice is sorted.\n     ///\n     /// Assumes that the slice is sorted by the key, for instance with\n     /// [`sort_by_key`] using the same key extraction function.\n@@ -2391,6 +2402,7 @@ impl<T> [T] {\n     ///\n     /// See also [`binary_search`], [`binary_search_by`], and [`partition_point`].\n     ///\n+    /// [`contains`]: slice::contains\n     /// [`sort_by_key`]: slice::sort_by_key\n     /// [`binary_search`]: slice::binary_search\n     /// [`binary_search_by`]: slice::binary_search_by"}]}