{"sha": "a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZjkxYjFiMGUxYjc0ZDMzZDViMjdiMTgxMWY3YWEzOTUzMTQ1NDM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-14T21:51:46Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-10-27T19:14:41Z"}, "message": "Preparations and cleanup\n\nDiagnostics for struct path resolution errors in resolve and typeck are unified.\nSelf type is treated as a type alias in few places (not reachable yet).\nUnsafe cell is seen in constants even through type aliases.\nAll checks for struct paths in typeck work on type level.", "tree": {"sha": "a432018ef91e0eb10bddd4e9d602368c33043d43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a432018ef91e0eb10bddd4e9d602368c33043d43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "html_url": "https://github.com/rust-lang/rust/commit/a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07436946b6ee6345509b73c6e4dafb38b6a243f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07436946b6ee6345509b73c6e4dafb38b6a243f1", "html_url": "https://github.com/rust-lang/rust/commit/07436946b6ee6345509b73c6e4dafb38b6a243f1"}], "stats": {"total": 438, "additions": 232, "deletions": 206}, "files": [{"sha": "c37b6df369dfcf46ef302b40850a8874aecad116", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -1017,7 +1017,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n                 Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) => {\n+                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) | Some(Def::SelfTy(..)) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }"}, {"sha": "96700a8da86a3c1aa36ee8d47b12137044e2e679", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -1698,7 +1698,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         match def {\n             Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) => self.struct_variant(),\n+            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => self.struct_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n     }"}, {"sha": "c0b5969fa95986e10e8a9c14815da177023e2e8a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -14,7 +14,7 @@ use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n-use ty::TyClosure;\n+use ty::{TyClosure, TyProjection, TyAnon};\n use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::fold::{TypeFolder, TypeVisitor};\n@@ -802,6 +802,34 @@ impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> ty::TypeVariants<'tcx> {\n+    pub fn descr(&self) -> &'static str {\n+        match *self {\n+            TyInt(..) | TyUint(..) | TyFloat(..) |\n+            TyBool | TyChar | TyStr => \"builtin type\",\n+            TyRawPtr(..) => \"pointer\",\n+            TyRef(..) => \"reference\",\n+            TyTuple(..) => \"tuple\",\n+            TyFnDef(..) => \"function type\",\n+            TyFnPtr(..) => \"function pointer\",\n+            TyArray(..) => \"array\",\n+            TySlice(..) => \"slice\",\n+            TyParam(..) => \"type parameter\",\n+            TyProjection(..) => \"associated type\",\n+            TyTrait(..) => \"trait type\",\n+            TyClosure(..) => \"closure type\",\n+            TyBox(..) => \"struct\",\n+            TyAdt(def, ..) => match def.adt_kind() {\n+                ty::AdtKind::Struct => \"struct\",\n+                ty::AdtKind::Union => \"union\",\n+                ty::AdtKind::Enum => \"enum\",\n+            },\n+            TyInfer(..) | TyAnon(..) |\n+            TyNever | TyError => \"type\",\n+        }\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -879,8 +907,8 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                 })\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n-            ty::TyProjection(ref data) => write!(f, \"{}\", data),\n-            ty::TyAnon(def_id, substs) => {\n+            TyProjection(ref data) => write!(f, \"{}\", data),\n+            TyAnon(def_id, substs) => {\n                 ty::tls::with(|tcx| {\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id."}, {"sha": "8ad4d7f57a6f0a4505c5116654acfc2b5de07fd3", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -565,9 +565,11 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprStruct(..) => {\n-            // unsafe_cell_type doesn't necessarily exist with no_core\n-            if Some(v.tcx.expect_def(e.id).def_id()) == v.tcx.lang_items.unsafe_cell_type() {\n-                v.add_qualif(ConstQualif::MUTABLE_MEM);\n+            if let ty::TyAdt(adt, ..) = v.tcx.expr_ty(e).sty {\n+                // unsafe_cell_type doesn't necessarily exist with no_core\n+                if Some(adt.did) == v.tcx.lang_items.unsafe_cell_type() {\n+                    v.add_qualif(ConstQualif::MUTABLE_MEM);\n+                }\n             }\n         }\n "}, {"sha": "1fb5db05dd5088e0b7c8f55942f5a3b496537024", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -860,31 +860,6 @@ match (A, B, C) {\n ```\n \"##,\n \n-E0422: r##\"\n-You are trying to use an identifier that is either undefined or not a struct.\n-\n-Erroneous code example:\n-\n-``` compile_fail,E0422\n-fn main () {\n-    let x = Foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `Foo` is undefined, so it inherently isn't anything, and\n-definitely not a struct.\n-\n-```compile_fail,E0422\n-fn main () {\n-    let foo = 1;\n-    let x = foo { x: 1, y: 2 };\n-}\n-```\n-\n-In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n-one.\n-\"##,\n-\n E0423: r##\"\n A `struct` variant name was used like a function name.\n \n@@ -1503,6 +1478,7 @@ register_diagnostics! {\n //  E0419, merged into 531\n //  E0420, merged into 532\n //  E0421, merged into 531\n+//  E0422, merged into 531/532\n     E0531, // unresolved pattern path kind `name`\n     E0532, // expected pattern path kind, found another pattern path kind\n //  E0427, merged into 530"}, {"sha": "d4900be575873f993508b5f0a159fdc9eeca4512", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 35, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -129,8 +129,6 @@ enum ResolutionError<'a> {\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n     IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n-    /// error E0422: does not name a struct\n-    DoesNotNameAStruct(&'a str),\n     /// error E0423: is a struct variant name, but this expression uses it like a function name\n     StructVariantUsedAsFunction(&'a str),\n     /// error E0424: `self` is not available in a static method\n@@ -336,15 +334,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n             err.span_label(span, &format!(\"used in a pattern more than once\"));\n             err\n         }\n-        ResolutionError::DoesNotNameAStruct(name) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0422,\n-                             \"`{}` does not name a structure\",\n-                             name);\n-            err.span_label(span, &format!(\"not a structure\"));\n-            err\n-        }\n         ResolutionError::StructVariantUsedAsFunction(path_name) => {\n             let mut err = struct_span_err!(resolver.session,\n                              span,\n@@ -2383,6 +2372,18 @@ impl<'a> Resolver<'a> {\n         self.record_def(pat_id, resolution);\n     }\n \n+    fn resolve_struct_path(&mut self, node_id: NodeId, path: &Path) {\n+        // Resolution logic is equivalent for expressions and patterns,\n+        // reuse `resolve_pattern_path` for both.\n+        self.resolve_pattern_path(node_id, None, path, TypeNS, |def| {\n+            match def {\n+                Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => true,\n+                _ => false,\n+            }\n+        }, \"struct, variant or union type\");\n+    }\n+\n     fn resolve_pattern(&mut self,\n                        pat: &Pat,\n                        pat_src: PatternSource,\n@@ -2460,13 +2461,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 PatKind::Struct(ref path, ..) => {\n-                    self.resolve_pattern_path(pat.id, None, path, TypeNS, |def| {\n-                        match def {\n-                            Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n-                            Def::TyAlias(..) | Def::AssociatedTy(..) => true,\n-                            _ => false,\n-                        }\n-                    }, \"variant, struct or type alias\");\n+                    self.resolve_struct_path(pat.id, path);\n                 }\n \n                 _ => {}\n@@ -3024,23 +3019,7 @@ impl<'a> Resolver<'a> {\n             }\n \n             ExprKind::Struct(ref path, ..) => {\n-                // Resolve the path to the structure it goes to. We don't\n-                // check to ensure that the path is actually a structure; that\n-                // is checked later during typeck.\n-                match self.resolve_path(expr.id, path, 0, TypeNS) {\n-                    Ok(definition) => self.record_def(expr.id, definition),\n-                    Err(true) => self.record_def(expr.id, err_path_resolution()),\n-                    Err(false) => {\n-                        debug!(\"(resolving expression) didn't find struct def\",);\n-\n-                        resolve_error(self,\n-                                      path.span,\n-                                      ResolutionError::DoesNotNameAStruct(\n-                                                                &path_names_to_string(path, 0))\n-                                     );\n-                        self.record_def(expr.id, err_path_resolution());\n-                    }\n-                }\n+                self.resolve_struct_path(expr.id, path);\n \n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "53a5f3193231d9b600d3dccccb4b23cc4bef2176", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -1493,7 +1493,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                 Def::StructCtor(..) | Def::VariantCtor(..) |\n                 Def::Const(..) | Def::AssociatedConst(..) |\n                 Def::Struct(..) | Def::Variant(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) => {\n+                Def::TyAlias(..) | Def::AssociatedTy(..) |\n+                Def::SelfTy(..) => {\n                     paths_to_process.push((id, p.clone(), Some(ref_kind)))\n                 }\n                 def => error!(\"unexpected definition kind when processing collected paths: {:?}\","}, {"sha": "0c71b0424ae6d08cf40ec37493c640bc64a97ab9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -1484,7 +1484,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                       def: Def,\n                       opt_self_ty: Option<Ty<'tcx>>,\n                       base_path_ref_id: ast::NodeId,\n-                      base_segments: &[hir::PathSegment])\n+                      base_segments: &[hir::PathSegment],\n+                      permit_variants: bool)\n                       -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -1515,6 +1516,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                     did,\n                                     base_segments.last().unwrap())\n             }\n+            Def::Variant(did) if permit_variants => {\n+                // Convert \"variant type\" as if it were a real type.\n+                // The resulting `Ty` is type of the variant's enum for now.\n+                tcx.prohibit_type_params(base_segments.split_last().unwrap().1);\n+                let mut ty = self.ast_path_to_ty(rscope,\n+                                                 span,\n+                                                 param_mode,\n+                                                 tcx.parent_def_id(did).unwrap(),\n+                                                 base_segments.last().unwrap());\n+                if ty.is_fn() {\n+                    // Tuple variants have fn type even in type namespace,\n+                    // extract true variant type from it.\n+                    ty = tcx.no_late_bound_regions(&ty.fn_ret()).unwrap();\n+                }\n+                ty\n+            }\n             Def::TyParam(did) => {\n                 tcx.prohibit_type_params(base_segments);\n \n@@ -1604,7 +1621,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                       opt_self_ty: Option<Ty<'tcx>>,\n                                       base_path_ref_id: ast::NodeId,\n                                       base_segments: &[hir::PathSegment],\n-                                      assoc_segments: &[hir::PathSegment])\n+                                      assoc_segments: &[hir::PathSegment],\n+                                      permit_variants: bool)\n                                       -> (Ty<'tcx>, Def) {\n         // Convert the base type.\n         debug!(\"finish_resolving_def_to_ty(base_def={:?}, \\\n@@ -1619,7 +1637,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                           base_def,\n                                           opt_self_ty,\n                                           base_path_ref_id,\n-                                          base_segments);\n+                                          base_segments,\n+                                          permit_variants);\n         debug!(\"finish_resolving_def_to_ty: base_def_to_ty returned {:?}\", base_ty);\n \n         // If any associated type segments remain, attempt to resolve them.\n@@ -1775,7 +1794,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                                                 opt_self_ty,\n                                                                 ast_ty.id,\n                                                                 &path.segments[..base_ty_end],\n-                                                                &path.segments[base_ty_end..]);\n+                                                                &path.segments[base_ty_end..],\n+                                                                false);\n \n                 // Write back the new resolution.\n                 if path_res.depth != 0 {"}, {"sha": "c842514227ca090b50b19ed6abc854a7189e3035", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -489,8 +489,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         expected: Ty<'tcx>) -> Ty<'tcx>\n     {\n         // Resolve the path and check the definition for errors.\n-        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id,\n-                                                                                 pat.span) {\n+        let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(path, pat.id) {\n             variant_ty\n         } else {\n             for field in fields {"}, {"sha": "1c29867bfb8fa603ce371e6362ca7b3dda19ce42", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 54, "deletions": 83, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -1686,41 +1686,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        cause)\n     }\n \n-    /// Instantiates the type in `did` with the generics in `path` and returns\n-    /// it (registering the necessary trait obligations along the way).\n-    ///\n-    /// Note that this function is only intended to be used with type-paths,\n-    /// not with value-paths.\n-    pub fn instantiate_type_path(&self,\n-                                 did: DefId,\n-                                 path: &hir::Path,\n-                                 node_id: ast::NodeId)\n-                                 -> Ty<'tcx> {\n-        debug!(\"instantiate_type_path(did={:?}, path={:?})\", did, path);\n-        let mut ty = self.tcx.lookup_item_type(did).ty;\n-        if ty.is_fn() {\n-            // Tuple variants have fn type even in type namespace, extract true variant type from it\n-            ty = self.tcx.no_late_bound_regions(&ty.fn_ret()).unwrap();\n-        }\n-        let type_predicates = self.tcx.lookup_predicates(did);\n-        let substs = AstConv::ast_path_substs_for_ty(self, self,\n-                                                     path.span,\n-                                                     PathParamMode::Optional,\n-                                                     did,\n-                                                     path.segments.last().unwrap());\n-        debug!(\"instantiate_type_path: ty={:?} substs={:?}\", ty, substs);\n-        let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n-        let cause = traits::ObligationCause::new(path.span, self.body_id,\n-                                                 traits::ItemObligation(did));\n-        self.add_obligations_for_parameters(cause, &bounds);\n-\n-        let ty_substituted = self.instantiate_type_scheme(path.span, substs, &ty);\n-        self.write_substs(node_id, ty::ItemSubsts {\n-            substs: substs\n-        });\n-        ty_substituted\n-    }\n-\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx.mk_nil());\n     }\n@@ -3252,46 +3217,56 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_struct_path(&self,\n                          path: &hir::Path,\n-                         node_id: ast::NodeId,\n-                         span: Span)\n+                         node_id: ast::NodeId)\n                          -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n-        let def = self.finish_resolving_struct_path(path, node_id, span);\n+        let (def, ty) = self.finish_resolving_struct_path(path, node_id);\n         let variant = match def {\n             Def::Err => {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(did) => {\n-                let type_did = self.tcx.parent_def_id(did).unwrap();\n-                Some((type_did, self.tcx.expect_variant_def(def)))\n-            }\n-            Def::Struct(type_did) | Def::Union(type_did) => {\n-                Some((type_did, self.tcx.expect_variant_def(def)))\n+            Def::Variant(..) => {\n+                match ty.sty {\n+                    ty::TyAdt(adt, substs) => {\n+                        Some((adt.variant_of_def(def), adt.did, substs))\n+                    }\n+                    _ => bug!(\"unexpected type: {:?}\", ty.sty)\n+                }\n             }\n-            Def::TyAlias(did) | Def::AssociatedTy(did) => {\n-                match self.tcx.opt_lookup_item_type(did).map(|scheme| &scheme.ty.sty) {\n-                    Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => {\n-                        Some((did, adt.struct_variant()))\n+            Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n+            Def::AssociatedTy(..) => {\n+                match ty.sty {\n+                    ty::TyAdt(adt, substs) if !adt.is_enum() => {\n+                        Some((adt.struct_variant(), adt.did, substs))\n                     }\n                     _ => None,\n                 }\n             }\n-            _ => None\n+            // Self is not supported yet.\n+            Def::SelfTy(..) => None,\n+            _ => bug!(\"unexpected definition: {:?}\", def)\n         };\n \n-        if let Some((def_id, variant)) = variant {\n+        if let Some((variant, did, substs)) = variant {\n             if variant.ctor_kind == CtorKind::Fn &&\n                     !self.tcx.sess.features.borrow().relaxed_adts {\n                 emit_feature_err(&self.tcx.sess.parse_sess,\n-                                 \"relaxed_adts\", span, GateIssue::Language,\n+                                 \"relaxed_adts\", path.span, GateIssue::Language,\n                                  \"tuple structs and variants in struct patterns are unstable\");\n             }\n-            let ty = self.instantiate_type_path(def_id, path, node_id);\n+\n+            // Check bounds on type arguments used in the path.\n+            let type_predicates = self.tcx.lookup_predicates(did);\n+            let bounds = self.instantiate_bounds(path.span, substs, &type_predicates);\n+            let cause = traits::ObligationCause::new(path.span, self.body_id,\n+                                                     traits::ItemObligation(did));\n+            self.add_obligations_for_parameters(cause, &bounds);\n+\n             Some((variant, ty))\n         } else {\n             struct_span_err!(self.tcx.sess, path.span, E0071,\n-                             \"`{}` does not name a struct or a struct variant\",\n-                             pprust::path_to_string(path))\n+                             \"expected struct, variant or union type, found {} `{}`\",\n+                             ty.sty.descr(), ty)\n                 .span_label(path.span, &format!(\"not a struct\"))\n                 .emit();\n             None\n@@ -3305,12 +3280,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n-        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n-                                                                                    expr.span) {\n+        let (variant, struct_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id) {\n             variant_ty\n         } else {\n             self.check_struct_fields_on_error(fields, base_expr);\n-            return self.tcx().types.err;\n+            return self.tcx.types.err;\n         };\n \n         self.check_expr_struct_fields(struct_ty, path.span, variant, fields,\n@@ -3805,7 +3779,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               }\n                           }\n                           err.emit();\n-                          self.tcx().types.err\n+                          self.tcx.types.err\n                       }\n                   }\n               }\n@@ -3815,29 +3789,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n     // The newly resolved definition is written into `def_map`.\n-    pub fn finish_resolving_struct_path(&self,\n-                                        path: &hir::Path,\n-                                        node_id: ast::NodeId,\n-                                        span: Span)\n-                                        -> Def\n+    fn finish_resolving_struct_path(&self,\n+                                    path: &hir::Path,\n+                                    node_id: ast::NodeId)\n+                                    -> (Def, Ty<'tcx>)\n     {\n-        let path_res = self.tcx().expect_resolution(node_id);\n-        if path_res.depth == 0 {\n-            // If fully resolved already, we don't have to do anything.\n-            path_res.base_def\n-        } else {\n-            let base_ty_end = path.segments.len() - path_res.depth;\n-            let (_ty, def) = AstConv::finish_resolving_def_to_ty(self, self, span,\n-                                                                 PathParamMode::Optional,\n-                                                                 path_res.base_def,\n-                                                                 None,\n-                                                                 node_id,\n-                                                                 &path.segments[..base_ty_end],\n-                                                                 &path.segments[base_ty_end..]);\n-            // Write back the new resolution.\n-            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n-            def\n+        let path_res = self.tcx.expect_resolution(node_id);\n+        let base_ty_end = path.segments.len() - path_res.depth;\n+        let (ty, def) = AstConv::finish_resolving_def_to_ty(self, self, path.span,\n+                                                            PathParamMode::Optional,\n+                                                            path_res.base_def,\n+                                                            None,\n+                                                            node_id,\n+                                                            &path.segments[..base_ty_end],\n+                                                            &path.segments[base_ty_end..],\n+                                                            true);\n+        // Write back the new resolution.\n+        if path_res.depth != 0 {\n+            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n         }\n+        (def, ty)\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n@@ -3849,7 +3820,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let path_res = self.tcx().expect_resolution(node_id);\n+        let path_res = self.tcx.expect_resolution(node_id);\n         if path_res.depth == 0 {\n             // If fully resolved already, we don't have to do anything.\n             (path_res.base_def, opt_self_ty, &path.segments)\n@@ -3863,7 +3834,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                  opt_self_ty,\n                                                                  node_id,\n                                                                  &ty_segments[..base_ty_end],\n-                                                                 &ty_segments[base_ty_end..]);\n+                                                                 &ty_segments[base_ty_end..],\n+                                                                 false);\n \n             // Resolve an associated constant or method on the previously resolved type.\n             let item_segment = path.segments.last().unwrap();\n@@ -3883,7 +3855,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             // Write back the new resolution.\n-            self.tcx().def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+            self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n             (def, Some(ty), slice::ref_slice(item_segment))\n         }\n     }\n@@ -4308,7 +4280,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // the referenced item.\n         let ty_substituted = self.instantiate_type_scheme(span, &substs, &scheme.ty);\n \n-\n         if let Some((ty::ImplContainer(impl_def_id), self_ty)) = ufcs_associated {\n             // In the case of `Foo<T>::method` and `<Foo<T>>::method`, if `method`\n             // is inherent, there is no `Self` parameter, instead, the impl needs"}, {"sha": "7dd850180d44206ffd167ee32ff6ee6558867274", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -895,17 +895,14 @@ fn some_func(x: &mut i32) {\n \n E0071: r##\"\n You tried to use structure-literal syntax to create an item that is\n-not a struct-style structure or enum variant.\n+not a structure or enum variant.\n \n Example of erroneous code:\n \n ```compile_fail,E0071\n-enum Foo { FirstValue(i32) };\n-\n-let u = Foo::FirstValue { value: 0 }; // error: Foo::FirstValue\n-                                         // isn't a structure!\n-// or even simpler, if the name doesn't refer to a structure at all.\n-let t = u32 { value: 4 }; // error: `u32` does not name a structure.\n+type U32 = u32;\n+let t = U32 { value: 4 }; // error: expected struct, variant or union type,\n+                          // found builtin type `u32`\n ```\n \n To fix this, ensure that the name was correctly spelled, and that"}, {"sha": "95af37605441da366b6a6ada5171c7fe024ffef2", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -15,6 +15,6 @@ pub use use_from_trait_xc::Trait;\n \n fn main() {\n     match () {\n-        Trait { x: 42 } => () //~ ERROR expected variant, struct or type alias, found trait `Trait`\n+        Trait { x: 42 } => () //~ ERROR expected struct, variant or union type, found trait `Trait`\n     }\n }"}, {"sha": "95653ae83e7cd6080fcd0142a727db746168d51c", "filename": "src/test/compile-fail/E0071.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2FE0071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2FE0071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0071.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n enum Foo {}\n+type FooAlias = Foo;\n \n fn main() {\n-    let u = Foo { value: 0 };\n-    //~^ ERROR `Foo` does not name a struct or a struct variant [E0071]\n-    //~| NOTE not a struct\n-\n-    let t = u32 { value: 4 };\n-    //~^ ERROR `u32` does not name a struct or a struct variant [E0071]\n+    let u = FooAlias { value: 0 };\n+    //~^ ERROR expected struct, variant or union type, found enum `Foo` [E0071]\n     //~| NOTE not a struct\n }"}, {"sha": "02939565f69cd0417b160218761931fab61a05f7", "filename": "src/test/compile-fail/enums-are-namespaced-xc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fenums-are-namespaced-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fenums-are-namespaced-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenums-are-namespaced-xc.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -14,5 +14,6 @@ extern crate namespaced_enums;\n fn main() {\n     let _ = namespaced_enums::A; //~ ERROR unresolved name\n     let _ = namespaced_enums::B(10); //~ ERROR unresolved name\n-    let _ = namespaced_enums::C { a: 10 }; //~ ERROR does not name a structure\n+    let _ = namespaced_enums::C { a: 10 };\n+    //~^ ERROR unresolved struct, variant or union type `namespaced_enums::C`\n }"}, {"sha": "92c1e4b5f5060810c5bb8da8e6cd39b8d7baa19f", "filename": "src/test/compile-fail/issue-16058.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16058.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -16,7 +16,7 @@ pub struct GslResult {\n \n impl GslResult {\n     pub fn new() -> GslResult {\n-        Result { //~ ERROR: `Result` does not name a struct or a struct variant\n+        Result { //~ ERROR: expected struct, variant or union type, found enum `Result`\n             val: 0f64,\n             err: 0f64\n         }"}, {"sha": "413e8b464fff78a2aacbe103f7e0651f970407d2", "filename": "src/test/compile-fail/issue-17001.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17001.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -11,5 +11,5 @@\n mod foo {}\n \n fn main() {\n-    let p = foo { x: () }; //~ ERROR `foo` does not name a struct or a struct variant\n+    let p = foo { x: () }; //~ ERROR expected struct, variant or union type, found module `foo`\n }"}, {"sha": "5a6bd5ed588a676d6ecfcecc944f9c10970c209c", "filename": "src/test/compile-fail/issue-17405.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17405.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -14,6 +14,6 @@ enum Foo {\n \n fn main() {\n     match Foo::Bar(1) {\n-        Foo { i } => () //~ ERROR expected variant, struct or type alias, found enum `Foo`\n+        Foo { i } => () //~ ERROR expected struct, variant or union type, found enum `Foo`\n     }\n }"}, {"sha": "2113e38c45cc38aab2c7e1bf9413ef63ad08d00f", "filename": "src/test/compile-fail/issue-17518.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-17518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-17518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17518.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -13,5 +13,5 @@ enum SomeEnum {\n }\n \n fn main() {\n-    E { name: \"foobar\" }; //~ ERROR `E` does not name a structure\n+    E { name: \"foobar\" }; //~ ERROR unresolved struct, variant or union type `E`\n }"}, {"sha": "cc44cf88f09bd97b0d5364052265657c3f89e2d7", "filename": "src/test/compile-fail/issue-21449.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21449.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -11,5 +11,6 @@\n mod MyMod {}\n \n fn main() {\n-    let myVar = MyMod { T: 0 }; //~ ERROR `MyMod` does not name a struct or a struct variant\n+    let myVar = MyMod { T: 0 };\n+    //~^ ERROR expected struct, variant or union type, found module `MyMod`\n }"}, {"sha": "8be3d88bd5c8f5bcfdbbf24fd16d895ed77f411a", "filename": "src/test/compile-fail/issue-26459.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26459.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -11,6 +11,6 @@\n fn main() {\n     match 'a' {\n         char{ch} => true\n-        //~^ ERROR expected variant, struct or type alias, found builtin type `char`\n+        //~^ ERROR expected struct, variant or union type, found builtin type `char`\n     };\n }"}, {"sha": "d9840abf0ca77a371182b9f69e33e4f67251fbe5", "filename": "src/test/compile-fail/issue-27815.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -11,12 +11,12 @@\n mod A {}\n \n fn main() {\n-    let u = A { x: 1 }; //~ ERROR `A` does not name a struct or a struct variant\n-    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a struct or a struct variant\n+    let u = A { x: 1 }; //~ ERROR expected struct, variant or union type, found module `A`\n+    let v = u32 { x: 1 }; //~ ERROR expected struct, variant or union type, found builtin type `u32`\n     match () {\n         A { x: 1 } => {}\n-        //~^ ERROR expected variant, struct or type alias, found module `A`\n+        //~^ ERROR expected struct, variant or union type, found module `A`\n         u32 { x: 1 } => {}\n-        //~^ ERROR expected variant, struct or type alias, found builtin type `u32`\n+        //~^ ERROR expected struct, variant or union type, found builtin type `u32`\n     }\n }"}, {"sha": "1ab59e790d7ee5975a6a41524625763b08c24930", "filename": "src/test/compile-fail/lexical-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flexical-scopes.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -10,7 +10,7 @@\n \n struct T { i: i32 }\n fn f<T>() {\n-    let t = T { i: 0 }; //~ ERROR `T` does not name a struct or a struct variant\n+    let t = T { i: 0 }; //~ ERROR expected struct, variant or union type, found type parameter `T`\n }\n \n mod Foo {"}, {"sha": "1b6e51e37034e5be42d59d1609769f5ae592b85f", "filename": "src/test/compile-fail/struct-path-alias-bounds.rs", "status": "renamed", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fstruct-path-alias-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fstruct-path-alias-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-alias-bounds.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main () {\n-    let x = Foo { x: 1, y: 2 };\n-    //~^ ERROR E0422\n-    //~| NOTE not a structure\n+// issue #36286\n+\n+struct S<T: Clone> { a: T }\n+\n+struct NoClone;\n+type A = S<NoClone>;\n+\n+fn main() {\n+    let s = A { a: NoClone };\n+    //~^ ERROR the trait bound `NoClone: std::clone::Clone` is not satisfied\n }", "previous_filename": "src/test/compile-fail/E0422.rs"}, {"sha": "2f7330cb391b252b0136109049ed4e961226479f", "filename": "src/test/compile-fail/struct-path-associated-type.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-path-associated-type.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+trait Tr {\n+    type A;\n+}\n+\n+impl Tr for S {\n+    type A = S;\n+}\n+\n+fn f<T: Tr>() {\n+    let s = T::A {};\n+    //~^ ERROR expected struct, variant or union type, found associated type `<T as Tr>::A`\n+    let z = T::A::<u8> {};\n+    //~^ ERROR expected struct, variant or union type, found associated type `<T as Tr>::A`\n+    //~| ERROR type parameters are not allowed on this type\n+    match S {\n+        T::A {} => {}\n+        //~^ ERROR expected struct, variant or union type, found associated type `<T as Tr>::A`\n+    }\n+}\n+\n+fn g<T: Tr<A = S>>() {\n+    let s = T::A {}; // OK\n+    let z = T::A::<u8> {}; //~ ERROR type parameters are not allowed on this type\n+    match S {\n+        T::A {} => {} // OK\n+    }\n+}\n+\n+fn main() {\n+    let s = S::A {}; //~ ERROR ambiguous associated type\n+    let z = S::A::<u8> {}; //~ ERROR ambiguous associated type\n+    //~^ ERROR type parameters are not allowed on this type\n+    match S {\n+        S::A {} => {} //~ ERROR ambiguous associated type\n+    }\n+}"}, {"sha": "49d58580da52ddb34f353c6b7df55e0ed655865d", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -12,6 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: `TraitNotAStruct` does not name a struct or a struct variant [E0071]\n-    //~| NOTE not a struct\n+    //~^ ERROR expected struct, variant or union type, found trait `TraitNotAStruct`\n }"}, {"sha": "fd9eb1f87c7433bee6b9bad525cfce1b06f65327", "filename": "src/test/run-pass/issue-22546.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Frun-pass%2Fissue-22546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Frun-pass%2Fissue-22546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22546.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -51,4 +51,7 @@ fn main() {\n     if let None::<u8> = Some(8) {\n         panic!();\n     }\n+    if let None::<u8> { .. } = Some(8) {\n+        panic!();\n+    }\n }"}, {"sha": "b033ed5c802100f51c53096bbccdb43e5c00d84a", "filename": "src/test/run-pass/struct-path-associated-type.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f91b1b0e1b74d33d5b27b1811f7aa395314543/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-path-associated-type.rs?ref=a9f91b1b0e1b74d33d5b27b1811f7aa395314543", "patch": "@@ -8,30 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S;\n+struct S<T, U = u16> {\n+    a: T,\n+    b: U,\n+}\n \n trait Tr {\n     type A;\n }\n-\n-impl Tr for S {\n-    type A = S;\n-}\n-\n-fn f<T: Tr>() {\n-    match S {\n-        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n-    }\n+impl Tr for u8 {\n+    type A = S<u8, u16>;\n }\n \n-fn g<T: Tr<A = S>>() {\n-    match S {\n-        T::A {} => {} //~ ERROR `T::A` does not name a struct or a struct variant\n+fn f<T: Tr<A = S<u8>>>() {\n+    let s = T::A { a: 0, b: 1 };\n+    match s {\n+        T::A { a, b } => {\n+            assert_eq!(a, 0);\n+            assert_eq!(b, 1);\n+        }\n     }\n }\n \n fn main() {\n-    match S {\n-        S::A {} => {} //~ ERROR ambiguous associated type\n-    }\n+    f::<u8>();\n }", "previous_filename": "src/test/compile-fail/struct-pat-associated-path.rs"}]}