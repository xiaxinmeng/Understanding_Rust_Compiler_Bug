{"sha": "213a25d975e06fcba28c2e6aab829ef9f16617cf", "node_id": "C_kwDOAAsO6NoAKDIxM2EyNWQ5NzVlMDZmY2JhMjhjMmU2YWFiODI5ZWY5ZjE2NjE3Y2Y", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-16T02:58:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-18T17:57:35Z"}, "message": "interpret: make some large types not Copy", "tree": {"sha": "2932efefa2d3fbac1fcbd4c81deb2b1970e95d62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2932efefa2d3fbac1fcbd4c81deb2b1970e95d62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/213a25d975e06fcba28c2e6aab829ef9f16617cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/213a25d975e06fcba28c2e6aab829ef9f16617cf", "html_url": "https://github.com/rust-lang/rust/commit/213a25d975e06fcba28c2e6aab829ef9f16617cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/213a25d975e06fcba28c2e6aab829ef9f16617cf/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "388971b05d84b81592a818d7e789eb5684755131", "url": "https://api.github.com/repos/rust-lang/rust/commits/388971b05d84b81592a818d7e789eb5684755131", "html_url": "https://github.com/rust-lang/rust/commit/388971b05d84b81592a818d7e789eb5684755131"}], "stats": {"total": 84, "additions": 45, "deletions": 39}, "files": [{"sha": "6feb5219ab1f9cb06e0d348ba33fd36f9fa24c61", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -674,7 +674,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             body,\n             loc: Err(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n-            return_place: *return_place,\n+            return_place: return_place.clone(),\n             // empty local array, we fill it in below, after we are inside the stack frame and\n             // all methods actually know about the frame\n             locals: IndexVec::new(),\n@@ -795,7 +795,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let op = self\n                 .local_to_op(self.frame(), mir::RETURN_PLACE, None)\n                 .expect(\"return place should always be live\");\n-            let dest = self.frame().return_place;\n+            let dest = self.frame().return_place.clone();\n             let err = self.copy_op(&op, &dest, /*allow_transmute*/ true);\n             trace!(\"return value: {:?}\", self.dump_place(*dest));\n             // We delay actually short-circuiting on this error until *after* the stack frame is"}, {"sha": "f8613965f4668377cb3639926ed600433952c8e7", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -457,8 +457,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 for i in 0..dest_len {\n                     let place = self.mplace_index(&dest, i)?;\n-                    let value =\n-                        if i == index { *elem } else { self.mplace_index(&input, i)?.into() };\n+                    let value = if i == index {\n+                        elem.clone()\n+                    } else {\n+                        self.mplace_index(&input, i)?.into()\n+                    };\n                     self.copy_op(&value, &place.into(), /*allow_transmute*/ false)?;\n                 }\n             }"}, {"sha": "de6eb1c03361bfd0c4fcd9c160e21d7d144cf3df", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -111,7 +111,7 @@ impl<'tcx, Tag: Provenance> Immediate<Tag> {\n \n // ScalarPair needs a type to interpret, so we often have an immediate and a type together\n // as input for binary and cast operations.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct ImmTy<'tcx, Tag: Provenance = AllocId> {\n     imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n@@ -187,7 +187,10 @@ pub enum Operand<Tag: Provenance = AllocId> {\n     Indirect(MemPlace<Tag>),\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(Operand, 64);\n+\n+#[derive(Clone, Debug)]\n pub struct OpTy<'tcx, Tag: Provenance = AllocId> {\n     op: Operand<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,"}, {"sha": "bc71bfe4327d4ae16adcfa3def7c441fce73e866", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -59,6 +59,21 @@ pub struct MemPlace<Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(MemPlace, 40);\n \n+/// A MemPlace with its layout. Constructing it is only possible in this module.\n+#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n+pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n+    mplace: MemPlace<Tag>,\n+    pub layout: TyAndLayout<'tcx>,\n+    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n+    /// it needs to have a different alignment than the field type would usually have.\n+    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n+    /// This means `layout.align` should never be used for a `MPlaceTy`!\n+    pub align: Align,\n+}\n+\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n+\n #[derive(Copy, Clone, Debug)]\n pub enum Place<Tag: Provenance = AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n@@ -72,7 +87,7 @@ pub enum Place<Tag: Provenance = AllocId> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Place, 48);\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Clone, Debug)]\n pub struct PlaceTy<'tcx, Tag: Provenance = AllocId> {\n     place: Place<Tag>, // Keep this private; it helps enforce invariants.\n     pub layout: TyAndLayout<'tcx>,\n@@ -94,21 +109,6 @@ impl<'tcx, Tag: Provenance> std::ops::Deref for PlaceTy<'tcx, Tag> {\n     }\n }\n \n-/// A MemPlace with its layout. Constructing it is only possible in this module.\n-#[derive(Copy, Clone, Hash, Eq, PartialEq, Debug)]\n-pub struct MPlaceTy<'tcx, Tag: Provenance = AllocId> {\n-    mplace: MemPlace<Tag>,\n-    pub layout: TyAndLayout<'tcx>,\n-    /// rustc does not have a proper way to represent the type of a field of a `repr(packed)` struct:\n-    /// it needs to have a different alignment than the field type would usually have.\n-    /// So we represent this here with a separate field that \"overwrites\" `layout.align`.\n-    /// This means `layout.align` should never be used for a `MPlaceTy`!\n-    pub align: Align,\n-}\n-\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(MPlaceTy<'_>, 64);\n-\n impl<'tcx, Tag: Provenance> std::ops::Deref for MPlaceTy<'tcx, Tag> {\n     type Target = MemPlace<Tag>;\n     #[inline(always)]"}, {"sha": "4e69d71dc00ec6c1370c9426e867540074c65bc0", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -157,7 +157,7 @@ where\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n-        let mut base = *base;\n+        let mut base = base.clone();\n         base.layout = base.layout.for_variant(self, variant);\n         Ok(base)\n     }\n@@ -168,7 +168,7 @@ where\n         variant: VariantIdx,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         // Downcast just changes the layout\n-        let mut base = *base;\n+        let mut base = base.clone();\n         base.layout = base.layout.for_variant(self, variant);\n         Ok(base)\n     }\n@@ -350,7 +350,7 @@ where\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             OpaqueCast(ty) => {\n-                let mut place = *base;\n+                let mut place = base.clone();\n                 place.layout = self.layout_of(ty)?;\n                 place\n             }\n@@ -379,7 +379,7 @@ where\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n             OpaqueCast(ty) => {\n-                let mut op = *base;\n+                let mut op = base.clone();\n                 op.layout = self.layout_of(ty)?;\n                 op\n             }"}, {"sha": "d0c9b5319ddc1092c2138c6639744e23b3ef11ff", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -444,7 +444,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             trace!(\"eval_fn_call: Will pass last argument by untupling\");\n                             Cow::from(\n                                 args.iter()\n-                                    .map(|&a| Ok(a))\n+                                    .map(|a| Ok(a.clone()))\n                                     .chain(\n                                         (0..untuple_arg.layout.fields.count())\n                                             .map(|i| self.operand_field(untuple_arg, i)),\n@@ -525,7 +525,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // We have to implement all \"object safe receivers\". So we have to go search for a\n                 // pointer or `dyn Trait` type, but it could be wrapped in newtypes. So recursively\n                 // unwrap those newtypes until we are there.\n-                let mut receiver = args[0];\n+                let mut receiver = args[0].clone();\n                 let receiver_place = loop {\n                     match receiver.layout.ty.kind() {\n                         ty::Ref(..) | ty::RawPtr(..) => break self.deref_operand(&receiver)?,"}, {"sha": "6ad669b12c196d0220decb3c27ea86f38b3ea594", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -13,7 +13,7 @@ use super::{InterpCx, MPlaceTy, Machine, OpTy, PlaceTy};\n /// A thing that we can project into, and that has a layout.\n /// This wouldn't have to depend on `Machine` but with the current type inference,\n /// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n+pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n@@ -54,7 +54,7 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n /// A thing that we can project into given *mutable* access to `ecx`, and that has a layout.\n /// This wouldn't have to depend on `Machine` but with the current type inference,\n /// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n-pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n+pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Sized {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n@@ -106,12 +106,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(*self)\n+        Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n-        *op\n+        op.clone()\n     }\n \n     #[inline(always)]\n@@ -146,20 +146,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(*self)\n+        Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn to_op_for_proj(\n         &self,\n         _ecx: &mut InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n-        Ok(*self)\n+        Ok(self.clone())\n     }\n \n     #[inline(always)]\n     fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n-        *op\n+        op.clone()\n     }\n \n     #[inline(always)]"}, {"sha": "2fd026b1bcaf68f7fc93201f92f0fe0baefac28e", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -516,7 +516,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n-            let r = r?;\n+            let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n             let left_ty = left.ty(self.local_decls, self.tcx);"}, {"sha": "9c843f11c1ed13e5ddd04940733954ee99438055", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/213a25d975e06fcba28c2e6aab829ef9f16617cf/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=213a25d975e06fcba28c2e6aab829ef9f16617cf", "patch": "@@ -584,7 +584,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         });\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n-            let r = r?;\n+            let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n             let left_ty = left.ty(self.local_decls, self.tcx);\n@@ -616,10 +616,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        if let (Some(l), Some(r)) = (&l, &r) {\n+        if let (Some(l), Some(r)) = (l, r) {\n             // The remaining operators are handled through `overflowing_binary_op`.\n             if self.use_ecx(source_info, |this| {\n-                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, &l, &r)?;\n                 Ok(overflow)\n             })? {\n                 self.report_assert_as_lint("}]}