{"sha": "647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0N2U1NGQ2ZDE1NGUxYTI2N2U4NGM4YWU5ZjEzMTVlM2Y5YjkzZmM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-27T21:57:43Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-27T21:57:43Z"}, "message": "Fallout of changing format_args!(f, args) to f(format_args!(args)).", "tree": {"sha": "a25d8f7f938435e2dfcb2056353cbd4c3c3d8a55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a25d8f7f938435e2dfcb2056353cbd4c3c3d8a55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "comment_count": 12, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "html_url": "https://github.com/rust-lang/rust/commit/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "html_url": "https://github.com/rust-lang/rust/commit/fc3f22bf2510dacb1fc4f5422b025a51bfda410e"}], "stats": {"total": 718, "additions": 627, "deletions": 91}, "files": [{"sha": "9460b9a8966468f40dccd332fa2c25c0f8178624", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -945,6 +945,15 @@ pub trait ToString {\n }\n \n impl<T: fmt::Show> ToString for T {\n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    fn to_string(&self) -> String {\n+        let mut buf = Vec::<u8>::new();\n+        let _ = fmt::write(&mut buf, format_args!(\"{}\", *self));\n+        String::from_utf8(buf).unwrap()\n+    }\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     fn to_string(&self) -> String {\n         let mut buf = Vec::<u8>::new();\n         let _ = format_args!(|args| fmt::write(&mut buf, args), \"{}\", self);"}, {"sha": "47701ab8ffd638ce7db4a52ec1ff042430b0fcae", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -325,6 +325,13 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             let mut filler = Filler { buf: &mut buf, end: &mut end };\n             match sign {\n+                // NOTE(stage0): Remove cfg after a snapshot\n+                #[cfg(not(stage0))]\n+                SignNeg => {\n+                    let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n+                }\n+                // NOTE(stage0): Remove match arm after a snapshot\n+                #[cfg(stage0)]\n                 SignNeg => {\n                     let _ = format_args!(|args| {\n                         fmt::write(&mut filler, args)"}, {"sha": "b050b98de2f81ac60f193416c4b0485a055f4acc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -70,6 +70,16 @@ pub trait FormatWriter {\n     /// This function will return an instance of `FormatError` on error.\n     fn write(&mut self, bytes: &[u8]) -> Result;\n \n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    /// Glue for usage of the `write!` macro with implementers of this trait.\n+    ///\n+    /// This method should generally not be invoked manually, but rather through\n+    /// the `write!` macro itself.\n+    fn write_fmt(&mut self, args: Arguments) -> Result { write(self, args) }\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     /// Glue for usage of the `write!` macro with implementers of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n@@ -180,6 +190,7 @@ impl<'a> Arguments<'a> {\n /// macro validates the format string at compile-time so usage of the `write`\n /// and `format` functions can be safely performed.\n #[stable]\n+#[deriving(Copy)]\n pub struct Arguments<'a> {\n     // Format string pieces to print.\n     pieces: &'a [&'a str],\n@@ -193,6 +204,14 @@ pub struct Arguments<'a> {\n }\n \n impl<'a> Show for Arguments<'a> {\n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    fn fmt(&self, fmt: &mut Formatter) -> Result {\n+        write(fmt.buf, *self)\n+    }\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, self)\n     }\n@@ -268,6 +287,63 @@ static DEFAULT_ARGUMENT: rt::Argument<'static> = rt::Argument {\n     }\n };\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The `write` function takes an output stream, a precompiled format string,\n+/// and a list of arguments. The arguments will be formatted according to the\n+/// specified format string into the output stream provided.\n+///\n+/// # Arguments\n+///\n+///   * output - the buffer to write output to\n+///   * args - the precompiled arguments generated by `format_args!`\n+#[experimental = \"libcore and I/O have yet to be reconciled, and this is an \\\n+                  implementation detail which should not otherwise be exported\"]\n+pub fn write(output: &mut FormatWriter, args: Arguments) -> Result {\n+    let mut formatter = Formatter {\n+        flags: 0,\n+        width: None,\n+        precision: None,\n+        buf: output,\n+        align: rt::AlignUnknown,\n+        fill: ' ',\n+        args: args.args,\n+        curarg: args.args.iter(),\n+    };\n+\n+    let mut pieces = args.pieces.iter();\n+\n+    match args.fmt {\n+        None => {\n+            // We can use default formatting parameters for all arguments.\n+            for _ in range(0, args.args.len()) {\n+                try!(formatter.buf.write(pieces.next().unwrap().as_bytes()));\n+                try!(formatter.run(&DEFAULT_ARGUMENT));\n+            }\n+        }\n+        Some(fmt) => {\n+            // Every spec has a corresponding argument that is preceded by\n+            // a string piece.\n+            for (arg, piece) in fmt.iter().zip(pieces.by_ref()) {\n+                try!(formatter.buf.write(piece.as_bytes()));\n+                try!(formatter.run(arg));\n+            }\n+        }\n+    }\n+\n+    // There can be only one trailing string piece left.\n+    match pieces.next() {\n+        Some(piece) => {\n+            try!(formatter.buf.write(piece.as_bytes()));\n+        }\n+        None => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// The `write` function takes an output stream, a precompiled format string,\n /// and a list of arguments. The arguments will be formatted according to the\n /// specified format string into the output stream provided.\n@@ -527,6 +603,16 @@ impl<'a> Formatter<'a> {\n         self.buf.write(data)\n     }\n \n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    /// Writes some formatted information into this instance\n+    #[unstable = \"reconciling core and I/O may alter this definition\"]\n+    pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n+        write(self.buf, fmt)\n+    }\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     /// Writes some formatted information into this instance\n     #[unstable = \"reconciling core and I/O may alter this definition\"]\n     pub fn write_fmt(&mut self, fmt: &Arguments) -> Result {"}, {"sha": "6d0d6e0817abd1fcf86e0a02c3a526d63df769aa", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -39,7 +39,7 @@\n //!   distribution.\n //!\n //! * `rust_begin_unwind` - This function takes three arguments, a\n-//!   `&fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n+//!   `fmt::Arguments`, a `&str`, and a `uint`. These three arguments dictate\n //!   the panic message, the file at which panic was invoked, and the line.\n //!   It is up to consumers of this core library to define this panic\n //!   function; it is only required to never return."}, {"sha": "2cd9e7c45098ea82425f62351e62b13dc423e98d", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -10,6 +10,30 @@\n \n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Entry point of task panic, for details, see std::macros\n+#[macro_export]\n+macro_rules! panic {\n+    () => (\n+        panic!(\"explicit panic\")\n+    );\n+    ($msg:expr) => ({\n+        static _MSG_FILE_LINE: (&'static str, &'static str, uint) = ($msg, file!(), line!());\n+        ::core::panicking::panic(&_MSG_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::core::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+    });\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n@@ -105,6 +129,16 @@ macro_rules! try {\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Writing a formatted string into a writer\n+#[macro_export]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Writing a formatted string into a writer\n #[macro_export]\n macro_rules! write {"}, {"sha": "32f09a4c17f3c64a15e768d48284f0fdba1861c3", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -16,7 +16,7 @@\n //! interface for panicking is:\n //!\n //! ```ignore\n-//! fn panic_impl(fmt: &fmt::Arguments, &(&'static str, uint)) -> !;\n+//! fn panic_impl(fmt: fmt::Arguments, &(&'static str, uint)) -> !;\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n@@ -31,8 +31,20 @@\n #![allow(dead_code, missing_docs)]\n \n use fmt;\n-use intrinsics;\n+// NOTE(stage0): Remove import after a snapshot\n+#[cfg(stage0)] use intrinsics;\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)] // this is the slow path, always\n+#[lang=\"panic\"]\n+pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n+    let (expr, file, line) = *expr_file_line;\n+    panic_fmt(format_args!(\"{}\", expr), &(file, line))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"panic\"]\n pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n@@ -45,6 +57,18 @@ pub fn panic(expr_file_line: &(&'static str, &'static str, uint)) -> ! {\n     unsafe { intrinsics::abort() }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)]\n+#[lang=\"panic_bounds_check\"]\n+fn panic_bounds_check(file_line: &(&'static str, uint),\n+                     index: uint, len: uint) -> ! {\n+    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n+                           len, index), file_line)\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n #[cold] #[inline(never)]\n #[lang=\"panic_bounds_check\"]\n fn panic_bounds_check(file_line: &(&'static str, uint),\n@@ -55,6 +79,21 @@ fn panic_bounds_check(file_line: &(&'static str, uint),\n     unsafe { intrinsics::abort() }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+#[cold] #[inline(never)]\n+pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+    #[allow(improper_ctypes)]\n+    extern {\n+        #[lang = \"panic_fmt\"]\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: uint) -> !;\n+    }\n+    let (file, line) = *file_line;\n+    unsafe { panic_impl(fmt, file, line) }\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n #[cold] #[inline(never)]\n pub fn panic_fmt(fmt: &fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n     #[allow(improper_ctypes)]"}, {"sha": "1d865868f18834f75196366becf74a4a9bdbdec1", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -268,6 +268,8 @@ impl Drop for DefaultLogger {\n     }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n /// This function is called directly by the compiler when using the logging\n /// macros. This function does not take into account whether the log level\n /// specified is active or not, it will always log something if this method is\n@@ -276,7 +278,7 @@ impl Drop for DefaultLogger {\n /// It is not recommended to call this function directly, rather it should be\n /// invoked through the logging family of macros.\n #[doc(hidden)]\n-pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n+pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n@@ -302,6 +304,42 @@ pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n     set_logger(logger);\n }\n \n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n+/// This function is called directly by the compiler when using the logging\n+/// macros. This function does not take into account whether the log level\n+/// specified is active or not, it will always log something if this method is\n+/// called.\n+///\n+/// It is not recommended to call this function directly, rather it should be\n+/// invoked through the logging family of macros.\n+#[doc(hidden)]\n+pub fn log(level: u32, loc: &'static LogLocation, args: &fmt::Arguments) {\n+    // Test the literal string from args against the current filter, if there\n+    // is one.\n+    match unsafe { FILTER.as_ref() } {\n+        Some(filter) if !filter.is_match(args.to_string().as_slice()) => return,\n+        _ => {}\n+    }\n+\n+    // Completely remove the local logger from TLS in case anyone attempts to\n+    // frob the slot while we're doing the logging. This will destroy any logger\n+    // set during logging.\n+    let mut logger = LOCAL_LOGGER.with(|s| {\n+        s.borrow_mut().take()\n+    }).unwrap_or_else(|| {\n+        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n+    });\n+    logger.log(&LogRecord {\n+        level: LogLevel(level),\n+        args: *args,\n+        file: loc.file,\n+        module_path: loc.module_path,\n+        line: loc.line,\n+    });\n+    set_logger(logger);\n+}\n+\n /// Getter for the global log level. This is a function so that it can be called\n /// safely\n #[doc(hidden)]\n@@ -329,7 +367,7 @@ pub struct LogRecord<'a> {\n     pub level: LogLevel,\n \n     /// The arguments from the log line.\n-    pub args: &'a fmt::Arguments<'a>,\n+    pub args: fmt::Arguments<'a>,\n \n     /// The file of where the LogRecord originated.\n     pub file: &'a str,"}, {"sha": "2e8302cc10f9aa794bdc49594f5d6bcb47f37c00", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -12,6 +12,63 @@\n \n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The standard logging macro\n+///\n+/// This macro will generically log over a provided level (of type u32) with a\n+/// format!-based argument list. See documentation in `std::fmt` for details on\n+/// how to use the syntax.\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(phase)]\n+/// #[phase(plugin, link)] extern crate log;\n+///\n+/// fn main() {\n+///     log!(log::WARN, \"this is a warning {}\", \"message\");\n+///     log!(log::DEBUG, \"this is a debug message\");\n+///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=warn ./main\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=6 ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// 6:main: this is a custom logging level: 6\n+/// ```\n+#[macro_export]\n+macro_rules! log {\n+    ($lvl:expr, $($arg:tt)+) => ({\n+        static LOC: ::log::LogLocation = ::log::LogLocation {\n+            line: line!(),\n+            file: file!(),\n+            module_path: module_path!(),\n+        };\n+        let lvl = $lvl;\n+        if log_enabled!(lvl) {\n+            ::log::log(lvl, &LOC, format_args!($($arg)+))\n+        }\n+    })\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// The standard logging macro\n ///\n /// This macro will generically log over a provided level (of type u32) with a"}, {"sha": "b75cf9a196b507e87e936df574879b92bae7f6ae", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -16,13 +16,6 @@\n //! This macro is implemented in the compiler to emit calls to this module in\n //! order to format arguments at runtime into strings and streams.\n //!\n-//! The functions contained in this module should not normally be used in\n-//! everyday use cases of `format!`. The assumptions made by these functions are\n-//! unsafe for all inputs, and the compiler performs a large amount of\n-//! validation on the arguments to `format!` in order to ensure safety at\n-//! runtime. While it is possible to call these functions directly, it is not\n-//! recommended to do so in the general case.\n-//!\n //! ## Usage\n //!\n //! The `format!` macro is intended to be familiar to those coming from C's\n@@ -275,35 +268,28 @@\n //!\n //! # #[allow(unused_must_use)]\n //! # fn main() {\n-//! format_args!(fmt::format, \"this returns {}\", \"String\");\n+//! fmt::format(format_args!(\"this returns {}\", \"String\"));\n //!\n //! let some_writer: &mut io::Writer = &mut io::stdout();\n-//! format_args!(|args| { write!(some_writer, \"{}\", args) },\n-//!              \"print with a {}\", \"closure\");\n+//! write!(some_writer, \"{}\", format_args!(\"print with a {}\", \"macro\"));\n //!\n-//! fn my_fmt_fn(args: &fmt::Arguments) {\n+//! fn my_fmt_fn(args: fmt::Arguments) {\n //!     write!(&mut io::stdout(), \"{}\", args);\n //! }\n-//! format_args!(my_fmt_fn, \"or a {} too\", \"function\");\n+//! my_fmt_fn(format_args!(\"or a {} too\", \"function\"));\n //! # }\n //! ```\n //!\n-//! The first argument of the `format_args!` macro is a function (or closure)\n-//! which takes one argument of type `&fmt::Arguments`. This structure can then\n-//! be passed to the `write` and `format` functions inside this module in order\n-//! to process the format string. The goal of this macro is to even further\n-//! prevent intermediate allocations when dealing formatting strings.\n+//! The result of the `format_args!` macro is a value of type `fmt::Arguments`.\n+//! This structure can then be passed to the `write` and `format` functions\n+//! inside this module in order to process the format string.\n+//! The goal of this macro is to even further prevent intermediate allocations\n+//! when dealing formatting strings.\n //!\n //! For example, a logging library could use the standard formatting syntax, but\n //! it would internally pass around this structure until it has been determined\n //! where output should go to.\n //!\n-//! It is unsafe to programmatically create an instance of `fmt::Arguments`\n-//! because the operations performed when executing a format string require the\n-//! compile-time checks provided by the compiler. The `format_args!` macro is\n-//! the only method of safely creating these structures, but they can be\n-//! unsafely created with the constructor provided.\n-//!\n //! ## Syntax\n //!\n //! The syntax for the formatting language used is drawn from other languages,\n@@ -420,14 +406,39 @@ pub use core::fmt::{Argument, Arguments, write, radix, Radix, RadixFmt};\n #[doc(hidden)]\n pub use core::fmt::{argument, argumentuint};\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The format function takes a precompiled format string and a list of\n+/// arguments, to return the resulting formatted string.\n+///\n+/// # Arguments\n+///\n+///   * args - a structure of arguments generated via the `format_args!` macro.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::fmt;\n+///\n+/// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n+/// assert_eq!(s, \"Hello, world!\".to_string());\n+/// ```\n+#[experimental = \"this is an implementation detail of format! and should not \\\n+                  be called directly\"]\n+pub fn format(args: Arguments) -> string::String {\n+    let mut output = Vec::new();\n+    let _ = write!(&mut output as &mut Writer, \"{}\", args);\n+    string::String::from_utf8(output).unwrap()\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n /// # Arguments\n ///\n ///   * args - a structure of arguments generated via the `format_args!` macro.\n-///            Because this structure can only be safely generated at\n-///            compile-time, this function is safe.\n ///\n /// # Example\n ///"}, {"sha": "b6f8bb25b65312adabedba8ead94e7c61827e037", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -1017,6 +1017,48 @@ pub trait Writer {\n     /// decide whether their stream needs to be buffered or not.\n     fn flush(&mut self) -> IoResult<()> { Ok(()) }\n \n+    // NOTE(stage0): Remove cfg after a snapshot\n+    #[cfg(not(stage0))]\n+    /// Writes a formatted string into this writer, returning any error\n+    /// encountered.\n+    ///\n+    /// This method is primarily used to interface with the `format_args!`\n+    /// macro, but it is rare that this should explicitly be called. The\n+    /// `write!` macro should be favored to invoke this method instead.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return any I/O error reported while formatting.\n+    fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n+        // Create a shim which translates a Writer to a FormatWriter and saves\n+        // off I/O errors. instead of discarding them\n+        struct Adaptor<'a, T:'a> {\n+            inner: &'a mut T,\n+            error: IoResult<()>,\n+        }\n+\n+        impl<'a, T: Writer> fmt::FormatWriter for Adaptor<'a, T> {\n+            fn write(&mut self, bytes: &[u8]) -> fmt::Result {\n+                match self.inner.write(bytes) {\n+                    Ok(()) => Ok(()),\n+                    Err(e) => {\n+                        self.error = Err(e);\n+                        Err(fmt::Error)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut output = Adaptor { inner: self, error: Ok(()) };\n+        match fmt::write(&mut output, fmt) {\n+            Ok(()) => Ok(()),\n+            Err(..) => output.error\n+        }\n+    }\n+\n+\n+    // NOTE(stage0): Remove method after a snapshot\n+    #[cfg(stage0)]\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///"}, {"sha": "6bd721599f341df1d2ed49777ed3ad419717f31a", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -378,12 +378,32 @@ pub fn println(s: &str) {\n     })\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n+/// with the `format_args!` macro.\n+pub fn print_args(fmt: fmt::Arguments) {\n+    with_task_stdout(|io| write!(io, \"{}\", fmt))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n     with_task_stdout(|io| write!(io, \"{}\", fmt))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Similar to `println`, but takes a `fmt::Arguments` structure to be\n+/// compatible with the `format_args!` macro.\n+pub fn println_args(fmt: fmt::Arguments) {\n+    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {"}, {"sha": "edb6218c5cc0beb25a9971fe0e491b607965d717", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 126, "deletions": 10, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -17,6 +17,50 @@\n #![experimental]\n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The entry point for panic of Rust tasks.\n+///\n+/// This macro is used to inject panic into a Rust task, causing the task to\n+/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n+/// the value which is transmitted.\n+///\n+/// The multi-argument form of this macro panics with a string and has the\n+/// `format!` syntax for building a string.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #![allow(unreachable_code)]\n+/// panic!();\n+/// panic!(\"this is a terrible mistake!\");\n+/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// ```\n+#[macro_export]\n+macro_rules! panic {\n+    () => ({\n+        panic!(\"explicit panic\")\n+    });\n+    ($msg:expr) => ({\n+        // static requires less code at runtime, more constant data\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+\n+    });\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// The entry point for panic of Rust tasks.\n ///\n /// This macro is used to inject panic into a Rust task, causing the task to\n@@ -245,6 +289,26 @@ macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! format {\n+    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n ///\n@@ -263,6 +327,28 @@ macro_rules! format {\n     )\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n /// See `std::fmt` for more information.\n ///\n@@ -294,6 +380,18 @@ macro_rules! writeln {\n     )\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// the end of the message.\n+#[macro_export]\n+#[stable]\n+macro_rules! print {\n+    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -302,6 +400,28 @@ macro_rules! print {\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// Macro for printing to a task's stdout handle.\n+///\n+/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// The syntax of this macro is the same as that used for `format!`. For more\n+/// information, see `std::fmt` and `std::io::stdio`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// println!(\"hello there!\");\n+/// println!(\"format {} arguments\", \"some\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! println {\n+    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n /// Macro for printing to a task's stdout handle.\n ///\n /// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n@@ -411,11 +531,10 @@ macro_rules! log {\n pub mod builtin {\n     /// The core macro for formatted string creation & output.\n     ///\n-    /// This macro takes as its first argument a callable expression which will\n-    /// receive as its first argument a value of type `&fmt::Arguments`. This\n-    /// value can be passed to the functions in `std::fmt` for performing useful\n-    /// functions. All other formatting macros (`format!`, `write!`,\n-    /// `println!`, etc) are proxied through this one.\n+    /// This macro produces a value of type `fmt::Arguments`. This value can be\n+    /// passed to the functions in `std::fmt` for performing useful functions.\n+    /// All other formatting macros (`format!`, `write!`, `println!`, etc) are\n+    /// proxied through this one.\n     ///\n     /// For more information, see the documentation in `std::fmt`.\n     ///\n@@ -424,15 +543,12 @@ pub mod builtin {\n     /// ```rust\n     /// use std::fmt;\n     ///\n-    /// let s = format_args!(fmt::format, \"hello {}\", \"world\");\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n     /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n     ///\n-    /// format_args!(|args| {\n-    ///     // pass `args` to another function, etc.\n-    /// }, \"hello {}\", \"world\");\n     /// ```\n     #[macro_export]\n-    macro_rules! format_args { ($closure:expr, $fmt:expr $($args:tt)*) => ({\n+    macro_rules! format_args { ($fmt:expr $($args:tt)*) => ({\n         /* compiler built-in */\n     }) }\n "}, {"sha": "095a27203f9819e28397ddcec446f1b707ad4129", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -15,6 +15,16 @@\n \n #![macro_escape]\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+macro_rules! rterrln {\n+    ($fmt:expr $($arg:tt)*) => ( {\n+        ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))\n+    } )\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         format_args!(::rt::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n@@ -40,6 +50,14 @@ macro_rules! rtassert {\n     } )\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+macro_rules! rtabort {\n+    ($($arg:tt)*) => (::rt::util::abort(format_args!($($arg)*)))\n+}\n+\n+// NOTE(stage0): Remove macro after a snapshot\n+#[cfg(stage0)]\n macro_rules! rtabort {\n     ($($arg:tt)*) => (format_args!(::rt::util::abort, $($arg)*))\n }"}, {"sha": "261a8335173d0a1315b2d42144f3fd9de69ac38e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -477,14 +477,61 @@ pub mod eabi {\n     }\n }\n \n-// Entry point of panic from the libcore crate\n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n #[cfg(not(test))]\n+/// Entry point of panic from the libcore crate.\n+#[lang = \"panic_fmt\"]\n+pub extern fn rust_begin_unwind(msg: fmt::Arguments,\n+                                file: &'static str, line: uint) -> ! {\n+    begin_unwind_fmt(msg, &(file, line))\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n+#[cfg(not(test))]\n+/// Entry point of panic from the libcore crate.\n #[lang = \"panic_fmt\"]\n pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n                                 file: &'static str, line: uint) -> ! {\n     begin_unwind_fmt(msg, &(file, line))\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+/// The entry point for unwinding with a formatted message.\n+///\n+/// This is designed to reduce the amount of code required at the call\n+/// site as much as possible (so that `panic!()` has as low an impact\n+/// on (e.g.) the inlining of other functions as possible), by moving\n+/// the actual formatting into this shared place.\n+#[inline(never)] #[cold]\n+pub fn begin_unwind_fmt(msg: fmt::Arguments, file_line: &(&'static str, uint)) -> ! {\n+    use fmt::FormatWriter;\n+\n+    // We do two allocations here, unfortunately. But (a) they're\n+    // required with the current scheme, and (b) we don't handle\n+    // panic + OOM properly anyway (see comment in begin_unwind\n+    // below).\n+\n+    struct VecWriter<'a> { v: &'a mut Vec<u8> }\n+\n+    impl<'a> fmt::FormatWriter for VecWriter<'a> {\n+        fn write(&mut self, buf: &[u8]) -> fmt::Result {\n+            self.v.push_all(buf);\n+            Ok(())\n+        }\n+    }\n+\n+    let mut v = Vec::new();\n+    let _ = write!(&mut VecWriter { v: &mut v }, \"{}\", msg);\n+\n+    let msg = box String::from_utf8_lossy(v.as_slice()).into_owned();\n+    begin_unwind_inner(msg, file_line)\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call"}, {"sha": "26dadfd9fb1db505e68564d0a5fb2c094a6dc835", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -112,12 +112,25 @@ impl fmt::FormatWriter for Stdio {\n     }\n }\n \n+// NOTE(stage0): Remove cfg after a snapshot\n+#[cfg(not(stage0))]\n+pub fn dumb_print(args: fmt::Arguments) {\n+    let _ = Stderr.write_fmt(args);\n+}\n+\n+// NOTE(stage0): Remove function after a snapshot\n+#[cfg(stage0)]\n pub fn dumb_print(args: &fmt::Arguments) {\n     let mut w = Stderr;\n     let _ = write!(&mut w, \"{}\", args);\n }\n \n-pub fn abort(args: &fmt::Arguments) -> ! {\n+// NOTE(stage0): Remove wrappers after a snapshot\n+#[cfg(not(stage0))] pub fn abort(args: fmt::Arguments) -> ! { abort_(&args) }\n+#[cfg(stage0)] pub fn abort(args: &fmt::Arguments) -> ! { abort_(args) }\n+\n+// NOTE(stage0): Change to `pub fn abort(args: fmt::Arguments) -> !` after a snapshot\n+fn abort_(args: &fmt::Arguments) -> ! {\n     use fmt::FormatWriter;\n \n     struct BufWriter<'a> {"}, {"sha": "0aa3c40fa5f88c64b1f38034a28635e5d2ceffe0", "filename": "src/test/compile-fail/dead-code-closure-bang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-closure-bang.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     let x: || -> ! = || panic!();\n     x();\n-    println!(\"Foo bar\"); //~ ERROR: unreachable statement\n+    std::io::println(\"Foo bar\"); //~ ERROR: unreachable statement\n }"}, {"sha": "8bd3cb0f60b04884fe875a3e88c108413d7407d4", "filename": "src/test/compile-fail/ifmt-bad-format-args.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,6 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    format_args!(\"test\"); //~ ERROR: expected token\n-    format_args!(\"\", || {}); //~ ERROR: must be a string literal\n+    format_args!(); //~ ERROR: requires at least a format string argument\n+    format_args!(|| {}); //~ ERROR: must be a string literal\n }"}, {"sha": "7bb8365bc128ed4c2a1b459a25948ba61ab5c196", "filename": "src/test/compile-fail/ifmt-bad-format-args2.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3f22bf2510dacb1fc4f5422b025a51bfda410e/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-format-args2.rs?ref=fc3f22bf2510dacb1fc4f5422b025a51bfda410e", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    format_args!(\"{}\", \"\"); //~ ERROR: expected function\n-}"}, {"sha": "c2ebd764ad6b993c549e659b5d9c06a2c56d6967", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -34,13 +34,6 @@\n                 [int; 3]) as &[int; 3]) as *const _ as *const [int; 3]) as\n             *const [int; (3u as uint)] as *const [int; 3]);\n \n-    (match (() as ()) {\n-         () => {\n-             #[inline]\n-             #[allow(dead_code)]\n-             static __STATIC_FMTSTR: &'static [&'static str] =\n-                 (&([(\"test\" as &'static str)] as [&'static str; 1]) as\n-                     &'static [&'static str; 1]);\n \n \n \n@@ -49,24 +42,45 @@\n \n \n \n-             ((::std::fmt::format as\n-                  fn(&core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})((&((::std::fmt::Arguments::new\n-                                                                                                          as\n-                                                                                                          fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})((__STATIC_FMTSTR\n-                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                   &'static [&'static str]),\n-                                                                                                                                                                                                               (&([]\n-                                                                                                                                                                                                                     as\n-                                                                                                                                                                                                                     [core::fmt::Argument<'_>; 0])\n-                                                                                                                                                                                                                   as\n-                                                                                                                                                                                                                   &[core::fmt::Argument<'_>; 0]))\n-                                                                                                         as\n-                                                                                                         core::fmt::Arguments<'_>)\n-                                                                                                       as\n-                                                                                                       &core::fmt::Arguments<'_>))\n-                 as collections::string::String)\n-         }\n-     } as collections::string::String);\n+    ((::std::fmt::format as\n+         fn(core::fmt::Arguments<'_>) -> collections::string::String {std::fmt::format})(((::std::fmt::Arguments::new\n+                                                                                              as\n+                                                                                              fn(&[&str], &[core::fmt::Argument<'_>]) -> core::fmt::Arguments<'_> {core::fmt::Arguments<'a>::new})(({\n+                                                                                                                                                                                                        #[inline]\n+                                                                                                                                                                                                        #[allow(dead_code)]\n+                                                                                                                                                                                                        static __STATIC_FMTSTR:\n+                                                                                                                                                                                                               &'static [&'static str]\n+                                                                                                                                                                                                               =\n+                                                                                                                                                                                                            (&([(\"test\"\n+                                                                                                                                                                                                                    as\n+                                                                                                                                                                                                                    &'static str)]\n+                                                                                                                                                                                                                  as\n+                                                                                                                                                                                                                  [&'static str; 1])\n+                                                                                                                                                                                                                as\n+                                                                                                                                                                                                                &'static [&'static str; 1]);\n+                                                                                                                                                                                                        (__STATIC_FMTSTR\n+                                                                                                                                                                                                            as\n+                                                                                                                                                                                                            &'static [&'static str])\n+                                                                                                                                                                                                    }\n+                                                                                                                                                                                                       as\n+                                                                                                                                                                                                       &[&str]),\n+                                                                                                                                                                                                   (&(match (()\n+                                                                                                                                                                                                                as\n+                                                                                                                                                                                                                ())\n+                                                                                                                                                                                                          {\n+                                                                                                                                                                                                          ()\n+                                                                                                                                                                                                          =>\n+                                                                                                                                                                                                          ([]\n+                                                                                                                                                                                                              as\n+                                                                                                                                                                                                              [core::fmt::Argument<'_>; 0]),\n+                                                                                                                                                                                                      }\n+                                                                                                                                                                                                         as\n+                                                                                                                                                                                                         [core::fmt::Argument<'_>; 0])\n+                                                                                                                                                                                                       as\n+                                                                                                                                                                                                       &[core::fmt::Argument<'_>; 0]))\n+                                                                                             as\n+                                                                                             core::fmt::Arguments<'_>))\n+        as collections::string::String);\n }\n pub type Foo = [int; (3u as uint)];\n pub struct Bar {"}, {"sha": "fa62699a303783b4e0538c174f90c214894aa96a", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/647e54d6d154e1a267e84c8ae9f1315e3f9b93fc/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=647e54d6d154e1a267e84c8ae9f1315e3f9b93fc", "patch": "@@ -190,18 +190,16 @@ fn test_format_args() {\n     let mut buf = Vec::new();\n     {\n         let w = &mut buf as &mut io::Writer;\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"{}\", 1i);\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"test\");\n-        format_args!(|args| { write!(w, \"{}\", args); }, \"{test}\", test=3i);\n+        write!(w, \"{}\", format_args!(\"{}\", 1i));\n+        write!(w, \"{}\", format_args!(\"test\"));\n+        write!(w, \"{}\", format_args!(\"{test}\", test=3i));\n     }\n     let s = String::from_utf8(buf).unwrap();\n     t!(s, \"1test3\");\n \n-    let s = format_args!(fmt::format, \"hello {}\", \"world\");\n+    let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n     t!(s, \"hello world\");\n-    let s = format_args!(|args| {\n-        format!(\"{}: {}\", \"args were\", args)\n-    }, \"hello {}\", \"world\");\n+    let s = format!(\"{}: {}\", \"args were\", format_args!(\"hello {}\", \"world\"));\n     t!(s, \"args were: hello world\");\n }\n "}]}