{"sha": "71dd5422acd06a9cab95c6f202dbb5c577f91ef9", "node_id": "C_kwDOAAsO6NoAKDcxZGQ1NDIyYWNkMDZhOWNhYjk1YzZmMjAyZGJiNWM1NzdmOTFlZjk", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2021-12-02T22:20:03Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2021-12-03T01:31:38Z"}, "message": "Use new MIR pass manager", "tree": {"sha": "6205b334e21b70344c8953971806039a69b805c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6205b334e21b70344c8953971806039a69b805c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71dd5422acd06a9cab95c6f202dbb5c577f91ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71dd5422acd06a9cab95c6f202dbb5c577f91ef9", "html_url": "https://github.com/rust-lang/rust/commit/71dd5422acd06a9cab95c6f202dbb5c577f91ef9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71dd5422acd06a9cab95c6f202dbb5c577f91ef9/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fca642c1c38b53db368114efe617378fd8229532", "url": "https://api.github.com/repos/rust-lang/rust/commits/fca642c1c38b53db368114efe617378fd8229532", "html_url": "https://github.com/rust-lang/rust/commit/fca642c1c38b53db368114efe617378fd8229532"}], "stats": {"total": 253, "additions": 79, "deletions": 174}, "files": [{"sha": "793e46687d2f13272e7380af0eb5cabe1065c763", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 73, "deletions": 168, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/71dd5422acd06a9cab95c6f202dbb5c577f91ef9/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71dd5422acd06a9cab95c6f202dbb5c577f91ef9/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=71dd5422acd06a9cab95c6f202dbb5c577f91ef9", "patch": "@@ -27,15 +27,15 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n-use rustc_middle::mir::{dump_mir, traversal, Body, ConstQualifs, MirPass, MirPhase, Promoted};\n+use rustc_middle::mir::{traversal, Body, ConstQualifs, MirPass, MirPhase, Promoted};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_span::{Span, Symbol};\n \n #[macro_use]\n mod pass_manager;\n \n-use pass_manager::{Lint, MirLint};\n+use pass_manager::{self as pm, Lint, MirLint};\n \n mod abort_unwinding_calls;\n mod add_call_guards;\n@@ -174,66 +174,6 @@ fn mir_keys(tcx: TyCtxt<'_>, (): ()) -> FxHashSet<LocalDefId> {\n     set\n }\n \n-fn run_passes(\n-    tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n-    mir_phase: MirPhase,\n-    passes: &[&[&dyn MirPass<'tcx>]],\n-) {\n-    let phase_index = mir_phase.phase_index();\n-    let validate = tcx.sess.opts.debugging_opts.validate_mir;\n-\n-    if body.phase >= mir_phase {\n-        return;\n-    }\n-\n-    if validate {\n-        validate::Validator { when: format!(\"input to phase {:?}\", mir_phase), mir_phase }\n-            .run_pass(tcx, body);\n-    }\n-\n-    let mut index = 0;\n-    let mut run_pass = |pass: &dyn MirPass<'tcx>| {\n-        let run_hooks = |body: &_, index, is_after| {\n-            let disambiguator = if is_after { \"after\" } else { \"before\" };\n-            dump_mir(\n-                tcx,\n-                Some(&format_args!(\"{:03}-{:03}\", phase_index, index)),\n-                &pass.name(),\n-                &disambiguator,\n-                body,\n-                |_, _| Ok(()),\n-            );\n-        };\n-        run_hooks(body, index, false);\n-        pass.run_pass(tcx, body);\n-        run_hooks(body, index, true);\n-\n-        if validate {\n-            validate::Validator {\n-                when: format!(\"after {} in phase {:?}\", pass.name(), mir_phase),\n-                mir_phase,\n-            }\n-            .run_pass(tcx, body);\n-        }\n-\n-        index += 1;\n-    };\n-\n-    for pass_group in passes {\n-        for pass in *pass_group {\n-            run_pass(*pass);\n-        }\n-    }\n-\n-    body.phase = mir_phase;\n-\n-    if mir_phase == MirPhase::Optimization {\n-        validate::Validator { when: format!(\"end of phase {:?}\", mir_phase), mir_phase }\n-            .run_pass(tcx, body);\n-    }\n-}\n-\n fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> ConstQualifs {\n     let const_kind = tcx.hir().body_const_context(def.did);\n \n@@ -285,19 +225,19 @@ fn mir_const<'tcx>(\n \n     rustc_middle::mir::dump_mir(tcx, None, \"mir_map\", &0, &body, |_, _| Ok(()));\n \n-    run_passes(\n+    pm::run_passes(\n         tcx,\n         &mut body,\n-        MirPhase::Const,\n-        &[&[\n+        &[\n             // MIR-level lints.\n             &Lint(check_packed_ref::CheckPackedRef),\n             &Lint(check_const_item_mutation::CheckConstItemMutation),\n             &Lint(function_item_references::FunctionItemReferences),\n             // What we need to do constant evaluation.\n             &simplify::SimplifyCfg::new(\"initial\"),\n             &rustc_peek::SanityCheck, // Just a lint\n-        ]],\n+            &marker::PhaseChange(MirPhase::Const),\n+        ],\n     );\n     tcx.alloc_steal_mir(body)\n }\n@@ -324,17 +264,17 @@ fn mir_promoted(\n     }\n     body.required_consts = required_consts;\n \n+    // What we need to run borrowck etc.\n     let promote_pass = promote_consts::PromoteTemps::default();\n-    let promote: &[&dyn MirPass<'tcx>] = &[\n-        // What we need to run borrowck etc.\n-        &promote_pass,\n-        &simplify::SimplifyCfg::new(\"promote-consts\"),\n-    ];\n-\n-    let opt_coverage: &[&dyn MirPass<'tcx>] =\n-        if tcx.sess.instrument_coverage() { &[&coverage::InstrumentCoverage] } else { &[] };\n-\n-    run_passes(tcx, &mut body, MirPhase::ConstPromotion, &[promote, opt_coverage]);\n+    pm::run_passes(\n+        tcx,\n+        &mut body,\n+        &[\n+            &promote_pass,\n+            &simplify::SimplifyCfg::new(\"promote-consts\"),\n+            &coverage::InstrumentCoverage,\n+        ],\n+    );\n \n     let promoted = promote_pass.promoted_fragments.into_inner();\n     (tcx.alloc_steal_mir(body), tcx.alloc_steal_promoted(promoted))\n@@ -396,19 +336,10 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n         // Technically we want to not run on regular const items, but oli-obk doesn't know how to\n         // conveniently detect that at this point without looking at the HIR.\n         hir::ConstContext::Const => {\n-            #[rustfmt::skip]\n-            let optimizations: &[&dyn MirPass<'_>] = &[\n-                &const_prop::ConstProp,\n-            ];\n-\n-            #[rustfmt::skip]\n-            run_passes(\n+            pm::run_passes(\n                 tcx,\n                 &mut body,\n-                MirPhase::Optimization,\n-                &[\n-                    optimizations,\n-                ],\n+                &[&const_prop::ConstProp, &marker::PhaseChange(MirPhase::Optimization)],\n             );\n         }\n     }\n@@ -453,19 +384,23 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n     let mut body = body.steal();\n \n     // IMPORTANT\n-    remove_false_edges::RemoveFalseEdges.run_pass(tcx, &mut body);\n+    pm::run_passes(tcx, &mut body, &[&remove_false_edges::RemoveFalseEdges]);\n \n     // Do a little drop elaboration before const-checking if `const_precise_live_drops` is enabled.\n-    //\n-    // FIXME: Can't use `run_passes` for these, since `run_passes` SILENTLY DOES NOTHING IF THE MIR\n-    // PHASE DOESN'T CHANGE.\n     if check_consts::post_drop_elaboration::checking_enabled(&ConstCx::new(tcx, &body)) {\n-        simplify::SimplifyCfg::new(\"remove-false-edges\").run_pass(tcx, &mut body);\n-        remove_uninit_drops::RemoveUninitDrops.run_pass(tcx, &mut body);\n-        check_consts::post_drop_elaboration::check_live_drops(tcx, &body);\n+        pm::run_passes(\n+            tcx,\n+            &mut body,\n+            &[\n+                &simplify::SimplifyCfg::new(\"remove-false-edges\"),\n+                &remove_uninit_drops::RemoveUninitDrops,\n+            ],\n+        );\n+        check_consts::post_drop_elaboration::check_live_drops(tcx, &body); // FIXME: make this a MIR lint\n     }\n \n     run_post_borrowck_cleanup_passes(tcx, &mut body);\n+    assert!(body.phase == MirPhase::DropLowering);\n     tcx.alloc_steal_mir(body)\n }\n \n@@ -499,95 +434,65 @@ fn run_post_borrowck_cleanup_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tc\n         &deaggregator::Deaggregator,\n     ];\n \n-    run_passes(tcx, body, MirPhase::DropLowering, &[post_borrowck_cleanup]);\n+    pm::run_passes(tcx, body, post_borrowck_cleanup);\n }\n \n fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let mir_opt_level = tcx.sess.mir_opt_level();\n-\n     // Lowering generator control-flow and variables has to happen before we do anything else\n     // to them. We run some optimizations before that, because they may be harder to do on the state\n     // machine than on MIR with async primitives.\n-    let optimizations_with_generators: &[&dyn MirPass<'tcx>] = &[\n-        &reveal_all::RevealAll, // has to be done before inlining, since inlined code is in RevealAll mode.\n-        &lower_slice_len::LowerSliceLenCalls, // has to be done before inlining, otherwise actual call will be almost always inlined. Also simple, so can just do first\n-        &normalize_array_len::NormalizeArrayLen, // has to run after `slice::len` lowering\n-        &unreachable_prop::UnreachablePropagation,\n-        &uninhabited_enum_branching::UninhabitedEnumBranching,\n-        &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n-        &inline::Inline,\n-        &generator::StateTransform,\n-    ];\n-\n-    // Even if we don't do optimizations, we still have to lower generators for codegen.\n-    let no_optimizations_with_generators: &[&dyn MirPass<'tcx>] = &[&generator::StateTransform];\n-\n-    // The main optimizations that we do on MIR.\n-    let optimizations: &[&dyn MirPass<'tcx>] = &[\n-        &remove_storage_markers::RemoveStorageMarkers,\n-        &remove_zsts::RemoveZsts,\n-        &const_goto::ConstGoto,\n-        &remove_unneeded_drops::RemoveUnneededDrops,\n-        &match_branches::MatchBranchSimplification,\n-        // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n-        &multiple_return_terminators::MultipleReturnTerminators,\n-        &instcombine::InstCombine,\n-        &separate_const_switch::SeparateConstSwitch,\n-        &const_prop::ConstProp,\n-        &simplify_branches::SimplifyConstCondition::new(\"after-const-prop\"),\n-        &early_otherwise_branch::EarlyOtherwiseBranch,\n-        &simplify_comparison_integral::SimplifyComparisonIntegral,\n-        &simplify_try::SimplifyArmIdentity,\n-        &simplify_try::SimplifyBranchSame,\n-        &dest_prop::DestinationPropagation,\n-        &simplify_branches::SimplifyConstCondition::new(\"final\"),\n-        &remove_noop_landing_pads::RemoveNoopLandingPads,\n-        &simplify::SimplifyCfg::new(\"final\"),\n-        &nrvo::RenameReturnPlace,\n-        &const_debuginfo::ConstDebugInfo,\n-        &simplify::SimplifyLocals,\n-        &multiple_return_terminators::MultipleReturnTerminators,\n-        &deduplicate_blocks::DeduplicateBlocks,\n-    ];\n-\n-    // Optimizations to run even if mir optimizations have been disabled.\n-    let no_optimizations: &[&dyn MirPass<'tcx>] = &[\n-        // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n-        &const_prop::ConstProp,\n-    ];\n-\n-    // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n-    let pre_codegen_cleanup: &[&dyn MirPass<'tcx>] = &[\n-        &add_call_guards::CriticalCallEdges,\n-        // Dump the end result for testing and debugging purposes.\n-        &dump_mir::Marker(\"PreCodegen\"),\n-    ];\n-\n-    // End of pass declarations, now actually run the passes.\n-    // Generator Lowering\n-    #[rustfmt::skip]\n-    run_passes(\n+    pm::run_passes(\n         tcx,\n         body,\n-        MirPhase::GeneratorLowering,\n         &[\n-            if mir_opt_level > 0 {\n-                optimizations_with_generators\n-            } else {\n-                no_optimizations_with_generators\n-            }\n+            &reveal_all::RevealAll, // has to be done before inlining, since inlined code is in RevealAll mode.\n+            &lower_slice_len::LowerSliceLenCalls, // has to be done before inlining, otherwise actual call will be almost always inlined. Also simple, so can just do first\n+            &normalize_array_len::NormalizeArrayLen, // has to run after `slice::len` lowering\n+            &unreachable_prop::UnreachablePropagation,\n+            &uninhabited_enum_branching::UninhabitedEnumBranching,\n+            &simplify::SimplifyCfg::new(\"after-uninhabited-enum-branching\"),\n+            &inline::Inline,\n+            &generator::StateTransform,\n         ],\n     );\n \n-    // Main optimization passes\n-    #[rustfmt::skip]\n-    run_passes(\n+    assert!(body.phase == MirPhase::GeneratorLowering);\n+\n+    // The main optimizations that we do on MIR.\n+    pm::run_passes(\n         tcx,\n         body,\n-        MirPhase::Optimization,\n         &[\n-            if mir_opt_level > 0 { optimizations } else { no_optimizations },\n-            pre_codegen_cleanup,\n+            &remove_storage_markers::RemoveStorageMarkers,\n+            &remove_zsts::RemoveZsts,\n+            &const_goto::ConstGoto,\n+            &remove_unneeded_drops::RemoveUnneededDrops,\n+            &match_branches::MatchBranchSimplification,\n+            // inst combine is after MatchBranchSimplification to clean up Ne(_1, false)\n+            &multiple_return_terminators::MultipleReturnTerminators,\n+            &instcombine::InstCombine,\n+            &separate_const_switch::SeparateConstSwitch,\n+            // FIXME(#70073): This pass is responsible for both optimization as well as some lints.\n+            &const_prop::ConstProp,\n+            &simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n+            &early_otherwise_branch::EarlyOtherwiseBranch,\n+            &simplify_comparison_integral::SimplifyComparisonIntegral,\n+            &simplify_try::SimplifyArmIdentity,\n+            &simplify_try::SimplifyBranchSame,\n+            &dest_prop::DestinationPropagation,\n+            &simplify_branches::SimplifyBranches::new(\"final\"),\n+            &remove_noop_landing_pads::RemoveNoopLandingPads,\n+            &simplify::SimplifyCfg::new(\"final\"),\n+            &nrvo::RenameReturnPlace,\n+            &const_debuginfo::ConstDebugInfo,\n+            &simplify::SimplifyLocals,\n+            &multiple_return_terminators::MultipleReturnTerminators,\n+            &deduplicate_blocks::DeduplicateBlocks,\n+            // Some cleanup necessary at least for LLVM and potentially other codegen backends.\n+            &add_call_guards::CriticalCallEdges,\n+            &marker::PhaseChange(MirPhase::Optimization),\n+            // Dump the end result for testing and debugging purposes.\n+            &dump_mir::Marker(\"PreCodegen\"),\n         ],\n     );\n }"}, {"sha": "b4a92064377a52ab0db5d8f7d947088f4cef51fa", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71dd5422acd06a9cab95c6f202dbb5c577f91ef9/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71dd5422acd06a9cab95c6f202dbb5c577f91ef9/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=71dd5422acd06a9cab95c6f202dbb5c577f91ef9", "patch": "@@ -17,8 +17,8 @@ use std::iter;\n \n use crate::util::expand_aggregate;\n use crate::{\n-    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, remove_noop_landing_pads,\n-    run_passes, simplify,\n+    abort_unwinding_calls, add_call_guards, add_moves_for_packed_drops, marker, pass_manager as pm,\n+    remove_noop_landing_pads, simplify,\n };\n use rustc_middle::mir::patch::MirPatch;\n use rustc_mir_dataflow::elaborate_drops::{self, DropElaborator, DropFlagMode, DropStyle};\n@@ -75,17 +75,17 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n     };\n     debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n \n-    run_passes(\n+    pm::run_passes(\n         tcx,\n         &mut result,\n-        MirPhase::Const,\n-        &[&[\n+        &[\n             &add_moves_for_packed_drops::AddMovesForPackedDrops,\n             &remove_noop_landing_pads::RemoveNoopLandingPads,\n             &simplify::SimplifyCfg::new(\"make_shim\"),\n             &add_call_guards::CriticalCallEdges,\n             &abort_unwinding_calls::AbortUnwindingCalls,\n-        ]],\n+            &marker::PhaseChange(MirPhase::Const),\n+        ],\n     );\n \n     debug!(\"make_shim({:?}) = {:?}\", instance, result);"}]}