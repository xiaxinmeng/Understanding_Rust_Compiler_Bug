{"sha": "5f3c1412ad8224e0fea0bc2b4f67894619045c54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmM2MxNDEyYWQ4MjI0ZTBmZWEwYmMyYjRmNjc4OTQ2MTkwNDVjNTQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-02T19:52:50Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2015-08-06T13:54:40Z"}, "message": "use VariantDef instead of struct_fields", "tree": {"sha": "b8dfdae35aaccbc7cc5d9f4b34cdb17c96389f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8dfdae35aaccbc7cc5d9f4b34cdb17c96389f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f3c1412ad8224e0fea0bc2b4f67894619045c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f3c1412ad8224e0fea0bc2b4f67894619045c54", "html_url": "https://github.com/rust-lang/rust/commit/5f3c1412ad8224e0fea0bc2b4f67894619045c54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f3c1412ad8224e0fea0bc2b4f67894619045c54/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4816e60667596718682ae70f6c34fed03288e07b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4816e60667596718682ae70f6c34fed03288e07b", "html_url": "https://github.com/rust-lang/rust/commit/4816e60667596718682ae70f6c34fed03288e07b"}], "stats": {"total": 2333, "additions": 892, "deletions": 1441}, "files": [{"sha": "baa9750d311aa7e4bce913f0086f66a2069f2758", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -692,64 +692,6 @@ There's no easy fix for this, generally code will need to be refactored so that\n you no longer need to derive from `Super<Self>`.\n \"####,\n \n-E0079: r##\"\n-Enum variants which contain no data can be given a custom integer\n-representation. This error indicates that the value provided is not an integer\n-literal and is therefore invalid.\n-\n-For example, in the following code,\n-\n-```\n-enum Foo {\n-    Q = \"32\"\n-}\n-```\n-\n-we try to set the representation to a string.\n-\n-There's no general fix for this; if you can work with an integer then just set\n-it to one:\n-\n-```\n-enum Foo {\n-    Q = 32\n-}\n-```\n-\n-however if you actually wanted a mapping between variants and non-integer\n-objects, it may be preferable to use a method with a match instead:\n-\n-```\n-enum Foo { Q }\n-impl Foo {\n-    fn get_str(&self) -> &'static str {\n-        match *self {\n-            Foo::Q => \"32\",\n-        }\n-    }\n-}\n-```\n-\"##,\n-\n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate an\n-integer expression provided as an enum discriminant. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n E0109: r##\"\n You tried to give a type parameter to a type which doesn't need it. Erroneous\n code example:\n@@ -1937,6 +1879,5 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n-    E0370, // discriminant overflow\n     E0400  // overloaded derefs are not allowed in constants\n }"}, {"sha": "8233b6b2b2b6e7a61f4a16e3f5ce45442b6814c2", "filename": "src/librustc/middle/cast.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -58,15 +58,14 @@ pub enum CastKind {\n }\n \n impl<'tcx> CastTy<'tcx> {\n-    pub fn from_ty(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n-                   -> Option<CastTy<'tcx>> {\n+    pub fn from_ty(t: Ty<'tcx>) -> Option<CastTy<'tcx>> {\n         match t.sty {\n             ty::TyBool => Some(CastTy::Int(IntTy::Bool)),\n             ty::TyChar => Some(CastTy::Int(IntTy::Char)),\n             ty::TyInt(_) => Some(CastTy::Int(IntTy::I)),\n             ty::TyUint(u) => Some(CastTy::Int(IntTy::U(u))),\n             ty::TyFloat(_) => Some(CastTy::Float),\n-            ty::TyEnum(..) if t.is_c_like_enum(tcx) =>\n+            ty::TyEnum(d,_) if d.is_payloadfree() =>\n                 Some(CastTy::Int(IntTy::CEnum)),\n             ty::TyRawPtr(ref mt) => Some(CastTy::Ptr(mt)),\n             ty::TyRef(_, ref mt) => Some(CastTy::RPtr(mt)),"}, {"sha": "2c835b35cc20943ff4e560cca589bf3eccb02b24", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 33, "deletions": 59, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -237,9 +237,9 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                 if let ty::TyEnum(edef, _) = pat_ty.sty {\n                     let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n                     if let Some(DefLocal(_)) = def {\n-                        if cx.tcx.enum_variants(edef.did).iter().any(|variant|\n+                        if edef.variants.iter().any(|variant|\n                             variant.name == ident.node.name\n-                                && variant.args.is_empty()\n+                                && variant.kind() == VariantKind::Unit\n                         ) {\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n@@ -508,16 +508,10 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     let pat = match left_ty.sty {\n         ty::TyTuple(_) => ast::PatTup(pats.collect()),\n \n-        ty::TyEnum(cid, _) | ty::TyStruct(cid, _)  => {\n-            let (vid, is_structure) = match ctor {\n-                &Variant(vid) =>\n-                    (vid, cx.tcx.enum_variant_with_id(cid.did, vid).arg_names.is_some()),\n-                _ =>\n-                    (cid.did, !cid.struct_variant().is_tuple_struct())\n-            };\n-            if is_structure {\n-                let fields = cx.tcx.lookup_struct_fields(vid);\n-                let field_pats: Vec<_> = fields.into_iter()\n+        ty::TyEnum(adt, _) | ty::TyStruct(adt, _)  => {\n+            let v = adt.variant_of_ctor(ctor);\n+            if let VariantKind::Dict = v.kind() {\n+                let field_pats: Vec<_> = v.fields.iter()\n                     .zip(pats)\n                     .filter(|&(_, ref pat)| pat.node != ast::PatWild(ast::PatWildSingle))\n                     .map(|(field, pat)| Spanned {\n@@ -529,9 +523,9 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n                         }\n                     }).collect();\n                 let has_more_fields = field_pats.len() < pats_len;\n-                ast::PatStruct(def_to_path(cx.tcx, vid), field_pats, has_more_fields)\n+                ast::PatStruct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n             } else {\n-                ast::PatEnum(def_to_path(cx.tcx, vid), Some(pats.collect()))\n+                ast::PatEnum(def_to_path(cx.tcx, v.did), Some(pats.collect()))\n             }\n         }\n \n@@ -580,6 +574,15 @@ fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n     })\n }\n \n+impl<'tcx> ADTDef<'tcx> {\n+    fn variant_of_ctor(&'tcx self, ctor: &Constructor) -> &'tcx VariantDef<'tcx> {\n+        match ctor {\n+            &Variant(vid) => self.variant_with_id(vid),\n+            _ => self.struct_variant()\n+        }\n+    }\n+}\n+\n fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n                        left_ty: Ty, max_slice_length: usize) -> Option<Constructor> {\n     let used_constructors: Vec<Constructor> = rows.iter()\n@@ -594,7 +597,7 @@ fn missing_constructor(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n-fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n+fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n                     max_slice_length: usize) -> Vec<Constructor> {\n     match left_ty.sty {\n         ty::TyBool =>\n@@ -603,17 +606,11 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: Ty,\n         ty::TyRef(_, ty::TypeAndMut { ty, .. }) => match ty.sty {\n             ty::TySlice(_) =>\n                 range_inclusive(0, max_slice_length).map(|length| Slice(length)).collect(),\n-            _ => vec!(Single)\n+            _ => vec![Single]\n         },\n \n-        ty::TyEnum(edef, _) =>\n-            cx.tcx.enum_variants(edef.did)\n-                .iter()\n-                .map(|va| Variant(va.id))\n-                .collect(),\n-\n-        _ =>\n-            vec!(Single)\n+        ty::TyEnum(def, _) => def.variants.iter().map(|v| Variant(v.did)).collect(),\n+        _ => vec![Single]\n     }\n }\n \n@@ -804,7 +801,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n         ty::TyBox(_) => 1,\n@@ -817,13 +814,9 @@ pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usi\n             ty::TyStr => 0,\n             _ => 1\n         },\n-        ty::TyEnum(edef, _) => {\n-            match *ctor {\n-                Variant(id) => cx.tcx.enum_variant_with_id(edef.did, id).args.len(),\n-                _ => unreachable!()\n-            }\n+        ty::TyEnum(adt, _) | ty::TyStruct(adt, _) => {\n+            adt.variant_of_ctor(ctor).fields.len()\n         }\n-        ty::TyStruct(cdef, _) => cx.tcx.lookup_struct_fields(cdef.did).len(),\n         ty::TyArray(_, n) => n,\n         _ => 0\n     }\n@@ -902,39 +895,20 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n-            // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n-            let class_id = match def {\n-                DefConst(..) | DefAssociatedConst(..) =>\n-                    cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n-                                                    been rewritten\"),\n-                DefVariant(_, variant_id, _) => if *constructor == Variant(variant_id) {\n-                    Some(variant_id)\n-                } else {\n-                    None\n-                },\n-                _ => {\n-                    // Assume this is a struct.\n-                    match cx.tcx.node_id_to_type(pat_id).ty_to_def_id() {\n-                        None => {\n-                            cx.tcx.sess.span_bug(pat_span,\n-                                                 \"struct pattern wasn't of a \\\n-                                                  type with a def ID?!\")\n-                        }\n-                        Some(def_id) => Some(def_id),\n-                    }\n-                }\n-            };\n-            class_id.map(|variant_id| {\n-                let struct_fields = cx.tcx.lookup_struct_fields(variant_id);\n-                let args = struct_fields.iter().map(|sf| {\n+            let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n+            let variant = adt.variant_of_ctor(constructor);\n+            let def_variant = adt.variant_of_def(def);\n+            if variant.did == def_variant.did {\n+                Some(variant.fields.iter().map(|sf| {\n                     match pattern_fields.iter().find(|f| f.node.ident.name == sf.name) {\n                         Some(ref f) => &*f.node.pat,\n                         _ => DUMMY_WILD_PAT\n                     }\n-                }).collect();\n-                args\n-            })\n+                }).collect())\n+            } else {\n+                None\n+            }\n         }\n \n         ast::PatTup(ref args) =>"}, {"sha": "bd8a666ffecb22236983f722479afe9f78e92bdf", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -100,51 +100,32 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn handle_field_access(&mut self, lhs: &ast::Expr, name: ast::Name) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(def, _) => {\n-                let fields = self.tcx.lookup_struct_fields(def.did);\n-                let field_id = fields.iter()\n-                    .find(|field| field.name == name).unwrap().id;\n-                self.live_symbols.insert(field_id.node);\n-            },\n-            _ => ()\n+        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n+            self.live_symbols.insert(def.struct_variant().field_named(name).did.node);\n+        } else {\n+            self.tcx.sess.span_bug(lhs.span, \"named field access on non-struct\")\n         }\n     }\n \n     fn handle_tup_field_access(&mut self, lhs: &ast::Expr, idx: usize) {\n-        match self.tcx.expr_ty_adjusted(lhs).sty {\n-            ty::TyStruct(def, _) => {\n-                let fields = self.tcx.lookup_struct_fields(def.did);\n-                let field_id = fields[idx].id;\n-                self.live_symbols.insert(field_id.node);\n-            },\n-            _ => ()\n+        if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(lhs).sty {\n+            self.live_symbols.insert(def.struct_variant().fields[idx].did.node);\n         }\n     }\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n-            def::DefVariant(_, id, _) => id,\n-            _ => {\n-                match self.tcx.node_id_to_type(lhs.id).ty_to_def_id() {\n-                    None => {\n-                        self.tcx.sess.span_bug(lhs.span,\n-                                               \"struct pattern wasn't of a \\\n-                                                type with a def ID?!\")\n-                    }\n-                    Some(def_id) => def_id,\n-                }\n-            }\n+        let def = self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def();\n+        let pat_ty = self.tcx.node_id_to_type(lhs.id);\n+        let variant = match pat_ty.sty {\n+            ty::TyStruct(adt, _) | ty::TyEnum(adt, _) => adt.variant_of_def(def),\n+            _ => self.tcx.sess.span_bug(lhs.span, \"non-ADT in struct pattern\")\n         };\n-        let fields = self.tcx.lookup_struct_fields(id);\n         for pat in pats {\n             if let ast::PatWild(ast::PatWildSingle) = pat.node.pat.node {\n                 continue;\n             }\n-            let field_id = fields.iter()\n-                .find(|field| field.name == pat.node.ident.name).unwrap().id;\n-            self.live_symbols.insert(field_id.node);\n+            self.live_symbols.insert(variant.field_named(pat.node.ident.name).did.node);\n         }\n     }\n "}, {"sha": "8e827257f7e9e56872ccfcc70249fa10d516f8a1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -694,40 +694,36 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n-        let with_fields = match with_cmt.ty.sty {\n-            ty::TyStruct(def, substs) => {\n-                self.tcx().struct_fields(def.did, substs)\n-            }\n-            _ => {\n-                // the base expression should always evaluate to a\n-                // struct; however, when EUV is run during typeck, it\n-                // may not. This will generate an error earlier in typeck,\n-                // so we can just ignore it.\n-                if !self.tcx().sess.has_errors() {\n-                    self.tcx().sess.span_bug(\n-                        with_expr.span,\n-                        \"with expression doesn't evaluate to a struct\");\n+        if let ty::TyStruct(def, substs) = with_cmt.ty.sty {\n+            // Consume those fields of the with expression that are needed.\n+            for with_field in &def.struct_variant().fields {\n+                if !contains_field_named(with_field, fields) {\n+                    let cmt_field = self.mc.cat_field(\n+                        &*with_expr,\n+                        with_cmt.clone(),\n+                        with_field.name,\n+                        with_field.ty(self.tcx(), substs)\n+                    );\n+                    self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n                 }\n-                vec!()\n             }\n-        };\n-\n-        // Consume those fields of the with expression that are needed.\n-        for with_field in &with_fields {\n-            if !contains_field_named(with_field, fields) {\n-                let cmt_field = self.mc.cat_field(&*with_expr,\n-                                                  with_cmt.clone(),\n-                                                  with_field.name,\n-                                                  with_field.mt.ty);\n-                self.delegate_consume(with_expr.id, with_expr.span, cmt_field);\n+        } else {\n+            // the base expression should always evaluate to a\n+            // struct; however, when EUV is run during typeck, it\n+            // may not. This will generate an error earlier in typeck,\n+            // so we can just ignore it.\n+            if !self.tcx().sess.has_errors() {\n+                self.tcx().sess.span_bug(\n+                    with_expr.span,\n+                    \"with expression doesn't evaluate to a struct\");\n             }\n-        }\n+        };\n \n         // walk the with expression so that complex expressions\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: &ty::Field,\n+        fn contains_field_named(field: &ty::FieldDef,\n                                 fields: &Vec<ast::Field>)\n                                 -> bool\n         {\n@@ -1105,7 +1101,7 @@ impl<'d,'t,'a,'tcx> ExprUseVisitor<'d,'t,'a,'tcx> {\n \n                         Some(def::DefVariant(enum_did, variant_did, _is_struct)) => {\n                             let downcast_cmt =\n-                                if tcx.enum_is_univariant(enum_did) {\n+                                if tcx.lookup_adt_def(enum_did).is_univariant() {\n                                     cmt_pat\n                                 } else {\n                                     let cmt_pat_ty = cmt_pat.ty;"}, {"sha": "3ab0d4c04d73c3208ced509311338958c5ff05b5", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -1216,7 +1216,7 @@ impl<'t, 'a,'tcx> MemCategorizationContext<'t, 'a, 'tcx> {\n         let cmt = match opt_def {\n             Some(def::DefVariant(enum_did, variant_did, _))\n                 // univariant enums do not need downcasts\n-                if !self.tcx().enum_is_univariant(enum_did) => {\n+                if !self.tcx().lookup_adt_def(enum_did).is_univariant() => {\n                     self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                 }\n             _ => cmt"}, {"sha": "16f744b6887ab61051b6a68660b8b6ff6e7455da", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 42, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -415,32 +415,15 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n         ast::ExprField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => {\n-                    tcx.lookup_struct_fields(def.did)\n-                        .iter()\n-                        .find(|f| f.name == field.node.name)\n-                        .unwrap_or_else(|| {\n-                            tcx.sess.span_bug(field.span,\n-                                              \"stability::check_expr: unknown named field access\")\n-                        })\n-                        .id\n-                }\n+                ty::TyStruct(def, _) => def.struct_variant().field_named(field.node.name).did,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: named field access on non-struct\")\n             }\n         }\n         ast::ExprTupField(ref base_e, ref field) => {\n             span = field.span;\n             match tcx.expr_ty_adjusted(base_e).sty {\n-                ty::TyStruct(def, _) => {\n-                    tcx.lookup_struct_fields(def.did)\n-                        .get(field.node)\n-                        .unwrap_or_else(|| {\n-                            tcx.sess.span_bug(field.span,\n-                                              \"stability::check_expr: unknown unnamed field access\")\n-                        })\n-                        .id\n-                }\n+                ty::TyStruct(def, _) => def.struct_variant().fields[field.node].did,\n                 ty::TyTuple(..) => return,\n                 _ => tcx.sess.span_bug(e.span,\n                                        \"stability::check_expr: unnamed field access on \\\n@@ -451,19 +434,12 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n             let type_ = tcx.expr_ty(e);\n             match type_.sty {\n                 ty::TyStruct(def, _) => {\n-                    let struct_fields = tcx.lookup_struct_fields(def.did);\n                     // check the stability of each field that appears\n                     // in the construction expression.\n                     for field in expr_fields {\n-                        let did = struct_fields\n-                            .iter()\n-                            .find(|f| f.name == field.ident.node.name)\n-                            .unwrap_or_else(|| {\n-                                tcx.sess.span_bug(field.span,\n-                                                  \"stability::check_expr: unknown named \\\n-                                                   field access\")\n-                            })\n-                            .id;\n+                        let did = def.struct_variant()\n+                            .field_named(field.ident.node.name)\n+                            .did;\n                         maybe_do_stability_check(tcx, did, field.span, cb);\n                     }\n \n@@ -505,34 +481,26 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    let def = match tcx.pat_ty_opt(pat) {\n-        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) => def,\n+    let v = match tcx.pat_ty_opt(pat) {\n+        Some(&ty::TyS { sty: ty::TyStruct(def, _), .. }) => def.struct_variant(),\n         Some(_) | None => return,\n     };\n-    let struct_fields = tcx.lookup_struct_fields(def.did);\n     match pat.node {\n         // Foo(a, b, c)\n         ast::PatEnum(_, Some(ref pat_fields)) => {\n-            for (field, struct_field) in pat_fields.iter().zip(&struct_fields) {\n+            for (field, struct_field) in pat_fields.iter().zip(&v.fields) {\n                 // a .. pattern is fine, but anything positional is\n                 // not.\n                 if let ast::PatWild(ast::PatWildMulti) = field.node {\n                     continue\n                 }\n-                maybe_do_stability_check(tcx, struct_field.id, field.span, cb)\n+                maybe_do_stability_check(tcx, struct_field.did, field.span, cb)\n             }\n         }\n         // Foo { a, b, c }\n         ast::PatStruct(_, ref pat_fields, _) => {\n             for field in pat_fields {\n-                let did = struct_fields\n-                    .iter()\n-                    .find(|f| f.name == field.node.ident.name)\n-                    .unwrap_or_else(|| {\n-                        tcx.sess.span_bug(field.span,\n-                                          \"stability::check_pat: unknown named field access\")\n-                    })\n-                    .id;\n+                let did = v.field_named(field.node.ident.name).did;\n                 maybe_do_stability_check(tcx, did, field.span, cb);\n             }\n         }"}, {"sha": "0c9cf1a68b7320132a30ba1493491266ef848ee2", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -1721,21 +1721,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ok_if(substs.upvar_tys.clone())\n             }\n \n-            ty::TyStruct(def, substs) => {\n-                let types: Vec<Ty> =\n-                    self.tcx().struct_fields(def.did, substs).iter()\n-                                                             .map(|f| f.mt.ty)\n-                                                             .collect();\n-                nominal(bound, types)\n-            }\n-\n-            ty::TyEnum(def, substs) => {\n-                let types: Vec<Ty> =\n-                    self.tcx().substd_enum_variants(def.did, substs)\n-                    .iter()\n-                    .flat_map(|variant| &variant.args)\n-                    .cloned()\n-                    .collect();\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                let types: Vec<Ty> = def.all_fields().map(|f| {\n+                    f.ty(self.tcx(), substs)\n+                }).collect();\n                 nominal(bound, types)\n             }\n \n@@ -1865,18 +1854,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 substs.types.get_slice(TypeSpace).to_vec()\n             }\n \n-            ty::TyStruct(def, substs) => {\n-                self.tcx().struct_fields(def.did, substs)\n-                          .iter()\n-                          .map(|f| f.mt.ty)\n-                          .collect()\n-            }\n-\n-            ty::TyEnum(def, substs) => {\n-                self.tcx().substd_enum_variants(def.did, substs)\n-                    .iter()\n-                    .flat_map(|variant| &variant.args)\n-                    .map(|&ty| ty)\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n+                def.all_fields()\n+                    .map(|f| f.ty(self.tcx(), substs))\n                     .collect()\n             }\n         }\n@@ -2522,9 +2502,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             // Struct<T> -> Struct<U>.\n             (&ty::TyStruct(def, substs_a), &ty::TyStruct(_, substs_b)) => {\n-                let fields = tcx.lookup_struct_fields(def.did).iter().map(|f| {\n-                    tcx.lookup_field_type_unsubstituted(def.did, f.id)\n-                }).collect::<Vec<_>>();\n+                let fields = def\n+                    .all_fields()\n+                    .map(|f| f.unsubst_ty())\n+                    .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters.\n                 let field = if let Some(&field) = fields.last() {"}, {"sha": "d41ca44ceea5e666047e53bc36870f786a29acba", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 62, "deletions": 336, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -93,8 +93,6 @@ use syntax::ast_util::{self, is_local, local_def};\n use syntax::attr::{self, AttrMetaMethods, SignedInt, UnsignedInt};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n-use syntax::print::pprust;\n-use syntax::ptr::P;\n use syntax::ast;\n \n pub type Disr = u64;\n@@ -3061,21 +3059,19 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n \n         let adt = match self_type.sty {\n             ty::TyStruct(struct_def, substs) => {\n-                let fields = tcx.struct_fields(struct_def.did, substs);\n-                for field in &fields {\n-                    if infcx.type_moves_by_default(field.mt.ty, span) {\n+                for field in struct_def.all_fields() {\n+                    let field_ty = field.ty(tcx, substs);\n+                    if infcx.type_moves_by_default(field_ty, span) {\n                         return Err(FieldDoesNotImplementCopy(field.name))\n                     }\n                 }\n                 struct_def\n             }\n             ty::TyEnum(enum_def, substs) => {\n-                let enum_variants = tcx.enum_variants(enum_def.did);\n-                for variant in enum_variants.iter() {\n-                    for variant_arg_type in &variant.args {\n-                        let substd_arg_type =\n-                            variant_arg_type.subst(tcx, substs);\n-                        if infcx.type_moves_by_default(substd_arg_type, span) {\n+                for variant in &enum_def.variants {\n+                    for field in &variant.fields {\n+                        let field_ty = field.ty(tcx, substs);\n+                        if infcx.type_moves_by_default(field_ty, span) {\n                             return Err(VariantDoesNotImplementCopy(variant.name))\n                         }\n                     }\n@@ -4256,9 +4252,9 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_empty(&self, cx: &ctxt) -> bool {\n+    pub fn is_empty(&self, _cx: &ctxt) -> bool {\n         match self.sty {\n-            TyEnum(def, _) => cx.enum_variants(def.did).is_empty(),\n+            TyEnum(def, _) | TyStruct(def, _) => def.is_empty(),\n             _ => false\n         }\n     }\n@@ -4316,18 +4312,15 @@ impl<'tcx> TyS<'tcx> {\n     pub fn simd_type(&self, cx: &ctxt<'tcx>) -> Ty<'tcx> {\n         match self.sty {\n             TyStruct(def, substs) => {\n-                let fields = cx.lookup_struct_fields(def.did);\n-                cx.lookup_field_type(def.did, fields[0].id, substs)\n+                def.struct_variant().fields[0].ty(cx, substs)\n             }\n             _ => panic!(\"simd_type called on invalid type\")\n         }\n     }\n \n-    pub fn simd_size(&self, cx: &ctxt) -> usize {\n+    pub fn simd_size(&self, _cx: &ctxt) -> usize {\n         match self.sty {\n-            TyStruct(def, _) => {\n-                cx.lookup_struct_fields(def.did).len()\n-            }\n+            TyStruct(def, _) => def.struct_variant().fields.len(),\n             _ => panic!(\"simd_size called on invalid type\")\n         }\n     }\n@@ -4385,6 +4378,13 @@ impl<'tcx> TyS<'tcx> {\n             _ => None\n         }\n     }\n+\n+    pub fn ty_adt_def(&self) -> Option<&'tcx ADTDef<'tcx>> {\n+        match self.sty {\n+            TyStruct(adt, _) | TyEnum(adt, _) => Some(adt),\n+            _ => None\n+        }\n+    }\n }\n \n /// Type contents is how the type checker reasons about kinds.\n@@ -4587,18 +4587,6 @@ impl<'tcx> TyS<'tcx> {\n                 }\n                 TyStr => TC::None,\n \n-                TyStruct(def, substs) => {\n-                    let flds = cx.struct_fields(def.did, substs);\n-                    let mut res =\n-                        TypeContents::union(&flds[..],\n-                                            |f| tc_ty(cx, f.mt.ty, cache));\n-\n-                    if def.has_dtor(cx) {\n-                        res = res | TC::OwnsDtor;\n-                    }\n-                    apply_lang_items(cx, def.did, res)\n-                }\n-\n                 TyClosure(_, ref substs) => {\n                     TypeContents::union(&substs.upvar_tys, |ty| tc_ty(cx, &ty, cache))\n                 }\n@@ -4608,13 +4596,11 @@ impl<'tcx> TyS<'tcx> {\n                                         |ty| tc_ty(cx, *ty, cache))\n                 }\n \n-                TyEnum(def, substs) => {\n-                    let variants = cx.substd_enum_variants(def.did, substs);\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n                     let mut res =\n-                        TypeContents::union(&variants[..], |variant| {\n-                            TypeContents::union(&variant.args,\n-                                                |arg_ty| {\n-                                tc_ty(cx, *arg_ty, cache)\n+                        TypeContents::union(&def.variants, |v| {\n+                            TypeContents::union(&v.fields, |f| {\n+                                tc_ty(cx, f.ty(cx, substs), cache)\n                             })\n                         });\n \n@@ -4794,16 +4780,22 @@ impl<'tcx> TyS<'tcx> {\n                     false\n                 }\n \n-                TyStruct(ref did, _) if seen.contains(did) => {\n-                    false\n-                }\n-\n-                TyStruct(def, substs) => {\n-                    seen.push(def);\n-                    let fields = cx.struct_fields(def.did, substs);\n-                    let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n-                    seen.pop().unwrap();\n-                    r\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                    if seen.contains(&def) {\n+                        // FIXME(#27497) ???\n+                        false\n+                    } else if def.is_empty() {\n+                        // HACK: required for empty types to work. This\n+                        // check is basically a lint anyway.\n+                        false\n+                    } else {\n+                        seen.push(def);\n+                        let r = def.variants.iter().all(|v| v.fields.iter().any(|f| {\n+                            type_requires(cx, seen, r_ty, f.ty(cx, substs))\n+                        }));\n+                        seen.pop().unwrap();\n+                        r\n+                    }\n                 }\n \n                 TyError |\n@@ -4817,23 +4809,6 @@ impl<'tcx> TyS<'tcx> {\n                 TyTuple(ref ts) => {\n                     ts.iter().any(|ty| type_requires(cx, seen, r_ty, *ty))\n                 }\n-\n-                TyEnum(ref def, _) if seen.contains(def) => {\n-                    false\n-                }\n-\n-                TyEnum(def, substs) => {\n-                    seen.push(def);\n-                    let vs = cx.enum_variants(def.did);\n-                    let r = !vs.is_empty() && vs.iter().all(|variant| {\n-                        variant.args.iter().any(|aty| {\n-                            let sty = aty.subst(cx, substs);\n-                            type_requires(cx, seen, r_ty, sty)\n-                        })\n-                    });\n-                    seen.pop().unwrap();\n-                    r\n-                }\n             };\n \n             debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n@@ -4888,17 +4863,11 @@ impl<'tcx> TyS<'tcx> {\n                 TyArray(ty, _) => {\n                     is_type_structurally_recursive(cx, sp, seen, ty)\n                 }\n-                TyStruct(def, substs) => {\n-                    let fields = cx.struct_fields(def.did, substs);\n-                    find_nonrepresentable(cx, sp, seen, fields.iter().map(|f| f.mt.ty))\n-                }\n-                TyEnum(def, substs) => {\n-                    let vs = cx.enum_variants(def.did);\n-                    let iter = vs.iter()\n-                        .flat_map(|variant| &variant.args)\n-                        .map(|aty| { aty.subst_spanned(cx, substs, Some(sp)) });\n-\n-                    find_nonrepresentable(cx, sp, seen, iter)\n+                TyStruct(def, substs) | TyEnum(def, substs) => {\n+                    find_nonrepresentable(cx,\n+                                          sp,\n+                                          seen,\n+                                          def.all_fields().map(|f| f.ty(cx, substs)))\n                 }\n                 TyClosure(..) => {\n                     // this check is run on type definitions, so we don't expect\n@@ -5094,22 +5063,6 @@ impl<'tcx> TyS<'tcx> {\n         }\n     }\n \n-    // Whether a type is enum like, that is an enum type with only nullary\n-    // constructors\n-    pub fn is_c_like_enum(&self, cx: &ctxt) -> bool {\n-        match self.sty {\n-            TyEnum(def, _) => {\n-                let variants = cx.enum_variants(def.did);\n-                if variants.is_empty() {\n-                    false\n-                } else {\n-                    variants.iter().all(|v| v.args.is_empty())\n-                }\n-            }\n-            _ => false\n-        }\n-    }\n-\n     // Returns the type and mutability of *ty.\n     //\n     // The parameter `explicit` indicates if this is an *explicit* dereference.\n@@ -5508,27 +5461,18 @@ impl<'tcx> ctxt<'tcx> {\n                                  ty: Ty<'tcx>,\n                                  i: usize,\n                                  variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n-\n         match (&ty.sty, variant) {\n-            (&TyTuple(ref v), None) => v.get(i).cloned(),\n-\n-\n-            (&TyStruct(def, substs), None) => self.lookup_struct_fields(def.did)\n-                .get(i)\n-                .map(|&t| self.lookup_item_type(t.id).ty.subst(self, substs)),\n-\n-            (&TyEnum(def, substs), Some(variant_def_id)) => {\n-                let variant_info = self.enum_variant_with_id(def.did, variant_def_id);\n-                variant_info.args.get(i).map(|t|t.subst(self, substs))\n+            (&TyStruct(def, substs), None) => {\n+                def.struct_variant().fields.get(i).map(|f| f.ty(self, substs))\n+            }\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).fields.get(i).map(|f| f.ty(self, substs))\n             }\n-\n             (&TyEnum(def, substs), None) => {\n-                assert!(self.enum_is_univariant(def.did));\n-                let enum_variants = self.enum_variants(def.did);\n-                let variant_info = &enum_variants[0];\n-                variant_info.args.get(i).map(|t|t.subst(self, substs))\n+                assert!(def.is_univariant());\n+                def.variants[0].fields.get(i).map(|f| f.ty(self, substs))\n             }\n-\n+            (&TyTuple(ref v), None) => v.get(i).cloned(),\n             _ => None\n         }\n     }\n@@ -5539,22 +5483,14 @@ impl<'tcx> ctxt<'tcx> {\n                             ty: Ty<'tcx>,\n                             n: ast::Name,\n                             variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n-\n         match (&ty.sty, variant) {\n             (&TyStruct(def, substs), None) => {\n-                let r = self.lookup_struct_fields(def.did);\n-                r.iter().find(|f| f.name == n)\n-                    .map(|&f| self.lookup_field_type(def.did, f.id, substs))\n-            }\n-            (&TyEnum(def, substs), Some(variant_def_id)) => {\n-                let variant_info = self.enum_variant_with_id(def.did, variant_def_id);\n-                variant_info.arg_names.as_ref()\n-                    .expect(\"must have struct enum variant if accessing a named fields\")\n-                    .iter().zip(&variant_info.args)\n-                    .find(|&(&name, _)| name == n)\n-                    .map(|(_name, arg_t)| arg_t.subst(self, substs))\n+                def.struct_variant().find_field_named(n).map(|f| f.ty(self, substs))\n             }\n-            _ => None\n+            (&TyEnum(def, substs), Some(vid)) => {\n+                def.variant_with_id(vid).find_field_named(n).map(|f| f.ty(self, substs))\n+            }\n+            _ => return None\n         }\n     }\n \n@@ -6022,24 +5958,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn substd_enum_variants(&self,\n-                                id: ast::DefId,\n-                                substs: &Substs<'tcx>)\n-                                -> Vec<Rc<VariantInfo<'tcx>>> {\n-        self.enum_variants(id).iter().map(|variant_info| {\n-            let substd_args = variant_info.args.iter()\n-                .map(|aty| aty.subst(self, substs)).collect::<Vec<_>>();\n-\n-            let substd_ctor_ty = variant_info.ctor_ty.subst(self, substs);\n-\n-            Rc::new(VariantInfo {\n-                args: substd_args,\n-                ctor_ty: substd_ctor_ty,\n-                ..(**variant_info).clone()\n-            })\n-        }).collect()\n-    }\n-\n     pub fn item_path_str(&self, id: ast::DefId) -> String {\n         self.with_path(id, |path| ast_map::path_to_string(path))\n     }\n@@ -6066,10 +5984,6 @@ impl<'tcx> ctxt<'tcx> {\n         }\n     }\n \n-    pub fn enum_is_univariant(&self, id: ast::DefId) -> bool {\n-        self.enum_variants(id).len() == 1\n-    }\n-\n     /// Returns `(normalized_type, ty)`, where `normalized_type` is the\n     /// IntType representation of one of {i64,i32,i16,i8,u64,u32,u16,u8},\n     /// and `ty` is the original type (i.e. may include `isize` or\n@@ -6098,133 +6012,6 @@ impl<'tcx> ctxt<'tcx> {\n         (repr_type, repr_type_ty)\n     }\n \n-    fn report_discrim_overflow(&self,\n-                               variant_span: Span,\n-                               variant_name: &str,\n-                               repr_type: attr::IntType,\n-                               prev_val: Disr) {\n-        let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n-        let computed_value = repr_type.disr_string(computed_value);\n-        let prev_val = repr_type.disr_string(prev_val);\n-        let repr_type = repr_type.to_ty(self);\n-        span_err!(self.sess, variant_span, E0370,\n-                  \"enum discriminant overflowed on value after {}: {}; \\\n-                   set explicitly via {} = {} if that is desired outcome\",\n-                  prev_val, repr_type, variant_name, computed_value);\n-    }\n-\n-    // This computes the discriminant values for the sequence of Variants\n-    // attached to a particular enum, taking into account the #[repr] (if\n-    // any) provided via the `opt_hint`.\n-    fn compute_enum_variants(&self,\n-                             vs: &'tcx [P<ast::Variant>],\n-                             opt_hint: Option<&attr::ReprAttr>)\n-                             -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n-        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n-        let mut prev_disr_val: Option<ty::Disr> = None;\n-\n-        let (repr_type, repr_type_ty) = self.enum_repr_type(opt_hint);\n-\n-        for v in vs {\n-            // If the discriminant value is specified explicitly in the\n-            // enum, check whether the initialization expression is valid,\n-            // otherwise use the last value plus one.\n-            let current_disr_val;\n-\n-            // This closure marks cases where, when an error occurs during\n-            // the computation, attempt to assign a (hopefully) fresh\n-            // value to avoid spurious error reports downstream.\n-            let attempt_fresh_value = move || -> Disr {\n-                repr_type.disr_wrap_incr(prev_disr_val)\n-            };\n-\n-            match v.node.disr_expr {\n-                Some(ref e) => {\n-                    debug!(\"disr expr, checking {}\", pprust::expr_to_string(&**e));\n-\n-                    let hint = UncheckedExprHint(repr_type_ty);\n-                    match const_eval::eval_const_expr_partial(self, &**e, hint) {\n-                        Ok(ConstVal::Int(val)) => current_disr_val = val as Disr,\n-                        Ok(ConstVal::Uint(val)) => current_disr_val = val as Disr,\n-                        Ok(_) => {\n-                            let sign_desc = if repr_type.is_signed() {\n-                                \"signed\"\n-                            } else {\n-                                \"unsigned\"\n-                            };\n-                            span_err!(self.sess, e.span, E0079,\n-                                      \"expected {} integer constant\",\n-                                      sign_desc);\n-                            current_disr_val = attempt_fresh_value();\n-                        },\n-                        Err(ref err) => {\n-                            span_err!(self.sess, err.span, E0080,\n-                                      \"constant evaluation error: {}\",\n-                                      err.description());\n-                            current_disr_val = attempt_fresh_value();\n-                        },\n-                    }\n-                },\n-                None => {\n-                    current_disr_val = match prev_disr_val {\n-                        Some(prev_disr_val) => {\n-                            if let Some(v) = repr_type.disr_incr(prev_disr_val) {\n-                                v\n-                            } else {\n-                                self.report_discrim_overflow(v.span, &v.node.name.name.as_str(),\n-                                                             repr_type, prev_disr_val);\n-                                attempt_fresh_value()\n-                            }\n-                        }\n-                        None => ty::INITIAL_DISCRIMINANT_VALUE,\n-                    }\n-                },\n-            }\n-\n-            let variant_info = Rc::new(VariantInfo::from_ast_variant(self, &**v, current_disr_val));\n-            prev_disr_val = Some(current_disr_val);\n-\n-            variants.push(variant_info);\n-        }\n-\n-        variants\n-    }\n-\n-    pub fn enum_variants(&self, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo<'tcx>>>> {\n-        memoized(&self.enum_var_cache, id, |id: ast::DefId| {\n-            if ast::LOCAL_CRATE != id.krate {\n-                Rc::new(csearch::get_enum_variants(self, id))\n-            } else {\n-                match self.map.get(id.node) {\n-                    ast_map::NodeItem(ref item) => {\n-                        match item.node {\n-                            ast::ItemEnum(ref enum_definition, _) => {\n-                                Rc::new(self.compute_enum_variants(\n-                                    &enum_definition.variants,\n-                                    self.lookup_repr_hints(id).get(0)))\n-                            }\n-                            _ => {\n-                                self.sess.bug(\"enum_variants: id not bound to an enum\")\n-                            }\n-                        }\n-                    }\n-                    _ => self.sess.bug(\"enum_variants: id not bound to an enum\")\n-                }\n-            }\n-        })\n-    }\n-\n-    // Returns information about the enum variant with the given ID:\n-    pub fn enum_variant_with_id(&self,\n-                                enum_id: ast::DefId,\n-                                variant_id: ast::DefId)\n-                                -> Rc<VariantInfo<'tcx>> {\n-        self.enum_variants(enum_id).iter()\n-                                   .find(|variant| variant.id == variant_id)\n-                                   .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n-                                   .clone()\n-    }\n-\n     // Register a given item type\n     pub fn register_item_type(&self, did: ast::DefId, ty: TypeScheme<'tcx>) {\n         self.tcache.borrow_mut().insert(did, ty);\n@@ -6306,70 +6093,13 @@ impl<'tcx> ctxt<'tcx> {\n         })\n     }\n \n-    // Look up a field ID, whether or not it's local\n-    pub fn lookup_field_type_unsubstituted(&self,\n-                                           struct_id: DefId,\n-                                           id: DefId)\n-                                           -> Ty<'tcx> {\n-        if id.krate == ast::LOCAL_CRATE {\n-            self.node_id_to_type(id.node)\n-        } else {\n-            memoized(&self.tcache, id,\n-                     |id| csearch::get_field_type(self, struct_id, id)).ty\n-        }\n-    }\n-\n-\n-    // Look up a field ID, whether or not it's local\n-    // Takes a list of type substs in case the struct is generic\n-    pub fn lookup_field_type(&self,\n-                             struct_id: DefId,\n-                             id: DefId,\n-                             substs: &Substs<'tcx>)\n-                             -> Ty<'tcx> {\n-        self.lookup_field_type_unsubstituted(struct_id, id).subst(self, substs)\n-    }\n-\n-    // Look up the list of field names and IDs for a given struct or struct-variant.\n-    // Panics if the id is not bound to a struct.\n-    pub fn lookup_struct_fields(&self, did: ast::DefId) -> Vec<FieldTy> {\n-        if did.krate == ast::LOCAL_CRATE {\n-            let struct_fields = self.struct_fields.borrow();\n-            match struct_fields.get(&did) {\n-                Some(fields) => (**fields).clone(),\n-                _ => {\n-                    self.sess.bug(\n-                        &format!(\"ID not mapped to struct fields: {}\",\n-                                self.map.node_to_string(did.node)));\n-                }\n-            }\n-        } else {\n-            csearch::get_struct_fields(&self.sess.cstore, did)\n-        }\n-    }\n-\n-    // Returns a list of fields corresponding to the struct's items. trans uses\n-    // this. Takes a list of substs with which to instantiate field types.\n-    pub fn struct_fields(&self, did: ast::DefId, substs: &Substs<'tcx>)\n-                         -> Vec<Field<'tcx>> {\n-        self.lookup_struct_fields(did).iter().map(|f| {\n-           Field {\n-                name: f.name,\n-                mt: TypeAndMut {\n-                    ty: self.lookup_field_type(did, f.id, substs),\n-                    mutbl: MutImmutable\n-                }\n-            }\n-        }).collect()\n-    }\n-\n     /// Returns the deeply last field of nested structures, or the same type,\n     /// if not a structure at all. Corresponds to the only possible unsized\n     /// field, and its type can be used to determine unsizing strategy.\n     pub fn struct_tail(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n         while let TyStruct(def, substs) = ty.sty {\n-            match self.struct_fields(def.did, substs).last() {\n-                Some(f) => ty = f.mt.ty,\n+            match def.struct_variant().fields.last() {\n+                Some(f) => ty = f.ty(self, substs),\n                 None => break\n             }\n         }\n@@ -6390,13 +6120,9 @@ impl<'tcx> ctxt<'tcx> {\n             if a_def != b_def {\n                 break;\n             }\n-            if let Some(a_f) = self.struct_fields(a_def.did, a_substs).last() {\n-                if let Some(b_f) = self.struct_fields(b_def.did, b_substs).last() {\n-                    a = a_f.mt.ty;\n-                    b = b_f.mt.ty;\n-                } else {\n-                    break;\n-                }\n+            if let Some(f) = a_def.struct_variant().fields.last() {\n+                a = f.ty(self, a_substs);\n+                b = f.ty(self, b_substs);\n             } else {\n                 break;\n             }"}, {"sha": "e30b85919e281ebeeb1cba87f4ee34cf5997c5fa", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -438,11 +438,10 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyStruct(def, ref _substs), None) => {\n-            let fields = tcx.lookup_struct_fields(def.did);\n+        (&ty::TyStruct(def, _), None) => {\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n-                    for f in &fields {\n+                    for f in &def.struct_variant().fields {\n                         if f.name == ast_name {\n                             continue;\n                         }\n@@ -451,7 +450,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n                     }\n                 }\n                 mc::PositionalField(tuple_idx) => {\n-                    for (i, _f) in fields.iter().enumerate() {\n+                    for (i, _f) in def.struct_variant().fields.iter().enumerate() {\n                         if i == tuple_idx {\n                             continue\n                         }\n@@ -462,35 +461,26 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             }\n         }\n \n-        (&ty::TyEnum(enum_def, substs), ref enum_variant_info) => {\n-            let variant_info = {\n-                let mut variants = tcx.substd_enum_variants(enum_def.did, substs);\n-                match *enum_variant_info {\n-                    Some((variant_def_id, ref _lp2)) =>\n-                        variants.iter()\n-                        .find(|variant| variant.id == variant_def_id)\n-                        .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n-                        .clone(),\n-                    None => {\n-                        assert_eq!(variants.len(), 1);\n-                        variants.pop().unwrap()\n-                    }\n+        (&ty::TyEnum(def, _), ref enum_variant_info) => {\n+            let variant = match *enum_variant_info {\n+                Some((vid, ref _lp2)) => def.variant_with_id(vid),\n+                None => {\n+                    assert!(def.is_univariant());\n+                    &def.variants[0]\n                 }\n             };\n             match *origin_field_name {\n                 mc::NamedField(ast_name) => {\n-                    let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n-                    for &variant_arg_name in variant_arg_names {\n-                        if variant_arg_name == ast_name {\n+                    for field in &variant.fields {\n+                        if field.name == ast_name {\n                             continue;\n                         }\n-                        let field_name = mc::NamedField(variant_arg_name);\n-                        add_fragment_sibling_local(field_name, Some(variant_info.id));\n+                        let field_name = mc::NamedField(field.name);\n+                        add_fragment_sibling_local(field_name, Some(variant.did));\n                     }\n                 }\n                 mc::PositionalField(tuple_idx) => {\n-                    let variant_arg_types = &variant_info.args;\n-                    for (i, _variant_arg_ty) in variant_arg_types.iter().enumerate() {\n+                    for (i, _f) in variant.fields.iter().enumerate() {\n                         if tuple_idx == i {\n                             continue;\n                         }"}, {"sha": "695cfd43e14249b95cb2d1ec745539c564d0ce37", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -45,7 +45,6 @@ use std::collections::{HashSet, BitSet};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::{cmp, slice};\n use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n-use std::rc::Rc;\n \n use syntax::{abi, ast};\n use syntax::ast_util::{self, is_shift_binop, local_def};\n@@ -413,18 +412,23 @@ enum FfiResult {\n /// to function pointers and references, but could be\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n-fn is_repr_nullable_ptr<'tcx>(variants: &Vec<Rc<ty::VariantInfo<'tcx>>>) -> bool {\n-    if variants.len() == 2 {\n-        let mut data_idx = 0;\n-\n-        if variants[0].args.is_empty() {\n+fn is_repr_nullable_ptr<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                              def: &ty::ADTDef<'tcx>,\n+                              substs: &Substs<'tcx>)\n+                              -> bool {\n+    if def.variants.len() == 2 {\n+        let data_idx;\n+\n+        if def.variants[0].fields.is_empty() {\n             data_idx = 1;\n-        } else if !variants[1].args.is_empty() {\n+        } else if def.variants[1].fields.is_empty() {\n+            data_idx = 0;\n+        } else {\n             return false;\n         }\n \n-        if variants[data_idx].args.len() == 1 {\n-            match variants[data_idx].args[0].sty {\n+        if def.variants[data_idx].fields.len() == 1 {\n+            match def.variants[data_idx].fields[0].ty(tcx, substs).sty {\n                 ty::TyBareFn(None, _) => { return true; }\n                 ty::TyRef(..) => { return true; }\n                 _ => { }\n@@ -474,16 +478,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                 // We can't completely trust repr(C) markings; make sure the\n                 // fields are actually safe.\n-                let fields = cx.struct_fields(def.did, substs);\n-\n-                if fields.is_empty() {\n+                if def.struct_variant().fields.is_empty() {\n                     return FfiUnsafe(\n                         \"found zero-size struct in foreign module, consider \\\n                          adding a member to this struct\");\n                 }\n \n-                for field in fields {\n-                    let field_ty = infer::normalize_associated_type(cx, &field.mt.ty);\n+                for field in &def.struct_variant().fields {\n+                    let field_ty = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n                     let r = self.check_type_for_ffi(cache, field_ty);\n                     match r {\n                         FfiSafe => {}\n@@ -494,8 +496,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 FfiSafe\n             }\n             ty::TyEnum(def, substs) => {\n-                let variants = cx.substd_enum_variants(def.did, substs);\n-                if variants.is_empty() {\n+                if def.variants.is_empty() {\n                     // Empty enums are okay... although sort of useless.\n                     return FfiSafe\n                 }\n@@ -506,7 +507,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 match &**repr_hints {\n                     [] => {\n                         // Special-case types like `Option<extern fn()>`.\n-                        if !is_repr_nullable_ptr(&variants) {\n+                        if !is_repr_nullable_ptr(cx, def, substs) {\n                             return FfiUnsafe(\n                                 \"found enum without foreign-function-safe \\\n                                  representation annotation in foreign module, \\\n@@ -537,9 +538,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n \n                 // Check the contained variants.\n-                for variant in variants {\n-                    for arg in &variant.args {\n-                        let arg = infer::normalize_associated_type(cx, arg);\n+                for variant in &def.variants {\n+                    for field in &variant.fields {\n+                        let arg = infer::normalize_associated_type(cx, &field.ty(cx, substs));\n                         let r = self.check_type_for_ffi(cache, arg);\n                         match r {\n                             FfiSafe => {}"}, {"sha": "38eabd2e8c3c8ee16085530d1b1afc5bd06a40d3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 51, "deletions": 96, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -34,7 +34,6 @@ use self::FieldName::*;\n use std::mem::replace;\n \n use rustc::ast_map;\n-use rustc::metadata::csearch;\n use rustc::middle::def;\n use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n@@ -688,29 +687,26 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a field is in scope.\n     fn check_field(&mut self,\n                    span: Span,\n-                   id: ast::DefId,\n+                   def: &'tcx ty::ADTDef<'tcx>,\n+                   v: &'tcx ty::VariantDef<'tcx>,\n                    name: FieldName) {\n-        // TODO: refactor to variant API\n-        let fields = self.tcx.lookup_struct_fields(id);\n         let field = match name {\n             NamedField(f_name) => {\n-                debug!(\"privacy - check named field {} in struct {:?}\", f_name, id);\n-                fields.iter().find(|f| f.name == f_name).unwrap()\n+                debug!(\"privacy - check named field {} in struct {:?}\", f_name, def);\n+                v.field_named(f_name)\n             }\n-            UnnamedField(idx) => &fields[idx]\n+            UnnamedField(idx) => &v.fields[idx]\n         };\n         if field.vis == ast::Public ||\n-            (is_local(field.id) && self.private_accessible(field.id.node)) {\n+            (is_local(field.did) && self.private_accessible(field.did.node)) {\n             return\n         }\n \n-        let struct_type = self.tcx.lookup_item_type(id).ty;\n-        let struct_desc = match struct_type.sty {\n-            ty::TyStruct(_, _) =>\n-                format!(\"struct `{}`\", self.tcx.item_path_str(id)),\n+        let struct_desc = match def.adt_kind() {\n+            ty::ADTKind::Struct =>\n+                format!(\"struct `{}`\", self.tcx.item_path_str(def.did)),\n             // struct variant fields have inherited visibility\n-            ty::TyEnum(..) => return,\n-            _ => self.tcx.sess.span_bug(span, \"can't find struct for field\")\n+            ty::ADTKind::Enum => return\n         };\n         let msg = match name {\n             NamedField(name) => format!(\"field `{}` of {} is private\",\n@@ -885,12 +881,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprField(ref base, ident) => {\n                 if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n-                    self.check_field(expr.span, def.did, NamedField(ident.node.name));\n+                    self.check_field(expr.span,\n+                                     def,\n+                                     def.struct_variant(),\n+                                     NamedField(ident.node.name));\n                 }\n             }\n             ast::ExprTupField(ref base, idx) => {\n                 if let ty::TyStruct(def, _) = self.tcx.expr_ty_adjusted(&**base).sty {\n-                    self.check_field(expr.span, def.did, UnnamedField(idx.node));\n+                    self.check_field(expr.span,\n+                                     def,\n+                                     def.struct_variant(),\n+                                     UnnamedField(idx.node));\n                 }\n             }\n             ast::ExprMethodCall(ident, _, _) => {\n@@ -899,67 +901,36 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 debug!(\"(privacy checking) checking impl method\");\n                 self.check_method(expr.span, method.def_id, ident.node.name);\n             }\n-            ast::ExprStruct(_, ref fields, _) => {\n-                match self.tcx.expr_ty(expr).sty {\n-                    ty::TyStruct(ctor_def, _) => {\n-                        // RFC 736: ensure all unmentioned fields are visible.\n-                        // Rather than computing the set of unmentioned fields\n-                        // (i.e. `all_fields - fields`), just check them all.\n-                        let all_fields = self.tcx.lookup_struct_fields(ctor_def.did);\n-                        for field in all_fields {\n-                            self.check_field(expr.span, ctor_def.did,\n-                                             NamedField(field.name));\n-                        }\n-                    }\n-                    ty::TyEnum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n-                            def::DefVariant(_, variant_id, _) => {\n-                                for field in fields {\n-                                    self.check_field(expr.span, variant_id,\n-                                                     NamedField(field.ident.node.name));\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(expr.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         constructor to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(expr.span, \"struct expr \\\n-                                                            didn't have \\\n-                                                            struct type?!\"),\n+            ast::ExprStruct(..) => {\n+                let adt = self.tcx.expr_ty(expr).ty_adt_def().unwrap();\n+                let variant = adt.variant_of_def(self.tcx.resolve_expr(expr));\n+                // RFC 736: ensure all unmentioned fields are visible.\n+                // Rather than computing the set of unmentioned fields\n+                // (i.e. `all_fields - fields`), just check them all.\n+                for field in &variant.fields {\n+                    self.check_field(expr.span, adt, variant, NamedField(field.name));\n                 }\n             }\n             ast::ExprPath(..) => {\n-                let guard = |did: ast::DefId| {\n-                    let fields = self.tcx.lookup_struct_fields(did);\n-                    let any_priv = fields.iter().any(|f| {\n+\n+                if let def::DefStruct(_) = self.tcx.resolve_expr(expr) {\n+                    let expr_ty = self.tcx.expr_ty(expr);\n+                    let def = match expr_ty.sty {\n+                        ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+                            output: ty::FnConverging(ty), ..\n+                        }), ..}) => ty,\n+                        _ => expr_ty\n+                    }.ty_adt_def().unwrap();\n+                    let any_priv = def.struct_variant().fields.iter().any(|f| {\n                         f.vis != ast::Public && (\n-                            !is_local(f.id) ||\n-                            !self.private_accessible(f.id.node))\n-                    });\n+                            !is_local(f.did) ||\n+                                    !self.private_accessible(f.did.node))\n+                        });\n                     if any_priv {\n                         self.tcx.sess.span_err(expr.span,\n-                            \"cannot invoke tuple struct constructor \\\n-                             with private fields\");\n-                    }\n-                };\n-                match self.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n-                    Some(def::DefStruct(did)) => {\n-                        guard(if is_local(did) {\n-                            local_def(self.tcx.map.get_parent(did.node))\n-                        } else {\n-                            // \"tuple structs\" with zero fields (such as\n-                            // `pub struct Foo;`) don't have a ctor_id, hence\n-                            // the unwrap_or to the same struct id.\n-                            let maybe_did =\n-                                csearch::get_tuple_struct_definition_if_ctor(\n-                                    &self.tcx.sess.cstore, did);\n-                            maybe_did.unwrap_or(did)\n-                        })\n+                                               \"cannot invoke tuple struct constructor \\\n+                                                with private fields\");\n                     }\n-                    _ => {}\n                 }\n             }\n             _ => {}\n@@ -977,31 +948,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n \n         match pattern.node {\n             ast::PatStruct(_, ref fields, _) => {\n-                match self.tcx.pat_ty(pattern).sty {\n-                    ty::TyStruct(def, _) => {\n-                        for field in fields {\n-                            self.check_field(pattern.span, def.did,\n-                                             NamedField(field.node.ident.name));\n-                        }\n-                    }\n-                    ty::TyEnum(_, _) => {\n-                        match self.tcx.def_map.borrow().get(&pattern.id).map(|d| d.full_def()) {\n-                            Some(def::DefVariant(_, variant_id, _)) => {\n-                                for field in fields {\n-                                    self.check_field(pattern.span, variant_id,\n-                                                     NamedField(field.node.ident.name));\n-                                }\n-                            }\n-                            _ => self.tcx.sess.span_bug(pattern.span,\n-                                                        \"resolve didn't \\\n-                                                         map enum struct \\\n-                                                         pattern to a \\\n-                                                         variant def\"),\n-                        }\n-                    }\n-                    _ => self.tcx.sess.span_bug(pattern.span,\n-                                                \"struct pattern didn't have \\\n-                                                 struct type?!\"),\n+                let adt = self.tcx.pat_ty(pattern).ty_adt_def().unwrap();\n+                let def = self.tcx.def_map.borrow().get(&pattern.id).unwrap().full_def();\n+                let variant = adt.variant_of_def(def);\n+                for field in fields {\n+                    self.check_field(pattern.span, adt, variant,\n+                                     NamedField(field.node.ident.name));\n                 }\n             }\n \n@@ -1014,7 +966,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                             if let ast::PatWild(..) = field.node {\n                                 continue\n                             }\n-                            self.check_field(field.span, def.did, UnnamedField(i));\n+                            self.check_field(field.span,\n+                                             def,\n+                                             def.struct_variant(),\n+                                             UnnamedField(i));\n                         }\n                     }\n                     ty::TyEnum(..) => {"}, {"sha": "deef88fede7d12fbf220f3b4c796c9dc8c53bdec", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 31, "deletions": 49, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -742,6 +742,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n+                          variant: &ty::VariantDef,\n                           base: &Option<P<ast::Expr>>) {\n         if generated_code(path.span) {\n             return\n@@ -756,7 +757,6 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                              Some(struct_lit_data.span),\n                              struct_lit_data.ref_id,\n                              struct_lit_data.scope);\n-            let struct_def = struct_lit_data.ref_id;\n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n \n             for field in fields {\n@@ -765,7 +765,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 }\n \n                 let field_data = self.save_ctxt.get_field_ref_data(field,\n-                                                                   struct_def,\n+                                                                   variant,\n                                                                    scope);\n                 self.fmt.ref_str(recorder::VarRef,\n                                  field.ident.span,\n@@ -804,43 +804,24 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         match p.node {\n             ast::PatStruct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n+                let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n+                let def = self.tcx.def_map.borrow()[&p.id].full_def();\n+                let variant = adt.variant_of_def(def);\n \n-                let def = self.tcx.def_map.borrow().get(&p.id).unwrap().full_def();\n-                let struct_def = match def {\n-                    def::DefConst(..) | def::DefAssociatedConst(..) => None,\n-                    def::DefVariant(_, variant_id, _) => Some(variant_id),\n-                    _ => {\n-                        match self.tcx.node_id_to_type(p.id).ty_to_def_id() {\n-                            None => {\n-                                self.sess.span_bug(p.span,\n-                                                   &format!(\"Could not find struct_def for `{}`\",\n-                                                            self.span.snippet(p.span)));\n-                            }\n-                            Some(def_id) => Some(def_id),\n-                        }\n+                for &Spanned { node: ref field, span } in fields {\n+                    if generated_code(span) {\n+                        continue;\n                     }\n-                };\n \n-                if let Some(struct_def) = struct_def {\n-                    let struct_fields = self.tcx.lookup_struct_fields(struct_def);\n-                    for &Spanned { node: ref field, span } in fields {\n-                        if generated_code(span) {\n-                            continue;\n-                        }\n-\n-                        let sub_span = self.span.span_for_first_ident(span);\n-                        for f in &struct_fields {\n-                            if f.name == field.ident.name {\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                        self.visit_pat(&field.pat);\n+                    let sub_span = self.span.span_for_first_ident(span);\n+                    if let Some(f) = variant.find_field_named(field.ident.name) {\n+                        self.fmt.ref_str(recorder::VarRef,\n+                                         span,\n+                                         sub_span,\n+                                         f.did,\n+                                         self.cur_scope);\n                     }\n+                    self.visit_pat(&field.pat);\n                 }\n             }\n             _ => visit::walk_pat(self, p)\n@@ -1091,8 +1072,15 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 self.process_path(ex.id, path, None);\n                 visit::walk_expr(self, ex);\n             }\n-            ast::ExprStruct(ref path, ref fields, ref base) =>\n-                self.process_struct_lit(ex, path, fields, base),\n+            ast::ExprStruct(ref path, ref fields, ref base) => {\n+                let adt = self.tcx.expr_ty(ex).ty_adt_def().unwrap();\n+                let def = self.tcx.resolve_expr(ex);\n+                self.process_struct_lit(ex,\n+                                        path,\n+                                        fields,\n+                                        adt.variant_of_def(def),\n+                                        base)\n+            }\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n             ast::ExprField(ref sub_ex, _) => {\n                 if generated_code(sub_ex.span) {\n@@ -1120,18 +1108,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 let ty = &self.tcx.expr_ty_adjusted(&**sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n-                        let fields = self.tcx.lookup_struct_fields(def.did);\n-                        for (i, f) in fields.iter().enumerate() {\n-                            if i == idx.node {\n-                                let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n+                        let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n+                        self.fmt.ref_str(recorder::VarRef,\n+                                         ex.span,\n+                                         sub_span,\n+                                         def.struct_variant().fields[idx.node].did,\n+                                         self.cur_scope);\n                     }\n                     ty::TyTuple(_) => {}\n                     _ => self.sess.span_bug(ex.span,"}, {"sha": "78c224131f19ccecd414dcefa08adf9b20ee8ffe", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 17, "deletions": 33, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -448,22 +448,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 let ty = &self.tcx.expr_ty_adjusted(&sub_ex).sty;\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n-                        let fields = self.tcx.lookup_struct_fields(def.did);\n-                        for f in &fields {\n-                            if f.name == ident.node.name {\n-                                let sub_span = self.span_utils.span_for_last_ident(expr.span);\n-                                return Some(Data::VariableRefData(VariableRefData {\n-                                    name: ident.node.to_string(),\n-                                    span: sub_span.unwrap(),\n-                                    scope: self.enclosing_scope(expr.id),\n-                                    ref_id: f.id,\n-                                }));\n-                            }\n-                        }\n-\n-                        self.tcx.sess.span_bug(expr.span,\n-                                               &format!(\"Couldn't find field {} on {:?}\",\n-                                                        ident.node, ty))\n+                        let f = def.struct_variant().field_named(ident.node.name);\n+                        let sub_span = self.span_utils.span_for_last_ident(expr.span);\n+                        return Some(Data::VariableRefData(VariableRefData {\n+                            name: ident.node.to_string(),\n+                            span: sub_span.unwrap(),\n+                            scope: self.enclosing_scope(expr.id),\n+                            ref_id: f.did,\n+                        }));\n                     }\n                     _ => {\n                         debug!(\"Expected struct type, found {:?}\", ty);\n@@ -621,26 +613,18 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n-                              struct_id: DefId,\n+                              variant: &ty::VariantDef,\n                               parent: NodeId)\n                               -> VariableRefData {\n-        let fields = self.tcx.lookup_struct_fields(struct_id);\n-        let field_name = field_ref.ident.node.to_string();\n-        for f in &fields {\n-            if f.name == field_ref.ident.node.name {\n-                // We don't really need a sub-span here, but no harm done\n-                let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n-                return VariableRefData {\n-                    name: field_name,\n-                    span: sub_span.unwrap(),\n-                    scope: parent,\n-                    ref_id: f.id,\n-                };\n-            }\n+        let f = variant.field_named(field_ref.ident.node.name);\n+        // We don't really need a sub-span here, but no harm done\n+        let sub_span = self.span_utils.span_for_last_ident(field_ref.ident.span);\n+        VariableRefData {\n+            name: field_ref.ident.node.to_string(),\n+            span: sub_span.unwrap(),\n+            scope: parent,\n+            ref_id: f.did,\n         }\n-\n-        self.tcx.sess.span_bug(field_ref.span,\n-                               &format!(\"Couldn't find field {}\", field_name));\n     }\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {"}, {"sha": "bd7c67fa8bb8d4762f3bad8042bbf620230e9952", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -656,7 +656,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(def::DefVariant(enum_id, var_id, _)) => {\n-                        let variant = tcx.enum_variant_with_id(enum_id, var_id);\n+                        let variant = tcx.lookup_adt_def(enum_id).variant_with_id(var_id);\n                         Variant(variant.disr_val,\n                                 adt::represent_node(bcx, cur.id),\n                                 var_id,\n@@ -1190,10 +1190,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // The last field is technically unsized but\n                 // since we can only ever match that field behind\n                 // a reference we construct a fat ptr here.\n-                let fields = bcx.tcx().lookup_struct_fields(def.did);\n-                let unsized_ty = fields.iter().last().map(|field| {\n-                    let fty = bcx.tcx().lookup_field_type(def.did, field.id, substs);\n-                    monomorphize::normalize_associated_type(bcx.tcx(), &fty)\n+                let unsized_ty = def.struct_variant().fields.last().map(|field| {\n+                    monomorphize::field_ty(bcx.tcx(), substs, field)\n                 }).unwrap();\n                 let llty = type_of::type_of(bcx.ccx(), unsized_ty);\n                 let scratch = alloca_no_lifetime(bcx, llty, \"__struct_field_fat_ptr\");\n@@ -1833,7 +1831,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match opt_def {\n                 Some(def::DefVariant(enum_id, var_id, _)) => {\n                     let repr = adt::represent_node(bcx, pat.id);\n-                    let vinfo = ccx.tcx().enum_variant_with_id(enum_id, var_id);\n+                    let vinfo = ccx.tcx().lookup_adt_def(enum_id).variant_with_id(var_id);\n                     let args = extract_variant_args(bcx,\n                                                     &*repr,\n                                                     vinfo.disr_val,\n@@ -1877,21 +1875,20 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n             let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n-            expr::with_field_tys(tcx, pat_ty, Some(pat.id), |discr, field_tys| {\n-                for f in fields {\n-                    let ix = tcx.field_idx_strict(f.node.ident.name, field_tys);\n-                    let fldptr = adt::trans_field_ptr(\n-                        bcx,\n-                        &*pat_repr,\n-                        val.val,\n-                        discr,\n-                        ix);\n-                    bcx = bind_irrefutable_pat(bcx,\n-                                               &*f.node.pat,\n-                                               MatchInput::from_val(fldptr),\n-                                               cleanup_scope);\n-                }\n-            })\n+            let pat_v = VariantInfo::of_node(tcx, pat_ty, pat.id);\n+            for f in fields {\n+                let name = f.node.ident.name;\n+                let fldptr = adt::trans_field_ptr(\n+                    bcx,\n+                    &*pat_repr,\n+                    val.val,\n+                    pat_v.discr,\n+                    pat_v.field_index(name));\n+                bcx = bind_irrefutable_pat(bcx,\n+                                           &*f.node.pat,\n+                                           MatchInput::from_val(fldptr),\n+                                           cleanup_scope);\n+            }\n         }\n         ast::PatTup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);"}, {"sha": "9fb808a7d2d9340d8b7e35daddbfe45435ea0109", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -246,10 +246,8 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, &elems[..], false, t), 0)\n         }\n         ty::TyStruct(def, substs) => {\n-            let fields = cx.tcx().lookup_struct_fields(def.did);\n-            let mut ftys = fields.iter().map(|field| {\n-                let fty = cx.tcx().lookup_field_type(def.did, field.id, substs);\n-                monomorphize::normalize_associated_type(cx.tcx(), &fty)\n+            let mut ftys = def.struct_variant().fields.iter().map(|field| {\n+                monomorphize::field_ty(cx.tcx(), substs, field)\n             }).collect::<Vec<_>>();\n             let packed = cx.tcx().lookup_packed(def.did);\n             let dtor = cx.tcx().ty_dtor(def.did).has_drop_flag();\n@@ -263,7 +261,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             Univariant(mk_struct(cx, &substs.upvar_tys, false, t), 0)\n         }\n         ty::TyEnum(def, substs) => {\n-            let cases = get_cases(cx.tcx(), def.did, substs);\n+            let cases = get_cases(cx.tcx(), def, substs);\n             let hint = *cx.tcx().lookup_repr_hints(def.did).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n@@ -444,10 +442,10 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n         // Is this the NonZero lang item wrapping a pointer or integer type?\n         ty::TyStruct(def, substs) if Some(def.did) == tcx.lang_items.non_zero() => {\n-            let nonzero_fields = tcx.lookup_struct_fields(def.did);\n+            let nonzero_fields = &def.struct_variant().fields;\n             assert_eq!(nonzero_fields.len(), 1);\n-            let nonzero_field = tcx.lookup_field_type(def.did, nonzero_fields[0].id, substs);\n-            match nonzero_field.sty {\n+            let field_ty = monomorphize::field_ty(tcx, substs, &nonzero_fields[0]);\n+            match field_ty.sty {\n                 ty::TyRawPtr(ty::TypeAndMut { ty, .. }) if !type_is_sized(tcx, ty) => {\n                     path.push_all(&[0, FAT_PTR_ADDR]);\n                     Some(path)\n@@ -463,9 +461,9 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // Perhaps one of the fields of this struct is non-zero\n         // let's recurse and find out\n         ty::TyStruct(def, substs) => {\n-            let fields = tcx.lookup_struct_fields(def.did);\n-            for (j, field) in fields.iter().enumerate() {\n-                let field_ty = tcx.lookup_field_type(def.did, field.id, substs);\n+            for (j, field) in def.struct_variant().fields.iter().enumerate() {\n+                // TODO(#27532)\n+                let field_ty = field.ty(tcx, substs);\n                 if let Some(mut fpath) = find_discr_field_candidate(tcx, field_ty, path.clone()) {\n                     fpath.push(j);\n                     return Some(fpath);\n@@ -530,14 +528,14 @@ impl<'tcx> Case<'tcx> {\n }\n \n fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                   def_id: ast::DefId,\n+                   adt: &ty::ADTDef<'tcx>,\n                    substs: &subst::Substs<'tcx>)\n                    -> Vec<Case<'tcx>> {\n-    tcx.enum_variants(def_id).iter().map(|vi| {\n-        let arg_tys = vi.args.iter().map(|&raw_ty| {\n-            monomorphize::apply_param_substs(tcx, substs, &raw_ty)\n+    adt.variants.iter().map(|vi| {\n+        let field_tys = vi.fields.iter().map(|field| {\n+            monomorphize::field_ty(tcx, substs, field)\n         }).collect();\n-        Case { discr: vi.disr_val, tys: arg_tys }\n+        Case { discr: vi.disr_val, tys: field_tys }\n     }).collect()\n }\n "}, {"sha": "d119e0006c6616a59f70dfc71ee5cdd205e6cb6a", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -55,8 +55,8 @@ use trans::cleanup::{self, CleanupMethods, DropHint};\n use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n-use trans::common::{CrateContext, DropFlagHintsMap, FunctionContext};\n-use trans::common::{Result, NodeIdAndSpan};\n+use trans::common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n+use trans::common::{Result, NodeIdAndSpan, VariantInfo};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{type_is_immediate, type_is_zero_size, val_ty};\n use trans::common;\n@@ -386,7 +386,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     fn iter_variant<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    repr: &adt::Repr<'tcx>,\n                                    av: ValueRef,\n-                                   variant: &ty::VariantInfo<'tcx>,\n+                                   variant: &ty::VariantDef<'tcx>,\n                                    substs: &Substs<'tcx>,\n                                    f: &mut F)\n                                    -> Block<'blk, 'tcx> where\n@@ -396,8 +396,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n-        for (i, &arg) in variant.args.iter().enumerate() {\n-            let arg = monomorphize::apply_param_substs(tcx, substs, &arg);\n+        for (i, field) in variant.fields.iter().enumerate() {\n+            let arg = monomorphize::field_ty(tcx, substs, field);\n             cx = f(cx, adt::trans_field_ptr(cx, repr, av, variant.disr_val, i), arg);\n         }\n         return cx;\n@@ -415,22 +415,20 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n     match t.sty {\n       ty::TyStruct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n-              for (i, field_ty) in field_tys.iter().enumerate() {\n-                  let field_ty = field_ty.mt.ty;\n-                  let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n-\n-                  let val = if common::type_is_sized(cx.tcx(), field_ty) {\n-                      llfld_a\n-                  } else {\n-                      let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n-                      Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n-                      Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n-                      scratch.val\n-                  };\n-                  cx = f(cx, val, field_ty);\n-              }\n-          })\n+          let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+          for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n+              let llfld_a = adt::trans_field_ptr(cx, &*repr, data_ptr, discr, i);\n+\n+              let val = if common::type_is_sized(cx.tcx(), field_ty) {\n+                  llfld_a\n+              } else {\n+                  let scratch = datum::rvalue_scratch_datum(cx, field_ty, \"__fat_ptr_iter\");\n+                  Store(cx, llfld_a, GEPi(cx, scratch.val, &[0, abi::FAT_PTR_ADDR]));\n+                  Store(cx, info.unwrap(), GEPi(cx, scratch.val, &[0, abi::FAT_PTR_EXTRA]));\n+                  scratch.val\n+              };\n+              cx = f(cx, val, field_ty);\n+          }\n       }\n       ty::TyClosure(_, ref substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n@@ -460,8 +458,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           let ccx = fcx.ccx;\n \n           let repr = adt::represent_type(ccx, t);\n-          let variants = ccx.tcx().enum_variants(en.did);\n-          let n_variants = (*variants).len();\n+          let n_variants = en.variants.len();\n \n           // NB: we must hit the discriminant first so that structural\n           // comparison know not to proceed when the discriminants differ.\n@@ -470,7 +467,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               (_match::Single, None) => {\n                   if n_variants != 0 {\n                       assert!(n_variants == 1);\n-                      cx = iter_variant(cx, &*repr, av, &*(*variants)[0],\n+                      cx = iter_variant(cx, &*repr, av, &en.variants[0],\n                                         substs, &mut f);\n                   }\n               }\n@@ -496,7 +493,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                         n_variants);\n                   let next_cx = fcx.new_temp_block(\"enum-iter-next\");\n \n-                  for variant in &(*variants) {\n+                  for variant in &en.variants {\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               &format!(\"enum-iter-variant-{}\",\n@@ -513,7 +510,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                           iter_variant(variant_cx,\n                                        &*repr,\n                                        data_ptr,\n-                                       &**variant,\n+                                       variant,\n                                        substs,\n                                        &mut f);\n                       Br(variant_cx, next_cx.llbb, DebugLoc::None);\n@@ -1694,17 +1691,15 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    _enum_id: ast::NodeId,\n-                                    variant: &ast::Variant,\n-                                    _args: &[ast::VariantArg],\n+                                    ctor_id: ast::NodeId,\n                                     disr: ty::Disr,\n                                     param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n     trans_enum_variant_or_tuple_like_struct(\n         ccx,\n-        variant.node.id,\n+        ctor_id,\n         disr,\n         param_substs,\n         llfndecl);\n@@ -1776,7 +1771,6 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                    _fields: &[ast::StructField],\n                                     ctor_id: ast::NodeId,\n                                     param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {"}, {"sha": "d0d5b46ab2839087971ec28f57fed6d2d002ee21", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -182,10 +182,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 fn_callee(bcx, fn_datum)\n             }\n             def::DefVariant(tid, vid, _) => {\n-                let vinfo = bcx.tcx().enum_variant_with_id(tid, vid);\n-\n-                // Nullary variants are not callable\n-                assert!(!vinfo.args.is_empty());\n+                let vinfo = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n+                assert_eq!(vinfo.kind(), ty::VariantKind::Tuple);\n \n                 Callee {\n                     bcx: bcx,"}, {"sha": "15c81b114d307ce196dfd0c8bdb6c86bace5518c", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -49,6 +49,7 @@ use std::cell::{Cell, RefCell};\n use std::result::Result as StdResult;\n use std::vec::Vec;\n use syntax::ast;\n+use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -174,11 +175,9 @@ fn type_needs_drop_given_env<'a,'tcx>(cx: &ty::ctxt<'tcx>,\n fn type_is_newtype_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyStruct(def, substs) => {\n-            let fields = ccx.tcx().lookup_struct_fields(def.did);\n+            let fields = &def.struct_variant().fields;\n             fields.len() == 1 && {\n-                let ty = ccx.tcx().lookup_field_type(def.did, fields[0].id, substs);\n-                let ty = monomorphize::normalize_associated_type(ccx.tcx(), &ty);\n-                type_is_immediate(ccx, ty)\n+                type_is_immediate(ccx, monomorphize::field_ty(ccx.tcx(), substs, &fields[0]))\n             }\n         }\n         _ => false\n@@ -271,6 +270,67 @@ pub fn expr_info(expr: &ast::Expr) -> NodeIdAndSpan {\n     NodeIdAndSpan { id: expr.id, span: expr.span }\n }\n \n+/// The concrete version of ty::FieldDef. The name is the field index if\n+/// the field is numeric.\n+pub struct Field<'tcx>(pub ast::Name, pub Ty<'tcx>);\n+\n+/// The concrete version of ty::VariantDef\n+pub struct VariantInfo<'tcx> {\n+    pub discr: ty::Disr,\n+    pub fields: Vec<Field<'tcx>>\n+}\n+\n+impl<'tcx> VariantInfo<'tcx> {\n+    pub fn from_ty(tcx: &ty::ctxt<'tcx>,\n+                   ty: Ty<'tcx>,\n+                   opt_def: Option<def::Def>)\n+                   -> Self\n+    {\n+        match ty.sty {\n+            ty::TyStruct(adt, substs) | ty::TyEnum(adt, substs) => {\n+                let variant = match opt_def {\n+                    None => adt.struct_variant(),\n+                    Some(def) => adt.variant_of_def(def)\n+                };\n+\n+                VariantInfo {\n+                    discr: variant.disr_val,\n+                    fields: variant.fields.iter().map(|f| {\n+                        Field(f.name, monomorphize::field_ty(tcx, substs, f))\n+                    }).collect()\n+                }\n+            }\n+\n+            ty::TyTuple(ref v) => {\n+                VariantInfo {\n+                    discr: 0,\n+                    fields: v.iter().enumerate().map(|(i, &t)| {\n+                        Field(token::intern(&i.to_string()), t)\n+                    }).collect()\n+                }\n+            }\n+\n+            _ => {\n+                tcx.sess.bug(&format!(\n+                    \"cannot get field types from the type {:?}\",\n+                    ty));\n+            }\n+        }\n+    }\n+\n+    /// Return the variant corresponding to a given node (e.g. expr)\n+    pub fn of_node(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, id: ast::NodeId) -> Self {\n+        let node_def = tcx.def_map.borrow().get(&id).map(|v| v.full_def());\n+        Self::from_ty(tcx, ty, node_def)\n+    }\n+\n+    pub fn field_index(&self, name: ast::Name) -> usize {\n+        self.fields.iter().position(|&Field(n,_)| n == name).unwrap_or_else(|| {\n+            panic!(\"unknown field `{}`\", name)\n+        })\n+    }\n+}\n+\n pub struct BuilderRef_res {\n     pub b: BuilderRef,\n }\n@@ -1178,3 +1238,26 @@ pub fn langcall(bcx: Block,\n         }\n     }\n }\n+\n+/// Return the VariantDef corresponding to an inlined variant node\n+pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                     inlined_vid: ast::NodeId)\n+                                     -> &'tcx ty::VariantDef<'tcx>\n+{\n+\n+    let ctor_ty = ccx.tcx().node_id_to_type(inlined_vid);\n+    debug!(\"inlined_variant_def: ctor_ty={:?} inlined_vid={:?}\", ctor_ty,\n+           inlined_vid);\n+    let adt_def = match ctor_ty.sty {\n+        ty::TyBareFn(_, &ty::BareFnTy { sig: ty::Binder(ty::FnSig {\n+            output: ty::FnConverging(ty), ..\n+        }), ..}) => ty,\n+        _ => ctor_ty\n+    }.ty_adt_def().unwrap();\n+    adt_def.variants.iter().find(|v| {\n+        local_def(inlined_vid) == v.did ||\n+            ccx.external().borrow().get(&v.did) == Some(&Some(inlined_vid))\n+    }).unwrap_or_else(|| {\n+        ccx.sess().bug(&format!(\"no variant for {:?}::{}\", adt_def, inlined_vid))\n+    })\n+}"}, {"sha": "7a9ddf5a99cd4fe92634d5874760448407e397c2", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -579,17 +579,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast::ExprField(ref base, field) => {\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n             let brepr = adt::represent_type(cx, bt);\n-            expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n-                let ix = cx.tcx().field_idx_strict(field.node.name, field_tys);\n-                adt::const_get_field(cx, &*brepr, bv, discr, ix)\n-            })\n+            let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n+            let ix = vinfo.field_index(field.node.name);\n+            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, ix)\n         },\n         ast::ExprTupField(ref base, idx) => {\n             let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n             let brepr = adt::represent_type(cx, bt);\n-            expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n-                adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n-            })\n+            let vinfo = VariantInfo::from_ty(cx.tcx(), bt, None);\n+            adt::const_get_field(cx, &*brepr, bv, vinfo.discr, idx.node)\n         },\n \n         ast::ExprIndex(ref base, ref index) => {\n@@ -664,8 +662,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n             unsafe { match (\n-                CastTy::from_ty(cx.tcx(), t_expr).expect(\"bad input type for cast\"),\n-                CastTy::from_ty(cx.tcx(), t_cast).expect(\"bad output type for cast\"),\n+                CastTy::from_ty(t_expr).expect(\"bad input type for cast\"),\n+                CastTy::from_ty(t_cast).expect(\"bad output type for cast\"),\n             ) {\n                 (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n                     let repr = adt::represent_type(cx, t_expr);\n@@ -748,21 +746,19 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 None => None\n             };\n \n-            expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n-                let cs = field_tys.iter().enumerate()\n-                                  .map(|(ix, &field_ty)| {\n-                    match (fs.iter().find(|f| field_ty.name == f.ident.node.name), base_val) {\n-                        (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n-                        (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n-                        (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n-                    }\n-                }).collect::<Vec<_>>();\n-                if ety.is_simd(cx.tcx()) {\n-                    C_vector(&cs[..])\n-                } else {\n-                    adt::trans_const(cx, &*repr, discr, &cs[..])\n+            let VariantInfo { discr, fields } = VariantInfo::of_node(cx.tcx(), ety, e.id);\n+            let cs = fields.iter().enumerate().map(|(ix, &Field(f_name, _))| {\n+                match (fs.iter().find(|f| f_name == f.ident.node.name), base_val) {\n+                    (Some(ref f), _) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n+                    (_, Some((bv, _))) => adt::const_get_field(cx, &*repr, bv, discr, ix),\n+                    (_, None) => cx.sess().span_bug(e.span, \"missing struct field\"),\n                 }\n-            })\n+            }).collect::<Vec<_>>();\n+            if ety.is_simd(cx.tcx()) {\n+                C_vector(&cs[..])\n+            } else {\n+                adt::trans_const(cx, &*repr, discr, &cs[..])\n+            }\n         },\n         ast::ExprVec(ref es) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n@@ -806,14 +802,18 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n-                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n-                    if !vinfo.args.is_empty() {\n-                        // N-ary variant.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n-                    } else {\n-                        // Nullary variant.\n-                        let repr = adt::represent_type(cx, ety);\n-                        adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                    let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n+                    match vinfo.kind() {\n+                        ty::VariantKind::Unit => {\n+                            let repr = adt::represent_type(cx, ety);\n+                            adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n+                        }\n+                        ty::VariantKind::Tuple => {\n+                            expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n+                        }\n+                        ty::VariantKind::Dict => {\n+                            cx.sess().span_bug(e.span, \"path-expr refers to a dict variant!\")\n+                        }\n                     }\n                 }\n                 def::DefStruct(_) => {\n@@ -859,7 +859,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let repr = adt::represent_type(cx, ety);\n-                    let vinfo = cx.tcx().enum_variant_with_id(enum_did, variant_did);\n+                    let vinfo = cx.tcx().lookup_adt_def(enum_did).variant_with_id(variant_did);\n                     adt::trans_const(cx,\n                                      &*repr,\n                                      vinfo.disr_val,"}, {"sha": "98188a40e10364d6fc775910de6949167a3dcf90", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -44,7 +44,7 @@ use std::rc::Rc;\n use syntax::util::interner::Interner;\n use syntax::codemap::Span;\n use syntax::{ast, codemap, ast_util};\n-use syntax::parse::token::{self, special_idents};\n+use syntax::parse::token;\n \n \n const DW_LANG_RUST: c_uint = 0x9000;\n@@ -784,11 +784,9 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n-        ty::TyStruct(def, substs) => {\n+        ty::TyStruct(..) => {\n             prepare_struct_metadata(cx,\n                                     t,\n-                                    def.did,\n-                                    substs,\n                                     unique_type_id,\n                                     usage_site_span).finalize(cx)\n         }\n@@ -1096,42 +1094,49 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n-    fields: Vec<ty::Field<'tcx>>,\n+    variant: &'tcx ty::VariantDef<'tcx>,\n+    substs: &'tcx subst::Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n }\n \n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if self.fields.is_empty() {\n+        if let ty::VariantKind::Unit = self.variant.kind() {\n             return Vec::new();\n         }\n \n         let field_size = if self.is_simd {\n-            machine::llsize_of_alloc(cx, type_of::type_of(cx, self.fields[0].mt.ty)) as usize\n+            let fty = monomorphize::field_ty(cx.tcx(),\n+                                             self.substs,\n+                                             &self.variant.fields[0]);\n+            Some(machine::llsize_of_alloc(\n+                cx,\n+                type_of::type_of(cx, fty)\n+            ) as usize)\n         } else {\n-            0xdeadbeef\n+            None\n         };\n \n-        self.fields.iter().enumerate().map(|(i, field)| {\n-            let name = if field.name == special_idents::unnamed_field.name {\n+        self.variant.fields.iter().enumerate().map(|(i, f)| {\n+            let name = if let ty::VariantKind::Tuple = self.variant.kind() {\n                 format!(\"__{}\", i)\n             } else {\n-                field.name.to_string()\n+                f.name.to_string()\n             };\n+            let fty = monomorphize::field_ty(cx.tcx(), self.substs, f);\n \n             let offset = if self.is_simd {\n-                assert!(field_size != 0xdeadbeef);\n-                FixedMemberOffset { bytes: i * field_size }\n+                FixedMemberOffset { bytes: i * field_size.unwrap() }\n             } else {\n                 ComputedMemberOffset\n             };\n \n             MemberDescription {\n                 name: name,\n-                llvm_type: type_of::type_of(cx, field.mt.ty),\n-                type_metadata: type_metadata(cx, field.mt.ty, self.span),\n+                llvm_type: type_of::type_of(cx, fty),\n+                type_metadata: type_metadata(cx, fty, self.span),\n                 offset: offset,\n                 flags: FLAGS_NONE,\n             }\n@@ -1142,38 +1147,34 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n \n fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      struct_type: Ty<'tcx>,\n-                                     def_id: ast::DefId,\n-                                     substs: &subst::Substs<'tcx>,\n                                      unique_type_id: UniqueTypeId,\n                                      span: Span)\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n     let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n-    let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n+    let (variant, substs) = match struct_type.sty {\n+        ty::TyStruct(def, substs) => (def.struct_variant(), substs),\n+        _ => cx.tcx().sess.bug(\"prepare_struct_metadata on a non-struct\")\n+    };\n+\n+    let (containing_scope, _) = get_namespace_and_span_for_item(cx, variant.did);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n                                                   &struct_name,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n-    let mut fields = cx.tcx().struct_fields(def_id, substs);\n-\n-    // The `Ty` values returned by `ty::struct_fields` can still contain\n-    // `TyProjection` variants, so normalize those away.\n-    for field in &mut fields {\n-        field.mt.ty = monomorphize::normalize_associated_type(cx.tcx(), &field.mt.ty);\n-    }\n-\n     create_and_register_recursive_type_forward_declaration(\n         cx,\n         struct_type,\n         unique_type_id,\n         struct_metadata_stub,\n         struct_llvm_type,\n         StructMDF(StructMemberDescriptionFactory {\n-            fields: fields,\n+            variant: variant,\n+            substs: substs,\n             is_simd: struct_type.is_simd(cx.tcx()),\n             span: span,\n         })\n@@ -1248,7 +1249,6 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n     type_rep: Rc<adt::Repr<'tcx>>,\n-    variants: Rc<Vec<Rc<ty::VariantInfo<'tcx>>>>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1258,11 +1258,11 @@ struct EnumMemberDescriptionFactory<'tcx> {\n impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n+        let adt = &self.enum_type.ty_adt_def().unwrap();\n         match *self.type_rep {\n             adt::General(_, ref struct_defs, _) => {\n                 let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n                     .expect(\"\"));\n-\n                 struct_defs\n                     .iter()\n                     .enumerate()\n@@ -1273,7 +1273,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n-                                                  &*self.variants[i],\n+                                                  &adt.variants[i],\n                                                   discriminant_info,\n                                                   self.containing_scope,\n                                                   self.span);\n@@ -1295,9 +1295,9 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }).collect()\n             },\n             adt::Univariant(ref struct_def, _) => {\n-                assert!(self.variants.len() <= 1);\n+                assert!(adt.variants.len() <= 1);\n \n-                if self.variants.is_empty() {\n+                if adt.variants.is_empty() {\n                     vec![]\n                 } else {\n                     let (variant_type_metadata,\n@@ -1306,7 +1306,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               struct_def,\n-                                              &*self.variants[0],\n+                                              &adt.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n                                               self.span);\n@@ -1335,7 +1335,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n-                let non_null_variant = &self.variants[non_null_variant_index as usize];\n+                let non_null_variant = &adt.variants[non_null_variant_index as usize];\n                 let non_null_variant_name = non_null_variant.name.as_str();\n \n                 // The llvm type and metadata of the pointer\n@@ -1350,9 +1350,12 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // For the metadata of the wrapper struct, we need to create a\n                 // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n-                    name: match non_null_variant.arg_names {\n-                        Some(ref names) => names[0].to_string(),\n-                        None => \"__0\".to_string()\n+                    name: match non_null_variant.kind() {\n+                        ty::VariantKind::Tuple => \"__0\".to_string(),\n+                        ty::VariantKind::Dict => {\n+                            non_null_variant.fields[0].name.to_string()\n+                        }\n+                        ty::VariantKind::Unit => unreachable!()\n                     },\n                     llvm_type: non_null_llvm_type,\n                     type_metadata: non_null_type_metadata,\n@@ -1381,7 +1384,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as usize;\n-                let null_variant_name = self.variants[null_variant_index].name;\n+                let null_variant_name = adt.variants[null_variant_index].name;\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 0,\n                                                 null_variant_name);\n@@ -1406,7 +1409,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     describe_enum_variant(cx,\n                                           self.enum_type,\n                                           struct_def,\n-                                          &*self.variants[nndiscr as usize],\n+                                          &adt.variants[nndiscr as usize],\n                                           OptimizedDiscriminant,\n                                           self.containing_scope,\n                                           self.span);\n@@ -1422,7 +1425,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 // Encode the information about the null variant in the union\n                 // member's name.\n                 let null_variant_index = (1 - nndiscr) as usize;\n-                let null_variant_name = self.variants[null_variant_index].name;\n+                let null_variant_name = adt.variants[null_variant_index].name;\n                 let discrfield = discrfield.iter()\n                                            .skip(1)\n                                            .map(|x| x.to_string())\n@@ -1486,7 +1489,7 @@ enum EnumDiscriminantInfo {\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    struct_def: &adt::Struct<'tcx>,\n-                                   variant_info: &ty::VariantInfo<'tcx>,\n+                                   variant: &ty::VariantDef<'tcx>,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n@@ -1500,7 +1503,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n-    let variant_name = variant_info.name.as_str();\n+    let variant_name = variant.name.as_str();\n     let unique_type_id = debug_context(cx).type_map\n                                           .borrow_mut()\n                                           .get_unique_type_id_of_enum_variant(\n@@ -1515,18 +1518,20 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                            containing_scope);\n \n     // Get the argument names from the enum variant info\n-    let mut arg_names: Vec<_> = match variant_info.arg_names {\n-        Some(ref names) => {\n-            names.iter()\n-                 .map(|name| name.to_string())\n-                 .collect()\n+    let mut arg_names: Vec<_> = match variant.kind() {\n+        ty::VariantKind::Unit => vec![],\n+        ty::VariantKind::Tuple => {\n+            variant.fields\n+                   .iter()\n+                   .enumerate()\n+                   .map(|(i, _)| format!(\"__{}\", i))\n+                   .collect()\n         }\n-        None => {\n-            variant_info.args\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(i, _)| format!(\"__{}\", i))\n-                        .collect()\n+        ty::VariantKind::Dict => {\n+            variant.fields\n+                   .iter()\n+                   .map(|f| f.name.to_string())\n+                   .collect()\n         }\n     };\n \n@@ -1569,7 +1574,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let loc = span_start(cx, definition_span);\n     let file_metadata = file_metadata(cx, &loc.file.name);\n \n-    let variants = cx.tcx().enum_variants(enum_def_id);\n+    let variants = &enum_type.ty_adt_def().unwrap().variants;\n \n     let enumerators_metadata: Vec<DIDescriptor> = variants\n         .iter()\n@@ -1671,7 +1676,6 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type: enum_type,\n             type_rep: type_rep.clone(),\n-            variants: variants,\n             discriminant_type_metadata: discriminant_type_metadata,\n             containing_scope: containing_scope,\n             file_metadata: file_metadata,"}, {"sha": "baf14df5b804dffe6f3fe7ef47dee5b145a27431", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 57, "deletions": 135, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -68,7 +68,6 @@ use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::glue;\n use trans::machine;\n use trans::meth;\n-use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n use middle::cast::{CastKind, CastTy};\n@@ -708,43 +707,42 @@ fn trans_field<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                               base: &ast::Expr,\n                               get_idx: F)\n                               -> DatumBlock<'blk, 'tcx, Expr> where\n-    F: FnOnce(&'blk ty::ctxt<'tcx>, &[ty::Field<'tcx>]) -> usize,\n+    F: FnOnce(&'blk ty::ctxt<'tcx>, &VariantInfo<'tcx>) -> usize,\n {\n     let mut bcx = bcx;\n     let _icx = push_ctxt(\"trans_rec_field\");\n \n     let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, base, \"field\"));\n     let bare_ty = base_datum.ty;\n     let repr = adt::represent_type(bcx.ccx(), bare_ty);\n-    with_field_tys(bcx.tcx(), bare_ty, None, move |discr, field_tys| {\n-        let ix = get_idx(bcx.tcx(), field_tys);\n-        let d = base_datum.get_element(\n-            bcx,\n-            field_tys[ix].mt.ty,\n-            |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, ix));\n-\n-        if type_is_sized(bcx.tcx(), d.ty) {\n-            DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n-        } else {\n-            let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n-            Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n-            let info = Load(bcx, get_len(bcx, base_datum.val));\n-            Store(bcx, info, get_len(bcx, scratch.val));\n+    let vinfo = VariantInfo::from_ty(bcx.tcx(), bare_ty, None);\n \n-            // Always generate an lvalue datum, because this pointer doesn't own\n-            // the data and cleanup is scheduled elsewhere.\n-            DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n-        }\n-    })\n+    let ix = get_idx(bcx.tcx(), &vinfo);\n+    let d = base_datum.get_element(\n+        bcx,\n+        vinfo.fields[ix].1,\n+        |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, vinfo.discr, ix));\n \n+    if type_is_sized(bcx.tcx(), d.ty) {\n+        DatumBlock { datum: d.to_expr_datum(), bcx: bcx }\n+    } else {\n+        let scratch = rvalue_scratch_datum(bcx, d.ty, \"\");\n+        Store(bcx, d.val, get_dataptr(bcx, scratch.val));\n+        let info = Load(bcx, get_len(bcx, base_datum.val));\n+        Store(bcx, info, get_len(bcx, scratch.val));\n+\n+        // Always generate an lvalue datum, because this pointer doesn't own\n+        // the data and cleanup is scheduled elsewhere.\n+        DatumBlock::new(bcx, Datum::new(scratch.val, scratch.ty, LvalueExpr(d.kind)))\n+    }\n }\n \n /// Translates `base.field`.\n fn trans_rec_field<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                base: &ast::Expr,\n                                field: ast::Name)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n-    trans_field(bcx, base, |tcx, field_tys| tcx.field_idx_strict(field, field_tys))\n+    trans_field(bcx, base, |_, vinfo| vinfo.field_index(field))\n }\n \n /// Translates `base.<idx>`.\n@@ -1249,8 +1247,8 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match def {\n         def::DefVariant(tid, vid, _) => {\n-            let variant_info = bcx.tcx().enum_variant_with_id(tid, vid);\n-            if !variant_info.args.is_empty() {\n+            let variant = bcx.tcx().lookup_adt_def(tid).variant_with_id(vid);\n+            if let ty::VariantKind::Tuple = variant.kind() {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n                                                 ExprId(ref_expr.id),\n@@ -1261,8 +1259,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 // Nullary variant.\n                 let ty = expr_ty(bcx, ref_expr);\n                 let repr = adt::represent_type(bcx.ccx(), ty);\n-                adt::trans_set_discr(bcx, &*repr, lldest,\n-                                     variant_info.disr_val);\n+                adt::trans_set_discr(bcx, &*repr, lldest, variant.disr_val);\n                 return bcx;\n             }\n         }\n@@ -1362,71 +1359,6 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Helper for enumerating the field types of structs, enums, or records. The optional node ID here\n-/// is the node ID of the path identifying the enum variant in use. If none, this cannot possibly\n-/// an enum variant (so, if it is and `node_id_opt` is none, this function panics).\n-pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  node_id_opt: Option<ast::NodeId>,\n-                                  op: F)\n-                                  -> R where\n-    F: FnOnce(ty::Disr, &[ty::Field<'tcx>]) -> R,\n-{\n-    match ty.sty {\n-        ty::TyStruct(def, substs) => {\n-            let fields = tcx.struct_fields(def.did, substs);\n-            let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-            op(0, &fields[..])\n-        }\n-\n-        ty::TyTuple(ref v) => {\n-            let fields: Vec<_> = v.iter().enumerate().map(|(i, &f)| {\n-                ty::Field {\n-                    name: token::intern(&i.to_string()),\n-                    mt: ty::TypeAndMut {\n-                        ty: f,\n-                        mutbl: ast::MutImmutable\n-                    }\n-                }\n-            }).collect();\n-            op(0, &fields)\n-        }\n-\n-        ty::TyEnum(_, substs) => {\n-            // We want the *variant* ID here, not the enum ID.\n-            match node_id_opt {\n-                None => {\n-                    tcx.sess.bug(&format!(\n-                        \"cannot get field types from the enum type {:?} \\\n-                         without a node ID\",\n-                        ty));\n-                }\n-                Some(node_id) => {\n-                    let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n-                    match def {\n-                        def::DefVariant(enum_id, variant_id, _) => {\n-                            let variant_info = tcx.enum_variant_with_id(enum_id, variant_id);\n-                            let fields = tcx.struct_fields(variant_id, substs);\n-                            let fields = monomorphize::normalize_associated_type(tcx, &fields);\n-                            op(variant_info.disr_val, &fields[..])\n-                        }\n-                        _ => {\n-                            tcx.sess.bug(\"resolve didn't map this expr to a \\\n-                                          variant ID\")\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        _ => {\n-            tcx.sess.bug(&format!(\n-                \"cannot get field types from the type {:?}\",\n-                ty));\n-        }\n-    }\n-}\n-\n fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                             fields: &[ast::Field],\n                             base: Option<&ast::Expr>,\n@@ -1437,52 +1369,42 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_rec\");\n \n     let tcx = bcx.tcx();\n-    with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n-        let mut need_base = vec![true; field_tys.len()];\n-\n-        let numbered_fields = fields.iter().map(|field| {\n-            let opt_pos =\n-                field_tys.iter().position(|field_ty|\n-                                          field_ty.name == field.ident.node.name);\n-            let result = match opt_pos {\n-                Some(i) => {\n-                    need_base[i] = false;\n-                    (i, &*field.expr)\n-                }\n-                None => {\n-                    tcx.sess.span_bug(field.span,\n-                                      \"Couldn't find field in struct type\")\n+    let vinfo = VariantInfo::of_node(tcx, ty, expr_id);\n+\n+    let mut need_base = vec![true; vinfo.fields.len()];\n+\n+    let numbered_fields = fields.iter().map(|field| {\n+        let pos = vinfo.field_index(field.ident.node.name);\n+        need_base[pos] = false;\n+        (pos, &*field.expr)\n+    }).collect::<Vec<_>>();\n+\n+    let optbase = match base {\n+        Some(base_expr) => {\n+            let mut leftovers = Vec::new();\n+            for (i, b) in need_base.iter().enumerate() {\n+                if *b {\n+                    leftovers.push((i, vinfo.fields[i].1));\n                 }\n-            };\n-            result\n-        }).collect::<Vec<_>>();\n-        let optbase = match base {\n-            Some(base_expr) => {\n-                let mut leftovers = Vec::new();\n-                for (i, b) in need_base.iter().enumerate() {\n-                    if *b {\n-                        leftovers.push((i, field_tys[i].mt.ty));\n-                    }\n-                }\n-                Some(StructBaseInfo {expr: base_expr,\n-                                     fields: leftovers })\n             }\n-            None => {\n-                if need_base.iter().any(|b| *b) {\n-                    tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n-                }\n-                None\n+            Some(StructBaseInfo {expr: base_expr,\n+                                 fields: leftovers })\n+        }\n+        None => {\n+            if need_base.iter().any(|b| *b) {\n+                tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n             }\n-        };\n+            None\n+        }\n+    };\n \n-        trans_adt(bcx,\n-                  ty,\n-                  discr,\n-                  &numbered_fields,\n-                  optbase,\n-                  dest,\n-                  DebugLoc::At(expr_id, expr_span))\n-    })\n+    trans_adt(bcx,\n+              ty,\n+              vinfo.discr,\n+              &numbered_fields,\n+              optbase,\n+              dest,\n+              DebugLoc::At(expr_id, expr_span))\n }\n \n /// Information that `trans_adt` needs in order to fill in the fields\n@@ -2126,8 +2048,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    let r_t_in = CastTy::from_ty(bcx.tcx(), t_in).expect(\"bad input type for cast\");\n-    let r_t_out = CastTy::from_ty(bcx.tcx(), t_out).expect(\"bad output type for cast\");\n+    let r_t_in = CastTy::from_ty(t_in).expect(\"bad input type for cast\");\n+    let r_t_out = CastTy::from_ty(t_out).expect(\"bad output type for cast\");\n \n     let (llexpr, signed) = if let Int(CEnum) = r_t_in {\n         let repr = adt::represent_type(ccx, t_in);"}, {"sha": "30cf6f519fbd1d02e6861e5c3196fe4d751842c2", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -432,9 +432,8 @@ pub fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, in\n \n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n-            let fields = bcx.tcx().struct_fields(def.did, substs);\n-            let last_field = fields[fields.len()-1];\n-            let field_ty = last_field.mt.ty;\n+            let last_field = def.struct_variant().fields.last().unwrap();\n+            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             let dbloc = DebugLoc::None;"}, {"sha": "01bfc51a5c0de20134551b7e5fd11498ef908f81", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -100,30 +100,32 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n-          let mut my_id = 0;\n-          match item.node {\n-            ast::ItemEnum(_, _) => {\n-              let vs_here = ccx.tcx().enum_variants(local_def(item.id));\n-              let vs_there = ccx.tcx().enum_variants(parent_id);\n-              for (here, there) in vs_here.iter().zip(vs_there.iter()) {\n-                  if there.id == fn_id { my_id = here.id.node; }\n-                  ccx.external().borrow_mut().insert(there.id, Some(here.id.node));\n-              }\n-            }\n-            ast::ItemStruct(ref struct_def, _) => {\n-              match struct_def.ctor_id {\n-                None => {}\n-                Some(ctor_id) => {\n-                    ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n-                    my_id = ctor_id;\n+            let mut my_id = 0;\n+            match item.node {\n+                ast::ItemEnum(ref ast_def, _) => {\n+                    let ast_vs = &ast_def.variants;\n+                    let ty_vs = &ccx.tcx().lookup_adt_def(parent_id).variants;\n+                    assert_eq!(ast_vs.len(), ty_vs.len());\n+                    for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n+                        if ty_v.did == fn_id { my_id = ast_v.node.id; }\n+                        ccx.external().borrow_mut().insert(ty_v.did, Some(ast_v.node.id));\n+                    }\n                 }\n-              }\n-            }\n-            _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n+                ast::ItemStruct(ref struct_def, _) => {\n+                    match struct_def.ctor_id {\n+                        None => ccx.sess().bug(\"instantiate_inline: called on a \\\n+                                                non-tuple struct\"),\n+                        Some(ctor_id) => {\n+                            ccx.external().borrow_mut().insert(fn_id, Some(ctor_id));\n+                            my_id = ctor_id;\n+                        }\n+                    }\n+                }\n+                _ => ccx.sess().bug(\"instantiate_inline: item has a \\\n                                  non-enum, non-struct parent\")\n-          }\n-          trans_item(ccx, &**item);\n-          my_id\n+            }\n+            trans_item(ccx, &**item);\n+            my_id\n         }\n         csearch::FoundAst::FoundParent(_, _) => {\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\"}, {"sha": "242ba6f207c56049c7b2da52f24d2eea4050efd9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -29,7 +29,6 @@ use middle::ty::{self, HasTypeFlags, Ty};\n \n use syntax::abi;\n use syntax::ast;\n-use syntax::ast_util::local_def;\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n use std::hash::{Hasher, Hash, SipHasher};\n@@ -192,24 +191,11 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         ast_map::NodeVariant(v) => {\n-            let parent = ccx.tcx().map.get_parent(fn_id.node);\n-            let tvs = ccx.tcx().enum_variants(local_def(parent));\n-            let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n+            let variant = inlined_variant_def(ccx, fn_id.node);\n+            assert_eq!(v.node.name.name, variant.name);\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n-            match v.node.kind {\n-                ast::TupleVariantKind(ref args) => {\n-                    trans_enum_variant(ccx,\n-                                       parent,\n-                                       &*v,\n-                                       &args[..],\n-                                       this_tv.disr_val,\n-                                       psubsts,\n-                                       d);\n-                }\n-                ast::StructVariantKind(_) =>\n-                    ccx.sess().bug(\"can't monomorphize struct variants\"),\n-            }\n+            trans_enum_variant(ccx, fn_id.node, variant.disr_val, psubsts, d);\n             d\n         }\n         ast_map::NodeImplItem(impl_item) => {\n@@ -255,7 +241,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let d = mk_lldecl(abi::Rust);\n             attributes::inline(d, attributes::InlineAttr::Hint);\n             base::trans_tuple_struct(ccx,\n-                                     &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -302,6 +287,16 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n     normalize_associated_type(tcx, &substituted)\n }\n \n+\n+/// Returns the normalized type of a struct field\n+pub fn field_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                      param_substs: &Substs<'tcx>,\n+                      f: &ty::FieldDef<'tcx>)\n+                      -> Ty<'tcx>\n+{\n+    normalize_associated_type(tcx, &f.ty(tcx, param_substs))\n+}\n+\n /// Removes associated types, if any. Since this during\n /// monomorphization, we know that only concrete types are involved,\n /// and hence we can be sure that all associated types will be"}, {"sha": "bc583a67d933e3808da0454e0b8b9fbc39ac2171", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -528,7 +528,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let (adt_def, variant_def_id) = match def {\n+    let (adt_def, variant) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0168,\n@@ -544,11 +544,10 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n             let def_type = tcx.lookup_item_type(def.def_id());\n             match def_type.ty.sty {\n                 ty::TyStruct(struct_def, _) =>\n-                    (struct_def, struct_def.did),\n+                    (struct_def, struct_def.struct_variant()),\n                 ty::TyEnum(enum_def, _)\n-                    // TODO: wut?\n                     if def == def::DefVariant(enum_def.did, def.def_id(), true) =>\n-                    (enum_def, def.def_id()),\n+                    (enum_def, enum_def.variant_of_def(def)),\n                 _ => {\n                     let name = pprust::path_to_string(path);\n                     span_err!(tcx.sess, pat.span, E0163,\n@@ -582,9 +581,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         .map(|substs| substs.substs.clone())\n         .unwrap_or_else(|| Substs::empty());\n \n-    let struct_fields = tcx.struct_fields(variant_def_id, &item_substs);\n-    check_struct_pat_fields(pcx, pat.span, fields, &struct_fields,\n-                            variant_def_id, etc);\n+    check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);\n }\n \n pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n@@ -651,19 +648,23 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ty::TyEnum(enum_def, expected_substs)\n             if def == def::DefVariant(enum_def.did, def.def_id(), false) =>\n         {\n-            let variant = tcx.enum_variant_with_id(enum_def.did, def.def_id());\n-            (variant.args.iter()\n-                         .map(|t| fcx.instantiate_type_scheme(pat.span, expected_substs, t))\n-                         .collect(),\n+            let variant = enum_def.variant_of_def(def);\n+            (variant.fields\n+                    .iter()\n+                    .map(|f| fcx.instantiate_type_scheme(pat.span,\n+                                                         expected_substs,\n+                                                         &f.unsubst_ty()))\n+                    .collect(),\n              \"variant\")\n         }\n         ty::TyStruct(struct_def, expected_substs) => {\n-            let struct_fields = tcx.struct_fields(struct_def.did, expected_substs);\n-            (struct_fields.iter()\n-                          .map(|field| fcx.instantiate_type_scheme(pat.span,\n-                                                                   expected_substs,\n-                                                                   &field.mt.ty))\n-                          .collect(),\n+            (struct_def.struct_variant()\n+                       .fields\n+                       .iter()\n+                       .map(|f| fcx.instantiate_type_scheme(pat.span,\n+                                                            expected_substs,\n+                                                            &f.unsubst_ty()))\n+                       .collect(),\n              \"struct\")\n         }\n         _ => {\n@@ -716,23 +717,23 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                          span: Span,\n                                          fields: &'tcx [Spanned<ast::FieldPat>],\n-                                         struct_fields: &[ty::Field<'tcx>],\n-                                         struct_id: ast::DefId,\n+                                         variant: &ty::VariantDef<'tcx>,\n+                                         substs: &Substs<'tcx>,\n                                          etc: bool) {\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Index the struct fields' types.\n-    let field_type_map = struct_fields\n+    let field_map = variant.fields\n         .iter()\n-        .map(|field| (field.name, field.mt.ty))\n+        .map(|field| (field.name, field))\n         .collect::<FnvHashMap<_, _>>();\n \n     // Keep track of which fields have already appeared in the pattern.\n     let mut used_fields = FnvHashMap();\n \n     // Typecheck each field.\n     for &Spanned { node: ref field, span } in fields {\n-        let field_type = match used_fields.entry(field.ident.name) {\n+        let field_ty = match used_fields.entry(field.ident.name) {\n             Occupied(occupied) => {\n                 span_err!(tcx.sess, span, E0025,\n                     \"field `{}` bound multiple times in the pattern\",\n@@ -744,25 +745,24 @@ pub fn check_struct_pat_fields<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             }\n             Vacant(vacant) => {\n                 vacant.insert(span);\n-                field_type_map.get(&field.ident.name).cloned()\n+                field_map.get(&field.ident.name)\n+                    .map(|f| pcx.fcx.field_ty(span, f, substs))\n                     .unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0026,\n                             \"struct `{}` does not have a field named `{}`\",\n-                            tcx.item_path_str(struct_id),\n+                            tcx.item_path_str(variant.did),\n                             field.ident);\n                         tcx.types.err\n                     })\n             }\n         };\n \n-        let field_type = pcx.fcx.normalize_associated_types_in(span, &field_type);\n-\n-        check_pat(pcx, &*field.pat, field_type);\n+        check_pat(pcx, &*field.pat, field_ty);\n     }\n \n     // Report an error if not all the fields were specified.\n     if !etc {\n-        for field in struct_fields\n+        for field in variant.fields\n             .iter()\n             .filter(|field| !used_fields.contains_key(&field.name)) {\n             span_err!(tcx.sess, span, E0027,"}, {"sha": "b6ba62e4f09658e89f0ab6ef7bd6cc4fe679f5fd", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -80,9 +80,10 @@ fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         ty::TySlice(_) | ty::TyStr => Some(UnsizeKind::Length),\n         ty::TyTrait(ref tty) => Some(UnsizeKind::Vtable(tty.principal_def_id())),\n         ty::TyStruct(def, substs) => {\n-            match fcx.tcx().struct_fields(def.did, substs).pop() {\n+            // FIXME(arielb1): do some kind of normalization\n+            match def.struct_variant().fields.last() {\n                 None => None,\n-                Some(f) => unsize_kind(fcx, f.mt.ty)\n+                Some(f) => unsize_kind(fcx, f.ty(fcx.tcx(), substs))\n             }\n         }\n         // We should really try to normalize here.\n@@ -223,8 +224,8 @@ impl<'tcx> CastCheck<'tcx> {\n         use middle::cast::IntTy::*;\n         use middle::cast::CastTy::*;\n \n-        let (t_from, t_cast) = match (CastTy::from_ty(fcx.tcx(), self.expr_ty),\n-                                      CastTy::from_ty(fcx.tcx(), self.cast_ty)) {\n+        let (t_from, t_cast) = match (CastTy::from_ty(self.expr_ty),\n+                                      CastTy::from_ty(self.cast_ty)) {\n             (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n             _ => {\n                 return Err(CastError::NonScalar)"}, {"sha": "57f2f063c71c41b69544a76480a0ad888185cc39", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 31, "deletions": 50, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -285,26 +285,28 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>\n                     // no need for an additional note if the overflow\n                     // was somehow on the root.\n                 }\n-                TypeContext::EnumVariant { def_id, variant, arg_index } => {\n+                TypeContext::ADT { def_id, variant, field, field_index } => {\n                     // FIXME (pnkfelix): eventually lookup arg_name\n                     // for the given index on struct variants.\n-                    span_note!(\n-                        rcx.tcx().sess,\n-                        span,\n-                        \"overflowed on enum {} variant {} argument {} type: {}\",\n-                        tcx.item_path_str(def_id),\n-                        variant,\n-                        arg_index,\n-                        detected_on_typ);\n-                }\n-                TypeContext::Struct { def_id, field } => {\n-                    span_note!(\n-                        rcx.tcx().sess,\n-                        span,\n-                        \"overflowed on struct {} field {} type: {}\",\n-                        tcx.item_path_str(def_id),\n-                        field,\n-                        detected_on_typ);\n+                    // TODO: be saner\n+                    if let ty::ADTKind::Enum = tcx.lookup_adt_def(def_id).adt_kind() {\n+                        span_note!(\n+                            rcx.tcx().sess,\n+                            span,\n+                            \"overflowed on enum {} variant {} argument {} type: {}\",\n+                            tcx.item_path_str(def_id),\n+                            variant,\n+                            field_index,\n+                            detected_on_typ);\n+                    } else {\n+                        span_note!(\n+                            rcx.tcx().sess,\n+                            span,\n+                            \"overflowed on struct {} field {} type: {}\",\n+                            tcx.item_path_str(def_id),\n+                            field,\n+                            detected_on_typ);\n+                    }\n                 }\n             }\n         }\n@@ -318,14 +320,11 @@ enum Error<'tcx> {\n #[derive(Copy, Clone)]\n enum TypeContext {\n     Root,\n-    EnumVariant {\n+    ADT {\n         def_id: ast::DefId,\n         variant: ast::Name,\n-        arg_index: usize,\n-    },\n-    Struct {\n-        def_id: ast::DefId,\n         field: ast::Name,\n+        field_index: usize\n     }\n }\n \n@@ -437,41 +436,23 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n                 cx, context, ity, depth+1)\n         }\n \n-        ty::TyStruct(def, substs) => {\n-            let did = def.did;\n-            let fields = tcx.lookup_struct_fields(did);\n-            for field in &fields {\n-                let fty = tcx.lookup_field_type(did, field.id, substs);\n-                let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n-                    cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n-                try!(iterate_over_potentially_unsafe_regions_in_type(\n-                    cx,\n-                    TypeContext::Struct {\n-                        def_id: did,\n-                        field: field.name,\n-                    },\n-                    fty,\n-                    depth+1))\n-            }\n-            Ok(())\n-        }\n-\n-        ty::TyEnum(def, substs) => {\n+        ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n             let did = def.did;\n-            let all_variant_info = tcx.substd_enum_variants(did, substs);\n-            for variant_info in &all_variant_info {\n-                for (i, fty) in variant_info.args.iter().enumerate() {\n+            for variant in &def.variants {\n+                for (i, field) in variant.fields.iter().enumerate() {\n+                    let fty = field.ty(tcx, substs);\n                     let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n                         cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n                     try!(iterate_over_potentially_unsafe_regions_in_type(\n                         cx,\n-                        TypeContext::EnumVariant {\n+                        TypeContext::ADT {\n                             def_id: did,\n-                            variant: variant_info.name,\n-                            arg_index: i,\n+                            field: field.name,\n+                            variant: variant.name,\n+                            field_index: i\n                         },\n                         fty,\n-                        depth+1));\n+                        depth+1))\n                 }\n             }\n             Ok(())"}, {"sha": "15cc5ee6eb801730a815efed48220e0bbe3ce677", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -66,9 +66,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // If the item has the name of a field, give a help note\n             if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                let fields = cx.lookup_struct_fields(def.did);\n-\n-                if let Some(field) = fields.iter().find(|f| f.name == item_name) {\n+                if let Some(field) = def.struct_variant().find_field_named(item_name) {\n                     let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n                         Ok(expr_string) => expr_string,\n                         _ => \"s\".into() // Default to a generic placeholder for the\n@@ -89,7 +87,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     };\n \n                     // Determine if the field can be used as a function in some way\n-                    let field_ty = cx.lookup_field_type(def.did, field.id, substs);\n+                    let field_ty = field.ty(cx, substs);\n                     if let Ok(fn_once_trait_did) = cx.lang_items.require(FnOnceTraitLangItem) {\n                         let infcx = fcx.infcx();\n                         infcx.probe(|_| {"}, {"sha": "ac3733db9c2e4ee8800fd7216895504208b64a84", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 78, "deletions": 120, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -1674,34 +1674,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    // Only for fields! Returns <none> for methods>\n-    // Indifferent to privacy flags\n-    pub fn lookup_field_ty(&self,\n-                           span: Span,\n-                           struct_def: &'tcx ty::ADTDef<'tcx>,\n-                           items: &[ty::FieldTy],\n-                           fieldname: ast::Name,\n-                           substs: &subst::Substs<'tcx>)\n-                           -> Option<Ty<'tcx>>\n-    {\n-        let o_field = items.iter().find(|f| f.name == fieldname);\n-        o_field.map(|f| self.tcx().lookup_field_type(struct_def.did, f.id, substs))\n-               .map(|t| self.normalize_associated_types_in(span, &t))\n-    }\n-\n-    pub fn lookup_tup_field_ty(&self,\n-                               span: Span,\n-                               struct_def: &'tcx ty::ADTDef<'tcx>,\n-                               items: &[ty::FieldTy],\n-                               idx: usize,\n-                               substs: &subst::Substs<'tcx>)\n-                               -> Option<Ty<'tcx>>\n+    // FIXME(arielb1): use this instead of field.ty everywhere\n+    pub fn field_ty(&self,\n+                    span: Span,\n+                    field: &ty::FieldDef<'tcx>,\n+                    substs: &Substs<'tcx>)\n+                    -> Ty<'tcx>\n     {\n-        let o_field = if idx < items.len() { Some(&items[idx]) } else { None };\n-        o_field.map(|f| self.tcx().lookup_field_type(struct_def.did, f.id, substs))\n-               .map(|t| self.normalize_associated_types_in(span, &t))\n+        self.normalize_associated_types_in(span,\n+                                           &field.ty(self.tcx(), substs))\n     }\n \n+    // Only for fields! Returns <none> for methods>\n+    // Indifferent to privacy flags\n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n         for cast in deferred_cast_checks.drain(..) {\n@@ -2880,9 +2865,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 match base_t.sty {\n                     ty::TyStruct(base_def, substs) => {\n                         debug!(\"struct named {:?}\",  base_t);\n-                        let fields = tcx.lookup_struct_fields(base_def.did);\n-                        fcx.lookup_field_ty(expr.span, base_def, &fields[..],\n-                                            field.node.name, &(*substs))\n+                        base_def.struct_variant()\n+                                .find_field_named(field.node.name)\n+                                .map(|f| fcx.field_ty(expr.span, f, substs))\n                     }\n                     _ => None\n                 }\n@@ -2920,31 +2905,30 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 },\n                 expr_t, None);\n             if let ty::TyStruct(def, _) = expr_t.sty {\n-                suggest_field_names(def.did, field, tcx, vec![]);\n+                suggest_field_names(def.struct_variant(), field, tcx, vec![]);\n             }\n         }\n \n         fcx.write_error(expr.id);\n     }\n \n     // displays hints about the closest matches in field names\n-    fn suggest_field_names<'tcx>(variant_id: ast::DefId,\n+    fn suggest_field_names<'tcx>(variant: &ty::VariantDef<'tcx>,\n                                  field: &ast::SpannedIdent,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  skip : Vec<InternedString>) {\n         let name = field.node.name.as_str();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let fields = tcx.lookup_struct_fields(variant_id);\n         let mut best = None;\n-        for elem in &fields {\n+        for elem in &variant.fields {\n             let n = elem.name.as_str();\n             // ignore already set fields\n             if skip.iter().any(|x| *x == n) {\n                 continue;\n             }\n             // ignore private fields from non-local crates\n-            if variant_id.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n+            if variant.did.krate != ast::LOCAL_CRATE && elem.vis != Visibility::Public {\n                 continue;\n             }\n             let dist = lev_distance(&n, &name);\n@@ -2965,7 +2949,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 lvalue_pref: LvaluePreference,\n                                 base: &'tcx ast::Expr,\n                                 idx: codemap::Spanned<usize>) {\n-        let tcx = fcx.ccx.tcx;\n         check_expr_with_lvalue_pref(fcx, base, lvalue_pref);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n@@ -2983,9 +2966,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         tuple_like = base_def.struct_variant().is_tuple_struct();\n                         if tuple_like {\n                             debug!(\"tuple struct named {:?}\",  base_t);\n-                            let fields = tcx.lookup_struct_fields(base_def.did);\n-                            fcx.lookup_tup_field_ty(expr.span, base_def, &fields[..],\n-                                                    idx.node, &(*substs))\n+                            base_def.struct_variant()\n+                                    .fields\n+                                    .get(idx.node)\n+                                    .map(|f| fcx.field_ty(expr.span, f, substs))\n                         } else {\n                             None\n                         }\n@@ -3025,71 +3009,63 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_error(expr.id);\n     }\n \n+    fn report_unknown_field<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                      ty: Ty<'tcx>,\n+                                      variant: &ty::VariantDef<'tcx>,\n+                                      field: &ast::Field,\n+                                      skip_fields: &[ast::Field]) {\n+        fcx.type_error_message(\n+            field.ident.span,\n+            |actual| if let ty::TyEnum(..) = ty.sty {\n+                format!(\"struct variant `{}::{}` has no field named `{}`\",\n+                        actual, variant.name.as_str(), field.ident.node)\n+            } else {\n+                format!(\"structure `{}` has no field named `{}`\",\n+                        actual, field.ident.node)\n+            },\n+            ty,\n+            None);\n+        // prevent all specified fields from being suggested\n+        let skip_fields = skip_fields.iter().map(|ref x| x.ident.node.name.as_str());\n+        suggest_field_names(variant, &field.ident, fcx.tcx(), skip_fields.collect());\n+    }\n+\n+\n     fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 adt_ty: Ty<'tcx>,\n                                                 span: Span,\n                                                 variant_id: ast::DefId,\n-                                                substitutions: &'tcx subst::Substs<'tcx>,\n-                                                field_types: &[ty::FieldTy],\n                                                 ast_fields: &'tcx [ast::Field],\n                                                 check_completeness: bool) -> Result<(),()> {\n         let tcx = fcx.ccx.tcx;\n-        let (adt_def, is_enum) = match adt_ty.sty {\n-            ty::TyStruct(def, _) => (def, false),\n-            ty::TyEnum(def, _) => (def, true),\n+        let (adt_def, substs) = match adt_ty.sty {\n+            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => (def, substs),\n             _ => tcx.sess.span_bug(span, \"non-ADT passed to check_struct_or_variant_fields\")\n         };\n+        let variant = adt_def.variant_with_id(variant_id);\n \n-        let mut class_field_map = FnvHashMap();\n-        let mut fields_found = 0;\n-        for field in field_types {\n-            class_field_map.insert(field.name, (field.id, false));\n+        let mut remaining_fields = FnvHashMap();\n+        for field in &variant.fields {\n+            remaining_fields.insert(field.name, field);\n         }\n \n         let mut error_happened = false;\n \n         // Typecheck each field.\n         for field in ast_fields {\n-            let mut expected_field_type = tcx.types.err;\n-\n-            let pair = class_field_map.get(&field.ident.node.name).cloned();\n-            match pair {\n-                None => {\n-                    fcx.type_error_message(\n-                        field.ident.span,\n-                        |actual| if is_enum {\n-                            let variant_type = tcx.enum_variant_with_id(adt_def.did,\n-                                                                        variant_id);\n-                            format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                                    actual, variant_type.name.as_str(),\n-                                        field.ident.node)\n-                        } else {\n-                            format!(\"structure `{}` has no field named `{}`\",\n-                                    actual,\n-                                        field.ident.node)\n-                        },\n-                        adt_ty,\n-                        None);\n-                    // prevent all specified fields from being suggested\n-                    let skip_fields = ast_fields.iter().map(|ref x| x.ident.node.name.as_str());\n-                    suggest_field_names(variant_id, &field.ident, tcx, skip_fields.collect());\n-                    error_happened = true;\n-                }\n-                Some((_, true)) => {\n+            let expected_field_type;\n+\n+            if let Some(v_field) = remaining_fields.remove(&field.ident.node.name) {\n+                expected_field_type = fcx.field_ty(field.span, v_field, substs);\n+            } else {\n+                error_happened = true;\n+                expected_field_type = tcx.types.err;\n+                if let Some(_) = variant.find_field_named(field.ident.node.name) {\n                     span_err!(fcx.tcx().sess, field.ident.span, E0062,\n                         \"field `{}` specified more than once\",\n                         field.ident.node);\n-                    error_happened = true;\n-                }\n-                Some((field_id, false)) => {\n-                    expected_field_type =\n-                        tcx.lookup_field_type(variant_id, field_id, substitutions);\n-                    expected_field_type =\n-                        fcx.normalize_associated_types_in(\n-                            field.span, &expected_field_type);\n-                    class_field_map.insert(\n-                        field.ident.node.name, (field_id, true));\n-                    fields_found += 1;\n+                } else {\n+                    report_unknown_field(fcx, adt_ty, variant, field, ast_fields);\n                 }\n             }\n \n@@ -3098,25 +3074,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n         }\n \n-        if check_completeness && !error_happened {\n             // Make sure the programmer specified all the fields.\n-            assert!(fields_found <= field_types.len());\n-            if fields_found < field_types.len() {\n-                let mut missing_fields = Vec::new();\n-                for class_field in field_types {\n-                    let name = class_field.name;\n-                    let (_, seen) = *class_field_map.get(&name).unwrap();\n-                    if !seen {\n-                        missing_fields.push(\n-                            format!(\"`{}`\", name))\n-                    }\n-                }\n-\n-                span_err!(tcx.sess, span, E0063,\n-                    \"missing field{}: {}\",\n-                    if missing_fields.len() == 1 {\"\"} else {\"s\"},\n-                    missing_fields.join(\", \"));\n-             }\n+        if check_completeness &&\n+            !error_happened &&\n+            !remaining_fields.is_empty()\n+        {\n+            error_happened = true;\n+            span_err!(tcx.sess, span, E0063,\n+                      \"missing field{}: {}\",\n+                      if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n+                      remaining_fields.keys()\n+                                      .map(|n| format!(\"`{}`\", n))\n+                                      .collect::<Vec<_>>()\n+                                      .join(\", \"));\n         }\n \n         if error_happened { Err(()) } else { Ok(()) }\n@@ -3133,17 +3103,14 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // Generate the struct type.\n         let TypeAndSubsts {\n             ty: mut struct_type,\n-            substs: struct_substs\n+            substs: _\n         } = fcx.instantiate_type(span, struct_def.did);\n \n         // Look up and check the fields.\n-        let class_fields = tcx.lookup_struct_fields(struct_def.did);\n         let res = check_struct_or_variant_fields(fcx,\n                                                  struct_type,\n                                                  span,\n                                                  struct_def.did,\n-                                                 fcx.ccx.tcx.mk_substs(struct_substs),\n-                                                 &class_fields[..],\n                                                  fields,\n                                                  base_expr.is_none());\n         if res.is_err() {\n@@ -3168,23 +3135,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                           enum_id: ast::DefId,\n                                           variant_id: ast::DefId,\n                                           fields: &'tcx [ast::Field]) {\n-        let tcx = fcx.ccx.tcx;\n-\n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n         let TypeAndSubsts {\n             ty: enum_type,\n-            substs: substitutions\n+            substs: _\n         } = fcx.instantiate_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n-        let variant_fields = tcx.lookup_struct_fields(variant_id);\n         let _ = check_struct_or_variant_fields(fcx,\n                                                enum_type,\n                                                span,\n                                                variant_id,\n-                                               fcx.ccx.tcx.mk_substs(substitutions),\n-                                               &variant_fields[..],\n                                                fields,\n                                                true);\n         fcx.write_ty(id, enum_type);\n@@ -4295,14 +4257,13 @@ pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     }\n     match t.sty {\n         ty::TyStruct(def, substs) => {\n-            let fields = tcx.lookup_struct_fields(def.did);\n+            let fields = &def.struct_variant().fields;\n             if fields.is_empty() {\n                 span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = tcx.lookup_field_type(def.did, fields[0].id, substs);\n-            if !fields.iter().all(\n-                         |f| tcx.lookup_field_type(def.did, f.id, substs) == e) {\n+            let e = fields[0].ty(tcx, substs);\n+            if !fields.iter().all(|f| f.ty(tcx, substs) == e) {\n                 span_err!(tcx.sess, sp, E0076, \"SIMD vector should be homogeneous\");\n                 return;\n             }\n@@ -4370,10 +4331,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n         let def_id = local_def(id);\n \n-        // ty::enum_variants guards against discriminant overflows, so\n-        // we need not check for that.\n-        let variants = ccx.tcx.enum_variants(def_id);\n-\n+        let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n         for (v, variant) in vs.iter().zip(variants.iter()) {\n             let current_disr_val = variant.disr_val;\n \n@@ -4382,7 +4340,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                 Some(i) => {\n                     span_err!(ccx.tcx.sess, v.span, E0081,\n                         \"discriminant value `{}` already exists\", disr_vals[i]);\n-                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].id.node),\n+                    span_note!(ccx.tcx.sess, ccx.tcx.map.span(variants[i].did.node),\n                         \"conflicting discriminant here\")\n                 }\n                 None => {}"}, {"sha": "7ab8d327a8097b9604be12257b15e25b7e1c90fc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -483,10 +483,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n \n                     let origin = infer::Misc(span);\n-                    let fields = tcx.lookup_struct_fields(def_a.did);\n+                    let fields = &def_a.struct_variant().fields;\n                     let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                        let ty = tcx.lookup_field_type_unsubstituted(def_a.did, f.id);\n-                        let (a, b) = (ty.subst(tcx, substs_a), ty.subst(tcx, substs_b));\n+                        let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n                         if infcx.sub_types(false, origin, b, a).is_ok() {\n                             None\n                         } else {"}, {"sha": "ddc900b1d25b59a5261f08874a424d21694b26cb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 35, "deletions": 18, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -1174,33 +1174,50 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n             Ok(ConstVal::Int(val)) => Some(val as ty::Disr),\n             Ok(ConstVal::Uint(val)) => Some(val as ty::Disr),\n             Ok(_) => {\n-//                let sign_desc = if repr_type.is_signed() {\n-//                    \"signed\"\n-//                } else {\n-//                    \"unsigned\"\n-//                };\n-//                span_err!(self.sess, e.span, E0079,\n-//                          \"expected {} integer constant\",\n-//                          sign_desc);\n+                let sign_desc = if repr_ty.is_signed() {\n+                    \"signed\"\n+                } else {\n+                    \"unsigned\"\n+                };\n+                span_err!(tcx.sess, e.span, E0079,\n+                          \"expected {} integer constant\",\n+                          sign_desc);\n                 None\n             },\n-            Err(_) => {\n-//              span_err!(self.sess, err.span, E0080,\n-//                        \"constant evaluation error: {}\",\n-//                        err.description());\n+            Err(err) => {\n+              span_err!(tcx.sess, err.span, E0080,\n+                        \"constant evaluation error: {}\",\n+                        err.description());\n                 None\n             }\n         }\n     }\n \n-    fn next_disr(repr_type: attr::IntType,\n+    fn report_discrim_overflow(tcx: &ty::ctxt,\n+                               variant_span: Span,\n+                               variant_name: &str,\n+                               repr_type: attr::IntType,\n+                               prev_val: ty::Disr) {\n+        let computed_value = repr_type.disr_wrap_incr(Some(prev_val));\n+        let computed_value = repr_type.disr_string(computed_value);\n+        let prev_val = repr_type.disr_string(prev_val);\n+        let repr_type = repr_type.to_ty(tcx);\n+        span_err!(tcx.sess, variant_span, E0370,\n+                  \"enum discriminant overflowed on value after {}: {}; \\\n+                   set explicitly via {} = {} if that is desired outcome\",\n+                  prev_val, repr_type, variant_name, computed_value);\n+    }\n+\n+    fn next_disr(tcx: &ty::ctxt,\n+                 v: &ast::Variant,\n+                 repr_type: attr::IntType,\n                  prev_disr_val: Option<ty::Disr>) -> Option<ty::Disr> {\n         if let Some(prev_disr_val) = prev_disr_val {\n             let result = repr_type.disr_incr(prev_disr_val);\n-//          if let None = result {\n-//              self.report_discrim_overflow(v.span, &v.node.name.name.as_str(),\n-//                                           repr_type, prev_disr_val);\n-//          }\n+            if let None = result {\n+                report_discrim_overflow(tcx, v.span, &v.node.name.name.as_str(),\n+                                             repr_type, prev_disr_val);\n+            }\n             result\n         } else {\n             Some(ty::INITIAL_DISCRIMINANT_VALUE)\n@@ -1240,7 +1257,7 @@ fn convert_enum_def<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let variants = def.variants.iter().map(|v| {\n         let disr = match v.node.disr_expr {\n             Some(ref e) => evaluate_disr_expr(tcx, repr_type_ty, e),\n-            None => next_disr(repr_type, prev_disr)\n+            None => next_disr(tcx, v, repr_type, prev_disr)\n         }.unwrap_or(repr_type.disr_wrap_incr(prev_disr));\n \n         let v = convert_enum_variant(tcx, v, disr);"}, {"sha": "4660adaffaec066d0c54bce18d9a43cc4140c58f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -883,6 +883,64 @@ struct Good(u32, u32, u32); // This will not\n ```\n \"##,\n \n+E0079: r##\"\n+Enum variants which contain no data can be given a custom integer\n+representation. This error indicates that the value provided is not an integer\n+literal and is therefore invalid.\n+\n+For example, in the following code,\n+\n+```\n+enum Foo {\n+    Q = \"32\"\n+}\n+```\n+\n+we try to set the representation to a string.\n+\n+There's no general fix for this; if you can work with an integer then just set\n+it to one:\n+\n+```\n+enum Foo {\n+    Q = 32\n+}\n+```\n+\n+however if you actually wanted a mapping between variants and non-integer\n+objects, it may be preferable to use a method with a match instead:\n+\n+```\n+enum Foo { Q }\n+impl Foo {\n+    fn get_str(&self) -> &'static str {\n+        match *self {\n+            Foo::Q => \"32\",\n+        }\n+    }\n+}\n+```\n+\"##,\n+\n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+integer expression provided as an enum discriminant. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n+\n+```\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n+```\n+\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n+\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -2510,6 +2568,7 @@ register_diagnostics! {\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n     E0369, // binary operation `<op>` cannot be applied to types\n+    E0370, // discriminant overflow\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "69e2141b17b07807c2907eb3660b2001418b6fae", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -602,7 +602,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n         match item.node {\n-            ast::ItemEnum(ref enum_definition, _) => {\n+            ast::ItemEnum(..) | ast::ItemStruct(..) => {\n                 let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n@@ -611,44 +611,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 //\n                 // self.add_constraints_from_generics(&scheme.generics);\n \n-                // Hack: If we directly call `ty::enum_variants`, it\n-                // annoyingly takes it upon itself to run off and\n-                // evaluate the discriminants eagerly (*grumpy* that's\n-                // not the typical pattern). This results in double\n-                // error messages because typeck goes off and does\n-                // this at a later time. All we really care about is\n-                // the types of the variant arguments, so we just call\n-                // `ty::VariantInfo::from_ast_variant()` ourselves\n-                // here, mainly so as to mask the differences between\n-                // struct-like enums and so forth.\n-                for ast_variant in &enum_definition.variants {\n-                    let variant =\n-                        ty::VariantInfo::from_ast_variant(tcx,\n-                                                          &**ast_variant,\n-                                                          /*discriminant*/ 0);\n-                    for arg_ty in &variant.args {\n-                        self.add_constraints_from_ty(&scheme.generics, *arg_ty, self.covariant);\n-                    }\n+                for field in tcx.lookup_adt_def(did).all_fields() {\n+                    self.add_constraints_from_ty(&scheme.generics,\n+                                                 field.unsubst_ty(),\n+                                                 self.covariant);\n                 }\n             }\n-\n-            ast::ItemStruct(..) => {\n-                let scheme = tcx.lookup_item_type(did);\n-\n-                // Not entirely obvious: constraints on structs/enums do not\n-                // affect the variance of their type parameters. See discussion\n-                // in comment at top of module.\n-                //\n-                // self.add_constraints_from_generics(&scheme.generics);\n-\n-                let struct_fields = tcx.lookup_struct_fields(did);\n-                for field_info in &struct_fields {\n-                    assert_eq!(field_info.id.krate, ast::LOCAL_CRATE);\n-                    let field_ty = tcx.node_id_to_type(field_info.id.node);\n-                    self.add_constraints_from_ty(&scheme.generics, field_ty, self.covariant);\n-                }\n-            }\n-\n             ast::ItemTrait(..) => {\n                 let trait_def = tcx.lookup_trait_def(did);\n                 self.add_constraints_from_trait_ref(&trait_def.generics,"}, {"sha": "7fd1555d06654558b2afbe62e18baffd472b5924", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -185,17 +185,17 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n \n     let t = tcx.lookup_item_type(did);\n     let predicates = tcx.lookup_predicates(did);\n-    let fields = tcx.lookup_struct_fields(did);\n+    let variant = tcx.lookup_adt_def(did).struct_variant();\n \n     clean::Struct {\n-        struct_type: match &*fields {\n+        struct_type: match &*variant.fields {\n             [] => doctree::Unit,\n             [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n         generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n-        fields: fields.clean(cx),\n+        fields: variant.fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n@@ -208,7 +208,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n             return clean::EnumItem(clean::Enum {\n                 generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n-                variants: tcx.enum_variants(edef.did).clean(cx),\n+                variants: edef.variants.clean(cx),\n             })\n         }\n         _ => {}"}, {"sha": "f4a21ee4f4e05928e337265f516fcc5414cece1b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f3c1412ad8224e0fea0bc2b4f67894619045c54/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5f3c1412ad8224e0fea0bc2b4f67894619045c54", "patch": "@@ -1730,29 +1730,27 @@ impl Clean<Item> for ast::StructField {\n     }\n }\n \n-impl Clean<Item> for ty::FieldTy {\n+impl<'tcx> Clean<Item> for ty::FieldDef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         use syntax::parse::token::special_idents::unnamed_field;\n         use rustc::metadata::csearch;\n \n-        let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.id);\n+        let attr_map = csearch::get_struct_field_attrs(&cx.tcx().sess.cstore, self.did);\n \n         let (name, attrs) = if self.name == unnamed_field.name {\n             (None, None)\n         } else {\n-            (Some(self.name), Some(attr_map.get(&self.id.node).unwrap()))\n+            (Some(self.name), Some(attr_map.get(&self.did.node).unwrap()))\n         };\n \n-        let ty = cx.tcx().lookup_item_type(self.id);\n-\n         Item {\n             name: name.clean(cx),\n             attrs: attrs.unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n-            stability: get_stability(cx, self.id),\n-            def_id: self.id,\n-            inner: StructFieldItem(TypedStructField(ty.ty.clean(cx))),\n+            stability: get_stability(cx, self.did),\n+            def_id: self.did,\n+            inner: StructFieldItem(TypedStructField(self.unsubst_ty().clean(cx))),\n         }\n     }\n }\n@@ -1858,22 +1856,24 @@ impl Clean<Item> for doctree::Variant {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n+impl<'tcx> Clean<Item> for ty::VariantDef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let kind = match self.arg_names.as_ref().map(|s| &**s) {\n-            None | Some([]) if self.args.is_empty() => CLikeVariant,\n-            None | Some([]) => {\n-                TupleVariant(self.args.clean(cx))\n+        let kind = match self.kind() {\n+            ty::VariantKind::Unit => CLikeVariant,\n+            ty::VariantKind::Tuple => {\n+                TupleVariant(\n+                    self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n+                )\n             }\n-            Some(s) => {\n+            ty::VariantKind::Dict => {\n                 StructVariant(VariantStruct {\n                     struct_type: doctree::Plain,\n                     fields_stripped: false,\n-                    fields: s.iter().zip(&self.args).map(|(name, ty)| {\n+                    fields: self.fields.iter().map(|field| {\n                         Item {\n                             source: Span::empty(),\n-                            name: Some(name.clean(cx)),\n+                            name: Some(field.name.clean(cx)),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n                             // FIXME: this is not accurate, we need an id for\n@@ -1883,10 +1883,10 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n                             //        Struct variants are experimental and need\n                             //        more infrastructure work before we can get\n                             //        at the needed information here.\n-                            def_id: self.id,\n-                            stability: get_stability(cx, self.id),\n+                            def_id: self.did,\n+                            stability: get_stability(cx, self.did),\n                             inner: StructFieldItem(\n-                                TypedStructField(ty.clean(cx))\n+                                TypedStructField(field.unsubst_ty().clean(cx))\n                             )\n                         }\n                     }).collect()\n@@ -1895,12 +1895,12 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n         };\n         Item {\n             name: Some(self.name.clean(cx)),\n-            attrs: inline::load_attrs(cx, cx.tcx(), self.id),\n+            attrs: inline::load_attrs(cx, cx.tcx(), self.did),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n-            def_id: self.id,\n+            def_id: self.did,\n             inner: VariantItem(Variant { kind: kind }),\n-            stability: get_stability(cx, self.id),\n+            stability: get_stability(cx, self.did),\n         }\n     }\n }"}]}