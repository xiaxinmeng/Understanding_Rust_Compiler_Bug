{"sha": "fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzkzYzAxNjZlNjBmYzZlNTZlNjU5NzUyNGFlZWM3ZDE3Y2JjNTg=", "commit": {"author": {"name": "Josh Holmer", "email": "jholmer.in@gmail.com", "date": "2018-08-30T03:01:24Z"}, "committer": {"name": "Josh Holmer", "email": "jholmer.in@gmail.com", "date": "2018-09-04T03:29:44Z"}, "message": "Lint against needless uses of `collect()`\n\nHandles cases of `.collect().len()`, `.collect().is_empty()`, and\n`.collect().contains()`. This lint is intended to be generic enough to\nbe added to at a later time with other similar patterns that could be\noptimized.\n\nCloses #3034", "tree": {"sha": "ad6793bb9ad32d9c9e6c6a655a8a4fefb93e4f7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad6793bb9ad32d9c9e6c6a655a8a4fefb93e4f7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "html_url": "https://github.com/rust-lang/rust/commit/fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/comments", "author": {"login": "shssoichiro", "id": 5951392, "node_id": "MDQ6VXNlcjU5NTEzOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5951392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shssoichiro", "html_url": "https://github.com/shssoichiro", "followers_url": "https://api.github.com/users/shssoichiro/followers", "following_url": "https://api.github.com/users/shssoichiro/following{/other_user}", "gists_url": "https://api.github.com/users/shssoichiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/shssoichiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shssoichiro/subscriptions", "organizations_url": "https://api.github.com/users/shssoichiro/orgs", "repos_url": "https://api.github.com/users/shssoichiro/repos", "events_url": "https://api.github.com/users/shssoichiro/events{/privacy}", "received_events_url": "https://api.github.com/users/shssoichiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shssoichiro", "id": 5951392, "node_id": "MDQ6VXNlcjU5NTEzOTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5951392?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shssoichiro", "html_url": "https://github.com/shssoichiro", "followers_url": "https://api.github.com/users/shssoichiro/followers", "following_url": "https://api.github.com/users/shssoichiro/following{/other_user}", "gists_url": "https://api.github.com/users/shssoichiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/shssoichiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shssoichiro/subscriptions", "organizations_url": "https://api.github.com/users/shssoichiro/orgs", "repos_url": "https://api.github.com/users/shssoichiro/repos", "events_url": "https://api.github.com/users/shssoichiro/events{/privacy}", "received_events_url": "https://api.github.com/users/shssoichiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0513097ab648f497e18e565bf00b71edd60c65c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0513097ab648f497e18e565bf00b71edd60c65c", "html_url": "https://github.com/rust-lang/rust/commit/c0513097ab648f497e18e565bf00b71edd60c65c"}], "stats": {"total": 122, "additions": 122, "deletions": 0}, "files": [{"sha": "23fdbf648e3078a49b2e7a2ea6f681a7031f7c36", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "patch": "@@ -554,6 +554,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         loops::ITER_NEXT_LOOP,\n         loops::MANUAL_MEMCPY,\n         loops::MUT_RANGE_BOUND,\n+        loops::NEEDLESS_COLLECT,\n         loops::NEEDLESS_RANGE_LOOP,\n         loops::NEVER_LOOP,\n         loops::REVERSE_RANGE_LOOP,\n@@ -904,6 +905,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         escape::BOXED_LOCAL,\n         large_enum_variant::LARGE_ENUM_VARIANT,\n         loops::MANUAL_MEMCPY,\n+        loops::NEEDLESS_COLLECT,\n         loops::UNUSED_COLLECT,\n         methods::EXPECT_FUN_CALL,\n         methods::ITER_NTH,"}, {"sha": "dfe1a3ccb1f8c9cd99356b9d4090da5bbfec0ea7", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "patch": "@@ -223,6 +223,27 @@ declare_clippy_lint! {\n      written as a for loop\"\n }\n \n+/// **What it does:** Checks for functions collecting an iterator when collect\n+/// is not needed.\n+///\n+/// **Why is this bad?** `collect` causes the allocation of a new data structure,\n+/// when this allocation may not be needed.\n+///\n+/// **Known problems:**\n+/// None\n+///\n+/// **Example:**\n+/// ```rust\n+/// let len = iterator.collect::<Vec<_>>().len();\n+/// // should be\n+/// let len = iterator.count();\n+/// ```\n+declare_clippy_lint! {\n+    pub NEEDLESS_COLLECT,\n+    perf,\n+    \"collecting an iterator when collect is not needed\"\n+}\n+\n /// **What it does:** Checks for loops over ranges `x..y` where both `x` and `y`\n /// are constant and `x` is greater or equal to `y`, unless the range is\n /// reversed or has a negative `.step_by(_)`.\n@@ -400,6 +421,7 @@ impl LintPass for Pass {\n             FOR_LOOP_OVER_OPTION,\n             WHILE_LET_LOOP,\n             UNUSED_COLLECT,\n+            NEEDLESS_COLLECT,\n             REVERSE_RANGE_LOOP,\n             EXPLICIT_COUNTER_LOOP,\n             EMPTY_LOOP,\n@@ -523,6 +545,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         if let ExprKind::While(ref cond, _, _) = expr.node {\n             check_infinite_loop(cx, cond, expr);\n         }\n+\n+        check_needless_collect(expr, cx);\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n@@ -2241,3 +2265,67 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n+\n+fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) {\n+    if let ExprKind::MethodCall(ref method, _, ref args) = expr.node {\n+        if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].node {\n+            if chain_method.ident.name == \"collect\" && match_trait_method(cx, &args[0], &paths::ITERATOR) {\n+                if method.ident.name == \"len\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        expr.span,\n+                        \"you are collecting an iterator to check its length\",\n+                        \"consider replacing with\",\n+                        generate_needless_collect_len_sugg(&args[0], cx),\n+                    );\n+                }\n+                if method.ident.name == \"is_empty\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        expr.span,\n+                        \"you are collecting an iterator to check if it is empty\",\n+                        \"consider replacing with\",\n+                        generate_needless_collect_is_empty_sugg(&args[0], cx),\n+                    );\n+                }\n+                if method.ident.name == \"contains\" {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        NEEDLESS_COLLECT,\n+                        expr.span,\n+                        \"you are collecting an iterator to check if contains an element\",\n+                        \"consider replacing with\",\n+                        generate_needless_collect_contains_sugg(&args[0], &args[1], cx),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn generate_needless_collect_len_sugg<'a, 'tcx>(collect_expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) -> String {\n+    if let ExprKind::MethodCall(_, _, ref args) = collect_expr.node {\n+        let iter = snippet(cx, args[0].span, \"??\");\n+        return format!(\"{}.count()\", iter);\n+    }\n+    unreachable!();\n+}\n+\n+fn generate_needless_collect_is_empty_sugg<'a, 'tcx>(collect_expr: &'tcx Expr, cx: &LateContext<'a, 'tcx>) -> String {\n+    if let ExprKind::MethodCall(_, _, ref args) = collect_expr.node {\n+        let iter = snippet(cx, args[0].span, \"??\");\n+        return format!(\"{}.any(|_| true)\", iter);\n+    }\n+    unreachable!();\n+}\n+\n+fn generate_needless_collect_contains_sugg<'a, 'tcx>(collect_expr: &'tcx Expr, contains_arg: &'tcx Expr, cx: &LateContext<'a, 'tcx>) -> String {\n+    if let ExprKind::MethodCall(_, _, ref args) = collect_expr.node {\n+        let iter = snippet(cx, args[0].span, \"??\");\n+        let arg = snippet(cx, contains_arg.span, \"??\");\n+        return format!(\"{}.any(|&x| x == {})\", iter, if arg.starts_with('&') { &arg[1..] } else { &arg });\n+    }\n+    unreachable!();\n+}"}, {"sha": "89054ecc66f60c623c8587eed4911b55ac2ad87b", "filename": "needless_collect", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/needless_collect", "raw_url": "https://github.com/rust-lang/rust/raw/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/needless_collect", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/needless_collect?ref=fbc93c0166e60fc6e56e6597524aeec7d17cbc58"}, {"sha": "5da77755d3919d254f865f16417eeca368f3e47a", "filename": "tests/ui/needless_collect.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/tests%2Fui%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/tests%2Fui%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.rs?ref=fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "patch": "@@ -0,0 +1,10 @@\n+#[warn(clippy, needless_collect)]\n+#[allow(unused_variables, iter_cloned_collect)]\n+fn main() {\n+    let sample = [1; 5];\n+    let len = sample.iter().collect::<Vec<_>>().len();\n+    if sample.iter().collect::<Vec<_>>().is_empty() {\n+        // Empty\n+    }\n+    sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n+}"}, {"sha": "b4e478c7eeca9ff25b43daea3f6f38522c28c907", "filename": "tests/ui/needless_collect.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/tests%2Fui%2Fneedless_collect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fbc93c0166e60fc6e56e6597524aeec7d17cbc58/tests%2Fui%2Fneedless_collect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect.stderr?ref=fbc93c0166e60fc6e56e6597524aeec7d17cbc58", "patch": "@@ -0,0 +1,22 @@\n+error: you are collecting an iterator to check its length\n+ --> $DIR/needless_collect.rs:5:15\n+  |\n+5 |     let len = sample.iter().collect::<Vec<_>>().len();\n+  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `sample.iter().count()`\n+  |\n+  = note: `-D needless-collect` implied by `-D warnings`\n+\n+error: you are collecting an iterator to check if it is empty\n+ --> $DIR/needless_collect.rs:6:8\n+  |\n+6 |     if sample.iter().collect::<Vec<_>>().is_empty() {\n+  |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `sample.iter().any(|_| true)`\n+\n+error: you are collecting an iterator to check if contains an element\n+ --> $DIR/needless_collect.rs:9:5\n+  |\n+9 |     sample.iter().cloned().collect::<Vec<_>>().contains(&1);\n+  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider replacing with: `sample.iter().cloned().any(|&x| x == 1)`\n+\n+error: aborting due to 3 previous errors\n+"}]}