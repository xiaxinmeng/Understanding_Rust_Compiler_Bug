{"sha": "7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNjExZDkyMjQwZDQzZDlhMDRjZjhkYjBjYjRmYjU2OTBmODI0OWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-10T18:10:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-10T18:10:08Z"}, "message": "Auto merge of #5769 - robojumper:match_like_matches_macro, r=phansch\n\nnew lint: match_like_matches_macro\n\nSuggests using the `matches!` macro from `std` where appropriate.\n\n`redundant_pattern_matching` has been moved into the `matches` pass to allow suppressing the suggestion where `is_some` and friends are a better replacement.\n\nchangelog: new lint: `match_like_matches_macro`", "tree": {"sha": "77fa94daf53e0cb5ef76f48f6aad27c31888b3a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77fa94daf53e0cb5ef76f48f6aad27c31888b3a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "html_url": "https://github.com/rust-lang/rust/commit/7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be8812203998042783b4ea9850cd8cfa3fd26242", "url": "https://api.github.com/repos/rust-lang/rust/commits/be8812203998042783b4ea9850cd8cfa3fd26242", "html_url": "https://github.com/rust-lang/rust/commit/be8812203998042783b4ea9850cd8cfa3fd26242"}, {"sha": "37d75da266443dd4253ceedebd692ba77dd72e03", "url": "https://api.github.com/repos/rust-lang/rust/commits/37d75da266443dd4253ceedebd692ba77dd72e03", "html_url": "https://github.com/rust-lang/rust/commit/37d75da266443dd4253ceedebd692ba77dd72e03"}], "stats": {"total": 1155, "additions": 659, "deletions": 496}, "files": [{"sha": "6261ca4879a53587684eccb240271934e460f77f", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -1513,6 +1513,7 @@ Released 2018-09-13\n [`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or\n [`match_as_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_as_ref\n [`match_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_bool\n+[`match_like_matches_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n [`match_on_vec_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_on_vec_items\n [`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n [`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats"}, {"sha": "25ccabc1c883e200811c69b2762d6c0f008a8349", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -122,8 +122,5 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n }\n \n fn kind_is_cmp(kind: BinOpKind) -> bool {\n-    match kind {\n-        BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq => true,\n-        _ => false,\n-    }\n+    matches!(kind, BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq)\n }"}, {"sha": "7839908fe4c91b98900e20b1a0813e6223f8e7cb", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -214,20 +214,20 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n }\n \n fn is_valid_operator(op: BinOp) -> bool {\n-    match op.node {\n+    matches!(\n+        op.node,\n         BinOpKind::Sub\n-        | BinOpKind::Div\n-        | BinOpKind::Eq\n-        | BinOpKind::Lt\n-        | BinOpKind::Le\n-        | BinOpKind::Gt\n-        | BinOpKind::Ge\n-        | BinOpKind::Ne\n-        | BinOpKind::And\n-        | BinOpKind::Or\n-        | BinOpKind::BitXor\n-        | BinOpKind::BitAnd\n-        | BinOpKind::BitOr => true,\n-        _ => false,\n-    }\n+            | BinOpKind::Div\n+            | BinOpKind::Eq\n+            | BinOpKind::Lt\n+            | BinOpKind::Le\n+            | BinOpKind::Gt\n+            | BinOpKind::Ge\n+            | BinOpKind::Ne\n+            | BinOpKind::And\n+            | BinOpKind::Or\n+            | BinOpKind::BitXor\n+            | BinOpKind::BitAnd\n+            | BinOpKind::BitOr\n+    )\n }"}, {"sha": "ceb3c40d869a1ba4409fcd28b50060a2ab628149", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -105,10 +105,7 @@ fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n         _ => return false,\n     }\n \n-    match map.find(map.get_parent_node(id)) {\n-        Some(Node::Param(_)) => true,\n-        _ => false,\n-    }\n+    matches!(map.find(map.get_parent_node(id)), Some(Node::Param(_)))\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {"}, {"sha": "fb26b9fc27d259793ed799f6d6d4888aaec85d3d", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -175,10 +175,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     match (&lhs.kind, &rhs.kind) {\n         (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n-        (l, r) => match (l, r) {\n-            (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n-            (_, _) => true,\n-        },\n+        (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n "}, {"sha": "1bd16e6cce53a3a5fae6dab1fb18b936c1679682", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -305,18 +305,10 @@ fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n }\n \n fn is_block(expr: &Expr) -> bool {\n-    if let ExprKind::Block(..) = expr.kind {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(expr.kind, ExprKind::Block(..))\n }\n \n /// Check if the expression is an `if` or `if let`\n fn is_if(expr: &Expr) -> bool {\n-    if let ExprKind::If(..) = expr.kind {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(expr.kind, ExprKind::If(..))\n }"}, {"sha": "63133a4872a3e76dd698cc3354a490cd2f0fdf91", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -645,13 +645,7 @@ fn is_mutated_static(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::{Field, Index, Path};\n \n     match e.kind {\n-        Path(ref qpath) => {\n-            if let Res::Local(_) = qpath_res(cx, qpath, e.hir_id) {\n-                false\n-            } else {\n-                true\n-            }\n-        },\n+        Path(ref qpath) => !matches!(qpath_res(cx, qpath, e.hir_id), Res::Local(_)),\n         Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n         _ => false,\n     }"}, {"sha": "c4f1af8f4e414f9c891d349fb5708eb78605ce96", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -277,7 +277,6 @@ mod question_mark;\n mod ranges;\n mod redundant_clone;\n mod redundant_field_names;\n-mod redundant_pattern_matching;\n mod redundant_pub_crate;\n mod redundant_static_lifetimes;\n mod reference;\n@@ -623,11 +622,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &matches::INFALLIBLE_DESTRUCTURING_MATCH,\n         &matches::MATCH_AS_REF,\n         &matches::MATCH_BOOL,\n+        &matches::MATCH_LIKE_MATCHES_MACRO,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n         &matches::MATCH_SINGLE_BINDING,\n         &matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n         &matches::MATCH_WILD_ERR_ARM,\n+        &matches::REDUNDANT_PATTERN_MATCHING,\n         &matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n         &matches::SINGLE_MATCH,\n         &matches::SINGLE_MATCH_ELSE,\n@@ -757,7 +758,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ranges::REVERSED_EMPTY_RANGES,\n         &redundant_clone::REDUNDANT_CLONE,\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n-        &redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         &redundant_pub_crate::REDUNDANT_PUB_CRATE,\n         &redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n         &reference::DEREF_ADDROF,\n@@ -956,7 +956,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box missing_doc::MissingDoc::new());\n     store.register_late_pass(|| box missing_inline::MissingInline);\n     store.register_late_pass(|| box if_let_some_result::OkIfLet);\n-    store.register_late_pass(|| box redundant_pattern_matching::RedundantPatternMatching);\n     store.register_late_pass(|| box partialeq_ne_impl::PartialEqNeImpl);\n     store.register_late_pass(|| box unused_io_amount::UnusedIoAmount);\n     let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n@@ -1295,9 +1294,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_AS_REF),\n+        LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n+        LintId::of(&matches::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n@@ -1387,7 +1388,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n-        LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n@@ -1488,8 +1488,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+        LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n+        LintId::of(&matches::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),\n@@ -1526,7 +1528,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&question_mark::QUESTION_MARK),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n-        LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&returns::NEEDLESS_RETURN),"}, {"sha": "168f9f953e4d899b70174f8db6d06b55610f1a09", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -129,10 +129,10 @@ fn check_fn_inner<'tcx>(\n     }\n \n     let mut bounds_lts = Vec::new();\n-    let types = generics.params.iter().filter(|param| match param.kind {\n-        GenericParamKind::Type { .. } => true,\n-        _ => false,\n-    });\n+    let types = generics\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n         for bound in typ.bounds {\n             let mut visitor = RefVisitor::new(cx);\n@@ -337,10 +337,10 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath<'_>, ty: &Ty<'_>) {\n         if let Some(ref last_path_segment) = last_path_segment(qpath).args {\n             if !last_path_segment.parenthesized\n-                && !last_path_segment.args.iter().any(|arg| match arg {\n-                    GenericArg::Lifetime(_) => true,\n-                    _ => false,\n-                })\n+                && !last_path_segment\n+                    .args\n+                    .iter()\n+                    .any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n             {\n                 let hir_id = ty.hir_id;\n                 match self.cx.qpath_res(qpath, hir_id) {"}, {"sha": "396bb6591090321e80c534f2903f68d88b4b3b69", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -2091,17 +2091,11 @@ fn var_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<HirId> {\n }\n \n fn is_loop(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Loop(..) => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Loop(..))\n }\n \n fn is_conditional(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Match(..) => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Match(..))\n }\n \n fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {"}, {"sha": "bd474c208070cb516d9b5ff3305272cc91c8f69d", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 377, "deletions": 15, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -13,14 +13,14 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n-    QPath, RangeEnd,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n+use rustc_span::source_map::{Span, Spanned};\n use std::cmp::Ordering;\n use std::collections::Bound;\n \n@@ -409,6 +409,74 @@ declare_clippy_lint! {\n     \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Lint for redundant pattern matching over `Result` or\n+    /// `Option`\n+    ///\n+    /// **Why is this bad?** It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match`  or `if let` expressions producing a\n+    /// `bool` that could be written using `matches!`\n+    ///\n+    /// **Why is this bad?** Readability and needless complexity.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// let a = if let Some(0) = x {\n+    ///     true\n+    /// } else {\n+    ///     false\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(0));\n+    /// ```\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     infallible_destructuring_match_linted: bool,\n@@ -427,14 +495,20 @@ impl_lint_pass!(Matches => [\n     WILDCARD_IN_OR_PATTERNS,\n     MATCH_SINGLE_BINDING,\n     INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n+\n+        redundant_pattern_match::check(cx, expr);\n+        check_match_like_matches(cx, expr);\n+\n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n@@ -808,13 +882,8 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                     // Some simple checks for exhaustive patterns.\n                     // There is a room for improvements to detect more cases,\n                     // but it can be more expensive to do so.\n-                    let is_pattern_exhaustive = |pat: &&Pat<'_>| {\n-                        if let PatKind::Wild | PatKind::Binding(.., None) = pat.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    };\n+                    let is_pattern_exhaustive =\n+                        |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n                     if patterns.iter().all(is_pattern_exhaustive) {\n                         missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                     }\n@@ -995,6 +1064,79 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     }\n }\n \n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n+        match match_source {\n+            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n+            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n+            _ => return,\n+        }\n+    }\n+}\n+\n+/// Lint a `match` or desugared `if let` for replacement by `matches!`\n+fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n+    if_chain! {\n+        if arms.len() == 2;\n+        if cx.tables().expr_ty(expr).is_bool();\n+        if is_wild(&arms[1].pat);\n+        if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n+        if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n+        if first != second;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            let pat_and_guard = if let Some(Guard::If(g)) = arms[0].guard {\n+                format!(\"{} if {}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability), snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                format!(\"{}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability))\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if first { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            )\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if desugared => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n@@ -1185,10 +1327,7 @@ fn is_unit_expr(expr: &Expr<'_>) -> bool {\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm<'_>) -> bool {\n-    match arm.pat.kind {\n-        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n-        _ => false,\n-    }\n+    matches!(arm.pat.kind, PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE))\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n@@ -1299,6 +1438,229 @@ where\n     None\n }\n \n+mod redundant_pattern_match {\n+    use super::REDUNDANT_PATTERN_MATCHING;\n+    use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n+    use if_chain::if_chain;\n+    use rustc_ast::ast::LitKind;\n+    use rustc_errors::Applicability;\n+    use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n+    use rustc_lint::LateContext;\n+    use rustc_middle::ty;\n+    use rustc_mir::const_eval::is_const_fn;\n+    use rustc_span::source_map::Symbol;\n+\n+    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n+            match match_source {\n+                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n+                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n+                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    fn find_sugg_for_if_let<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        op: &Expr<'_>,\n+        arms: &[Arm<'_>],\n+        keyword: &'static str,\n+    ) {\n+        fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n+            if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n+                return Some(\"is_ok()\");\n+            }\n+            if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n+                return Some(\"is_err()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n+                return Some(\"is_some()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n+                return Some(\"is_none()\");\n+            }\n+            None\n+        }\n+\n+        let hir_id = expr.hir_id;\n+        let good_method = match arms[0].pat.kind {\n+            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_suggestion(cx, hir_id, path)\n+                } else {\n+                    None\n+                }\n+            },\n+            PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n+            _ => None,\n+        };\n+        let good_method = match good_method {\n+            Some(method) => method,\n+            None => return,\n+        };\n+\n+        // check that `while_let_on_iterator` lint does not trigger\n+        if_chain! {\n+            if keyword == \"while\";\n+            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if method_path.ident.name == sym!(next);\n+            if match_trait_method(cx, op, &paths::ITERATOR);\n+            then {\n+                return;\n+            }\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_PATTERN_MATCHING,\n+            arms[0].pat.span,\n+            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+            |diag| {\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                let expr_span = expr.span;\n+\n+                // while let ... = ... { ... }\n+                //                 ^^^\n+                let op_span = op.span.source_callsite();\n+\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^\n+                let span = expr_span.until(op_span.shrink_to_hi());\n+                diag.span_suggestion(\n+                    span,\n+                    \"try this\",\n+                    format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            },\n+        );\n+    }\n+\n+    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+        if arms.len() == 2 {\n+            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+            let hir_id = expr.hir_id;\n+            let found_good_method = match node_pair {\n+                (\n+                    PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n+                    PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n+                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::RESULT_OK,\n+                            &paths::RESULT_ERR,\n+                            \"is_ok()\",\n+                            \"is_err()\",\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n+                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                    if patterns.len() == 1 =>\n+                {\n+                    if let PatKind::Wild = patterns[0].kind {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::OPTION_SOME,\n+                            &paths::OPTION_NONE,\n+                            \"is_some()\",\n+                            \"is_none()\",\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            };\n+\n+            if let Some(good_method) = found_good_method {\n+                span_lint_and_then(\n+                    cx,\n+                    REDUNDANT_PATTERN_MATCHING,\n+                    expr.span,\n+                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                    |diag| {\n+                        let span = expr.span.to(op.span);\n+                        diag.span_suggestion(\n+                            span,\n+                            \"try this\",\n+                            format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                            Applicability::MaybeIncorrect, // snippet\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn find_good_method_for_match<'a>(\n+        arms: &[Arm<'_>],\n+        path_left: &QPath<'_>,\n+        path_right: &QPath<'_>,\n+        expected_left: &[&str],\n+        expected_right: &[&str],\n+        should_be_left: &'a str,\n+        should_be_right: &'a str,\n+        can_suggest_left: impl Fn() -> bool,\n+        can_suggest_right: impl Fn() -> bool,\n+    ) -> Option<&'a str> {\n+        let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+        } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+        } else {\n+            return None;\n+        };\n+\n+        match body_node_pair {\n+            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+                (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n+        if !in_constant(cx, hir_id) {\n+            return true;\n+        }\n+\n+        // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n+        cx.tcx\n+            .get_diagnostic_item(diag_item)\n+            .and_then(|def_id| {\n+                cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n+                    cx.tcx\n+                        .associated_items(*imp)\n+                        .in_definition_order()\n+                        .find_map(|item| match item.kind {\n+                            ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n+                            _ => None,\n+                        })\n+                })\n+            })\n+            .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n+    }\n+}\n+\n #[test]\n fn test_overlapping() {\n     use rustc_span::source_map::DUMMY_SP;"}, {"sha": "4c595029ff7bc32fd81c56a2e7c7c69af1943204", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -1844,10 +1844,10 @@ fn lint_expect_fun_call(\n                         ty::Ref(ty::ReStatic, ..)\n                     )\n                 }),\n-            hir::ExprKind::Path(ref p) => match cx.qpath_res(p, arg.hir_id) {\n-                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _) => true,\n-                _ => false,\n-            },\n+            hir::ExprKind::Path(ref p) => matches!(\n+                cx.qpath_res(p, arg.hir_id),\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+            ),\n             _ => false,\n         }\n     }\n@@ -2028,13 +2028,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     .tables()\n                     .expr_adjustments(arg)\n                     .iter()\n-                    .filter(|adj| {\n-                        if let ty::adjustment::Adjust::Deref(_) = adj.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    })\n+                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n                     .count();\n                 let derefs: String = iter::repeat('*').take(deref_count).collect();\n                 snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));"}, {"sha": "400f4b609af7f577833d183d1bf3486ef2224a88", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -694,12 +694,7 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-\n-        if let ExpnKind::Macro(MacroKind::Attr, _) = data.kind {\n-            true\n-        } else {\n-            false\n-        }\n+        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr, _))\n     } else {\n         false\n     }"}, {"sha": "b84a1a3fe249449a81a574ea2be25118976bbd7e", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -641,28 +641,22 @@ fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n             );\n         }\n \n-        #[allow(clippy::trivially_copy_pass_by_ref)]\n-        fn is_wild<P: std::ops::Deref<Target = Pat>>(pat: &&P) -> bool {\n-            if let PatKind::Wild = pat.kind {\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n         if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n             if let Some((left_index, left_pat)) = patterns[..rest_index]\n                 .iter()\n                 .rev()\n-                .take_while(is_wild)\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n                 .enumerate()\n                 .last()\n             {\n                 span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n             }\n \n-            if let Some((right_index, right_pat)) =\n-                patterns[rest_index + 1..].iter().take_while(is_wild).enumerate().last()\n+            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n+                .iter()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n             {\n                 span_lint(\n                     cx,"}, {"sha": "9c9626735370180deccffb545cc5579933943f59", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -71,10 +71,11 @@ fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp\n fn is_executable(cx: &LateContext<'_>) -> bool {\n     use rustc_session::config::CrateType;\n \n-    cx.tcx.sess.crate_types().iter().any(|t: &CrateType| match t {\n-        CrateType::Executable => true,\n-        _ => false,\n-    })\n+    cx.tcx\n+        .sess\n+        .crate_types()\n+        .iter()\n+        .any(|t: &CrateType| matches!(t, CrateType::Executable))\n }\n \n declare_lint_pass!(MissingInline => [MISSING_INLINE_IN_PUBLIC_ITEMS]);"}, {"sha": "621ebdef2f0b17462cbabee5e277f369899cf47a", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -80,10 +80,12 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if impl_item.generics.params.iter().any(|gen| match gen.kind {\n-                            hir::GenericParamKind::Type { .. } => true,\n-                            _ => false,\n-                        }) {\n+                        if impl_item\n+                            .generics\n+                            .params\n+                            .iter()\n+                            .any(|gen| matches!(gen.kind, hir::GenericParamKind::Type { .. }))\n+                        {\n                             // when the result of `new()` depends on a type parameter we should not require\n                             // an\n                             // impl of `Default`"}, {"sha": "a3521c31a6be6b7f063703b911767113c7ed43b3", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -238,10 +238,10 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n \n             let ty = if needs_check_adjustment {\n                 let adjustments = cx.tables().expr_adjustments(dereferenced_expr);\n-                if let Some(i) = adjustments.iter().position(|adj| match adj.kind {\n-                    Adjust::Borrow(_) | Adjust::Deref(_) => true,\n-                    _ => false,\n-                }) {\n+                if let Some(i) = adjustments\n+                    .iter()\n+                    .position(|adj| matches!(adj.kind, Adjust::Borrow(_) | Adjust::Deref(_)))\n+                {\n                     if i == 0 {\n                         cx.tables().expr_ty(dereferenced_expr)\n                     } else {"}, {"sha": "04be96aa64cf52346cf097d611bf9d6beb698017", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -148,17 +148,11 @@ fn is_arith_expr(expr: &Expr) -> bool {\n #[must_use]\n fn is_bit_op(op: BinOpKind) -> bool {\n     use rustc_ast::ast::BinOpKind::{BitAnd, BitOr, BitXor, Shl, Shr};\n-    match op {\n-        BitXor | BitAnd | BitOr | Shl | Shr => true,\n-        _ => false,\n-    }\n+    matches!(op, BitXor | BitAnd | BitOr | Shl | Shr)\n }\n \n #[must_use]\n fn is_arith_op(op: BinOpKind) -> bool {\n     use rustc_ast::ast::BinOpKind::{Add, Div, Mul, Rem, Sub};\n-    match op {\n-        Add | Sub | Mul | Div | Rem => true,\n-        _ => false,\n-    }\n+    matches!(op, Add | Sub | Mul | Div | Rem)\n }"}, {"sha": "d8d16efb978a53727fe61bdd746c11d2c5a10708", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/be8812203998042783b4ea9850cd8cfa3fd26242/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be8812203998042783b4ea9850cd8cfa3fd26242/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=be8812203998042783b4ea9850cd8cfa3fd26242", "patch": "@@ -1,260 +0,0 @@\n-use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_mir::const_eval::is_const_fn;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Symbol;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Lint for redundant pattern matching over `Result` or\n-    /// `Option`\n-    ///\n-    /// **Why is this bad?** It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RedundantPatternMatching {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n-                _ => return,\n-            }\n-        }\n-    }\n-}\n-\n-fn find_sugg_for_if_let<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    op: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    keyword: &'static str,\n-) {\n-    fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n-        if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n-            return Some(\"is_ok()\");\n-        }\n-        if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n-            return Some(\"is_err()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n-            return Some(\"is_some()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n-            return Some(\"is_none()\");\n-        }\n-        None\n-    }\n-\n-    let hir_id = expr.hir_id;\n-    let good_method = match arms[0].pat.kind {\n-        PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n-            if let PatKind::Wild = patterns[0].kind {\n-                find_suggestion(cx, hir_id, path)\n-            } else {\n-                None\n-            }\n-        },\n-        PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n-        _ => None,\n-    };\n-    let good_method = match good_method {\n-        Some(method) => method,\n-        None => return,\n-    };\n-\n-    // check that `while_let_on_iterator` lint does not trigger\n-    if_chain! {\n-        if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n-        if method_path.ident.name == sym!(next);\n-        if match_trait_method(cx, op, &paths::ITERATOR);\n-        then {\n-            return;\n-        }\n-    }\n-\n-    span_lint_and_then(\n-        cx,\n-        REDUNDANT_PATTERN_MATCHING,\n-        arms[0].pat.span,\n-        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-        |diag| {\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-            let expr_span = expr.span;\n-\n-            // while let ... = ... { ... }\n-            //                 ^^^\n-            let op_span = op.span.source_callsite();\n-\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^\n-            let span = expr_span.until(op_span.shrink_to_hi());\n-            diag.span_suggestion(\n-                span,\n-                \"try this\",\n-                format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-    if arms.len() == 2 {\n-        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-        let hir_id = expr.hir_id;\n-        let found_good_method = match node_pair {\n-            (\n-                PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n-            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::RESULT_OK,\n-                        &paths::RESULT_ERR,\n-                        \"is_ok()\",\n-                        \"is_err()\",\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n-            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n-                if patterns.len() == 1 =>\n-            {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::OPTION_SOME,\n-                        &paths::OPTION_NONE,\n-                        \"is_some()\",\n-                        \"is_none()\",\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(good_method) = found_good_method {\n-            span_lint_and_then(\n-                cx,\n-                REDUNDANT_PATTERN_MATCHING,\n-                expr.span,\n-                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                |diag| {\n-                    let span = expr.span.to(op.span);\n-                    diag.span_suggestion(\n-                        span,\n-                        \"try this\",\n-                        format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                        Applicability::MaybeIncorrect, // snippet\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-#[allow(clippy::too_many_arguments)]\n-fn find_good_method_for_match<'a>(\n-    arms: &[Arm<'_>],\n-    path_left: &QPath<'_>,\n-    path_right: &QPath<'_>,\n-    expected_left: &[&str],\n-    expected_right: &[&str],\n-    should_be_left: &'a str,\n-    should_be_right: &'a str,\n-    can_suggest_left: impl Fn() -> bool,\n-    can_suggest_right: impl Fn() -> bool,\n-) -> Option<&'a str> {\n-    let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n-        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-    } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n-        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-    } else {\n-        return None;\n-    };\n-\n-    match body_node_pair {\n-        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-            (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n-            (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n-    if !in_constant(cx, hir_id) {\n-        return true;\n-    }\n-\n-    // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n-    cx.tcx\n-        .get_diagnostic_item(diag_item)\n-        .and_then(|def_id| {\n-            cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n-                cx.tcx\n-                    .associated_items(*imp)\n-                    .in_definition_order()\n-                    .find_map(|item| match item.kind {\n-                        ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n-                        _ => None,\n-                    })\n-            })\n-        })\n-        .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n-}"}, {"sha": "f204a0ffb2c7b92aed6041cfc80dbbcaf39a7bb7", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -99,12 +99,7 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n     use regex_syntax::hir::Anchor::{EndText, StartText};\n     use regex_syntax::hir::HirKind::{Alternation, Anchor, Concat, Empty, Literal};\n \n-    let is_literal = |e: &[regex_syntax::hir::Hir]| {\n-        e.iter().all(|e| match *e.kind() {\n-            Literal(_) => true,\n-            _ => false,\n-        })\n-    };\n+    let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| matches!(*e.kind(), Literal(_)));\n \n     match *s.kind() {\n         Empty | Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),"}, {"sha": "194786c5c41451be22774b8db0ca7ba16350429b", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -165,10 +165,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables().node_type_opt(pat_id);\n-    var_ty.map_or(false, |var_ty| match var_ty.kind {\n-        ty::Adt(..) => false,\n-        _ => true,\n-    })\n+    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n }\n \n fn check_pat<'tcx>("}, {"sha": "1aeff1baa362e24a2362263c07a946e412abde46", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -25,13 +25,7 @@ declare_clippy_lint! {\n fn is_temporary(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n-        ExprKind::Path(qpath) => {\n-            if let Res::Def(DefKind::Const, ..) = cx.qpath_res(qpath, expr.hir_id) {\n-                true\n-            } else {\n-                false\n-            }\n-        },\n+        ExprKind::Path(qpath) => matches!(cx.qpath_res(qpath, expr.hir_id), Res::Def(DefKind::Const, ..)),\n         _ => false,\n     }\n }"}, {"sha": "71207caecf585fac77088729776b2049d443f14a", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -775,11 +775,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n                     .iter()\n                     .filter(|arg| {\n                         if is_unit(cx.tables().expr_ty(arg)) && !is_unit_literal(arg) {\n-                            if let ExprKind::Match(.., MatchSource::TryDesugar) = &arg.kind {\n-                                false\n-                            } else {\n-                                true\n-                            }\n+                            !matches!(&arg.kind, ExprKind::Match(.., MatchSource::TryDesugar))\n                         } else {\n                             false\n                         }\n@@ -899,17 +895,11 @@ fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n }\n \n fn is_unit(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n-        ty::Tuple(slice) if slice.is_empty() => true,\n-        _ => false,\n-    }\n+    matches!(ty.kind, ty::Tuple(slice) if slice.is_empty())\n }\n \n fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Tup(ref slice) if slice.is_empty() => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n }\n \n declare_clippy_lint! {\n@@ -1154,10 +1144,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n }\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    match typ.kind {\n-        ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => true,\n-        _ => false,\n-    }\n+    matches!(typ.kind, ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n }\n \n fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n@@ -1737,10 +1724,10 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n \n             TyKind::TraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n-                    bound.bound_generic_params.iter().any(|gen| match gen.kind {\n-                        GenericParamKind::Lifetime { .. } => true,\n-                        _ => false,\n-                    })\n+                    bound\n+                        .bound_generic_params\n+                        .iter()\n+                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n                 });\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>"}, {"sha": "25d136e564d3ee8bd8e4633d3c33915ef502c91f", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -58,10 +58,10 @@ declare_lint_pass!(UnnamedAddress => [FN_ADDRESS_COMPARISONS, VTABLE_ADDRESS_COM\n impl LateLintPass<'_> for UnnamedAddress {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         fn is_comparison(binop: BinOpKind) -> bool {\n-            match binop {\n-                BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt => true,\n-                _ => false,\n-            }\n+            matches!(\n+                binop,\n+                BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt\n+            )\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n@@ -72,11 +72,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            if let ty::FnDef(..) = cx.tables().expr_ty(expr).kind {\n-                true\n-            } else {\n-                false\n-            }\n+            matches!(cx.tables().expr_ty(expr).kind, ty::FnDef(..))\n         }\n \n         if_chain! {"}, {"sha": "776c6bc57ca6f857c4d86b699d99a4d5f2351f41", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -169,10 +169,8 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n                 let should_check = parameters.as_ref().map_or(\n                     true,\n-                    |params| !params.parenthesized && !params.args.iter().any(|arg| match arg {\n-                        GenericArg::Lifetime(_) => true,\n-                        _ => false,\n-                    })\n+                    |params| !params.parenthesized\n+                        &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n                 );\n \n                 if should_check {"}, {"sha": "58c1103da9f7dfed78e7039b107944057e7eecb9", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -387,10 +387,7 @@ pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n }\n \n pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n-    match (l, r) {\n-        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)) => true,\n-        _ => false,\n-    }\n+    matches!((l, r), (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)))\n }\n \n pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {"}, {"sha": "0b4cba3fc42dc2e83a2bbb4fd0526cb770d4a84e", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -102,11 +102,7 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n #[must_use]\n pub fn in_macro(span: Span) -> bool {\n     if span.from_expansion() {\n-        if let ExpnKind::Desugaring(..) = span.ctxt().outer_expn_data().kind {\n-            false\n-        } else {\n-            true\n-        }\n+        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n     } else {\n         false\n     }\n@@ -127,10 +123,7 @@ pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n \n /// Checks if given pattern is a wildcard (`_`)\n pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        _ => false,\n-    }\n+    matches!(pat.kind, PatKind::Wild)\n }\n \n /// Checks if type is struct, enum or union type with the given def path."}, {"sha": "87cb454f654bcfb9a2a8ad70c4cceac6ccbd3253", "filename": "clippy_lints/src/utils/numeric_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -51,7 +51,7 @@ impl<'a> NumericLiteral<'a> {\n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n             let (unsuffixed, suffix) = split_suffix(&src, lit_kind);\n-            let float = if let LitKind::Float(..) = lit_kind { true } else { false };\n+            let float = matches!(lit_kind, LitKind::Float(..));\n             Some(NumericLiteral::new(unsuffixed, suffix, float))\n         } else {\n             None"}, {"sha": "47315fa64cd8019cba3c508de3d960a6c50ebcc0", "filename": "src/driver.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -382,13 +382,8 @@ pub fn main() {\n \n         let should_describe_lints = || {\n             let args: Vec<_> = env::args().collect();\n-            args.windows(2).any(|args| {\n-                args[1] == \"help\"\n-                    && match args[0].as_str() {\n-                        \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n-                        _ => false,\n-                    }\n-            })\n+            args.windows(2)\n+                .any(|args| args[1] == \"help\" && matches!(args[0].as_str(), \"-W\" | \"-A\" | \"-D\" | \"-F\"))\n         };\n \n         if !wrapper_mode && should_describe_lints() {"}, {"sha": "888b475548461b17cb447927f716349506ebf665", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -1179,6 +1179,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"matches\",\n     },\n+    Lint {\n+        name: \"match_like_matches_macro\",\n+        group: \"style\",\n+        desc: \"a match that could be written with the matches! macro\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"match_on_vec_items\",\n         group: \"pedantic\",\n@@ -1856,7 +1863,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"use the proper utility function avoiding an `if let`\",\n         deprecation: None,\n-        module: \"redundant_pattern_matching\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"redundant_pub_crate\","}, {"sha": "88d3b0e74900152d33938bf332da60dd9035f31c", "filename": "tests/ui/find_map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Ffind_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Ffind_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffind_map.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -19,6 +19,7 @@ fn main() {\n \n     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s| s.parse().unwrap());\n \n+    #[allow(clippy::match_like_matches_macro)]\n     let _: Option<Flavor> = desserts_of_the_week\n         .iter()\n         .find(|dessert| match *dessert {"}, {"sha": "f279850fef8af91a0c520197efb7571f4e22b5e6", "filename": "tests/ui/find_map.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Ffind_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Ffind_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffind_map.stderr?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -8,7 +8,7 @@ LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s\n    = help: this is more succinctly expressed by calling `.find_map(..)` instead\n \n error: called `find(p).map(q)` on an `Iterator`\n-  --> $DIR/find_map.rs:22:29\n+  --> $DIR/find_map.rs:23:29\n    |\n LL |       let _: Option<Flavor> = desserts_of_the_week\n    |  _____________________________^"}, {"sha": "f3e19092480ad12483c9d6a91ddd36abaaa2ff8e", "filename": "tests/ui/match_expr_like_matches_macro.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+#![allow(unreachable_patterns)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = matches!(x, Some(0));\n+\n+    // Lint\n+    let _w = matches!(x, Some(_));\n+\n+    // Turn into is_none\n+    let _z = x.is_none();\n+\n+    // Lint\n+    let _zz = !matches!(x, Some(r) if r == 0);\n+\n+    // Lint\n+    let _zzz = matches!(x, Some(5));\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        _ => false,\n+    };\n+\n+    // No lint\n+    let _ab = match x {\n+        Some(0) => false,\n+        _ => true,\n+        None => false,\n+    };\n+}"}, {"sha": "fbae7c18b92392f2bf494a59d3efcb684983962a", "filename": "tests/ui/match_expr_like_matches_macro.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -0,0 +1,48 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+#![allow(unreachable_patterns)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = match x {\n+        Some(0) => true,\n+        _ => false,\n+    };\n+\n+    // Lint\n+    let _w = match x {\n+        Some(_) => true,\n+        _ => false,\n+    };\n+\n+    // Turn into is_none\n+    let _z = match x {\n+        Some(_) => false,\n+        None => true,\n+    };\n+\n+    // Lint\n+    let _zz = match x {\n+        Some(r) if r == 0 => false,\n+        _ => true,\n+    };\n+\n+    // Lint\n+    let _zzz = if let Some(5) = x { true } else { false };\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        _ => false,\n+    };\n+\n+    // No lint\n+    let _ab = match x {\n+        Some(0) => false,\n+        _ => true,\n+        None => false,\n+    };\n+}"}, {"sha": "4668f8565a656f54740ecb3eb0a21f2a63f12386", "filename": "tests/ui/match_expr_like_matches_macro.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -0,0 +1,52 @@\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:10:14\n+   |\n+LL |       let _y = match x {\n+   |  ______________^\n+LL | |         Some(0) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(0))`\n+   |\n+   = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:16:14\n+   |\n+LL |       let _w = match x {\n+   |  ______________^\n+LL | |         Some(_) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(_))`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/match_expr_like_matches_macro.rs:22:14\n+   |\n+LL |       let _z = match x {\n+   |  ______________^\n+LL | |         Some(_) => false,\n+LL | |         None => true,\n+LL | |     };\n+   | |_____^ help: try this: `x.is_none()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:28:15\n+   |\n+LL |       let _zz = match x {\n+   |  _______________^\n+LL | |         Some(r) if r == 0 => false,\n+LL | |         _ => true,\n+LL | |     };\n+   | |_____^ help: try this: `!matches!(x, Some(r) if r == 0)`\n+\n+error: if let .. else expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:34:16\n+   |\n+LL |     let _zzz = if let Some(5) = x { true } else { false };\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "0cee0a28fc7cd23b6e6b508e6d99f7881c230ee0", "filename": "tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -4,7 +4,7 @@\n \n use std::cmp::Ordering;\n \n-#[allow(clippy::unnested_or_patterns)]\n+#[allow(clippy::unnested_or_patterns, clippy::match_like_matches_macro)]\n #[warn(clippy::neg_cmp_op_on_partial_ord)]\n fn main() {\n     let a_value = 1.0;"}, {"sha": "ce8582d2b221cd21c891bfd38af0d20bfd073ec4", "filename": "tests/ui/redundant_pattern_matching.fixed", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.fixed?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if Ok::<i32, i32>(42).is_ok() {}"}, {"sha": "a3a9aa40e3b9c8ec7fd2b7a708c34bf5d93377ab", "filename": "tests/ui/redundant_pattern_matching.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if let Ok(_) = Ok::<i32, i32>(42) {}"}, {"sha": "25d1476062e7f599e7fe37dfddab9c1ce80bc1c0", "filename": "tests/ui/redundant_pattern_matching.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching.stderr?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -1,73 +1,73 @@\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:8:12\n+  --> $DIR/redundant_pattern_matching.rs:14:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:10:12\n+  --> $DIR/redundant_pattern_matching.rs:16:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:12:12\n+  --> $DIR/redundant_pattern_matching.rs:18:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:14:12\n+  --> $DIR/redundant_pattern_matching.rs:20:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:16:12\n+  --> $DIR/redundant_pattern_matching.rs:22:12\n    |\n LL |     if let Some(_) = Some(42) {\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:22:15\n+  --> $DIR/redundant_pattern_matching.rs:28:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:24:15\n+  --> $DIR/redundant_pattern_matching.rs:30:15\n    |\n LL |     while let None = Some(42) {}\n    |     ----------^^^^----------- help: try this: `while Some(42).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:26:15\n+  --> $DIR/redundant_pattern_matching.rs:32:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:28:15\n+  --> $DIR/redundant_pattern_matching.rs:34:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:30:15\n+  --> $DIR/redundant_pattern_matching.rs:36:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:33:15\n+  --> $DIR/redundant_pattern_matching.rs:39:15\n    |\n LL |     while let Some(_) = v.pop() {\n    |     ----------^^^^^^^---------- help: try this: `while v.pop().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:49:5\n+  --> $DIR/redundant_pattern_matching.rs:55:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -76,7 +76,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:54:5\n+  --> $DIR/redundant_pattern_matching.rs:60:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -85,7 +85,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:59:5\n+  --> $DIR/redundant_pattern_matching.rs:65:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -94,7 +94,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:64:5\n+  --> $DIR/redundant_pattern_matching.rs:70:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -103,7 +103,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:69:5\n+  --> $DIR/redundant_pattern_matching.rs:75:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -112,7 +112,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:74:5\n+  --> $DIR/redundant_pattern_matching.rs:80:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -121,7 +121,7 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:79:13\n+  --> $DIR/redundant_pattern_matching.rs:85:13\n    |\n LL |       let _ = match None::<()> {\n    |  _____________^\n@@ -131,61 +131,61 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:84:20\n+  --> $DIR/redundant_pattern_matching.rs:90:20\n    |\n LL |     let _ = if let Ok(_) = Ok::<usize, ()>(4) { true } else { false };\n    |             -------^^^^^--------------------- help: try this: `if Ok::<usize, ()>(4).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:87:20\n+  --> $DIR/redundant_pattern_matching.rs:93:20\n    |\n LL |     let x = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:93:20\n+  --> $DIR/redundant_pattern_matching.rs:99:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:95:19\n+  --> $DIR/redundant_pattern_matching.rs:101:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:97:19\n+  --> $DIR/redundant_pattern_matching.rs:103:19\n    |\n LL |     } else if let Ok(_) = gen_res() {\n    |            -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:99:19\n+  --> $DIR/redundant_pattern_matching.rs:105:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:132:19\n+  --> $DIR/redundant_pattern_matching.rs:138:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:133:16\n+  --> $DIR/redundant_pattern_matching.rs:139:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:139:12\n+  --> $DIR/redundant_pattern_matching.rs:145:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:140:15\n+  --> $DIR/redundant_pattern_matching.rs:146:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`"}, {"sha": "de3fe00d5fa689b81591706e9acd4693f1073053", "filename": "tests/ui/redundant_pattern_matching_const_result.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_const_result.fixed?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}, {"sha": "b77969d53d92df3def12d657c545d7c62e5ee39d", "filename": "tests/ui/redundant_pattern_matching_const_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching_const_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d611d92240d43d9a04cf8db0cb4fb5690f8249c/tests%2Fui%2Fredundant_pattern_matching_const_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pattern_matching_const_result.rs?ref=7d611d92240d43d9a04cf8db0cb4fb5690f8249c", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}]}