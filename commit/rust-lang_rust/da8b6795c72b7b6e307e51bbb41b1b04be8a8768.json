{"sha": "da8b6795c72b7b6e307e51bbb41b1b04be8a8768", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhOGI2Nzk1YzcyYjdiNmUzMDdlNTFiYmI0MWIxYjA0YmU4YTg3Njg=", "commit": {"author": {"name": "Dave Herman", "email": "dherman@mozilla.com", "date": "2010-10-21T14:36:13Z"}, "committer": {"name": "Dave Herman", "email": "dherman@mozilla.com", "date": "2010-10-21T14:36:13Z"}, "message": "tests and bugfixes: fns take aliases, fixed binary arithmetic in create, eliminated wasted bit per uint", "tree": {"sha": "8edbab055224907e064b8d520cf1560840f6d56a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8edbab055224907e064b8d520cf1560840f6d56a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da8b6795c72b7b6e307e51bbb41b1b04be8a8768", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da8b6795c72b7b6e307e51bbb41b1b04be8a8768", "html_url": "https://github.com/rust-lang/rust/commit/da8b6795c72b7b6e307e51bbb41b1b04be8a8768", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da8b6795c72b7b6e307e51bbb41b1b04be8a8768/comments", "author": null, "committer": null, "parents": [{"sha": "ce3224652f22c5c81e81da3eb31de56683c9d8ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3224652f22c5c81e81da3eb31de56683c9d8ec", "html_url": "https://github.com/rust-lang/rust/commit/ce3224652f22c5c81e81da3eb31de56683c9d8ec"}], "stats": {"total": 351, "additions": 322, "deletions": 29}, "files": [{"sha": "147d5dff5df6e6169f4d544e55b36d89f0cf3613", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da8b6795c72b7b6e307e51bbb41b1b04be8a8768/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da8b6795c72b7b6e307e51bbb41b1b04be8a8768/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=da8b6795c72b7b6e307e51bbb41b1b04be8a8768", "patch": "@@ -5,8 +5,12 @@ import front.token;\n import middle.trans;\n import middle.resolve;\n \n+import util.bits;\n+\n io fn main(vec[str] args) {\n \n+  bits.test();\n+\n   log \"This is the rust 'self-hosted' compiler.\";\n   log \"The one written in rust.\";\n   log \"It does nothing yet, it's a placeholder.\";"}, {"sha": "3c73c1533a1f7410ba04cce28bce3f6c6019bb61", "filename": "src/comp/util/bits.rs", "status": "modified", "additions": 318, "deletions": 29, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/da8b6795c72b7b6e307e51bbb41b1b04be8a8768/src%2Fcomp%2Futil%2Fbits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da8b6795c72b7b6e307e51bbb41b1b04be8a8768/src%2Fcomp%2Futil%2Fbits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fbits.rs?ref=da8b6795c72b7b6e307e51bbb41b1b04be8a8768", "patch": "@@ -5,30 +5,31 @@ import std._vec;\n // FIXME: With recursive object types, we could implement binary methods like\n //        union, intersection, and difference. At that point, we could write\n //        an optimizing version of this module that produces a different obj\n-//        for the case where nbits < 32.\n+//        for the case where nbits <= 32.\n+\n+// FIXME: Almost all the functions in this module should be state fns, but the\n+//        effect system isn't currently working correctly.\n \n state type t = rec(vec[mutable uint] storage, uint nbits);\n \n // FIXME: this should be a constant once they work\n fn uint_bits() -> uint {\n-    ret 32u + ((1u << 32u) >> 27u) - 1u;\n+    ret 32u + ((1u << 32u) >> 27u);\n }\n \n-// FIXME: this should be state\n fn create(uint nbits, bool init) -> t {\n     auto elt;\n     if (init) {\n-        elt = 1u;\n+        elt = ~0u;\n     } else {\n         elt = 0u;\n     }\n \n-    ret rec(storage = _vec.init_elt[mutable uint](nbits / uint_bits() + 1u, elt),\n+    ret rec(storage = _vec.init_elt[mutable uint](elt, nbits / uint_bits() + 1u),\n             nbits = nbits);\n }\n \n-// FIXME: this should be state\n-fn process(fn(uint, uint) -> uint op, t v0, t v1) -> bool {\n+fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n     auto len = _vec.len[mutable uint](v1.storage);\n \n     check (_vec.len[mutable uint](v0.storage) == len);\n@@ -54,8 +55,7 @@ fn lor(uint w0, uint w1) -> uint {\n     ret w0 | w1;\n }\n \n-// FIXME: this should be state\n-fn union(t v0, t v1) -> bool {\n+fn union(&t v0, &t v1) -> bool {\n     auto sub = lor;\n     ret process(sub, v0, v1);\n }\n@@ -64,8 +64,7 @@ fn land(uint w0, uint w1) -> uint {\n     ret w0 & w1;\n }\n \n-// FIXME: this should be state\n-fn intersect(t v0, t v1) -> bool {\n+fn intersect(&t v0, &t v1) -> bool {\n     auto sub = land;\n     ret process(sub, v0, v1);\n }\n@@ -74,14 +73,12 @@ fn right(uint w0, uint w1) -> uint {\n     ret w1;\n }\n \n-// FIXME: this should be state\n-fn copy(t v0, t v1) -> bool {\n+fn copy(&t v0, t v1) -> bool {\n     auto sub = right;\n     ret process(sub, v0, v1);\n }\n \n-// FIXME: this should be state\n-fn get(t v, uint i) -> bool {\n+fn get(&t v, uint i) -> bool {\n     check (i < v.nbits);\n \n     auto bits = uint_bits();\n@@ -92,8 +89,7 @@ fn get(t v, uint i) -> bool {\n     ret x == 1u;\n }\n \n-// FIXME: this should be state\n-fn equal(t v0, t v1) -> bool {\n+fn equal(&t v0, &t v1) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n     auto len = _vec.len[mutable uint](v1.storage);\n@@ -107,31 +103,27 @@ fn equal(t v0, t v1) -> bool {\n     ret true;\n }\n \n-// FIXME: this should be state\n-fn clear(t v) {\n+fn clear(&t v) {\n     for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n \n-// FIXME: this should be state\n-fn invert(t v) {\n+fn invert(&t v) {\n     for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n         v.storage.(i) = ~v.storage.(i);\n     }\n }\n \n-// FIXME: this should be state\n /* v0 = v0 - v1 */\n-fn difference(t v0, t v1) -> bool {\n+fn difference(&t v0, &t v1) -> bool {\n     invert(v1);\n     auto b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n-// FIXME: this should be state\n-fn set(t v, uint i, bool x) {\n+fn set(&t v, uint i, bool x) {\n     check (i < v.nbits);\n \n     auto bits = uint_bits();\n@@ -147,21 +139,318 @@ fn set(t v, uint i, bool x) {\n     }\n }\n \n-// FIXME: this should be state\n-fn init_to_vec(t v, uint i) -> uint {\n+fn init_to_vec(&t v, uint i) -> uint {\n     if (get(v, i)) {\n         ret 1u;\n     } else {\n         ret 0u;\n     }\n }\n \n-// FIXME: this should be state\n-fn to_vec(t v) -> vec[uint] {\n+fn to_vec(&t v) -> vec[uint] {\n     auto sub = bind init_to_vec(v, _);\n     ret _vec.init_fn[uint](sub, v.nbits);\n }\n \n+// FIXME: can we just use structural equality on to_vec?\n+fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n+    check (v0.nbits == _vec.len[uint](v1));\n+    auto len = v0.nbits;\n+    auto i = 0u;\n+    while (i < len) {\n+        auto w0 = get(v0, i);\n+        auto w1 = v1.(i);\n+        if ((!w0 && w1 != 0u) || (w0 && w1 == 0u)) {\n+            ret false;\n+        }\n+        i = i + 1u;\n+    }\n+    ret true;\n+}\n+\n+fn test() {\n+    auto act;\n+    auto exp;\n+\n+    // -----------------------------------------------------------------------\n+    // Tests of 0-element bit-vectors.\n+\n+    act = create(0u, false);\n+    exp = _vec.init_elt[uint](0u, 0u);\n+    // FIXME: why can't I write vec[uint]()?\n+    check (eq_vec(act, exp));\n+\n+    // -----------------------------------------------------------------------\n+    // Tests of 1-element bit-vectors.\n+\n+    act = create(1u, false);\n+    check (eq_vec(act, vec(0u)));\n+\n+    act = create(1u, true);\n+    check (eq_vec(act, vec(1u)));\n+\n+    // -----------------------------------------------------------------------\n+    // Tests of 10-element bit-vectors.\n+\n+    // all 0\n+    act = create(10u, false);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // all 1\n+    act = create(10u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+\n+    // mixed\n+    act = create(10u, false);\n+    set(act, 0u, true);\n+    set(act, 1u, true);\n+    set(act, 2u, true);\n+    set(act, 3u, true);\n+    set(act, 4u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // mixed\n+    act = create(10u, false);\n+    set(act, 5u, true);\n+    set(act, 6u, true);\n+    set(act, 7u, true);\n+    set(act, 8u, true);\n+    set(act, 9u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u)));\n+\n+    // mixed\n+    act = create(10u, false);\n+    set(act, 0u, true);\n+    set(act, 3u, true);\n+    set(act, 6u, true);\n+    set(act, 9u, true);\n+    check (eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n+\n+    // -----------------------------------------------------------------------\n+    // Tests of 31-element bit-vectors.\n+\n+    // all 0\n+    act = create(31u, false);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // all 1\n+    act = create(31u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+\n+    // mixed\n+    act = create(31u, false);\n+    set(act, 0u, true);\n+    set(act, 1u, true);\n+    set(act, 2u, true);\n+    set(act, 3u, true);\n+    set(act, 4u, true);\n+    set(act, 5u, true);\n+    set(act, 6u, true);\n+    set(act, 7u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // mixed\n+    act = create(31u, false);\n+    set(act, 16u, true);\n+    set(act, 17u, true);\n+    set(act, 18u, true);\n+    set(act, 19u, true);\n+    set(act, 20u, true);\n+    set(act, 21u, true);\n+    set(act, 22u, true);\n+    set(act, 23u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // mixed\n+    act = create(31u, false);\n+    set(act, 24u, true);\n+    set(act, 25u, true);\n+    set(act, 26u, true);\n+    set(act, 27u, true);\n+    set(act, 28u, true);\n+    set(act, 29u, true);\n+    set(act, 30u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+\n+    // mixed\n+    act = create(31u, false);\n+    set(act, 3u, true);\n+    set(act, 17u, true);\n+    set(act, 30u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n+\n+    // -----------------------------------------------------------------------\n+    // Tests of 32-element bit-vectors.\n+\n+    // all 0\n+    act = create(32u, false);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // all 1\n+    act = create(32u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+\n+    // mixed\n+    act = create(32u, false);\n+    set(act, 0u, true);\n+    set(act, 1u, true);\n+    set(act, 2u, true);\n+    set(act, 3u, true);\n+    set(act, 4u, true);\n+    set(act, 5u, true);\n+    set(act, 6u, true);\n+    set(act, 7u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // mixed\n+    act = create(32u, false);\n+    set(act, 16u, true);\n+    set(act, 17u, true);\n+    set(act, 18u, true);\n+    set(act, 19u, true);\n+    set(act, 20u, true);\n+    set(act, 21u, true);\n+    set(act, 22u, true);\n+    set(act, 23u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u)));\n+\n+    // mixed\n+    act = create(32u, false);\n+    set(act, 24u, true);\n+    set(act, 25u, true);\n+    set(act, 26u, true);\n+    set(act, 27u, true);\n+    set(act, 28u, true);\n+    set(act, 29u, true);\n+    set(act, 30u, true);\n+    set(act, 31u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u)));\n+\n+    // mixed\n+    act = create(32u, false);\n+    set(act, 3u, true);\n+    set(act, 17u, true);\n+    set(act, 30u, true);\n+    set(act, 31u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n+\n+    // -----------------------------------------------------------------------\n+    // Tests of 33-element bit-vectors.\n+\n+    // all 0\n+    act = create(33u, false);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u)));\n+\n+    // all 1\n+    act = create(33u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           1u)));\n+\n+    // mixed\n+    act = create(33u, false);\n+    set(act, 0u, true);\n+    set(act, 1u, true);\n+    set(act, 2u, true);\n+    set(act, 3u, true);\n+    set(act, 4u, true);\n+    set(act, 5u, true);\n+    set(act, 6u, true);\n+    set(act, 7u, true);\n+    check (eq_vec(act, vec(1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u)));\n+\n+    // mixed\n+    act = create(33u, false);\n+    set(act, 16u, true);\n+    set(act, 17u, true);\n+    set(act, 18u, true);\n+    set(act, 19u, true);\n+    set(act, 20u, true);\n+    set(act, 21u, true);\n+    set(act, 22u, true);\n+    set(act, 23u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u)));\n+\n+    // mixed\n+    act = create(33u, false);\n+    set(act, 24u, true);\n+    set(act, 25u, true);\n+    set(act, 26u, true);\n+    set(act, 27u, true);\n+    set(act, 28u, true);\n+    set(act, 29u, true);\n+    set(act, 30u, true);\n+    set(act, 31u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                           0u)));\n+\n+    // mixed\n+    act = create(33u, false);\n+    set(act, 3u, true);\n+    set(act, 17u, true);\n+    set(act, 30u, true);\n+    set(act, 31u, true);\n+    set(act, 32u, true);\n+    check (eq_vec(act, vec(0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                           0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n+                           1u)));\n+}\n+\n //\n // Local Variables:\n // mode: rust"}]}