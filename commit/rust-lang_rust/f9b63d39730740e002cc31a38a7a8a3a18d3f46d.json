{"sha": "f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YjYzZDM5NzMwNzQwZTAwMmNjMzFhMzhhN2E4YTNhMThkM2Y0NmQ=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2015-08-27T15:10:28Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2015-08-28T16:41:54Z"}, "message": "implement RFC 1194", "tree": {"sha": "ff0b3f0e6e39f13aa8686f003be0e3a197e9e50c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff0b3f0e6e39f13aa8686f003be0e3a197e9e50c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "html_url": "https://github.com/rust-lang/rust/commit/f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40fd4d678706af0684cee1e95304352a6ca02837", "url": "https://api.github.com/repos/rust-lang/rust/commits/40fd4d678706af0684cee1e95304352a6ca02837", "html_url": "https://github.com/rust-lang/rust/commit/40fd4d678706af0684cee1e95304352a6ca02837"}], "stats": {"total": 296, "additions": 283, "deletions": 13}, "files": [{"sha": "3ed4deccb5de6417cf34aede6e3f51a06722b16b", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 92, "deletions": 9, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -459,7 +459,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 }\n             });\n             match result {\n-                Finished(ret) => return ret,\n+                Finished(ret) => return ret.map(|(_, v)| v),\n                 Continue(new_stack) => stack = new_stack\n             }\n         }\n@@ -693,16 +693,16 @@ mod stack {\n     impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::Leaf> {\n         /// Removes the key and value in the top element of the stack, then handles underflows as\n         /// described in BTree's pop function.\n-        fn remove_leaf(mut self) -> V {\n+        fn remove_leaf(mut self) -> (K, V) {\n             self.map.length -= 1;\n \n             // Remove the key-value pair from the leaf that this search stack points to.\n             // Then, note if the leaf is underfull, and promptly forget the leaf and its ptr\n             // to avoid ownership issues.\n-            let (value, mut underflow) = unsafe {\n-                let (_, value) = self.top.from_raw_mut().remove_as_leaf();\n+            let (key_val, mut underflow) = unsafe {\n+                let key_val = self.top.from_raw_mut().remove_as_leaf();\n                 let underflow = self.top.from_raw().node().is_underfull();\n-                (value, underflow)\n+                (key_val, underflow)\n             };\n \n             loop {\n@@ -717,7 +717,7 @@ mod stack {\n                             self.map.depth -= 1;\n                             self.map.root.hoist_lone_child();\n                         }\n-                        return value;\n+                        return key_val;\n                     }\n                     Some(mut handle) => {\n                         if underflow {\n@@ -728,7 +728,7 @@ mod stack {\n                             }\n                         } else {\n                             // All done!\n-                            return value;\n+                            return key_val;\n                         }\n                     }\n                 }\n@@ -739,7 +739,7 @@ mod stack {\n     impl<'a, K, V> SearchStack<'a, K, V, handle::KV, handle::LeafOrInternal> {\n         /// Removes the key and value in the top element of the stack, then handles underflows as\n         /// described in BTree's pop function.\n-        pub fn remove(self) -> V {\n+        pub fn remove(self) -> (K, V) {\n             // Ensure that the search stack goes to a leaf. This is necessary to perform deletion\n             // in a BTree. Note that this may put the tree in an inconsistent state (further\n             // described in into_leaf's comments), but this is immediately fixed by the\n@@ -1208,7 +1208,7 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Takes the value of the entry out of the map, and returns it.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n-        self.stack.remove()\n+        self.stack.remove().1\n     }\n }\n \n@@ -1609,3 +1609,86 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n }\n+\n+impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()> where K: Borrow<Q> + Ord, Q: Ord {\n+    type Key = K;\n+\n+    fn get(&self, key: &Q) -> Option<&K> {\n+        let mut cur_node = &self.root;\n+        loop {\n+            match Node::search(cur_node, key) {\n+                Found(handle) => return Some(handle.into_kv().0),\n+                GoDown(handle) => match handle.force() {\n+                    Leaf(_) => return None,\n+                    Internal(internal_handle) => {\n+                        cur_node = internal_handle.into_edge();\n+                        continue;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn take(&mut self, key: &Q) -> Option<K> {\n+        // See `remove` for an explanation of this.\n+\n+        let mut stack = stack::PartialSearchStack::new(self);\n+        loop {\n+            let result = stack.with(move |pusher, node| {\n+                match Node::search(node, key) {\n+                    Found(handle) => {\n+                        // Perfect match. Terminate the stack here, and remove the entry\n+                        Finished(Some(pusher.seal(handle).remove()))\n+                    },\n+                    GoDown(handle) => {\n+                        // We need to keep searching, try to go down the next edge\n+                        match handle.force() {\n+                            // We're at a leaf; the key isn't in here\n+                            Leaf(_) => Finished(None),\n+                            Internal(internal_handle) => Continue(pusher.push(internal_handle))\n+                        }\n+                    }\n+                }\n+            });\n+            match result {\n+                Finished(ret) => return ret.map(|(k, _)| k),\n+                Continue(new_stack) => stack = new_stack\n+            }\n+        }\n+    }\n+\n+    fn replace(&mut self, mut key: K) -> Option<K> {\n+        // See `insert` for an explanation of this.\n+\n+        let mut stack = stack::PartialSearchStack::new(self);\n+\n+        loop {\n+            let result = stack.with(move |pusher, node| {\n+                match Node::search::<K, _>(node, &key) {\n+                    Found(mut handle) => {\n+                        mem::swap(handle.key_mut(), &mut key);\n+                        Finished(Some(key))\n+                    },\n+                    GoDown(handle) => {\n+                        match handle.force() {\n+                            Leaf(leaf_handle) => {\n+                                pusher.seal(leaf_handle).insert(key, ());\n+                                Finished(None)\n+                            }\n+                            Internal(internal_handle) => {\n+                                Continue((pusher.push(internal_handle), key, ()))\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+            match result {\n+                Finished(ret) => return ret,\n+                Continue((new_stack, renewed_key, _)) => {\n+                    stack = new_stack;\n+                    key = renewed_key;\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "a235021e6396ba7133ab321bff60fe5155c0026b", "filename": "src/libcollections/btree/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmod.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -11,3 +11,11 @@\n mod node;\n pub mod map;\n pub mod set;\n+\n+trait Recover<Q: ?Sized> {\n+    type Key;\n+\n+    fn get(&self, key: &Q) -> Option<&Self::Key>;\n+    fn take(&mut self, key: &Q) -> Option<Self::Key>;\n+    fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n+}"}, {"sha": "fe680c72615eec38a87a6a9eaa3ee71e6c0eacec", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -19,6 +19,7 @@ use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n use borrow::Borrow;\n use btree_map::{BTreeMap, Keys};\n+use super::Recover;\n use Bound;\n \n // FIXME(conventions): implement bounded iterators\n@@ -329,6 +330,16 @@ impl<T: Ord> BTreeSet<T> {\n         self.map.contains_key(value)\n     }\n \n+    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n+    ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T> where T: Borrow<Q>, Q: Ord {\n+        Recover::get(&self.map, value)\n+    }\n+\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     ///\n@@ -436,6 +447,13 @@ impl<T: Ord> BTreeSet<T> {\n         self.map.insert(value, ()).is_none()\n     }\n \n+    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n+    /// one. Returns the replaced value.\n+    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    pub fn replace(&mut self, value: T) -> Option<T> {\n+        Recover::replace(&mut self.map, value)\n+    }\n+\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n@@ -458,6 +476,16 @@ impl<T: Ord> BTreeSet<T> {\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool where T: Borrow<Q>, Q: Ord {\n         self.map.remove(value).is_some()\n     }\n+\n+    /// Removes and returns the value in the set, if any, that is equal to the given one.\n+    ///\n+    /// The value may be any borrowed form of the set's value type,\n+    /// but the ordering on the borrowed form *must* match the\n+    /// ordering on the value type.\n+    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T> where T: Borrow<Q>, Q: Ord {\n+        Recover::take(&mut self.map, value)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e7593bfcfe55634e230f611013608e1f3199fed9", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -211,3 +211,52 @@ fn test_extend_ref() {\n     assert!(a.contains(&5));\n     assert!(a.contains(&6));\n }\n+\n+#[test]\n+fn test_recovery() {\n+    use std::cmp::Ordering;\n+\n+    #[derive(Debug)]\n+    struct Foo(&'static str, i32);\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, other: &Self) -> bool {\n+            self.0 == other.0\n+        }\n+    }\n+\n+    impl Eq for Foo {}\n+\n+    impl PartialOrd for Foo {\n+        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+            self.0.partial_cmp(&other.0)\n+        }\n+    }\n+\n+    impl Ord for Foo {\n+        fn cmp(&self, other: &Self) -> Ordering {\n+            self.0.cmp(&other.0)\n+        }\n+    }\n+\n+    let mut s = BTreeSet::new();\n+    assert_eq!(s.replace(Foo(\"a\", 1)), None);\n+    assert_eq!(s.len(), 1);\n+    assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n+    assert_eq!(s.len(), 1);\n+\n+    {\n+        let mut it = s.iter();\n+        assert_eq!(it.next(), Some(&Foo(\"a\", 2)));\n+        assert_eq!(it.next(), None);\n+    }\n+\n+    assert_eq!(s.get(&Foo(\"a\", 1)), Some(&Foo(\"a\", 2)));\n+    assert_eq!(s.take(&Foo(\"a\", 1)), Some(Foo(\"a\", 2)));\n+    assert_eq!(s.len(), 0);\n+\n+    assert_eq!(s.get(&Foo(\"a\", 1)), None);\n+    assert_eq!(s.take(&Foo(\"a\", 1)), None);\n+\n+    assert_eq!(s.iter().next(), None);\n+}"}, {"sha": "5748c105eed97f17e8f9639d86e797053d470a51", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -25,6 +25,7 @@\n #![feature(rand)]\n #![feature(range_inclusive)]\n #![feature(rustc_private)]\n+#![feature(set_recovery)]\n #![feature(slice_bytes)]\n #![feature(slice_splits)]\n #![feature(split_off)]"}, {"sha": "1e5c012e7d8084880726a88342bdc1cdc2ea489b", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -769,7 +769,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// If the key already exists, the hashtable will be returned untouched\n     /// and a reference to the existing element will be returned.\n     fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        self.insert_or_replace_with(hash, k, v, |_, _, _| ())\n+        self.insert_or_replace_with(hash, k, v, |_, _, _, _| ())\n     }\n \n     fn insert_or_replace_with<'a, F>(&'a mut self,\n@@ -778,7 +778,7 @@ impl<K, V, S> HashMap<K, V, S>\n                                      v: V,\n                                      mut found_existing: F)\n                                      -> &'a mut V where\n-        F: FnMut(&mut K, &mut V, V),\n+        F: FnMut(&mut K, &mut V, K, V),\n     {\n         // Worst case, we'll find one empty bucket among `size + 1` buckets.\n         let size = self.table.size();\n@@ -801,7 +801,7 @@ impl<K, V, S> HashMap<K, V, S>\n                     let (bucket_k, bucket_v) = bucket.into_mut_refs();\n                     debug_assert!(k == *bucket_k);\n                     // Key already exists. Get its reference.\n-                    found_existing(bucket_k, bucket_v, v);\n+                    found_existing(bucket_k, bucket_v, k, v);\n                     return bucket_v;\n                 }\n             }\n@@ -1123,7 +1123,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.reserve(1);\n \n         let mut retval = None;\n-        self.insert_or_replace_with(hash, k, v, |_, val_ref, val| {\n+        self.insert_or_replace_with(hash, k, v, |_, val_ref, _, val| {\n             retval = Some(replace(val_ref, val));\n         });\n         retval\n@@ -1630,6 +1630,35 @@ impl Default for RandomState {\n     }\n }\n \n+impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n+    where K: Eq + Hash + Borrow<Q>, S: HashState, Q: Eq + Hash\n+{\n+    type Key = K;\n+\n+    fn get(&self, key: &Q) -> Option<&K> {\n+        self.search(key).map(|bucket| bucket.into_refs().0)\n+    }\n+\n+    fn take(&mut self, key: &Q) -> Option<K> {\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n+    }\n+\n+    fn replace(&mut self, key: K) -> Option<K> {\n+        let hash = self.make_hash(&key);\n+        self.reserve(1);\n+\n+        let mut retkey = None;\n+        self.insert_or_replace_with(hash, key, (), |key_ref, _, key, _| {\n+            retkey = Some(replace(key_ref, key));\n+        });\n+        retkey\n+    }\n+}\n+\n #[cfg(test)]\n mod test_map {\n     use prelude::v1::*;"}, {"sha": "4a6fcf44926a334e4e3b033d7152dc6a3d8c7806", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -15,3 +15,11 @@ mod table;\n pub mod map;\n pub mod set;\n pub mod state;\n+\n+trait Recover<Q: ?Sized> {\n+    type Key;\n+\n+    fn get(&self, key: &Q) -> Option<&Self::Key>;\n+    fn take(&mut self, key: &Q) -> Option<Self::Key>;\n+    fn replace(&mut self, key: Self::Key) -> Option<Self::Key>;\n+}"}, {"sha": "1f19a72371c9adc51a08b0dbe3dd07ca2ed96b51", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9b63d39730740e002cc31a38a7a8a3a18d3f46d/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=f9b63d39730740e002cc31a38a7a8a3a18d3f46d", "patch": "@@ -20,6 +20,7 @@ use iter::{Iterator, IntoIterator, ExactSizeIterator, FromIterator, Map, Chain,\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n+use super::Recover;\n use super::map::{self, HashMap, Keys, RandomState};\n use super::state::HashState;\n \n@@ -459,6 +460,18 @@ impl<T, S> HashSet<T, S>\n         self.map.contains_key(value)\n     }\n \n+    /// Returns a reference to the value in the set, if any, that is equal to the given value.\n+    ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    pub fn get<Q: ?Sized>(&self, value: &Q) -> Option<&T>\n+        where T: Borrow<Q>, Q: Hash + Eq\n+    {\n+        Recover::get(&self.map, value)\n+    }\n+\n     /// Returns `true` if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     ///\n@@ -544,6 +557,13 @@ impl<T, S> HashSet<T, S>\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n \n+    /// Adds a value to the set, replacing the existing value, if any, that is equal to the given\n+    /// one. Returns the replaced value.\n+    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    pub fn replace(&mut self, value: T) -> Option<T> {\n+        Recover::replace(&mut self.map, value)\n+    }\n+\n     /// Removes a value from the set. Returns `true` if the value was\n     /// present in the set.\n     ///\n@@ -568,6 +588,18 @@ impl<T, S> HashSet<T, S>\n     {\n         self.map.remove(value).is_some()\n     }\n+\n+    /// Removes and returns the value in the set, if any, that is equal to the given one.\n+    ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    #[unstable(feature = \"set_recovery\", issue = \"28050\")]\n+    pub fn take<Q: ?Sized>(&mut self, value: &Q) -> Option<T>\n+        where T: Borrow<Q>, Q: Hash + Eq\n+    {\n+        Recover::take(&mut self.map, value)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1261,4 +1293,36 @@ mod test_set {\n             s.extend(1..100);\n         }\n     }\n+\n+    #[test]\n+    fn test_replace() {\n+        use hash;\n+\n+        #[derive(Debug)]\n+        struct Foo(&'static str, i32);\n+\n+        impl PartialEq for Foo {\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl Eq for Foo {}\n+\n+        impl hash::Hash for Foo {\n+            fn hash<H: hash::Hasher>(&self, h: &mut H) {\n+                self.0.hash(h);\n+            }\n+        }\n+\n+        let mut s = HashSet::new();\n+        assert_eq!(s.replace(Foo(\"a\", 1)), None);\n+        assert_eq!(s.len(), 1);\n+        assert_eq!(s.replace(Foo(\"a\", 2)), Some(Foo(\"a\", 1)));\n+        assert_eq!(s.len(), 1);\n+\n+        let mut it = s.iter();\n+        assert_eq!(it.next(), Some(&Foo(\"a\", 2)));\n+        assert_eq!(it.next(), None);\n+    }\n }"}]}