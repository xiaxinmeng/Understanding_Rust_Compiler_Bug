{"sha": "da573206f87b5510de4b0ee1a9c044127e409bd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTczMjA2Zjg3YjU1MTBkZTRiMGVlMWE5YzA0NDEyN2U0MDliZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T11:57:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-25T11:57:00Z"}, "message": "Auto merge of #58728 - Centril:rollup, r=Centril\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #55632 (Deny the `overflowing_literals` lint for all editions)\n - #58687 (Reduce Miri Code Repetition like `(n << amt) >> amt`)\n - #58690 (Reduce a Code Repetition like `(n << amt) >> amt`)\n - #58718 (Apply docs convention: Replace # Unsafety with # Safety in docs)\n - #58719 (librustc_codegen_llvm: #![deny(elided_lifetimes_in_paths)])\n - #58720 (librustc_codegen_ssa: #![deny(elided_lifetimes_in_paths)])\n - #58722 (librustc_typeck: deny(elided_lifetimes_in_paths))\n - #58723 (librustc: deny(elided_lifetimes_in_paths))\n - #58725 (Test that binop subtyping in rustc_typeck fixes #27949)\n - #58727 (bootstrap: deny(rust_2018_idioms))\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2c7b768fbdd02447625350e6d53fd8f7910a5003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c7b768fbdd02447625350e6d53fd8f7910a5003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da573206f87b5510de4b0ee1a9c044127e409bd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da573206f87b5510de4b0ee1a9c044127e409bd3", "html_url": "https://github.com/rust-lang/rust/commit/da573206f87b5510de4b0ee1a9c044127e409bd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da573206f87b5510de4b0ee1a9c044127e409bd3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "url": "https://api.github.com/repos/rust-lang/rust/commits/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be", "html_url": "https://github.com/rust-lang/rust/commit/31eb0e2d3c0bfd2e0f5b662d82971c1a203708be"}, {"sha": "d6de1e9714b58298a688026470aeeffcf3645314", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6de1e9714b58298a688026470aeeffcf3645314", "html_url": "https://github.com/rust-lang/rust/commit/d6de1e9714b58298a688026470aeeffcf3645314"}], "stats": {"total": 1149, "additions": 625, "deletions": 524}, "files": [{"sha": "7e6c0a9f52aa21bb1d6f28edd335ff34203f81c5", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -62,21 +62,21 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n     /// Primary function to execute this rule. Can call `builder.ensure()`\n     /// with other steps to run those.\n-    fn run(self, builder: &Builder) -> Self::Output;\n+    fn run(self, builder: &Builder<'_>) -> Self::Output;\n \n     /// When bootstrap is passed a set of paths, this controls whether this rule\n     /// will execute. However, it does not get called in a \"default\" context\n     /// when we are not passed any paths; in that case, `make_run` is called\n     /// directly.\n-    fn should_run(run: ShouldRun) -> ShouldRun;\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_>;\n \n     /// Builds up a \"root\" rule, either as a default rule or from a path passed\n     /// to us.\n     ///\n     /// When path is `None`, we are executing in a context where no paths were\n     /// passed. When `./x.py build` is run, for example, this rule could get\n     /// called if it is in the correct list below with a path of `None`.\n-    fn make_run(_run: RunConfig) {\n+    fn make_run(_run: RunConfig<'_>) {\n         // It is reasonable to not have an implementation of make_run for rules\n         // who do not want to get called from the root context. This means that\n         // they are likely dependencies (e.g., sysroot creation) or similar, and\n@@ -95,8 +95,8 @@ pub struct RunConfig<'a> {\n struct StepDescription {\n     default: bool,\n     only_hosts: bool,\n-    should_run: fn(ShouldRun) -> ShouldRun,\n-    make_run: fn(RunConfig),\n+    should_run: fn(ShouldRun<'_>) -> ShouldRun<'_>,\n+    make_run: fn(RunConfig<'_>),\n     name: &'static str,\n }\n \n@@ -124,7 +124,7 @@ impl PathSet {\n         }\n     }\n \n-    fn path(&self, builder: &Builder) -> PathBuf {\n+    fn path(&self, builder: &Builder<'_>) -> PathBuf {\n         match self {\n             PathSet::Set(set) => set\n                 .iter()\n@@ -147,7 +147,7 @@ impl StepDescription {\n         }\n     }\n \n-    fn maybe_run(&self, builder: &Builder, pathset: &PathSet) {\n+    fn maybe_run(&self, builder: &Builder<'_>, pathset: &PathSet) {\n         if builder.config.exclude.iter().any(|e| pathset.has(e)) {\n             eprintln!(\"Skipping {:?} because it is excluded\", pathset);\n             return;\n@@ -183,7 +183,7 @@ impl StepDescription {\n         }\n     }\n \n-    fn run(v: &[StepDescription], builder: &Builder, paths: &[PathBuf]) {\n+    fn run(v: &[StepDescription], builder: &Builder<'_>, paths: &[PathBuf]) {\n         let should_runs = v\n             .iter()\n             .map(|desc| (desc.should_run)(ShouldRun::new(builder)))\n@@ -245,7 +245,7 @@ pub struct ShouldRun<'a> {\n }\n \n impl<'a> ShouldRun<'a> {\n-    fn new(builder: &'a Builder) -> ShouldRun<'a> {\n+    fn new(builder: &'a Builder<'_>) -> ShouldRun<'a> {\n         ShouldRun {\n             builder,\n             paths: BTreeSet::new(),\n@@ -511,7 +511,7 @@ impl<'a> Builder<'a> {\n         Some(help)\n     }\n \n-    pub fn new(build: &Build) -> Builder {\n+    pub fn new(build: &Build) -> Builder<'_> {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n@@ -591,11 +591,11 @@ impl<'a> Builder<'a> {\n         impl Step for Libdir {\n             type Output = Interned<PathBuf>;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.never()\n             }\n \n-            fn run(self, builder: &Builder) -> Interned<PathBuf> {\n+            fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n                 let compiler = self.compiler;\n                 let config = &builder.build.config;\n                 let lib = if compiler.stage >= 1 && config.libdir_relative().is_some() {"}, {"sha": "239959682cb005771bccfd074bd5c9d4d2e0ecb1", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -68,20 +68,20 @@ unsafe impl<T> Send for Interned<T> {}\n unsafe impl<T> Sync for Interned<T> {}\n \n impl fmt::Display for Interned<String> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let s: &str = &*self;\n         f.write_str(s)\n     }\n }\n \n impl fmt::Debug for Interned<String> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let s: &str = &*self;\n         f.write_fmt(format_args!(\"{:?}\", s))\n     }\n }\n impl fmt::Debug for Interned<PathBuf> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let s: &Path = &*self;\n         f.write_fmt(format_args!(\"{:?}\", s))\n     }"}, {"sha": "dfc243b7054abf6caf660bf6610828cf537308c7", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -27,7 +27,6 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use build_helper::output;\n-use cc;\n \n use crate::{Build, GitRepo};\n use crate::config::Target;\n@@ -157,7 +156,7 @@ fn set_compiler(cfg: &mut cc::Build,\n                 None => return,\n             };\n             match output[i + 3..].chars().next().unwrap() {\n-                '0' ... '6' => {}\n+                '0' ..= '6' => {}\n                 _ => return,\n             }\n             let alternative = format!(\"e{}\", gnu_compiler);"}, {"sha": "20370372082b94ef009ab1408ad143ff28423799", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -17,17 +17,17 @@ impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"std\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = builder.compiler(0, builder.config.build);\n \n@@ -56,11 +56,11 @@ impl Step for Rustc {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc-main\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             target: run.target,\n         });\n@@ -71,7 +71,7 @@ impl Step for Rustc {\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n@@ -103,11 +103,11 @@ impl Step for CodegenBackend {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let backend = run.builder.config.rust_codegen_backends.get(0);\n         let backend = backend.cloned().unwrap_or_else(|| {\n             INTERNER.intern_str(\"llvm\")\n@@ -118,7 +118,7 @@ impl Step for CodegenBackend {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n         let backend = self.backend;\n@@ -148,17 +148,17 @@ impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"test\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Test {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n@@ -189,17 +189,17 @@ impl Step for Rustdoc {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustdoc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n@@ -229,25 +229,37 @@ impl Step for Rustdoc {\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libstd_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libtest_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn librustc_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc-check.stamp\")\n }\n \n /// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n-fn codegen_backend_stamp(builder: &Builder,\n+fn codegen_backend_stamp(builder: &Builder<'_>,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n@@ -257,7 +269,11 @@ fn codegen_backend_stamp(builder: &Builder,\n \n /// Cargo's output path for rustdoc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn rustdoc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn rustdoc_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::ToolRustc, target)\n         .join(\".rustdoc-check.stamp\")\n }"}, {"sha": "249a18318904831ff362d09da4ed8854858b4d5f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 66, "deletions": 47, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -37,11 +37,11 @@ impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"std\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -53,7 +53,7 @@ impl Step for Std {\n     /// This will build the standard library for a particular stage of the build\n     /// using the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = self.compiler;\n \n@@ -111,7 +111,7 @@ impl Step for Std {\n }\n \n /// Copies third pary objects needed by various targets.\n-fn copy_third_party_objects(builder: &Builder, compiler: &Compiler, target: Interned<String>) {\n+fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target: Interned<String>) {\n     let libdir = builder.sysroot_libdir(*compiler, target);\n \n     // Copies the crt(1,i,n).o startup objects\n@@ -145,7 +145,7 @@ fn copy_third_party_objects(builder: &Builder, compiler: &Compiler, target: Inte\n \n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n-pub fn std_cargo(builder: &Builder,\n+pub fn std_cargo(builder: &Builder<'_>,\n                  compiler: &Compiler,\n                  target: Interned<String>,\n                  cargo: &mut Command) {\n@@ -201,7 +201,7 @@ struct StdLink {\n impl Step for StdLink {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -213,7 +213,7 @@ impl Step for StdLink {\n     /// Note that this assumes that `compiler` has already generated the libstd\n     /// libraries for `target`, and this method will find them in the relevant\n     /// output directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n@@ -237,7 +237,12 @@ impl Step for StdLink {\n     }\n }\n \n-fn copy_apple_sanitizer_dylibs(builder: &Builder, native_dir: &Path, platform: &str, into: &Path) {\n+fn copy_apple_sanitizer_dylibs(\n+    builder: &Builder<'_>,\n+    native_dir: &Path,\n+    platform: &str,\n+    into: &Path,\n+) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"lib__rustc__clang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);\n         let mut src_path = native_dir.join(sanitizer);\n@@ -258,11 +263,11 @@ pub struct StartupObjects {\n impl Step for StartupObjects {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/rtstartup\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(StartupObjects {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -275,7 +280,7 @@ impl Step for StartupObjects {\n     /// They don't require any library support as they're just plain old object\n     /// files, so we just use the nightly snapshot compiler to always build them (as\n     /// no other compilers are guaranteed to be available).\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let for_compiler = self.compiler;\n         let target = self.target;\n         if !target.contains(\"pc-windows-gnu\") {\n@@ -323,11 +328,11 @@ impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"test\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Test {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -339,7 +344,7 @@ impl Step for Test {\n     /// This will build libtest and supporting libraries for a particular stage of\n     /// the build using the `compiler` targeting the `target` architecture. The\n     /// artifacts created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = self.compiler;\n \n@@ -390,7 +395,7 @@ impl Step for Test {\n }\n \n /// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(builder: &Builder,\n+pub fn test_cargo(builder: &Builder<'_>,\n                   _compiler: &Compiler,\n                   _target: Interned<String>,\n                   cargo: &mut Command) {\n@@ -411,12 +416,12 @@ pub struct TestLink {\n impl Step for TestLink {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Same as `std_link`, only for libtest\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n@@ -444,11 +449,11 @@ impl Step for Rustc {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc-main\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n             target: run.target,\n@@ -460,7 +465,7 @@ impl Step for Rustc {\n     /// This will build the compiler for a particular stage of the build using\n     /// the `compiler` targeting the `target` architecture. The artifacts\n     /// created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -516,14 +521,14 @@ impl Step for Rustc {\n     }\n }\n \n-pub fn rustc_cargo(builder: &Builder, cargo: &mut Command) {\n+pub fn rustc_cargo(builder: &Builder<'_>, cargo: &mut Command) {\n     cargo.arg(\"--features\").arg(builder.rustc_features())\n          .arg(\"--manifest-path\")\n          .arg(builder.src.join(\"src/rustc/Cargo.toml\"));\n     rustc_cargo_env(builder, cargo);\n }\n \n-pub fn rustc_cargo_env(builder: &Builder, cargo: &mut Command) {\n+pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Command) {\n     // Set some configuration variables picked up by build scripts and\n     // the compiler alike\n     cargo.env(\"CFG_RELEASE\", builder.rust_release())\n@@ -572,12 +577,12 @@ struct RustcLink {\n impl Step for RustcLink {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Same as `std_link`, only for librustc\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n@@ -605,11 +610,11 @@ impl Step for CodegenBackend {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.all_krates(\"rustc_codegen_llvm\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let backend = run.builder.config.rust_codegen_backends.get(0);\n         let backend = backend.cloned().unwrap_or_else(|| {\n             INTERNER.intern_str(\"llvm\")\n@@ -621,7 +626,7 @@ impl Step for CodegenBackend {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let backend = self.backend;\n@@ -684,7 +689,7 @@ impl Step for CodegenBackend {\n     }\n }\n \n-pub fn build_codegen_backend(builder: &Builder,\n+pub fn build_codegen_backend(builder: &Builder<'_>,\n                              cargo: &mut Command,\n                              compiler: &Compiler,\n                              target: Interned<String>,\n@@ -753,7 +758,7 @@ pub fn build_codegen_backend(builder: &Builder,\n /// This will take the codegen artifacts produced by `compiler` and link them\n /// into an appropriate location for `target_compiler` to be a functional\n /// compiler.\n-fn copy_codegen_backends_to_sysroot(builder: &Builder,\n+fn copy_codegen_backends_to_sysroot(builder: &Builder<'_>,\n                                     compiler: Compiler,\n                                     target_compiler: Compiler) {\n     let target = target_compiler.host;\n@@ -791,7 +796,7 @@ fn copy_codegen_backends_to_sysroot(builder: &Builder,\n     }\n }\n \n-fn copy_lld_to_sysroot(builder: &Builder,\n+fn copy_lld_to_sysroot(builder: &Builder<'_>,\n                        target_compiler: Compiler,\n                        lld_install_root: &Path) {\n     let target = target_compiler.host;\n@@ -811,36 +816,50 @@ fn copy_lld_to_sysroot(builder: &Builder,\n \n /// Cargo's output path for the standard library in a given stage, compiled\n /// by a particular compiler for the specified target.\n-pub fn libstd_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libstd_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n /// Cargo's output path for libtest in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn libtest_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn libtest_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n }\n \n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n-pub fn librustc_stamp(builder: &Builder, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+pub fn librustc_stamp(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Rustc, target).join(\".librustc.stamp\")\n }\n \n /// Cargo's output path for librustc_codegen_llvm in a given stage, compiled by a particular\n /// compiler for the specified target and backend.\n-fn codegen_backend_stamp(builder: &Builder,\n+fn codegen_backend_stamp(builder: &Builder<'_>,\n                          compiler: Compiler,\n                          target: Interned<String>,\n                          backend: Interned<String>) -> PathBuf {\n     builder.cargo_out(compiler, Mode::Codegen, target)\n         .join(format!(\".librustc_codegen_llvm-{}.stamp\", backend))\n }\n \n-pub fn compiler_file(builder: &Builder,\n-                 compiler: &Path,\n-                 target: Interned<String>,\n-                 file: &str) -> PathBuf {\n+pub fn compiler_file(\n+    builder: &Builder<'_>,\n+    compiler: &Path,\n+    target: Interned<String>,\n+    file: &str,\n+) -> PathBuf {\n     let mut cmd = Command::new(compiler);\n     cmd.args(builder.cflags(target, GitRepo::Rustc));\n     cmd.arg(format!(\"-print-file-name={}\", file));\n@@ -856,7 +875,7 @@ pub struct Sysroot {\n impl Step for Sysroot {\n     type Output = Interned<PathBuf>;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -866,7 +885,7 @@ impl Step for Sysroot {\n     /// That is, the sysroot for the stage0 compiler is not what the compiler\n     /// thinks it is by default, but it's the same as the default for stages\n     /// 1-3.\n-    fn run(self, builder: &Builder) -> Interned<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Interned<PathBuf> {\n         let compiler = self.compiler;\n         let sysroot = if compiler.stage == 0 {\n             builder.out.join(&compiler.host).join(\"stage0-sysroot\")\n@@ -891,7 +910,7 @@ pub struct Assemble {\n impl Step for Assemble {\n     type Output = Compiler;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -900,7 +919,7 @@ impl Step for Assemble {\n     /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n     /// must have been previously produced by the `stage - 1` builder.build\n     /// compiler.\n-    fn run(self, builder: &Builder) -> Compiler {\n+    fn run(self, builder: &Builder<'_>) -> Compiler {\n         let target_compiler = self.target_compiler;\n \n         if target_compiler.stage == 0 {\n@@ -996,14 +1015,14 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-pub fn add_to_sysroot(builder: &Builder, sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(builder: &Builder<'_>, sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     for path in builder.read_stamp_file(stamp) {\n         builder.copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n     }\n }\n \n-pub fn run_cargo(builder: &Builder,\n+pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: &mut Command,\n                  stamp: &Path,\n                  is_check: bool)\n@@ -1150,9 +1169,9 @@ pub fn run_cargo(builder: &Builder,\n }\n \n pub fn stream_cargo(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     cargo: &mut Command,\n-    cb: &mut dyn FnMut(CargoMessage),\n+    cb: &mut dyn FnMut(CargoMessage<'_>),\n ) -> bool {\n     if builder.config.dry_run {\n         return true;\n@@ -1174,7 +1193,7 @@ pub fn stream_cargo(\n     let stdout = BufReader::new(child.stdout.take().unwrap());\n     for line in stdout.lines() {\n         let line = t!(line);\n-        match serde_json::from_str::<CargoMessage>(&line) {\n+        match serde_json::from_str::<CargoMessage<'_>>(&line) {\n             Ok(msg) => cb(msg),\n             // If this was informational, just print it out and continue\n             Err(_) => println!(\"{}\", line)"}, {"sha": "2dae3f9135d8448a2d9a598b0adc430aa825cb4d", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -25,7 +25,7 @@ use crate::tool::{self, Tool};\n use crate::cache::{INTERNER, Interned};\n use time::{self, Timespec};\n \n-pub fn pkgname(builder: &Builder, component: &str) -> String {\n+pub fn pkgname(builder: &Builder<'_>, component: &str) -> String {\n     if component == \"cargo\" {\n         format!(\"{}-{}\", component, builder.cargo_package_vers())\n     } else if component == \"rls\" {\n@@ -46,15 +46,15 @@ pub fn pkgname(builder: &Builder, component: &str) -> String {\n     }\n }\n \n-fn distdir(builder: &Builder) -> PathBuf {\n+fn distdir(builder: &Builder<'_>) -> PathBuf {\n     builder.out.join(\"dist\")\n }\n \n-pub fn tmpdir(builder: &Builder) -> PathBuf {\n+pub fn tmpdir(builder: &Builder<'_>) -> PathBuf {\n     builder.out.join(\"tmp/dist\")\n }\n \n-fn rust_installer(builder: &Builder) -> Command {\n+fn rust_installer(builder: &Builder<'_>) -> Command {\n     builder.tool_cmd(Tool::RustInstaller)\n }\n \n@@ -76,19 +76,19 @@ impl Step for Docs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/doc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Docs {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Builds the `rust-docs` installer component.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let host = self.host;\n \n         let name = pkgname(builder, \"rust-docs\");\n@@ -138,19 +138,19 @@ impl Step for RustcDocs {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/librustc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcDocs {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Builds the `rustc-docs` installer component.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let host = self.host;\n \n         let name = pkgname(builder, \"rustc-docs\");\n@@ -210,7 +210,7 @@ fn find_files(files: &[&str], path: &[PathBuf]) -> Vec<PathBuf> {\n }\n \n fn make_win_dist(\n-    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder\n+    rust_root: &Path, plat_root: &Path, target_triple: Interned<String>, builder: &Builder<'_>\n ) {\n     //Ask gcc where it keeps its stuff\n     let mut cmd = Command::new(builder.cc(target_triple));\n@@ -334,19 +334,19 @@ impl Step for Mingw {\n     type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Mingw { host: run.target });\n     }\n \n     /// Builds the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let host = self.host;\n \n         if !host.contains(\"pc-windows-gnu\") {\n@@ -392,18 +392,18 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/librustc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             compiler: run.builder.compiler(run.builder.top_stage, run.target),\n         });\n     }\n \n     /// Creates the `rustc` installer component.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n@@ -470,7 +470,7 @@ impl Step for Rustc {\n \n         return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n \n-        fn prepare_image(builder: &Builder, compiler: Compiler, image: &Path) {\n+        fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n             let src = builder.sysroot(compiler);\n             let libdir = libdir(&host);\n@@ -580,19 +580,19 @@ pub struct DebuggerScripts {\n impl Step for DebuggerScripts {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/lldb_batchmode.py\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(DebuggerScripts {\n             sysroot: run.builder.sysroot(run.builder.compiler(run.builder.top_stage, run.host)),\n             host: run.target,\n         });\n     }\n \n     /// Copies debugger scripts for `target` into the `sysroot` specified.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let host = self.host;\n         let sysroot = self.sysroot;\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n@@ -639,18 +639,18 @@ impl Step for Std {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/libstd\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n \n@@ -728,20 +728,20 @@ impl Step for Analysis {\n     type Output = PathBuf;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"analysis\").default_condition(builder.config.extended)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Analysis {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -791,7 +791,7 @@ impl Step for Analysis {\n     }\n }\n \n-fn copy_src_dirs(builder: &Builder, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n+fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str], dst_dir: &Path) {\n     fn filter_fn(exclude_dirs: &[&str], dir: &str, path: &Path) -> bool {\n         let spath = match path.to_str() {\n             Some(path) => path,\n@@ -861,16 +861,16 @@ impl Step for Src {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Src);\n     }\n \n     /// Creates the `rust-src` installer component\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         builder.info(\"Dist src\");\n \n         let name = pkgname(builder, \"rust-src\");\n@@ -941,17 +941,17 @@ impl Step for PlainSourceTarball {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src\").default_condition(builder.config.rust_dist_src)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(PlainSourceTarball);\n     }\n \n     /// Creates the plain source tarball\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         builder.info(\"Create plain source tarball\");\n \n         // Make sure that the root folder of tarball has the correct name\n@@ -1069,18 +1069,18 @@ impl Step for Cargo {\n     type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"cargo\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let stage = self.stage;\n         let target = self.target;\n \n@@ -1155,18 +1155,18 @@ impl Step for Rls {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"rls\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1234,18 +1234,18 @@ impl Step for Clippy {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"clippy\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1318,18 +1318,18 @@ impl Step for Miri {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"miri\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -1402,18 +1402,18 @@ impl Step for Rustfmt {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"rustfmt\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n \n@@ -1485,12 +1485,12 @@ impl Step for Extended {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"extended\").default_condition(builder.config.extended)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Extended {\n             stage: run.builder.top_stage,\n             host: run.builder.config.build,\n@@ -1499,7 +1499,7 @@ impl Step for Extended {\n     }\n \n     /// Creates a combined installer for the specified target in the provided stage.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n \n@@ -1949,7 +1949,7 @@ impl Step for Extended {\n     }\n }\n \n-fn add_env(builder: &Builder, cmd: &mut Command, target: Interned<String>) {\n+fn add_env(builder: &Builder<'_>, cmd: &mut Command, target: Interned<String>) {\n     let mut parts = channel::CFG_RELEASE_NUM.split('.');\n     cmd.env(\"CFG_RELEASE_INFO\", builder.rust_version())\n        .env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM)\n@@ -1985,15 +1985,15 @@ impl Step for HashSign {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"hash-and-sign\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(HashSign);\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         if builder.config.dry_run {\n             return;\n@@ -2037,7 +2037,7 @@ impl Step for HashSign {\n // LLVM tools are linked dynamically.\n // Note: This function does no yet support Windows but we also don't support\n //       linking LLVM tools dynamically on Windows yet.\n-pub fn maybe_install_llvm_dylib(builder: &Builder,\n+pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n                                 target: Interned<String>,\n                                 sysroot: &Path) {\n     let src_libdir = builder\n@@ -2079,18 +2079,18 @@ impl Step for LlvmTools {\n     type Output = Option<PathBuf>;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"llvm-tools\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(LlvmTools {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n@@ -2163,17 +2163,17 @@ impl Step for Lldb {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/llvm-project/lldb\").path(\"src/tools/lldb\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Lldb {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let target = self.target;\n \n         if builder.config.dry_run {"}, {"sha": "40f0e5ede8bd7ce41a90d8265024d237ae383910", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -34,18 +34,18 @@ macro_rules! book {\n             type Output = ();\n             const DEFAULT: bool = true;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n                 run.path($path).default_condition(builder.config.docs)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     target: run.target,\n                 });\n             }\n \n-            fn run(self, builder: &Builder) {\n+            fn run(self, builder: &Builder<'_>) {\n                 builder.ensure(Rustbook {\n                     target: self.target,\n                     name: INTERNER.intern_str($book_name),\n@@ -87,15 +87,15 @@ impl Step for Rustbook {\n \n     // rustbook is never directly called, and only serves as a shim for the nomicon and the\n     // reference.\n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Invoke `rustbook` for `target` for the doc book `name`.\n     ///\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let src = builder.src.join(\"src/doc\");\n         builder.ensure(RustbookSrc {\n             target: self.target,\n@@ -115,18 +115,18 @@ impl Step for UnstableBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/doc/unstable-book\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(UnstableBook {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(UnstableBookGen {\n             target: self.target,\n         });\n@@ -149,19 +149,19 @@ impl Step for CargoBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/cargo/src/doc/book\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(CargoBook {\n             target: run.target,\n             name: INTERNER.intern_str(\"cargo\"),\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let name = self.name;\n         let src = builder.src.join(\"src/tools/cargo/src/doc\");\n@@ -194,15 +194,15 @@ struct RustbookSrc {\n impl Step for RustbookSrc {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n     ///\n     /// This will not actually generate any documentation if the documentation has\n     /// already been generated.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let name = self.name;\n         let src = self.src;\n@@ -246,12 +246,12 @@ impl Step for TheBook {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/doc/book\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(TheBook {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n@@ -268,7 +268,7 @@ impl Step for TheBook {\n     /// * Version info and CSS\n     /// * Index page\n     /// * Redirect pages\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let name = self.name;\n@@ -321,7 +321,12 @@ impl Step for TheBook {\n     }\n }\n \n-fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String>, markdown: &str) {\n+fn invoke_rustdoc(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    markdown: &str,\n+) {\n     let out = builder.doc_out(target);\n \n     let path = builder.src.join(\"src/doc\").join(markdown);\n@@ -358,12 +363,12 @@ impl Step for Standalone {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/doc\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Standalone {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n@@ -378,7 +383,7 @@ impl Step for Standalone {\n     /// `STAMP` along with providing the various header/footer HTML we've customized.\n     ///\n     /// In the end, this is just a glorified wrapper around rustdoc!\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n         let compiler = self.compiler;\n         builder.info(&format!(\"Documenting standalone ({})\", target));\n@@ -452,12 +457,12 @@ impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.all_krates(\"std\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n             stage: run.builder.top_stage,\n             target: run.target\n@@ -468,7 +473,7 @@ impl Step for Std {\n     ///\n     /// This will generate all documentation for the standard library and its\n     /// dependencies. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n@@ -539,12 +544,12 @@ impl Step for Test {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.krate(\"test\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Test {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -555,7 +560,7 @@ impl Step for Test {\n     ///\n     /// This will generate all documentation for libtest and its dependencies. This\n     /// is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n@@ -602,12 +607,12 @@ impl Step for WhitelistedRustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(WhitelistedRustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -623,7 +628,7 @@ impl Step for WhitelistedRustc {\n     /// documentation. We don't build other compiler documentation\n     /// here as we want to be able to keep it separate from the standard\n     /// documentation. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n@@ -674,12 +679,12 @@ impl Step for Rustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.krate(\"rustc-main\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -692,7 +697,7 @@ impl Step for Rustc {\n     /// Compiler documentation is distributed separately, so we make sure\n     /// we do not merge it with the other documentation from std, test and\n     /// proc_macros. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} compiler ({})\", stage, target));\n@@ -750,7 +755,7 @@ impl Step for Rustc {\n }\n \n fn find_compiler_crates(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     name: &Interned<String>,\n     crates: &mut HashSet<Interned<String>>\n ) {\n@@ -776,11 +781,11 @@ impl Step for Rustdoc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.krate(\"rustdoc-tool\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n             stage: run.builder.top_stage,\n             target: run.target,\n@@ -793,7 +798,7 @@ impl Step for Rustdoc {\n     /// Compiler documentation is distributed separately, so we make sure\n     /// we do not merge it with the other documentation from std, test and\n     /// proc_macros. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let target = self.target;\n         builder.info(&format!(\"Documenting stage{} rustdoc ({})\", stage, target));\n@@ -859,20 +864,20 @@ impl Step for ErrorIndex {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/error_index_generator\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(ErrorIndex {\n             target: run.target,\n         });\n     }\n \n     /// Generates the HTML rendered error-index by running the\n     /// `error_index_generator` tool.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n \n         builder.info(&format!(\"Documenting error index ({})\", target));\n@@ -900,18 +905,18 @@ impl Step for UnstableBookGen {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/unstable-book-gen\").default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(UnstableBookGen {\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n \n         builder.ensure(compile::Std {"}, {"sha": "2d040d60e5fd7d2aa7e3af14e70b3f57c05cb4ff", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -14,45 +14,45 @@ use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n use crate::config::Config;\n \n-pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_docs(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"docs\", \"rust-docs\", stage, Some(host));\n }\n \n-pub fn install_std(builder: &Builder, stage: u32, target: Interned<String>) {\n+pub fn install_std(builder: &Builder<'_>, stage: u32, target: Interned<String>) {\n     install_sh(builder, \"std\", \"rust-std\", stage, Some(target));\n }\n \n-pub fn install_cargo(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_cargo(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"cargo\", \"cargo\", stage, Some(host));\n }\n \n-pub fn install_rls(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_rls(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rls\", \"rls\", stage, Some(host));\n }\n-pub fn install_clippy(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_clippy(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"clippy\", \"clippy\", stage, Some(host));\n }\n-pub fn install_miri(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_miri(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"miri\", \"miri\", stage, Some(host));\n }\n \n-pub fn install_rustfmt(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_rustfmt(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustfmt\", \"rustfmt\", stage, Some(host));\n }\n \n-pub fn install_analysis(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_analysis(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"analysis\", \"rust-analysis\", stage, Some(host));\n }\n \n-pub fn install_src(builder: &Builder, stage: u32) {\n+pub fn install_src(builder: &Builder<'_>, stage: u32) {\n     install_sh(builder, \"src\", \"rust-src\", stage, None);\n }\n-pub fn install_rustc(builder: &Builder, stage: u32, host: Interned<String>) {\n+pub fn install_rustc(builder: &Builder<'_>, stage: u32, host: Interned<String>) {\n     install_sh(builder, \"rustc\", \"rustc\", stage, Some(host));\n }\n \n fn install_sh(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     package: &str,\n     name: &str,\n     stage: u32,\n@@ -155,7 +155,7 @@ macro_rules! install {\n             }\n \n             #[allow(dead_code)]\n-            fn should_install(builder: &Builder) -> bool {\n+            fn should_install(builder: &Builder<'_>) -> bool {\n                 builder.config.tools.as_ref().map_or(false, |t| t.contains($path))\n             }\n         }\n@@ -166,20 +166,20 @@ macro_rules! install {\n             const ONLY_HOSTS: bool = $only_hosts;\n             $(const $c: bool = true;)*\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let $_config = &run.builder.config;\n                 run.path($path).default_condition($default_cond)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     stage: run.builder.top_stage,\n                     target: run.target,\n                     host: run.builder.config.build,\n                 });\n             }\n \n-            fn run($sel, $builder: &Builder) {\n+            fn run($sel, $builder: &Builder<'_>) {\n                 $run_item\n             }\n         })+\n@@ -262,20 +262,20 @@ impl Step for Src {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let config = &run.builder.config;\n         let cond = config.extended &&\n             config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n         run.path(\"src\").default_condition(cond)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Src {\n             stage: run.builder.top_stage,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(dist::Src);\n         install_src(builder, self.stage);\n     }"}, {"sha": "84e2c5aab54a33bfb4926c865512eb3d36e95f60", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -103,7 +103,7 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(bare_trait_objects)]\n+#![deny(rust_2018_idioms)]\n #![deny(warnings)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n@@ -164,8 +164,6 @@ mod job;\n \n #[cfg(all(unix, not(target_os = \"haiku\")))]\n mod job {\n-    use libc;\n-\n     pub unsafe fn setup(build: &mut crate::Build) {\n         if build.config.low_priority {\n             libc::setpriority(libc::PRIO_PGRP as _, 0, 10);"}, {"sha": "192b1cd1fbb756bd68b726c56132f2363d73d149", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -35,14 +35,14 @@ impl Step for Llvm {\n \n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/llvm-project\")\n             .path(\"src/llvm-project/llvm\")\n             .path(\"src/llvm\")\n             .path(\"src/llvm-emscripten\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let emscripten = run.path.ends_with(\"llvm-emscripten\");\n         run.builder.ensure(Llvm {\n             target: run.target,\n@@ -51,7 +51,7 @@ impl Step for Llvm {\n     }\n \n     /// Compile LLVM for `target`.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target = self.target;\n         let emscripten = self.emscripten;\n \n@@ -261,7 +261,7 @@ impl Step for Llvm {\n     }\n }\n \n-fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n+fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n     if !builder.config.llvm_version_check {\n         return\n     }\n@@ -282,7 +282,7 @@ fn check_llvm_version(builder: &Builder, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=6.0\\n\\n\", version)\n }\n \n-fn configure_cmake(builder: &Builder,\n+fn configure_cmake(builder: &Builder<'_>,\n                    target: Interned<String>,\n                    cfg: &mut cmake::Config) {\n     if builder.config.ninja {\n@@ -417,16 +417,16 @@ impl Step for Lld {\n     type Output = PathBuf;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/llvm-project/lld\").path(\"src/tools/lld\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Lld { target: run.target });\n     }\n \n     /// Compile LLVM for `target`.\n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         if builder.config.dry_run {\n             return PathBuf::from(\"lld-out-dir-test-gen\");\n         }\n@@ -489,17 +489,17 @@ pub struct TestHelpers {\n impl Step for TestHelpers {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/test/auxiliary/rust_test_helpers.c\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(TestHelpers { target: run.target })\n     }\n \n     /// Compiles the `rust_test_helpers.c` library which we used in various\n     /// `run-pass` test suites for ABI testing.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         if builder.config.dry_run {\n             return;\n         }"}, {"sha": "51412f79c3d0c85789ac2dddffc172339c716338", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -57,15 +57,15 @@ impl TestKind {\n }\n \n impl fmt::Display for TestKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(match *self {\n             TestKind::Test => \"Testing\",\n             TestKind::Bench => \"Benchmarking\",\n         })\n     }\n }\n \n-fn try_run(builder: &Builder, cmd: &mut Command) -> bool {\n+fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     if !builder.fail_fast {\n         if !builder.try_run(cmd) {\n             let mut failures = builder.delayed_failures.borrow_mut();\n@@ -78,7 +78,7 @@ fn try_run(builder: &Builder, cmd: &mut Command) -> bool {\n     true\n }\n \n-fn try_run_quiet(builder: &Builder, cmd: &mut Command) -> bool {\n+fn try_run_quiet(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     if !builder.fail_fast {\n         if !builder.try_run_quiet(cmd) {\n             let mut failures = builder.delayed_failures.borrow_mut();\n@@ -105,7 +105,7 @@ impl Step for Linkcheck {\n     ///\n     /// This tool in `src/tools` will verify the validity of all our links in the\n     /// documentation to ensure we don't have a bunch of dead ones.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let host = self.host;\n \n         builder.info(&format!(\"Linkcheck ({})\", host));\n@@ -121,13 +121,13 @@ impl Step for Linkcheck {\n         );\n     }\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/linkchecker\")\n             .default_condition(builder.config.docs)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Linkcheck { host: run.target });\n     }\n }\n@@ -142,11 +142,11 @@ impl Step for Cargotest {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/cargotest\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargotest {\n             stage: run.builder.top_stage,\n             host: run.target,\n@@ -157,7 +157,7 @@ impl Step for Cargotest {\n     ///\n     /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n     /// test` to ensure that we don't regress the test suites there.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc {\n             compiler,\n@@ -192,19 +192,19 @@ impl Step for Cargo {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/cargo\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for `cargo` packaged with Rust.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n \n         builder.ensure(tool::Cargo {\n@@ -247,19 +247,19 @@ impl Step for Rls {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rls\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for the rls.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -303,19 +303,19 @@ impl Step for Rustfmt {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustfmt\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for rustfmt.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -362,20 +362,20 @@ impl Step for Miri {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let test_miri = run.builder.config.test_miri;\n         run.path(\"src/tools/miri\").default_condition(test_miri)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for miri.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -421,19 +421,19 @@ pub struct CompiletestTest {\n impl Step for CompiletestTest {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/compiletest\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(CompiletestTest {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for compiletest.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -462,19 +462,19 @@ impl Step for Clippy {\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = false;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/clippy\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n             stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for clippy.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let stage = self.stage;\n         let host = self.host;\n         let compiler = builder.compiler(stage, host);\n@@ -516,7 +516,7 @@ impl Step for Clippy {\n     }\n }\n \n-fn path_for_cargo(builder: &Builder, compiler: Compiler) -> OsString {\n+fn path_for_cargo(builder: &Builder<'_>, compiler: Compiler) -> OsString {\n     // Configure PATH to find the right rustc. NB. we have to use PATH\n     // and not RUSTC because the Cargo test suite has tests that will\n     // fail if rustc is not spelled `rustc`.\n@@ -535,17 +535,17 @@ impl Step for RustdocTheme {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustdoc-themes\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n         run.builder.ensure(RustdocTheme { compiler });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let rustdoc = builder.out.join(\"bootstrap/debug/rustdoc\");\n         let mut cmd = builder.tool_cmd(Tool::RustdocTheme);\n         cmd.arg(rustdoc.to_str().unwrap())\n@@ -584,18 +584,18 @@ impl Step for RustdocJS {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/test/rustdoc-js\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustdocJS {\n             host: run.host,\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         if let Some(ref nodejs) = builder.config.nodejs {\n             let mut command = Command::new(nodejs);\n             command.args(&[\"src/tools/rustdoc-js/tester.js\", &*self.host]);\n@@ -624,11 +624,11 @@ impl Step for RustdocUi {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/test/rustdoc-ui\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n         run.builder.ensure(RustdocUi {\n             host: run.host,\n@@ -637,7 +637,7 @@ impl Step for RustdocUi {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Compiletest {\n             compiler: self.compiler,\n             target: self.target,\n@@ -662,7 +662,7 @@ impl Step for Tidy {\n     /// This tool in `src/tools` checks up on various bits and pieces of style and\n     /// otherwise just implements a few lint-like checks that are specific to the\n     /// compiler itself.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(&builder.initial_cargo);\n@@ -678,16 +678,16 @@ impl Step for Tidy {\n         try_run(builder, &mut cmd);\n     }\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/tidy\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Tidy);\n     }\n }\n \n-fn testdir(builder: &Builder, host: Interned<String>) -> PathBuf {\n+fn testdir(builder: &Builder<'_>, host: Interned<String>) -> PathBuf {\n     builder.out.join(host).join(\"test\")\n }\n \n@@ -747,11 +747,11 @@ macro_rules! test_definitions {\n             const DEFAULT: bool = $default;\n             const ONLY_HOSTS: bool = $host;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.suite_path($path)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 let compiler = run.builder.compiler(run.builder.top_stage, run.host);\n \n                 run.builder.ensure($name {\n@@ -760,7 +760,7 @@ macro_rules! test_definitions {\n                 });\n             }\n \n-            fn run(self, builder: &Builder) {\n+            fn run(self, builder: &Builder<'_>) {\n                 builder.ensure(Compiletest {\n                     compiler: self.compiler,\n                     target: self.target,\n@@ -908,7 +908,7 @@ struct Compiletest {\n impl Step for Compiletest {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -917,7 +917,7 @@ impl Step for Compiletest {\n     /// Compiles all tests with `compiler` for `target` with the specified\n     /// compiletest `mode` and `suite` arguments. For example `mode` can be\n     /// \"run-pass\" or `suite` can be something like `debuginfo`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n@@ -1284,7 +1284,7 @@ impl Step for DocTest {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n@@ -1293,7 +1293,7 @@ impl Step for DocTest {\n     /// This will run all tests in our markdown documentation (e.g., the book)\n     /// located in `src/doc`. The `rustdoc` that's run is the one that sits next to\n     /// `compiler`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Test {\n@@ -1354,17 +1354,17 @@ macro_rules! test_book {\n                 const DEFAULT: bool = $default;\n                 const ONLY_HOSTS: bool = true;\n \n-                fn should_run(run: ShouldRun) -> ShouldRun {\n+                fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                     run.path($path)\n                 }\n \n-                fn make_run(run: RunConfig) {\n+                fn make_run(run: RunConfig<'_>) {\n                     run.builder.ensure($name {\n                         compiler: run.builder.compiler(run.builder.top_stage, run.host),\n                     });\n                 }\n \n-                fn run(self, builder: &Builder) {\n+                fn run(self, builder: &Builder<'_>) {\n                     builder.ensure(DocTest {\n                         compiler: self.compiler,\n                         path: $path,\n@@ -1398,11 +1398,11 @@ impl Step for ErrorIndex {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/error_index_generator\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(ErrorIndex {\n             compiler: run.builder.compiler(run.builder.top_stage, run.host),\n         });\n@@ -1414,7 +1414,7 @@ impl Step for ErrorIndex {\n     /// The `error_index_generator` tool lives in `src/tools` and is used to\n     /// generate a markdown file from the error indexes of the code base which is\n     /// then passed to `rustdoc --test`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n         builder.ensure(compile::Std {\n@@ -1440,7 +1440,7 @@ impl Step for ErrorIndex {\n     }\n }\n \n-fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) -> bool {\n+fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) -> bool {\n     match fs::read_to_string(markdown) {\n         Ok(contents) => {\n             if !contents.contains(\"```\") {\n@@ -1480,11 +1480,11 @@ impl Step for CrateLibrustc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.krate(\"rustc-main\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n@@ -1502,7 +1502,7 @@ impl Step for CrateLibrustc {\n         }\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n@@ -1524,14 +1524,14 @@ pub struct CrateNotDefault {\n impl Step for CrateNotDefault {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/librustc_asan\")\n             .path(\"src/librustc_lsan\")\n             .path(\"src/librustc_msan\")\n             .path(\"src/librustc_tsan\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n@@ -1551,7 +1551,7 @@ impl Step for CrateNotDefault {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n@@ -1575,7 +1575,7 @@ impl Step for Crate {\n     type Output = ();\n     const DEFAULT: bool = true;\n \n-    fn should_run(mut run: ShouldRun) -> ShouldRun {\n+    fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run = run.krate(\"test\");\n         for krate in run.builder.in_tree_crates(\"std\") {\n@@ -1586,7 +1586,7 @@ impl Step for Crate {\n         run\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n         let compiler = builder.compiler(builder.top_stage, run.host);\n \n@@ -1622,7 +1622,7 @@ impl Step for Crate {\n     ///\n     /// Currently this runs all tests for a DAG by passing a bunch of `-p foo`\n     /// arguments, and those arguments are discovered from `cargo metadata`.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n@@ -1763,11 +1763,11 @@ impl Step for CrateRustdoc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.paths(&[\"src/librustdoc\", \"src/tools/rustdoc\"])\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n \n         let test_kind = builder.kind.into();\n@@ -1778,7 +1778,7 @@ impl Step for CrateRustdoc {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let test_kind = self.test_kind;\n \n         let compiler = builder.compiler(builder.top_stage, self.host);\n@@ -1846,11 +1846,11 @@ pub struct RemoteCopyLibs {\n impl Step for RemoteCopyLibs {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n         let target = self.target;\n         if !builder.remote_tested(target) {\n@@ -1896,16 +1896,16 @@ pub struct Distcheck;\n impl Step for Distcheck {\n     type Output = ();\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"distcheck\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Distcheck);\n     }\n \n     /// Runs \"distcheck\", a 'make check' from a tarball\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         builder.info(\"Distcheck\");\n         let dir = builder.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n@@ -1966,7 +1966,7 @@ impl Step for Bootstrap {\n     const ONLY_HOSTS: bool = true;\n \n     /// Tests the build system itself.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder<'_>) {\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")\n             .current_dir(builder.src.join(\"src/bootstrap\"))\n@@ -1990,11 +1990,11 @@ impl Step for Bootstrap {\n         try_run(builder, &mut cmd);\n     }\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/bootstrap\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Bootstrap);\n     }\n }"}, {"sha": "fc1a17d54667540c7c5681f8866124721dd76720", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -36,15 +36,15 @@ struct ToolBuild {\n impl Step for ToolBuild {\n     type Output = Option<PathBuf>;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.never()\n     }\n \n     /// Builds a tool in `src/tools`\n     ///\n     /// This will build the specified tool with the specified `host` compiler in\n     /// `stage` into the normal cargo output directory.\n-    fn run(self, builder: &Builder) -> Option<PathBuf> {\n+    fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n         let compiler = self.compiler;\n         let target = self.target;\n         let tool = self.tool;\n@@ -192,7 +192,7 @@ impl Step for ToolBuild {\n }\n \n pub fn prepare_tool_cargo(\n-    builder: &Builder,\n+    builder: &Builder<'_>,\n     compiler: Compiler,\n     mode: Mode,\n     target: Interned<String>,\n@@ -315,18 +315,18 @@ macro_rules! tool {\n         impl Step for $name {\n             type Output = PathBuf;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 run.path($path)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n                 });\n             }\n \n-            fn run(self, builder: &Builder) -> PathBuf {\n+            fn run(self, builder: &Builder<'_>) -> PathBuf {\n                 builder.ensure(ToolBuild {\n                     compiler: self.compiler,\n                     target: self.target,\n@@ -371,18 +371,18 @@ pub struct RemoteTestServer {\n impl Step for RemoteTestServer {\n     type Output = PathBuf;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/remote-test-server\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RemoteTestServer {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -406,17 +406,17 @@ impl Step for Rustdoc {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/rustdoc\")\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n             host: run.host,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         let target_compiler = builder.compiler(builder.top_stage, self.host);\n         if target_compiler.stage == 0 {\n             if !target_compiler.is_snapshot(builder) {\n@@ -490,19 +490,19 @@ impl Step for Cargo {\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n-    fn should_run(run: ShouldRun) -> ShouldRun {\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n         run.path(\"src/tools/cargo\").default_condition(builder.config.extended)\n     }\n \n-    fn make_run(run: RunConfig) {\n+    fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n             compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n             target: run.target,\n         });\n     }\n \n-    fn run(self, builder: &Builder) -> PathBuf {\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n         // Cargo depends on procedural macros, which requires a full host\n         // compiler to be available, so we need to depend on that.\n         builder.ensure(compile::Rustc {\n@@ -542,12 +542,12 @@ macro_rules! tool_extended {\n             const DEFAULT: bool = true;\n             const ONLY_HOSTS: bool = true;\n \n-            fn should_run(run: ShouldRun) -> ShouldRun {\n+            fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n                 let builder = run.builder;\n                 run.path($path).default_condition(builder.config.extended)\n             }\n \n-            fn make_run(run: RunConfig) {\n+            fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n                     compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n@@ -556,7 +556,7 @@ macro_rules! tool_extended {\n             }\n \n             #[allow(unused_mut)]\n-            fn run(mut $sel, $builder: &Builder) -> Option<PathBuf> {\n+            fn run(mut $sel, $builder: &Builder<'_>) -> Option<PathBuf> {\n                 $extra_deps\n                 $builder.ensure(ToolBuild {\n                     compiler: $sel.compiler,"}, {"sha": "bda1e56e1e73b124788dab30944f6cacc9a011d0", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -95,7 +95,7 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n pub struct TimeIt(bool, Instant);\n \n /// Returns an RAII structure that prints out how long it took to drop.\n-pub fn timeit(builder: &Builder) -> TimeIt {\n+pub fn timeit(builder: &Builder<'_>) -> TimeIt {\n     TimeIt(builder.config.dry_run, Instant::now())\n }\n "}, {"sha": "fa62d1a03f53b5d2f761bde3dae9bee3bf8e234e", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -149,6 +149,26 @@ error: const items should never be #[no_mangle]\n   |\n ```\n \n+## overflowing-literals\n+\n+This lint detects literal out of range for its type. Some\n+example code that triggers this lint:\n+\n+```rust,compile_fail\n+let x: u8 = 1000;\n+```\n+\n+This will produce:\n+\n+```text\n+error: literal out of range for u8\n+ --> src/main.rs:2:17\n+  |\n+2 |     let x: u8 = 1000;\n+  |                 ^^^^\n+  |\n+```\n+\n ## parenthesized-params-in-types-and-modules\n \n This lint detects incorrect parentheses. Some example code that triggers this"}, {"sha": "ba927b1ef3b5761dcc08ba64c1d8d76f65e9cf42", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -285,26 +285,6 @@ warning: functions generic over types must be mangled\n   |\n ```\n \n-## overflowing-literals\n-\n-This lint detects literal out of range for its type. Some\n-example code that triggers this lint:\n-\n-```rust\n-let x: u8 = 1000;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: literal out of range for u8\n- --> src/main.rs:2:17\n-  |\n-2 |     let x: u8 = 1000;\n-  |                 ^^^^\n-  |\n-```\n-\n ## path-statements\n \n This lint detects path statements with no effect. Some example code that"}, {"sha": "e842020561d35a9c4aeb47783208259fe18d8e33", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -420,7 +420,7 @@ impl fmt::Display for CannotReallocInPlace {\n /// }\n /// ```\n ///\n-/// # Unsafety\n+/// # Safety\n ///\n /// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n@@ -643,7 +643,7 @@ pub unsafe trait GlobalAlloc {\n ///    currently allocated via an allocator `a`, then it is legal to\n ///    use that layout to deallocate it, i.e., `a.dealloc(ptr, k);`.\n ///\n-/// # Unsafety\n+/// # Safety\n ///\n /// The `Alloc` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:"}, {"sha": "f41d293e80ad3da86b45c6a069734d50eff5a892", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1173,7 +1173,7 @@ impl<T> MaybeUninit<T> {\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n@@ -1187,7 +1187,7 @@ impl<T> MaybeUninit<T> {\n \n     /// Gets a reference to the contained value.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n@@ -1200,7 +1200,7 @@ impl<T> MaybeUninit<T> {\n \n     /// Gets a mutable reference to the contained value.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined"}, {"sha": "2063f8ffaf65a8c5a5a826672815e08ca45aabac", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -2158,7 +2158,7 @@ impl<T> [T] {\n     /// This method has no purpose when either input element `T` or output element `U` are\n     /// zero-sized and will return the original slice without splitting anything.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This method is essentially a `transmute` with respect to the elements in the returned\n     /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n@@ -2211,7 +2211,7 @@ impl<T> [T] {\n     /// This method has no purpose when either input element `T` or output element `U` are\n     /// zero-sized and will return the original slice without splitting anything.\n     ///\n-    /// # Unsafety\n+    /// # Safety\n     ///\n     /// This method is essentially a `transmute` with respect to the elements in the returned\n     /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here."}, {"sha": "205ea6126fc59b511139d4741bfeb809aca2bac3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -62,8 +62,6 @@\n \n #![recursion_limit=\"512\"]\n \n-#![warn(elided_lifetimes_in_paths)]\n-\n #[macro_use] extern crate bitflags;\n extern crate getopts;\n #[macro_use] extern crate lazy_static;"}, {"sha": "dd382ec006bd7437fa7b4d45d58ed584e6391a94", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -3,7 +3,7 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::mir::interpret::ConstValue;\n+use crate::mir::interpret::{ConstValue, truncate};\n use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -2118,8 +2118,7 @@ impl<'tcx> Const<'tcx> {\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n-        let shift = 128 - size.bits();\n-        let truncated = (bits << shift) >> shift;\n+        let truncated = truncate(bits, size);\n         assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n         Self::from_scalar(Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n     }"}, {"sha": "1fe020561dde11a0f278f7cd017986788ee2e53d", "filename": "src/librustc_codegen_llvm/allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fallocator.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -9,7 +9,7 @@ use rustc_allocator::{ALLOCATOR_METHODS, AllocatorTy};\n use crate::ModuleLlvm;\n use crate::llvm::{self, False, True};\n \n-pub(crate) unsafe fn codegen(tcx: TyCtxt, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n+pub(crate) unsafe fn codegen(tcx: TyCtxt<'_, '_, '_>, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n     let llcx = &*mods.llcx;\n     let llmod = mods.llmod();\n     let usize = match &tcx.sess.target.target.target_pointer_width[..] {"}, {"sha": "71e7535313f77e8c7fe43d68c7bbf74f37eb31ff", "filename": "src/librustc_codegen_llvm/attributes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fattributes.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -308,7 +308,7 @@ pub fn from_fn_attrs(\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     providers.target_features_whitelist = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         if tcx.sess.opts.actually_rustdoc {\n@@ -328,7 +328,7 @@ pub fn provide(providers: &mut Providers) {\n     provide_extern(providers);\n }\n \n-pub fn provide_extern(providers: &mut Providers) {\n+pub fn provide_extern(providers: &mut Providers<'_>) {\n     providers.wasm_import_module_map = |tcx, cnum| {\n         // Build up a map from DefId to a `NativeLibrary` structure, where\n         // `NativeLibrary` internally contains information about\n@@ -362,7 +362,7 @@ pub fn provide_extern(providers: &mut Providers) {\n     };\n }\n \n-fn wasm_import_module(tcx: TyCtxt, id: DefId) -> Option<CString> {\n+fn wasm_import_module(tcx: TyCtxt<'_, '_, '_>, id: DefId) -> Option<CString> {\n     tcx.wasm_import_module_map(id.krate)\n         .get(&id)\n         .map(|s| CString::new(&s[..]).unwrap())"}, {"sha": "3fb9d4b5b776bf823bbece07d392280de2b100cf", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -42,7 +42,7 @@ enum Addition {\n     },\n }\n \n-fn is_relevant_child(c: &Child) -> bool {\n+fn is_relevant_child(c: &Child<'_>) -> bool {\n     match c.name() {\n         Some(name) => !name.contains(\"SYMDEF\"),\n         None => false,"}, {"sha": "819f7f9410257cd483afca9138a9c5485a5f8a46", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -808,7 +808,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n     }\n \n     impl<'a> fmt::Display for Escape<'a> {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n             if self.is_like_msvc {\n                 // This is \"documented\" at\n                 // https://msdn.microsoft.com/en-us/library/4xdcbak7.aspx"}, {"sha": "2b7abcb52bef8cf5391c551c3c7127592e8c5360", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -15,7 +15,7 @@ pub struct RPathConfig<'a> {\n     pub get_install_prefix_lib_path: &'a mut dyn FnMut() -> PathBuf,\n }\n \n-pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n+pub fn get_rpath_flags(config: &mut RPathConfig<'_>) -> Vec<String> {\n     // No rpath on windows\n     if !config.has_rpath {\n         return Vec::new();\n@@ -52,7 +52,7 @@ fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     ret\n }\n \n-fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n+fn get_rpaths(config: &mut RPathConfig<'_>, libs: &[PathBuf]) -> Vec<String> {\n     debug!(\"output: {:?}\", config.out_filename.display());\n     debug!(\"libs:\");\n     for libpath in libs {\n@@ -86,12 +86,12 @@ fn get_rpaths(config: &mut RPathConfig, libs: &[PathBuf]) -> Vec<String> {\n     rpaths\n }\n \n-fn get_rpaths_relative_to_output(config: &mut RPathConfig,\n+fn get_rpaths_relative_to_output(config: &mut RPathConfig<'_>,\n                                  libs: &[PathBuf]) -> Vec<String> {\n     libs.iter().map(|a| get_rpath_relative_to_output(config, a)).collect()\n }\n \n-fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String {\n+fn get_rpath_relative_to_output(config: &mut RPathConfig<'_>, lib: &Path) -> String {\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = if config.is_like_osx {\n         \"@loader_path\"\n@@ -127,7 +127,7 @@ fn path_relative_from(path: &Path, base: &Path) -> Option<PathBuf> {\n     } else {\n         let mut ita = path.components();\n         let mut itb = base.components();\n-        let mut comps: Vec<Component> = vec![];\n+        let mut comps: Vec<Component<'_>> = vec![];\n         loop {\n             match (ita.next(), itb.next()) {\n                 (None, None) => break,\n@@ -154,7 +154,7 @@ fn path_relative_from(path: &Path, base: &Path) -> Option<PathBuf> {\n }\n \n \n-fn get_install_prefix_rpath(config: &mut RPathConfig) -> String {\n+fn get_install_prefix_rpath(config: &mut RPathConfig<'_>) -> String {\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "e1d3351d3deca7476946d7f76bd28e8a98f70935", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -60,7 +60,7 @@ pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n     fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n \n     fn rewrite_import_section(\n-        wasm: &mut WasmDecoder,\n+        wasm: &mut WasmDecoder<'_>,\n         import_map: &FxHashMap<String, String>,\n     )\n         -> Vec<u8>\n@@ -75,7 +75,7 @@ pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n         return dst.data\n     }\n \n-    fn rewrite_import_entry(wasm: &mut WasmDecoder,\n+    fn rewrite_import_entry(wasm: &mut WasmDecoder<'_>,\n                             dst: &mut WasmEncoder,\n                             import_map: &FxHashMap<String, String>) {\n         // More info about the binary format here is available at:"}, {"sha": "db5430a4219a0acea6d5f90f655360642fd76c36", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -83,7 +83,7 @@ pub fn write_output_file(\n }\n \n pub fn create_target_machine(\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     find_features: bool,\n ) -> &'static mut llvm::TargetMachine {\n     target_machine_factory(tcx.sess, tcx.backend_optimization_level(LOCAL_CRATE), find_features)()"}, {"sha": "1dac1557707c9c903ceb2fcf415aac10530f2f55", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -172,17 +172,17 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let mono_items = cx.codegen_unit\n                                .items_in_deterministic_order(cx.tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {\n-                mono_item.predefine::<Builder>(&cx, linkage, visibility);\n+                mono_item.predefine::<Builder<'_, '_, '_>>(&cx, linkage, visibility);\n             }\n \n             // ... and now that we have everything pre-defined, fill out those definitions.\n             for &(mono_item, _) in &mono_items {\n-                mono_item.define::<Builder>(&cx);\n+                mono_item.define::<Builder<'_, '_, '_>>(&cx);\n             }\n \n             // If this codegen unit contains the main function, also create the\n             // wrapper here\n-            maybe_create_entry_wrapper::<Builder>(&cx);\n+            maybe_create_entry_wrapper::<Builder<'_, '_, '_>>(&cx);\n \n             // Run replace-all-uses-with for statics that need it\n             for &(old_g, new_g) in cx.statics_to_rauw().borrow().iter() {"}, {"sha": "d4d38a464576d2a9539082556764ef97475a2074", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -456,7 +456,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn checked_binop(\n         &mut self,\n         oop: OverflowOp,\n-        ty: Ty,\n+        ty: Ty<'_>,\n         lhs: Self::Value,\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value) {"}, {"sha": "23e3a8425d37001bf67be923f9693d7c8a0dc93a", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -144,7 +144,7 @@ pub fn is_pie_binary(sess: &Session) -> bool {\n }\n \n pub unsafe fn create_module(\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     llcx: &'ll llvm::Context,\n     mod_name: &str,\n ) -> &'ll llvm::Module {"}, {"sha": "c8ddf733ecf1f5c8d1583afda83616f94e601068", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -20,7 +20,7 @@ use syntax_pos::BytePos;\n /// If debuginfo is disabled, the returned vector is empty.\n pub fn create_mir_scopes(\n     cx: &CodegenCx<'ll, '_>,\n-    mir: &Mir,\n+    mir: &Mir<'_>,\n     debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n ) -> IndexVec<SourceScope, MirDebugScope<&'ll DIScope>> {\n     let null_scope = MirDebugScope {\n@@ -55,7 +55,7 @@ pub fn create_mir_scopes(\n }\n \n fn make_mir_scope(cx: &CodegenCx<'ll, '_>,\n-                  mir: &Mir,\n+                  mir: &Mir<'_>,\n                   has_variables: &BitSet<SourceScope>,\n                   debug_context: &FunctionDebugContextData<&'ll DISubprogram>,\n                   scope: SourceScope,"}, {"sha": "91496ffbe557a4b65aea8c791f76c6d1bf4958cc", "filename": "src/librustc_codegen_llvm/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fgdb.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -13,7 +13,7 @@ use syntax::attr;\n \n /// Inserts a side-effect free instruction sequence that makes sure that the\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n-pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder) {\n+pub fn insert_reference_to_gdb_debug_scripts_section_global(bx: &mut Builder<'_, '_, '_>) {\n     if needs_gdb_debug_scripts_section(bx) {\n         let gdb_debug_scripts_section = get_or_insert_gdb_debug_scripts_section_global(bx);\n         // Load just the first byte as that's all that's necessary to force\n@@ -64,7 +64,7 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>)\n     })\n }\n \n-pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx) -> bool {\n+pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n     let omit_gdb_pretty_printer_section =\n         attr::contains_name(&cx.tcx.hir().krate_attrs(),\n                             \"omit_gdb_pretty_printer_section\");"}, {"sha": "ddcbf29da832b95dd9bab76446e1eb00b91498d1", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -60,7 +60,7 @@ impl Hash for llvm::Metadata {\n }\n \n impl fmt::Debug for llvm::Metadata {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         (self as *const Self).fmt(f)\n     }\n }\n@@ -817,7 +817,7 @@ fn pointer_type_metadata(\n     }\n }\n \n-pub fn compile_unit_metadata(tcx: TyCtxt,\n+pub fn compile_unit_metadata(tcx: TyCtxt<'_, '_, '_>,\n                              codegen_unit_name: &str,\n                              debug_context: &CrateDebugContext<'ll, '_>)\n                              -> &'ll DIDescriptor {\n@@ -1162,7 +1162,7 @@ fn prepare_union_metadata(\n // sometimes emit the old style rather than emit something completely\n // useless when rust is compiled against LLVM 6 or older.  This\n // function decides which representation will be emitted.\n-fn use_enum_fallback(cx: &CodegenCx) -> bool {\n+fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n     // On MSVC we have to use the fallback mode, because LLVM doesn't\n     // lower variant parts to PDB.\n     return cx.sess().target.target.options.is_like_msvc\n@@ -1736,7 +1736,7 @@ fn prepare_enum_metadata(\n         }),\n     );\n \n-    fn get_enum_discriminant_name(cx: &CodegenCx,\n+    fn get_enum_discriminant_name(cx: &CodegenCx<'_, '_>,\n                                   def_id: DefId)\n                                   -> InternedString {\n         cx.tcx.item_name(def_id)\n@@ -1863,7 +1863,7 @@ fn compute_type_parameters(cx: &CodegenCx<'ll, 'tcx>, ty: Ty<'tcx>) -> Option<&'\n     }\n     return Some(create_DIArray(DIB(cx), &[]));\n \n-    fn get_parameter_names(cx: &CodegenCx,\n+    fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n                            generics: &ty::Generics)\n                            -> Vec<InternedString> {\n         let mut names = generics.parent.map_or(vec![], |def_id| {"}, {"sha": "ae6e16b31e7aa13b6616440e6b475f33fa478e52", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'tcx> CrateDebugContext<'a, 'tcx> {\n }\n \n /// Creates any deferred debug metadata nodes\n-pub fn finalize(cx: &CodegenCx) {\n+pub fn finalize(cx: &CodegenCx<'_, '_>) {\n     if cx.dbg_cx.is_none() {\n         return;\n     }\n@@ -233,7 +233,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: &'ll Value,\n-        mir: &mir::Mir,\n+        mir: &mir::Mir<'_>,\n     ) -> FunctionDebugContext<&'ll DISubprogram> {\n         if self.sess().opts.debuginfo == DebugInfo::None {\n             return FunctionDebugContext::DebugInfoDisabled;\n@@ -455,7 +455,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             return create_DIArray(DIB(cx), &template_params[..]);\n         }\n \n-        fn get_parameter_names(cx: &CodegenCx,\n+        fn get_parameter_names(cx: &CodegenCx<'_, '_>,\n                                generics: &ty::Generics)\n                                -> Vec<InternedString> {\n             let mut names = generics.parent.map_or(vec![], |def_id| {\n@@ -518,7 +518,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn create_mir_scopes(\n         &self,\n-        mir: &mir::Mir,\n+        mir: &mir::Mir<'_>,\n         debug_context: &FunctionDebugContext<&'ll DISubprogram>,\n     ) -> IndexVec<mir::SourceScope, MirDebugScope<&'ll DIScope>> {\n         create_scope_map::create_mir_scopes(self, mir, debug_context)"}, {"sha": "32e930ac44c850a007c6e5711bddd5386f5301be", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -178,7 +178,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n         }\n     }\n \n-    fn push_item_name(cx: &CodegenCx,\n+    fn push_item_name(cx: &CodegenCx<'_, '_>,\n                       def_id: DefId,\n                       qualified: bool,\n                       output: &mut String) {"}, {"sha": "c64e0d9806b2930653f9f2907fba2c188cff2567", "filename": "src/librustc_codegen_llvm/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Futils.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -13,7 +13,7 @@ use rustc_codegen_ssa::traits::*;\n \n use syntax_pos::Span;\n \n-pub fn is_node_local_to_unit(cx: &CodegenCx, def_id: DefId) -> bool\n+pub fn is_node_local_to_unit(cx: &CodegenCx<'_, '_>, def_id: DefId) -> bool\n {\n     // The is_local_to_unit flag indicates whether a function is local to the\n     // current compilation unit (i.e., if it is *static* in the C-sense). The\n@@ -37,7 +37,7 @@ pub fn create_DIArray(\n }\n \n /// Returns syntax_pos::Loc corresponding to the beginning of the span\n-pub fn span_start(cx: &CodegenCx, span: Span) -> syntax_pos::Loc {\n+pub fn span_start(cx: &CodegenCx<'_, '_>, span: Span) -> syntax_pos::Loc {\n     cx.sess().source_map().lookup_char_pos(span.lo())\n }\n "}, {"sha": "d1cbe1d4dd6866c44880432ada15a6e69a6c7ea5", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1251,8 +1251,8 @@ fn generic_simd_intrinsic(\n \n     fn simd_simple_float_intrinsic(\n         name: &str,\n-        in_elem: &::rustc::ty::TyS,\n-        in_ty: &::rustc::ty::TyS,\n+        in_elem: &::rustc::ty::TyS<'_>,\n+        in_ty: &::rustc::ty::TyS<'_>,\n         in_len: usize,\n         bx: &mut Builder<'a, 'll, 'tcx>,\n         span: Span,\n@@ -1362,7 +1362,7 @@ fn generic_simd_intrinsic(\n     // FIXME: use:\n     //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Function.h#L182\n     //  https://github.com/llvm-mirror/llvm/blob/master/include/llvm/IR/Intrinsics.h#L81\n-    fn llvm_vector_str(elem_ty: ty::Ty, vec_len: usize, no_pointers: usize) -> String {\n+    fn llvm_vector_str(elem_ty: ty::Ty<'_>, vec_len: usize, no_pointers: usize) -> String {\n         let p0s: String = \"p0\".repeat(no_pointers);\n         match elem_ty.sty {\n             ty::Int(v) => format!(\"v{}{}i{}\", vec_len, p0s, v.bit_width().unwrap()),\n@@ -1372,7 +1372,7 @@ fn generic_simd_intrinsic(\n         }\n     }\n \n-    fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: ty::Ty, vec_len: usize,\n+    fn llvm_vector_ty(cx: &CodegenCx<'ll, '_>, elem_ty: ty::Ty<'_>, vec_len: usize,\n                       mut no_pointers: usize) -> &'ll Type {\n         // FIXME: use cx.layout_of(ty).llvm_type() ?\n         let mut elem_ty = match elem_ty.sty {\n@@ -1418,15 +1418,15 @@ fn generic_simd_intrinsic(\n                  in_ty, ret_ty);\n \n         // This counts how many pointers\n-        fn ptr_count(t: ty::Ty) -> usize {\n+        fn ptr_count(t: ty::Ty<'_>) -> usize {\n             match t.sty {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n-        fn non_ptr(t: ty::Ty) -> ty::Ty {\n+        fn non_ptr(t: ty::Ty<'_>) -> ty::Ty<'_> {\n             match t.sty {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n@@ -1517,15 +1517,15 @@ fn generic_simd_intrinsic(\n                  arg_tys[2].simd_size(tcx));\n \n         // This counts how many pointers\n-        fn ptr_count(t: ty::Ty) -> usize {\n+        fn ptr_count(t: ty::Ty<'_>) -> usize {\n             match t.sty {\n                 ty::RawPtr(p) => 1 + ptr_count(p.ty),\n                 _ => 0,\n             }\n         }\n \n         // Non-ptr type\n-        fn non_ptr(t: ty::Ty) -> ty::Ty {\n+        fn non_ptr(t: ty::Ty<'_>) -> ty::Ty<'_> {\n             match t.sty {\n                 ty::RawPtr(p) => non_ptr(p.ty),\n                 _ => t,\n@@ -1901,7 +1901,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n // Returns None if the type is not an integer\n // FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n // stuffs.\n-fn int_type_width_signed(ty: Ty, cx: &CodegenCx) -> Option<(u64, bool)> {\n+fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, bool)> {\n     match ty.sty {\n         ty::Int(t) => Some((match t {\n             ast::IntTy::Isize => cx.tcx.sess.target.isize_ty.bit_width().unwrap() as u64,"}, {"sha": "5b8c7461bcb60ed3aa667beb59b7bcc705c29b5e", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -23,7 +23,6 @@\n #![feature(static_nobundle)]\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n-#![allow(elided_lifetimes_in_paths)]\n \n use back::write::create_target_machine;\n use syntax_pos::symbol::Symbol;\n@@ -114,7 +113,7 @@ mod va_arg;\n pub struct LlvmCodegenBackend(());\n \n impl ExtraBackendMethods for LlvmCodegenBackend {\n-    fn new_metadata(&self, tcx: TyCtxt, mod_name: &str) -> ModuleLlvm {\n+    fn new_metadata(&self, tcx: TyCtxt<'_, '_, '_>, mod_name: &str) -> ModuleLlvm {\n         ModuleLlvm::new(tcx, mod_name)\n     }\n     fn write_metadata<'b, 'gcx>(\n@@ -124,7 +123,12 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     ) -> EncodedMetadata {\n         base::write_metadata(tcx, metadata)\n     }\n-    fn codegen_allocator(&self, tcx: TyCtxt, mods: &mut ModuleLlvm, kind: AllocatorKind) {\n+    fn codegen_allocator(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        mods: &mut ModuleLlvm,\n+        kind: AllocatorKind\n+    ) {\n         unsafe { allocator::codegen(tcx, mods, kind) }\n     }\n     fn compile_codegen_unit<'a, 'tcx: 'a>(\n@@ -280,14 +284,14 @@ impl CodegenBackend for LlvmCodegenBackend {\n         box metadata::LlvmMetadataLoader\n     }\n \n-    fn provide(&self, providers: &mut ty::query::Providers) {\n+    fn provide(&self, providers: &mut ty::query::Providers<'_>) {\n         rustc_codegen_utils::symbol_names::provide(providers);\n         rustc_codegen_ssa::back::symbol_export::provide(providers);\n         rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide(providers);\n     }\n \n-    fn provide_extern(&self, providers: &mut ty::query::Providers) {\n+    fn provide_extern(&self, providers: &mut ty::query::Providers<'_>) {\n         rustc_codegen_ssa::back::symbol_export::provide_extern(providers);\n         rustc_codegen_ssa::base::provide_both(providers);\n         attributes::provide_extern(providers);\n@@ -362,7 +366,7 @@ unsafe impl Send for ModuleLlvm { }\n unsafe impl Sync for ModuleLlvm { }\n \n impl ModuleLlvm {\n-    fn new(tcx: TyCtxt, mod_name: &str) -> Self {\n+    fn new(tcx: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(tcx.sess.fewer_names());\n             let llmod_raw = context::create_module(tcx, llcx, mod_name) as *const _;"}, {"sha": "0a8bb3250c5d5a5e7cdc563813f6142ebe6f57f5", "filename": "src/librustc_codegen_llvm/llvm/archive_ro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Farchive_ro.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -36,7 +36,7 @@ impl ArchiveRO {\n         };\n     }\n \n-    pub fn iter(&self) -> Iter {\n+    pub fn iter(&self) -> Iter<'_> {\n         unsafe {\n             Iter {\n                 raw: super::LLVMRustArchiveIteratorNew(self.raw),"}, {"sha": "2ad6d9c053a2035575cbf0427d35ec4f006a498e", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1283,7 +1283,7 @@ extern \"C\" {\n                               SingleThreaded: Bool)\n                               -> &'a Value;\n \n-    pub fn LLVMRustBuildAtomicFence(B: &Builder,\n+    pub fn LLVMRustBuildAtomicFence(B: &Builder<'_>,\n                                     Order: AtomicOrdering,\n                                     Scope: SynchronizationScope);\n \n@@ -1311,17 +1311,17 @@ extern \"C\" {\n     pub fn LLVMPassManagerBuilderUseInlinerWithThreshold(PMB: &PassManagerBuilder,\n                                                          threshold: c_uint);\n     pub fn LLVMPassManagerBuilderPopulateModulePassManager(PMB: &PassManagerBuilder,\n-                                                           PM: &PassManager);\n+                                                           PM: &PassManager<'_>);\n \n     pub fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB: &PassManagerBuilder,\n-                                                             PM: &PassManager);\n+                                                             PM: &PassManager<'_>);\n     pub fn LLVMPassManagerBuilderPopulateLTOPassManager(PMB: &PassManagerBuilder,\n-                                                        PM: &PassManager,\n+                                                        PM: &PassManager<'_>,\n                                                         Internalize: Bool,\n                                                         RunInliner: Bool);\n     pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n         PMB: &PassManagerBuilder,\n-        PM: &PassManager);\n+        PM: &PassManager<'_>);\n \n     // Stuff that's in rustllvm/ because it's not upstream yet.\n \n@@ -1340,11 +1340,11 @@ extern \"C\" {\n     /// list:\n     pub fn LLVMIsSectionIteratorAtEnd(ObjFile: &'a ObjectFile, SI: &SectionIterator<'a>) -> Bool;\n     /// Moves the section iterator to point to the next section.\n-    pub fn LLVMMoveToNextSection(SI: &SectionIterator);\n+    pub fn LLVMMoveToNextSection(SI: &SectionIterator<'_>);\n     /// Returns the current section size.\n-    pub fn LLVMGetSectionSize(SI: &SectionIterator) -> c_ulonglong;\n+    pub fn LLVMGetSectionSize(SI: &SectionIterator<'_>) -> c_ulonglong;\n     /// Returns the current section contents as a string buffer.\n-    pub fn LLVMGetSectionContents(SI: &SectionIterator) -> *const c_char;\n+    pub fn LLVMGetSectionContents(SI: &SectionIterator<'_>) -> *const c_char;\n \n     /// Reads the given file and returns it as a memory buffer. Use\n     /// LLVMDisposeMemoryBuffer() to get rid of it.\n@@ -1392,7 +1392,7 @@ extern \"C\" {\n \n     pub fn LLVMRustDIBuilderDispose(Builder: &'a mut DIBuilder<'a>);\n \n-    pub fn LLVMRustDIBuilderFinalize(Builder: &DIBuilder);\n+    pub fn LLVMRustDIBuilderFinalize(Builder: &DIBuilder<'_>);\n \n     pub fn LLVMRustDIBuilderCreateCompileUnit(Builder: &DIBuilder<'a>,\n                                               Lang: c_uint,\n@@ -1635,7 +1635,7 @@ extern \"C\" {\n \n     pub fn LLVMRustPassKind(Pass: &Pass) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n-    pub fn LLVMRustAddPass(PM: &PassManager, Pass: &'static mut Pass);\n+    pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n \n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n@@ -1700,13 +1700,13 @@ extern \"C\" {\n     pub fn LLVMRustArchiveIteratorNext(\n         AIR: &ArchiveIterator<'a>,\n     ) -> Option<&'a mut ArchiveChild<'a>>;\n-    pub fn LLVMRustArchiveChildName(ACR: &ArchiveChild, size: &mut size_t) -> *const c_char;\n-    pub fn LLVMRustArchiveChildData(ACR: &ArchiveChild, size: &mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildName(ACR: &ArchiveChild<'_>, size: &mut size_t) -> *const c_char;\n+    pub fn LLVMRustArchiveChildData(ACR: &ArchiveChild<'_>, size: &mut size_t) -> *const c_char;\n     pub fn LLVMRustArchiveChildFree(ACR: &'a mut ArchiveChild<'a>);\n     pub fn LLVMRustArchiveIteratorFree(AIR: &'a mut ArchiveIterator<'a>);\n     pub fn LLVMRustDestroyArchive(AR: &'static mut Archive);\n \n-    pub fn LLVMRustGetSectionName(SI: &SectionIterator, data: &mut *const c_char) -> size_t;\n+    pub fn LLVMRustGetSectionName(SI: &SectionIterator<'_>, data: &mut *const c_char) -> size_t;\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustWriteTwineToString(T: &Twine, s: &RustString);\n@@ -1742,7 +1742,7 @@ extern \"C\" {\n \n     pub fn LLVMRustWriteArchive(Dst: *const c_char,\n                                 NumMembers: size_t,\n-                                Members: *const &RustArchiveMember,\n+                                Members: *const &RustArchiveMember<'_>,\n                                 WriteSymbtab: bool,\n                                 Kind: ArchiveKind)\n                                 -> LLVMRustResult;\n@@ -1815,7 +1815,7 @@ extern \"C\" {\n     pub fn LLVMRustThinLTOPatchDICompileUnit(M: &Module, CU: *mut c_void);\n \n     pub fn LLVMRustLinkerNew(M: &'a Module) -> &'a mut Linker<'a>;\n-    pub fn LLVMRustLinkerAdd(linker: &Linker,\n+    pub fn LLVMRustLinkerAdd(linker: &Linker<'_>,\n                              bytecode: *const c_char,\n                              bytecode_len: usize) -> bool;\n     pub fn LLVMRustLinkerFree(linker: &'a mut Linker<'a>);"}, {"sha": "d5424fa45916660469ce49e5f842882681fd1666", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -31,7 +31,7 @@ impl PartialEq for Type {\n }\n \n impl fmt::Debug for Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n             llvm::LLVMRustWriteTypeToString(self, s);\n         }).expect(\"non-UTF8 type description from LLVM\"))"}, {"sha": "eadbe754e8e41cdaa07bcaf08587436e995ba45f", "filename": "src/librustc_codegen_llvm/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_llvm%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fvalue.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -22,7 +22,7 @@ impl Hash for Value {\n \n \n impl fmt::Debug for Value {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&llvm::build_string(|s| unsafe {\n             llvm::LLVMRustWriteValueToString(self, s);\n         }).expect(\"non-UTF8 value description from LLVM\"))"}, {"sha": "78570cce57dd9ea9d88ea6ddd73aa4dda8d2b382", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -159,7 +159,7 @@ impl Command {\n }\n \n impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.command().fmt(f)\n     }\n }"}, {"sha": "1f4c5543fa9aa05d2481752264a44d561698a630", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -25,7 +25,7 @@ pub struct LinkerInfo {\n }\n \n impl LinkerInfo {\n-    pub fn new(tcx: TyCtxt) -> LinkerInfo {\n+    pub fn new(tcx: TyCtxt<'_, '_, '_>) -> LinkerInfo {\n         LinkerInfo {\n             exports: tcx.sess.crate_types.borrow().iter().map(|&c| {\n                 (c, exported_symbols(tcx, c))\n@@ -1052,7 +1052,7 @@ impl<'a> Linker for WasmLd<'a> {\n     }\n }\n \n-fn exported_symbols(tcx: TyCtxt, crate_type: CrateType) -> Vec<String> {\n+fn exported_symbols(tcx: TyCtxt<'_, '_, '_>, crate_type: CrateType) -> Vec<String> {\n     if let Some(ref exports) = tcx.sess.target.target.options.override_export_symbols {\n         return exports.clone()\n     }"}, {"sha": "16f5880b13f5bd70dc6878469361ef0a00fe3c9a", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -22,7 +22,7 @@ pub type ExportedSymbols = FxHashMap<\n     Arc<Vec<(String, SymbolExportLevel)>>,\n >;\n \n-pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n+pub fn threshold(tcx: TyCtxt<'_, '_, '_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types.borrow())\n }\n \n@@ -342,7 +342,7 @@ fn upstream_monomorphizations_for_provider<'a, 'tcx>(\n        .cloned()\n }\n \n-fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool {\n+fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) -> bool {\n     if let Some(node_id) = tcx.hir().as_local_node_id(def_id) {\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n     } else {\n@@ -351,20 +351,20 @@ fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool\n     }\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     providers.reachable_non_generics = reachable_non_generics_provider;\n     providers.is_reachable_non_generic = is_reachable_non_generic_provider_local;\n     providers.exported_symbols = exported_symbols_provider_local;\n     providers.upstream_monomorphizations = upstream_monomorphizations_provider;\n     providers.is_unreachable_local_definition = is_unreachable_local_definition_provider;\n }\n \n-pub fn provide_extern(providers: &mut Providers) {\n+pub fn provide_extern(providers: &mut Providers<'_>) {\n     providers.is_reachable_non_generic = is_reachable_non_generic_provider_extern;\n     providers.upstream_monomorphizations_for = upstream_monomorphizations_for_provider;\n }\n \n-fn symbol_export_level(tcx: TyCtxt, sym_def_id: DefId) -> SymbolExportLevel {\n+fn symbol_export_level(tcx: TyCtxt<'_, '_, '_>, sym_def_id: DefId) -> SymbolExportLevel {\n     // We export anything that's not mangled at the \"C\" layer as it probably has\n     // to do with ABI concerns. We do not, however, apply such treatment to\n     // special symbols in the standard library for various plumbing between"}, {"sha": "908ee95efcba3ffa0e1a92cf1f2216534ad35b17", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -321,7 +321,7 @@ fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n \n pub fn start_async_codegen<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     time_graph: Option<TimeGraph>,\n     metadata: EncodedMetadata,\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n@@ -947,7 +947,7 @@ enum MainThreadWorkerState {\n \n fn start_executing_work<B: ExtraBackendMethods>(\n     backend: B,\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     crate_info: &CrateInfo,\n     shared_emitter: SharedEmitter,\n     codegen_worker_send: Sender<Message<B>>,\n@@ -1683,7 +1683,7 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n+    fn emit(&mut self, db: &DiagnosticBuilder<'_>) {\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n             msg: db.message(),\n             code: db.code.clone(),\n@@ -1822,7 +1822,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n     }\n \n     pub fn submit_pre_codegened_module_to_llvm(&self,\n-                                                       tcx: TyCtxt,\n+                                                       tcx: TyCtxt<'_, '_, '_>,\n                                                        module: ModuleCodegen<B::Module>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n@@ -1832,7 +1832,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n         submit_codegened_module_to_llvm(&self.backend, tcx, module, cost);\n     }\n \n-    pub fn codegen_finished(&self, tcx: TyCtxt) {\n+    pub fn codegen_finished(&self, tcx: TyCtxt<'_, '_, '_>) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n         drop(self.coordinator_send.send(Box::new(Message::CodegenComplete::<B>)));\n@@ -1871,7 +1871,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     module: ModuleCodegen<B::Module>,\n     cost: u64\n ) {\n@@ -1884,7 +1884,7 @@ pub fn submit_codegened_module_to_llvm<B: ExtraBackendMethods>(\n \n pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     module: CachedModuleCodegen\n ) {\n     let llvm_work_item = WorkItem::CopyPostLtoArtifacts(module);\n@@ -1896,7 +1896,7 @@ pub fn submit_post_lto_module_to_llvm<B: ExtraBackendMethods>(\n \n pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n     _backend: &B,\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     module: CachedModuleCodegen\n ) {\n     let filename = pre_lto_bitcode_filename(&module.name);\n@@ -1921,7 +1921,7 @@ pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n     format!(\"{}.{}\", module_name, PRE_LTO_BC_EXT)\n }\n \n-fn msvc_imps_needed(tcx: TyCtxt) -> bool {\n+fn msvc_imps_needed(tcx: TyCtxt<'_, '_, '_>) -> bool {\n     // This should never be true (because it's not supported). If it is true,\n     // something is wrong with commandline arg validation.\n     assert!(!(tcx.sess.opts.cg.linker_plugin_lto.enabled() &&"}, {"sha": "fad41a11a82ba126351146f3b678f0bf2abcb9e3", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -370,7 +370,7 @@ pub fn from_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n pub fn to_immediate<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n     val: Bx::Value,\n-    layout: layout::TyLayout,\n+    layout: layout::TyLayout<'_>,\n ) -> Bx::Value {\n     if let layout::Abi::Scalar(ref scalar) = layout.abi {\n         return to_immediate_scalar(bx, val, scalar);\n@@ -802,7 +802,7 @@ fn assert_and_save_dep_graph<'ll, 'tcx>(tcx: TyCtxt<'ll, 'tcx, 'tcx>) {\n }\n \n impl CrateInfo {\n-    pub fn new(tcx: TyCtxt) -> CrateInfo {\n+    pub fn new(tcx: TyCtxt<'_, '_, '_>) -> CrateInfo {\n         let mut info = CrateInfo {\n             panic_runtime: None,\n             compiler_builtins: None,\n@@ -880,7 +880,7 @@ impl CrateInfo {\n         return info\n     }\n \n-    fn load_wasm_imports(&mut self, tcx: TyCtxt, cnum: CrateNum) {\n+    fn load_wasm_imports(&mut self, tcx: TyCtxt<'_, '_, '_>, cnum: CrateNum) {\n         self.wasm_imports.extend(tcx.wasm_import_module_map(cnum).iter().map(|(&id, module)| {\n             let instance = Instance::mono(tcx, id);\n             let import_name = tcx.symbol_name(instance);\n@@ -890,13 +890,13 @@ impl CrateInfo {\n     }\n }\n \n-fn is_codegened_item(tcx: TyCtxt, id: DefId) -> bool {\n+fn is_codegened_item(tcx: TyCtxt<'_, '_, '_>, id: DefId) -> bool {\n     let (all_mono_items, _) =\n         tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n     all_mono_items.contains(&id)\n }\n \n-pub fn provide_both(providers: &mut Providers) {\n+pub fn provide_both(providers: &mut Providers<'_>) {\n     providers.backend_optimization_level = |tcx, cratenum| {\n         let for_speed = match tcx.sess.opts.optimize {\n             // If globally no optimisation is done, #[optimize] has no effect."}, {"sha": "db77074deef9415526a6bfac2d7a3c19ac40b753", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -134,7 +134,7 @@ mod temp_stable_hash_impls {\n     }\n }\n \n-pub fn langcall(tcx: TyCtxt,\n+pub fn langcall(tcx: TyCtxt<'_, '_, '_>,\n                 span: Option<Span>,\n                 msg: &str,\n                 li: LangItem)"}, {"sha": "92fa2766f8727a535d1d6c548fdc4a8a33c830dd", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -11,7 +11,6 @@\n #![allow(dead_code)]\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n-#![allow(elided_lifetimes_in_paths)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "0e8cdc83b486e24aed97a27d18e12f73bc6d30b0", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -48,7 +48,7 @@ pub struct OperandRef<'tcx, V> {\n }\n \n impl<V: CodegenObject> fmt::Debug for OperandRef<'tcx, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"OperandRef({:?} @ {:?})\", self.val, self.layout)\n     }\n }"}, {"sha": "00eae9098e74fdd0abd4e77c8011c9adedcca4a3", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -32,13 +32,18 @@ impl<'tcx, T> Backend<'tcx> for T where\n }\n \n pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Send {\n-    fn new_metadata(&self, sess: TyCtxt, mod_name: &str) -> Self::Module;\n+    fn new_metadata(&self, sess: TyCtxt<'_, '_, '_>, mod_name: &str) -> Self::Module;\n     fn write_metadata<'b, 'gcx>(\n         &self,\n         tcx: TyCtxt<'b, 'gcx, 'gcx>,\n         metadata: &mut Self::Module,\n     ) -> EncodedMetadata;\n-    fn codegen_allocator(&self, tcx: TyCtxt, mods: &mut Self::Module, kind: AllocatorKind);\n+    fn codegen_allocator(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        mods: &mut Self::Module,\n+        kind: AllocatorKind\n+    );\n     fn compile_codegen_unit<'a, 'tcx: 'a>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "5099107a393036a28b2cbee10b7304e670897450", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -100,7 +100,7 @@ pub trait BuilderMethods<'a, 'tcx: 'a>:\n     fn checked_binop(\n         &mut self,\n         oop: OverflowOp,\n-        ty: Ty,\n+        ty: Ty<'_>,\n         lhs: Self::Value,\n         rhs: Self::Value,\n     ) -> (Self::Value, Self::Value);"}, {"sha": "135188e98c71c57e6183c17f412c9a9c89c4cda8", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -22,12 +22,12 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         sig: ty::FnSig<'tcx>,\n         llfn: Self::Value,\n-        mir: &mir::Mir,\n+        mir: &mir::Mir<'_>,\n     ) -> FunctionDebugContext<Self::DIScope>;\n \n     fn create_mir_scopes(\n         &self,\n-        mir: &mir::Mir,\n+        mir: &mir::Mir<'_>,\n         debug_context: &FunctionDebugContext<Self::DIScope>,\n     ) -> IndexVec<mir::SourceScope, MirDebugScope<Self::DIScope>>;\n     fn extend_scope_to_file("}, {"sha": "f03f84ba519d6ab803555da60f0aea6c0e7f4bce", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -16,7 +16,6 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{ast, attr};\n use syntax::errors::Applicability;\n use rustc_target::spec::abi::Abi;\n-use syntax::edition::Edition;\n use syntax_pos::Span;\n use syntax::source_map;\n \n@@ -34,9 +33,8 @@ declare_lint! {\n \n declare_lint! {\n     OVERFLOWING_LITERALS,\n-    Warn,\n-    \"literal out of range for its type\",\n-    Edition::Edition2018 => Deny\n+    Deny,\n+    \"literal out of range for its type\"\n }\n \n declare_lint! {"}, {"sha": "caadc6055b5c617cbb34635c6624409dfb55660f", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -21,8 +21,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         let param_ty = ParamEnv::reveal_all().and(tcx.lift_to_global(&ty).unwrap());\n         let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n-        let shift = 128 - width.bits();\n-        let result = (n << shift) >> shift;\n+        let result = truncate(n, width);\n         trace!(\"trunc result: {}\", result);\n         Ok(ConstValue::Scalar(Scalar::Bits {\n             bits: result,"}, {"sha": "71368927a801dc575e5760bc458adfa04a7f4a01", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -196,7 +196,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n     /// Report error if there is an explicit type parameter when using `impl Trait`.\n     fn check_impl_trait(\n-        tcx: TyCtxt,\n+        tcx: TyCtxt<'_, '_, '_>,\n         span: Span,\n         seg: &hir::PathSegment,\n         generics: &ty::Generics,\n@@ -227,7 +227,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// Used specifically for function calls.\n     pub fn check_generic_arg_count_for_call(\n-        tcx: TyCtxt,\n+        tcx: TyCtxt<'_, '_, '_>,\n         span: Span,\n         def: &ty::Generics,\n         seg: &hir::PathSegment,\n@@ -259,7 +259,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     /// Checks that the correct number of generic arguments have been provided.\n     /// This is used both for datatypes and function calls.\n     fn check_generic_arg_count(\n-        tcx: TyCtxt,\n+        tcx: TyCtxt<'_, '_, '_>,\n         span: Span,\n         def: &ty::Generics,\n         args: &hir::GenericArgs,\n@@ -1502,7 +1502,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         has_err\n     }\n \n-    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt, span: Span) {\n+    pub fn prohibit_assoc_ty_binding(tcx: TyCtxt<'_, '_, '_>, span: Span) {\n         let mut err = struct_span_err!(tcx.sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n         err.span_label(span, \"associated type not allowed here\").emit();"}, {"sha": "13469f1696631908712f63e0052a978ca0561c81", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -183,7 +183,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let rhs_ty = self.check_expr(end);\n \n                 // Check that both end-points are of numeric or char type.\n-                let numeric_or_char = |ty: Ty| ty.is_numeric() || ty.is_char();\n+                let numeric_or_char = |ty: Ty<'_>| ty.is_numeric() || ty.is_char();\n                 let lhs_compat = numeric_or_char(lhs_ty);\n                 let rhs_compat = numeric_or_char(rhs_ty);\n "}, {"sha": "84d3c203afbe429f704acb1de40896ac01bc1356", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -18,7 +18,7 @@ use rustc::hir;\n /// Checks that it is legal to call methods of the trait corresponding\n /// to `trait_id` (this only cares about the trait, not the specific\n /// method that is called).\n-pub fn check_legal_trait_for_method_call(tcx: TyCtxt, span: Span, trait_id: DefId) {\n+pub fn check_legal_trait_for_method_call(tcx: TyCtxt<'_, '_, '_>, span: Span, trait_id: DefId) {\n     if tcx.lang_items().drop_trait() == Some(trait_id) {\n         struct_span_err!(tcx.sess, span, E0040, \"explicit use of destructor method\")\n             .span_label(span, \"explicit destructor calls not allowed\")"}, {"sha": "5f765245183901aedfea60ecb6caaa0b365ef8b1", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -574,7 +574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         expr_def_id: DefId,\n         decl: &hir::FnDecl,\n     ) -> ty::PolyFnSig<'tcx> {\n-        let astconv: &dyn AstConv = self;\n+        let astconv: &dyn AstConv<'_, '_> = self;\n \n         // First, convert the types that the user supplied (if any).\n         let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n@@ -606,7 +606,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// so should yield an error, but returns back a signature where\n     /// all parameters are of type `TyErr`.\n     fn error_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n-        let astconv: &dyn AstConv = self;\n+        let astconv: &dyn AstConv<'_, '_> = self;\n \n         let supplied_arguments = decl.inputs.iter().map(|a| {\n             // Convert the types that the user supplied (if any), but ignore them."}, {"sha": "8841f6b268419651af8ebf8869b1e423c1cbd31c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -101,7 +101,7 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n     }\n }\n \n-fn identity(_: Ty) -> Vec<Adjustment> { vec![] }\n+fn identity(_: Ty<'_>) -> Vec<Adjustment<'_>> { vec![] }\n \n fn simple<'tcx>(kind: Adjust<'tcx>) -> impl FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>> {\n     move |target| vec![Adjustment { kind, target }]\n@@ -1084,7 +1084,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     pub fn coerce_forced_unit<'a>(&mut self,\n                                   fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n                                   cause: &ObligationCause<'tcx>,\n-                                  augment_error: &mut dyn FnMut(&mut DiagnosticBuilder),\n+                                  augment_error: &mut dyn FnMut(&mut DiagnosticBuilder<'_>),\n                                   label_unit_as_expected: bool)\n     {\n         self.coerce_inner(fcx,\n@@ -1103,7 +1103,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         cause: &ObligationCause<'tcx>,\n                         expression: Option<&'gcx hir::Expr>,\n                         mut expression_ty: Ty<'tcx>,\n-                        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder)>,\n+                        augment_error: Option<&mut dyn FnMut(&mut DiagnosticBuilder<'_>)>,\n                         label_expression_as_expected: bool)\n     {\n         // Incorporate whatever type inference information we have"}, {"sha": "c6b34672e6b4c485102fc60786211633ddc84626", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -408,7 +408,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n                                                      param_env: ty::ParamEnv<'tcx>,\n-                                                     terr: &TypeError,\n+                                                     terr: &TypeError<'_>,\n                                                      cause: &ObligationCause<'tcx>,\n                                                      impl_m: &ty::AssociatedItem,\n                                                      impl_sig: ty::FnSig<'tcx>,"}, {"sha": "adff5f2f9b9c8f7a677447333dc0f040a1d6e243", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -544,7 +544,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             let into_sugg = into_suggestion.clone();\n-            let suggest_to_change_suffix_or_into = |err: &mut DiagnosticBuilder,\n+            let suggest_to_change_suffix_or_into = |err: &mut DiagnosticBuilder<'_>,\n                                                     note: Option<&str>| {\n                 let suggest_msg = if literal_is_ty_suffixed(expr) {\n                     format!("}, {"sha": "1eaa8b17d09f7e64ed48e2db09a90b33a64bce6a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             })\n     }\n \n-    fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n+    fn enforce_illegal_method_limitations(&self, pick: &probe::Pick<'_>) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {\n             ty::TraitContainer(trait_def_id) => {"}, {"sha": "04352626190f316bc6b5ea4c7447c0d46c3679de", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -388,7 +388,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.method_autoderef_steps = method_autoderef_steps;\n }\n \n@@ -1180,7 +1180,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn emit_unstable_name_collision_hint(\n         &self,\n-        stable_pick: &Pick,\n+        stable_pick: &Pick<'_>,\n         unstable_candidates: &[(&Candidate<'tcx>, Symbol)],\n     ) {\n         let mut diag = self.tcx.struct_span_lint_hir("}, {"sha": "c15cb1e5bb15140cd804318bd6ac44388ad7229a", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -72,7 +72,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let report_candidates = |err: &mut DiagnosticBuilder, mut sources: Vec<CandidateSource>| {\n+        let report_candidates = |err: &mut DiagnosticBuilder<'_>,\n+                                 mut sources: Vec<CandidateSource>| {\n             sources.sort();\n             sources.dedup();\n             // Dynamic limit to avoid hiding just one candidate, which is silly.\n@@ -497,7 +498,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn suggest_use_candidates(&self,\n-                              err: &mut DiagnosticBuilder,\n+                              err: &mut DiagnosticBuilder<'_>,\n                               mut msg: String,\n                               candidates: Vec<DefId>) {\n         let module_did = self.tcx.hir().get_module_parent_by_hir_id(self.body_id);\n@@ -549,7 +550,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn suggest_valid_traits(&self,\n-                            err: &mut DiagnosticBuilder,\n+                            err: &mut DiagnosticBuilder<'_>,\n                             valid_out_of_scope_traits: Vec<DefId>) -> bool {\n         if !valid_out_of_scope_traits.is_empty() {\n             let mut candidates = valid_out_of_scope_traits;\n@@ -577,7 +578,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn suggest_traits_to_import<'b>(&self,\n-                                    err: &mut DiagnosticBuilder,\n+                                    err: &mut DiagnosticBuilder<'_>,\n                                     span: Span,\n                                     rcvr_ty: Ty<'tcx>,\n                                     item_name: ast::Ident,\n@@ -648,8 +649,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn type_derefs_to_local(&self,\n                             span: Span,\n                             rcvr_ty: Ty<'tcx>,\n-                            source: SelfSource) -> bool {\n-        fn is_local(ty: Ty) -> bool {\n+                            source: SelfSource<'_>) -> bool {\n+        fn is_local(ty: Ty<'_>) -> bool {\n             match ty.sty {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n@@ -749,7 +750,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     // Cross-crate:\n \n     let mut external_mods = FxHashSet::default();\n-    fn handle_external_def(tcx: TyCtxt,\n+    fn handle_external_def(tcx: TyCtxt<'_, '_, '_>,\n                            traits: &mut Vec<DefId>,\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n@@ -779,7 +780,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n     traits\n }\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     providers.all_traits = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Lrc::new(compute_all_traits(tcx))"}, {"sha": "2128466515123aa8b946cb6648da9e1716b2e004", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -738,7 +738,7 @@ fn check_impl_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: De\n     wfcheck::check_impl_item(tcx, def_id);\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     method::provide(providers);\n     *providers = Providers {\n         typeck_item_bodies,\n@@ -1437,7 +1437,7 @@ pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Ite\n     }\n }\n \n-fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n+fn maybe_check_static_with_link_section(tcx: TyCtxt<'_, '_, '_>, id: DefId, span: Span) {\n     // Only restricted on wasm32 target for now\n     if !tcx.sess.opts.target_triple.triple().starts_with(\"wasm32\") {\n         return\n@@ -2122,7 +2122,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn tag(&self) -> String {\n-        let self_ptr: *const FnCtxt = self;\n+        let self_ptr: *const FnCtxt<'_, '_, '_> = self;\n         format!(\"{:?}\", self_ptr)\n     }\n \n@@ -3369,7 +3369,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // (`only_has_type`); otherwise, we just go with a\n         // fresh type variable.\n         let coerce_to_ty = expected.coercion_target_type(self, sp);\n-        let mut coerce: DynamicCoerceMany = CoerceMany::new(coerce_to_ty);\n+        let mut coerce: DynamicCoerceMany<'_, '_> = CoerceMany::new(coerce_to_ty);\n \n         coerce.coerce(self, &self.misc(sp), then_expr, then_ty);\n \n@@ -5043,7 +5043,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given a function `Node`, return its `FnDecl` if it exists, or `None` otherwise.\n-    fn get_node_fn_decl(&self, node: Node) -> Option<(hir::FnDecl, ast::Ident, bool)> {\n+    fn get_node_fn_decl(&self, node: Node<'_>) -> Option<(hir::FnDecl, ast::Ident, bool)> {\n         match node {\n             Node::Item(&hir::Item {\n                 ident, node: hir::ItemKind::Fn(ref decl, ..), .."}, {"sha": "e6b4523f9e7cc5e467b201ce6b4c9e79fd77a8db", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         rhs_expr: &'gcx hir::Expr,\n         lhs_ty: Ty<'tcx>,\n         rhs_ty: Ty<'tcx>,\n-        err: &mut errors::DiagnosticBuilder,\n+        err: &mut errors::DiagnosticBuilder<'_>,\n         is_assign: bool,\n     ) -> bool {\n         let source_map = self.tcx.sess.source_map();\n@@ -688,7 +688,7 @@ enum Op {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/codegen after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop(lhs: Ty, rhs: Ty, op: hir::BinOp) -> bool {\n+fn is_builtin_binop(lhs: Ty<'_>, rhs: Ty<'_>, op: hir::BinOp) -> bool {\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             true"}, {"sha": "1a165e6ff1eb88c32f363453b42380131ba35479", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -649,6 +649,6 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn var_name(tcx: TyCtxt, var_hir_id: hir::HirId) -> ast::Name {\n+fn var_name(tcx: TyCtxt<'_, '_, '_>, var_hir_id: hir::HirId) -> ast::Name {\n     tcx.hir().name_by_hir_id(var_hir_id)\n }"}, {"sha": "9217484f3a7af84714eb1d8db04f7f0140ba4cb2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -938,7 +938,7 @@ fn report_bivariance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     err.emit();\n }\n \n-fn reject_shadowing_parameters(tcx: TyCtxt, def_id: DefId) {\n+fn reject_shadowing_parameters(tcx: TyCtxt<'_, '_, '_>, def_id: DefId) {\n     let generics = tcx.generics_of(def_id);\n     let parent = tcx.generics_of(generics.parent.unwrap());\n     let impl_params: FxHashMap<_, _> = parent.params.iter().flat_map(|param| match param.kind {\n@@ -1093,7 +1093,7 @@ fn error_392<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, param_name: ast:\n     err\n }\n \n-fn error_194(tcx: TyCtxt, span: Span, trait_decl_span: Span, name: &str) {\n+fn error_194(tcx: TyCtxt<'_, '_, '_>, span: Span, trait_decl_span: Span, name: &str) {\n     struct_span_err!(tcx.sess, span, E0194,\n                      \"type parameter `{}` shadows another type parameter of the same name\",\n                      name)"}, {"sha": "c4575e6b01ee51d5864c4ceb2ec52e04c5190205", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -729,30 +729,30 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n }\n \n trait Locatable {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span;\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span;\n }\n \n impl Locatable for Span {\n-    fn to_span(&self, _: &TyCtxt) -> Span {\n+    fn to_span(&self, _: &TyCtxt<'_, '_, '_>) -> Span {\n         *self\n     }\n }\n \n impl Locatable for ast::NodeId {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span {\n         tcx.hir().span(*self)\n     }\n }\n \n impl Locatable for DefIndex {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span {\n         let hir_id = tcx.hir().def_index_to_hir_id(*self);\n         tcx.hir().span_by_hir_id(hir_id)\n     }\n }\n \n impl Locatable for hir::HirId {\n-    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+    fn to_span(&self, tcx: &TyCtxt<'_, '_, '_>) -> Span {\n         tcx.hir().span_by_hir_id(*self)\n     }\n }"}, {"sha": "282f1bad172dca5ed204d8e02b34e7b4a6fb9036", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -20,7 +20,7 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult,\n+                                       overlap: traits::OverlapResult<'_>,\n                                        used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {"}, {"sha": "01aba658850bfb345830327518ee6a1751d9ca60", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -41,7 +41,11 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     }\n }\n \n-fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_trait_manually_implementable(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    impl_def_id: DefId,\n+    trait_def_id: DefId\n+) {\n     let did = Some(trait_def_id);\n     let li = tcx.lang_items();\n     let span = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n@@ -93,7 +97,11 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, impl_def_id: DefId, trait_d\n \n /// We allow impls of marker traits to overlap, so they can't override impls\n /// as that could make it ambiguous which associated item to use.\n-fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt, impl_def_id: DefId, trait_def_id: DefId) {\n+fn enforce_empty_impls_for_marker_traits(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    impl_def_id: DefId,\n+    trait_def_id: DefId\n+) {\n     if !tcx.trait_def(trait_def_id).is_marker {\n         return;\n     }\n@@ -110,7 +118,7 @@ fn enforce_empty_impls_for_marker_traits(tcx: TyCtxt, impl_def_id: DefId, trait_\n         .emit();\n }\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     use self::builtin::coerce_unsized_info;\n     use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n     use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;"}, {"sha": "5af66969477cadccbc1fe9ef06c95121b5c71d36", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1406,7 +1406,7 @@ fn find_existential_constraints<'a, 'tcx>(\n                         ty::Param(p) => Some(*index_map.get(p).unwrap()),\n                         _ => None,\n                     }).collect();\n-                let is_param = |ty: ty::Ty| match ty.sty {\n+                let is_param = |ty: ty::Ty<'_>| match ty.sty {\n                     ty::Param(_) => true,\n                     _ => false,\n                 };\n@@ -2216,7 +2216,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n         && abi != abi::Abi::PlatformIntrinsic\n         && !tcx.features().simd_ffi\n     {\n-        let check = |ast_ty: &hir::Ty, ty: Ty| {\n+        let check = |ast_ty: &hir::Ty, ty: Ty<'_>| {\n             if ty.is_simd() {\n                 tcx.sess\n                    .struct_span_err(\n@@ -2251,7 +2251,7 @@ fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool\n }\n \n fn from_target_feature(\n-    tcx: TyCtxt,\n+    tcx: TyCtxt<'_, '_, '_>,\n     id: DefId,\n     attr: &ast::Attribute,\n     whitelist: &FxHashMap<String, Option<String>>,"}, {"sha": "feff79dc3f5089308cc37564db91c3e83100d62c", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -2873,8 +2873,8 @@ E0370: r##\"\n The maximum value of an enum was reached, so it cannot be automatically\n set in the next enum value. Erroneous code example:\n \n-```compile_fail\n-#[deny(overflowing_literals)]\n+```compile_fail,E0370\n+#[repr(i64)]\n enum Foo {\n     X = 0x7fffffffffffffff,\n     Y, // error: enum discriminant overflowed on value after\n@@ -2887,6 +2887,7 @@ To fix this, please set manually the next enum value or put the enum variant\n with the maximum value at the end of the enum. Examples:\n \n ```\n+#[repr(i64)]\n enum Foo {\n     X = 0x7fffffffffffffff,\n     Y = 0, // ok!\n@@ -2896,6 +2897,7 @@ enum Foo {\n Or:\n \n ```\n+#[repr(i64)]\n enum Foo {\n     Y = 0, // ok!\n     X = 0x7fffffffffffffff,"}, {"sha": "3682acd3c62c127e8f2b28e3716cfcda808454d9", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -74,8 +74,6 @@ This API is completely unstable and subject to change.\n #![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n \n-#![allow(elided_lifetimes_in_paths)] // WIP\n-\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n "}, {"sha": "c2f79207a562469ef6e1b86e6ce22408037f0eb2", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -27,7 +27,7 @@ pub mod test;\n /// Code for transforming variances.\n mod xform;\n \n-pub fn provide(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         variances_of,\n         crate_variances,\n@@ -91,4 +91,3 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n                        .unwrap_or(&crate_map.empty_variance)\n                        .clone()\n }\n-"}, {"sha": "f962c1313a923ee60b2d0615d781ab9d53b25481", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -23,7 +23,7 @@ struct SolveContext<'a, 'tcx: 'a> {\n     solutions: Vec<ty::Variance>,\n }\n \n-pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n+pub fn solve_constraints(constraints_cx: ConstraintContext<'_, '_>) -> ty::CrateVariancesMap {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n     let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];"}, {"sha": "4e562992e8cf931ee267600ae1fe85d305bb02b5", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -32,7 +32,7 @@ pub enum VarianceTerm<'a> {\n }\n \n impl<'a> fmt::Debug for VarianceTerm<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n             TransformTerm(v1, v2) => write!(f, \"({:?} \\u{00D7} {:?})\", v1, v2),\n@@ -86,7 +86,7 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     terms_cx\n }\n \n-fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n+fn lang_items(tcx: TyCtxt<'_, '_, '_>) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n     let lang_items = tcx.lang_items();\n     let all = vec![\n         (lang_items.phantom_data(), vec![ty::Covariant]),"}, {"sha": "e905da72aad70ba91d73d189eeb633ad1ae88ece", "filename": "src/test/run-pass/issues/issue-27949.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27949.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27949.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-27949.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -0,0 +1,41 @@\n+// run-pass\n+//\n+// At one time, the `==` operator (and other binary operators) did not\n+// support subtyping during type checking, and would therefore require\n+// LHS and RHS to be exactly identical--i.e. to have the same lifetimes.\n+//\n+// This was fixed in 1a7fb7dc78439a704f024609ce3dc0beb1386552.\n+\n+#[derive(Copy, Clone)]\n+struct Input<'a> {\n+    foo: &'a u32\n+}\n+\n+impl <'a> std::cmp::PartialEq<Input<'a>> for Input<'a> {\n+    fn eq(&self, other: &Input<'a>) -> bool {\n+        self.foo == other.foo\n+    }\n+\n+    fn ne(&self, other: &Input<'a>) -> bool {\n+        self.foo != other.foo\n+    }\n+}\n+\n+\n+fn check_equal<'a, 'b>(x: Input<'a>, y: Input<'b>) -> bool {\n+    // Type checking error due to 'a != 'b prior to 1a7fb7dc78\n+    x == y\n+}\n+\n+fn main() {\n+    let i = 1u32;\n+    let j = 1u32;\n+    let k = 2u32;\n+\n+    let input_i = Input { foo: &i };\n+    let input_j = Input { foo: &j };\n+    let input_k = Input { foo: &k };\n+    assert!(check_equal(input_i, input_i));\n+    assert!(check_equal(input_i, input_j));\n+    assert!(!check_equal(input_i, input_k));\n+}"}, {"sha": "ebd6654d39b1f7aae97380983600c1c0b38aa93b", "filename": "src/test/ui/lint/deny-overflowing-literals.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,5 +1,3 @@\n-// edition:2018\n-\n fn main() {\n     let x: u8 = 256;\n     //~^ error: literal out of range for u8", "previous_filename": "src/test/ui/editions/edition-deny-overflowing-literals-2018.rs"}, {"sha": "7313dd0bfb5a7caa035cb4d36aed48da688b24bc", "filename": "src/test/ui/lint/deny-overflowing-literals.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdeny-overflowing-literals.stderr?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,5 +1,5 @@\n error: literal out of range for u8\n-  --> $DIR/edition-deny-overflowing-literals-2018.rs:4:17\n+  --> $DIR/deny-overflowing-literals.rs:2:17\n    |\n LL |     let x: u8 = 256;\n    |                 ^^^", "previous_filename": "src/test/ui/editions/edition-deny-overflowing-literals-2018.stderr"}, {"sha": "c4486e06768873a7f3c89fcab58a2ebd0b062ffb", "filename": "src/test/ui/lint/lint-type-limits2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,4 +1,5 @@\n #![allow(dead_code)]\n+#![warn(overflowing_literals)]\n \n // compile-flags: -D unused-comparisons\n fn main() { }"}, {"sha": "f88fff62e21fc1e65b6cbd9060f89467d8d62cbd", "filename": "src/test/ui/lint/lint-type-limits2.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits2.stderr?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,18 +1,22 @@\n error: comparison is useless due to type limits\n-  --> $DIR/lint-type-limits2.rs:12:5\n+  --> $DIR/lint-type-limits2.rs:13:5\n    |\n LL |     128 > bar() //~ ERROR comparison is useless due to type limits\n    |     ^^^^^^^^^^^\n    |\n    = note: requested on the command line with `-D unused-comparisons`\n \n warning: literal out of range for i8\n-  --> $DIR/lint-type-limits2.rs:12:5\n+  --> $DIR/lint-type-limits2.rs:13:5\n    |\n LL |     128 > bar() //~ ERROR comparison is useless due to type limits\n    |     ^^^\n    |\n-   = note: #[warn(overflowing_literals)] on by default\n+note: lint level defined here\n+  --> $DIR/lint-type-limits2.rs:2:9\n+   |\n+LL | #![warn(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "a715c69f7849ef244ed38505ee987b0b2441023a", "filename": "src/test/ui/lint/lint-type-limits3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,4 +1,5 @@\n #![allow(dead_code)]\n+#![warn(overflowing_literals)]\n \n // compile-flags: -D unused-comparisons\n fn main() { }"}, {"sha": "4f47a7ce31665bc00289f8d0aeb3128e85fb6f2d", "filename": "src/test/ui/lint/lint-type-limits3.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-type-limits3.stderr?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,18 +1,22 @@\n error: comparison is useless due to type limits\n-  --> $DIR/lint-type-limits3.rs:8:11\n+  --> $DIR/lint-type-limits3.rs:9:11\n    |\n LL |     while 200 != i { //~ ERROR comparison is useless due to type limits\n    |           ^^^^^^^^\n    |\n    = note: requested on the command line with `-D unused-comparisons`\n \n warning: literal out of range for i8\n-  --> $DIR/lint-type-limits3.rs:8:11\n+  --> $DIR/lint-type-limits3.rs:9:11\n    |\n LL |     while 200 != i { //~ ERROR comparison is useless due to type limits\n    |           ^^^\n    |\n-   = note: #[warn(overflowing_literals)] on by default\n+note: lint level defined here\n+  --> $DIR/lint-type-limits3.rs:2:9\n+   |\n+LL | #![warn(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "64e595120737990734d65f444832b3f9ede825ca", "filename": "src/test/ui/lint/type-overflow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.rs?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,4 +1,5 @@\n // compile-pass\n+#![warn(overflowing_literals)]\n \n fn main() {\n     let error = 255i8; //~WARNING literal out of range for i8"}, {"sha": "349d0be0164974386c1d6642717d329529b6c82d", "filename": "src/test/ui/lint/type-overflow.stderr", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da573206f87b5510de4b0ee1a9c044127e409bd3/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftype-overflow.stderr?ref=da573206f87b5510de4b0ee1a9c044127e409bd3", "patch": "@@ -1,37 +1,41 @@\n warning: literal out of range for i8\n-  --> $DIR/type-overflow.rs:4:17\n+  --> $DIR/type-overflow.rs:5:17\n    |\n LL |     let error = 255i8; //~WARNING literal out of range for i8\n    |                 ^^^^^\n    |\n-   = note: #[warn(overflowing_literals)] on by default\n+note: lint level defined here\n+  --> $DIR/type-overflow.rs:2:9\n+   |\n+LL | #![warn(overflowing_literals)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n \n warning: literal out of range for i8\n-  --> $DIR/type-overflow.rs:9:16\n+  --> $DIR/type-overflow.rs:10:16\n    |\n LL |     let fail = 0b1000_0001i8; //~WARNING literal out of range for i8\n    |                ^^^^^^^^^^^^^ help: consider using `u8` instead: `0b1000_0001u8`\n    |\n    = note: the literal `0b1000_0001i8` (decimal `129`) does not fit into an `i8` and will become `-127i8`\n \n warning: literal out of range for i64\n-  --> $DIR/type-overflow.rs:11:16\n+  --> $DIR/type-overflow.rs:12:16\n    |\n LL |     let fail = 0x8000_0000_0000_0000i64; //~WARNING literal out of range for i64\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `u64` instead: `0x8000_0000_0000_0000u64`\n    |\n    = note: the literal `0x8000_0000_0000_0000i64` (decimal `9223372036854775808`) does not fit into an `i64` and will become `-9223372036854775808i64`\n \n warning: literal out of range for u32\n-  --> $DIR/type-overflow.rs:13:16\n+  --> $DIR/type-overflow.rs:14:16\n    |\n LL |     let fail = 0x1_FFFF_FFFFu32; //~WARNING literal out of range for u32\n    |                ^^^^^^^^^^^^^^^^ help: consider using `u64` instead: `0x1_FFFF_FFFFu64`\n    |\n    = note: the literal `0x1_FFFF_FFFFu32` (decimal `8589934591`) does not fit into an `u32` and will become `4294967295u32`\n \n warning: literal out of range for i128\n-  --> $DIR/type-overflow.rs:15:22\n+  --> $DIR/type-overflow.rs:16:22\n    |\n LL |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -40,7 +44,7 @@ LL |     let fail: i128 = 0x8000_0000_0000_0000_0000_0000_0000_0000;\n    = help: consider using `u128` instead\n \n warning: literal out of range for i32\n-  --> $DIR/type-overflow.rs:18:16\n+  --> $DIR/type-overflow.rs:19:16\n    |\n LL |     let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i32\n    |                ^^^^^^^^^^^^^^^^^^^^^\n@@ -49,7 +53,7 @@ LL |     let fail = 0x8FFF_FFFF_FFFF_FFFE; //~WARNING literal out of range for i\n    = help: consider using `i128` instead\n \n warning: literal out of range for i8\n-  --> $DIR/type-overflow.rs:20:17\n+  --> $DIR/type-overflow.rs:21:17\n    |\n LL |     let fail = -0b1111_1111i8; //~WARNING literal out of range for i8\n    |                 ^^^^^^^^^^^^^ help: consider using `i16` instead: `0b1111_1111i16`"}]}