{"sha": "ad3a69739f508a2d6219479bf98ac9f853ac3574", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkM2E2OTczOWY1MDhhMmQ2MjE5NDc5YmY5OGFjOWY4NTNhYzM1NzQ=", "commit": {"author": {"name": "OGINO Masanori", "email": "masanori.ogino@gmail.com", "date": "2013-07-16T22:18:42Z"}, "committer": {"name": "OGINO Masanori", "email": "masanori.ogino@gmail.com", "date": "2013-07-16T22:48:30Z"}, "message": "Add project information to l10n templates.", "tree": {"sha": "e66d2f98f64817dad0ce882056fe27895c8ddebc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e66d2f98f64817dad0ce882056fe27895c8ddebc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad3a69739f508a2d6219479bf98ac9f853ac3574", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3a69739f508a2d6219479bf98ac9f853ac3574", "html_url": "https://github.com/rust-lang/rust/commit/ad3a69739f508a2d6219479bf98ac9f853ac3574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad3a69739f508a2d6219479bf98ac9f853ac3574/comments", "author": {"login": "omasanori", "id": 167209, "node_id": "MDQ6VXNlcjE2NzIwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/167209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omasanori", "html_url": "https://github.com/omasanori", "followers_url": "https://api.github.com/users/omasanori/followers", "following_url": "https://api.github.com/users/omasanori/following{/other_user}", "gists_url": "https://api.github.com/users/omasanori/gists{/gist_id}", "starred_url": "https://api.github.com/users/omasanori/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omasanori/subscriptions", "organizations_url": "https://api.github.com/users/omasanori/orgs", "repos_url": "https://api.github.com/users/omasanori/repos", "events_url": "https://api.github.com/users/omasanori/events{/privacy}", "received_events_url": "https://api.github.com/users/omasanori/received_events", "type": "User", "site_admin": false}, "committer": {"login": "omasanori", "id": 167209, "node_id": "MDQ6VXNlcjE2NzIwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/167209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/omasanori", "html_url": "https://github.com/omasanori", "followers_url": "https://api.github.com/users/omasanori/followers", "following_url": "https://api.github.com/users/omasanori/following{/other_user}", "gists_url": "https://api.github.com/users/omasanori/gists{/gist_id}", "starred_url": "https://api.github.com/users/omasanori/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/omasanori/subscriptions", "organizations_url": "https://api.github.com/users/omasanori/orgs", "repos_url": "https://api.github.com/users/omasanori/repos", "events_url": "https://api.github.com/users/omasanori/events{/privacy}", "received_events_url": "https://api.github.com/users/omasanori/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db190305f7562f15b5282fed508aef81cfc9689", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db190305f7562f15b5282fed508aef81cfc9689", "html_url": "https://github.com/rust-lang/rust/commit/9db190305f7562f15b5282fed508aef81cfc9689"}], "stats": {"total": 2098, "additions": 1202, "deletions": 896}, "files": [{"sha": "516ca32104adf4cd9a38c465ecc17922330c1173", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 631, "deletions": 482, "changes": 1113, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574"}, {"sha": "134aa56b3dab48ca8154096594c19faf987e3ef4", "filename": "doc/po/rustpkg.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Frustpkg.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Frustpkg.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frustpkg.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -19,7 +19,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n #: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4 doc/tut.md:4\n+#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"\"\n "}, {"sha": "816b3eeea61e61e88611d1c6bd92bbda4d0c2547", "filename": "doc/po/tutorial-borrowed-ptr.md.pot", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-borrowed-ptr.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-borrowed-ptr.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-borrowed-ptr.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -19,12 +19,12 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n #: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4 doc/tut.md:4\n+#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1110 doc/tutorial-borrowed-ptr.md:72\n+#: doc/tutorial.md:1111 doc/tutorial-borrowed-ptr.md:72\n msgid \"Now we can call `compute_distance()` in various ways:\"\n msgstr \"\"\n "}, {"sha": "3a4e86f8c82ee6c102c94568199583e79d730f26", "filename": "doc/po/tutorial-container.md.pot", "status": "modified", "additions": 163, "deletions": 7, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-container.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-container.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-container.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -195,7 +195,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:89\n+#: doc/tutorial-container.md:89 doc/tutorial-container.md:262\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -217,7 +217,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:107\n+#: doc/tutorial-container.md:107 doc/tutorial-container.md:284\n #, no-wrap\n msgid \"\"\n \"impl Iterator<int> for ZeroStream {\\n\"\n@@ -440,6 +440,162 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial-container.md:207\n+#: doc/tutorial-container.md:208\n msgid \"// the iterator is now fully consumed assert!(it.next().is_none()); ~~~\"\n msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:210\n+msgid \"## Conversion\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:212\n+msgid \"\"\n+\"Iterators offer generic conversion to containers with the `collect` adaptor:\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:218\n+msgid \"\"\n+\"~~~ let xs = [0, 1, 1, 2, 3, 5, 8]; let ys = xs.rev_iter().skip(1).\"\n+\"transform(|&x| x * 2).collect::<~[int]>(); assert_eq!(ys, ~[10, 6, 4, 2, 2, \"\n+\"0]); ~~~\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:221\n+msgid \"\"\n+\"The method requires a type hint for the container type, if the surrounding \"\n+\"code does not provide sufficient information.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:225\n+msgid \"\"\n+\"Containers can provide conversion from iterators through `collect` by \"\n+\"implementing the `FromIterator` trait. For example, the implementation for \"\n+\"vectors is as follows:\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:238\n+#, no-wrap\n+msgid \"\"\n+\"~~~\\n\"\n+\"impl<A, T: Iterator<A>> FromIterator<A, T> for ~[A] {\\n\"\n+\"    pub fn from_iterator(iterator: &mut T) -> ~[A] {\\n\"\n+\"        let (lower, _) = iterator.size_hint();\\n\"\n+\"        let mut xs = with_capacity(lower);\\n\"\n+\"        for iterator.advance |x| {\\n\"\n+\"            xs.push(x);\\n\"\n+\"        }\\n\"\n+\"        xs\\n\"\n+\"    }\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:240\n+msgid \"### Size hints\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:243\n+msgid \"\"\n+\"The `Iterator` trait provides a `size_hint` default method, returning a \"\n+\"lower bound and optionally on upper bound on the length of the iterator:\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:247\n+msgid \"~~~ fn size_hint(&self) -> (uint, Option<uint>) { (0, None) } ~~~\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:251\n+msgid \"\"\n+\"The vector implementation of `FromIterator` from above uses the lower bound \"\n+\"to pre-allocate enough space to hold the minimum number of elements the \"\n+\"iterator will yield.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:254\n+msgid \"\"\n+\"The default implementation is always correct, but it should be overridden if \"\n+\"the iterator can provide better information.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:256\n+msgid \"\"\n+\"The `ZeroStream` from earlier can provide an exact lower and upper bound:\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:267\n+#, no-wrap\n+msgid \"\"\n+\"impl ZeroStream {\\n\"\n+\"    fn new(n: uint) -> ZeroStream {\\n\"\n+\"        ZeroStream { remaining: n }\\n\"\n+\"    }\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:272\n+#, no-wrap\n+msgid \"\"\n+\"    fn size_hint(&self) -> (uint, Option<uint>) {\\n\"\n+\"        (self.remaining, Some(self.remaining))\\n\"\n+\"    }\\n\"\n+\"}\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:286\n+msgid \"## Double-ended iterators\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:290\n+msgid \"\"\n+\"The `DoubleEndedIterator` trait represents an iterator able to yield \"\n+\"elements from either end of a range. It inherits from the `Iterator` trait \"\n+\"and extends it with the `next_back` function.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:293\n+msgid \"\"\n+\"A `DoubleEndedIterator` can be flipped with the `invert` adaptor, returning \"\n+\"another `DoubleEndedIterator` with `next` and `next_back` exchanged.\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:300\n+msgid \"\"\n+\"~~~ let xs = [1, 2, 3, 4, 5, 6]; let mut it = xs.iter(); println(fmt!(\\\"%?\"\n+\"\\\", it.next())); // prints `Some(&1)` println(fmt!(\\\"%?\\\", it.next())); // \"\n+\"prints `Some(&2)` println(fmt!(\\\"%?\\\", it.next_back())); // prints `Some(&6)`\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:306\n+#, no-wrap\n+msgid \"\"\n+\"// prints `5`, `4` and `3`\\n\"\n+\"for it.invert().advance |&x| {\\n\"\n+\"    println(fmt!(\\\"%?\\\", x))\\n\"\n+\"}\\n\"\n+\"~~~\\n\"\n+msgstr \"\"\n+\n+#. type: Plain text\n+#: doc/tutorial-container.md:308\n+msgid \"\"\n+\"The `rev_iter` and `mut_rev_iter` methods on vectors just return an inverted \"\n+\"version of the standard immutable and mutable vector iterators.\"\n+msgstr \"\""}, {"sha": "c43b6652331ff0282cd4efa1867fd67c3ede6b05", "filename": "doc/po/tutorial-ffi.md.pot", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-ffi.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-ffi.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-ffi.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -19,12 +19,12 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n #: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4 doc/tut.md:4\n+#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:875 doc/tutorial-ffi.md:143\n+#: doc/tutorial.md:876 doc/tutorial-ffi.md:143\n msgid \"# Destructors\"\n msgstr \"\"\n "}, {"sha": "5487ab5ebbd8c3d8667ee8952bded2f835b3b4c3", "filename": "doc/po/tutorial-macros.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-macros.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-macros.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-macros.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -19,7 +19,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n #: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4 doc/tut.md:4\n+#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"\"\n "}, {"sha": "43c0f4c0924047ceb87db39f14b16f2ed8e20445", "filename": "doc/po/tutorial-tasks.md.pot", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-tasks.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial-tasks.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial-tasks.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -19,7 +19,7 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n #: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4 doc/tut.md:4\n+#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"\"\n "}, {"sha": "415d5052a0643a849b5d266b7203c8ac7ca81d7f", "filename": "doc/po/tutorial.md.pot", "status": "modified", "additions": 377, "deletions": 379, "changes": 756, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/doc%2Fpo%2Ftutorial.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial.md.pot?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -1,13 +1,13 @@\n # SOME DESCRIPTIVE TITLE\n-# Copyright (C) YEAR Free Software Foundation, Inc.\n-# This file is distributed under the same license as the PACKAGE package.\n+# Copyright (C) YEAR The Rust Project Developers\n+# This file is distributed under the same license as the Rust package.\n # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.\n #\n #, fuzzy\n msgid \"\"\n msgstr \"\"\n-\"Project-Id-Version: PACKAGE VERSION\\n\"\n-\"POT-Creation-Date: 2013-07-07 21:10+0300\\n\"\n+\"Project-Id-Version: Rust 0.8-pre\\n\"\n+\"POT-Creation-Date: 2013-07-17 07:18+0900\\n\"\n \"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\\n\"\n \"Last-Translator: FULL NAME <EMAIL@ADDRESS>\\n\"\n \"Language-Team: LANGUAGE <LL@li.org>\\n\"\n@@ -19,20 +19,20 @@ msgstr \"\"\n #. type: Plain text\n #: doc/rust.md:4 doc/rustpkg.md:4 doc/tutorial.md:4\n #: doc/tutorial-borrowed-ptr.md:4 doc/tutorial-ffi.md:4\n-#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4 doc/tut.md:4\n+#: doc/tutorial-macros.md:4 doc/tutorial-tasks.md:4\n msgid \"# Introduction\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rust.md:1231 doc/tutorial.md:2179\n+#: doc/rust.md:1231 doc/tutorial.md:2177\n msgid \"\"\n \"In type-parameterized functions, methods of the supertrait may be called on \"\n \"values of subtrait-bound type parameters.  Refering to the previous example \"\n \"of `trait Circle : Shape`:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rust.md:1240 doc/tutorial.md:2188\n+#: doc/rust.md:1240 doc/tutorial.md:2186\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -46,12 +46,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/rust.md:1242 doc/tutorial.md:2190\n+#: doc/rust.md:1242 doc/tutorial.md:2188\n msgid \"Likewise, supertrait methods may also be called on trait objects.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2 doc/tut.md:2\n+#: doc/tutorial.md:2\n msgid \"% The Rust Language Tutorial\"\n msgstr \"\"\n \n@@ -961,24 +961,25 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:515\n+#: doc/tutorial.md:516\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n \"# use std::float;\\n\"\n+\"# use std::num::atan;\\n\"\n \"fn angle(vector: (float, float)) -> float {\\n\"\n \"    let pi = float::consts::pi;\\n\"\n \"    match vector {\\n\"\n \"      (0f, y) if y < 0f => 1.5 * pi,\\n\"\n \"      (0f, y) => 0.5 * pi,\\n\"\n-\"      (x, y) => float::atan(y / x)\\n\"\n+\"      (x, y) => atan(y / x)\\n\"\n \"    }\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:521\n+#: doc/tutorial.md:522\n msgid \"\"\n \"A variable name in a pattern matches any value, *and* binds that name to the \"\n \"value of the matched value inside of the arm's action. Thus, `(0f, y)` \"\n@@ -988,7 +989,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:528\n+#: doc/tutorial.md:529\n msgid \"\"\n \"Any `match` arm can have a guard clause (written `if EXPR`), called a \"\n \"*pattern guard*, which is an expression of type `bool` that determines, \"\n@@ -998,7 +999,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:533\n+#: doc/tutorial.md:534\n msgid \"\"\n \"You've already seen simple `let` bindings, but `let` is a little fancier \"\n \"than you've been led to believe. It, too, supports destructuring patterns. \"\n@@ -1007,27 +1008,27 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:538\n+#: doc/tutorial.md:539\n msgid \"\"\n \"~~~~ # fn get_tuple_of_two_ints() -> (int, int) { (1, 1) } let (a, b) = \"\n \"get_tuple_of_two_ints(); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:542\n+#: doc/tutorial.md:543\n msgid \"\"\n \"Let bindings only work with _irrefutable_ patterns: that is, patterns that \"\n \"can never fail to match. This excludes `let` from matching literals and most \"\n \"`enum` variants.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:544\n+#: doc/tutorial.md:545\n msgid \"## Loops\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:549\n+#: doc/tutorial.md:550\n msgid \"\"\n \"`while` denotes a loop that iterates as long as its given condition (which \"\n \"must have type `bool`) evaluates to `true`. Inside a loop, the keyword \"\n@@ -1036,7 +1037,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:556\n+#: doc/tutorial.md:557\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1048,14 +1049,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:558\n+#: doc/tutorial.md:559\n msgid \"\"\n \"`loop` denotes an infinite loop, and is the preferred way of writing `while \"\n \"true`:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:568\n+#: doc/tutorial.md:569\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1070,14 +1071,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:571\n+#: doc/tutorial.md:572\n msgid \"\"\n \"This code prints out a weird sequence of numbers and stops as soon as it \"\n \"finds one that can be divided by five.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:576\n+#: doc/tutorial.md:577\n msgid \"\"\n \"Rust also has a `for` construct. It's different from C's `for` and it works \"\n \"best when iterating over collections. See the section on [closures]\"\n@@ -1086,17 +1087,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:578\n+#: doc/tutorial.md:579\n msgid \"# Data structures\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:580\n+#: doc/tutorial.md:581\n msgid \"## Structs\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:585\n+#: doc/tutorial.md:586\n msgid \"\"\n \"Rust struct types must be declared before they are used using the `struct` \"\n \"syntax: `struct Name { field1: T1, field2: T2 [, ...] }`, where `T1`, \"\n@@ -1105,15 +1106,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:589\n+#: doc/tutorial.md:590\n msgid \"\"\n \"Structs are quite similar to C structs and are even laid out the same way in \"\n \"memory (so you can read from a Rust struct in C, and vice-versa). Use the \"\n \"dot operator to access struct fields, as in `mypoint.x`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:596\n+#: doc/tutorial.md:597\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1125,44 +1126,44 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:600\n+#: doc/tutorial.md:601\n msgid \"\"\n \"Inherited mutability means that any field of a struct may be mutable, if the \"\n \"struct is in a mutable slot (or a field of a struct in a mutable slot, and \"\n \"so forth).\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:604\n+#: doc/tutorial.md:605\n msgid \"\"\n \"With a value (say, `mypoint`) of such a type in a mutable location, you can \"\n \"do `mypoint.y += 1.0`. But in an immutable location, such an assignment to a \"\n \"struct without inherited mutability would result in a type error.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:609\n+#: doc/tutorial.md:610\n msgid \"\"\n \"~~~~ {.xfail-test} # struct Point { x: float, y: float } let mut mypoint = \"\n \"Point { x: 1.0, y: 1.0 }; let origin = Point { x: 0.0, y: 0.0 };\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:613\n+#: doc/tutorial.md:614\n msgid \"\"\n \"mypoint.y += 1.0; // mypoint is mutable, and its fields as well origin.y += \"\n \"1.0; // ERROR: assigning to immutable field ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:616\n+#: doc/tutorial.md:617\n msgid \"\"\n \"`match` patterns destructure structs. The basic syntax is `Name { fieldname: \"\n \"pattern, ... }`:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:625\n+#: doc/tutorial.md:626\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1176,7 +1177,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:632\n+#: doc/tutorial.md:633\n msgid \"\"\n \"In general, the field names of a struct do not have to appear in the same \"\n \"order they appear in the type. When you are not interested in all the fields \"\n@@ -1187,7 +1188,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:640\n+#: doc/tutorial.md:641\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -1200,19 +1201,19 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:642\n+#: doc/tutorial.md:643\n msgid \"## Enums\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:645\n+#: doc/tutorial.md:646\n msgid \"\"\n \"Enums are datatypes that have several alternate representations. For \"\n \"example, consider the type shown earlier:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:653\n+#: doc/tutorial.md:654\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1225,7 +1226,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:659\n+#: doc/tutorial.md:660\n msgid \"\"\n \"A value of this type is either a `Circle`, in which case it contains a \"\n \"`Point` struct and a float, or a `Rectangle`, in which case it contains two \"\n@@ -1235,7 +1236,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:665\n+#: doc/tutorial.md:666\n msgid \"\"\n \"The above declaration will define a type `Shape` that can refer to such \"\n \"shapes, and two functions, `Circle` and `Rectangle`, which can be used to \"\n@@ -1244,14 +1245,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:668\n+#: doc/tutorial.md:669\n msgid \"\"\n \"Enum variants need not have parameters. This `enum` declaration, for \"\n \"example, is equivalent to a C enum:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:677\n+#: doc/tutorial.md:678\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1265,22 +1266,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:680\n+#: doc/tutorial.md:681\n msgid \"\"\n \"This declaration defines `North`, `East`, `South`, and `West` as constants, \"\n \"all of which have type `Direction`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:684\n+#: doc/tutorial.md:685\n msgid \"\"\n \"When an enum is C-like (that is, when none of the variants have parameters), \"\n \"it is possible to explicitly set the discriminator values to a constant \"\n \"value:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:692\n+#: doc/tutorial.md:693\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1293,7 +1294,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:697\n+#: doc/tutorial.md:698\n msgid \"\"\n \"If an explicit discriminator is not specified for a variant, the value \"\n \"defaults to the value of the previous variant plus one. If the first variant \"\n@@ -1302,22 +1303,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:700\n+#: doc/tutorial.md:701\n msgid \"\"\n \"When an enum is C-like, you can apply the `as` cast operator to convert it \"\n \"to its discriminator value as an `int`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:704\n+#: doc/tutorial.md:705\n msgid \"\"\n \"For enum types with multiple variants, destructuring is the only way to get \"\n \"at their contents. All variant constructors can be used as patterns, as in \"\n \"this definition of `area`:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:716\n+#: doc/tutorial.md:717\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1334,15 +1335,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:721\n+#: doc/tutorial.md:722\n msgid \"\"\n \"You can write a lone `_` to ignore an individual field, and can ignore all \"\n \"fields of a variant like: `Circle(*)`. As in their introduction form, \"\n \"nullary enum patterns are written without parentheses.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:734\n+#: doc/tutorial.md:735\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1360,12 +1361,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:736\n+#: doc/tutorial.md:737\n msgid \"Enum variants may also be structs. For example:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:754\n+#: doc/tutorial.md:755\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1388,12 +1389,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:756\n+#: doc/tutorial.md:757\n msgid \"## Tuples\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:761\n+#: doc/tutorial.md:762\n msgid \"\"\n \"Tuples in Rust behave exactly like structs, except that their fields do not \"\n \"have names. Thus, you cannot access their fields with dot notation.  Tuples \"\n@@ -1402,7 +1403,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:768\n+#: doc/tutorial.md:769\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1414,12 +1415,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:770\n+#: doc/tutorial.md:771\n msgid \"## Tuple structs\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:775\n+#: doc/tutorial.md:776\n msgid \"\"\n \"Rust also has _tuple structs_, which behave like both structs and tuples, \"\n \"except that, unlike tuples, tuple structs have names (so `Foo(1, 2)` has a \"\n@@ -1428,7 +1429,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:784\n+#: doc/tutorial.md:785\n #, no-wrap\n msgid \"\"\n \"For example:\\n\"\n@@ -1442,12 +1443,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:786\n+#: doc/tutorial.md:787\n msgid \"<a name=\\\"newtype\\\"></a>\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:791\n+#: doc/tutorial.md:792\n msgid \"\"\n \"There is a special case for tuple structs with a single field, which are \"\n \"sometimes called \\\"newtypes\\\" (after Haskell's \\\"newtype\\\" feature). These \"\n@@ -1456,50 +1457,50 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:795\n+#: doc/tutorial.md:796\n msgid \"~~~~ struct GizmoId(int); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:798\n+#: doc/tutorial.md:799\n msgid \"\"\n \"For convenience, you can extract the contents of such a struct with the \"\n \"dereference (`*`) unary operator:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:804\n+#: doc/tutorial.md:805\n msgid \"\"\n \"~~~~ # struct GizmoId(int); let my_gizmo_id: GizmoId = GizmoId(10); let \"\n \"id_int: int = *my_gizmo_id; ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:807\n+#: doc/tutorial.md:808\n msgid \"\"\n \"Types like this can be useful to differentiate between data that have the \"\n \"same type but must be used in different ways.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:812\n+#: doc/tutorial.md:813\n msgid \"~~~~ struct Inches(int); struct Centimeters(int); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:815\n+#: doc/tutorial.md:816\n msgid \"\"\n \"The above definitions allow for a simple way for programs to avoid confusing \"\n \"numbers that correspond to different units.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:817\n+#: doc/tutorial.md:818\n msgid \"# Functions\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:825\n+#: doc/tutorial.md:826\n msgid \"\"\n \"We've already seen several function definitions. Like all other static \"\n \"declarations, such as `type`, functions can be declared both at the top \"\n@@ -1511,7 +1512,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:831\n+#: doc/tutorial.md:832\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1522,15 +1523,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:836\n+#: doc/tutorial.md:837\n msgid \"\"\n \"The `return` keyword immediately returns from the body of a function. It is \"\n \"optionally followed by an expression to return. A function can also return a \"\n \"value by having its top-level block produce an expression.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:842\n+#: doc/tutorial.md:843\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1541,7 +1542,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:849\n+#: doc/tutorial.md:850\n msgid \"\"\n \"It's better Rust style to write a return value this way instead of writing \"\n \"an explicit `return`. The utility of `return` comes in when returning early \"\n@@ -1551,75 +1552,75 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:852\n+#: doc/tutorial.md:853\n msgid \"~~~~ fn do_nothing_the_hard_way() -> () { return (); }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:855\n+#: doc/tutorial.md:856\n msgid \"fn do_nothing_the_easy_way() { } ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:857\n+#: doc/tutorial.md:858\n msgid \"\"\n \"Ending the function with a semicolon like so is equivalent to returning `()`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:861\n+#: doc/tutorial.md:862\n msgid \"\"\n \"~~~~ fn line(a: int, b: int, x: int) -> int { a * x + b } fn oops(a: int, b: \"\n \"int, x: int) -> ()  { a * x + b; }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:865\n+#: doc/tutorial.md:866\n msgid \"assert!(8 == line(5, 3, 1)); assert!(() == oops(5, 3, 1)); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:869\n+#: doc/tutorial.md:870\n msgid \"\"\n \"As with `match` expressions and `let` bindings, function arguments support \"\n \"pattern destructuring. Like `let`, argument patterns must be irrefutable, as \"\n \"in this example that unpacks the first value from a tuple and returns it.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:873\n+#: doc/tutorial.md:874\n msgid \"~~~ fn first((value, _): (int, float)) -> int { value } ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:875 doc/tutorial-ffi.md:143\n+#: doc/tutorial.md:876 doc/tutorial-ffi.md:143\n msgid \"# Destructors\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:879\n+#: doc/tutorial.md:880\n msgid \"\"\n \"A *destructor* is a function responsible for cleaning up the resources used \"\n \"by an object when it is no longer accessible. Destructors can be defined to \"\n \"handle the release of resources like files, sockets and heap memory.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:883\n+#: doc/tutorial.md:884\n msgid \"\"\n \"Objects are never accessible after their destructor has been called, so \"\n \"there are no dynamic failures from accessing freed resources. When a task \"\n \"fails, the destructors of all objects in the task are called.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:885\n+#: doc/tutorial.md:886\n msgid \"\"\n \"The `~` sigil represents a unique handle for a memory allocation on the heap:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:893\n+#: doc/tutorial.md:894\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1632,20 +1633,20 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:897\n+#: doc/tutorial.md:898\n msgid \"\"\n \"Rust includes syntax for heap memory allocation in the language since it's \"\n \"commonly used, but the same semantics can be implemented by a type with a \"\n \"custom destructor.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:899\n+#: doc/tutorial.md:900\n msgid \"# Ownership\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:904\n+#: doc/tutorial.md:905\n msgid \"\"\n \"Rust formalizes the concept of object ownership to delegate management of an \"\n \"object's lifetime to either a variable or a task-local garbage collector. An \"\n@@ -1655,7 +1656,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:910\n+#: doc/tutorial.md:911\n msgid \"\"\n \"Ownership is recursive, so mutability is inherited recursively and a \"\n \"destructor destroys the contained tree of owned objects. Variables are top-\"\n@@ -1665,14 +1666,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:914\n+#: doc/tutorial.md:915\n msgid \"\"\n \"~~~~ // the struct owns the objects contained in the `x` and `y` fields \"\n \"struct Foo { x: int, y: ~int }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:921\n+#: doc/tutorial.md:922\n #, no-wrap\n msgid \"\"\n \"{\\n\"\n@@ -1684,14 +1685,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:926\n+#: doc/tutorial.md:927\n msgid \"\"\n \"// `b` is mutable, and the mutability is inherited by the objects it owns \"\n \"let mut b = Foo { x: 5, y: ~10 }; b.x = 10; ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:932\n+#: doc/tutorial.md:933\n msgid \"\"\n \"If an object doesn't contain garbage-collected boxes, it consists of a \"\n \"single ownership tree and is given the `Owned` trait which allows it to be \"\n@@ -1701,12 +1702,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:934\n+#: doc/tutorial.md:935\n msgid \"# Boxes\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:941\n+#: doc/tutorial.md:942\n msgid \"\"\n \"Many modern languages represent values as pointers to heap memory by \"\n \"default. In contrast, Rust, like C and C++, represents such types directly.  \"\n@@ -1717,7 +1718,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:946\n+#: doc/tutorial.md:947\n msgid \"\"\n \"For small structs like `Point`, this is usually more efficient than \"\n \"allocating memory and indirecting through a pointer. But for big structs, or \"\n@@ -1726,31 +1727,31 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:948\n+#: doc/tutorial.md:949\n msgid \"## Owned boxes\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:951\n+#: doc/tutorial.md:952\n msgid \"\"\n \"An owned box (`~`) is a uniquely owned allocation on the heap. It inherits \"\n \"the mutability and lifetime of the owner as it would if there was no box:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:956\n+#: doc/tutorial.md:957\n msgid \"~~~~ let x = 5; // immutable let mut y = 5; // mutable y += 2;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:961\n+#: doc/tutorial.md:962\n msgid \"\"\n \"let x = ~5; // immutable let mut y = ~5; // mutable *y += 2; // the * \"\n \"operator is needed to access the contained value ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:966\n+#: doc/tutorial.md:967\n msgid \"\"\n \"The purpose of an owned box is to add a layer of indirection in order to \"\n \"create recursive data structures or cheaply pass around an object larger \"\n@@ -1759,14 +1760,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:969\n+#: doc/tutorial.md:970\n msgid \"\"\n \"The following struct won't compile, because the lack of indirection would \"\n \"mean it has an infinite size:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:975\n+#: doc/tutorial.md:976\n #, no-wrap\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n@@ -1777,23 +1778,23 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:979\n+#: doc/tutorial.md:980\n msgid \"\"\n \"> ***Note:*** The `Option` type is an enum that represents an *optional* \"\n \"value.  > It's comparable to a nullable pointer in many other languages, but \"\n \"stores the > contained value unboxed.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:983\n+#: doc/tutorial.md:984\n msgid \"\"\n \"Adding indirection with an owned pointer allocates the child outside of the \"\n \"struct on the heap, which makes it a finite size and won't result in a \"\n \"compile-time error:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:989\n+#: doc/tutorial.md:990\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1804,12 +1805,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:991\n+#: doc/tutorial.md:992\n msgid \"## Managed boxes\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:999\n+#: doc/tutorial.md:1000\n msgid \"\"\n \"A managed box (`@`) is a heap allocation with the lifetime managed by a task-\"\n \"local garbage collector. It will be destroyed at some point after there are \"\n@@ -1821,29 +1822,29 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1002\n+#: doc/tutorial.md:1003\n msgid \"~~~~ let a = @5; // immutable\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1005\n+#: doc/tutorial.md:1006\n msgid \"let mut b = @5; // mutable variable, immutable box b = @10;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1008\n+#: doc/tutorial.md:1009\n msgid \"let c = @mut 5; // immutable variable, mutable box *c = 10;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1013\n+#: doc/tutorial.md:1014\n msgid \"\"\n \"let mut d = @mut 5; // mutable variable, mutable box *d += 5; d = @mut 15; \"\n \"~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1018\n+#: doc/tutorial.md:1019\n msgid \"\"\n \"A mutable variable and an immutable variable can refer to the same box, \"\n \"given that their types are compatible. Mutability of a box is a property of \"\n@@ -1852,7 +1853,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1022\n+#: doc/tutorial.md:1023\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -1861,15 +1862,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1025\n+#: doc/tutorial.md:1026\n #, no-wrap\n msgid \"\"\n \"let mut c : @int;       // declare a variable with type managed immutable int\\n\"\n \"let mut d : @mut int;   // and one of type managed mutable int\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1029\n+#: doc/tutorial.md:1030\n #, no-wrap\n msgid \"\"\n \"c = a;          // box type is the same, okay\\n\"\n@@ -1878,7 +1879,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1034\n+#: doc/tutorial.md:1035\n #, no-wrap\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n@@ -1888,12 +1889,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1036\n+#: doc/tutorial.md:1037\n msgid \"# Move semantics\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1042\n+#: doc/tutorial.md:1043\n msgid \"\"\n \"Rust uses a shallow copy for parameter passing, assignment and returning \"\n \"values from functions. A shallow copy is considered a move of ownership if \"\n@@ -1903,33 +1904,33 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1048\n+#: doc/tutorial.md:1049\n msgid \"\"\n \"~~~~ let x = ~5; let y = x.clone(); // y is a newly allocated box let z = \"\n \"x; // no new memory allocated, x can no longer be used ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1051\n+#: doc/tutorial.md:1052\n msgid \"\"\n \"Since in owned boxes mutability is a property of the owner, not the box, \"\n \"mutable boxes may become immutable when they are moved, and vice-versa.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1058\n+#: doc/tutorial.md:1059\n msgid \"\"\n \"~~~~ let r = ~13; let mut s = r; // box becomes mutable *s += 1; let t = \"\n \"s; // box becomes immutable ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1060\n+#: doc/tutorial.md:1061\n msgid \"# Borrowed pointers\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1066\n+#: doc/tutorial.md:1067\n msgid \"\"\n \"Rust's borrowed pointers are a general purpose reference type. In contrast \"\n \"with owned boxes, where the holder of an owned box is the owner of the \"\n@@ -1939,12 +1940,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1068\n+#: doc/tutorial.md:1069\n msgid \"As an example, consider a simple struct type, `Point`:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1075\n+#: doc/tutorial.md:1076\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -1956,15 +1957,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1079\n+#: doc/tutorial.md:1080\n msgid \"\"\n \"We can use this simple definition to allocate points in many different ways. \"\n \"For example, in this code, each of these three local variables contains a \"\n \"point, but allocated in a different location:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1086\n+#: doc/tutorial.md:1087\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -1976,7 +1977,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1098\n+#: doc/tutorial.md:1099\n msgid \"\"\n \"Suppose we want to write a procedure that computes the distance between any \"\n \"two points, no matter where they are stored. For example, we might like to \"\n@@ -1991,7 +1992,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1108\n+#: doc/tutorial.md:1109\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2006,12 +2007,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1110 doc/tutorial-borrowed-ptr.md:72\n+#: doc/tutorial.md:1111 doc/tutorial-borrowed-ptr.md:72\n msgid \"Now we can call `compute_distance()` in various ways:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1120\n+#: doc/tutorial.md:1121\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2026,7 +2027,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1127\n+#: doc/tutorial.md:1128\n msgid \"\"\n \"Here the `&` operator is used to take the address of the variable \"\n \"`on_the_stack`; this is because `on_the_stack` has the type `Point` (that \"\n@@ -2036,7 +2037,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1133\n+#: doc/tutorial.md:1134\n msgid \"\"\n \"In the case of the boxes `managed_box` and `owned_box`, however, no explicit \"\n \"action is necessary. The compiler will automatically convert a box like \"\n@@ -2046,7 +2047,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1142\n+#: doc/tutorial.md:1143\n msgid \"\"\n \"Whenever a value is borrowed, there are some limitations on what you can do \"\n \"with the original. For example, if the contents of a variable have been lent \"\n@@ -2058,31 +2059,31 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1145\n+#: doc/tutorial.md:1146\n msgid \"\"\n \"For a more in-depth explanation of borrowed pointers, read the [borrowed \"\n \"pointer tutorial][borrowtut].\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1147\n+#: doc/tutorial.md:1148\n msgid \"[borrowtut]: tutorial-borrowed-ptr.html\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1149\n+#: doc/tutorial.md:1150\n msgid \"## Freezing\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1152\n+#: doc/tutorial.md:1153\n msgid \"\"\n \"Borrowing an immutable pointer to an object freezes it and prevents \"\n \"mutation.  `Owned` objects have freezing enforced statically at compile-time.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1160\n+#: doc/tutorial.md:1161\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2095,15 +2096,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1164\n+#: doc/tutorial.md:1165\n msgid \"\"\n \"Mutable managed boxes handle freezing dynamically when any of their contents \"\n \"are borrowed, and the task will fail if an attempt to modify them is made \"\n \"while they are frozen:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1174\n+#: doc/tutorial.md:1175\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2118,47 +2119,47 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1176\n+#: doc/tutorial.md:1177\n msgid \"# Dereferencing pointers\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1179\n+#: doc/tutorial.md:1180\n msgid \"\"\n \"Rust uses the unary star operator (`*`) to access the contents of a box or \"\n \"pointer, similarly to C.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1184\n+#: doc/tutorial.md:1185\n msgid \"~~~ let managed = @10; let owned = ~20; let borrowed = &30;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1187\n+#: doc/tutorial.md:1188\n msgid \"let sum = *managed + *owned + *borrowed; ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1191\n+#: doc/tutorial.md:1192\n msgid \"\"\n \"Dereferenced mutable pointers may appear on the left hand side of \"\n \"assignments. Such an assignment modifies the value that the pointer points \"\n \"to.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1195\n+#: doc/tutorial.md:1196\n msgid \"~~~ let managed = @mut 10; let mut owned = ~20;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1198\n+#: doc/tutorial.md:1199\n msgid \"let mut value = 30; let borrowed = &mut value;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1203\n+#: doc/tutorial.md:1204\n #, no-wrap\n msgid \"\"\n \"*managed = *owned + 10;\\n\"\n@@ -2168,15 +2169,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1207\n+#: doc/tutorial.md:1208\n msgid \"\"\n \"Pointers have high operator precedence, but lower precedence than the dot \"\n \"operator used for field and method access. This precedence order can \"\n \"sometimes make code awkward and parenthesis-filled.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1217\n+#: doc/tutorial.md:1218\n msgid \"\"\n \"~~~ # struct Point { x: float, y: float } # enum Shape { Rectangle(Point, \"\n \"Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point \"\n@@ -2185,15 +2186,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1221\n+#: doc/tutorial.md:1222\n msgid \"\"\n \"To combat this ugliness the dot operator applies _automatic pointer \"\n \"dereferencing_ to the receiver (the value on the left-hand side of the dot), \"\n \"so in most cases, explicitly dereferencing the receiver is not necessary.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1231\n+#: doc/tutorial.md:1232\n msgid \"\"\n \"~~~ # struct Point { x: float, y: float } # enum Shape { Rectangle(Point, \"\n \"Point) } # impl Shape { fn area(&self) -> int { 0 } } let start = @Point \"\n@@ -2202,32 +2203,32 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1235\n+#: doc/tutorial.md:1236\n msgid \"\"\n \"You can write an expression that dereferences any number of pointers \"\n \"automatically. For example, if you feel inclined, you could write something \"\n \"silly like\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1241\n+#: doc/tutorial.md:1242\n msgid \"\"\n \"~~~ # struct Point { x: float, y: float } let point = &@~Point { x: 10f, y: \"\n \"20f }; println(fmt!(\\\"%f\\\", point.x)); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1243\n+#: doc/tutorial.md:1244\n msgid \"The indexing operator (`[]`) also auto-dereferences.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1245\n+#: doc/tutorial.md:1246\n msgid \"# Vectors and strings\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1250\n+#: doc/tutorial.md:1251\n msgid \"\"\n \"A vector is a contiguous section of memory containing zero or more values of \"\n \"the same type. Like other types in Rust, vectors can be stored on the stack, \"\n@@ -2236,7 +2237,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1260\n+#: doc/tutorial.md:1261\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2251,33 +2252,33 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1263\n+#: doc/tutorial.md:1264\n msgid \"\"\n \"// A borrowed pointer to stack-allocated vector let stack_crayons: &[Crayon] \"\n \"= &[Aquamarine, Asparagus, AtomicTangerine];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1266\n+#: doc/tutorial.md:1267\n msgid \"\"\n \"// A local heap (managed) vector of crayons let local_crayons: @[Crayon] = \"\n \"@[BananaMania, Beaver, Bittersweet];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1270\n+#: doc/tutorial.md:1271\n msgid \"\"\n \"// An exchange heap (owned) vector of crayons let exchange_crayons: \"\n \"~[Crayon] = ~[Black, BlizzardBlue, Blue]; ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1272\n+#: doc/tutorial.md:1273\n msgid \"The `+` operator means concatenation when applied to vector types.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1277\n+#: doc/tutorial.md:1278\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2287,41 +2288,41 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1280\n+#: doc/tutorial.md:1281\n msgid \"\"\n \"let my_crayons = ~[Almond, AntiqueBrass, Apricot]; let your_crayons = \"\n \"~[BananaMania, Beaver, Bittersweet];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1283\n+#: doc/tutorial.md:1284\n msgid \"\"\n \"// Add two vectors to create a new one let our_crayons = my_crayons + \"\n \"your_crayons;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1288\n+#: doc/tutorial.md:1289\n msgid \"\"\n \"// .push_all() will append to a vector, provided it lives in a mutable slot \"\n \"let mut my_crayons = my_crayons; my_crayons.push_all(your_crayons); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1293\n+#: doc/tutorial.md:1294\n msgid \"\"\n \"> ***Note:*** The above examples of vector addition use owned > vectors. \"\n \"Some operations on slices and stack vectors are > not yet well-supported. \"\n \"Owned vectors are often the most > usable.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1295\n+#: doc/tutorial.md:1296\n msgid \"Square brackets denote indexing into a vector:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1307\n+#: doc/tutorial.md:1308\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2338,12 +2339,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1309\n+#: doc/tutorial.md:1310\n msgid \"A vector can be destructured using pattern matching:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1319\n+#: doc/tutorial.md:1320\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2358,15 +2359,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1323\n+#: doc/tutorial.md:1324\n msgid \"\"\n \"The elements of a vector _inherit the mutability of the vector_, and as \"\n \"such, individual elements may not be reassigned when the vector lives in an \"\n \"immutable slot.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1329\n+#: doc/tutorial.md:1330\n #, no-wrap\n msgid \"\"\n \"~~~ {.xfail-test}\\n\"\n@@ -2377,17 +2378,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1332\n+#: doc/tutorial.md:1333\n msgid \"crayons[0] = Apricot; // ERROR: Can't assign to immutable vector ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1334\n+#: doc/tutorial.md:1335\n msgid \"Moving it into a mutable slot makes the elements assignable.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1340\n+#: doc/tutorial.md:1341\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2398,25 +2399,25 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1343\n+#: doc/tutorial.md:1344\n msgid \"\"\n \"// Put the vector into a mutable slot let mut mutable_crayons = crayons;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1347\n+#: doc/tutorial.md:1348\n msgid \"// Now it's mutable to the bone mutable_crayons[0] = Apricot; ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1350\n+#: doc/tutorial.md:1351\n msgid \"\"\n \"This is a simple example of Rust's _dual-mode data structures_, also \"\n \"referred to as _freezing and thawing_.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1358\n+#: doc/tutorial.md:1359\n msgid \"\"\n \"Strings are implemented with vectors of `u8`, though they have a distinct \"\n \"type. They support most of the same allocation options as vectors, though \"\n@@ -2427,47 +2428,47 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1362\n+#: doc/tutorial.md:1363\n msgid \"\"\n \"~~~ // A plain string is a slice to read-only (static) memory let \"\n \"stack_crayons: &str = \\\"Almond, AntiqueBrass, Apricot\\\";\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1365\n+#: doc/tutorial.md:1366\n msgid \"\"\n \"// The same thing, but with the `&` let stack_crayons: &str = &\\\"Aquamarine, \"\n \"Asparagus, AtomicTangerine\\\";\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1368\n+#: doc/tutorial.md:1369\n msgid \"\"\n \"// A local heap (managed) string let local_crayons: @str = @\\\"BananaMania, \"\n \"Beaver, Bittersweet\\\";\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1372\n+#: doc/tutorial.md:1373\n msgid \"\"\n \"// An exchange heap (owned) string let exchange_crayons: ~str = ~\\\"Black, \"\n \"BlizzardBlue, Blue\\\"; ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1376\n+#: doc/tutorial.md:1377\n msgid \"\"\n \"Both vectors and strings support a number of useful [methods](#functions-and-\"\n \"methods), defined in [`std::vec`] and [`std::str`]. Here are some examples.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1379\n+#: doc/tutorial.md:1380\n msgid \"[`std::vec`]: std/vec.html [`std::str`]: std/str.html\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1390\n+#: doc/tutorial.md:1391\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2483,19 +2484,19 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1392\n+#: doc/tutorial.md:1393\n msgid \"let crayons = [Almond, AntiqueBrass, Apricot];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1396\n+#: doc/tutorial.md:1397\n msgid \"\"\n \"// Check the length of the vector assert!(crayons.len() == 3); assert!(!\"\n \"crayons.is_empty());\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1403\n+#: doc/tutorial.md:1404\n #, no-wrap\n msgid \"\"\n \"// Iterate over a vector, obtaining a pointer to each element\\n\"\n@@ -2507,21 +2508,21 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1407\n+#: doc/tutorial.md:1408\n msgid \"\"\n \"// Map vector elements let crayon_names = crayons.map(|v| \"\n \"crayon_to_str(*v)); let favorite_crayon_name = crayon_names[0];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1410\n+#: doc/tutorial.md:1411\n msgid \"\"\n \"// Remove whitespace from before and after the string let \"\n \"new_favorite_crayon_name = favorite_crayon_name.trim();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1416\n+#: doc/tutorial.md:1417\n #, no-wrap\n msgid \"\"\n \"if favorite_crayon_name.len() > 5 {\\n\"\n@@ -2532,12 +2533,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1418\n+#: doc/tutorial.md:1419\n msgid \"# Closures\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1423\n+#: doc/tutorial.md:1424\n msgid \"\"\n \"Named functions, like those we've seen so far, may not refer to local \"\n \"variables declared outside the function: they do not close over their \"\n@@ -2546,12 +2547,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1426\n+#: doc/tutorial.md:1427\n msgid \"~~~~ {.ignore} let foo = 10;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1431\n+#: doc/tutorial.md:1432\n #, no-wrap\n msgid \"\"\n \"fn bar() -> int {\\n\"\n@@ -2561,31 +2562,31 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1434\n+#: doc/tutorial.md:1435\n msgid \"\"\n \"Rust also supports _closures_, functions that can access variables in the \"\n \"enclosing scope.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1437\n+#: doc/tutorial.md:1438\n msgid \"~~~~ fn call_closure_with_ten(b: &fn(int)) { b(10); }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1440\n+#: doc/tutorial.md:1441\n msgid \"\"\n \"let captured_var = 20; let closure = |arg| println(fmt!(\\\"captured_var=%d, \"\n \"arg=%d\\\", captured_var, arg));\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1443\n+#: doc/tutorial.md:1444\n msgid \"call_closure_with_ten(closure); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1449\n+#: doc/tutorial.md:1450\n msgid \"\"\n \"Closures begin with the argument list between vertical bars and are followed \"\n \"by a single expression. Remember that a block, `{ <expr1>; <expr2>; ... }`, \"\n@@ -2595,7 +2596,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1454\n+#: doc/tutorial.md:1455\n msgid \"\"\n \"The types of the arguments are generally omitted, as is the return type, \"\n \"because the compiler can almost always infer them. In the rare case where \"\n@@ -2604,25 +2605,25 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1458\n+#: doc/tutorial.md:1459\n msgid \"~~~~ let square = |x: int| -> uint { x * x as uint }; ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1462\n+#: doc/tutorial.md:1463\n msgid \"\"\n \"There are several forms of closure, each with its own role. The most common, \"\n \"called a _stack closure_, has type `&fn` and can directly access local \"\n \"variables in the enclosing scope.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1467\n+#: doc/tutorial.md:1468\n msgid \"~~~~ let mut max = 0; [1, 2, 3].map(|x| if *x > max { max = *x }); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1476\n+#: doc/tutorial.md:1477\n msgid \"\"\n \"Stack closures are very efficient because their environment is allocated on \"\n \"the call stack and refers by pointer to captured locals. To ensure that \"\n@@ -2634,12 +2635,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1478\n+#: doc/tutorial.md:1479\n msgid \"## Managed closures\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1484\n+#: doc/tutorial.md:1485\n msgid \"\"\n \"When you need to store a closure in a data structure, a stack closure will \"\n \"not do, since the compiler will refuse to let you store it. For this \"\n@@ -2649,7 +2650,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1489\n+#: doc/tutorial.md:1490\n msgid \"\"\n \"A managed closure does not directly access its environment, but merely \"\n \"copies out the values that it closes over into a private data structure. \"\n@@ -2658,14 +2659,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1492\n+#: doc/tutorial.md:1493\n msgid \"\"\n \"This code creates a closure that adds a given string to its argument, \"\n \"returns it from a function, and then calls it:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1498\n+#: doc/tutorial.md:1499\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2676,7 +2677,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1504\n+#: doc/tutorial.md:1505\n #, no-wrap\n msgid \"\"\n \"fn main() {\\n\"\n@@ -2687,12 +2688,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1506\n+#: doc/tutorial.md:1507\n msgid \"## Owned closures\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1513\n+#: doc/tutorial.md:1514\n msgid \"\"\n \"Owned closures, written `~fn` in analogy to the `~` pointer type, hold on to \"\n \"things that can safely be sent between processes. They copy the values they \"\n@@ -2702,17 +2703,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1515\n+#: doc/tutorial.md:1516\n msgid \"[tasks]: tutorial-tasks.html\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1517\n+#: doc/tutorial.md:1518\n msgid \"## Closure compatibility\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1524\n+#: doc/tutorial.md:1525\n msgid \"\"\n \"Rust closures have a convenient subtyping property: you can pass any kind of \"\n \"closure (as long as the arguments and return types match) to functions that \"\n@@ -2723,42 +2724,42 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1532\n+#: doc/tutorial.md:1533\n msgid \"\"\n \"~~~~ fn call_twice(f: &fn()) { f(); f(); } let closure = || { \\\"I'm a \"\n \"closure, and it doesn't matter what type I am\\\"; }; fn function() { \\\"I'm a \"\n \"normal function\\\"; } call_twice(closure); call_twice(function); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1536\n+#: doc/tutorial.md:1537\n msgid \"\"\n \"> ***Note:*** Both the syntax and the semantics will be changing > in small \"\n \"ways. At the moment they can be unsound in some > scenarios, particularly \"\n \"with non-copyable types.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1538\n+#: doc/tutorial.md:1539\n msgid \"## Do syntax\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1541\n+#: doc/tutorial.md:1542\n msgid \"\"\n \"The `do` expression provides a way to treat higher-order functions \"\n \"(functions that take closures as arguments) as control structures.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1544\n+#: doc/tutorial.md:1545\n msgid \"\"\n \"Consider this function that iterates over a vector of integers, passing in a \"\n \"pointer to each integer in the vector:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1554\n+#: doc/tutorial.md:1555\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2773,14 +2774,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1558\n+#: doc/tutorial.md:1559\n msgid \"\"\n \"As a caller, if we use a closure to provide the final operator argument, we \"\n \"can write it in a way that has a pleasant, block-like structure.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1566\n+#: doc/tutorial.md:1567\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2793,14 +2794,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1569\n+#: doc/tutorial.md:1570\n msgid \"\"\n \"This is such a useful pattern that Rust has a special form of function call \"\n \"that can be written more like a built-in control structure:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1577\n+#: doc/tutorial.md:1578\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2813,28 +2814,28 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1582\n+#: doc/tutorial.md:1583\n msgid \"\"\n \"The call is prefixed with the keyword `do` and, instead of writing the final \"\n \"closure inside the argument list, it appears outside of the parentheses, \"\n \"where it looks more like a typical block of code.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1587\n+#: doc/tutorial.md:1588\n msgid \"\"\n \"`do` is a convenient way to create tasks with the `task::spawn` function.  \"\n \"`spawn` has the signature `spawn(fn: ~fn())`. In other words, it is a \"\n \"function that takes an owned closure that takes no arguments.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1590\n+#: doc/tutorial.md:1591\n msgid \"~~~~ use std::task::spawn;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1595\n+#: doc/tutorial.md:1596\n #, no-wrap\n msgid \"\"\n \"do spawn() || {\\n\"\n@@ -2844,15 +2845,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1599\n+#: doc/tutorial.md:1600\n msgid \"\"\n \"Look at all those bars and parentheses -- that's two empty argument lists \"\n \"back to back. Since that is so unsightly, empty argument lists may be \"\n \"omitted from `do` expressions.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1606\n+#: doc/tutorial.md:1607\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -2864,7 +2865,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1609\n+#: doc/tutorial.md:1610\n msgid \"\"\n \"If you want to see the output of `debug!` statements, you will need to turn \"\n \"on `debug!` logging.  To enable `debug!` logging, set the RUST_LOG \"\n@@ -2873,12 +2874,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1611\n+#: doc/tutorial.md:1612\n msgid \"# Methods\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1617\n+#: doc/tutorial.md:1618\n msgid \"\"\n \"Methods are like functions except that they always begin with a special \"\n \"argument, called `self`, which has the type of the method's receiver. The \"\n@@ -2887,15 +2888,15 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1621\n+#: doc/tutorial.md:1622\n msgid \"\"\n \"_Implementations_, written with the `impl` keyword, can define methods on \"\n \"most Rust types, including structs and enums.  As an example, let's define a \"\n \"`draw` method on our `Shape` enum.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1629\n+#: doc/tutorial.md:1630\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2908,7 +2909,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1634\n+#: doc/tutorial.md:1635\n #, no-wrap\n msgid \"\"\n \"enum Shape {\\n\"\n@@ -2918,7 +2919,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1643\n+#: doc/tutorial.md:1644\n #, no-wrap\n msgid \"\"\n \"impl Shape {\\n\"\n@@ -2932,20 +2933,20 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1647\n+#: doc/tutorial.md:1648\n msgid \"let s = Circle(Point { x: 1f, y: 2f }, 3f); s.draw(); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1651\n+#: doc/tutorial.md:1652\n msgid \"\"\n \"This defines an _implementation_ for `Shape` containing a single method, \"\n \"`draw`. In most respects the `draw` method is defined like any other \"\n \"function, except for the name `self`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1656\n+#: doc/tutorial.md:1657\n msgid \"\"\n \"The type of `self` is the type on which the method is implemented, or a \"\n \"pointer thereof. As an argument it is written either `self`, `&self`, \"\n@@ -2954,7 +2955,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1671\n+#: doc/tutorial.md:1672\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -2974,26 +2975,26 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1673\n+#: doc/tutorial.md:1674\n msgid \"let s = Circle(Point { x: 1f, y: 2f }, 3f);\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1679\n+#: doc/tutorial.md:1680\n msgid \"\"\n \"(@s).draw_managed(); (~s).draw_owned(); (&s).draw_borrowed(); s.\"\n \"draw_value(); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1683\n+#: doc/tutorial.md:1684\n msgid \"\"\n \"Methods typically take a borrowed pointer self type, so the compiler will go \"\n \"to great lengths to convert a callee to a borrowed pointer.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1701\n+#: doc/tutorial.md:1702\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -3016,37 +3017,37 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1704\n+#: doc/tutorial.md:1705\n msgid \"(@s).draw_borrowed(); (~s).draw_borrowed();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1708\n+#: doc/tutorial.md:1709\n msgid \"\"\n \"// Unlike typical function arguments, the self value will // automatically \"\n \"be referenced ...  s.draw_borrowed();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1711\n+#: doc/tutorial.md:1712\n msgid \"// ... and dereferenced (& &s).draw_borrowed();\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1715\n+#: doc/tutorial.md:1716\n msgid \"// ... and dereferenced and borrowed (&@~s).draw_borrowed(); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1719\n+#: doc/tutorial.md:1720\n msgid \"\"\n \"Implementations may also define standalone (sometimes called \\\"static\\\")  \"\n \"methods. The absence of a `self` parameter distinguishes such methods.  \"\n \"These methods are the preferred way to define constructor functions.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1726\n+#: doc/tutorial.md:1727\n #, no-wrap\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n@@ -3058,7 +3059,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:1728\n+#: doc/tutorial.md:1729\n msgid \"\"\n \"To call such a method, just prefix it with the type name and a double colon:\"\n msgstr \"\"\n@@ -3069,10 +3070,9 @@ msgstr \"\"\n msgid \"\"\n \"~~~~\\n\"\n \"# use std::float::consts::pi;\\n\"\n-\"# use std::float::sqrt;\\n\"\n \"struct Circle { radius: float }\\n\"\n \"impl Circle {\\n\"\n-\"    fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\\n\"\n+\"    fn new(area: float) -> Circle { Circle { radius: (area / pi).sqrt() } }\\n\"\n \"}\\n\"\n \"let c = Circle::new(42.5);\\n\"\n \"~~~~\\n\"\n@@ -3525,47 +3525,46 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2004\n+#: doc/tutorial.md:2003\n msgid \"\"\n-\"~~~~ # use std::float::consts::pi; # use std::float::sqrt; trait Shape { fn \"\n-\"new(area: float) -> Self; } struct Circle { radius: float } struct Square \"\n-\"{ length: float }\"\n+\"~~~~ # use std::float::consts::pi; trait Shape { fn new(area: float) -> \"\n+\"Self; } struct Circle { radius: float } struct Square { length: float }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2011\n+#: doc/tutorial.md:2010\n #, no-wrap\n msgid \"\"\n \"impl Shape for Circle {\\n\"\n-\"    fn new(area: float) -> Circle { Circle { radius: sqrt(area / pi) } }\\n\"\n+\"    fn new(area: float) -> Circle { Circle { radius: (area / pi).sqrt() } }\\n\"\n \"}\\n\"\n \"impl Shape for Square {\\n\"\n-\"    fn new(area: float) -> Square { Square { length: sqrt(area) } }\\n\"\n+\"    fn new(area: float) -> Square { Square { length: (area).sqrt() } }\\n\"\n \"}\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2016\n+#: doc/tutorial.md:2015\n msgid \"\"\n \"let area = 42.5; let c: Circle = Shape::new(area); let s: Square = Shape::\"\n \"new(area); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2018\n+#: doc/tutorial.md:2017\n msgid \"## Bounded type parameters and static method dispatch\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2023\n+#: doc/tutorial.md:2022\n msgid \"\"\n \"Traits give us a language for defining predicates on types, or abstract \"\n \"properties that types can have. We can use this language to define _bounds_ \"\n \"on type parameters, so that we can then operate on generic types.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2032\n+#: doc/tutorial.md:2031\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -3579,7 +3578,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2038\n+#: doc/tutorial.md:2037\n msgid \"\"\n \"Declaring `T` as conforming to the `Printable` trait (as we earlier did with \"\n \"`Copy`) makes it possible to call methods from that trait on values of type \"\n@@ -3589,14 +3588,14 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2041\n+#: doc/tutorial.md:2040\n msgid \"\"\n \"Type parameters can have multiple bounds by separating them with `+`, as in \"\n \"this version of `print_all` that copies elements.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2053\n+#: doc/tutorial.md:2052\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -3613,41 +3612,41 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2057\n+#: doc/tutorial.md:2056\n msgid \"\"\n \"Method calls to bounded type parameters are _statically dispatched_, \"\n \"imposing no more overhead than normal function invocation, so are the \"\n \"preferred way to use traits polymorphically.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2059\n+#: doc/tutorial.md:2058\n msgid \"This usage of traits is similar to Haskell type classes.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2061\n+#: doc/tutorial.md:2060\n msgid \"## Trait objects and dynamic method dispatch\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2065\n+#: doc/tutorial.md:2064\n msgid \"\"\n \"The above allows us to define functions that polymorphically act on values \"\n \"of a single unknown type that conforms to a given trait.  However, consider \"\n \"this function:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2071\n+#: doc/tutorial.md:2070\n msgid \"\"\n \"~~~~ # type Circle = int; type Rectangle = int; # impl Drawable for int { fn \"\n \"draw(&self) {} } # fn new_circle() -> int { 1 } trait Drawable { fn \"\n \"draw(&self); }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2078\n+#: doc/tutorial.md:2077\n #, no-wrap\n msgid \"\"\n \"fn draw_all<T: Drawable>(shapes: ~[T]) {\\n\"\n@@ -3659,7 +3658,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2084\n+#: doc/tutorial.md:2083\n msgid \"\"\n \"You can call that on an array of circles, or an array of rectangles \"\n \"(assuming those have suitable `Drawable` traits defined), but not on an \"\n@@ -3668,7 +3667,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2091\n+#: doc/tutorial.md:2090\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -3680,7 +3679,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2096\n+#: doc/tutorial.md:2095\n msgid \"\"\n \"In this example, there is no type parameter. Instead, the `@Drawable` type \"\n \"denotes any managed box value that implements the `Drawable` trait. To \"\n@@ -3689,29 +3688,29 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2103\n+#: doc/tutorial.md:2102\n msgid \"\"\n \"~~~~ # type Circle = int; type Rectangle = bool; # trait Drawable { fn \"\n \"draw(&self); } # fn new_circle() -> Circle { 1 } # fn new_rectangle() -> \"\n \"Rectangle { true } # fn draw_all(shapes: &[@Drawable]) {}\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2106\n+#: doc/tutorial.md:2105\n msgid \"\"\n \"impl Drawable for Circle { fn draw(&self) { ... } } impl Drawable for \"\n \"Rectangle { fn draw(&self) { ... } }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2111\n+#: doc/tutorial.md:2110\n msgid \"\"\n \"let c: @Circle = @new_circle(); let r: @Rectangle = @new_rectangle(); \"\n \"draw_all([c as @Drawable, r as @Drawable]); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2119\n+#: doc/tutorial.md:2118\n msgid \"\"\n \"We omit the code for `new_circle` and `new_rectangle`; imagine that these \"\n \"just return `Circle`s and `Rectangle`s with a default size. Note that, like \"\n@@ -3722,7 +3721,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2133\n+#: doc/tutorial.md:2132\n msgid \"\"\n \"~~~ # type Circle = int; type Rectangle = int; # trait Drawable { fn \"\n \"draw(&self); } # impl Drawable for int { fn draw(&self) {} } # fn \"\n@@ -3733,7 +3732,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2138\n+#: doc/tutorial.md:2137\n msgid \"\"\n \"Method calls to trait types are _dynamically dispatched_. Since the compiler \"\n \"doesn't know specifically which functions to call at compile time, it uses a \"\n@@ -3742,17 +3741,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2140\n+#: doc/tutorial.md:2139\n msgid \"This usage of traits is similar to Java interfaces.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2142\n+#: doc/tutorial.md:2141\n msgid \"## Trait inheritance\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2147\n+#: doc/tutorial.md:2146\n msgid \"\"\n \"We can write a trait declaration that _inherits_ from other traits, called \"\n \"_supertraits_.  Types that implement a trait must also implement its \"\n@@ -3761,32 +3760,31 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2152\n+#: doc/tutorial.md:2151\n msgid \"\"\n \"~~~~ trait Shape { fn area(&self) -> float; } trait Circle : Shape { fn \"\n \"radius(&self) -> float; } ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2154\n+#: doc/tutorial.md:2153\n msgid \"\"\n \"Now, we can implement `Circle` on a type only if we also implement `Shape`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2170\n+#: doc/tutorial.md:2168\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n \"# use std::float::consts::pi;\\n\"\n-\"# use std::float::sqrt;\\n\"\n \"# trait Shape { fn area(&self) -> float; }\\n\"\n \"# trait Circle : Shape { fn radius(&self) -> float; }\\n\"\n \"# struct Point { x: float, y: float }\\n\"\n \"# fn square(x: float) -> float { x * x }\\n\"\n \"struct CircleStruct { center: Point, radius: float }\\n\"\n \"impl Circle for CircleStruct {\\n\"\n-\"    fn radius(&self) -> float { sqrt(self.area() / pi) }\\n\"\n+\"    fn radius(&self) -> float { (self.area() / pi).sqrt() }\\n\"\n \"}\\n\"\n \"impl Shape for CircleStruct {\\n\"\n \"    fn area(&self) -> float { pi * square(self.radius) }\\n\"\n@@ -3795,7 +3793,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2175\n+#: doc/tutorial.md:2173\n msgid \"\"\n \"Notice that methods of `Circle` can call methods on `Shape`, as our `radius` \"\n \"implementation calls the `area` method.  This is a silly way to compute the \"\n@@ -3804,36 +3802,36 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2200\n+#: doc/tutorial.md:2197\n msgid \"\"\n-\"~~~ {.xfail-test} # use std::float::consts::pi; # use std::float::sqrt; # \"\n-\"trait Shape { fn area(&self) -> float; } # trait Circle : Shape { fn \"\n-\"radius(&self) -> float; } # struct Point { x: float, y: float } # struct \"\n-\"CircleStruct { center: Point, radius: float } # impl Circle for CircleStruct \"\n-\"{ fn radius(&self) -> float { sqrt(self.area() / pi) } } # impl Shape for \"\n+\"~~~ {.xfail-test} # use std::float::consts::pi; # trait Shape { fn \"\n+\"area(&self) -> float; } # trait Circle : Shape { fn radius(&self) -> \"\n+\"float; } # struct Point { x: float, y: float } # struct CircleStruct \"\n+\"{ center: Point, radius: float } # impl Circle for CircleStruct { fn \"\n+\"radius(&self) -> float { (self.area() / pi).sqrt() } } # impl Shape for \"\n \"CircleStruct { fn area(&self) -> float { pi * square(self.radius) } }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2205\n+#: doc/tutorial.md:2202\n msgid \"\"\n \"let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f}; let \"\n \"mycircle: Circle = concrete as @Circle; let nonsense = mycircle.radius() * \"\n \"mycircle.area(); ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2207\n+#: doc/tutorial.md:2204\n msgid \"> ***Note:*** Trait inheritance does not actually work with objects yet\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2209\n+#: doc/tutorial.md:2206\n msgid \"## Deriving implementations for traits\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2216\n+#: doc/tutorial.md:2213\n msgid \"\"\n \"A small number of traits in `std` and `extra` can have implementations that \"\n \"can be automatically derived. These instances are specified by placing the \"\n@@ -3844,37 +3842,37 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2220\n+#: doc/tutorial.md:2217\n msgid \"~~~ #[deriving(Eq)] struct Circle { radius: float }\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2224\n+#: doc/tutorial.md:2221\n msgid \"#[deriving(Rand, ToStr)] enum ABC { A, B, C } ~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2228\n+#: doc/tutorial.md:2225\n msgid \"\"\n \"The full list of derivable traits is `Eq`, `TotalEq`, `Ord`, `TotalOrd`, \"\n \"`Encodable` `Decodable`, `Clone`, `DeepClone`, `IterBytes`, `Rand`, `Zero`, \"\n \"and `ToStr`.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2230\n+#: doc/tutorial.md:2227\n msgid \"# Modules and crates\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2234\n+#: doc/tutorial.md:2231\n msgid \"\"\n \"The Rust namespace is arranged in a hierarchy of modules. Each source (.rs) \"\n \"file represents a single module and may in turn contain additional modules.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2240\n+#: doc/tutorial.md:2237\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n@@ -3885,7 +3883,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2245\n+#: doc/tutorial.md:2242\n #, no-wrap\n msgid \"\"\n \"fn main() {\\n\"\n@@ -3895,22 +3893,22 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2250\n+#: doc/tutorial.md:2247\n msgid \"\"\n \"The contents of modules can be imported into the current scope with the \"\n \"`use` keyword, optionally giving it an alias. `use` may appear at the \"\n \"beginning of crates, `mod`s, `fn`s, and other blocks.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2256\n+#: doc/tutorial.md:2253\n msgid \"\"\n \"~~~ # mod farm { pub fn chicken() { } } # fn main() { // Bring `chicken` \"\n \"into scope use farm::chicken;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2266\n+#: doc/tutorial.md:2263\n #, no-wrap\n msgid \"\"\n \"fn chicken_farmer() {\\n\"\n@@ -3925,7 +3923,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2273\n+#: doc/tutorial.md:2270\n msgid \"\"\n \"These farm animal functions have a new keyword, `pub`, attached to them. The \"\n \"`pub` keyword modifies an item's visibility, making it visible outside its \"\n@@ -3935,7 +3933,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2280\n+#: doc/tutorial.md:2277\n msgid \"\"\n \"Visibility restrictions in Rust exist only at module boundaries. This is \"\n \"quite different from most object-oriented languages that also enforce \"\n@@ -3946,7 +3944,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2293\n+#: doc/tutorial.md:2290\n #, no-wrap\n msgid \"\"\n \"~~~\\n\"\n@@ -3964,7 +3962,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2299\n+#: doc/tutorial.md:2296\n #, no-wrap\n msgid \"\"\n \"    impl Farm {\\n\"\n@@ -3975,7 +3973,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2305\n+#: doc/tutorial.md:2302\n #, no-wrap\n msgid \"\"\n \"    pub fn feed_animals(farm: &Farm) {\\n\"\n@@ -3986,7 +3984,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2315\n+#: doc/tutorial.md:2312\n #, no-wrap\n msgid \"\"\n \"fn main() {\\n\"\n@@ -4001,20 +3999,20 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2317\n+#: doc/tutorial.md:2314\n msgid \"## Crates\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2321\n+#: doc/tutorial.md:2318\n msgid \"\"\n \"The unit of independent compilation in Rust is the crate: rustc compiles a \"\n \"single crate at a time, from which it produces either a library or an \"\n \"executable.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2326\n+#: doc/tutorial.md:2323\n msgid \"\"\n \"When compiling a single `.rs` source file, the file acts as the whole \"\n \"crate.  You can compile it with the `--lib` compiler switch to create a \"\n@@ -4023,7 +4021,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2331\n+#: doc/tutorial.md:2328\n msgid \"\"\n \"Larger crates typically span multiple files and are, by convention, compiled \"\n \"from a source file with the `.rc` extension, called a *crate file*.  The \"\n@@ -4032,7 +4030,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2340\n+#: doc/tutorial.md:2337\n msgid \"\"\n \"A typical crate file declares attributes associated with the crate that may \"\n \"affect how the compiler processes the source.  Crate attributes specify \"\n@@ -4043,34 +4041,34 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2344\n+#: doc/tutorial.md:2341\n msgid \"\"\n \"~~~~ { .xfail-test } // Crate linkage metadata #[link(name = \\\"farm\\\", vers \"\n \"= \\\"2.5\\\", author = \\\"mjh\\\")];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2347\n+#: doc/tutorial.md:2344\n msgid \"// Make a library (\\\"bin\\\" is the default)  #[crate_type = \\\"lib\\\"];\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2350\n+#: doc/tutorial.md:2347\n msgid \"// Turn on a warning #[warn(non_camel_case_types)]\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2353\n+#: doc/tutorial.md:2350\n msgid \"// Link to the standard library extern mod std;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2358\n+#: doc/tutorial.md:2355\n msgid \"// Load some modules from other files mod cow; mod chicken; mod horse;\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2363\n+#: doc/tutorial.md:2360\n #, no-wrap\n msgid \"\"\n \"fn main() {\\n\"\n@@ -4080,7 +4078,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2370\n+#: doc/tutorial.md:2367\n msgid \"\"\n \"Compiling this file will cause `rustc` to look for files named `cow.rs`, \"\n \"`chicken.rs`, and `horse.rs` in the same directory as the `.rc` file, \"\n@@ -4090,21 +4088,21 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2374\n+#: doc/tutorial.md:2371\n msgid \"\"\n \"The `#[link(...)]` attribute provides meta information about the module, \"\n \"which other crates can use to load the right module. More about that later.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2377\n+#: doc/tutorial.md:2374\n msgid \"\"\n \"To have a nested directory structure for your source files, you can nest \"\n \"mods:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2384\n+#: doc/tutorial.md:2381\n #, no-wrap\n msgid \"\"\n \"~~~~ {.ignore}\\n\"\n@@ -4116,7 +4114,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2389\n+#: doc/tutorial.md:2386\n msgid \"\"\n \"The compiler will now look for `poultry/chicken.rs` and `poultry/turkey.rs`, \"\n \"and export their content in `poultry::chicken` and `poultry::turkey`. You \"\n@@ -4125,12 +4123,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2391\n+#: doc/tutorial.md:2388\n msgid \"## Using other crates\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2399\n+#: doc/tutorial.md:2396\n msgid \"\"\n \"The `extern mod` directive lets you use a crate (once it's been compiled \"\n \"into a library) from inside another crate. `extern mod` can appear at the \"\n@@ -4141,17 +4139,17 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2401\n+#: doc/tutorial.md:2398\n msgid \"For example, `extern mod std` links the [standard library].\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2403\n+#: doc/tutorial.md:2400\n msgid \"[standard library]: std/index.html\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2410\n+#: doc/tutorial.md:2407\n msgid \"\"\n \"When a comma-separated list of name/value pairs appears after `extern mod`, \"\n \"the compiler front-end matches these pairs against the attributes provided \"\n@@ -4161,68 +4159,68 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2412\n+#: doc/tutorial.md:2409\n msgid \"Our example crate declared this set of `link` attributes:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2416\n+#: doc/tutorial.md:2413\n msgid \"~~~~ #[link(name = \\\"farm\\\", vers = \\\"2.5\\\", author = \\\"mjh\\\")]; ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2418\n+#: doc/tutorial.md:2415\n msgid \"Which you can then link with any (or all) of the following:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2424\n+#: doc/tutorial.md:2421\n msgid \"\"\n \"~~~~ {.xfail-test} extern mod farm; extern mod my_farm (name = \\\"farm\\\", \"\n \"vers = \\\"2.5\\\"); extern mod my_auxiliary_farm (name = \\\"farm\\\", author = \"\n \"\\\"mjh\\\"); ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2427\n+#: doc/tutorial.md:2424\n msgid \"\"\n \"If any of the requested metadata do not match, then the crate will not be \"\n \"compiled successfully.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2429\n+#: doc/tutorial.md:2426\n msgid \"## A minimal example\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2432\n+#: doc/tutorial.md:2429\n msgid \"\"\n \"Now for something that you can actually compile yourself, we have these two \"\n \"files:\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2438\n+#: doc/tutorial.md:2435\n msgid \"\"\n \"~~~~ // world.rs #[link(name = \\\"world\\\", vers = \\\"1.0\\\")]; pub fn explore() \"\n \"-> &str { \\\"world\\\" } ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2444\n+#: doc/tutorial.md:2441\n msgid \"\"\n \"~~~~ {.xfail-test} // main.rs extern mod world; fn main() { println(~\\\"hello \"\n \"\\\" + world::explore()); } ~~~~\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2446\n+#: doc/tutorial.md:2443\n msgid \"Now compile and run like this (adjust to your platform if necessary):\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2453\n+#: doc/tutorial.md:2450\n #, no-wrap\n msgid \"\"\n \"~~~~ {.notrust}\\n\"\n@@ -4234,7 +4232,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2458\n+#: doc/tutorial.md:2455\n msgid \"\"\n \"Notice that the library produced contains the version in the filename as \"\n \"well as an inscrutable string of alphanumerics. These are both part of \"\n@@ -4243,12 +4241,12 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2460\n+#: doc/tutorial.md:2457\n msgid \"## The standard library\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2465\n+#: doc/tutorial.md:2462\n msgid \"\"\n \"The Rust standard library provides runtime features required by the \"\n \"language, including the task scheduler and memory allocators, as well as \"\n@@ -4257,7 +4255,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2476\n+#: doc/tutorial.md:2473\n msgid \"\"\n \"[`std`] includes modules corresponding to each of the integer types, each of \"\n \"the floating point types, the [`bool`] type, [tuples], [characters], \"\n@@ -4271,33 +4269,33 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2478\n+#: doc/tutorial.md:2475\n msgid \"### Standard Library injection and the Rust prelude\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2481\n+#: doc/tutorial.md:2478\n msgid \"\"\n \"`std` is imported at the topmost level of every crate by default, as if the \"\n \"first line of each crate was\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2483\n+#: doc/tutorial.md:2480\n #, no-wrap\n msgid \"    extern mod std;\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2487\n+#: doc/tutorial.md:2484\n msgid \"\"\n \"This means that the contents of std can be accessed from from any context \"\n \"with the `std::` path prefix, as in `use std::vec`, `use std::task::spawn`, \"\n \"etc.\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2492\n+#: doc/tutorial.md:2489\n msgid \"\"\n \"Additionally, `std` contains a `prelude` module that reexports many of the \"\n \"most common standard modules, types and traits. The contents of the prelude \"\n@@ -4306,13 +4304,13 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2494\n+#: doc/tutorial.md:2491\n #, no-wrap\n msgid \"    use std::prelude::*;\\n\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2520\n+#: doc/tutorial.md:2517\n msgid \"\"\n \"[`std`]: std/index.html [`bool`]: std/bool.html [tuples]: std/tuple.html \"\n \"[characters]: std/char.html [strings]: std/str.html [vectors]: std/vec.html \"\n@@ -4326,56 +4324,56 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2522\n+#: doc/tutorial.md:2519\n msgid \"# What next?\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2525\n+#: doc/tutorial.md:2522\n msgid \"\"\n \"Now that you know the essentials, check out any of the additional tutorials \"\n \"on individual topics.\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial.md:2531\n+#: doc/tutorial.md:2528\n msgid \"[Borrowed pointers][borrow]\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial.md:2531\n+#: doc/tutorial.md:2528\n msgid \"[Tasks and communication][tasks]\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial.md:2531\n+#: doc/tutorial.md:2528\n msgid \"[Macros][macros]\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial.md:2531\n+#: doc/tutorial.md:2528\n msgid \"[The foreign function interface][ffi]\"\n msgstr \"\"\n \n #. type: Bullet: '* '\n-#: doc/tutorial.md:2531\n+#: doc/tutorial.md:2528\n msgid \"[Containers and iterators](tutorial-container.html)\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2533\n+#: doc/tutorial.md:2530\n msgid \"There is further documentation on the [wiki].\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2538\n+#: doc/tutorial.md:2535\n msgid \"\"\n \"[borrow]: tutorial-borrowed-ptr.html [tasks]: tutorial-tasks.html [macros]: \"\n \"tutorial-macros.html [ffi]: tutorial-ffi.html\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2544\n+#: doc/tutorial.md:2541\n msgid \"\"\n \"[wiki]: https://github.com/mozilla/rust/wiki/Docs [unit testing]: https://\"\n \"github.com/mozilla/rust/wiki/Doc-unit-testing [rustdoc]: https://github.com/\"\n@@ -4385,7 +4383,7 @@ msgid \"\"\n msgstr \"\"\n \n #. type: Plain text\n-#: doc/tutorial.md:2545\n+#: doc/tutorial.md:2542\n msgid \"\"\n \"[pound-rust]: http://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust\"\n msgstr \"\""}, {"sha": "cc86111b728d4db37a06debd49a4038af0a690bf", "filename": "mk/docs.mk", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad3a69739f508a2d6219479bf98ac9f853ac3574/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ad3a69739f508a2d6219479bf98ac9f853ac3574/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=ad3a69739f508a2d6219479bf98ac9f853ac3574", "patch": "@@ -236,6 +236,9 @@ GENERATED += doc/version.md doc/version_info.html\n docs: $(DOCS)\n \n docs-l10n:\n-\tpo4a doc/po4a.conf\n+\tpo4a --copyright-holder=\"The Rust Project Developers\" \\\n+\t     --package-name=\"Rust\" \\\n+\t     --package-version=\"$(CFG_RELEASE)\" \\\n+\t     doc/po4a.conf\n \n .PHONY: docs-l10n"}]}