{"sha": "5e9f006c5b95ea98893b0398decd458fd642f38f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOWYwMDZjNWI5NWVhOTg4OTNiMDM5OGRlY2Q0NThmZDY0MmYzOGY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-07T13:42:35Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-07T15:10:27Z"}, "message": "std: more dummy type parameters on iterators to work around #6967.", "tree": {"sha": "014b1cf213e38d8a4dab80f0b7bb05ccade393d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/014b1cf213e38d8a4dab80f0b7bb05ccade393d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e9f006c5b95ea98893b0398decd458fd642f38f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e9f006c5b95ea98893b0398decd458fd642f38f", "html_url": "https://github.com/rust-lang/rust/commit/5e9f006c5b95ea98893b0398decd458fd642f38f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e9f006c5b95ea98893b0398decd458fd642f38f/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d0c004b819f829f7401e74c339a7bbe596e0bdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d0c004b819f829f7401e74c339a7bbe596e0bdf", "html_url": "https://github.com/rust-lang/rust/commit/0d0c004b819f829f7401e74c339a7bbe596e0bdf"}], "stats": {"total": 39, "additions": 21, "deletions": 18}, "files": [{"sha": "4bc545f607dd1cd068412ddf698dde454f51e9b3", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5e9f006c5b95ea98893b0398decd458fd642f38f/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e9f006c5b95ea98893b0398decd458fd642f38f/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=5e9f006c5b95ea98893b0398decd458fd642f38f", "patch": "@@ -55,7 +55,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<Self, U>;\n+    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<A, Self, U>;\n \n     /// Creates an iterator which iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n@@ -73,7 +73,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (&0, &1));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<Self, U>;\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, Self, B, U>;\n \n     // FIXME: #5898: should be called map\n     /// Creates a new iterator which will apply the specified function to each\n@@ -139,7 +139,7 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (1, &200));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn enumerate(self) -> EnumerateIterator<Self>;\n+    fn enumerate(self) -> EnumerateIterator<A, Self>;\n \n     /// Creates an iterator which invokes the predicate on elements until it\n     /// returns true. Once the predicate returns true, all further elements are\n@@ -349,12 +349,12 @@ pub trait IteratorUtil<A> {\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     #[inline(always)]\n-    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<T, U> {\n+    fn chain<U: Iterator<A>>(self, other: U) -> ChainIterator<A, T, U> {\n         ChainIterator{a: self, b: other, flag: false}\n     }\n \n     #[inline(always)]\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<T, U> {\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> ZipIterator<A, T, B, U> {\n         ZipIterator{a: self, b: other}\n     }\n \n@@ -375,7 +375,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n \n     #[inline(always)]\n-    fn enumerate(self) -> EnumerateIterator<T> {\n+    fn enumerate(self) -> EnumerateIterator<A, T> {\n         EnumerateIterator{iter: self, count: 0}\n     }\n \n@@ -570,13 +570,14 @@ impl<A: Ord, T: Iterator<A>> OrdIterator<A> for T {\n }\n \n /// An iterator which strings two iterators together\n-pub struct ChainIterator<T, U> {\n+// FIXME #6967: Dummy A parameter to get around type inference bug\n+pub struct ChainIterator<A, T, U> {\n     priv a: T,\n     priv b: U,\n     priv flag: bool\n }\n \n-impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<T, U> {\n+impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -593,12 +594,13 @@ impl<A, T: Iterator<A>, U: Iterator<A>> Iterator<A> for ChainIterator<T, U> {\n }\n \n /// An iterator which iterates two other iterators simultaneously\n-pub struct ZipIterator<T, U> {\n+// FIXME #6967: Dummy A & B parameters to get around type inference bug\n+pub struct ZipIterator<A, T, B, U> {\n     priv a: T,\n     priv b: U\n }\n \n-impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<T, U> {\n+impl<A, B, T: Iterator<A>, U: Iterator<B>> Iterator<(A, B)> for ZipIterator<A, T, B, U> {\n     #[inline]\n     fn next(&mut self) -> Option<(A, B)> {\n         match (self.a.next(), self.b.next()) {\n@@ -664,12 +666,13 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMapIterator<'self, A, B,\n }\n \n /// An iterator which yields the current count and the element during iteration\n-pub struct EnumerateIterator<T> {\n+// FIXME #6967: Dummy A parameter to get around type inference bug\n+pub struct EnumerateIterator<A, T> {\n     priv iter: T,\n     priv count: uint\n }\n \n-impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<T> {\n+impl<A, T: Iterator<A>> Iterator<(uint, A)> for EnumerateIterator<A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, A)> {\n         match self.iter.next() {\n@@ -887,7 +890,7 @@ mod tests {\n         let expected = [0, 1, 2, 3, 4, 5, 30, 40, 50, 60];\n         let mut it = xs.iter().chain(ys.iter());\n         let mut i = 0;\n-        for it.advance |&x: &uint| {\n+        for it.advance |&x| {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n@@ -896,7 +899,7 @@ mod tests {\n         let ys = Counter::new(30u, 10).take(4);\n         let mut it = xs.iter().transform(|&x| x).chain(ys);\n         let mut i = 0;\n-        for it.advance |x: uint| {\n+        for it.advance |x| {\n             assert_eq!(x, expected[i]);\n             i += 1;\n         }\n@@ -906,15 +909,15 @@ mod tests {\n     #[test]\n     fn test_filter_map() {\n         let mut it = Counter::new(0u, 1u).take(10)\n-            .filter_map(|x: uint| if x.is_even() { Some(x*x) } else { None });\n+            .filter_map(|x| if x.is_even() { Some(x*x) } else { None });\n         assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n     #[test]\n     fn test_iterator_enumerate() {\n         let xs = [0u, 1, 2, 3, 4, 5];\n         let mut it = xs.iter().enumerate();\n-        for it.advance |(i, &x): (uint, &uint)| {\n+        for it.advance |(i, &x)| {\n             assert_eq!(i, x);\n         }\n     }\n@@ -925,7 +928,7 @@ mod tests {\n         let ys = [0u, 1, 2, 3, 5, 13];\n         let mut it = xs.iter().take_while(|&x| *x < 15u);\n         let mut i = 0;\n-        for it.advance |&x: &uint| {\n+        for it.advance |&x| {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }\n@@ -938,7 +941,7 @@ mod tests {\n         let ys = [15, 16, 17, 19];\n         let mut it = xs.iter().skip_while(|&x| *x < 15u);\n         let mut i = 0;\n-        for it.advance |&x: &uint| {\n+        for it.advance |&x| {\n             assert_eq!(x, ys[i]);\n             i += 1;\n         }"}]}