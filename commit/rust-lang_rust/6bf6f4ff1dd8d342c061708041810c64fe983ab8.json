{"sha": "6bf6f4ff1dd8d342c061708041810c64fe983ab8", "node_id": "C_kwDOAAsO6NoAKDZiZjZmNGZmMWRkOGQzNDJjMDYxNzA4MDQxODEwYzY0ZmU5ODNhYjg", "commit": {"author": {"name": "Chayim Refael Friedman", "email": "chayimfr@gmail.com", "date": "2022-01-23T03:39:26Z"}, "committer": {"name": "Chayim Refael Friedman", "email": "chayimfr@gmail.com", "date": "2022-02-21T06:34:34Z"}, "message": "Lower `let` expressions", "tree": {"sha": "f4322ea5e80ed41ed54e0f26469f9a4bcfcaba7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4322ea5e80ed41ed54e0f26469f9a4bcfcaba7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf6f4ff1dd8d342c061708041810c64fe983ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf6f4ff1dd8d342c061708041810c64fe983ab8", "html_url": "https://github.com/rust-lang/rust/commit/6bf6f4ff1dd8d342c061708041810c64fe983ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf6f4ff1dd8d342c061708041810c64fe983ab8/comments", "author": {"login": "ChayimFriedman2", "id": 24700207, "node_id": "MDQ6VXNlcjI0NzAwMjA3", "avatar_url": "https://avatars.githubusercontent.com/u/24700207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChayimFriedman2", "html_url": "https://github.com/ChayimFriedman2", "followers_url": "https://api.github.com/users/ChayimFriedman2/followers", "following_url": "https://api.github.com/users/ChayimFriedman2/following{/other_user}", "gists_url": "https://api.github.com/users/ChayimFriedman2/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChayimFriedman2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChayimFriedman2/subscriptions", "organizations_url": "https://api.github.com/users/ChayimFriedman2/orgs", "repos_url": "https://api.github.com/users/ChayimFriedman2/repos", "events_url": "https://api.github.com/users/ChayimFriedman2/events{/privacy}", "received_events_url": "https://api.github.com/users/ChayimFriedman2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChayimFriedman2", "id": 24700207, "node_id": "MDQ6VXNlcjI0NzAwMjA3", "avatar_url": "https://avatars.githubusercontent.com/u/24700207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChayimFriedman2", "html_url": "https://github.com/ChayimFriedman2", "followers_url": "https://api.github.com/users/ChayimFriedman2/followers", "following_url": "https://api.github.com/users/ChayimFriedman2/following{/other_user}", "gists_url": "https://api.github.com/users/ChayimFriedman2/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChayimFriedman2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChayimFriedman2/subscriptions", "organizations_url": "https://api.github.com/users/ChayimFriedman2/orgs", "repos_url": "https://api.github.com/users/ChayimFriedman2/repos", "events_url": "https://api.github.com/users/ChayimFriedman2/events{/privacy}", "received_events_url": "https://api.github.com/users/ChayimFriedman2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de8633f15fbfb2255d93c51e630a1e1854b1b746", "url": "https://api.github.com/repos/rust-lang/rust/commits/de8633f15fbfb2255d93c51e630a1e1854b1b746", "html_url": "https://github.com/rust-lang/rust/commit/de8633f15fbfb2255d93c51e630a1e1854b1b746"}], "stats": {"total": 197, "additions": 87, "deletions": 110}, "files": [{"sha": "06ad7ce4cd0887ebf7ba1570ee69b9614c90423b", "filename": "crates/hir_def/src/body/lower.rs", "status": "modified", "additions": 11, "deletions": 62, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=6bf6f4ff1dd8d342c061708041810c64fe983ab8", "patch": "@@ -28,7 +28,7 @@ use crate::{\n     db::DefDatabase,\n     expr::{\n         dummy_expr_id, Array, BindingAnnotation, Expr, ExprId, Label, LabelId, Literal, MatchArm,\n-        MatchGuard, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n+        Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     intern::Interned,\n     item_scope::BuiltinShadowMode,\n@@ -155,9 +155,6 @@ impl ExprCollector<'_> {\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n         self.make_expr(expr, Err(SyntheticSyntax))\n     }\n-    fn unit(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Tuple { exprs: Box::default() })\n-    }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n     }\n@@ -215,33 +212,15 @@ impl ExprCollector<'_> {\n                     }\n                 });\n \n-                let condition = match e.condition() {\n-                    None => self.missing_expr(),\n-                    Some(condition) => match condition.pat() {\n-                        None => self.collect_expr_opt(condition.expr()),\n-                        // if let -- desugar to match\n-                        Some(pat) => {\n-                            let pat = self.collect_pat(pat);\n-                            let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.missing_pat();\n-                            let arms = vec![\n-                                MatchArm { pat, expr: then_branch, guard: None },\n-                                MatchArm {\n-                                    pat: placeholder_pat,\n-                                    expr: else_branch.unwrap_or_else(|| self.unit()),\n-                                    guard: None,\n-                                },\n-                            ]\n-                            .into();\n-                            return Some(\n-                                self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr),\n-                            );\n-                        }\n-                    },\n-                };\n+                let condition = self.collect_expr_opt(e.condition());\n \n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n+            ast::Expr::LetExpr(e) => {\n+                let pat = self.collect_pat_opt(e.pat());\n+                let expr = self.collect_expr_opt(e.expr());\n+                self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n+            }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n                 Some(ast::BlockModifier::Try(_)) => {\n                     let body = self.collect_block(e);\n@@ -282,31 +261,7 @@ impl ExprCollector<'_> {\n                 let label = e.label().map(|label| self.collect_label(label));\n                 let body = self.collect_block_opt(e.loop_body());\n \n-                let condition = match e.condition() {\n-                    None => self.missing_expr(),\n-                    Some(condition) => match condition.pat() {\n-                        None => self.collect_expr_opt(condition.expr()),\n-                        // if let -- desugar to match\n-                        Some(pat) => {\n-                            cov_mark::hit!(infer_resolve_while_let);\n-                            let pat = self.collect_pat(pat);\n-                            let match_expr = self.collect_expr_opt(condition.expr());\n-                            let placeholder_pat = self.missing_pat();\n-                            let break_ =\n-                                self.alloc_expr_desugared(Expr::Break { expr: None, label: None });\n-                            let arms = vec![\n-                                MatchArm { pat, expr: body, guard: None },\n-                                MatchArm { pat: placeholder_pat, expr: break_, guard: None },\n-                            ]\n-                            .into();\n-                            let match_expr =\n-                                self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return Some(\n-                                self.alloc_expr(Expr::Loop { body: match_expr, label }, syntax_ptr),\n-                            );\n-                        }\n-                    },\n-                };\n+                let condition = self.collect_expr_opt(e.condition());\n \n                 self.alloc_expr(Expr::While { condition, body, label }, syntax_ptr)\n             }\n@@ -352,15 +307,9 @@ impl ExprCollector<'_> {\n                             self.check_cfg(&arm).map(|()| MatchArm {\n                                 pat: self.collect_pat_opt(arm.pat()),\n                                 expr: self.collect_expr_opt(arm.expr()),\n-                                guard: arm.guard().map(|guard| match guard.pat() {\n-                                    Some(pat) => MatchGuard::IfLet {\n-                                        pat: self.collect_pat(pat),\n-                                        expr: self.collect_expr_opt(guard.expr()),\n-                                    },\n-                                    None => {\n-                                        MatchGuard::If { expr: self.collect_expr_opt(guard.expr()) }\n-                                    }\n-                                }),\n+                                guard: arm\n+                                    .guard()\n+                                    .map(|guard| self.collect_expr_opt(guard.condition())),\n                             })\n                         })\n                         .collect()"}, {"sha": "505d33fa482a126a3c191609cbdd3ddc08f07e51", "filename": "crates/hir_def/src/body/scope.rs", "status": "modified", "additions": 65, "deletions": 37, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=6bf6f4ff1dd8d342c061708041810c64fe983ab8", "patch": "@@ -8,7 +8,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     body::Body,\n     db::DefDatabase,\n-    expr::{Expr, ExprId, LabelId, MatchGuard, Pat, PatId, Statement},\n+    expr::{Expr, ExprId, LabelId, Pat, PatId, Statement},\n     BlockId, DefWithBodyId,\n };\n \n@@ -53,9 +53,9 @@ impl ExprScopes {\n     fn new(body: &Body) -> ExprScopes {\n         let mut scopes =\n             ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n-        let root = scopes.root_scope();\n+        let mut root = scopes.root_scope();\n         scopes.add_params_bindings(body, root, &body.params);\n-        compute_expr_scopes(body.body_expr, body, &mut scopes, root);\n+        compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n         scopes\n     }\n \n@@ -151,79 +151,82 @@ fn compute_block_scopes(\n         match stmt {\n             Statement::Let { pat, initializer, else_branch, .. } => {\n                 if let Some(expr) = initializer {\n-                    compute_expr_scopes(*expr, body, scopes, scope);\n+                    compute_expr_scopes(*expr, body, scopes, &mut scope);\n                 }\n                 if let Some(expr) = else_branch {\n-                    compute_expr_scopes(*expr, body, scopes, scope);\n+                    compute_expr_scopes(*expr, body, scopes, &mut scope);\n                 }\n                 scope = scopes.new_scope(scope);\n                 scopes.add_bindings(body, scope, *pat);\n             }\n             Statement::Expr { expr, .. } => {\n-                compute_expr_scopes(*expr, body, scopes, scope);\n+                compute_expr_scopes(*expr, body, scopes, &mut scope);\n             }\n         }\n     }\n     if let Some(expr) = tail {\n-        compute_expr_scopes(expr, body, scopes, scope);\n+        compute_expr_scopes(expr, body, scopes, &mut scope);\n     }\n }\n \n-fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: ScopeId) {\n+fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope: &mut ScopeId) {\n     let make_label =\n         |label: &Option<LabelId>| label.map(|label| (label, body.labels[label].name.clone()));\n \n-    scopes.set_scope(expr, scope);\n+    scopes.set_scope(expr, *scope);\n     match &body[expr] {\n         Expr::Block { statements, tail, id, label } => {\n-            let scope = scopes.new_block_scope(scope, *id, make_label(label));\n+            let scope = scopes.new_block_scope(*scope, *id, make_label(label));\n             // Overwrite the old scope for the block expr, so that every block scope can be found\n             // via the block itself (important for blocks that only contain items, no expressions).\n             scopes.set_scope(expr, scope);\n             compute_block_scopes(statements, *tail, body, scopes, scope);\n         }\n         Expr::For { iterable, pat, body: body_expr, label } => {\n             compute_expr_scopes(*iterable, body, scopes, scope);\n-            let scope = scopes.new_labeled_scope(scope, make_label(label));\n+            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n             scopes.add_bindings(body, scope, *pat);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::While { condition, body: body_expr, label } => {\n-            let scope = scopes.new_labeled_scope(scope, make_label(label));\n-            compute_expr_scopes(*condition, body, scopes, scope);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n+            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n+            compute_expr_scopes(*condition, body, scopes, &mut scope);\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::Loop { body: body_expr, label } => {\n-            let scope = scopes.new_labeled_scope(scope, make_label(label));\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n+            let mut scope = scopes.new_labeled_scope(*scope, make_label(label));\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::Lambda { args, body: body_expr, .. } => {\n-            let scope = scopes.new_scope(scope);\n+            let mut scope = scopes.new_scope(*scope);\n             scopes.add_params_bindings(body, scope, args);\n-            compute_expr_scopes(*body_expr, body, scopes, scope);\n+            compute_expr_scopes(*body_expr, body, scopes, &mut scope);\n         }\n         Expr::Match { expr, arms } => {\n             compute_expr_scopes(*expr, body, scopes, scope);\n             for arm in arms.iter() {\n-                let mut scope = scopes.new_scope(scope);\n+                let mut scope = scopes.new_scope(*scope);\n                 scopes.add_bindings(body, scope, arm.pat);\n-                match arm.guard {\n-                    Some(MatchGuard::If { expr: guard }) => {\n-                        scopes.set_scope(guard, scope);\n-                        compute_expr_scopes(guard, body, scopes, scope);\n-                    }\n-                    Some(MatchGuard::IfLet { pat, expr: guard }) => {\n-                        scopes.set_scope(guard, scope);\n-                        compute_expr_scopes(guard, body, scopes, scope);\n-                        scope = scopes.new_scope(scope);\n-                        scopes.add_bindings(body, scope, pat);\n-                    }\n-                    _ => {}\n-                };\n-                scopes.set_scope(arm.expr, scope);\n-                compute_expr_scopes(arm.expr, body, scopes, scope);\n+                if let Some(guard) = arm.guard {\n+                    scope = scopes.new_scope(scope);\n+                    compute_expr_scopes(guard, body, scopes, &mut scope);\n+                }\n+                compute_expr_scopes(arm.expr, body, scopes, &mut scope);\n             }\n         }\n+        &Expr::If { condition, then_branch, else_branch } => {\n+            let mut then_branch_scope = scopes.new_scope(*scope);\n+            compute_expr_scopes(condition, body, scopes, &mut then_branch_scope);\n+            compute_expr_scopes(then_branch, body, scopes, &mut then_branch_scope);\n+            if let Some(else_branch) = else_branch {\n+                compute_expr_scopes(else_branch, body, scopes, scope);\n+            }\n+        }\n+        &Expr::Let { pat, expr } => {\n+            compute_expr_scopes(expr, body, scopes, scope);\n+            *scope = scopes.new_scope(*scope);\n+            scopes.add_bindings(body, *scope, pat);\n+        }\n         e => e.walk_child_exprs(|e| compute_expr_scopes(e, body, scopes, scope)),\n     };\n }\n@@ -500,8 +503,7 @@ fn foo() {\n     }\n \n     #[test]\n-    fn while_let_desugaring() {\n-        cov_mark::check!(infer_resolve_while_let);\n+    fn while_let_adds_binding() {\n         do_check_local_name(\n             r#\"\n fn test() {\n@@ -513,5 +515,31 @@ fn test() {\n \"#,\n             75,\n         );\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while (((let Option::Some(_) = foo))) && let Option::Some(spam) = foo {\n+        spam$0\n+    }\n+}\n+\"#,\n+            107,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_guard_if_let() {\n+        do_check_local_name(\n+            r#\"\n+fn test() {\n+    let foo: Option<f32> = None;\n+    match foo {\n+        _ if let Option::Some(spam) = foo => spam$0,\n+    }\n+}\n+\"#,\n+            93,\n+        );\n     }\n }"}, {"sha": "4dca8238880d9376833bf406c65369e8550737fe", "filename": "crates/hir_def/src/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=6bf6f4ff1dd8d342c061708041810c64fe983ab8", "patch": "@@ -59,6 +59,10 @@ pub enum Expr {\n         then_branch: ExprId,\n         else_branch: Option<ExprId>,\n     },\n+    Let {\n+        pat: PatId,\n+        expr: ExprId,\n+    },\n     Block {\n         id: BlockId,\n         statements: Box<[Statement]>,\n@@ -189,17 +193,10 @@ pub enum Array {\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MatchArm {\n     pub pat: PatId,\n-    pub guard: Option<MatchGuard>,\n+    pub guard: Option<ExprId>,\n     pub expr: ExprId,\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq)]\n-pub enum MatchGuard {\n-    If { expr: ExprId },\n-\n-    IfLet { pat: PatId, expr: ExprId },\n-}\n-\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct RecordLitField {\n     pub name: Name,\n@@ -232,6 +229,9 @@ impl Expr {\n                     f(else_branch);\n                 }\n             }\n+            Expr::Let { expr, .. } => {\n+                f(*expr);\n+            }\n             Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {"}, {"sha": "84cc3f3872f2a1a5f3247ed6b5f7c7bfc27098a1", "filename": "crates/hir_def/src/macro_expansion_tests/mbe/tt_conversion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf6f4ff1dd8d342c061708041810c64fe983ab8/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe%2Ftt_conversion.rs?ref=6bf6f4ff1dd8d342c061708041810c64fe983ab8", "patch": "@@ -108,18 +108,18 @@ fn expansion_does_not_parse_as_expression() {\n     check(\n         r#\"\n macro_rules! stmts {\n-    () => { let _ = 0; }\n+    () => { fn foo() {} }\n }\n \n fn f() { let _ = stmts!/*+errors*/(); }\n \"#,\n         expect![[r#\"\n macro_rules! stmts {\n-    () => { let _ = 0; }\n+    () => { fn foo() {} }\n }\n \n fn f() { let _ = /* parse error: expected expression */\n-let _ = 0;; }\n+fn foo() {}; }\n \"#]],\n     )\n }"}]}