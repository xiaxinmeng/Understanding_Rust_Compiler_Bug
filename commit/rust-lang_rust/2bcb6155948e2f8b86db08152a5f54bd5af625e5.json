{"sha": "2bcb6155948e2f8b86db08152a5f54bd5af625e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiY2I2MTU1OTQ4ZTJmOGI4NmRiMDgxNTJhNWY1NGJkNWFmNjI1ZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-24T07:45:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-24T07:45:29Z"}, "message": "Auto merge of #4443 - jeremystucki:methods-refactoring, r=phansch\n\nSmall refactoring of methods/mod.rs\n\nchangelog: none", "tree": {"sha": "a054ca4709b3c9421a4cb7902d66e147f745139a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a054ca4709b3c9421a4cb7902d66e147f745139a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bcb6155948e2f8b86db08152a5f54bd5af625e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bcb6155948e2f8b86db08152a5f54bd5af625e5", "html_url": "https://github.com/rust-lang/rust/commit/2bcb6155948e2f8b86db08152a5f54bd5af625e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bcb6155948e2f8b86db08152a5f54bd5af625e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56f51b35e8b4252aa0d10e9ac3d26e4b821e12a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/56f51b35e8b4252aa0d10e9ac3d26e4b821e12a0", "html_url": "https://github.com/rust-lang/rust/commit/56f51b35e8b4252aa0d10e9ac3d26e4b821e12a0"}, {"sha": "2da8288433a8a7686be767587fbb6bbc62838264", "url": "https://api.github.com/repos/rust-lang/rust/commits/2da8288433a8a7686be767587fbb6bbc62838264", "html_url": "https://github.com/rust-lang/rust/commit/2da8288433a8a7686be767587fbb6bbc62838264"}], "stats": {"total": 320, "additions": 151, "deletions": 169}, "files": [{"sha": "f7544e095b8bfdc7eea8559ea551a5a1fd921a4f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 151, "deletions": 169, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/2bcb6155948e2f8b86db08152a5f54bd5af625e5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bcb6155948e2f8b86db08152a5f54bd5af625e5/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2bcb6155948e2f8b86db08152a5f54bd5af625e5", "patch": "@@ -1075,56 +1075,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             if let hir::ImplItemKind::Method(ref sig, id) = impl_item.node;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, _, _) = item.node;\n+\n+            let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+            let method_sig = cx.tcx.fn_sig(method_def_id);\n+            let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n+\n+            let first_arg_ty = &method_sig.inputs().iter().next();\n+\n+            // check conventions w.r.t. conversion method names and predicates\n+            if let Some(first_arg_ty) = first_arg_ty;\n+\n             then {\n-                let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-                let method_sig = cx.tcx.fn_sig(method_def_id);\n-                let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n-\n-                let first_arg_ty = &method_sig.inputs().iter().next();\n-\n-                // check conventions w.r.t. conversion method names and predicates\n-                if let Some(first_arg_ty) = first_arg_ty {\n-\n-                    if cx.access_levels.is_exported(impl_item.hir_id) {\n-                    // check missing trait implementations\n-                        for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                            if name == method_name &&\n-                            sig.decl.inputs.len() == n_args &&\n-                            out_type.matches(cx, &sig.decl.output) &&\n-                            self_kind.matches(cx, ty, first_arg_ty) {\n-                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n-                                    \"defining a method called `{}` on this type; consider implementing \\\n-                                    the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                            }\n+                if cx.access_levels.is_exported(impl_item.hir_id) {\n+                // check missing trait implementations\n+                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                        if name == method_name &&\n+                        sig.decl.inputs.len() == n_args &&\n+                        out_type.matches(cx, &sig.decl.output) &&\n+                        self_kind.matches(cx, ty, first_arg_ty) {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n+                                \"defining a method called `{}` on this type; consider implementing \\\n+                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n                         }\n                     }\n+                }\n \n-                    for &(ref conv, self_kinds) in &CONVENTIONS {\n-                        if conv.check(&name) {\n-                            if !self_kinds\n-                                    .iter()\n-                                    .any(|k| k.matches(cx, ty, first_arg_ty)) {\n-                                let lint = if item.vis.node.is_pub() {\n-                                    WRONG_PUB_SELF_CONVENTION\n-                                } else {\n-                                    WRONG_SELF_CONVENTION\n-                                };\n-                                span_lint(cx,\n-                                          lint,\n-                                          first_arg.pat.span,\n-                                          &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                                    ambiguous name\",\n-                                                   conv,\n-                                                   &self_kinds.iter()\n-                                                              .map(|k| k.description())\n-                                                              .collect::<Vec<_>>()\n-                                                              .join(\" or \")));\n-                            }\n+                if let Some((ref conv, self_kinds)) = &CONVENTIONS\n+                    .iter()\n+                    .find(|(ref conv, _)| conv.check(&name))\n+                {\n+                    if !self_kinds.iter().any(|k| k.matches(cx, ty, first_arg_ty)) {\n+                        let lint = if item.vis.node.is_pub() {\n+                            WRONG_PUB_SELF_CONVENTION\n+                        } else {\n+                            WRONG_SELF_CONVENTION\n+                        };\n \n-                            // Only check the first convention to match (CONVENTIONS should be listed from most to least\n-                            // specific)\n-                            break;\n-                        }\n+                        span_lint(\n+                            cx,\n+                            lint,\n+                            first_arg.pat.span,\n+                            &format!(\n+                               \"methods called `{}` usually take {}; consider choosing a less \\\n+                                 ambiguous name\",\n+                                conv,\n+                                &self_kinds\n+                                    .iter()\n+                                    .map(|k| k.description())\n+                                    .collect::<Vec<_>>()\n+                                    .join(\" or \")\n+                            ),\n+                        );\n                     }\n                 }\n             }\n@@ -1134,10 +1135,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n-            for inner_type in ret_ty.walk() {\n-                if same_tys(cx, ty, inner_type) {\n-                    return;\n-                }\n+            if ret_ty.walk().any(|inner_type| same_tys(cx, ty, inner_type)) {\n+                return;\n             }\n \n             // if return type is impl trait, check the associated types\n@@ -1230,43 +1229,36 @@ fn lint_or_fun_call<'a, 'tcx>(\n         or_has_args: bool,\n         span: Span,\n     ) -> bool {\n-        if or_has_args {\n-            return false;\n-        }\n-\n-        if name == \"unwrap_or\" {\n-            if let hir::ExprKind::Path(ref qpath) = fun.node {\n-                let path = &*last_path_segment(qpath).ident.as_str();\n+        if_chain! {\n+            if !or_has_args;\n+            if name == \"unwrap_or\";\n+            if let hir::ExprKind::Path(ref qpath) = fun.node;\n+            let path = &*last_path_segment(qpath).ident.as_str();\n+            if [\"default\", \"new\"].contains(&path);\n+            let arg_ty = cx.tables.expr_ty(arg);\n+            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+            if implements_trait(cx, arg_ty, default_trait_id, &[]);\n \n-                if [\"default\", \"new\"].contains(&path) {\n-                    let arg_ty = cx.tables.expr_ty(arg);\n-                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT) {\n-                        default_trait_id\n-                    } else {\n-                        return false;\n-                    };\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span,\n+                    &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n+                    \"try this\",\n+                    format!(\n+                        \"{}.unwrap_or_default()\",\n+                        snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)\n+                    ),\n+                    applicability,\n+                );\n \n-                    if implements_trait(cx, arg_ty, default_trait_id, &[]) {\n-                        let mut applicability = Applicability::MachineApplicable;\n-                        span_lint_and_sugg(\n-                            cx,\n-                            OR_FUN_CALL,\n-                            span,\n-                            &format!(\"use of `{}` followed by a call to `{}`\", name, path),\n-                            \"try this\",\n-                            format!(\n-                                \"{}.unwrap_or_default()\",\n-                                snippet_with_applicability(cx, self_expr.span, \"_\", &mut applicability)\n-                            ),\n-                            applicability,\n-                        );\n-                        return true;\n-                    }\n-                }\n+                true\n+            } else {\n+                false\n             }\n         }\n-\n-        false\n     }\n \n     /// Checks for `*or(foo())`.\n@@ -1289,46 +1281,37 @@ fn lint_or_fun_call<'a, 'tcx>(\n             (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n-        // early check if the name is one we care about\n-        if know_types.iter().all(|k| !k.2.contains(&name)) {\n-            return;\n-        }\n+        if_chain! {\n+            if know_types.iter().any(|k| k.2.contains(&name));\n \n-        let mut finder = FunCallFinder { cx: &cx, found: false };\n-        finder.visit_expr(&arg);\n-        if !finder.found {\n-            return;\n-        }\n+            let mut finder = FunCallFinder { cx: &cx, found: false };\n+            if { finder.visit_expr(&arg); finder.found };\n \n-        let self_ty = cx.tables.expr_ty(self_expr);\n+            let self_ty = cx.tables.expr_ty(self_expr);\n \n-        let (fn_has_arguments, poss, suffix) = if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-            know_types.iter().find(|&&i| match_type(cx, self_ty, i.0))\n-        {\n-            (fn_has_arguments, poss, suffix)\n-        } else {\n-            return;\n-        };\n+            if let Some(&(_, fn_has_arguments, poss, suffix)) =\n+                   know_types.iter().find(|&&i| match_type(cx, self_ty, i.0));\n \n-        if !poss.contains(&name) {\n-            return;\n-        }\n+            if poss.contains(&name);\n \n-        let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n-            (true, _) => format!(\"|_| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n-            (false, false) => format!(\"|| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n-            (false, true) => snippet_with_macro_callsite(cx, fun_span, \"..\"),\n-        };\n-        let span_replace_word = method_span.with_hi(span.hi());\n-        span_lint_and_sugg(\n-            cx,\n-            OR_FUN_CALL,\n-            span_replace_word,\n-            &format!(\"use of `{}` followed by a function call\", name),\n-            \"try this\",\n-            format!(\"{}_{}({})\", name, suffix, sugg),\n-            Applicability::HasPlaceholders,\n-        );\n+            then {\n+                let sugg: Cow<'_, _> = match (fn_has_arguments, !or_has_args) {\n+                    (true, _) => format!(\"|_| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n+                    (false, false) => format!(\"|| {}\", snippet_with_macro_callsite(cx, arg.span, \"..\")).into(),\n+                    (false, true) => snippet_with_macro_callsite(cx, fun_span, \"..\"),\n+                };\n+                let span_replace_word = method_span.with_hi(span.hi());\n+                span_lint_and_sugg(\n+                    cx,\n+                    OR_FUN_CALL,\n+                    span_replace_word,\n+                    &format!(\"use of `{}` followed by a function call\", name),\n+                    \"try this\",\n+                    format!(\"{}_{}({})\", name, suffix, sugg),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n     }\n \n     if args.len() == 2 {\n@@ -1413,18 +1396,20 @@ fn lint_expect_fun_call(cx: &LateContext<'_, '_>, expr: &hir::Expr, method_span:\n         a: &hir::Expr,\n         applicability: &mut Applicability,\n     ) -> Vec<String> {\n-        if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node {\n-            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node {\n-                if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node {\n-                    return format_arg_expr_tup\n-                        .iter()\n-                        .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n-                        .collect();\n-                }\n-            }\n-        };\n+        if_chain! {\n+            if let hir::ExprKind::AddrOf(_, ref format_arg) = a.node;\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.node;\n+            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.node;\n \n-        unreachable!()\n+            then {\n+                format_arg_expr_tup\n+                    .iter()\n+                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n+                    .collect()\n+            } else {\n+                unreachable!()\n+            }\n+        }\n     }\n \n     fn is_call(node: &hir::ExprKind) -> bool {\n@@ -1688,20 +1673,22 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, source: &hir:\n }\n \n fn lint_iter_cloned_collect<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) {\n-        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])) {\n-            if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite()) {\n-                span_lint_and_sugg(\n-                    cx,\n-                    ITER_CLONED_COLLECT,\n-                    to_replace,\n-                    \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-                     more readable\",\n-                    \"try\",\n-                    \".to_vec()\".to_string(),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+    if_chain! {\n+        if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC);\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0]));\n+        if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite());\n+\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                ITER_CLONED_COLLECT,\n+                to_replace,\n+                \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                 more readable\",\n+                \"try\",\n+                \".to_vec()\".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n         }\n     }\n }\n@@ -1961,18 +1948,20 @@ fn lint_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, unwrap_args: &[hir::E\n \n /// lint use of `ok().expect()` for `Result`s\n fn lint_ok_expect(cx: &LateContext<'_, '_>, expr: &hir::Expr, ok_args: &[hir::Expr]) {\n-    // lint if the caller of `ok()` is a `Result`\n-    if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT) {\n+    if_chain! {\n+        // lint if the caller of `ok()` is a `Result`\n+        if match_type(cx, cx.tables.expr_ty(&ok_args[0]), &paths::RESULT);\n         let result_type = cx.tables.expr_ty(&ok_args[0]);\n-        if let Some(error_type) = get_error_type(cx, result_type) {\n-            if has_debug_impl(error_type, cx) {\n-                span_lint(\n-                    cx,\n-                    OK_EXPECT,\n-                    expr.span,\n-                    \"called `ok().expect()` on a Result value. You can call `expect` directly on the `Result`\",\n-                );\n-            }\n+        if let Some(error_type) = get_error_type(cx, result_type);\n+        if has_debug_impl(error_type, cx);\n+\n+        then {\n+            span_lint(\n+                cx,\n+                OK_EXPECT,\n+                expr.span,\n+                \"called `ok().expect()` on a Result value. You can call `expect` directly on the `Result`\",\n+            );\n         }\n     }\n }\n@@ -2524,11 +2513,11 @@ fn lint_chars_cmp_with_unwrap<'a, 'tcx>(\n                 applicability,\n             );\n \n-            return true;\n+            true\n+        } else {\n+            false\n         }\n     }\n-\n-    false\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n@@ -2616,7 +2605,7 @@ fn ty_has_iter_method(\n     cx: &LateContext<'_, '_>,\n     self_ref_ty: Ty<'_>,\n ) -> Option<(&'static Lint, &'static str, &'static str)> {\n-    if let Some(ty_name) = has_iter_method(cx, self_ref_ty) {\n+    has_iter_method(cx, self_ref_ty).map(|ty_name| {\n         let lint = if ty_name == \"array\" || ty_name == \"PathBuf\" {\n             INTO_ITER_ON_ARRAY\n         } else {\n@@ -2630,10 +2619,8 @@ fn ty_has_iter_method(\n             hir::MutImmutable => \"iter\",\n             hir::MutMutable => \"iter_mut\",\n         };\n-        Some((lint, ty_name, method_name))\n-    } else {\n-        None\n-    }\n+        (lint, ty_name, method_name)\n+    })\n }\n \n fn lint_into_iter(cx: &LateContext<'_, '_>, expr: &hir::Expr, self_ref_ty: Ty<'_>, method_span: Span) {\n@@ -2668,14 +2655,9 @@ fn lint_suspicious_map(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n fn get_error_type<'a>(cx: &LateContext<'_, '_>, ty: Ty<'a>) -> Option<Ty<'a>> {\n-    if let ty::Adt(_, substs) = ty.sty {\n-        if match_type(cx, ty, &paths::RESULT) {\n-            substs.types().nth(1)\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n+    match ty.sty {\n+        ty::Adt(_, substs) if match_type(cx, ty, &paths::RESULT) => substs.types().nth(1),\n+        _ => None,\n     }\n }\n "}]}