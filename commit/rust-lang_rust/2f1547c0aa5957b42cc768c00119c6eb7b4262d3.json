{"sha": "2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMTU0N2MwYWE1OTU3YjQyY2M3NjhjMDAxMTljNmViN2I0MjYyZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-11T20:59:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-11T20:59:11Z"}, "message": "Auto merge of #53873 - nikomatsakis:nll-universe-subtyping-and-pattern-ascription, r=pnkfelix\n\nsupport ascription for patterns in NLL\n\nThis implements the strategy outlined in [this comment](https://github.com/rust-lang/rust/issues/47184#issuecomment-416669986):\n\n- We first extend the NLL subtyping code so it can handle inference variables and subtyping.\n- Then we extend HAIR patterns with type ascription.\n- Then we treat the type `T` in `let pat: T = ...` as an ascription.\n\nBefore landing, a few things:\n\n- [x] Fix the WF rule bug (filed a FIXME https://github.com/rust-lang/rust/issues/54105)\n- [x] Fix an ICE I encountered locally around bound regions, or else file a follow-up\n- [x] More tests probably =)\n\nr? @pnkfelix", "tree": {"sha": "b473b735b42819d12e23e72f97c5294a6a228aa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b473b735b42819d12e23e72f97c5294a6a228aa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "html_url": "https://github.com/rust-lang/rust/commit/2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f17c2306e2eba49f6447cfda831e4161bf0b618a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f17c2306e2eba49f6447cfda831e4161bf0b618a", "html_url": "https://github.com/rust-lang/rust/commit/f17c2306e2eba49f6447cfda831e4161bf0b618a"}, {"sha": "f95f23f0c3f56d40a57b6e5b538aa98fd4f18b0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f95f23f0c3f56d40a57b6e5b538aa98fd4f18b0f", "html_url": "https://github.com/rust-lang/rust/commit/f95f23f0c3f56d40a57b6e5b538aa98fd4f18b0f"}], "stats": {"total": 2881, "additions": 1873, "deletions": 1008}, "files": [{"sha": "5f35c9fea0a337248d24634e744a0c6b5427fe99", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -24,6 +24,7 @@ impl_stable_hash_for!(enum mir::LocalKind { Var, Temp, Arg, ReturnPointer });\n impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n     mutability,\n     ty,\n+    user_ty,\n     name,\n     source_info,\n     visibility_scope,\n@@ -255,9 +256,10 @@ for mir::StatementKind<'gcx> {\n                 op.hash_stable(hcx, hasher);\n                 places.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::UserAssertTy(ref c_ty, ref local) => {\n+            mir::StatementKind::AscribeUserType(ref place, ref variance, ref c_ty) => {\n+                place.hash_stable(hcx, hasher);\n+                variance.hash_stable(hcx, hasher);\n                 c_ty.hash_stable(hcx, hasher);\n-                local.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {"}, {"sha": "e628a3458f9e628c0ed450caae519aea28dd4d12", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 396, "deletions": 335, "changes": 731, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -10,41 +10,41 @@\n \n //! See the Book for more information.\n \n+pub use self::freshen::TypeFreshener;\n pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n pub use ty::IntVarValue;\n-pub use self::freshen::TypeFreshener;\n \n+use arena::SyncDroplessArena;\n+use errors::DiagnosticBuilder;\n use hir::def_id::DefId;\n use middle::free_region::RegionRelations;\n-use middle::region;\n use middle::lang_items;\n-use ty::subst::{Kind, Substs};\n-use ty::{TyVid, IntVid, FloatVid};\n-use ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n-use ty::relate::RelateResult;\n-use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use middle::region;\n use rustc_data_structures::unify as ut;\n-use std::cell::{Cell, RefCell, Ref, RefMut};\n+use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n-use errors::DiagnosticBuilder;\n-use syntax_pos::{self, Span};\n use syntax_pos::symbol::InternedString;\n+use syntax_pos::{self, Span};\n+use traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use ty::fold::TypeFoldable;\n+use ty::relate::RelateResult;\n+use ty::subst::{Kind, Substs};\n+use ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use ty::{FloatVid, IntVid, TyVid};\n use util::nodemap::FxHashMap;\n-use arena::SyncDroplessArena;\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarInfos};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n+use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n@@ -54,16 +54,16 @@ pub mod canonical;\n mod combine;\n mod equate;\n pub mod error_reporting;\n+mod freshen;\n mod fudge;\n mod glb;\n mod higher_ranked;\n pub mod lattice;\n-mod lub;\n-pub mod region_constraints;\n mod lexical_region_resolve;\n+mod lub;\n pub mod outlives;\n+pub mod region_constraints;\n pub mod resolve;\n-mod freshen;\n mod sub;\n pub mod type_variable;\n pub mod unify_key;\n@@ -80,7 +80,7 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferCtxt<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n     /// During type-checking/inference of a body, `in_progress_tables`\n@@ -314,10 +314,10 @@ pub enum SubregionOrigin<'tcx> {\n /// Places that type/region parameters can appear.\n #[derive(Clone, Copy, Debug)]\n pub enum ParameterOrigin {\n-    Path, // foo::bar\n-    MethodCall, // foo.bar() <-- parameters on impl providing bar()\n+    Path,               // foo::bar\n+    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n     OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref, // *a when overloaded\n+    OverloadedDeref,    // *a when overloaded\n }\n \n /// Times when we replace late-bound regions with variables:\n@@ -400,7 +400,7 @@ impl NLLRegionVariableOrigin {\n pub enum FixupError {\n     UnresolvedIntTy(IntVid),\n     UnresolvedFloatTy(FloatVid),\n-    UnresolvedTy(TyVid)\n+    UnresolvedTy(TyVid),\n }\n \n /// See the `region_obligations` field for more information.\n@@ -416,23 +416,25 @@ impl fmt::Display for FixupError {\n         use self::FixupError::*;\n \n         match *self {\n-            UnresolvedIntTy(_) => {\n-                write!(f, \"cannot determine the type of this integer; \\\n-                           add a suffix to specify the type explicitly\")\n-            }\n-            UnresolvedFloatTy(_) => {\n-                write!(f, \"cannot determine the type of this number; \\\n-                           add a suffix to specify the type explicitly\")\n-            }\n-            UnresolvedTy(_) => write!(f, \"unconstrained type\")\n+            UnresolvedIntTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this integer; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedFloatTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this number; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n         }\n     }\n }\n \n /// Helper type of a temporary returned by tcx.infer_ctxt().\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n-pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct InferCtxtBuilder<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: SyncDroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n@@ -444,7 +446,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             global_tcx: self,\n             arena: SyncDroplessArena::new(),\n             fresh_tables: None,\n-\n         }\n     }\n }\n@@ -458,48 +459,60 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n-        where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n+    where\n+        F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R,\n     {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n             ref fresh_tables,\n         } = *self;\n         let in_progress_tables = fresh_tables.as_ref();\n-        global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n-            tcx,\n-            in_progress_tables,\n-            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-            float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-            region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n-            lexical_region_resolutions: RefCell::new(None),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n-            reported_trait_errors: RefCell::new(FxHashMap()),\n-            tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: tcx.sess.err_count(),\n-            in_snapshot: Cell::new(false),\n-            region_obligations: RefCell::new(vec![]),\n-            universe: Cell::new(ty::UniverseIndex::ROOT),\n-        }))\n+        global_tcx.enter_local(arena, |tcx| {\n+            f(InferCtxt {\n+                tcx,\n+                in_progress_tables,\n+                projection_cache: RefCell::new(traits::ProjectionCache::new()),\n+                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n+                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n+                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n+                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+                lexical_region_resolutions: RefCell::new(None),\n+                selection_cache: traits::SelectionCache::new(),\n+                evaluation_cache: traits::EvaluationCache::new(),\n+                reported_trait_errors: RefCell::new(FxHashMap()),\n+                tainted_by_errors_flag: Cell::new(false),\n+                err_count_on_creation: tcx.sess.err_count(),\n+                in_snapshot: Cell::new(false),\n+                region_obligations: RefCell::new(vec![]),\n+                universe: Cell::new(ty::UniverseIndex::ROOT),\n+            })\n+        })\n     }\n }\n \n impl<T> ExpectedFound<T> {\n     pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n         if a_is_expected {\n-            ExpectedFound {expected: a, found: b}\n+            ExpectedFound {\n+                expected: a,\n+                found: b,\n+            }\n         } else {\n-            ExpectedFound {expected: b, found: a}\n+            ExpectedFound {\n+                expected: b,\n+                found: a,\n+            }\n         }\n     }\n }\n \n impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n+        InferOk {\n+            value: (),\n+            obligations: self.obligations,\n+        }\n     }\n \n     /// Extract `value`, registering any obligations into `fulfill_cx`\n@@ -523,7 +536,7 @@ impl<'tcx> InferOk<'tcx, ()> {\n }\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx:'a> {\n+pub struct CombinedSnapshot<'a, 'tcx: 'a> {\n     projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n     int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n@@ -540,14 +553,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.in_snapshot.get()\n     }\n \n-    pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n+    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n         t.fold_with(&mut self.freshener())\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n         match ty.sty {\n             ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -557,22 +570,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn type_is_unconstrained_numeric(&'a self, ty: Ty) -> UnconstrainedNumeric {\n         use ty::error::UnconstrainedNumeric::Neither;\n-        use ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n+        use ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.sty {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.int_unification_table\n+                    .borrow_mut()\n+                    .probe_value(vid)\n+                    .is_some()\n+                {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n-            },\n+            }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.float_unification_table\n+                    .borrow_mut()\n+                    .probe_value(vid)\n+                    .is_some()\n+                {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n                 }\n-            },\n+            }\n             _ => Neither,\n         }\n     }\n@@ -590,17 +611,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (0..int_unification_table.len())\n                     .map(|i| ty::IntVid { index: i as u32 })\n                     .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v))\n-            ).chain(\n+                    .map(|v| self.tcx.mk_int_var(v)),\n+            )\n+            .chain(\n                 (0..float_unification_table.len())\n                     .map(|i| ty::FloatVid { index: i as u32 })\n                     .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v))\n-            ).collect()\n+                    .map(|v| self.tcx.mk_float_var(v)),\n+            )\n+            .collect()\n     }\n \n-    fn combine_fields(&'a self, trace: TypeTrace<'tcx>, param_env: ty::ParamEnv<'tcx>)\n-                      -> CombineFields<'a, 'gcx, 'tcx> {\n+    fn combine_fields(\n+        &'a self,\n+        trace: TypeTrace<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> CombineFields<'a, 'gcx, 'tcx> {\n         CombineFields {\n             infcx: self,\n             trace,\n@@ -627,7 +653,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // escaping obligations in the main cx. In those cases, you can\n     // use this function.\n     pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-        where F: FnOnce(&Self) -> R\n+    where\n+        F: FnOnce(&Self) -> R,\n     {\n         let flag = self.in_snapshot.get();\n         self.in_snapshot.set(false);\n@@ -653,33 +680,31 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n-            _in_progress_tables: self.in_progress_tables.map(|tables| {\n-                tables.borrow()\n-            })\n+            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n         }\n     }\n \n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_constraints_snapshot,\n-                               region_obligations_snapshot,\n-                               universe,\n-                               was_in_snapshot,\n-                               _in_progress_tables } = snapshot;\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot,\n+            universe,\n+            was_in_snapshot,\n+            _in_progress_tables,\n+        } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n         self.universe.set(universe);\n \n         self.projection_cache\n             .borrow_mut()\n             .rollback_to(projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .rollback_to(type_snapshot);\n+        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n         self.int_unification_table\n             .borrow_mut()\n             .rollback_to(int_snapshot);\n@@ -695,27 +720,25 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n-        let CombinedSnapshot { projection_cache_snapshot,\n-                               type_snapshot,\n-                               int_snapshot,\n-                               float_snapshot,\n-                               region_constraints_snapshot,\n-                               region_obligations_snapshot: _,\n-                               universe: _,\n-                               was_in_snapshot,\n-                               _in_progress_tables } = snapshot;\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot: _,\n+            universe: _,\n+            was_in_snapshot,\n+            _in_progress_tables,\n+        } = snapshot;\n \n         self.in_snapshot.set(was_in_snapshot);\n \n         self.projection_cache\n             .borrow_mut()\n             .commit(&projection_cache_snapshot);\n-        self.type_variables\n-            .borrow_mut()\n-            .commit(type_snapshot);\n-        self.int_unification_table\n-            .borrow_mut()\n-            .commit(int_snapshot);\n+        self.type_variables.borrow_mut().commit(type_snapshot);\n+        self.int_unification_table.borrow_mut().commit(int_snapshot);\n         self.float_unification_table\n             .borrow_mut()\n             .commit(float_snapshot);\n@@ -724,7 +747,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings\n-    pub fn commit_unconditionally<R, F>(&self, f: F) -> R where\n+    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n+    where\n         F: FnOnce() -> R,\n     {\n         debug!(\"commit()\");\n@@ -735,23 +759,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n-    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>\n+    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n     {\n         debug!(\"commit_if_ok()\");\n         let snapshot = self.start_snapshot();\n         let r = f(&snapshot);\n         debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n-            Ok(_) => { self.commit_from(snapshot); }\n-            Err(_) => { self.rollback_to(\"commit_if_ok -- error\", snapshot); }\n+            Ok(_) => {\n+                self.commit_from(snapshot);\n+            }\n+            Err(_) => {\n+                self.rollback_to(\"commit_if_ok -- error\", snapshot);\n+            }\n         }\n         r\n     }\n \n     // Execute `f` in a snapshot, and commit the bindings it creates\n-    pub fn in_snapshot<T, F>(&self, f: F) -> T where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T\n+    pub fn in_snapshot<T, F>(&self, f: F) -> T\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> T,\n     {\n         debug!(\"in_snapshot()\");\n         let snapshot = self.start_snapshot();\n@@ -761,7 +791,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<R, F>(&self, f: F) -> R where\n+    pub fn probe<R, F>(&self, f: F) -> R\n+    where\n         F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n     {\n         debug!(\"probe()\");\n@@ -771,59 +802,57 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         r\n     }\n \n-    pub fn add_given(&self,\n-                     sub: ty::Region<'tcx>,\n-                     sup: ty::RegionVid)\n-    {\n+    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n         self.borrow_region_constraints().add_given(sub, sup);\n     }\n \n-    pub fn can_sub<T>(&self,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      a: T,\n-                      b: T)\n-                      -> UnitResult<'tcx>\n-        where T: at::ToTrace<'tcx>\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n+            self.at(origin, param_env)\n+                .sub(a, b)\n+                .map(|InferOk { obligations: _, .. }| {\n+                    // Ignore obligations, since we are unrolling\n+                    // everything anyway.\n+                })\n         })\n     }\n \n-    pub fn can_eq<T>(&self,\n-                      param_env: ty::ParamEnv<'tcx>,\n-                      a: T,\n-                      b: T)\n-                      -> UnitResult<'tcx>\n-        where T: at::ToTrace<'tcx>\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n     {\n         let origin = &ObligationCause::dummy();\n         self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n+            self.at(origin, param_env)\n+                .eq(a, b)\n+                .map(|InferOk { obligations: _, .. }| {\n+                    // Ignore obligations, since we are unrolling\n+                    // everything anyway.\n+                })\n         })\n     }\n \n-    pub fn sub_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: ty::Region<'tcx>,\n-                       b: ty::Region<'tcx>) {\n+    pub fn sub_regions(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.borrow_region_constraints()\n+            .make_subregion(origin, a, b);\n     }\n \n-    pub fn subtype_predicate(&self,\n-                             cause: &ObligationCause<'tcx>,\n-                             param_env: ty::ParamEnv<'tcx>,\n-                             predicate: &ty::PolySubtypePredicate<'tcx>)\n-        -> Option<InferResult<'tcx, ()>>\n-    {\n+    pub fn subtype_predicate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: &ty::PolySubtypePredicate<'tcx>,\n+    ) -> Option<InferResult<'tcx, ()>> {\n         // Subtle: it's ok to skip the binder here and resolve because\n         // `shallow_resolve` just ignores anything that is not a type\n         // variable, and because type variable's can't (at present, at\n@@ -845,8 +874,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b}, skol_map) =\n-                self.skolemize_late_bound_regions(predicate);\n+            let (\n+                ty::SubtypePredicate {\n+                    a_is_expected,\n+                    a,\n+                    b,\n+                },\n+                skol_map,\n+            ) = self.skolemize_late_bound_regions(predicate);\n \n             let cause_span = cause.span;\n             let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n@@ -856,17 +891,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n-    pub fn region_outlives_predicate(&self,\n-                                     cause: &traits::ObligationCause<'tcx>,\n-                                     predicate: &ty::PolyRegionOutlivesPredicate<'tcx>)\n-        -> UnitResult<'tcx>\n-    {\n+    pub fn region_outlives_predicate(\n+        &self,\n+        cause: &traits::ObligationCause<'tcx>,\n+        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+    ) -> UnitResult<'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate);\n-            let origin =\n-                SubregionOrigin::from_obligation_cause(cause,\n-                                                       || RelateRegionParamBound(cause.span));\n+            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n+                RelateRegionParamBound(cause.span)\n+            });\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n             self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n@@ -888,27 +923,30 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table\n-            .borrow_mut()\n-            .new_key(None)\n+        self.int_unification_table.borrow_mut().new_key(None)\n     }\n \n     pub fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table\n-            .borrow_mut()\n-            .new_key(None)\n+        self.float_unification_table.borrow_mut().new_key(None)\n     }\n \n     /// Create a fresh region variable with the next available index.\n-    ///\n-    /// # Parameters\n-    ///\n-    /// - `origin`: information about why we created this variable, for use\n-    ///   during diagnostics / error-reporting.\n-    pub fn next_region_var(&self, origin: RegionVariableOrigin)\n-                           -> ty::Region<'tcx> {\n+    /// The variable will be created in the maximum universe created\n+    /// thus far, allowing it to name any region created thus far.\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.next_region_var_in_universe(origin, self.universe())\n+    }\n+\n+    /// Create a fresh region variable with the next available index\n+    /// in the given universe; typically, you can use\n+    /// `next_region_var` and just use the maximal universe.\n+    pub fn next_region_var_in_universe(\n+        &self,\n+        origin: RegionVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> ty::Region<'tcx> {\n         let region_var = self.borrow_region_constraints()\n-            .new_region_var(self.universe(), origin);\n+            .new_region_var(universe, origin);\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n@@ -918,22 +956,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin)\n-                               -> ty::Region<'tcx> {\n+    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var(RegionVariableOrigin::NLL(origin))\n     }\n \n-    pub fn var_for_def(&self,\n-                       span: Span,\n-                       param: &ty::GenericParamDef)\n-                       -> Kind<'tcx> {\n+    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    pub fn next_nll_region_var_in_universe(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> ty::Region<'tcx> {\n+        self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n+    }\n+\n+    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> Kind<'tcx> {\n         match param.kind {\n             GenericParamDefKind::Lifetime => {\n                 // Create a region inference variable for the given\n                 // region parameter definition.\n-                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n+                self.next_region_var(EarlyBoundRegion(span, param.name))\n+                    .into()\n             }\n-            GenericParamDefKind::Type {..} => {\n+            GenericParamDefKind::Type { .. } => {\n                 // Create a type inference variable for the given\n                 // type parameter definition. The substitutions are\n                 // for actual parameters that may be referred to by\n@@ -942,12 +986,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id =\n-                    self.type_variables\n-                        .borrow_mut()\n-                        .new_var(self.universe(),\n-                                    false,\n-                                    TypeVariableOrigin::TypeParameterDefinition(span, param.name));\n+                let ty_var_id = self.type_variables.borrow_mut().new_var(\n+                    self.universe(),\n+                    false,\n+                    TypeVariableOrigin::TypeParameterDefinition(span, param.name),\n+                );\n \n                 self.tcx.mk_var(ty_var_id).into()\n             }\n@@ -956,13 +999,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_item(&self,\n-                                 span: Span,\n-                                 def_id: DefId)\n-                                 -> &'tcx Substs<'tcx> {\n-        Substs::for_item(self.tcx, def_id, |param, _| {\n-            self.var_for_def(span, param)\n-        })\n+    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n     }\n \n     /// True if errors have been reported since this infcx was\n@@ -971,11 +1009,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// errors, but where it's hard to be 100% sure (e.g., unresolved\n     /// inference variables, regionck errors).\n     pub fn is_tainted_by_errors(&self) -> bool {\n-        debug!(\"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n-                tainted_by_errors_flag={})\",\n-               self.tcx.sess.err_count(),\n-               self.err_count_on_creation,\n-               self.tainted_by_errors_flag.get());\n+        debug!(\n+            \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n+             tainted_by_errors_flag={})\",\n+            self.tcx.sess.err_count(),\n+            self.err_count_on_creation,\n+            self.tainted_by_errors_flag.get()\n+        );\n \n         if self.tcx.sess.err_count() > self.err_count_on_creation {\n             return true; // errors reported since this infcx was made\n@@ -1018,12 +1058,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n     ) {\n-        self.resolve_regions_and_report_errors_inner(\n-            region_context,\n-            region_map,\n-            outlives_env,\n-            true,\n-        )\n+        self.resolve_regions_and_report_errors_inner(region_context, region_map, outlives_env, true)\n     }\n \n     fn resolve_regions_and_report_errors_inner(\n@@ -1033,22 +1068,28 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         outlives_env: &OutlivesEnvironment<'tcx>,\n         will_later_be_reported_by_nll: bool,\n     ) {\n-        assert!(self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                self.region_obligations.borrow());\n-\n-        let region_rels = &RegionRelations::new(self.tcx,\n-                                                region_context,\n-                                                region_map,\n-                                                outlives_env.free_region_map());\n-        let (var_infos, data) = self.region_constraints.borrow_mut()\n-                                                         .take()\n-                                                         .expect(\"regions already resolved\")\n-                                                         .into_infos_and_data();\n+        assert!(\n+            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.region_obligations.borrow()\n+        );\n+\n+        let region_rels = &RegionRelations::new(\n+            self.tcx,\n+            region_context,\n+            region_map,\n+            outlives_env.free_region_map(),\n+        );\n+        let (var_infos, data) = self.region_constraints\n+            .borrow_mut()\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n         let (lexical_region_resolutions, errors) =\n             lexical_region_resolve::resolve(region_rels, var_infos, data);\n \n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        let old_value = self.lexical_region_resolutions\n+            .replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n \n         if !self.is_tainted_by_errors() {\n@@ -1072,9 +1113,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// translate them into the form that the NLL solver\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(self.region_obligations.borrow().is_empty(),\n-                \"region_obligations not empty: {:#?}\",\n-                self.region_obligations.borrow());\n+        assert!(\n+            self.region_obligations.borrow().is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.region_obligations.borrow()\n+        );\n \n         self.borrow_region_constraints().take_and_reset_data()\n     }\n@@ -1095,10 +1138,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// called. This is used only during NLL processing to \"hand off\" ownership\n     /// of the set of region vairables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self.region_constraints.borrow_mut()\n-                                                         .take()\n-                                                         .expect(\"regions already resolved\")\n-                                                         .into_infos_and_data();\n+        let (var_infos, data) = self.region_constraints\n+            .borrow_mut()\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n         assert!(data.is_empty());\n         var_infos\n     }\n@@ -1132,32 +1176,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.type_variables.borrow_mut()\n-                                   .probe(v)\n-                                   .known()\n-                                   .map(|t| self.shallow_resolve(t))\n-                                   .unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => {\n-                self.int_unification_table\n+                self.type_variables\n                     .borrow_mut()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(self.tcx))\n+                    .probe(v)\n+                    .known()\n+                    .map(|t| self.shallow_resolve(t))\n                     .unwrap_or(typ)\n             }\n \n-            ty::Infer(ty::FloatVar(v)) => {\n-                self.float_unification_table\n-                    .borrow_mut()\n-                    .probe_value(v)\n-                    .map(|v| v.to_type(self.tcx))\n-                    .unwrap_or(typ)\n-            }\n+            ty::Infer(ty::IntVar(v)) => self.int_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.tcx))\n+                .unwrap_or(typ),\n \n-            _ => {\n-                typ\n-            }\n+            ty::Infer(ty::FloatVar(v)) => self.float_unification_table\n+                .borrow_mut()\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.tcx))\n+                .unwrap_or(typ),\n+\n+            _ => typ,\n         }\n     }\n \n@@ -1166,7 +1205,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         /*!\n          * Where possible, replaces type/int/float variables in\n@@ -1190,20 +1230,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// resolved type, so it's more efficient than\n     /// `resolve_type_vars_if_possible()`.\n     pub fn any_unresolved_type_vars<T>(&self, value: &T) -> bool\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::UnresolvedTypeFinder::new(self);\n         value.visit_with(&mut r)\n     }\n \n     pub fn resolve_type_and_region_vars_if_possible<T>(&self, value: &T) -> T\n-        where T: TypeFoldable<'tcx>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         let mut r = resolve::OpportunisticTypeAndRegionResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n-    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n          * `value`. Region inference must have been run already (e.g.,\n@@ -1228,12 +1270,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // types using one of these methods, and should not call span_err directly for such\n     // errors.\n \n-    pub fn type_error_struct_with_diag<M>(&self,\n-                                          sp: Span,\n-                                          mk_diag: M,\n-                                          actual_ty: Ty<'tcx>)\n-                                          -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n+    pub fn type_error_struct_with_diag<M>(\n+        &self,\n+        sp: Span,\n+        mk_diag: M,\n+        actual_ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx>\n+    where\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n         debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n@@ -1246,12 +1290,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         mk_diag(self.ty_to_string(actual_ty))\n     }\n \n-    pub fn report_mismatched_types(&self,\n-                                   cause: &ObligationCause<'tcx>,\n-                                   expected: Ty<'tcx>,\n-                                   actual: Ty<'tcx>,\n-                                   err: TypeError<'tcx>)\n-                                   -> DiagnosticBuilder<'tcx> {\n+    pub fn report_mismatched_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let trace = TypeTrace::types(cause, true, expected, actual);\n         self.report_and_explain_type_error(trace, &err)\n     }\n@@ -1260,13 +1305,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>)\n-        -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-        where T : TypeFoldable<'tcx>\n+        value: &ty::Binder<T>,\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.replace_late_bound_regions(\n-            value,\n-            |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n+        self.tcx.replace_late_bound_regions(value, |br| {\n+            self.next_region_var(LateBoundRegion(span, br, lbrct))\n+        })\n     }\n \n     /// Given a higher-ranked projection predicate like:\n@@ -1284,43 +1330,51 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ///\n     /// See `higher_ranked_match` in `higher_ranked/mod.rs` for more\n     /// details.\n-    pub fn match_poly_projection_predicate(&self,\n-                                           cause: ObligationCause<'tcx>,\n-                                           param_env: ty::ParamEnv<'tcx>,\n-                                           match_a: ty::PolyProjectionPredicate<'tcx>,\n-                                           match_b: ty::TraitRef<'tcx>)\n-                                           -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n-    {\n+    pub fn match_poly_projection_predicate(\n+        &self,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        match_a: ty::PolyProjectionPredicate<'tcx>,\n+        match_b: ty::TraitRef<'tcx>,\n+    ) -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>> {\n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n         let trace = TypeTrace {\n             cause,\n-            values: TraitRefs(ExpectedFound::new(true, match_pair.skip_binder().0, match_b))\n+            values: TraitRefs(ExpectedFound::new(\n+                true,\n+                match_pair.skip_binder().0,\n+                match_b,\n+            )),\n         };\n \n         let mut combine = self.combine_fields(trace, param_env);\n         let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n-        Ok(InferOk { value: result, obligations: combine.obligations })\n+        Ok(InferOk {\n+            value: result,\n+            obligations: combine.obligations,\n+        })\n     }\n \n     /// See `verify_generic_bound` method in `region_constraints`\n-    pub fn verify_generic_bound(&self,\n-                                origin: SubregionOrigin<'tcx>,\n-                                kind: GenericKind<'tcx>,\n-                                a: ty::Region<'tcx>,\n-                                bound: VerifyBound<'tcx>) {\n-        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\",\n-               kind,\n-               a,\n-               bound);\n-\n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n-    }\n-\n-    pub fn type_moves_by_default(&self,\n-                                 param_env: ty::ParamEnv<'tcx>,\n-                                 ty: Ty<'tcx>,\n-                                 span: Span)\n-                                 -> bool {\n+    pub fn verify_generic_bound(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n+\n+        self.borrow_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n+    }\n+\n+    pub fn type_moves_by_default(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         // Even if the type may have no inference variables, during\n         // type-checking closure types are in local tables only.\n@@ -1342,11 +1396,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Obtains the latest type of the given closure; this may be a\n     /// closure in the current function, in which case its\n     /// `ClosureKind` may not yet be known.\n-    pub fn closure_kind(&self,\n-                        closure_def_id: DefId,\n-                        closure_substs: ty::ClosureSubsts<'tcx>)\n-                        -> Option<ty::ClosureKind>\n-    {\n+    pub fn closure_kind(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_substs: ty::ClosureSubsts<'tcx>,\n+    ) -> Option<ty::ClosureKind> {\n         let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self.tcx);\n         let closure_kind_ty = self.shallow_resolve(&closure_kind_ty);\n         closure_kind_ty.to_opt_closure_kind()\n@@ -1359,7 +1413,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_sig(\n         &self,\n         def_id: DefId,\n-        substs: ty::ClosureSubsts<'tcx>\n+        substs: ty::ClosureSubsts<'tcx>,\n     ) -> ty::PolyFnSig<'tcx> {\n         let closure_sig_ty = substs.closure_sig_ty(def_id, self.tcx);\n         let closure_sig_ty = self.shallow_resolve(&closure_sig_ty);\n@@ -1368,29 +1422,32 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     /// Normalizes associated types in `value`, potentially returning\n     /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(&self,\n-                                                      span: Span,\n-                                                      body_id: ast::NodeId,\n-                                                      param_env: ty::ParamEnv<'tcx>,\n-                                                      value: &T)\n-                                                      -> InferOk<'tcx, T>\n-        where T : TypeFoldable<'tcx>\n+    pub fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: ast::NodeId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n     {\n         debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n         let mut selcx = traits::SelectionContext::new(self);\n         let cause = ObligationCause::misc(span, body_id);\n         let traits::Normalized { value, obligations } =\n             traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value,\n-            obligations);\n+        debug!(\n+            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value, obligations\n+        );\n         InferOk { value, obligations }\n     }\n \n     pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(\n-            self.region_constraints.borrow_mut(),\n-            |c| c.as_mut().expect(\"region constraints already solved\"))\n+        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n+            c.as_mut().expect(\"region constraints already solved\")\n+        })\n     }\n \n     /// Clears the selection, evaluation, and projection cachesThis is useful when\n@@ -1423,14 +1480,15 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n         self.cause.span\n     }\n \n-    pub fn types(cause: &ObligationCause<'tcx>,\n-                 a_is_expected: bool,\n-                 a: Ty<'tcx>,\n-                 b: Ty<'tcx>)\n-                 -> TypeTrace<'tcx> {\n+    pub fn types(\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> TypeTrace<'tcx> {\n         TypeTrace {\n             cause: cause.clone(),\n-            values: Types(ExpectedFound::new(a_is_expected, a, b))\n+            values: Types(ExpectedFound::new(a_is_expected, a, b)),\n         }\n     }\n \n@@ -1440,7 +1498,7 @@ impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {\n             values: Types(ExpectedFound {\n                 expected: tcx.types.err,\n                 found: tcx.types.err,\n-            })\n+            }),\n         }\n     }\n }\n@@ -1482,24 +1540,25 @@ impl<'tcx> SubregionOrigin<'tcx> {\n         }\n     }\n \n-    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>,\n-                                    default: F)\n-                                    -> Self\n-        where F: FnOnce() -> Self\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self\n+    where\n+        F: FnOnce() -> Self,\n     {\n         match cause.code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n-                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span),\n-\n-            traits::ObligationCauseCode::CompareImplMethodObligation { item_name,\n-                                                                       impl_item_def_id,\n-                                                                       trait_item_def_id, } =>\n-                SubregionOrigin::CompareImplMethodObligation {\n-                    span: cause.span,\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                },\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n+            }\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => SubregionOrigin::CompareImplMethodObligation {\n+                span: cause.span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            },\n \n             _ => default(),\n         }\n@@ -1534,8 +1593,10 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-               self.sub_region,\n-               self.sup_type)\n+        write!(\n+            f,\n+            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+            self.sub_region, self.sup_type\n+        )\n     }\n }"}, {"sha": "3450eec8082f37a2bf9885173b7cf438c50c697e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -640,6 +640,12 @@ pub struct LocalDecl<'tcx> {\n     /// Type of this local.\n     pub ty: Ty<'tcx>,\n \n+    /// If the user manually ascribed a type to this variable,\n+    /// e.g. via `let x: T`, then we carry that type here. The MIR\n+    /// borrow checker needs this information since it can affect\n+    /// region inference.\n+    pub user_ty: Option<CanonicalTy<'tcx>>,\n+\n     /// Name of the local, used in debuginfo and pretty-printing.\n     ///\n     /// Note that function arguments can also have this set to `Some(_)`\n@@ -802,6 +808,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         LocalDecl {\n             mutability,\n             ty,\n+            user_ty: None,\n             name: None,\n             source_info: SourceInfo {\n                 span,\n@@ -821,6 +828,7 @@ impl<'tcx> LocalDecl<'tcx> {\n         LocalDecl {\n             mutability: Mutability::Mut,\n             ty: return_ty,\n+            user_ty: None,\n             source_info: SourceInfo {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE,\n@@ -1636,22 +1644,19 @@ pub enum StatementKind<'tcx> {\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(region::Scope),\n \n-    /// Encodes a user's type assertion. These need to be preserved intact so that NLL can respect\n-    /// them. For example:\n-    ///\n-    ///     let (a, b): (T, U) = y;\n-    ///\n-    /// Here we would insert a `UserAssertTy<(T, U)>(y)` instruction to check that the type of `y`\n-    /// is the right thing.\n+    /// Encodes a user's type ascription. These need to be preserved\n+    /// intact so that NLL can respect them. For example:\n     ///\n-    /// `CanonicalTy` is used to capture \"inference variables\" from the user's types. For example:\n+    ///     let a: T = y;\n     ///\n-    ///     let x: Vec<_> = ...;\n-    ///     let y: &u32 = ...;\n+    /// The effect of this annotation is to relate the type `T_y` of the place `y`\n+    /// to the user-given type `T`. The effect depends on the specified variance:\n     ///\n-    /// would result in `Vec<?0>` and `&'?0 u32` respectively (where `?0` is a canonicalized\n-    /// variable).\n-    UserAssertTy(CanonicalTy<'tcx>, Local),\n+    /// - `Covariant` -- requires that `T_y <: T`\n+    /// - `Contravariant` -- requires that `T_y :> T`\n+    /// - `Invariant` -- requires that `T_y == T`\n+    /// - `Bivariant` -- no effect\n+    AscribeUserType(Place<'tcx>, ty::Variance, CanonicalTy<'tcx>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n@@ -1728,8 +1733,8 @@ impl<'tcx> Debug for Statement<'tcx> {\n                 ref outputs,\n                 ref inputs,\n             } => write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs),\n-            UserAssertTy(ref c_ty, ref local) => {\n-                write!(fmt, \"UserAssertTy({:?}, {:?})\", c_ty, local)\n+            AscribeUserType(ref place, ref variance, ref c_ty) => {\n+                write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n             Nop => write!(fmt, \"nop\"),\n         }\n@@ -2616,6 +2621,7 @@ BraceStructTypeFoldableImpl! {\n         is_user_variable,\n         internal,\n         ty,\n+        user_ty,\n         name,\n         source_info,\n         visibility_scope,\n@@ -2652,7 +2658,7 @@ EnumTypeFoldableImpl! {\n         (StatementKind::InlineAsm) { asm, outputs, inputs },\n         (StatementKind::Validate)(a, b),\n         (StatementKind::EndRegion)(a),\n-        (StatementKind::UserAssertTy)(a, b),\n+        (StatementKind::AscribeUserType)(a, v, b),\n         (StatementKind::Nop),\n     }\n }"}, {"sha": "0beb5ac0a3cb51e42e9e053a2f751b264ae11715", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -144,11 +144,12 @@ macro_rules! make_mir_visitor {\n                 self.super_operand(operand, location);\n             }\n \n-            fn visit_user_assert_ty(&mut self,\n-                                    c_ty: & $($mutability)* CanonicalTy<'tcx>,\n-                                    local: & $($mutability)* Local,\n-                                    location: Location) {\n-                self.super_user_assert_ty(c_ty, local, location);\n+            fn visit_ascribe_user_ty(&mut self,\n+                                     place: & $($mutability)* Place<'tcx>,\n+                                     variance: & $($mutability)* ty::Variance,\n+                                     c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                     location: Location) {\n+                self.super_ascribe_user_ty(place, variance, c_ty, location);\n             }\n \n             fn visit_place(&mut self,\n@@ -386,9 +387,12 @@ macro_rules! make_mir_visitor {\n                             self.visit_operand(input, location);\n                         }\n                     }\n-                    StatementKind::UserAssertTy(ref $($mutability)* c_ty,\n-                                                ref $($mutability)* local) => {\n-                        self.visit_user_assert_ty(c_ty, local, location);\n+                    StatementKind::AscribeUserType(\n+                        ref $($mutability)* place,\n+                        ref $($mutability)* variance,\n+                        ref $($mutability)* c_ty,\n+                    ) => {\n+                        self.visit_ascribe_user_ty(place, variance, c_ty, location);\n                     }\n                     StatementKind::Nop => {}\n                 }\n@@ -629,12 +633,13 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n-            fn super_user_assert_ty(&mut self,\n-                                    c_ty: & $($mutability)* CanonicalTy<'tcx>,\n-                                    local: & $($mutability)* Local,\n-                                    location: Location) {\n+            fn super_ascribe_user_ty(&mut self,\n+                                     place: & $($mutability)* Place<'tcx>,\n+                                     _variance: & $($mutability)* ty::Variance,\n+                                     c_ty: & $($mutability)* CanonicalTy<'tcx>,\n+                                     location: Location) {\n+                self.visit_place(place, PlaceContext::Validate, location);\n                 self.visit_canonical_ty(c_ty);\n-                self.visit_local(local, PlaceContext::Validate, location);\n             }\n \n             fn super_place(&mut self,\n@@ -716,6 +721,7 @@ macro_rules! make_mir_visitor {\n                 let LocalDecl {\n                     mutability: _,\n                     ref $($mutability)* ty,\n+                    ref $($mutability)* user_ty,\n                     name: _,\n                     ref $($mutability)* source_info,\n                     ref $($mutability)* visibility_scope,\n@@ -727,6 +733,9 @@ macro_rules! make_mir_visitor {\n                     local,\n                     source_info: *source_info,\n                 });\n+                if let Some(user_ty) = user_ty {\n+                    self.visit_canonical_ty(user_ty);\n+                }\n                 self.visit_source_info(source_info);\n                 self.visit_source_scope(visibility_scope);\n             }"}, {"sha": "83d6b715e95bc4681c261bb4c707a198548933de", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -356,8 +356,8 @@ pub struct TypeckTables<'tcx> {\n     /// belongs, but it may not exist if it's a tuple field (`tuple.0`).\n     field_indices: ItemLocalMap<usize>,\n \n-    /// Stores the canonicalized types provided by the user. See also `UserAssertTy` statement in\n-    /// MIR.\n+    /// Stores the canonicalized types provided by the user. See also\n+    /// `AscribeUserType` statement in MIR.\n     user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table"}, {"sha": "bd9dfc6b855144c0c7ea794eaa5aa1945f706f05", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -57,6 +57,7 @@ CloneTypeFoldableAndLiftImpls! {\n     ::ty::ClosureKind,\n     ::ty::IntVarValue,\n     ::ty::ParamTy,\n+    ::ty::Variance,\n     ::syntax_pos::Span,\n }\n "}, {"sha": "0cb8f99efc33fd66cb6a78db907aee2302ae660e", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -92,7 +92,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n             mir::StatementKind::ReadForMatch(_) |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::UserAssertTy(..) |\n+            mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => bx,\n         }\n     }"}, {"sha": "60aeb92d91a6f30b7cf2075a365ebe53b8bf0ab4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -535,10 +535,10 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 // flow_state already handled).\n             }\n             StatementKind::Nop\n-            | StatementKind::UserAssertTy(..)\n+            | StatementKind::AscribeUserType(..)\n             | StatementKind::Validate(..)\n             | StatementKind::StorageLive(..) => {\n-                // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "7e8e1b32d4d98450dfb7b121926effbfa1d4ca0e", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n-use rustc::mir::{Local, Statement, Terminator};\n+use rustc::mir::{Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, RegionVid};\n@@ -175,10 +175,11 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         self.super_terminator(block, terminator, location);\n     }\n \n-    fn visit_user_assert_ty(\n+    fn visit_ascribe_user_ty(\n         &mut self,\n+        _place: &Place<'tcx>,\n+        _variance: &ty::Variance,\n         _c_ty: &CanonicalTy<'tcx>,\n-        _local: &Local,\n         _location: Location,\n     ) {\n     }"}, {"sha": "71345f22e443b455b2cb01b1cee80232570d6801", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -144,10 +144,10 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n             // EndRegion matters to older NLL/MIR AST borrowck, not to alias NLL\n             StatementKind::EndRegion(..) |\n             StatementKind::Nop |\n-            StatementKind::UserAssertTy(..) |\n+            StatementKind::AscribeUserType(..) |\n             StatementKind::Validate(..) |\n             StatementKind::StorageLive(..) => {\n-                // `Nop`, `UserAssertTy`, `Validate`, and `StorageLive` are irrelevant\n+                // `Nop`, `AscribeUserType`, `Validate`, and `StorageLive` are irrelevant\n                 // to borrow check.\n             }\n             StatementKind::StorageDead(local) => {"}, {"sha": "214628600b370675e5708a51baa90ece318b7a96", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -319,23 +319,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n \n         for variable in self.definitions.indices() {\n+            let scc = self.constraint_sccs.scc(variable);\n+\n             match self.definitions[variable].origin {\n                 NLLRegionVariableOrigin::FreeRegion => {\n                     // For each free, universally quantified region X:\n \n                     // Add all nodes in the CFG to liveness constraints\n-                    let variable_scc = self.constraint_sccs.scc(variable);\n                     self.liveness_constraints.add_all_points(variable);\n-                    self.scc_values.add_all_points(variable_scc);\n+                    self.scc_values.add_all_points(scc);\n \n                     // Add `end(X)` into the set for X.\n-                    self.add_element_to_scc_of(variable, variable);\n+                    self.scc_values.add_element(scc, variable);\n                 }\n \n                 NLLRegionVariableOrigin::BoundRegion(ui) => {\n                     // Each placeholder region X outlives its\n-                    // associated universe but nothing else.\n-                    self.add_element_to_scc_of(variable, ui);\n+                    // associated universe but nothing else. Every\n+                    // placeholder region is always in a universe that\n+                    // contains `ui` -- but when placeholder regions\n+                    // are placed into an SCC, that SCC may include\n+                    // things from other universes that do not include\n+                    // `ui`.\n+                    let scc_universe = self.scc_universes[scc];\n+                    if ui.is_subset_of(scc_universe) {\n+                        self.scc_values.add_element(scc, ui);\n+                    } else {\n+                        self.add_incompatible_universe(scc);\n+                    }\n                 }\n \n                 NLLRegionVariableOrigin::Existential => {\n@@ -383,13 +394,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_universes[scc]\n     }\n \n-    /// Adds `elem` to the value of the SCC in which `v` appears.\n-    fn add_element_to_scc_of(&mut self, v: RegionVid, elem: impl ToElementIndex) {\n-        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n-        let scc = self.constraint_sccs.scc(v);\n-        self.scc_values.add_element(scc, elem);\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -516,22 +520,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // merge the bits.\n                 self.scc_values.add_region(scc_a, scc_b);\n             } else {\n-                // Otherwise, the only way for `A` to outlive `B`\n-                // is for it to outlive static. This is actually stricter\n-                // than necessary: ideally, we'd support bounds like `for<'a: 'b`>`\n-                // that might then allow us to approximate `'a` with `'b` and not\n-                // `'static`. But it will have to do for now.\n-                //\n-                // The code here is a bit hacky: we grab the current\n-                // value of the SCC in which `'static` appears, but\n-                // this value may not be fully computed yet. That's ok\n-                // though: it will contain the base liveness values,\n-                // which include (a) the static free region element\n-                // and (b) all the points in the CFG, so it is \"good\n-                // enough\" to bring it in here for our purposes.\n-                let fr_static = self.universal_regions.fr_static;\n-                let scc_static = constraint_sccs.scc(fr_static);\n-                self.scc_values.add_region(scc_a, scc_static);\n+                self.add_incompatible_universe(scc_a);\n             }\n         }\n \n@@ -563,6 +552,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .all(|u| u.is_subset_of(universe_a))\n     }\n \n+    /// Extend `scc` so that it can outlive some placeholder region\n+    /// from a universe it can't name; at present, the only way for\n+    /// this to be true is if `scc` outlives `'static`. This is\n+    /// actually stricter than necessary: ideally, we'd support bounds\n+    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// `'a` with `'b` and not `'static`. But it will have to do for\n+    /// now.\n+    fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {\n+        let fr_static = self.universal_regions.fr_static;\n+        self.scc_values.add_all_points(scc);\n+        self.scc_values.add_element(scc, fr_static);\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:"}, {"sha": "d77863d598f663792fd9a7f0edd0b6779c5bb7f6", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{BasicBlock, Local, Location, Mir, Statement, StatementKind};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -112,8 +112,13 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_closure_substs: substs={:?}\", substs);\n     }\n \n-    fn visit_user_assert_ty(&mut self, _c_ty: &mut CanonicalTy<'tcx>, _local: &mut Local,\n-                            _location: Location) {\n+    fn visit_ascribe_user_ty(\n+        &mut self,\n+        _place: &mut Place<'tcx>,\n+        _variance: &mut ty::Variance,\n+        _c_ty: &mut CanonicalTy<'tcx>,\n+        _location: Location,\n+    ) {\n         // User-assert-ty statements represent types that the user added explicitly.\n         // We don't want to erase the regions from these types: rather, we want to\n         // add them as constraints at type-check time."}, {"sha": "de96539ec30f106a8e3df51123b22657992f89ce", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 58, "deletions": 36, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -17,7 +17,9 @@ use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n+use borrow_check::nll::type_check::free_region_relations::{\n+    CreateResult, UniversalRegionRelations,\n+};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n@@ -246,10 +248,12 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(constant, constant.ty);\n \n         if let Some(user_ty) = constant.user_ty {\n-            if let Err(terr) =\n-                self.cx\n-                    .eq_canonical_type_and_type(user_ty, constant.ty, location.boring())\n-            {\n+            if let Err(terr) = self.cx.relate_type_and_user_type(\n+                constant.ty,\n+                ty::Variance::Invariant,\n+                user_ty,\n+                location.boring(),\n+            ) {\n                 span_mirbug!(\n                     self,\n                     constant,\n@@ -271,6 +275,25 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n         self.super_local_decl(local, local_decl);\n         self.sanitize_type(local_decl, local_decl.ty);\n+\n+        if let Some(user_ty) = local_decl.user_ty {\n+            if let Err(terr) = self.cx.relate_type_and_user_type(\n+                local_decl.ty,\n+                ty::Variance::Invariant,\n+                user_ty,\n+                Locations::All,\n+            ) {\n+                span_mirbug!(\n+                    self,\n+                    local,\n+                    \"bad user type on variable {:?}: {:?} != {:?} ({:?})\",\n+                    local,\n+                    local_decl.ty,\n+                    local_decl.user_ty,\n+                    terr,\n+                );\n+            }\n+        }\n     }\n \n     fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -850,15 +873,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n-    fn eq_canonical_type_and_type(\n+    fn relate_type_and_user_type(\n         &mut self,\n-        a: CanonicalTy<'tcx>,\n-        b: Ty<'tcx>,\n+        a: Ty<'tcx>,\n+        v: ty::Variance,\n+        b: CanonicalTy<'tcx>,\n         locations: Locations,\n     ) -> Fallible<()> {\n-        relate_tys::eq_canonical_type_and_type(\n+        relate_tys::relate_type_and_user_type(\n             self.infcx,\n             a,\n+            v,\n             b,\n             locations,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n@@ -879,8 +904,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let is_temp = if let Place::Local(l) = *place {\n-                    l != RETURN_PLACE &&\n-                    !mir.local_decls[l].is_user_variable.is_some()\n+                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n                 } else {\n                     false\n                 };\n@@ -905,9 +929,10 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(user_ty) = self.rvalue_user_ty(rv) {\n-                    if let Err(terr) = self.eq_canonical_type_and_type(\n-                        user_ty,\n+                    if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n+                        ty::Variance::Invariant,\n+                        user_ty,\n                         location.boring(),\n                     ) {\n                         span_mirbug!(\n@@ -955,15 +980,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::UserAssertTy(c_ty, local) => {\n-                let local_ty = mir.local_decls()[local].ty;\n-                if let Err(terr) = self.eq_canonical_type_and_type(c_ty, local_ty, Locations::All) {\n+            StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n+                let place_ty = place.ty(mir, tcx).to_ty(tcx);\n+                if let Err(terr) =\n+                    self.relate_type_and_user_type(place_ty, variance, c_ty, Locations::All)\n+                {\n                     span_mirbug!(\n                         self,\n                         stmt,\n-                        \"bad type assert ({:?} = {:?}): {:?}\",\n+                        \"bad type assert ({:?} <: {:?}): {:?}\",\n+                        place_ty,\n                         c_ty,\n-                        local_ty,\n                         terr\n                     );\n                 }\n@@ -1142,8 +1169,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n                 let is_temp = if let Place::Local(l) = *dest {\n-                    l != RETURN_PLACE &&\n-                    !mir.local_decls[l].is_user_variable.is_some()\n+                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n                 } else {\n                     false\n                 };\n@@ -1562,30 +1588,26 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// If this rvalue supports a user-given type annotation, then\n     /// extract and return it. This represents the final type of the\n     /// rvalue and will be unified with the inferred type.\n-    fn rvalue_user_ty(\n-        &self,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> Option<CanonicalTy<'tcx>> {\n+    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<CanonicalTy<'tcx>> {\n         match rvalue {\n-            Rvalue::Use(_) |\n-            Rvalue::Repeat(..) |\n-            Rvalue::Ref(..) |\n-            Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n-            Rvalue::BinaryOp(..) |\n-            Rvalue::CheckedBinaryOp(..) |\n-            Rvalue::NullaryOp(..) |\n-            Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) =>\n-                None,\n+            Rvalue::Use(_)\n+            | Rvalue::Repeat(..)\n+            | Rvalue::Ref(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::Cast(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..) => None,\n \n             Rvalue::Aggregate(aggregate, _) => match **aggregate {\n                 AggregateKind::Adt(_, _, _, user_ty, _) => user_ty,\n                 AggregateKind::Array(_) => None,\n                 AggregateKind::Tuple => None,\n                 AggregateKind::Closure(_, _) => None,\n                 AggregateKind::Generator(_, _, _) => None,\n-            }\n+            },\n         }\n     }\n "}, {"sha": "06cb44ac9714d0e287eeed16c4c524554dda21a4", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 280, "deletions": 68, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -21,8 +21,8 @@ use rustc::ty::subst::Kind;\n use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use std::mem;\n \n+/// Adds sufficient constraints to ensure that `a <: b`.\n pub(super) fn sub_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n@@ -41,6 +41,7 @@ pub(super) fn sub_types<'tcx>(\n     Ok(())\n }\n \n+/// Adds sufficient constraints to ensure that `a == b`.\n pub(super) fn eq_types<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n     a: Ty<'tcx>,\n@@ -59,28 +60,38 @@ pub(super) fn eq_types<'tcx>(\n     Ok(())\n }\n \n-pub(super) fn eq_canonical_type_and_type<'tcx>(\n+/// Adds sufficient constraints to ensure that `a <: b`, where `b` is\n+/// a user-given type (which means it may have canonical variables\n+/// encoding things like `_`).\n+pub(super) fn relate_type_and_user_type<'tcx>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n-    a: CanonicalTy<'tcx>,\n-    b: Ty<'tcx>,\n+    a: Ty<'tcx>,\n+    v: ty::Variance,\n+    b: CanonicalTy<'tcx>,\n     locations: Locations,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\n-        \"eq_canonical_type_and_type(a={:?}, b={:?}, locations={:?})\",\n+        \"sub_type_and_user_type(a={:?}, b={:?}, locations={:?})\",\n         a, b, locations\n     );\n     let Canonical {\n-        variables: a_variables,\n-        value: a_value,\n-    } = a;\n+        variables: b_variables,\n+        value: b_value,\n+    } = b;\n+\n+    // The `TypeRelating` code assumes that the \"canonical variables\"\n+    // appear in the \"a\" side, so flip `Contravariant` ambient\n+    // variance to get the right relationship.\n+    let v1 = ty::Contravariant.xform(v);\n+\n     TypeRelating::new(\n         infcx,\n-        ty::Variance::Invariant,\n+        v1,\n         locations,\n         borrowck_context,\n-        a_variables,\n-    ).relate(&a_value, &b)?;\n+        b_variables,\n+    ).relate(&b_value, &a)?;\n     Ok(())\n }\n \n@@ -128,7 +139,7 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     /// how can we enforce that? I guess I could add some kind of\n     /// \"minimum universe constraint\" that we can feed to the NLL checker.\n     /// --> also, we know this doesn't happen\n-    canonical_var_values: IndexVec<CanonicalVar, Option<ScopesAndKind<'tcx>>>,\n+    canonical_var_values: IndexVec<CanonicalVar, Option<Kind<'tcx>>>,\n }\n \n #[derive(Clone, Debug)]\n@@ -194,23 +205,44 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         scope\n     }\n \n+    /// When we encounter binders during the type traversal, we record\n+    /// the value to substitute for each of the things contained in\n+    /// that binder. (This will be either a universal placeholder or\n+    /// an existential inference variable.) Given the debruijn index\n+    /// `debruijn` (and name `br`) of some binder we have now\n+    /// encountered, this routine finds the value that we instantiated\n+    /// the region with; to do so, it indexes backwards into the list\n+    /// of ambient scopes `scopes`.\n+    fn lookup_bound_region(\n+        debruijn: ty::DebruijnIndex,\n+        br: &ty::BoundRegion,\n+        first_free_index: ty::DebruijnIndex,\n+        scopes: &[BoundRegionScope],\n+    ) -> RegionVid {\n+        // The debruijn index is a \"reverse index\" into the\n+        // scopes listing. So when we have INNERMOST (0), we\n+        // want the *last* scope pushed, and so forth.\n+        let debruijn_index = debruijn.index() - first_free_index.index();\n+        let scope = &scopes[scopes.len() - debruijn_index - 1];\n+\n+        // Find this bound region in that scope to map to a\n+        // particular region.\n+        scope.map[br]\n+    }\n+\n+    /// If `r` is a bound region, find the scope in which it is bound\n+    /// (from `scopes`) and return the value that we instantiated it\n+    /// with. Otherwise just return `r`.\n     fn replace_bound_region(\n         &self,\n         universal_regions: &UniversalRegions<'tcx>,\n         r: ty::Region<'tcx>,\n+        first_free_index: ty::DebruijnIndex,\n         scopes: &[BoundRegionScope],\n     ) -> RegionVid {\n         match r {\n             ty::ReLateBound(debruijn, br) => {\n-                // The debruijn index is a \"reverse index\" into the\n-                // scopes listing. So when we have INNERMOST (0), we\n-                // want the *last* scope pushed, and so forth.\n-                let debruijn_index = debruijn.index() - ty::INNERMOST.index();\n-                let scope = &scopes[scopes.len() - debruijn_index - 1];\n-\n-                // Find this bound region in that scope to map to a\n-                // particular region.\n-                scope.map[br]\n+                Self::lookup_bound_region(*debruijn, br, first_free_index, scopes)\n             }\n \n             ty::ReVar(v) => *v,\n@@ -219,6 +251,8 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Push a new outlives requirement into our output set of\n+    /// constraints.\n     fn push_outlives(&mut self, sup: RegionVid, sub: RegionVid) {\n         debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n \n@@ -236,46 +270,55 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn equate_var(\n+    /// When we encounter a canonical variable `var` in the output,\n+    /// equate it with `kind`. If the variable has been previously\n+    /// equated, then equate it again.\n+    fn relate_var(\n         &mut self,\n         var: CanonicalVar,\n         b_kind: Kind<'tcx>,\n     ) -> RelateResult<'tcx, Kind<'tcx>> {\n         debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n \n-        // We only encounter canonical variables when equating.\n-        assert_eq!(self.ambient_variance, ty::Variance::Invariant);\n-\n-        // The canonical variable already had a value. Equate that\n-        // value with `b`.\n-        let old_value = self.canonical_var_values[var].clone();\n-        if let Some(ScopesAndKind { scopes, kind }) = old_value {\n-            debug!(\"equate_var: installing kind={:?} scopes={:?}\", kind, scopes);\n-            let old_a_scopes = mem::replace(&mut self.a_scopes, scopes);\n-            let result = self.relate(&kind, &b_kind);\n-            self.a_scopes = old_a_scopes;\n-            debug!(\"equate_var: complete, result = {:?}\", result);\n-            return result;\n-        }\n+        let generalized_kind = match self.canonical_var_values[var] {\n+            Some(v) => v,\n+            None => {\n+                let generalized_kind = self.generalize_value(b_kind);\n+                self.canonical_var_values[var] = Some(generalized_kind);\n+                generalized_kind\n+            }\n+        };\n \n-        // Not yet. Capture the value from the RHS and carry on.\n-        self.canonical_var_values[var] = Some(ScopesAndKind {\n-            scopes: self.b_scopes.clone(),\n-            kind: b_kind,\n-        });\n-        debug!(\n-            \"equate_var: capturing value {:?}\",\n-            self.canonical_var_values[var]\n-        );\n+        // The generalized values we extract from `canonical_var_values` have\n+        // been fully instantiated and hence the set of scopes we have\n+        // doesn't matter -- just to be sure, put an empty vector\n+        // in there.\n+        let old_a_scopes = ::std::mem::replace(&mut self.a_scopes, vec![]);\n+\n+        // Relate the generalized kind to the original one.\n+        let result = self.relate(&generalized_kind, &b_kind);\n+\n+        // Restore the old scopes now.\n+        self.a_scopes = old_a_scopes;\n+\n+        debug!(\"equate_var: complete, result = {:?}\", result);\n+        return result;\n+    }\n \n-        // FIXME -- technically, we should add some sort of\n-        // assertion that this value can be named in the universe\n-        // of the canonical variable. But in practice these\n-        // canonical variables only arise presently in cases where\n-        // they are in the root universe and the main typeck has\n-        // ensured there are no universe errors. So we just kind\n-        // of over look this right now.\n-        Ok(b_kind)\n+    fn generalize_value(\n+        &self,\n+        kind: Kind<'tcx>,\n+    ) -> Kind<'tcx> {\n+        TypeGeneralizer {\n+            type_rel: self,\n+            first_free_index: ty::INNERMOST,\n+            ambient_variance: self.ambient_variance,\n+\n+            // These always correspond to an `_` or `'_` written by\n+            // user, and those are always in the root universe.\n+            universe: ty::UniverseIndex::ROOT,\n+        }.relate(&kind, &kind)\n+            .unwrap()\n     }\n }\n \n@@ -326,7 +369,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         // Watch out for the case that we are matching a `?T` against the\n         // right-hand side.\n         if let ty::Infer(ty::CanonicalTy(var)) = a.sty {\n-            self.equate_var(var, b.into())?;\n+            self.relate_var(var, b.into())?;\n             Ok(a)\n         } else {\n             debug!(\n@@ -348,7 +391,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n         }) = self.borrowck_context\n         {\n             if let ty::ReCanonical(var) = a {\n-                self.equate_var(*var, b.into())?;\n+                self.relate_var(*var, b.into())?;\n                 return Ok(a);\n             }\n \n@@ -357,8 +400,10 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n                 a, b, self.ambient_variance\n             );\n \n-            let v_a = self.replace_bound_region(universal_regions, a, &self.a_scopes);\n-            let v_b = self.replace_bound_region(universal_regions, b, &self.b_scopes);\n+            let v_a =\n+                self.replace_bound_region(universal_regions, a, ty::INNERMOST, &self.a_scopes);\n+            let v_b =\n+                self.replace_bound_region(universal_regions, b, ty::INNERMOST, &self.b_scopes);\n \n             debug!(\"regions: v_a = {:?}\", v_a);\n             debug!(\"regions: v_b = {:?}\", v_b);\n@@ -425,19 +470,30 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n             self.b_scopes.push(b_scope);\n             self.a_scopes.push(a_scope);\n \n-            // FIXME -- to be fully correct, we would set the ambient\n-            // variance to Covariant here. As is, we will sometimes\n-            // propagate down an ambient variance of Equal -- this in\n-            // turn causes us to report errors in some cases where\n-            // types perhaps *ought* to be equal. See the\n-            // `hr-fn-aau-eq-abu.rs` test for an example. Fixing this\n-            // though is a bit nontrivial: in particular, it would\n-            // require a more involved handling of canonical\n-            // variables, since we would no longer be able to rely on\n-            // having an `==` relationship for canonical variables.\n+            // Reset the ambient variance to covariant. This is needed\n+            // to correctly handle cases like\n+            //\n+            //     for<'a> fn(&'a u32, &'a u3) == for<'b, 'c> fn(&'b u32, &'c u32)\n+            //\n+            // Somewhat surprisingly, these two types are actually\n+            // **equal**, even though the one on the right looks more\n+            // polymorphic. The reason is due to subtyping. To see it,\n+            // consider that each function can call the other:\n+            //\n+            // - The left function can call the right with `'b` and\n+            //   `'c` both equal to `'a`\n+            //\n+            // - The right function can call the left with `'a` set to\n+            //   `{P}`, where P is the point in the CFG where the call\n+            //   itself occurs. Note that `'b` and `'c` must both\n+            //   include P. At the point, the call works because of\n+            //   subtyping (i.e., `&'b u32 <: &{P} u32`).\n+            let variance = ::std::mem::replace(&mut self.ambient_variance, ty::Variance::Covariant);\n \n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n+            self.ambient_variance = variance;\n+\n             self.b_scopes.pop().unwrap();\n             self.a_scopes.pop().unwrap();\n         }\n@@ -458,8 +514,17 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n             self.a_scopes.push(a_scope);\n             self.b_scopes.push(b_scope);\n \n+            // Reset ambient variance to contravariance. See the\n+            // covariant case above for an explanation.\n+            let variance = ::std::mem::replace(\n+                &mut self.ambient_variance,\n+                ty::Variance::Contravariant,\n+            );\n+\n             self.relate(a.skip_binder(), b.skip_binder())?;\n \n+            self.ambient_variance = variance;\n+\n             self.b_scopes.pop().unwrap();\n             self.a_scopes.pop().unwrap();\n         }\n@@ -468,7 +533,14 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n     }\n }\n \n-struct ScopeInstantiator<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n+/// When we encounter a binder like `for<..> fn(..)`, we actually have\n+/// to walk the `fn` value to find all the values bound by the `for`\n+/// (these are not explicitly present in the ty representation right\n+/// now). This visitor handles that: it descends the type, tracking\n+/// binder depth, and finds late-bound regions targeting the\n+/// `for<..`>.  For each of those, it creates an entry in\n+/// `bound_region_scope`.\n+struct ScopeInstantiator<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n@@ -510,3 +582,143 @@ impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n         false\n     }\n }\n+\n+/// The \"type generalize\" is used when handling inference variables.\n+///\n+/// The basic strategy for handling a constraint like `?A <: B` is to\n+/// apply a \"generalization strategy\" to the type `B` -- this replaces\n+/// all the lifetimes in the type `B` with fresh inference\n+/// variables. (You can read more about the strategy in this [blog\n+/// post].)\n+///\n+/// As an example, if we had `?A <: &'x u32`, we would generalize `&'x\n+/// u32` to `&'0 u32` where `'0` is a fresh variable. This becomes the\n+/// value of `A`. Finally, we relate `&'0 u32 <: &'x u32`, which\n+/// establishes `'0: 'x` as a constraint.\n+///\n+/// As a side-effect of this generalization procedure, we also replace\n+/// all the bound regions that we have traversed with concrete values,\n+/// so that the resulting generalized type is independent from the\n+/// scopes.\n+///\n+/// [blog post]: https://is.gd/0hKvIr\n+struct TypeGeneralizer<'me, 'bccx: 'me, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    type_rel: &'me TypeRelating<'me, 'bccx, 'gcx, 'tcx>,\n+\n+    /// After we generalize this type, we are going to relative it to\n+    /// some other type. What will be the variance at this point?\n+    ambient_variance: ty::Variance,\n+\n+    first_free_index: ty::DebruijnIndex,\n+\n+    universe: ty::UniverseIndex,\n+}\n+\n+impl TypeRelation<'me, 'gcx, 'tcx> for TypeGeneralizer<'me, 'bbcx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'me, 'gcx, 'tcx> {\n+        self.type_rel.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"TypeGeneralizer::relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"TypeGeneralizer::relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, _: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"TypeGeneralizer::tys(a={:?})\", a,);\n+\n+        match a.sty {\n+            ty::Infer(ty::TyVar(_)) | ty::Infer(ty::IntVar(_)) | ty::Infer(ty::FloatVar(_)) => {\n+                bug!(\n+                    \"unexpected inference variable encountered in NLL generalization: {:?}\",\n+                    a\n+                );\n+            }\n+\n+            _ => relate::super_relate_tys(self, a, a),\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        _: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"TypeGeneralizer::regions(a={:?})\", a,);\n+\n+        if let ty::ReLateBound(debruijn, _) = a {\n+            if *debruijn < self.first_free_index {\n+                return Ok(a);\n+            }\n+        }\n+\n+        // For now, we just always create a fresh region variable to\n+        // replace all the regions in the source type. In the main\n+        // type checker, we special case the case where the ambient\n+        // variance is `Invariant` and try to avoid creating a fresh\n+        // region variable, but since this comes up so much less in\n+        // NLL (only when users use `_` etc) it is much less\n+        // important.\n+        //\n+        // As an aside, since these new variables are created in\n+        // `self.universe` universe, this also serves to enforce the\n+        // universe scoping rules.\n+        //\n+        // FIXME(#54105) -- if the ambient variance is bivariant,\n+        // though, we may however need to check well-formedness or\n+        // risk a problem like #41677 again.\n+\n+        let replacement_region_vid = self.type_rel\n+            .infcx\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, self.universe);\n+\n+        Ok(replacement_region_vid)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        _: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"TypeGeneralizer::binders(a={:?})\", a,);\n+\n+        self.first_free_index.shift_in(1);\n+        let result = self.relate(a.skip_binder(), a.skip_binder())?;\n+        self.first_free_index.shift_out(1);\n+        Ok(ty::Binder::bind(result))\n+    }\n+}"}, {"sha": "bfb6daee6041ea80f58e2a80a2bbf5e18ad284ac", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -106,7 +106,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     remainder_scope,\n                     init_scope,\n                     pattern,\n-                    ty,\n                     initializer,\n                     lint_level\n                 } => {\n@@ -136,24 +135,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             opt_destruction_scope.map(|de|(de, source_info)), block, |this| {\n                                 let scope = (init_scope, source_info);\n                                 this.in_scope(scope, lint_level, block, |this| {\n-                                    this.expr_into_pattern(block, ty, pattern, init)\n+                                    this.expr_into_pattern(block, pattern, init)\n                                 })\n                             }));\n                     } else {\n                         scope = this.declare_bindings(\n                             None, remainder_span, lint_level, slice::from_ref(&pattern),\n                             ArmHasGuard(false), None);\n \n-                        // FIXME(#47184): We currently only insert `UserAssertTy` statements for\n-                        // patterns that are bindings, this is as we do not want to deconstruct\n-                        // the type being assertion to match the pattern.\n-                        if let PatternKind::Binding { var, .. } = *pattern.kind {\n-                            if let Some(ty) = ty {\n-                                this.user_assert_ty(block, ty, var, span);\n-                            }\n-                        }\n-\n-                        this.visit_bindings(&pattern, &mut |this, _, _, _, node, span, _| {\n+                        this.visit_bindings(&pattern, None, &mut |this, _, _, _, node, span, _, _| {\n                             this.storage_live_binding(block, node, span, OutsideGuard);\n                             this.schedule_drop_for_binding(node, span, OutsideGuard);\n                         })"}, {"sha": "5708ac4e6b50f7dfd58a57a374c9c8c87e366aa0", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -296,6 +296,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let ptr_temp = this.local_decls.push(LocalDecl {\n                         mutability: Mutability::Mut,\n                         ty: ptr_ty,\n+                        user_ty: None,\n                         name: None,\n                         source_info,\n                         visibility_scope: source_info.scope,"}, {"sha": "cef1fb77e5c9e68ade18b997619af33cf5a4e207", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 551, "deletions": 312, "changes": 863, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -13,16 +13,16 @@\n //! includes the high-level algorithm, the submodules contain the\n //! details.\n \n+use build::scope::{CachedBlock, DropKind};\n+use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n-use build::scope::{CachedBlock, DropKind};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::bitvec::BitArray;\n-use rustc::ty::{self, Ty};\n-use rustc::mir::*;\n-use rustc::hir;\n use hair::*;\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::ty::{self, CanonicalTy, Ty};\n+use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Name, NodeId};\n use syntax_pos::Span;\n \n@@ -37,13 +37,14 @@ mod util;\n pub(crate) struct ArmHasGuard(pub bool);\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n-    pub fn match_expr(&mut self,\n-                      destination: &Place<'tcx>,\n-                      span: Span,\n-                      mut block: BasicBlock,\n-                      discriminant: ExprRef<'tcx>,\n-                      arms: Vec<Arm<'tcx>>)\n-                      -> BlockAnd<()> {\n+    pub fn match_expr(\n+        &mut self,\n+        destination: &Place<'tcx>,\n+        span: Span,\n+        mut block: BasicBlock,\n+        discriminant: ExprRef<'tcx>,\n+        arms: Vec<Arm<'tcx>>,\n+    ) -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n         let discriminant_span = discriminant.span();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n@@ -67,68 +68,83 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n         let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n         let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n-        self.cfg.push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n+        self.cfg\n+            .push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n \n         let source_info = self.source_info(discriminant_span);\n         let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n             // The region is unknown at this point; we rely on NLL\n             // inference to find an appropriate one. Therefore you can\n             // only use this when NLL is turned on.\n             assert!(tcx.use_mir_borrowck());\n-            let borrowed_input =\n-                Rvalue::Ref(tcx.types.re_empty, BorrowKind::Shared, discriminant_place.clone());\n+            let borrowed_input = Rvalue::Ref(\n+                tcx.types.re_empty,\n+                BorrowKind::Shared,\n+                discriminant_place.clone(),\n+            );\n             let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n             let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n-            self.cfg.push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n+            self.cfg\n+                .push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n             Some(borrowed_input_temp)\n         } else {\n             None\n         };\n \n         let mut arm_blocks = ArmBlocks {\n-            blocks: arms.iter()\n-                        .map(|_| self.cfg.start_new_block())\n-                        .collect(),\n+            blocks: arms.iter().map(|_| self.cfg.start_new_block()).collect(),\n         };\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n-        let arm_bodies: Vec<_> = arms.iter().map(|arm| {\n-            // BUG: use arm lint level\n-            let body = self.hir.mirror(arm.body.clone());\n-            let scope = self.declare_bindings(None, body.span,\n-                                              LintLevel::Inherited,\n-                                              &arm.patterns[..],\n-                                              ArmHasGuard(arm.guard.is_some()),\n-                                              Some((Some(&discriminant_place), discriminant_span)));\n-            (body, scope.unwrap_or(self.source_scope))\n-        }).collect();\n+        let arm_bodies: Vec<_> = arms.iter()\n+            .map(|arm| {\n+                // BUG: use arm lint level\n+                let body = self.hir.mirror(arm.body.clone());\n+                let scope = self.declare_bindings(\n+                    None,\n+                    body.span,\n+                    LintLevel::Inherited,\n+                    &arm.patterns[..],\n+                    ArmHasGuard(arm.guard.is_some()),\n+                    Some((Some(&discriminant_place), discriminant_span)),\n+                );\n+                (body, scope.unwrap_or(self.source_scope))\n+            })\n+            .collect();\n \n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n         let pre_binding_blocks: Vec<_> = (0..candidate_count + 1)\n-            .map(|_| self.cfg.start_new_block()).collect();\n+            .map(|_| self.cfg.start_new_block())\n+            .collect();\n \n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n         // *per arm*. These candidates are kept sorted such that the\n         // highest priority candidate comes first in the list.\n         // (i.e. same order as in source)\n \n-        let candidates: Vec<_> =\n-            arms.iter()\n-                .enumerate()\n-                .flat_map(|(arm_index, arm)| {\n-                    arm.patterns.iter().enumerate()\n-                        .map(move |(pat_index, pat)| {\n-                            (arm_index, pat_index, pat, arm.guard.clone())\n-                        })\n-                })\n-                .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n-                .map(|((arm_index, pat_index, pattern, guard),\n-                       (pre_binding_block, next_candidate_pre_binding_block))| {\n-\n-                    if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n-                                                        borrowed_input_temp.clone()) {\n+        let candidates: Vec<_> = arms.iter()\n+            .enumerate()\n+            .flat_map(|(arm_index, arm)| {\n+                arm.patterns\n+                    .iter()\n+                    .enumerate()\n+                    .map(move |(pat_index, pat)| (arm_index, pat_index, pat, arm.guard.clone()))\n+            })\n+            .zip(\n+                pre_binding_blocks\n+                    .iter()\n+                    .zip(pre_binding_blocks.iter().skip(1)),\n+            )\n+            .map(\n+                |(\n+                    (arm_index, pat_index, pattern, guard),\n+                    (pre_binding_block, next_candidate_pre_binding_block),\n+                )| {\n+                    if let (true, Some(borrow_temp)) =\n+                        (tcx.emit_read_for_match(), borrowed_input_temp.clone())\n+                    {\n                         // inject a fake read of the borrowed input at\n                         // the start of each arm's pattern testing\n                         // code.\n@@ -137,10 +153,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         // the variant for an enum while you are in\n                         // the midst of matching on it.\n                         let pattern_source_info = self.source_info(pattern.span);\n-                        self.cfg.push(*pre_binding_block, Statement {\n-                            source_info: pattern_source_info,\n-                            kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n-                        });\n+                        self.cfg.push(\n+                            *pre_binding_block,\n+                            Statement {\n+                                source_info: pattern_source_info,\n+                                kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n+                            },\n+                        );\n                     }\n \n                     // One might ask: why not build up the match pair such that it\n@@ -168,18 +187,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],\n                         bindings: vec![],\n+                        ascriptions: vec![],\n                         guard,\n                         arm_index,\n                         pat_index,\n                         pre_binding_block: *pre_binding_block,\n                         next_candidate_pre_binding_block: *next_candidate_pre_binding_block,\n                     }\n-                })\n-                .collect();\n+                },\n+            )\n+            .collect();\n \n         let outer_source_info = self.source_info(span);\n-        self.cfg.terminate(*pre_binding_blocks.last().unwrap(),\n-                           outer_source_info, TerminatorKind::Unreachable);\n+        self.cfg.terminate(\n+            *pre_binding_blocks.last().unwrap(),\n+            outer_source_info,\n+            TerminatorKind::Unreachable,\n+        );\n \n         // this will generate code to test discriminant_place and\n         // branch to the appropriate arm block\n@@ -198,7 +222,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             otherwise.sort();\n             otherwise.dedup(); // variant switches can introduce duplicate target blocks\n             for block in otherwise {\n-                self.cfg.terminate(block, source_info, TerminatorKind::Unreachable);\n+                self.cfg\n+                    .terminate(block, source_info, TerminatorKind::Unreachable);\n             }\n         }\n \n@@ -211,50 +236,75 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // Re-enter the source scope we created the bindings in.\n             self.source_scope = source_scope;\n             unpack!(arm_block = self.into(destination, arm_block, body));\n-            self.cfg.terminate(arm_block, outer_source_info,\n-                               TerminatorKind::Goto { target: end_block });\n+            self.cfg.terminate(\n+                arm_block,\n+                outer_source_info,\n+                TerminatorKind::Goto { target: end_block },\n+            );\n         }\n         self.source_scope = outer_source_info.scope;\n \n         end_block.unit()\n     }\n \n-    pub fn user_assert_ty(&mut self, block: BasicBlock, hir_id: hir::HirId,\n-                          var: NodeId, span: Span) {\n-        if self.hir.tcx().sess.opts.debugging_opts.disable_nll_user_type_assert { return; }\n-\n-        let local_id = self.var_local_id(var, OutsideGuard);\n-        let source_info = self.source_info(span);\n-\n-        debug!(\"user_assert_ty: local_id={:?}\", hir_id.local_id);\n-        if let Some(c_ty) = self.hir.tables.user_provided_tys().get(hir_id) {\n-            debug!(\"user_assert_ty: c_ty={:?}\", c_ty);\n-            self.cfg.push(block, Statement {\n-                source_info,\n-                kind: StatementKind::UserAssertTy(*c_ty, local_id),\n-            });\n-        }\n-    }\n-\n-    pub fn expr_into_pattern(&mut self,\n-                             mut block: BasicBlock,\n-                             ty: Option<hir::HirId>,\n-                             irrefutable_pat: Pattern<'tcx>,\n-                             initializer: ExprRef<'tcx>)\n-                             -> BlockAnd<()> {\n-        // optimize the case of `let x = ...`\n+    pub fn expr_into_pattern(\n+        &mut self,\n+        mut block: BasicBlock,\n+        irrefutable_pat: Pattern<'tcx>,\n+        initializer: ExprRef<'tcx>,\n+    ) -> BlockAnd<()> {\n         match *irrefutable_pat.kind {\n-            PatternKind::Binding { mode: BindingMode::ByValue,\n-                                   var,\n-                                   subpattern: None, .. } => {\n-                let place = self.storage_live_binding(block, var, irrefutable_pat.span,\n-                                                      OutsideGuard);\n-\n-                if let Some(ty) = ty {\n-                    self.user_assert_ty(block, ty, var, irrefutable_pat.span);\n-                }\n+            // Optimize the case of `let x = ...` to write directly into `x`\n+            PatternKind::Binding {\n+                mode: BindingMode::ByValue,\n+                var,\n+                subpattern: None,\n+                ..\n+            } => {\n+                let place =\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n+                unpack!(block = self.into(&place, block, initializer));\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n+                block.unit()\n+            }\n \n+            // Optimize the case of `let x: T = ...` to write directly\n+            // into `x` and then require that `T == typeof(x)`.\n+            //\n+            // Weirdly, this is needed to prevent the\n+            // `intrinsic-move-val.rs` test case from crashing. That\n+            // test works with uninitialized values in a rather\n+            // dubious way, so it may be that the test is kind of\n+            // broken.\n+            PatternKind::AscribeUserType {\n+                subpattern: Pattern {\n+                    kind: box PatternKind::Binding {\n+                        mode: BindingMode::ByValue,\n+                        var,\n+                        subpattern: None,\n+                        ..\n+                    },\n+                    ..\n+                },\n+                user_ty: ascription_user_ty,\n+            } => {\n+                let place =\n+                    self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard);\n                 unpack!(block = self.into(&place, block, initializer));\n+\n+                let source_info = self.source_info(irrefutable_pat.span);\n+                self.cfg.push(\n+                    block,\n+                    Statement {\n+                        source_info,\n+                        kind: StatementKind::AscribeUserType(\n+                            place.clone(),\n+                            ty::Variance::Invariant,\n+                            ascription_user_ty,\n+                        ),\n+                    },\n+                );\n+\n                 self.schedule_drop_for_binding(var, irrefutable_pat.span, OutsideGuard);\n                 block.unit()\n             }\n@@ -265,35 +315,39 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn place_into_pattern(&mut self,\n-                               mut block: BasicBlock,\n-                               irrefutable_pat: Pattern<'tcx>,\n-                               initializer: &Place<'tcx>,\n-                               set_match_place: bool)\n-                               -> BlockAnd<()> {\n+    pub fn place_into_pattern(\n+        &mut self,\n+        mut block: BasicBlock,\n+        irrefutable_pat: Pattern<'tcx>,\n+        initializer: &Place<'tcx>,\n+        set_match_place: bool,\n+    ) -> BlockAnd<()> {\n         // create a dummy candidate\n         let mut candidate = Candidate {\n             span: irrefutable_pat.span,\n             match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n+            ascriptions: vec![],\n             guard: None,\n \n             // since we don't call `match_candidates`, next fields is unused\n             arm_index: 0,\n             pat_index: 0,\n             pre_binding_block: block,\n-            next_candidate_pre_binding_block: block\n+            next_candidate_pre_binding_block: block,\n         };\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n         // always convert all match-pairs into bindings.\n         unpack!(block = self.simplify_candidate(block, &mut candidate));\n \n         if !candidate.match_pairs.is_empty() {\n-            span_bug!(candidate.match_pairs[0].pattern.span,\n-                      \"match pairs {:?} remaining after simplifying \\\n-                       irrefutable pattern\",\n-                      candidate.match_pairs);\n+            span_bug!(\n+                candidate.match_pairs[0].pattern.span,\n+                \"match pairs {:?} remaining after simplifying \\\n+                 irrefutable pattern\",\n+                candidate.match_pairs\n+            );\n         }\n \n         // for matches and function arguments, the place that is being matched\n@@ -304,9 +358,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             for binding in &candidate.bindings {\n                 let local = self.var_local_id(binding.var_id, OutsideGuard);\n \n-                if let Some(ClearCrossCrate::Set(BindingForm::Var(\n-                    VarBindingForm {opt_match_place: Some((ref mut match_place, _)), .. }\n-                ))) = self.local_decls[local].is_user_variable\n+                if let Some(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n+                    opt_match_place: Some((ref mut match_place, _)),\n+                    ..\n+                }))) = self.local_decls[local].is_user_variable\n                 {\n                     *match_place = Some(initializer.clone());\n                 } else {\n@@ -315,6 +370,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        self.ascribe_types(block, &candidate.ascriptions);\n+\n         // now apply the bindings, which will also declare the variables\n         self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n \n@@ -325,124 +382,191 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n-    pub fn declare_bindings(&mut self,\n-                            mut visibility_scope: Option<SourceScope>,\n-                            scope_span: Span,\n-                            lint_level: LintLevel,\n-                            patterns: &[Pattern<'tcx>],\n-                            has_guard: ArmHasGuard,\n-                            opt_match_place: Option<(Option<&Place<'tcx>>, Span)>)\n-                            -> Option<SourceScope> {\n-        assert!(!(visibility_scope.is_some() && lint_level.is_explicit()),\n-                \"can't have both a visibility and a lint scope at the same time\");\n+    pub fn declare_bindings(\n+        &mut self,\n+        mut visibility_scope: Option<SourceScope>,\n+        scope_span: Span,\n+        lint_level: LintLevel,\n+        patterns: &[Pattern<'tcx>],\n+        has_guard: ArmHasGuard,\n+        opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n+    ) -> Option<SourceScope> {\n+        assert!(\n+            !(visibility_scope.is_some() && lint_level.is_explicit()),\n+            \"can't have both a visibility and a lint scope at the same time\"\n+        );\n         let mut scope = self.source_scope;\n         let num_patterns = patterns.len();\n-        self.visit_bindings(&patterns[0], &mut |this, mutability, name, mode, var, span, ty| {\n-            if visibility_scope.is_none() {\n-                visibility_scope = Some(this.new_source_scope(scope_span,\n-                                                           LintLevel::Inherited,\n-                                                           None));\n-                // If we have lints, create a new source scope\n-                // that marks the lints for the locals. See the comment\n-                // on the `source_info` field for why this is needed.\n-                if lint_level.is_explicit() {\n-                    scope =\n-                        this.new_source_scope(scope_span, lint_level, None);\n+        self.visit_bindings(\n+            &patterns[0],\n+            None,\n+            &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n+                if visibility_scope.is_none() {\n+                    visibility_scope =\n+                        Some(this.new_source_scope(scope_span, LintLevel::Inherited, None));\n+                    // If we have lints, create a new source scope\n+                    // that marks the lints for the locals. See the comment\n+                    // on the `source_info` field for why this is needed.\n+                    if lint_level.is_explicit() {\n+                        scope = this.new_source_scope(scope_span, lint_level, None);\n+                    }\n                 }\n-            }\n-            let source_info = SourceInfo {\n-                span,\n-                scope,\n-            };\n-            let visibility_scope = visibility_scope.unwrap();\n-            this.declare_binding(source_info, visibility_scope, mutability, name, mode,\n-                                 num_patterns, var, ty, has_guard,\n-                                 opt_match_place.map(|(x, y)| (x.cloned(), y)),\n-                                 patterns[0].span);\n-        });\n+                let source_info = SourceInfo { span, scope };\n+                let visibility_scope = visibility_scope.unwrap();\n+                this.declare_binding(\n+                    source_info,\n+                    visibility_scope,\n+                    mutability,\n+                    name,\n+                    mode,\n+                    num_patterns,\n+                    var,\n+                    ty,\n+                    user_ty,\n+                    has_guard,\n+                    opt_match_place.map(|(x, y)| (x.cloned(), y)),\n+                    patterns[0].span,\n+                );\n+            },\n+        );\n         visibility_scope\n     }\n \n-    pub fn storage_live_binding(&mut self,\n-                                block: BasicBlock,\n-                                var: NodeId,\n-                                span: Span,\n-                                for_guard: ForGuard)\n-                            -> Place<'tcx>\n-    {\n+    pub fn storage_live_binding(\n+        &mut self,\n+        block: BasicBlock,\n+        var: NodeId,\n+        span: Span,\n+        for_guard: ForGuard,\n+    ) -> Place<'tcx> {\n         let local_id = self.var_local_id(var, for_guard);\n         let source_info = self.source_info(span);\n-        self.cfg.push(block, Statement {\n-            source_info,\n-            kind: StatementKind::StorageLive(local_id)\n-        });\n+        self.cfg.push(\n+            block,\n+            Statement {\n+                source_info,\n+                kind: StatementKind::StorageLive(local_id),\n+            },\n+        );\n         let place = Place::Local(local_id);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n-        self.schedule_drop(\n-            span, region_scope, &place, var_ty,\n-            DropKind::Storage,\n-        );\n+        self.schedule_drop(span, region_scope, &place, var_ty, DropKind::Storage);\n         place\n     }\n \n-    pub fn schedule_drop_for_binding(&mut self,\n-                                     var: NodeId,\n-                                     span: Span,\n-                                     for_guard: ForGuard) {\n+    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span, for_guard: ForGuard) {\n         let local_id = self.var_local_id(var, for_guard);\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir.node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n         self.schedule_drop(\n-            span, region_scope, &Place::Local(local_id), var_ty,\n+            span,\n+            region_scope,\n+            &Place::Local(local_id),\n+            var_ty,\n             DropKind::Value {\n                 cached_block: CachedBlock::default(),\n             },\n         );\n     }\n \n-    pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, f: &mut F)\n-        where F: FnMut(&mut Self, Mutability, Name, BindingMode, NodeId, Span, Ty<'tcx>)\n-    {\n+    pub fn visit_bindings(\n+        &mut self,\n+        pattern: &Pattern<'tcx>,\n+        mut pattern_user_ty: Option<CanonicalTy<'tcx>>,\n+        f: &mut impl FnMut(\n+            &mut Self,\n+            Mutability,\n+            Name,\n+            BindingMode,\n+            NodeId,\n+            Span,\n+            Ty<'tcx>,\n+            Option<CanonicalTy<'tcx>>,\n+        ),\n+    ) {\n         match *pattern.kind {\n-            PatternKind::Binding { mutability, name, mode, var, ty, ref subpattern, .. } => {\n-                f(self, mutability, name, mode, var, pattern.span, ty);\n+            PatternKind::Binding {\n+                mutability,\n+                name,\n+                mode,\n+                var,\n+                ty,\n+                ref subpattern,\n+                ..\n+            } => {\n+                match mode {\n+                    BindingMode::ByValue => { }\n+                    BindingMode::ByRef(..) => {\n+                        // If this is a `ref` binding (e.g., `let ref\n+                        // x: T = ..`), then the type of `x` is not\n+                        // `T` but rather `&T`, so ignore\n+                        // `pattern_user_ty` for now.\n+                        //\n+                        // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n+                        pattern_user_ty = None;\n+                    }\n+                }\n+\n+                f(self, mutability, name, mode, var, pattern.span, ty, pattern_user_ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.visit_bindings(subpattern, f);\n+                    self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n             }\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+            PatternKind::Array {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            }\n+            | PatternKind::Slice {\n+                ref prefix,\n+                ref slice,\n+                ref suffix,\n+            } => {\n+                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.visit_bindings(subpattern, f);\n+                    self.visit_bindings(subpattern, None, f);\n                 }\n             }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n-            }\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n             PatternKind::Deref { ref subpattern } => {\n-                self.visit_bindings(subpattern, f);\n+                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n+                self.visit_bindings(subpattern, None, f);\n             }\n-            PatternKind::Leaf { ref subpatterns } |\n-            PatternKind::Variant { ref subpatterns, .. } => {\n+            PatternKind::AscribeUserType { ref subpattern, user_ty } => {\n+                // This corresponds to something like\n+                //\n+                // ```\n+                // let (p1: T1): T2 = ...;\n+                // ```\n+                //\n+                // Not presently possible, though maybe someday.\n+                assert!(pattern_user_ty.is_none());\n+                self.visit_bindings(subpattern, Some(user_ty), f)\n+            }\n+            PatternKind::Leaf { ref subpatterns }\n+            | PatternKind::Variant {\n+                ref subpatterns, ..\n+            } => {\n+                // FIXME(#47184): extract or handle `pattern_user_ty` somehow\n                 for subpattern in subpatterns {\n-                    self.visit_bindings(&subpattern.pattern, f);\n+                    self.visit_bindings(&subpattern.pattern, None, f);\n                 }\n             }\n         }\n     }\n }\n \n-\n /// List of blocks for each arm (and potentially other metadata in the\n /// future).\n struct ArmBlocks {\n     blocks: Vec<BasicBlock>,\n }\n \n #[derive(Clone, Debug)]\n-pub struct Candidate<'pat, 'tcx:'pat> {\n+pub struct Candidate<'pat, 'tcx: 'pat> {\n     // span of the original pattern that gave rise to this candidate\n     span: Span,\n \n@@ -452,6 +576,9 @@ pub struct Candidate<'pat, 'tcx:'pat> {\n     // ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n \n+    // ...these types asserted...\n+    ascriptions: Vec<Ascription<'tcx>>,\n+\n     // ...and the guard must be evaluated...\n     guard: Option<Guard<'tcx>>,\n \n@@ -477,8 +604,18 @@ struct Binding<'tcx> {\n     binding_mode: BindingMode<'tcx>,\n }\n \n+/// Indicates that the type of `source` must be a subtype of the\n+/// user-given type `user_ty`; this is basically a no-op but can\n+/// influence region inference.\n+#[derive(Clone, Debug)]\n+struct Ascription<'tcx> {\n+    span: Span,\n+    source: Place<'tcx>,\n+    user_ty: CanonicalTy<'tcx>,\n+}\n+\n #[derive(Clone, Debug)]\n-pub struct MatchPair<'pat, 'tcx:'pat> {\n+pub struct MatchPair<'pat, 'tcx: 'pat> {\n     // this place...\n     place: Place<'tcx>,\n \n@@ -490,7 +627,7 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n     // the \"rest\" part of the pattern right now has type &[T] and\n     // as such, it requires an Rvalue::Slice to be generated.\n     // See RFC 495 / issue #23121 for the eventual (proper) solution.\n-    slice_len_checked: bool\n+    slice_len_checked: bool,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -559,15 +696,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// up the list of candidates and recurse with a non-exhaustive\n     /// list. This is important to keep the size of the generated code\n     /// under control. See `test_candidates` for more details.\n-    fn match_candidates<'pat>(&mut self,\n-                              span: Span,\n-                              arm_blocks: &mut ArmBlocks,\n-                              mut candidates: Vec<Candidate<'pat, 'tcx>>,\n-                              mut block: BasicBlock)\n-                              -> Vec<BasicBlock>\n-    {\n-        debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n-               span, block, candidates);\n+    fn match_candidates<'pat>(\n+        &mut self,\n+        span: Span,\n+        arm_blocks: &mut ArmBlocks,\n+        mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+        mut block: BasicBlock,\n+    ) -> Vec<BasicBlock> {\n+        debug!(\n+            \"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n+            span, block, candidates\n+        );\n \n         // Start by simplifying candidates. Once this process is\n         // complete, all the match pairs which remain require some\n@@ -580,13 +719,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // whether the higher priority candidates (and hence at\n         // the front of the vec) have satisfied all their match\n         // pairs.\n-        let fully_matched =\n-            candidates.iter().take_while(|c| c.match_pairs.is_empty()).count();\n-        debug!(\"match_candidates: {:?} candidates fully matched\", fully_matched);\n+        let fully_matched = candidates\n+            .iter()\n+            .take_while(|c| c.match_pairs.is_empty())\n+            .count();\n+        debug!(\n+            \"match_candidates: {:?} candidates fully matched\",\n+            fully_matched\n+        );\n         let mut unmatched_candidates = candidates.split_off(fully_matched);\n \n-        let fully_matched_with_guard =\n-            candidates.iter().take_while(|c| c.guard.is_some()).count();\n+        let fully_matched_with_guard = candidates.iter().take_while(|c| c.guard.is_some()).count();\n \n         let unreachable_candidates = if fully_matched_with_guard + 1 < candidates.len() {\n             candidates.split_off(fully_matched_with_guard + 1)\n@@ -603,20 +746,23 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // if None is returned, then any remaining candidates\n                 // are unreachable (at least not through this path).\n                 // Link them with false edges.\n-                debug!(\"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n-                       unreachable_candidates, unmatched_candidates);\n+                debug!(\n+                    \"match_candidates: add false edges for unreachable {:?} and unmatched {:?}\",\n+                    unreachable_candidates, unmatched_candidates\n+                );\n                 for candidate in unreachable_candidates {\n                     let source_info = self.source_info(candidate.span);\n                     let target = self.cfg.start_new_block();\n-                    if let Some(otherwise) = self.bind_and_guard_matched_candidate(target,\n-                                                                                   arm_blocks,\n-                                                                                   candidate) {\n-                        self.cfg.terminate(otherwise, source_info, TerminatorKind::Unreachable);\n+                    if let Some(otherwise) =\n+                        self.bind_and_guard_matched_candidate(target, arm_blocks, candidate)\n+                    {\n+                        self.cfg\n+                            .terminate(otherwise, source_info, TerminatorKind::Unreachable);\n                     }\n                 }\n \n                 if unmatched_candidates.is_empty() {\n-                    return vec![]\n+                    return vec![];\n                 } else {\n                     let target = self.cfg.start_new_block();\n                     return self.match_candidates(span, arm_blocks, unmatched_candidates, target);\n@@ -649,11 +795,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.match_candidates(span, arm_blocks, untested_candidates, join_block)\n     }\n \n-    fn join_otherwise_blocks(&mut self,\n-                             span: Span,\n-                             mut otherwise: Vec<BasicBlock>)\n-                             -> BasicBlock\n-    {\n+    fn join_otherwise_blocks(&mut self, span: Span, mut otherwise: Vec<BasicBlock>) -> BasicBlock {\n         let source_info = self.source_info(span);\n         otherwise.sort();\n         otherwise.dedup(); // variant switches can introduce duplicate target blocks\n@@ -662,8 +804,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         } else {\n             let join_block = self.cfg.start_new_block();\n             for block in otherwise {\n-                self.cfg.terminate(block, source_info,\n-                                   TerminatorKind::Goto { target: join_block });\n+                self.cfg.terminate(\n+                    block,\n+                    source_info,\n+                    TerminatorKind::Goto { target: join_block },\n+                );\n             }\n             join_block\n         }\n@@ -781,13 +926,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// In addition to avoiding exponential-time blowups, this algorithm\n     /// also has nice property that each guard and arm is only generated\n     /// once.\n-    fn test_candidates<'pat>(&mut self,\n-                             span: Span,\n-                             arm_blocks: &mut ArmBlocks,\n-                             candidates: &[Candidate<'pat, 'tcx>],\n-                             block: BasicBlock)\n-                             -> (Vec<BasicBlock>, usize)\n-    {\n+    fn test_candidates<'pat>(\n+        &mut self,\n+        span: Span,\n+        arm_blocks: &mut ArmBlocks,\n+        candidates: &[Candidate<'pat, 'tcx>],\n+        block: BasicBlock,\n+    ) -> (Vec<BasicBlock>, usize) {\n         // extract the match-pair from the highest priority candidate\n         let match_pair = &candidates.first().unwrap().match_pairs[0];\n         let mut test = self.test(match_pair);\n@@ -797,66 +942,75 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // may want to add cases based on the candidates that are\n         // available\n         match test.kind {\n-            TestKind::SwitchInt { switch_ty, ref mut options, ref mut indices } => {\n+            TestKind::SwitchInt {\n+                switch_ty,\n+                ref mut options,\n+                ref mut indices,\n+            } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_cases_to_switch(&match_pair.place,\n-                                                 candidate,\n-                                                 switch_ty,\n-                                                 options,\n-                                                 indices) {\n+                    if !self.add_cases_to_switch(\n+                        &match_pair.place,\n+                        candidate,\n+                        switch_ty,\n+                        options,\n+                        indices,\n+                    ) {\n                         break;\n                     }\n                 }\n             }\n-            TestKind::Switch { adt_def: _, ref mut variants} => {\n+            TestKind::Switch {\n+                adt_def: _,\n+                ref mut variants,\n+            } => {\n                 for candidate in candidates.iter() {\n-                    if !self.add_variants_to_switch(&match_pair.place,\n-                                                    candidate,\n-                                                    variants) {\n+                    if !self.add_variants_to_switch(&match_pair.place, candidate, variants) {\n                         break;\n                     }\n                 }\n             }\n-            _ => { }\n+            _ => {}\n         }\n \n         // perform the test, branching to one of N blocks. For each of\n         // those N possible outcomes, create a (initially empty)\n         // vector of candidates. Those are the candidates that still\n         // apply if the test has that particular outcome.\n-        debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n+        debug!(\n+            \"match_candidates: test={:?} match_pair={:?}\",\n+            test, match_pair\n+        );\n         let target_blocks = self.perform_test(block, &match_pair.place, &test);\n         let mut target_candidates: Vec<_> = (0..target_blocks.len()).map(|_| vec![]).collect();\n \n         // Sort the candidates into the appropriate vector in\n         // `target_candidates`. Note that at some point we may\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n-        let tested_candidates =\n-            candidates.iter()\n-                      .take_while(|c| self.sort_candidate(&match_pair.place,\n-                                                          &test,\n-                                                          c,\n-                                                          &mut target_candidates))\n-                      .count();\n+        let tested_candidates = candidates\n+            .iter()\n+            .take_while(|c| {\n+                self.sort_candidate(&match_pair.place, &test, c, &mut target_candidates)\n+            })\n+            .count();\n         assert!(tested_candidates > 0); // at least the last candidate ought to be tested\n         debug!(\"tested_candidates: {}\", tested_candidates);\n-        debug!(\"untested_candidates: {}\", candidates.len() - tested_candidates);\n+        debug!(\n+            \"untested_candidates: {}\",\n+            candidates.len() - tested_candidates\n+        );\n \n         // For each outcome of test, process the candidates that still\n         // apply. Collect a list of blocks where control flow will\n         // branch if one of the `target_candidate` sets is not\n         // exhaustive.\n-        let otherwise: Vec<_> =\n-            target_blocks.into_iter()\n-                         .zip(target_candidates)\n-                         .flat_map(|(target_block, target_candidates)| {\n-                             self.match_candidates(span,\n-                                                   arm_blocks,\n-                                                   target_candidates,\n-                                                   target_block)\n-                         })\n-                         .collect();\n+        let otherwise: Vec<_> = target_blocks\n+            .into_iter()\n+            .zip(target_candidates)\n+            .flat_map(|(target_block, target_candidates)| {\n+                self.match_candidates(span, arm_blocks, target_candidates, target_block)\n+            })\n+            .collect();\n \n         (otherwise, tested_candidates)\n     }\n@@ -873,30 +1027,41 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// bindings, further tests would be a use-after-move (which would\n     /// in turn be detected by the borrowck code that runs on the\n     /// MIR).\n-    fn bind_and_guard_matched_candidate<'pat>(&mut self,\n-                                              mut block: BasicBlock,\n-                                              arm_blocks: &mut ArmBlocks,\n-                                              candidate: Candidate<'pat, 'tcx>)\n-                                              -> Option<BasicBlock> {\n-        debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n-               block, candidate);\n+    fn bind_and_guard_matched_candidate<'pat>(\n+        &mut self,\n+        mut block: BasicBlock,\n+        arm_blocks: &mut ArmBlocks,\n+        candidate: Candidate<'pat, 'tcx>,\n+    ) -> Option<BasicBlock> {\n+        debug!(\n+            \"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n+            block, candidate\n+        );\n \n         debug_assert!(candidate.match_pairs.is_empty());\n \n+        self.ascribe_types(block, &candidate.ascriptions);\n+\n         let arm_block = arm_blocks.blocks[candidate.arm_index];\n         let candidate_source_info = self.source_info(candidate.span);\n \n-        self.cfg.terminate(block, candidate_source_info,\n-                               TerminatorKind::Goto { target: candidate.pre_binding_block });\n+        self.cfg.terminate(\n+            block,\n+            candidate_source_info,\n+            TerminatorKind::Goto {\n+                target: candidate.pre_binding_block,\n+            },\n+        );\n \n         block = self.cfg.start_new_block();\n-        self.cfg.terminate(candidate.pre_binding_block, candidate_source_info,\n-                               TerminatorKind::FalseEdges {\n-                                   real_target: block,\n-                                   imaginary_targets:\n-                                       vec![candidate.next_candidate_pre_binding_block],\n-                               });\n-\n+        self.cfg.terminate(\n+            candidate.pre_binding_block,\n+            candidate_source_info,\n+            TerminatorKind::FalseEdges {\n+                real_target: block,\n+                imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+            },\n+        );\n \n         // rust-lang/rust#27282: The `autoref` business deserves some\n         // explanation here.\n@@ -980,13 +1145,20 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      match input itself; it is up to us to create a place\n         //      holding a `&` or `&mut` that we can then borrow).\n \n-        let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n+        let autoref = self.hir\n+            .tcx()\n+            .all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n             if autoref {\n                 self.bind_matched_candidate_for_guard(\n-                    block, candidate.pat_index, &candidate.bindings);\n+                    block,\n+                    candidate.pat_index,\n+                    &candidate.bindings,\n+                );\n                 let guard_frame = GuardFrame {\n-                    locals: candidate.bindings.iter()\n+                    locals: candidate\n+                        .bindings\n+                        .iter()\n                         .map(|b| GuardFrameLocal::new(b.var_id, b.binding_mode))\n                         .collect(),\n                 };\n@@ -1005,7 +1177,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let cond = unpack!(block = self.as_local_operand(block, guard));\n             if autoref {\n                 let guard_frame = self.guard_context.pop().unwrap();\n-                debug!(\"Exiting guard building context with locals: {:?}\", guard_frame);\n+                debug!(\n+                    \"Exiting guard building context with locals: {:?}\",\n+                    guard_frame\n+                );\n             }\n \n             let false_edge_block = self.cfg.start_new_block();\n@@ -1037,45 +1212,82 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             //\n             // and that is clearly not correct.\n             let post_guard_block = self.cfg.start_new_block();\n-            self.cfg.terminate(block, source_info,\n-                               TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block,\n-                                                   false_edge_block));\n+            self.cfg.terminate(\n+                block,\n+                source_info,\n+                TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block, false_edge_block),\n+            );\n \n             if autoref {\n                 self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n             }\n \n-            self.cfg.terminate(post_guard_block, source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(\n+                post_guard_block,\n+                source_info,\n+                TerminatorKind::Goto { target: arm_block },\n+            );\n \n             let otherwise = self.cfg.start_new_block();\n \n-            self.cfg.terminate(false_edge_block, source_info,\n-                               TerminatorKind::FalseEdges {\n-                                   real_target: otherwise,\n-                                   imaginary_targets:\n-                                       vec![candidate.next_candidate_pre_binding_block],\n-                               });\n+            self.cfg.terminate(\n+                false_edge_block,\n+                source_info,\n+                TerminatorKind::FalseEdges {\n+                    real_target: otherwise,\n+                    imaginary_targets: vec![candidate.next_candidate_pre_binding_block],\n+                },\n+            );\n             Some(otherwise)\n         } else {\n             // (Here, it is not too early to bind the matched\n             // candidate on `block`, because there is no guard result\n             // that we have to inspect before we bind them.)\n             self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n-            self.cfg.terminate(block, candidate_source_info,\n-                               TerminatorKind::Goto { target: arm_block });\n+            self.cfg.terminate(\n+                block,\n+                candidate_source_info,\n+                TerminatorKind::Goto { target: arm_block },\n+            );\n             None\n         }\n     }\n \n+    /// Append `AscribeUserType` statements onto the end of `block`\n+    /// for each ascription\n+    fn ascribe_types<'pat>(\n+        &mut self,\n+        block: BasicBlock,\n+        ascriptions: &[Ascription<'tcx>],\n+    ) {\n+        for ascription in ascriptions {\n+            let source_info = self.source_info(ascription.span);\n+            self.cfg.push(\n+                block,\n+                Statement {\n+                    source_info,\n+                    kind: StatementKind::AscribeUserType(\n+                        ascription.source.clone(),\n+                        ty::Variance::Covariant,\n+                        ascription.user_ty,\n+                    ),\n+                },\n+            );\n+        }\n+    }\n+\n     // Only called when all_pat_vars_are_implicit_refs_within_guards,\n     // and thus all code/comments assume we are in that context.\n-    fn bind_matched_candidate_for_guard(&mut self,\n-                                        block: BasicBlock,\n-                                        pat_index: usize,\n-                                        bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n-               block, pat_index, bindings);\n+    fn bind_matched_candidate_for_guard(\n+        &mut self,\n+        block: BasicBlock,\n+        pat_index: usize,\n+        bindings: &[Binding<'tcx>],\n+    ) {\n+        debug!(\n+            \"bind_matched_candidate_for_guard(block={:?}, pat_index={:?}, bindings={:?})\",\n+            block, pat_index, bindings\n+        );\n \n         // Assign each of the bindings. Since we are binding for a\n         // guard expression, this will never trigger moves out of the\n@@ -1088,16 +1300,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // a reference R: &T pointing to the location matched by\n             // the pattern, and every occurrence of P within a guard\n             // denotes *R.\n-            let ref_for_guard = self.storage_live_binding(\n-                block, binding.var_id, binding.span, RefWithinGuard);\n+            let ref_for_guard =\n+                self.storage_live_binding(block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n             // shared-&'s?  Answer: Because schedule_drop_for_binding\n             // also emits StorageDead's for those locals.\n             self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(region, borrow_kind) => {\n                     // Tricky business: For `ref id` and `ref mut id`\n@@ -1114,9 +1327,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // used by the arm body itself. This eases\n                     // observing two-phase borrow restrictions.\n                     let val_for_guard = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                        block,\n+                        binding.var_id,\n+                        binding.span,\n+                        ValWithinGuard(pat_index),\n+                    );\n                     self.schedule_drop_for_binding(\n-                        binding.var_id, binding.span, ValWithinGuard(pat_index));\n+                        binding.var_id,\n+                        binding.span,\n+                        ValWithinGuard(pat_index),\n+                    );\n \n                     // rust-lang/rust#27282: We reuse the two-phase\n                     // borrow infrastructure so that the mutable\n@@ -1126,27 +1346,36 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     // discussion on rust-lang/rust#49870.\n                     let borrow_kind = match borrow_kind {\n                         BorrowKind::Shared | BorrowKind::Unique => borrow_kind,\n-                        BorrowKind::Mut { .. } => BorrowKind::Mut { allow_two_phase_borrow: true },\n+                        BorrowKind::Mut { .. } => BorrowKind::Mut {\n+                            allow_two_phase_borrow: true,\n+                        },\n                     };\n                     let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &val_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &val_for_guard, rvalue);\n                     let rvalue = Rvalue::Ref(region, BorrowKind::Shared, val_for_guard);\n-                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n+                    self.cfg\n+                        .push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n-    fn bind_matched_candidate_for_arm_body(&mut self,\n-                                           block: BasicBlock,\n-                                           bindings: &[Binding<'tcx>]) {\n-        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\", block, bindings);\n+    fn bind_matched_candidate_for_arm_body(\n+        &mut self,\n+        block: BasicBlock,\n+        bindings: &[Binding<'tcx>],\n+    ) {\n+        debug!(\n+            \"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\",\n+            block, bindings\n+        );\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local = self.storage_live_binding(block, binding.var_id, binding.span,\n-                                                  OutsideGuard);\n+            let local =\n+                self.storage_live_binding(block, binding.var_id, binding.span, OutsideGuard);\n             self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue => {\n@@ -1175,22 +1404,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// parts of the matched data, and we want them to be distinct\n     /// temps in order to simplify checks performed by our internal\n     /// leveraging of two-phase borrows).\n-    fn declare_binding(&mut self,\n-                       source_info: SourceInfo,\n-                       visibility_scope: SourceScope,\n-                       mutability: Mutability,\n-                       name: Name,\n-                       mode: BindingMode,\n-                       num_patterns: usize,\n-                       var_id: NodeId,\n-                       var_ty: Ty<'tcx>,\n-                       has_guard: ArmHasGuard,\n-                       opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n-                       pat_span: Span)\n-    {\n-        debug!(\"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n-                visibility_scope={:?}, source_info={:?})\",\n-               var_id, name, mode, var_ty, visibility_scope, source_info);\n+    fn declare_binding(\n+        &mut self,\n+        source_info: SourceInfo,\n+        visibility_scope: SourceScope,\n+        mutability: Mutability,\n+        name: Name,\n+        mode: BindingMode,\n+        num_patterns: usize,\n+        var_id: NodeId,\n+        var_ty: Ty<'tcx>,\n+        user_var_ty: Option<CanonicalTy<'tcx>>,\n+        has_guard: ArmHasGuard,\n+        opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n+        pat_span: Span,\n+    ) {\n+        debug!(\n+            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n+             visibility_scope={:?}, source_info={:?})\",\n+            var_id, name, mode, var_ty, visibility_scope, source_info\n+        );\n \n         let tcx = self.hir.tcx();\n         let binding_mode = match mode {\n@@ -1199,7 +1432,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         };\n         let local = LocalDecl::<'tcx> {\n             mutability,\n-            ty: var_ty.clone(),\n+            ty: var_ty,\n+            user_ty: user_var_ty,\n             name: Some(name),\n             source_info,\n             visibility_scope,\n@@ -1231,14 +1465,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // See previous comment.\n                 mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n+                user_ty: None,\n                 name: Some(name),\n                 source_info,\n                 visibility_scope,\n                 // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n                 is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n-            LocalsForNode::ForGuard { vals_for_guard, ref_for_guard, for_arm_body }\n+            LocalsForNode::ForGuard {\n+                vals_for_guard,\n+                ref_for_guard,\n+                for_arm_body,\n+            }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "14da8e9083892fb435c743a83573f5fc412f4839", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -23,7 +23,7 @@\n //! testing a value against a constant.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::matches::{Binding, MatchPair, Candidate};\n+use build::matches::{Ascription, Binding, MatchPair, Candidate};\n use hair::*;\n use rustc::mir::*;\n \n@@ -63,6 +63,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                  candidate: &mut Candidate<'pat, 'tcx>)\n                                  -> Result<(), MatchPair<'pat, 'tcx>> {\n         match *match_pair.pattern.kind {\n+            PatternKind::AscribeUserType { ref subpattern, user_ty } => {\n+                candidate.ascriptions.push(Ascription {\n+                    span: match_pair.pattern.span,\n+                    user_ty,\n+                    source: match_pair.place.clone(),\n+                });\n+\n+                candidate.match_pairs.push(MatchPair::new(match_pair.place, subpattern));\n+\n+                Ok(())\n+            }\n+\n             PatternKind::Wild => {\n                 // nothing left to do\n                 Ok(())"}, {"sha": "2c606ebf322a844ce1d851bbd21a340bec3e7915", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -96,6 +96,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            PatternKind::AscribeUserType { .. } |\n             PatternKind::Array { .. } |\n             PatternKind::Slice { .. } |\n             PatternKind::Wild |\n@@ -138,6 +139,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n             PatternKind::Binding { .. } |\n+            PatternKind::AscribeUserType { .. } |\n             PatternKind::Leaf { .. } |\n             PatternKind::Deref { .. } => {\n                 // don't know how to add these patterns to a switch\n@@ -638,6 +640,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span: candidate.span,\n             match_pairs: other_match_pairs,\n             bindings: candidate.bindings.clone(),\n+            ascriptions: candidate.ascriptions.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n             pat_index: candidate.pat_index,\n@@ -702,6 +705,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             span: candidate.span,\n             match_pairs: all_match_pairs,\n             bindings: candidate.bindings.clone(),\n+            ascriptions: candidate.ascriptions.clone(),\n             guard: candidate.guard.clone(),\n             arm_index: candidate.arm_index,\n             pat_index: candidate.pat_index,"}, {"sha": "576c91a02b08daed34dd64fb31da5371800ad30a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -730,6 +730,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.local_decls.push(LocalDecl {\n                 mutability: Mutability::Mut,\n                 ty,\n+                user_ty: None,\n                 source_info,\n                 visibility_scope: source_info.scope,\n                 name,"}, {"sha": "cc92cdecc60768fab8d657ca7b1c3ee78ecef0a2", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -338,7 +338,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::UserAssertTy(..) |\n+            mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => {}\n \n         }"}, {"sha": "5451d27082db75d2e2319de4f1fd1de7fa4c21a9", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -304,7 +304,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             }\n             StatementKind::EndRegion(_) |\n             StatementKind::Validate(..) |\n-            StatementKind::UserAssertTy(..) |\n+            StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "85a9734a601011234096a268834990f9b37ee5bc", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -76,14 +76,26 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             first_statement_index: region::FirstStatementIndex::new(index),\n                         });\n \n-                        let ty = local.ty.clone().map(|ty| ty.hir_id);\n-                        let pattern = cx.pattern_from_hir(&local.pat);\n+                        let mut pattern = cx.pattern_from_hir(&local.pat);\n+\n+                        if let Some(ty) = &local.ty {\n+                            if let Some(user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n+                                pattern = Pattern {\n+                                    ty: pattern.ty,\n+                                    span: pattern.span,\n+                                    kind: Box::new(PatternKind::AscribeUserType {\n+                                        user_ty: *user_ty,\n+                                        subpattern: pattern\n+                                    })\n+                                };\n+                            }\n+                        }\n+\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_scope,\n                                 init_scope: region::Scope::Node(hir_id.local_id),\n                                 pattern,\n-                                ty,\n                                 initializer: local.init.to_ref(),\n                                 lint_level: cx.lint_level_of(local.id),\n                             },"}, {"sha": "d86aee5431267b1e3e1fb7044dab29a64867c279", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -93,12 +93,11 @@ pub enum StmtKind<'tcx> {\n         /// lifetime of temporaries\n         init_scope: region::Scope,\n \n-        /// let <PAT>: ty = ...\n+        /// `let <PAT> = ...`\n+        ///\n+        /// if a type is included, it is added as an ascription pattern\n         pattern: Pattern<'tcx>,\n \n-        /// let pat: <TY> = init ...\n-        ty: Option<hir::HirId>,\n-\n         /// let pat: ty = <INIT> ...\n         initializer: Option<ExprRef<'tcx>>,\n "}, {"sha": "e05e0bb0470f4011064de3932a455c93414af991", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -1235,6 +1235,8 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt,\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {\n+        PatternKind::AscribeUserType { ref subpattern, .. } =>\n+            pat_constructors(cx, subpattern, pcx),\n         PatternKind::Binding { .. } | PatternKind::Wild => None,\n         PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } => {\n@@ -1606,6 +1608,9 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n+        PatternKind::AscribeUserType { ref subpattern, .. } =>\n+            specialize(cx, ::std::slice::from_ref(&subpattern), constructor, wild_patterns),\n+\n         PatternKind::Binding { .. } | PatternKind::Wild => {\n             Some(wild_patterns.to_owned())\n         }"}, {"sha": "cd44869211a7d9f62d6a32d9568cd46f04c23c91", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -20,7 +20,7 @@ use interpret::{const_field, const_variant_index};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n+use rustc::ty::{self, CanonicalTy, TyCtxt, AdtDef, Ty, Region};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::hir::{self, PatKind, RangeEnd};\n use rustc::hir::def::{Def, CtorKind};\n@@ -66,6 +66,11 @@ pub struct Pattern<'tcx> {\n pub enum PatternKind<'tcx> {\n     Wild,\n \n+    AscribeUserType {\n+        user_ty: CanonicalTy<'tcx>,\n+        subpattern: Pattern<'tcx>,\n+    },\n+\n     /// x, ref x, x @ P, etc\n     Binding {\n         mutability: Mutability,\n@@ -125,6 +130,8 @@ impl<'tcx> fmt::Display for Pattern<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self.kind {\n             PatternKind::Wild => write!(f, \"_\"),\n+            PatternKind::AscribeUserType { ref subpattern, .. } =>\n+                write!(f, \"{}: _\", subpattern),\n             PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n                 let is_mut = match mode {\n                     BindingMode::ByValue => mutability == Mutability::Mut,\n@@ -939,7 +946,7 @@ macro_rules! CloneImpls {\n CloneImpls!{ <'tcx>\n     Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n-    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n+    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, CanonicalTy<'tcx>\n }\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n@@ -973,6 +980,13 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n             PatternKind::Wild => PatternKind::Wild,\n+            PatternKind::AscribeUserType {\n+                ref subpattern,\n+                user_ty,\n+            } => PatternKind::AscribeUserType {\n+                subpattern: subpattern.fold_with(folder),\n+                user_ty: user_ty.fold_with(folder),\n+            },\n             PatternKind::Binding {\n                 mutability,\n                 name,"}, {"sha": "cb8e1284d0968db49798a93a35f6a51658e66fcb", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -159,7 +159,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n \n             EndRegion(..) => {}\n-            UserAssertTy(..) => {}\n+            AscribeUserType(..) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n             // size of MIR constantly."}, {"sha": "f2c011ccee6a5704ffed97ff84204987d05caf1b", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -39,6 +39,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(if_while_or_patterns)]\n #![feature(try_from)]\n #![feature(reverse_bits)]\n+#![feature(underscore_imports)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "a6c0397568578b0de33e84872883ff45a19318cd", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -140,7 +140,9 @@ enum CallKind {\n fn temp_decl(mutability: Mutability, ty: Ty, span: Span) -> LocalDecl {\n     let source_info = SourceInfo { scope: OUTERMOST_SOURCE_SCOPE, span };\n     LocalDecl {\n-        mutability, ty, name: None,\n+        mutability, ty,\n+        user_ty: None,\n+        name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n         internal: false,"}, {"sha": "6fbc2f85c08dab24068373d5571cc08e7b16516b", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             StatementKind::StorageDead(..) |\n             StatementKind::EndRegion(..) |\n             StatementKind::Validate(..) |\n-            StatementKind::UserAssertTy(..) |\n+            StatementKind::AscribeUserType(..) |\n             StatementKind::Nop => {\n                 // safe (at least as emitted during MIR construction)\n             }"}, {"sha": "9edb1a1f76a6d7bf6a92350d70d6e5fe0ba41535", "filename": "src/librustc_mir/transform/cleanup_post_borrowck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcleanup_post_borrowck.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -12,7 +12,7 @@\n //!\n //!   - `CleanEndRegions`, that reduces the set of `EndRegion` statements\n //!     in the MIR.\n-//!   - `CleanUserAssertTy`, that replaces all `UserAssertTy` statements\n+//!   - `CleanAscribeUserType`, that replaces all `AscribeUserType` statements\n //!     with `Nop`.\n //!\n //! The `CleanEndRegions` \"pass\" is actually implemented as two\n@@ -24,10 +24,10 @@\n //! MIR and removes any `EndRegion` that is applied to a region that\n //! was not seen in the previous pass.\n //!\n-//! The `CleanUserAssertTy` pass runs at a distinct time from the\n-//! `CleanEndRegions` pass. It is important that the `CleanUserAssertTy`\n+//! The `CleanAscribeUserType` pass runs at a distinct time from the\n+//! `CleanEndRegions` pass. It is important that the `CleanAscribeUserType`\n //! pass runs after the MIR borrowck so that the NLL type checker can\n-//! perform the type assertion when it encounters the `UserAssertTy`\n+//! perform the type assertion when it encounters the `AscribeUserType`\n //! statements.\n \n use rustc_data_structures::fx::FxHashSet;\n@@ -110,26 +110,26 @@ impl<'a, 'tcx> MutVisitor<'tcx> for DeleteTrivialEndRegions<'a> {\n     }\n }\n \n-pub struct CleanUserAssertTy;\n+pub struct CleanAscribeUserType;\n \n-pub struct DeleteUserAssertTy;\n+pub struct DeleteAscribeUserType;\n \n-impl MirPass for CleanUserAssertTy {\n+impl MirPass for CleanAscribeUserType {\n     fn run_pass<'a, 'tcx>(&self,\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut delete = DeleteUserAssertTy;\n+        let mut delete = DeleteAscribeUserType;\n         delete.visit_mir(mir);\n     }\n }\n \n-impl<'tcx> MutVisitor<'tcx> for DeleteUserAssertTy {\n+impl<'tcx> MutVisitor<'tcx> for DeleteAscribeUserType {\n     fn visit_statement(&mut self,\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if let StatementKind::UserAssertTy(..) = statement.kind {\n+        if let StatementKind::AscribeUserType(..) = statement.kind {\n             statement.make_nop();\n         }\n         self.super_statement(block, statement, location);"}, {"sha": "f1f42768ce3248d2ef1483fd1d10a367b3574173", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -303,6 +303,7 @@ fn replace_result_variable<'tcx>(\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: ret_ty,\n+        user_ty: None,\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n@@ -656,6 +657,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n     mir.local_decls[RETURN_PLACE] = LocalDecl {\n         mutability: Mutability::Mut,\n         ty: tcx.mk_nil(),\n+        user_ty: None,\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,\n@@ -672,6 +674,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n             ty: gen_ty,\n             mutbl: hir::Mutability::MutMutable,\n         }),\n+        user_ty: None,\n         name: None,\n         source_info,\n         visibility_scope: source_info.scope,"}, {"sha": "19fb35be9d4e0567ba270723a76f622c92967c9b", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -238,8 +238,8 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         simplify_branches::SimplifyBranches::new(\"initial\"),\n         remove_noop_landing_pads::RemoveNoopLandingPads,\n         simplify::SimplifyCfg::new(\"early-opt\"),\n-        // Remove all `UserAssertTy` statements.\n-        cleanup_post_borrowck::CleanUserAssertTy,\n+        // Remove all `AscribeUserType` statements.\n+        cleanup_post_borrowck::CleanAscribeUserType,\n \n         // These next passes must be executed together\n         add_call_guards::CriticalCallEdges,"}, {"sha": "a2175dce33a833aa9df8e63062fe523393715d80", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -1098,7 +1098,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n                 StatementKind::Validate(..) |\n-                StatementKind::UserAssertTy(..) |\n+                StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {}\n             }\n         });"}, {"sha": "f7e44dde186fe04c4005fd4f0932c909362308ef", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -230,7 +230,7 @@ fn check_statement(\n         | StatementKind::StorageDead(_)\n         | StatementKind::Validate(..)\n         | StatementKind::EndRegion(_)\n-        | StatementKind::UserAssertTy(..)\n+        | StatementKind::AscribeUserType(..)\n         | StatementKind::Nop => Ok(()),\n     }\n }"}, {"sha": "a2561d3d79381d3f91be2496b8e45721df653979", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -53,7 +53,7 @@ impl RemoveNoopLandingPads {\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n                 StatementKind::EndRegion(_) |\n-                StatementKind::UserAssertTy(..) |\n+                StatementKind::AscribeUserType(..) |\n                 StatementKind::Nop => {\n                     // These are all nops in a landing pad (there's some\n                     // borrowck interaction between EndRegion and storage"}, {"sha": "f3e0f5573632ad476f1695e233b29aa3438e7b34", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -163,7 +163,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Validate(..) |\n-            mir::StatementKind::UserAssertTy(..) |\n+            mir::StatementKind::AscribeUserType(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,"}, {"sha": "710ccb2053b8492a6a27573026c85d3537fa6c1f", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -17,6 +17,7 @@ use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n+use std::fmt::Write as _;\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n@@ -493,14 +494,18 @@ fn write_scope_tree(\n             };\n \n             let indent = indent + INDENT.len();\n-            let indented_var = format!(\n-                \"{0:1$}let {2}{3:?}: {4:?};\",\n+            let mut indented_var = format!(\n+                \"{0:1$}let {2}{3:?}: {4:?}\",\n                 INDENT,\n                 indent,\n                 mut_str,\n                 local,\n                 var.ty\n             );\n+            if let Some(user_ty) = var.user_ty {\n+                write!(indented_var, \" as {:?}\", user_ty).unwrap();\n+            }\n+            indented_var.push_str(\";\");\n             writeln!(\n                 w,\n                 \"{0:1$} // \\\"{2}\\\" in {3}\","}, {"sha": "7c9f77042cb2a229328369d1e5b49ae4c574a410", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\",\n             StatementKind::InlineAsm { .. } => \"StatementKind::InlineAsm\",\n-            StatementKind::UserAssertTy(..) => \"StatementKind::UserAssertTy\",\n+            StatementKind::AscribeUserType(..) => \"StatementKind::AscribeUserType\",\n             StatementKind::Nop => \"StatementKind::Nop\",\n         }, &statement.kind);\n         self.super_statement(block, statement, location);"}, {"sha": "097cd66537539ac2bb3a4a7387998253de9ad482", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -49,7 +49,7 @@ pub fn add_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirValidated\")]\n+    except=\"HirBody,TypeckTables,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn add_type() {\n     let _x: u32 = 2u32;"}, {"sha": "f04d4328929686a856ce14b605a80963c885d782", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 32, "deletions": 49, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -19,70 +19,53 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// check that codegen of assignment expressions is sane. Assignments\n-// tend to be absent in simple code, so subtle breakage in them can\n-// leave a quite hard-to-find trail of destruction.\n+// Check codegen for assignments (`a = b`) where the left-hand-side is\n+// not yet initialized. Assignments tend to be absent in simple code,\n+// so subtle breakage in them can leave a quite hard-to-find trail of\n+// destruction.\n \n // ignore-tidy-linelength\n \n fn main() {\n     let nodrop_x = false;\n     let nodrop_y;\n \n+    // Since boolean does not require drop, this can be a simple\n+    // assignment:\n     nodrop_y = nodrop_x;\n \n     let drop_x : Option<Box<u32>> = None;\n     let drop_y;\n \n+    // Since the type of `drop_y` has drop, we generate a `replace`\n+    // terminator:\n     drop_y = drop_x;\n }\n \n // END RUST SOURCE\n // START rustc.main.SimplifyCfg-initial.after.mir\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = const false;\n-//         StorageLive(_2);\n-//         StorageLive(_3);\n-//         _3 = _1;\n-//         _2 = move _3;\n-//         StorageDead(_3);\n-//         StorageLive(_4);\n-//         UserAssertTy(Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> }, _4);\n-//         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n-//         StorageLive(_5);\n-//         StorageLive(_6);\n-//         _6 = move _4;\n-//         replace(_5 <-move _6) -> [return: bb2, unwind: bb5];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         drop(_6) -> [return: bb6, unwind: bb4];\n-//     }\n-//     bb3: {\n-//         drop(_4) -> bb1;\n-//     }\n-//     bb4: {\n-//         drop(_5) -> bb3;\n-//     }\n-//     bb5: {\n-//         drop(_6) -> bb4;\n-//     }\n-//     bb6: {\n-//         StorageDead(_6);\n-//         _0 = ();\n-//         drop(_5) -> [return: bb7, unwind: bb3];\n-//     }\n-//     bb7: {\n-//         StorageDead(_5);\n-//         drop(_4) -> [return: bb8, unwind: bb1];\n-//     }\n-//     bb8: {\n-//         StorageDead(_4);\n-//         StorageDead(_2);\n-//         StorageDead(_1);\n-//         return;\n-//     }\n+//    bb0: {\n+//        StorageLive(_1);\n+//        _1 = const false;\n+//        StorageLive(_2);\n+//        StorageLive(_3);\n+//        _3 = _1;\n+//        _2 = move _3;\n+//        StorageDead(_3);\n+//        StorageLive(_4);\n+//        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//        AscribeUserType(_4, o, Canonical { variables: [], value: std::option::Option<std::boxed::Box<u32>> });\n+//        StorageLive(_5);\n+//        StorageLive(_6);\n+//        _6 = move _4;\n+//        replace(_5 <- move _6) -> [return: bb2, unwind: bb5];\n+//    }\n+//    ...\n+//    bb2: {\n+//        drop(_6) -> [return: bb6, unwind: bb4];\n+//    }\n+//    ...\n+//    bb5: {\n+//        drop(_6) -> bb4;\n+//    }\n // END rustc.main.SimplifyCfg-initial.after.mir"}, {"sha": "8a7ea8962fc5d6ba21f626d5fd7d08d058ec2cf9", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=f17c2306e2eba49f6447cfda831e4161bf0b618a", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Basic test for reborrow constraints: the region (`R5`) that appears\n-// in the type of `r_a` must outlive the region (`R7`) that appears in\n-// the type of `r_b`\n-\n-// compile-flags:-Zborrowck=mir -Zverbose\n-//                              ^^^^^^^^^ force compiler to dump more region information\n-\n-#![allow(warnings)]\n-\n-fn use_x(_: &mut i32) -> bool { true }\n-\n-fn main() {\n-    let mut foo: i32     = 22;\n-    let r_a: &mut i32 = &mut foo;\n-    let r_b: &mut i32 = &mut *r_a;\n-    use_x(r_b);\n-}\n-\n-// END RUST SOURCE\n-// START rustc.main.nll.0.mir\n-// | '_#7r    | U0 | {bb0[4], bb0[8..=17]}\n-// ...\n-// | '_#9r    | U0 | {bb0[10], bb0[14..=17]}\n-// ...\n-// let _4: &'_#9r mut i32;\n-// ...\n-// let _2: &'_#7r mut i32;\n-// END rustc.main.nll.0.mir"}, {"sha": "ed3e38486baf628a045b33d3709c250044c4d5dd", "filename": "src/test/ui/consts/const-eval/dont_promote_unstable_const_fn.nll.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn.nll.stderr?ref=f17c2306e2eba49f6447cfda831e4161bf0b618a", "patch": "@@ -1,22 +0,0 @@\n-error: `foo` is not yet stable as a const fn\n-  --> $DIR/dont_promote_unstable_const_fn.rs:25:25\n-   |\n-LL | const fn bar() -> u32 { foo() } //~ ERROR `foo` is not yet stable as a const fn\n-   |                         ^^^^^\n-   |\n-   = help: in Nightly builds, add `#![feature(foo)]` to the crate attributes to enable\n-\n-error[E0597]: borrowed value does not live long enough\n-  --> $DIR/dont_promote_unstable_const_fn.rs:33:26\n-   |\n-LL |     let x: &'static _ = &std::time::Duration::from_millis(42).subsec_millis();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ temporary value does not live long enough\n-LL |     //~^ does not live long enough\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "4c8f2f47d1e8dce593cc47e062c087cc95ba18fc", "filename": "src/test/ui/consts/const-eval/dont_promote_unstable_const_fn_cross_crate.nll.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn_cross_crate.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn_cross_crate.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdont_promote_unstable_const_fn_cross_crate.nll.stderr?ref=f17c2306e2eba49f6447cfda831e4161bf0b618a", "patch": "@@ -1,13 +0,0 @@\n-error[E0597]: borrowed value does not live long enough\n-  --> $DIR/dont_promote_unstable_const_fn_cross_crate.rs:19:29\n-   |\n-LL |     let _x: &'static u32 = &foo(); //~ ERROR does not live long enough\n-   |                             ^^^^^ temporary value does not live long enough\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0597`."}, {"sha": "dd1c2a447300b5d16e879913d69f57b41c365593", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -20,8 +20,17 @@ fn make_it() -> for<'a> fn(&'a u32, &'a u32) -> &'a u32 {\n     panic!()\n }\n \n-fn main() {\n+fn foo() {\n     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n     //~^ ERROR higher-ranked subtype error\n     drop(a);\n }\n+\n+fn bar() {\n+    // The code path for patterns is mildly different, so go ahead and\n+    // test that too:\n+    let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+    //~^ ERROR higher-ranked subtype error\n+}\n+\n+fn main() { }"}, {"sha": "c9195395b878c47ffefd1df4fb1dfe26b6a1c2f0", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -4,5 +4,11 @@ error: higher-ranked subtype error\n LL |     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n    |                                                          ^^^^^^^^^\n \n-error: aborting due to previous error\n+error: higher-ranked subtype error\n+  --> $DIR/hr-fn-aaa-as-aba.rs:32:58\n+   |\n+LL |     let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+   |                                                          ^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "bc7b031f72c0bc319fc8bddec7204fface35834d", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -16,9 +16,7 @@\n // another -- effectively, the single lifetime `'a` is just inferred\n // to be the intersection of the two distinct lifetimes.\n //\n-// FIXME: However, we currently reject this example with an error,\n-// because of how we handle binders and equality in `relate_tys`.\n-//\n+// compile-pass\n // compile-flags:-Zno-leak-check\n \n #![feature(nll)]\n@@ -31,7 +29,6 @@ fn make_cell_aa() -> Cell<for<'a> fn(&'a u32, &'a u32)> {\n \n fn aa_eq_ab() {\n     let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n-    //~^ ERROR higher-ranked subtype error\n     drop(a);\n }\n "}, {"sha": "17e8a32cb2ad95d790206326dc529fa310a1d5b1", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f17c2306e2eba49f6447cfda831e4161bf0b618a/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr?ref=f17c2306e2eba49f6447cfda831e4161bf0b618a", "patch": "@@ -1,8 +0,0 @@\n-error: higher-ranked subtype error\n-  --> $DIR/hr-fn-aau-eq-abu.rs:33:53\n-   |\n-LL |     let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n-   |                                                     ^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "cc86c8d02d3aac3214fdee460cf9583b3add305b", "filename": "src/test/ui/nll/relate_tys/universe-violation.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -0,0 +1,17 @@\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning either argument CANNOT be upcast to one\n+// that returns always its first argument.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> fn(&'static u32) -> &'static u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: fn(_) -> _ = make_it();\n+    let b: fn(&u32) -> &u32 = a;\n+    drop(a);\n+}"}, {"sha": "6dc78789564c71f496898c02885c9c190b96b268", "filename": "src/test/ui/nll/relate_tys/universe-violation.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Funiverse-violation.stderr?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/universe-violation.rs:15:31\n+   |\n+LL |     let b: fn(&u32) -> &u32 = a;\n+   |                               ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "02b3006c5315c49158668d0f9b49f1abeef88d73", "filename": "src/test/ui/nll/relate_tys/var-appears-twice.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning always its first argument can be upcast to one\n+// that returns either first or second argument.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+use std::cell::Cell;\n+\n+type DoubleCell<A> = Cell<(A, A)>;\n+type DoublePair<A> = (A, A);\n+\n+fn make_cell<'b>(x: &'b u32) -> Cell<(&'static u32, &'b u32)> {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: &'static u32 = &22;\n+    let b = 44;\n+\n+    // Here we get an error because `DoubleCell<_>` requires the same type\n+    // on both parts of the `Cell`, and we can't have that.\n+    let x: DoubleCell<_> = make_cell(&b); //~ ERROR\n+\n+    // Here we do not get an error because `DoublePair<_>` permits\n+    // variance on the lifetimes involved.\n+    let y: DoublePair<_> = make_cell(&b).get();\n+}"}, {"sha": "15c4cc2e100b511625582520edec60fd32a419a1", "filename": "src/test/ui/nll/relate_tys/var-appears-twice.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fvar-appears-twice.stderr?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/var-appears-twice.rs:33:38\n+   |\n+LL |     let x: DoubleCell<_> = make_cell(&b); //~ ERROR\n+   |                                      ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `b` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "53d97360c869e3b034ece137fc2143743e1d53ea", "filename": "src/test/ui/nll/user-annotations/patterns.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.rs?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -0,0 +1,121 @@\n+// Test that various patterns also enforce types.\n+\n+#![feature(nll)]\n+\n+fn variable_no_initializer() {\n+    let x = 22;\n+    let y: &'static u32;\n+    y = &x; //~ ERROR\n+}\n+\n+fn tuple_no_initializer() {\n+    // FIXME(#47187): We are not propagating ascribed type through tuples.\n+\n+    let x = 22;\n+    let (y, z): (&'static u32, &'static u32);\n+    y = &x;\n+}\n+\n+fn ref_with_ascribed_static_type() -> u32 {\n+    // Check the behavior in some wacky cases.\n+    let x = 22;\n+    let y = &x; //~ ERROR\n+    let ref z: &'static u32 = y;\n+    **z\n+}\n+\n+fn ref_with_ascribed_any_type() -> u32 {\n+    let x = 22;\n+    let y = &x;\n+    let ref z: &u32 = y;\n+    **z\n+}\n+\n+struct Single<T> { value: T }\n+\n+fn struct_no_initializer() {\n+    // FIXME(#47187): We are not propagating ascribed type through patterns.\n+\n+    let x = 22;\n+    let Single { value: y }: Single<&'static u32>;\n+    y = &x;\n+}\n+\n+fn variable_with_initializer() {\n+    let x = 22;\n+    let y: &'static u32 = &x; //~ ERROR\n+}\n+\n+fn underscore_with_initializer() {\n+    let x = 22;\n+    let _: &'static u32 = &x; //~ ERROR\n+\n+    let _: Vec<&'static String> = vec![&String::new()];\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+\n+    let (_, a): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+\n+    let (_a, b): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+    //~^ ERROR borrowed value does not live long enough [E0597]\n+}\n+\n+fn pair_underscores_with_initializer() {\n+    let x = 22;\n+    let (_, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+}\n+\n+fn pair_variable_with_initializer() {\n+    let x = 22;\n+    let (y, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+}\n+\n+fn struct_single_field_variable_with_initializer() {\n+    let x = 22;\n+    let Single { value: y }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+}\n+\n+fn struct_single_field_underscore_with_initializer() {\n+    let x = 22;\n+    let Single { value: _ }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+}\n+\n+struct Double<T> { value1: T, value2: T }\n+\n+fn struct_double_field_underscore_with_initializer() {\n+    let x = 22;\n+    let Double { value1: _, value2: _ }: Double<&'static u32> = Double {\n+        value1: &x, //~ ERROR\n+        value2: &44,\n+    };\n+}\n+\n+fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n+    // The error in this test is inconsistency with\n+    // `static_to_a_to_static_through_tuple`, but \"feels right\" to\n+    // me. It occurs because we special case the single binding case\n+    // and force the type of `y` to be `&'a u32`, even though the\n+    // right-hand side has type `&'static u32`.\n+\n+    let y: &'a u32 = &22;\n+    y //~ ERROR\n+}\n+\n+fn static_to_a_to_static_through_tuple<'a>(x: &'a u32) -> &'static u32 {\n+    // FIXME(#47187): The fact that this type-checks is perhaps surprising.\n+    // What happens is that the right-hand side is constrained to have\n+    // type `&'a u32`, which is possible, because it has type\n+    // `&'static u32`. The variable `y` is then forced to have type\n+    // `&'static u32`, but it is constrained only by the right-hand\n+    // side, not the ascribed type, and hence it passes.\n+\n+    let (y, _z): (&'a u32, u32) = (&22, 44);\n+    y\n+}\n+\n+fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n+    let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n+    y\n+}\n+\n+fn main() { }"}, {"sha": "563de1a9e02e0caf99742ee945905e31b18eca4d", "filename": "src/test/ui/nll/user-annotations/patterns.stderr", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -0,0 +1,143 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:8:9\n+   |\n+LL |     y = &x; //~ ERROR\n+   |         ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:22:13\n+   |\n+LL |     let y = &x; //~ ERROR\n+   |             ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:46:27\n+   |\n+LL |     let y: &'static u32 = &x; //~ ERROR\n+   |                           ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:51:27\n+   |\n+LL |     let _: &'static u32 = &x; //~ ERROR\n+   |                           ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/patterns.rs:53:41\n+   |\n+LL |     let _: Vec<&'static String> = vec![&String::new()];\n+   |                                         ^^^^^^^^^^^^^ - temporary value only lives until here\n+   |                                         |\n+   |                                         temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/patterns.rs:56:52\n+   |\n+LL |     let (_, a): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+   |                                                    ^^^^^^^^^^^^^      - temporary value only lives until here\n+   |                                                    |\n+   |                                                    temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/patterns.rs:59:53\n+   |\n+LL |     let (_a, b): (Vec<&'static String>, _) = (vec![&String::new()], 44);\n+   |                                                     ^^^^^^^^^^^^^      - temporary value only lives until here\n+   |                                                     |\n+   |                                                     temporary value does not live long enough\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:65:40\n+   |\n+LL |     let (_, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+   |                                        ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:70:40\n+   |\n+LL |     let (y, _): (&'static u32, u32) = (&x, 44); //~ ERROR\n+   |                                        ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:75:69\n+   |\n+LL |     let Single { value: y }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+   |                                                                     ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:80:69\n+   |\n+LL |     let Single { value: _ }: Single<&'static u32> = Single { value: &x }; //~ ERROR\n+   |                                                                     ^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/patterns.rs:88:17\n+   |\n+LL |         value1: &x, //~ ERROR\n+   |                 ^^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:101:5\n+   |\n+LL | fn static_to_a_to_static_through_variable<'a>(x: &'a u32) -> &'static u32 {\n+   |                                           -- lifetime `'a` defined here\n+...\n+LL |     y //~ ERROR\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/patterns.rs:117:40\n+   |\n+LL | fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n+   |                            -- lifetime `'a` defined here\n+LL |     let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n+   |                                        ^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to 14 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "ebf56dc9835f4928842586f30424f8f2e8d83e43", "filename": "src/test/ui/try-block/try-block-bad-lifetime.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1547c0aa5957b42cc768c00119c6eb7b4262d3/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-lifetime.stderr?ref=2f1547c0aa5957b42cc768c00119c6eb7b4262d3", "patch": "@@ -1,13 +1,14 @@\n error[E0597]: `my_string` does not live long enough\n   --> $DIR/try-block-bad-lifetime.rs:25:33\n    |\n+LL |         let result: Result<(), &str> = try {\n+   |             ------ borrow later used here\n+LL |             let my_string = String::from(\"\");\n LL |             let my_str: & str = & my_string;\n    |                                 ^^^^^^^^^^^ borrowed value does not live long enough\n ...\n LL |         };\n    |         - `my_string` dropped here while still borrowed\n-LL |         do_something_with(result);\n-   |                           ------ borrow later used here\n \n error[E0506]: cannot assign to `i` because it is borrowed\n   --> $DIR/try-block-bad-lifetime.rs:39:13"}]}