{"sha": "c97f5f0045f8ba959dc3b72cd705043ac7b4d9eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5N2Y1ZjAwNDVmOGJhOTU5ZGMzYjcyY2Q3MDUwNDNhYzdiNGQ5ZWI=", "commit": {"author": {"name": "Tatsuyuki Ishi", "email": "ishitatsuyuki@gmail.com", "date": "2019-10-04T13:55:10Z"}, "committer": {"name": "Tatsuyuki Ishi", "email": "ishitatsuyuki@gmail.com", "date": "2019-10-04T13:55:10Z"}, "message": "Remove dead module", "tree": {"sha": "c92465c8f46642d74a386d298f8754003b3c740d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c92465c8f46642d74a386d298f8754003b3c740d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c97f5f0045f8ba959dc3b72cd705043ac7b4d9eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c97f5f0045f8ba959dc3b72cd705043ac7b4d9eb", "html_url": "https://github.com/rust-lang/rust/commit/c97f5f0045f8ba959dc3b72cd705043ac7b4d9eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c97f5f0045f8ba959dc3b72cd705043ac7b4d9eb/comments", "author": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ishitatsuyuki", "id": 12389383, "node_id": "MDQ6VXNlcjEyMzg5Mzgz", "avatar_url": "https://avatars.githubusercontent.com/u/12389383?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ishitatsuyuki", "html_url": "https://github.com/ishitatsuyuki", "followers_url": "https://api.github.com/users/ishitatsuyuki/followers", "following_url": "https://api.github.com/users/ishitatsuyuki/following{/other_user}", "gists_url": "https://api.github.com/users/ishitatsuyuki/gists{/gist_id}", "starred_url": "https://api.github.com/users/ishitatsuyuki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ishitatsuyuki/subscriptions", "organizations_url": "https://api.github.com/users/ishitatsuyuki/orgs", "repos_url": "https://api.github.com/users/ishitatsuyuki/repos", "events_url": "https://api.github.com/users/ishitatsuyuki/events{/privacy}", "received_events_url": "https://api.github.com/users/ishitatsuyuki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6293e359848c8c7275330719b33ccd168df04c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6293e359848c8c7275330719b33ccd168df04c3", "html_url": "https://github.com/rust-lang/rust/commit/c6293e359848c8c7275330719b33ccd168df04c3"}], "stats": {"total": 204, "additions": 0, "deletions": 204}, "files": [{"sha": "e63426281bf21fea294ffd71ecac399254a366a5", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "removed", "additions": 0, "deletions": 204, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/c6293e359848c8c7275330719b33ccd168df04c3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6293e359848c8c7275330719b33ccd168df04c3/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=c6293e359848c8c7275330719b33ccd168df04c3", "patch": "@@ -1,204 +0,0 @@\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::mir::mono::MonoItem;\n-use rustc::session::config::OptLevel;\n-use rustc::ty::{self, TyCtxt, Instance};\n-use rustc::ty::subst::InternalSubsts;\n-use rustc::ty::print::obsolete::DefPathBasedNames;\n-use syntax::attr::InlineAttr;\n-use std::fmt;\n-use rustc::mir::mono::Linkage;\n-use syntax_pos::symbol::InternedString;\n-use syntax::source_map::Span;\n-\n-/// Describes how a monomorphization will be instantiated in object files.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n-pub enum InstantiationMode {\n-    /// There will be exactly one instance of the given MonoItem. It will have\n-    /// external linkage so that it can be linked to from other codegen units.\n-    GloballyShared {\n-        /// In some compilation scenarios we may decide to take functions that\n-        /// are typically `LocalCopy` and instead move them to `GloballyShared`\n-        /// to avoid codegenning them a bunch of times. In this situation,\n-        /// however, our local copy may conflict with other crates also\n-        /// inlining the same function.\n-        ///\n-        /// This flag indicates that this situation is occurring, and informs\n-        /// symbol name calculation that some extra mangling is needed to\n-        /// avoid conflicts. Note that this may eventually go away entirely if\n-        /// ThinLTO enables us to *always* have a globally shared instance of a\n-        /// function within one crate's compilation.\n-        may_conflict: bool,\n-    },\n-\n-    /// Each codegen unit containing a reference to the given MonoItem will\n-    /// have its own private copy of the function (with internal linkage).\n-    LocalCopy,\n-}\n-\n-pub trait MonoItemExt<'tcx>: fmt::Debug {\n-    fn as_mono_item(&self) -> &MonoItem<'tcx>;\n-\n-    fn is_generic_fn(&self) -> bool {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => {\n-                instance.substs.non_erasable_generics().next().is_some()\n-            }\n-            MonoItem::Static(..) |\n-            MonoItem::GlobalAsm(..) => false,\n-        }\n-    }\n-\n-    fn symbol_name(&self, tcx: TyCtxt<'tcx>) -> ty::SymbolName {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(instance) => tcx.symbol_name(instance),\n-            MonoItem::Static(def_id) => {\n-                tcx.symbol_name(Instance::mono(tcx, def_id))\n-            }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                let def_id = tcx.hir().local_def_id(hir_id);\n-                ty::SymbolName {\n-                    name: InternedString::intern(&format!(\"global_asm_{:?}\", def_id))\n-                }\n-            }\n-        }\n-    }\n-    fn instantiation_mode(&self, tcx: TyCtxt<'tcx>) -> InstantiationMode {\n-        let inline_in_all_cgus =\n-            tcx.sess.opts.debugging_opts.inline_in_all_cgus.unwrap_or_else(|| {\n-                tcx.sess.opts.optimize != OptLevel::No\n-            }) && !tcx.sess.opts.cg.link_dead_code;\n-\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => {\n-                let entry_def_id = tcx.entry_fn(LOCAL_CRATE).map(|(id, _)| id);\n-                // If this function isn't inlined or otherwise has explicit\n-                // linkage, then we'll be creating a globally shared version.\n-                if self.explicit_linkage(tcx).is_some() ||\n-                    !instance.def.requires_local(tcx) ||\n-                    Some(instance.def_id()) == entry_def_id\n-                {\n-                    return InstantiationMode::GloballyShared  { may_conflict: false }\n-                }\n-\n-                // At this point we don't have explicit linkage and we're an\n-                // inlined function. If we're inlining into all CGUs then we'll\n-                // be creating a local copy per CGU\n-                if inline_in_all_cgus {\n-                    return InstantiationMode::LocalCopy\n-                }\n-\n-                // Finally, if this is `#[inline(always)]` we're sure to respect\n-                // that with an inline copy per CGU, but otherwise we'll be\n-                // creating one copy of this `#[inline]` function which may\n-                // conflict with upstream crates as it could be an exported\n-                // symbol.\n-                match tcx.codegen_fn_attrs(instance.def_id()).inline {\n-                    InlineAttr::Always => InstantiationMode::LocalCopy,\n-                    _ => {\n-                        InstantiationMode::GloballyShared  { may_conflict: true }\n-                    }\n-                }\n-            }\n-            MonoItem::Static(..) |\n-            MonoItem::GlobalAsm(..) => {\n-                InstantiationMode::GloballyShared { may_conflict: false }\n-            }\n-        }\n-    }\n-\n-    fn explicit_linkage(&self, tcx: TyCtxt<'tcx>) -> Option<Linkage> {\n-        let def_id = match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => instance.def_id(),\n-            MonoItem::Static(def_id) => def_id,\n-            MonoItem::GlobalAsm(..) => return None,\n-        };\n-\n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(def_id);\n-        codegen_fn_attrs.linkage\n-    }\n-\n-    /// Returns `true` if this instance is instantiable - whether it has no unsatisfied\n-    /// predicates.\n-    ///\n-    /// In order to codegen an item, all of its predicates must hold, because\n-    /// otherwise the item does not make sense. Type-checking ensures that\n-    /// the predicates of every item that is *used by* a valid item *do*\n-    /// hold, so we can rely on that.\n-    ///\n-    /// However, we codegen collector roots (reachable items) and functions\n-    /// in vtables when they are seen, even if they are not used, and so they\n-    /// might not be instantiable. For example, a programmer can define this\n-    /// public function:\n-    ///\n-    ///     pub fn foo<'a>(s: &'a mut ()) where &'a mut (): Clone {\n-    ///         <&mut () as Clone>::clone(&s);\n-    ///     }\n-    ///\n-    /// That function can't be codegened, because the method `<&mut () as Clone>::clone`\n-    /// does not exist. Luckily for us, that function can't ever be used,\n-    /// because that would require for `&'a mut (): Clone` to hold, so we\n-    /// can just not emit any code, or even a linker reference for it.\n-    ///\n-    /// Similarly, if a vtable method has such a signature, and therefore can't\n-    /// be used, we can just not emit it and have a placeholder (a null pointer,\n-    /// which will never be accessed) in its place.\n-    fn is_instantiable(&self, tcx: TyCtxt<'tcx>) -> bool {\n-        debug!(\"is_instantiable({:?})\", self);\n-        let (def_id, substs) = match *self.as_mono_item() {\n-            MonoItem::Fn(ref instance) => (instance.def_id(), instance.substs),\n-            MonoItem::Static(def_id) => (def_id, InternalSubsts::empty()),\n-            // global asm never has predicates\n-            MonoItem::GlobalAsm(..) => return true\n-        };\n-\n-        tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n-    }\n-\n-    fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {\n-        return match *self.as_mono_item() {\n-            MonoItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance, debug)\n-            },\n-            MonoItem::Static(def_id) => {\n-                let instance = Instance::new(def_id, tcx.intern_substs(&[]));\n-                to_string_internal(tcx, \"static \", instance, debug)\n-            },\n-            MonoItem::GlobalAsm(..) => {\n-                \"global_asm\".to_string()\n-            }\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(\n-            tcx: TyCtxt<'tcx>,\n-            prefix: &str,\n-            instance: Instance<'tcx>,\n-            debug: bool,\n-        ) -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            let printer = DefPathBasedNames::new(tcx, false, false);\n-            printer.push_instance_as_string(instance, &mut result, debug);\n-            result\n-        }\n-    }\n-\n-    fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n-        match *self.as_mono_item() {\n-            MonoItem::Fn(Instance { def, .. }) => {\n-                tcx.hir().as_local_hir_id(def.def_id())\n-            }\n-            MonoItem::Static(def_id) => {\n-                tcx.hir().as_local_hir_id(def_id)\n-            }\n-            MonoItem::GlobalAsm(hir_id) => {\n-                Some(hir_id)\n-            }\n-        }.map(|hir_id| tcx.hir().span(hir_id))\n-    }\n-}\n-\n-impl MonoItemExt<'tcx> for MonoItem<'tcx> {\n-    fn as_mono_item(&self) -> &MonoItem<'tcx> {\n-        self\n-    }\n-}"}]}