{"sha": "fdd7e3c74419385541e2ba244117e7aa65f72a01", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZDdlM2M3NDQxOTM4NTU0MWUyYmEyNDQxMTdlN2FhNjVmNzJhMDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-01T21:07:21Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-02-03T01:38:35Z"}, "message": "remove some of the ways to mutate a `DepTrackingMap`\n\nIt is pretty suspect to insert an entry twice.", "tree": {"sha": "c3c85779b4b72cebce25e9337a62408566d39759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c85779b4b72cebce25e9337a62408566d39759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fdd7e3c74419385541e2ba244117e7aa65f72a01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd7e3c74419385541e2ba244117e7aa65f72a01", "html_url": "https://github.com/rust-lang/rust/commit/fdd7e3c74419385541e2ba244117e7aa65f72a01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fdd7e3c74419385541e2ba244117e7aa65f72a01/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9aaca71cc61a7c0792da2789b5e278cc294733f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9aaca71cc61a7c0792da2789b5e278cc294733f", "html_url": "https://github.com/rust-lang/rust/commit/d9aaca71cc61a7c0792da2789b5e278cc294733f"}], "stats": {"total": 74, "additions": 29, "deletions": 45}, "files": [{"sha": "103f8ef653c1e33c141095897b6f0c5e507993ce", "filename": "src/librustc/dep_graph/dep_tracking_map.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_tracking_map.rs?ref=fdd7e3c74419385541e2ba244117e7aa65f72a01", "patch": "@@ -61,15 +61,10 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n         self.map.get(k)\n     }\n \n-    pub fn get_mut(&mut self, k: &M::Key) -> Option<&mut M::Value> {\n-        self.read(k);\n-        self.write(k);\n-        self.map.get_mut(k)\n-    }\n-\n-    pub fn insert(&mut self, k: M::Key, v: M::Value) -> Option<M::Value> {\n+    pub fn insert(&mut self, k: M::Key, v: M::Value) {\n         self.write(&k);\n-        self.map.insert(k, v)\n+        let _old_value = self.map.insert(k, v);\n+        // assert!(old_value.is_none());\n     }\n \n     pub fn contains_key(&self, k: &M::Key) -> bool {\n@@ -80,17 +75,6 @@ impl<M: DepTrackingMapConfig> DepTrackingMap<M> {\n     pub fn keys(&self) -> Vec<M::Key> {\n         self.map.keys().cloned().collect()\n     }\n-\n-    /// Append `elem` to the vector stored for `k`, creating a new vector if needed.\n-    /// This is considered a write to `k`.\n-    pub fn push<E: Clone>(&mut self, k: M::Key, elem: E)\n-        where M: DepTrackingMapConfig<Value=Vec<E>>\n-    {\n-        self.write(&k);\n-        self.map.entry(k)\n-                .or_insert(Vec::new())\n-                .push(elem);\n-    }\n }\n \n impl<M: DepTrackingMapConfig> MemoizationMap for RefCell<DepTrackingMap<M>> {"}, {"sha": "b7f90682c7c74a5382a4824f2d48213125dada4c", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=fdd7e3c74419385541e2ba244117e7aa65f72a01", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> Visitor<'tcx> for BuildMir<'a, 'tcx> {\n \n             let mir = tcx.alloc_mir(mir);\n             let def_id = tcx.hir.local_def_id(src.item_id());\n-            assert!(tcx.mir_map.borrow_mut().insert(def_id, mir).is_none());\n+            tcx.mir_map.borrow_mut().insert(def_id, mir);\n         });\n \n         let body = self.tcx.hir.body(body_id);"}, {"sha": "4a96a5e960dbe6f77f5a80f589813bcba056ab2e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=fdd7e3c74419385541e2ba244117e7aa65f72a01", "patch": "@@ -29,17 +29,19 @@ use rustc::dep_graph::DepNode;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::{Item, ItemImpl};\n use rustc::hir;\n+use rustc::util::nodemap::DefIdMap;\n \n mod builtin;\n mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'tcx: 'a> {\n+struct CoherenceCollect<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    inherent_impls: DefIdMap<Vec<DefId>>,\n }\n \n-impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceChecker<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceCollect<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n         if let ItemImpl(..) = item.node {\n             self.check_implementation(item)\n@@ -53,7 +55,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CoherenceChecker<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n+impl<'a, 'tcx> CoherenceCollect<'a, 'tcx> {\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n@@ -80,9 +82,14 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n         self.tcx.visit_all_item_likes_in_krate(DepNode::CoherenceCheckImpl, self);\n+\n+        // Transfer the inherent impl lists, not that they are known, into the tcx\n+        for (ty_def_id, impl_def_ids) in self.inherent_impls.drain() {\n+            self.tcx.inherent_impls.borrow_mut().insert(ty_def_id, impl_def_ids);\n+        }\n     }\n \n-    fn check_implementation(&self, item: &Item) {\n+    fn check_implementation(&mut self, item: &Item) {\n         let tcx = self.tcx;\n         let impl_did = tcx.hir.local_def_id(item.id);\n         let self_type = tcx.item_type(impl_did);\n@@ -119,8 +126,10 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         }\n     }\n \n-    fn add_inherent_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n-        self.tcx.inherent_impls.borrow_mut().push(base_def_id, impl_def_id);\n+    fn add_inherent_impl(&mut self, base_def_id: DefId, impl_def_id: DefId) {\n+        self.inherent_impls.entry(base_def_id)\n+                           .or_insert(vec![])\n+                           .push(impl_def_id);\n     }\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'tcx>, impl_def_id: DefId) {\n@@ -161,7 +170,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    CoherenceChecker { tcx: ccx.tcx }.check();\n+    CoherenceCollect { tcx: ccx.tcx, inherent_impls: DefIdMap() }.check();\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);\n     overlap::check(ccx.tcx);"}, {"sha": "cb0a6cccb03d46639c6b1c183b34c6179a4f8f9f", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fdd7e3c74419385541e2ba244117e7aa65f72a01", "patch": "@@ -634,7 +634,7 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.hir.local_def_id(field.id);\n-    ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n+    assert_eq!(def_id, ty_f.did);\n     ccx.tcx.generics.borrow_mut().insert(def_id, struct_generics);\n     ccx.tcx.predicates.borrow_mut().insert(def_id, struct_predicates.clone());\n }\n@@ -1283,9 +1283,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                                            items);\n     trait_predicates.predicates.extend(assoc_predicates);\n \n-    let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n-    assert!(prev_predicates.is_none());\n-\n+    tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n     return;\n \n     fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -1592,9 +1590,7 @@ fn predicates_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n \n     let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n-    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id,\n-                                                                 predicates.clone());\n-    assert!(prev_predicates.is_none());\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates.clone());\n \n     predicates\n }\n@@ -1617,8 +1613,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     };\n \n     let predicates = ty_generic_predicates(ccx, generics, None, vec![], false);\n-    let prev_predicates = ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n-    assert!(prev_predicates.is_none());\n+    ccx.tcx.predicates.borrow_mut().insert(def_id, predicates);\n }\n \n // Is it marked with ?Sized"}, {"sha": "3ccec97d606ea3afa60a968ad831825c6a8edca6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=fdd7e3c74419385541e2ba244117e7aa65f72a01", "patch": "@@ -137,11 +137,9 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                           item_variances);\n             }\n \n-            let newly_added = tcx.item_variance_map\n-                .borrow_mut()\n-                .insert(item_def_id, Rc::new(item_variances))\n-                .is_none();\n-            assert!(newly_added);\n+            tcx.item_variance_map\n+               .borrow_mut()\n+               .insert(item_def_id, Rc::new(item_variances));\n         }\n     }\n "}, {"sha": "253d7a25b632f2fea0afd6a2e24b071b99b6cac8", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fdd7e3c74419385541e2ba244117e7aa65f72a01/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=fdd7e3c74419385541e2ba244117e7aa65f72a01", "patch": "@@ -178,12 +178,10 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n             let item_def_id = self.tcx.hir.local_def_id(item_id);\n-            let newly_added = self.tcx\n+            self.tcx\n                 .item_variance_map\n                 .borrow_mut()\n-                .insert(item_def_id, self.empty_variances.clone())\n-                .is_none();\n-            assert!(newly_added);\n+                .insert(item_def_id, self.empty_variances.clone());\n         }\n     }\n "}]}