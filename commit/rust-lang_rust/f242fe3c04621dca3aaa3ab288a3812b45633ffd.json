{"sha": "f242fe3c04621dca3aaa3ab288a3812b45633ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNDJmZTNjMDQ2MjFkY2EzYWFhM2FiMjg4YTM4MTJiNDU2MzNmZmQ=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-15T00:36:16Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-04-28T01:17:43Z"}, "message": "Various improvements to MIR and LLVM IR Construction\n\nPrimarily affects the MIR construction, which indirectly improves LLVM\nIR generation, but some LLVM IR changes have been made too.\n\n* Handle \"statement expressions\" more intelligently. These are\n  expressions that always evaluate to `()`. Previously a temporary would\n  be generated as a destination to translate into, which is unnecessary.\n\n  This affects assignment, augmented assignment, `return`, `break` and\n  `continue`.\n* Avoid inserting drops for non-drop types in more places. Scheduled\n  drops were already skipped for types that we knew wouldn't need\n  dropping at construction time. However manually-inserted drops like\n  those for `x` in `x = y;` were still generated. `build_drop` now takes\n  a type parameter like its `schedule_drop` counterpart and checks to\n  see if the type needs dropping.\n* Avoid generating an extra temporary for an assignment where the types\n  involved don't need dropping. Previously an expression like\n  `a = b + 1;` would result in a temporary for `b + 1`. This is so the\n  RHS can be evaluated, then the LHS evaluated and dropped and have\n  everything work correctly. However, this isn't necessary if the `LHS`\n  doesn't need a drop, as we can just overwrite the existing value.\n* Improves lvalue analysis to allow treating an `Rvalue::Use` as an\n  operand in certain conditions. The reason for it never being an\n  operand is so it can be zeroed/drop-filled, but this is only true for\n  types that need dropping.\n\nThe first two changes result in significantly fewer MIR blocks being\ngenerated, as previously almost every statement would end up generating\na new block due to the drop of the `()` temporary being generated.", "tree": {"sha": "658a5e034cd643fea77516fb4a8e7b9d7d01e1fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/658a5e034cd643fea77516fb4a8e7b9d7d01e1fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f242fe3c04621dca3aaa3ab288a3812b45633ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f242fe3c04621dca3aaa3ab288a3812b45633ffd", "html_url": "https://github.com/rust-lang/rust/commit/f242fe3c04621dca3aaa3ab288a3812b45633ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f242fe3c04621dca3aaa3ab288a3812b45633ffd/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97", "url": "https://api.github.com/repos/rust-lang/rust/commits/cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97", "html_url": "https://github.com/rust-lang/rust/commit/cda7c1cf2463443aee4a2f51a5141bc7ce4a4f97"}], "stats": {"total": 302, "additions": 195, "deletions": 107}, "files": [{"sha": "fc67bc7ded0837ea8953bb709b748649eb4e027a", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 118, "deletions": 5, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -9,9 +9,12 @@\n // except according to those terms.\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::scope::LoopScope;\n use hair::*;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir::repr::*;\n use rustc::hir;\n+use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn ast_block(&mut self,\n@@ -44,11 +47,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     StmtKind::Expr { scope, expr } => {\n                         unpack!(block = this.in_scope(scope, block, |this, _| {\n                             let expr = this.hir.mirror(expr);\n-                            let expr_span = expr.span;\n-                            let temp = this.temp(expr.ty.clone());\n-                            unpack!(block = this.into(&temp, block, expr));\n-                            unpack!(block = this.build_drop(block, expr_span, temp));\n-                            block.unit()\n+                            this.stmt_expr(block, expr)\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n@@ -83,4 +82,118 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             block.unit()\n         })\n     }\n+\n+    pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n+        let this = self;\n+        let expr_span = expr.span;\n+        let scope_id = this.innermost_scope_id();\n+        // Handle a number of expressions that don't need a destination at all. This\n+        // avoids needing a mountain of temporary `()` variables.\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                let value = this.hir.mirror(value);\n+                this.in_scope(extent, block, |this, _| this.stmt_expr(block, value))\n+            }\n+            ExprKind::Assign { lhs, rhs } => {\n+                let lhs = this.hir.mirror(lhs);\n+                let scope_id = this.innermost_scope_id();\n+                let lhs_span = lhs.span;\n+                let lhs_ty = lhs.ty;\n+\n+                let lhs_needs_drop = this.hir.needs_drop(lhs_ty);\n+\n+                // Note: we evaluate assignments right-to-left. This\n+                // is better for borrowck interaction with overloaded\n+                // operators like x[j] = x[i].\n+\n+                // Generate better code for things that don't need to be\n+                // dropped. We need the temporary as_operand generates\n+                // so we can clean up the data if evaluating the LHS unwinds,\n+                // but if the LHS (and therefore the RHS) doesn't need\n+                // unwinding, we just translate directly to an rvalue instead.\n+                let rhs = if lhs_needs_drop {\n+                    let op = unpack!(block = this.as_operand(block, rhs));\n+                    Rvalue::Use(op)\n+                } else {\n+                    unpack!(block = this.as_rvalue(block, rhs))\n+                };\n+\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                unpack!(block = this.build_drop(block, lhs_span, lhs.clone(), lhs_ty));\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n+                block.unit()\n+            }\n+            ExprKind::AssignOp { op, lhs, rhs } => {\n+                // FIXME(#28160) there is an interesting semantics\n+                // question raised here -- should we \"freeze\" the\n+                // value of the lhs here?  I'm inclined to think not,\n+                // since it seems closer to the semantics of the\n+                // overloaded version, which takes `&mut self`.  This\n+                // only affects weird things like `x += {x += 1; x}`\n+                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n+\n+                // As above, RTL.\n+                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+\n+                // we don't have to drop prior contents or anything\n+                // because AssignOp is only legal for Copy types\n+                // (overloaded ops should be desugared into a call).\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n+                                     Rvalue::BinaryOp(op,\n+                                                      Operand::Consume(lhs.clone()),\n+                                                      rhs));\n+\n+                block.unit()\n+            }\n+            ExprKind::Continue { label } => {\n+                this.break_or_continue(expr_span, label, block,\n+                                       |loop_scope| loop_scope.continue_block)\n+            }\n+            ExprKind::Break { label } => {\n+                this.break_or_continue(expr_span, label, block, |loop_scope| {\n+                    loop_scope.might_break = true;\n+                    loop_scope.break_block\n+                })\n+            }\n+            ExprKind::Return { value } => {\n+                block = match value {\n+                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n+                    None => {\n+                        this.cfg.push_assign_unit(block, scope_id,\n+                                                  expr_span, &Lvalue::ReturnPointer);\n+                        block\n+                    }\n+                };\n+                let extent = this.extent_of_return_scope();\n+                let return_block = this.return_block();\n+                this.exit_scope(expr_span, extent, block, return_block);\n+                this.cfg.start_new_block().unit()\n+            }\n+            _ => {\n+                let expr_span = expr.span;\n+                let expr_ty = expr.ty;\n+                let temp = this.temp(expr.ty.clone());\n+                unpack!(block = this.into(&temp, block, expr));\n+                unpack!(block = this.build_drop(block, expr_span, temp, expr_ty));\n+                block.unit()\n+            }\n+        }\n+    }\n+\n+    fn break_or_continue<F>(&mut self,\n+                            span: Span,\n+                            label: Option<CodeExtent>,\n+                            block: BasicBlock,\n+                            exit_selector: F)\n+                            -> BlockAnd<()>\n+        where F: FnOnce(&mut LoopScope) -> BasicBlock\n+    {\n+        let (exit_block, extent) = {\n+            let loop_scope = self.find_loop_scope(span, label);\n+            (exit_selector(loop_scope), loop_scope.extent)\n+        };\n+        self.exit_scope(span, extent, block, exit_block);\n+        self.cfg.start_new_block().unit()\n+    }\n }"}, {"sha": "b7729b01737bad6628f5fbd22c76039aa603c92d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 78, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -12,12 +12,9 @@\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n-use build::scope::LoopScope;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n use rustc::ty;\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n@@ -207,65 +204,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n                 exit_block.unit()\n             }\n-            ExprKind::Assign { lhs, rhs } => {\n-                // Note: we evaluate assignments right-to-left. This\n-                // is better for borrowck interaction with overloaded\n-                // operators like x[j] = x[i].\n-                let lhs = this.hir.mirror(lhs);\n-                let lhs_span = lhs.span;\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                unpack!(block = this.build_drop(block, lhs_span, lhs.clone()));\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs, Rvalue::Use(rhs));\n-                block.unit()\n-            }\n-            ExprKind::AssignOp { op, lhs, rhs } => {\n-                // FIXME(#28160) there is an interesting semantics\n-                // question raised here -- should we \"freeze\" the\n-                // value of the lhs here?  I'm inclined to think not,\n-                // since it seems closer to the semantics of the\n-                // overloaded version, which takes `&mut self`.  This\n-                // only affects weird things like `x += {x += 1; x}`\n-                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n-\n-                // As above, RTL.\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-\n-                // we don't have to drop prior contents or anything\n-                // because AssignOp is only legal for Copy types\n-                // (overloaded ops should be desugared into a call).\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Consume(lhs.clone()),\n-                                                      rhs));\n-\n-                block.unit()\n-            }\n-            ExprKind::Continue { label } => {\n-                this.break_or_continue(expr_span, label, block,\n-                                       |loop_scope| loop_scope.continue_block)\n-            }\n-            ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block, |loop_scope| {\n-                    loop_scope.might_break = true;\n-                    loop_scope.break_block\n-                })\n-            }\n-            ExprKind::Return { value } => {\n-                block = match value {\n-                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n-                    None => {\n-                        this.cfg.push_assign_unit(block, scope_id,\n-                                                  expr_span, &Lvalue::ReturnPointer);\n-                        block\n-                    }\n-                };\n-                let extent = this.extent_of_return_scope();\n-                let return_block = this.return_block();\n-                this.exit_scope(expr_span, extent, block, return_block);\n-                this.cfg.start_new_block().unit()\n-            }\n             ExprKind::Call { ty, fun, args } => {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n@@ -294,6 +232,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 success.unit()\n             }\n \n+            // These cases don't actually need a destination\n+            ExprKind::Assign { .. } |\n+            ExprKind::AssignOp { .. } |\n+            ExprKind::Continue { .. } |\n+            ExprKind::Break { .. } |\n+            ExprKind::Return {.. } => {\n+                this.stmt_expr(block, expr)\n+            }\n+\n             // these are the cases that are more naturally handled by some other mode\n             ExprKind::Unary { .. } |\n             ExprKind::Binary { .. } |\n@@ -327,20 +274,4 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n         }\n     }\n-\n-    fn break_or_continue<F>(&mut self,\n-                            span: Span,\n-                            label: Option<CodeExtent>,\n-                            block: BasicBlock,\n-                            exit_selector: F)\n-                            -> BlockAnd<()>\n-        where F: FnOnce(&mut LoopScope) -> BasicBlock\n-    {\n-        let (exit_block, extent) = {\n-            let loop_scope = self.find_loop_scope(span, label);\n-            (exit_selector(loop_scope), loop_scope.extent)\n-        };\n-        self.exit_scope(span, extent, block, exit_block);\n-        self.cfg.start_new_block().unit()\n-    }\n }"}, {"sha": "b131b0ad5c11d593eb303b9ba84767c87a5411d6", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -75,5 +75,5 @@ mod as_lvalue;\n mod as_rvalue;\n mod as_operand;\n mod as_temp;\n-mod category;\n+pub mod category;\n mod into;"}, {"sha": "95c931df9e5cc3a7f56cd5c01faade649b59f762", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -497,8 +497,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn build_drop(&mut self,\n                       block: BasicBlock,\n                       span: Span,\n-                      value: Lvalue<'tcx>)\n-                      -> BlockAnd<()> {\n+                      value: Lvalue<'tcx>,\n+                      ty: Ty<'tcx>) -> BlockAnd<()> {\n+        if !self.hir.needs_drop(ty) {\n+            return block.unit();\n+        }\n         let scope_id = self.innermost_scope_id();\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();"}, {"sha": "6730f8c0fcc79a9163c10b8874e48068bddb53ae", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -20,7 +20,7 @@ use super::rvalue;\n pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n                                mir: &mir::Mir<'tcx>)\n                                -> BitVector {\n-    let mut analyzer = TempAnalyzer::new(mir.temp_decls.len());\n+    let mut analyzer = TempAnalyzer::new(mir, bcx, mir.temp_decls.len());\n \n     analyzer.visit_mir(mir);\n \n@@ -30,7 +30,8 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n         if ty.is_scalar() ||\n             ty.is_unique() ||\n             ty.is_region_ptr() ||\n-            ty.is_simd()\n+            ty.is_simd() ||\n+            common::type_is_zero_size(bcx.ccx(), ty)\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n@@ -50,14 +51,20 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n     analyzer.lvalue_temps\n }\n \n-struct TempAnalyzer {\n+struct TempAnalyzer<'mir, 'bcx, 'tcx: 'mir + 'bcx> {\n+    mir: &'mir mir::Mir<'tcx>,\n+    bcx: Block<'bcx, 'tcx>,\n     lvalue_temps: BitVector,\n     seen_assigned: BitVector\n }\n \n-impl TempAnalyzer {\n-    fn new(temp_count: usize) -> TempAnalyzer {\n+impl<'mir, 'bcx, 'tcx> TempAnalyzer<'mir, 'bcx, 'tcx> {\n+    fn new(mir: &'mir mir::Mir<'tcx>,\n+           bcx: Block<'bcx, 'tcx>,\n+           temp_count: usize) -> TempAnalyzer<'mir, 'bcx, 'tcx> {\n         TempAnalyzer {\n+            mir: mir,\n+            bcx: bcx,\n             lvalue_temps: BitVector::new(temp_count),\n             seen_assigned: BitVector::new(temp_count)\n         }\n@@ -75,7 +82,7 @@ impl TempAnalyzer {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n+impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     lvalue: &mir::Lvalue<'tcx>,\n@@ -85,7 +92,7 @@ impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n         match *lvalue {\n             mir::Lvalue::Temp(index) => {\n                 self.mark_assigned(index as usize);\n-                if !rvalue::rvalue_creates_operand(rvalue) {\n+                if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n                     self.mark_as_lvalue(index as usize);\n                 }\n             }"}, {"sha": "a5e116ae7b6262f8e5dabd88ea0397a88bb354ac", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -34,7 +34,7 @@ use rustc_data_structures::bitvec::BitVector;\n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use rustc_mir::traversal;\n \n-use self::operand::OperandRef;\n+use self::operand::{OperandRef, OperandValue};\n \n #[derive(Clone)]\n pub enum CachedMir<'mir, 'tcx: 'mir> {\n@@ -150,6 +150,15 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   TempRef::Lvalue(LvalueRef::alloca(&bcx,\n                                                                     mty,\n                                                                     &format!(\"temp{:?}\", i)))\n+                              } else if common::type_is_zero_size(bcx.ccx(), mty) {\n+                                  // Zero-size temporaries aren't always initialized, which\n+                                  // doesn't matter because they don't contain data, but\n+                                  // we need something in the operand.\n+                                  let op = OperandRef {\n+                                      val: OperandValue::Immediate(common::C_nil(bcx.ccx())),\n+                                      ty: mty\n+                                  };\n+                                  TempRef::Operand(Some(op))\n                               } else {\n                                   // If this is an immediate temp, we do not create an\n                                   // alloca in advance. Instead we wait until we see the"}, {"sha": "3050d2c5290b784e7e34f025936c6acf7e362c59", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::repr as mir;\n use asm;\n use base;\n use callee::Callee;\n-use common::{self, C_uint, BlockAndBuilder, Result};\n+use common::{self, C_uint, Block, BlockAndBuilder, Result};\n use datum::{Datum, Lvalue};\n use debuginfo::DebugLoc;\n use declare;\n@@ -29,6 +29,7 @@ use type_of;\n use tvec;\n use value::Value;\n use Disr;\n+use glue;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n@@ -217,7 +218,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             _ => {\n-                assert!(rvalue_creates_operand(rvalue));\n+                bcx.with_block(|bcx| {\n+                    assert!(rvalue_creates_operand(&self.mir, bcx, rvalue));\n+                });\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                 self.store_operand(&bcx, dest.llval, temp);\n                 bcx\n@@ -231,7 +234,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 debug_loc: DebugLoc)\n                                 -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n-        assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+        bcx.with_block(|bcx| {\n+            assert!(rvalue_creates_operand(&self.mir, bcx, rvalue),\n+                    \"cannot trans {:?} to operand\", rvalue);\n+        });\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -483,7 +489,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n-            mir::Rvalue::Use(..) |\n+            mir::Rvalue::Use(ref operand) => {\n+                let operand = self.trans_operand(&bcx, operand);\n+                (bcx, operand)\n+            }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n@@ -599,7 +608,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n }\n \n-pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n+pub fn rvalue_creates_operand<'bcx, 'tcx>(mir: &mir::Mir<'tcx>, bcx: Block<'bcx, 'tcx>,\n+                                          rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n         mir::Rvalue::Ref(..) |\n         mir::Rvalue::Len(..) |\n@@ -608,16 +618,20 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Box(..) =>\n             true,\n-        mir::Rvalue::Use(..) | // (**)\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n         mir::Rvalue::Slice { .. } |\n         mir::Rvalue::InlineAsm { .. } =>\n             false,\n+        mir::Rvalue::Use(ref operand) => {\n+            let ty = mir.operand_ty(bcx.tcx(), operand);\n+            let ty = bcx.monomorphize(&ty);\n+            // Types that don't need dropping can just be an operand,\n+            // this allows temporary lvalues, used as rvalues, to\n+            // avoid a stack slot when it's unnecessary\n+            !glue::type_needs_drop(bcx.tcx(), ty)\n+        }\n     }\n \n     // (*) this is only true if the type is suitable\n-    // (**) we need to zero-out the source operand after moving, so we are restricted to either\n-    // ensuring all users of `Use` zero it out themselves or not allowing to \u201ccreate\u201d operand for\n-    // it.\n }"}, {"sha": "6ec4ee3ce9326ae7e8da3a39ba0f8c54cb8ea936", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f242fe3c04621dca3aaa3ab288a3812b45633ffd/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=f242fe3c04621dca3aaa3ab288a3812b45633ffd", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::mir::repr as mir;\n-use common::BlockAndBuilder;\n+use common::{self, BlockAndBuilder};\n use debuginfo::DebugLoc;\n \n use super::MirContext;\n@@ -42,9 +42,20 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx\n                             }\n                             TempRef::Operand(Some(_)) => {\n-                                span_bug!(statement.span,\n-                                          \"operand {:?} already assigned\",\n-                                          rvalue);\n+                                let ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n+                                let ty = bcx.monomorphize(&ty.to_ty(bcx.tcx()));\n+\n+                                if !common::type_is_zero_size(bcx.ccx(), ty) {\n+                                    span_bug!(statement.span,\n+                                              \"operand {:?} already assigned\",\n+                                              rvalue);\n+                                } else {\n+                                    // If the type is zero-sized, it's already been set here,\n+                                    // but we still need to make sure we translate the operand\n+                                    let (bcx, _) = self.trans_rvalue_operand(bcx, rvalue,\n+                                                                                   debug_loc);\n+                                    bcx\n+                                }\n                             }\n                         }\n                     }"}]}