{"sha": "2be62451799456eb2b7c07aa173b800264e41bdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZTYyNDUxNzk5NDU2ZWIyYjdjMDdhYTE3M2I4MDAyNjRlNDFiZGI=", "commit": {"author": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-08T08:51:44Z"}, "committer": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-08T08:51:44Z"}, "message": "Duplicate ptr_arg's suggestion logic", "tree": {"sha": "8a750c011946826ce0c709b02f7657360c8fddbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a750c011946826ce0c709b02f7657360c8fddbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2be62451799456eb2b7c07aa173b800264e41bdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2be62451799456eb2b7c07aa173b800264e41bdb", "html_url": "https://github.com/rust-lang/rust/commit/2be62451799456eb2b7c07aa173b800264e41bdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2be62451799456eb2b7c07aa173b800264e41bdb/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c", "html_url": "https://github.com/rust-lang/rust/commit/bf97cd0338aa0de4d4e3946f7ccb68a2ac19193c"}], "stats": {"total": 255, "additions": 183, "deletions": 72}, "files": [{"sha": "a995593e8e5fb93fb5a9ae9a5dcbec58e2fb877c", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=2be62451799456eb2b7c07aa173b800264e41bdb", "patch": "@@ -9,8 +9,10 @@ use syntax::ast::NodeId;\n use syntax_pos::Span;\n use syntax::errors::DiagnosticBuilder;\n use utils::{get_trait_def_id, implements_trait, in_macro, is_copy, is_self, match_type, multispan_sugg, paths,\n-            snippet, span_lint_and_then};\n+            snippet, snippet_opt, span_lint_and_then};\n+use utils::ptr::get_spans;\n use std::collections::{HashMap, HashSet};\n+use std::borrow::Cow;\n \n /// **What it does:** Checks for functions taking arguments by value, but not\n /// consuming them in its\n@@ -109,7 +111,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n         let fn_sig = cx.tcx.fn_sig(fn_def_id);\n         let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n \n-        for ((input, &ty), arg) in decl.inputs.iter().zip(fn_sig.inputs()).zip(&body.arguments) {\n+        for (idx, ((input, &ty), arg)) in decl.inputs\n+            .iter()\n+            .zip(fn_sig.inputs())\n+            .zip(&body.arguments)\n+            .enumerate()\n+        {\n             // * Exclude a type that is specifically bounded by `Borrow`.\n             // * Exclude a type whose reference also fulfills its bound.\n             //   (e.g. `std::borrow::Borrow`, `serde::Serialize`)\n@@ -152,6 +159,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     let deref_span = spans_need_deref.get(&canonical_id);\n                     if_let_chain! {[\n                         match_type(cx, ty, &paths::VEC),\n+                        let Some(clone_spans) =\n+                            get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]),\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n                         let Some(elem_ty) = path.segments.iter()\n                             .find(|seg| seg.name == \"Vec\")\n@@ -162,14 +171,44 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                         db.span_suggestion(input.span,\n                                         \"consider changing the type to\",\n                                         slice_ty);\n+\n+                        for (span, suggestion) in clone_spans {\n+                            db.span_suggestion(\n+                                span,\n+                                &snippet_opt(cx, span)\n+                                    .map_or(\n+                                        \"change the call to\".into(),\n+                                        |x| Cow::from(format!(\"change `{}` to\", x)),\n+                                    ),\n+                                suggestion.into()\n+                            );\n+                        }\n+\n+                        // cannot be destructured, no need for `*` suggestion\n                         assert!(deref_span.is_none());\n-                        return; // `Vec` cannot be destructured - no need for `*` suggestion\n+                        return;\n                     }}\n \n                     if match_type(cx, ty, &paths::STRING) {\n-                        db.span_suggestion(input.span, \"consider changing the type to\", \"&str\".to_string());\n-                        assert!(deref_span.is_none());\n-                        return; // ditto\n+                        if let Some(clone_spans) =\n+                            get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n+                            db.span_suggestion(input.span, \"consider changing the type to\", \"&str\".to_string());\n+\n+                            for (span, suggestion) in clone_spans {\n+                                db.span_suggestion(\n+                                    span,\n+                                    &snippet_opt(cx, span)\n+                                        .map_or(\n+                                            \"change the call to\".into(),\n+                                            |x| Cow::from(format!(\"change `{}` to\", x))\n+                                        ),\n+                                    suggestion.into(),\n+                                );\n+                            }\n+\n+                            assert!(deref_span.is_none());\n+                            return;\n+                        }\n                     }\n \n                     let mut spans = vec![(input.span, format!(\"&{}\", snippet(cx, input.span, \"_\")))];"}, {"sha": "8f42750e19b12935b8e50467f84a3b3eecb27417", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 5, "deletions": 66, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=2be62451799456eb2b7c07aa173b800264e41bdb", "patch": "@@ -2,16 +2,15 @@\n \n use std::borrow::Cow;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::hir::map::NodeItem;\n use rustc::lint::*;\n use rustc::ty;\n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax_pos::MultiSpan;\n-use utils::{get_pat_name, match_qpath, match_type, match_var, paths,\n-            snippet, snippet_opt, span_lint, span_lint_and_then,\n+use utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then,\n             walk_ptrs_hir_ty};\n+use utils::ptr::get_spans;\n \n /// **What it does:** This lint checks for function arguments of type `&String`\n /// or `&Vec` unless the references are mutable. It will also suggest you\n@@ -164,7 +163,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 ], {\n                     ty_snippet = snippet_opt(cx, parameters.types[0].span);\n                 });\n-                if let Ok(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n+                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n                     span_lint_and_then(\n                         cx,\n                         PTR_ARG,\n@@ -187,7 +186,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                     );\n                 }\n             } else if match_type(cx, ty, &paths::STRING) {\n-                if let Ok(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n+                if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n                     span_lint_and_then(\n                         cx,\n                         PTR_ARG,\n@@ -234,66 +233,6 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n     }\n }\n \n-fn get_spans(cx: &LateContext, opt_body_id: Option<BodyId>, idx: usize, replacements: &'static [(&'static str, &'static str)]) -> Result<Vec<(Span, Cow<'static, str>)>, ()> {\n-    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n-        get_binding_name(&body.arguments[idx]).map_or_else(|| Ok(vec![]),\n-                                                |name| extract_clone_suggestions(cx, name, replacements, body))\n-    } else {\n-        Ok(vec![])\n-    }\n-}\n-\n-fn extract_clone_suggestions<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, name: Name, replace: &'static [(&'static str, &'static str)], body: &'tcx Body) -> Result<Vec<(Span, Cow<'static, str>)>, ()> {\n-    let mut visitor = PtrCloneVisitor {\n-        cx,\n-        name,\n-        replace,\n-        spans: vec![],\n-        abort: false,\n-    };\n-    visitor.visit_body(body);\n-    if visitor.abort { Err(()) } else { Ok(visitor.spans) }\n-}\n-\n-struct PtrCloneVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,\n-    name: Name,\n-    replace: &'static [(&'static str, &'static str)],\n-    spans: Vec<(Span, Cow<'static, str>)>,\n-    abort: bool,\n-}\n-\n-impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if self.abort { return; }\n-        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n-            if args.len() == 1 && match_var(&args[0], self.name) {\n-                if seg.name == \"capacity\" {\n-                    self.abort = true;\n-                    return;\n-                }\n-                for &(fn_name, suffix) in self.replace {\n-                    if seg.name == fn_name {\n-                        self.spans.push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n-                        return;\n-                    }\n-                }\n-            }\n-            return;\n-        }\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-}\n-\n-fn get_binding_name(arg: &Arg) -> Option<Name> {\n-    get_pat_name(&arg.pat)\n-}\n-\n fn get_rptr_lm(ty: &Ty) -> Option<(&Lifetime, Mutability, Span)> {\n     if let Ty_::TyRptr(ref lt, ref m) = ty.node {\n         Some((lt, m.mutbl, ty.span))"}, {"sha": "07caf07ac8d3bfcef3b2a50a0df0739b1f4903d7", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=2be62451799456eb2b7c07aa173b800264e41bdb", "patch": "@@ -32,6 +32,7 @@ pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n pub mod author;\n+pub mod ptr;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;"}, {"sha": "7782fb8bc76bf2ee36da3ea13391b3a4ddae365c", "filename": "clippy_lints/src/utils/ptr.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be62451799456eb2b7c07aa173b800264e41bdb/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=2be62451799456eb2b7c07aa173b800264e41bdb", "patch": "@@ -0,0 +1,83 @@\n+use std::borrow::Cow;\n+use rustc::hir::*;\n+use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc::lint::LateContext;\n+use syntax::ast::Name;\n+use syntax::codemap::Span;\n+use utils::{get_pat_name, match_var, snippet};\n+\n+pub fn get_spans(\n+    cx: &LateContext,\n+    opt_body_id: Option<BodyId>,\n+    idx: usize,\n+    replacements: &'static [(&'static str, &'static str)],\n+) -> Option<Vec<(Span, Cow<'static, str>)>> {\n+    if let Some(body) = opt_body_id.map(|id| cx.tcx.hir.body(id)) {\n+        get_binding_name(&body.arguments[idx])\n+            .map_or_else(|| Some(vec![]), |name| extract_clone_suggestions(cx, name, replacements, body))\n+    } else {\n+        Some(vec![])\n+    }\n+}\n+\n+fn extract_clone_suggestions<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    name: Name,\n+    replace: &'static [(&'static str, &'static str)],\n+    body: &'tcx Body,\n+) -> Option<Vec<(Span, Cow<'static, str>)>> {\n+    let mut visitor = PtrCloneVisitor {\n+        cx,\n+        name,\n+        replace,\n+        spans: vec![],\n+        abort: false,\n+    };\n+    visitor.visit_body(body);\n+    if visitor.abort {\n+        None\n+    } else {\n+        Some(visitor.spans)\n+    }\n+}\n+\n+struct PtrCloneVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+    name: Name,\n+    replace: &'static [(&'static str, &'static str)],\n+    spans: Vec<(Span, Cow<'static, str>)>,\n+    abort: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if self.abort {\n+            return;\n+        }\n+        if let ExprMethodCall(ref seg, _, ref args) = expr.node {\n+            if args.len() == 1 && match_var(&args[0], self.name) {\n+                if seg.name == \"capacity\" {\n+                    self.abort = true;\n+                    return;\n+                }\n+                for &(fn_name, suffix) in self.replace {\n+                    if seg.name == fn_name {\n+                        self.spans\n+                            .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n+                        return;\n+                    }\n+                }\n+            }\n+            return;\n+        }\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+fn get_binding_name(arg: &Arg) -> Option<Name> {\n+    get_pat_name(&arg.pat)\n+}"}, {"sha": "ac37b0bdda16860c071194326867513dde52beaa", "filename": "tests/ui/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2be62451799456eb2b7c07aa173b800264e41bdb/tests%2Fui%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be62451799456eb2b7c07aa173b800264e41bdb/tests%2Fui%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.rs?ref=2be62451799456eb2b7c07aa173b800264e41bdb", "patch": "@@ -72,4 +72,11 @@ impl Serialize for i32 {}\n \n fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n \n+fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+    s.capacity();\n+    let _ = t.clone();\n+    u.capacity();\n+    let _ = v.clone();\n+}\n+\n fn main() {}"}, {"sha": "f23b0714c599e4cb2c9dad11edae45116f96f158", "filename": "tests/ui/needless_pass_by_value.stderr", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2be62451799456eb2b7c07aa173b800264e41bdb/tests%2Fui%2Fneedless_pass_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2be62451799456eb2b7c07aa173b800264e41bdb/tests%2Fui%2Fneedless_pass_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_pass_by_value.stderr?ref=2be62451799456eb2b7c07aa173b800264e41bdb", "patch": "@@ -62,3 +62,45 @@ error: this argument is passed by value, but not consumed in the function body\n 73 | fn test_blanket_ref<T: Foo, S: Serialize>(_foo: T, _serializable: S) {}\n    |                                                 ^ help: consider taking a reference instead: `&T`\n \n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:18\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                  ^^^^^^ help: consider taking a reference instead: `&String`\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:29\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                             ^^^^^^\n+   |\n+help: consider changing the type to\n+   |\n+75 | fn issue_2114(s: String, t: &str, u: Vec<i32>, v: Vec<i32>) {\n+   |                             ^^^^\n+help: change `t.clone()` to\n+   |\n+77 |     let _ = t.to_string();\n+   |             ^^^^^^^^^^^^^\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:40\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                                        ^^^^^^^^ help: consider taking a reference instead: `&Vec<i32>`\n+\n+error: this argument is passed by value, but not consumed in the function body\n+  --> $DIR/needless_pass_by_value.rs:75:53\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: Vec<i32>) {\n+   |                                                     ^^^^^^^^\n+   |\n+help: consider changing the type to\n+   |\n+75 | fn issue_2114(s: String, t: String, u: Vec<i32>, v: &[i32]) {\n+   |                                                     ^^^^^^\n+help: change `v.clone()` to\n+   |\n+79 |     let _ = v.to_owned();\n+   |             ^^^^^^^^^^^^\n+"}]}