{"sha": "a990c76d84ccc5c285cbd533ea6020778fa18863", "node_id": "C_kwDOAAsO6NoAKGE5OTBjNzZkODRjY2M1YzI4NWNiZDUzM2VhNjAyMDc3OGZhMTg4NjM", "commit": {"author": {"name": "John Kugelman", "email": "john@kugelman.name", "date": "2021-10-05T23:50:28Z"}, "committer": {"name": "John Kugelman", "email": "john@kugelman.name", "date": "2021-10-07T22:42:02Z"}, "message": "Optimize File::read_to_end and read_to_string\n\nReading a file into an empty vector or string buffer can incur\nunnecessary `read` syscalls and memory re-allocations as the buffer\n\"warms up\" and grows to its final size. This is perhaps a necessary evil\nwith generic readers, but files can be read in smarter by checking the\nfile size and reserving that much capacity.\n\n`std::fs::read` and `read_to_string` already perform this optimization:\nthey open the file, reads its metadata, and call `with_capacity` with\nthe file size. This ensures that the buffer does not need to be resized\nand an initial string of small `read` syscalls.\n\nHowever, if a user opens the `File` themselves and calls\n`file.read_to_end` or `file.read_to_string` they do not get this\noptimization.\n\n```rust\nlet mut buf = Vec::new();\nfile.read_to_end(&mut buf)?;\n```\n\nI searched through this project's codebase and even here are a *lot* of\nexamples of this. They're found all over in unit tests, which isn't a\nbig deal, but there are also several real instances in the compiler and\nin Cargo. I've documented the ones I found in a comment here:\n\nhttps://github.com/rust-lang/rust/issues/89516#issuecomment-934423999\n\nMost telling, the `Read` trait and the `read_to_end` method both show\nthis exact pattern as examples of how to use readers. What this says to\nme is that this shouldn't be solved by simply fixing the instances of it\nin this codebase. If it's here it's certain to be prevalent in the wider\nRust ecosystem.\n\nTo that end, this commit adds specializations of `read_to_end` and\n`read_to_string` directly on `File`. This way it's no longer a minor\nfootgun to start with an empty buffer when reading a file in.\n\nA nice side effect of this change is that code that accesses a `File` as\na bare `Read` constraint or via a `dyn Read` trait object will benefit.\nFor example, this code from `compiler/rustc_serialize/src/json.rs`:\n\n```rust\npub fn from_reader(rdr: &mut dyn Read) -> Result<Json, BuilderError> {\n    let mut contents = Vec::new();\n    match rdr.read_to_end(&mut contents) {\n```\n\nRelated changes:\n\n- I also added specializations to `BufReader` to delegate to\n  `self.inner`'s methods. That way it can call `File`'s optimized\n  implementations if the inner reader is a file.\n\n- The private `std::io::append_to_string` function is now marked\n  `unsafe`.\n\n- `File::read_to_string` being more efficient means that the performance\n  note for `io::read_to_string` can be softened. I've added @camelid's\n  suggested wording from:\n\n  https://github.com/rust-lang/rust/issues/80218#issuecomment-936806502", "tree": {"sha": "7a2e80622a6b8fe1d44f8bba788c8702d2216df2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a2e80622a6b8fe1d44f8bba788c8702d2216df2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a990c76d84ccc5c285cbd533ea6020778fa18863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a990c76d84ccc5c285cbd533ea6020778fa18863", "html_url": "https://github.com/rust-lang/rust/commit/a990c76d84ccc5c285cbd533ea6020778fa18863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a990c76d84ccc5c285cbd533ea6020778fa18863/comments", "author": {"login": "jkugelman", "id": 4551859, "node_id": "MDQ6VXNlcjQ1NTE4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4551859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkugelman", "html_url": "https://github.com/jkugelman", "followers_url": "https://api.github.com/users/jkugelman/followers", "following_url": "https://api.github.com/users/jkugelman/following{/other_user}", "gists_url": "https://api.github.com/users/jkugelman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkugelman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkugelman/subscriptions", "organizations_url": "https://api.github.com/users/jkugelman/orgs", "repos_url": "https://api.github.com/users/jkugelman/repos", "events_url": "https://api.github.com/users/jkugelman/events{/privacy}", "received_events_url": "https://api.github.com/users/jkugelman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jkugelman", "id": 4551859, "node_id": "MDQ6VXNlcjQ1NTE4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4551859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jkugelman", "html_url": "https://github.com/jkugelman", "followers_url": "https://api.github.com/users/jkugelman/followers", "following_url": "https://api.github.com/users/jkugelman/following{/other_user}", "gists_url": "https://api.github.com/users/jkugelman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jkugelman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jkugelman/subscriptions", "organizations_url": "https://api.github.com/users/jkugelman/orgs", "repos_url": "https://api.github.com/users/jkugelman/repos", "events_url": "https://api.github.com/users/jkugelman/events{/privacy}", "received_events_url": "https://api.github.com/users/jkugelman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25ec8273855fde2d72ae877b397e054de5300e10", "url": "https://api.github.com/repos/rust-lang/rust/commits/25ec8273855fde2d72ae877b397e054de5300e10", "html_url": "https://github.com/rust-lang/rust/commit/25ec8273855fde2d72ae877b397e054de5300e10"}], "stats": {"total": 192, "additions": 146, "deletions": 46}, "files": [{"sha": "726c855c4fd36f4903a02e99bcd3da0f98e82634", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=a990c76d84ccc5c285cbd533ea6020778fa18863", "patch": "@@ -198,19 +198,10 @@ pub struct DirBuilder {\n     recursive: bool,\n }\n \n-/// Indicates how large a buffer to pre-allocate before reading the entire file.\n-fn initial_buffer_size(file: &File) -> usize {\n-    // Don't worry about `usize` overflow because reading will fail regardless\n-    // in that case.\n-    file.metadata().map(|m| m.len() as usize).unwrap_or(0)\n-}\n-\n /// Read the entire contents of a file into a bytes vector.\n ///\n /// This is a convenience function for using [`File::open`] and [`read_to_end`]\n-/// with fewer imports and without an intermediate variable. It pre-allocates a\n-/// buffer based on the file size when available, so it is generally faster than\n-/// reading into a vector created with [`Vec::new()`].\n+/// with fewer imports and without an intermediate variable.\n ///\n /// [`read_to_end`]: Read::read_to_end\n ///\n@@ -237,7 +228,7 @@ fn initial_buffer_size(file: &File) -> usize {\n pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n     fn inner(path: &Path) -> io::Result<Vec<u8>> {\n         let mut file = File::open(path)?;\n-        let mut bytes = Vec::with_capacity(initial_buffer_size(&file));\n+        let mut bytes = Vec::new();\n         file.read_to_end(&mut bytes)?;\n         Ok(bytes)\n     }\n@@ -247,9 +238,7 @@ pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n /// Read the entire contents of a file into a string.\n ///\n /// This is a convenience function for using [`File::open`] and [`read_to_string`]\n-/// with fewer imports and without an intermediate variable. It pre-allocates a\n-/// buffer based on the file size when available, so it is generally faster than\n-/// reading into a string created with [`String::new()`].\n+/// with fewer imports and without an intermediate variable.\n ///\n /// [`read_to_string`]: Read::read_to_string\n ///\n@@ -278,7 +267,7 @@ pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n pub fn read_to_string<P: AsRef<Path>>(path: P) -> io::Result<String> {\n     fn inner(path: &Path) -> io::Result<String> {\n         let mut file = File::open(path)?;\n-        let mut string = String::with_capacity(initial_buffer_size(&file));\n+        let mut string = String::new();\n         file.read_to_string(&mut string)?;\n         Ok(string)\n     }\n@@ -615,6 +604,15 @@ impl fmt::Debug for File {\n     }\n }\n \n+/// Indicates how much extra capacity is needed to read the rest of the file.\n+fn buffer_capacity_required(mut file: &File) -> usize {\n+    let size = file.metadata().map(|m| m.len()).unwrap_or(0);\n+    let pos = file.stream_position().unwrap_or(0);\n+    // Don't worry about `usize` overflow because reading will fail regardless\n+    // in that case.\n+    size.saturating_sub(pos) as usize\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -635,6 +633,18 @@ impl Read for File {\n         // SAFETY: Read is guaranteed to work on uninitialized memory\n         unsafe { Initializer::nop() }\n     }\n+\n+    // Reserves space in the buffer based on the file size when available.\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        buf.reserve(buffer_capacity_required(self));\n+        io::default_read_to_end(self, buf)\n+    }\n+\n+    // Reserves space in the buffer based on the file size when available.\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        buf.reserve(buffer_capacity_required(self));\n+        io::default_read_to_string(self, buf)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for File {\n@@ -681,6 +691,18 @@ impl Read for &File {\n         // SAFETY: Read is guaranteed to work on uninitialized memory\n         unsafe { Initializer::nop() }\n     }\n+\n+    // Reserves space in the buffer based on the file size when available.\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        buf.reserve(buffer_capacity_required(self));\n+        io::default_read_to_end(self, buf)\n+    }\n+\n+    // Reserves space in the buffer based on the file size when available.\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        buf.reserve(buffer_capacity_required(self));\n+        io::default_read_to_string(self, buf)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for &File {"}, {"sha": "243207a6065449cd4467f6f4fe88f674096c7745", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=a990c76d84ccc5c285cbd533ea6020778fa18863", "patch": "@@ -308,6 +308,51 @@ impl<R: Read> Read for BufReader<R> {\n     unsafe fn initializer(&self) -> Initializer {\n         self.inner.initializer()\n     }\n+\n+    // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n+    // delegate to the inner implementation.\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        let nread = self.cap - self.pos;\n+        buf.extend_from_slice(&self.buf[self.pos..self.cap]);\n+        self.discard_buffer();\n+        Ok(nread + self.inner.read_to_end(buf)?)\n+    }\n+\n+    // The inner reader might have an optimized `read_to_end`. Drain our buffer and then\n+    // delegate to the inner implementation.\n+    fn read_to_string(&mut self, buf: &mut String) -> io::Result<usize> {\n+        // In the general `else` case below we must read bytes into a side buffer, check\n+        // that they are valid UTF-8, and then append them to `buf`. This requires a\n+        // potentially large memcpy.\n+        //\n+        // If `buf` is empty--the most common case--we can leverage `append_to_string`\n+        // to read directly into `buf`'s internal byte buffer, saving an allocation and\n+        // a memcpy.\n+        if buf.is_empty() {\n+            // `append_to_string`'s safety relies on the buffer only being appended to since\n+            // it only checks the UTF-8 validity of new data. If there were existing content in\n+            // `buf` then an untrustworthy reader (i.e. `self.inner`) could not only append\n+            // bytes but also modify existing bytes and render them invalid. On the other hand,\n+            // if `buf` is empty then by definition any writes must be appends and\n+            // `append_to_string` will validate all of the new bytes.\n+            unsafe { crate::io::append_to_string(buf, |b| self.read_to_end(b)) }\n+        } else {\n+            // We cannot append our byte buffer directly onto the `buf` String as there could\n+            // be an incomplete UTF-8 sequence that has only been partially read. We must read\n+            // everything into a side buffer first and then call `from_utf8` on the complete\n+            // buffer.\n+            let mut bytes = Vec::new();\n+            self.read_to_end(&mut bytes)?;\n+            let string = crate::str::from_utf8(&bytes).map_err(|_| {\n+                io::Error::new_const(\n+                    io::ErrorKind::InvalidData,\n+                    &\"stream did not contain valid UTF-8\",\n+                )\n+            })?;\n+            *buf += string;\n+            Ok(string.len())\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "feb149c07a525010b5aa4d1ca6cafe1e67005b48", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=a990c76d84ccc5c285cbd533ea6020778fa18863", "patch": "@@ -243,6 +243,28 @@ fn test_buffered_reader_seek_underflow_discard_buffer_between_seeks() {\n     assert_eq!(reader.buffer().len(), 0);\n }\n \n+#[test]\n+fn test_buffered_reader_read_to_end_consumes_buffer() {\n+    let data: &[u8] = &[0, 1, 2, 3, 4, 5, 6, 7];\n+    let mut reader = BufReader::with_capacity(3, data);\n+    let mut buf = Vec::new();\n+    assert_eq!(reader.fill_buf().ok(), Some(&[0, 1, 2][..]));\n+    assert_eq!(reader.read_to_end(&mut buf).ok(), Some(8));\n+    assert_eq!(&buf, &[0, 1, 2, 3, 4, 5, 6, 7]);\n+    assert!(reader.buffer().is_empty());\n+}\n+\n+#[test]\n+fn test_buffered_reader_read_to_string_consumes_buffer() {\n+    let data: &[u8] = \"deadbeef\".as_bytes();\n+    let mut reader = BufReader::with_capacity(3, data);\n+    let mut buf = String::new();\n+    assert_eq!(reader.fill_buf().ok(), Some(\"dea\".as_bytes()));\n+    assert_eq!(reader.read_to_string(&mut buf).ok(), Some(8));\n+    assert_eq!(&buf, \"deadbeef\");\n+    assert!(reader.buffer().is_empty());\n+}\n+\n #[test]\n fn test_buffered_writer() {\n     let inner = Vec::new();"}, {"sha": "8c71138aa231db8920ac2c4f84cb97671d3cead9", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a990c76d84ccc5c285cbd533ea6020778fa18863", "patch": "@@ -316,11 +316,12 @@ impl Drop for Guard<'_> {\n     }\n }\n \n-// A few methods below (read_to_string, read_line) will append data into a\n-// `String` buffer, but we need to be pretty careful when doing this. The\n-// implementation will just call `.as_mut_vec()` and then delegate to a\n-// byte-oriented reading method, but we must ensure that when returning we never\n-// leave `buf` in a state such that it contains invalid UTF-8 in its bounds.\n+// Several `read_to_string` and `read_line` methods in the standard library will\n+// append data into a `String` buffer, but we need to be pretty careful when\n+// doing this. The implementation will just call `.as_mut_vec()` and then\n+// delegate to a byte-oriented reading method, but we must ensure that when\n+// returning we never leave `buf` in a state such that it contains invalid UTF-8\n+// in its bounds.\n //\n // To this end, we use an RAII guard (to protect against panics) which updates\n // the length of the string when it is dropped. This guard initially truncates\n@@ -334,21 +335,19 @@ impl Drop for Guard<'_> {\n // 2. We're passing a raw buffer to the function `f`, and it is expected that\n //    the function only *appends* bytes to the buffer. We'll get undefined\n //    behavior if existing bytes are overwritten to have non-UTF-8 data.\n-fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n+pub(crate) unsafe fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n where\n     F: FnOnce(&mut Vec<u8>) -> Result<usize>,\n {\n-    unsafe {\n-        let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n-        let ret = f(g.buf);\n-        if str::from_utf8(&g.buf[g.len..]).is_err() {\n-            ret.and_then(|_| {\n-                Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n-            })\n-        } else {\n-            g.len = g.buf.len();\n-            ret\n-        }\n+    let mut g = Guard { len: buf.len(), buf: buf.as_mut_vec() };\n+    let ret = f(g.buf);\n+    if str::from_utf8(&g.buf[g.len..]).is_err() {\n+        ret.and_then(|_| {\n+            Err(Error::new_const(ErrorKind::InvalidData, &\"stream did not contain valid UTF-8\"))\n+        })\n+    } else {\n+        g.len = g.buf.len();\n+        ret\n     }\n }\n \n@@ -361,7 +360,7 @@ where\n //\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n-fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n+pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n     let start_len = buf.len();\n     let start_cap = buf.capacity();\n     let mut g = Guard { len: buf.len(), buf };\n@@ -426,6 +425,22 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize>\n     }\n }\n \n+pub(crate) fn default_read_to_string<R: Read + ?Sized>(\n+    r: &mut R,\n+    buf: &mut String,\n+) -> Result<usize> {\n+    // Note that we do *not* call `r.read_to_end()` here. We are passing\n+    // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n+    // method to fill it up. An arbitrary implementation could overwrite the\n+    // entire contents of the vector, not just append to it (which is what\n+    // we are expecting).\n+    //\n+    // To prevent extraneously checking the UTF-8-ness of the entire buffer\n+    // we pass it to our hardcoded `default_read_to_end` implementation which\n+    // we know is guaranteed to only read data into the end of the buffer.\n+    unsafe { append_to_string(buf, |b| default_read_to_end(r, b)) }\n+}\n+\n pub(crate) fn default_read_vectored<F>(read: F, bufs: &mut [IoSliceMut<'_>]) -> Result<usize>\n where\n     F: FnOnce(&mut [u8]) -> Result<usize>,\n@@ -716,7 +731,7 @@ pub trait Read {\n     /// [`std::fs::read`]: crate::fs::read\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        read_to_end(self, buf)\n+        default_read_to_end(self, buf)\n     }\n \n     /// Read all bytes until EOF in this source, appending them to `buf`.\n@@ -759,16 +774,7 @@ pub trait Read {\n     /// [`std::fs::read_to_string`]: crate::fs::read_to_string\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n-        // Note that we do *not* call `.read_to_end()` here. We are passing\n-        // `&mut Vec<u8>` (the raw contents of `buf`) into the `read_to_end`\n-        // method to fill it up. An arbitrary implementation could overwrite the\n-        // entire contents of the vector, not just append to it (which is what\n-        // we are expecting).\n-        //\n-        // To prevent extraneously checking the UTF-8-ness of the entire buffer\n-        // we pass it to our hardcoded `read_to_end` implementation which we\n-        // know is guaranteed to only read data into the end of the buffer.\n-        append_to_string(buf, |b| read_to_end(self, b))\n+        default_read_to_string(self, buf)\n     }\n \n     /// Read the exact number of bytes required to fill `buf`.\n@@ -1005,6 +1011,11 @@ pub trait Read {\n /// need more control over performance, and in those cases you should definitely use\n /// [`Read::read_to_string`] directly.\n ///\n+/// Note that in some special cases, such as when reading files, this function will\n+/// pre-allocate memory based on the size of the input it is reading. In those\n+/// cases, the performance should be as good as if you had used\n+/// [`Read::read_to_string`] with a manually pre-allocated buffer.\n+///\n /// # Errors\n ///\n /// This function forces you to handle errors because the output (the `String`)\n@@ -2201,7 +2212,7 @@ pub trait BufRead: Read {\n         // Note that we are not calling the `.read_until` method here, but\n         // rather our hardcoded implementation. For more details as to why, see\n         // the comments in `read_to_end`.\n-        append_to_string(buf, |b| read_until(self, b'\\n', b))\n+        unsafe { append_to_string(buf, |b| read_until(self, b'\\n', b)) }\n     }\n \n     /// Returns an iterator over the contents of this reader split on the byte"}, {"sha": "0321a2b60b108c33bb4576ea9d6efe5c6d44b8d6", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a990c76d84ccc5c285cbd533ea6020778fa18863/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=a990c76d84ccc5c285cbd533ea6020778fa18863", "patch": "@@ -290,7 +290,7 @@ fn bench_read_to_end(b: &mut test::Bencher) {\n     b.iter(|| {\n         let mut lr = repeat(1).take(10000000);\n         let mut vec = Vec::with_capacity(1024);\n-        super::read_to_end(&mut lr, &mut vec)\n+        super::default_read_to_end(&mut lr, &mut vec)\n     });\n }\n "}]}