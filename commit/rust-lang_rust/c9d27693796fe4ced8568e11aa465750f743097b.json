{"sha": "c9d27693796fe4ced8568e11aa465750f743097b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZDI3NjkzNzk2ZmU0Y2VkODU2OGUxMWFhNDY1NzUwZjc0MzA5N2I=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-06T05:07:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-08-06T05:07:33Z"}, "message": "doc: Update for alt arrows", "tree": {"sha": "b2e96c30a41499631d94a23d0516c3fa34082aae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2e96c30a41499631d94a23d0516c3fa34082aae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9d27693796fe4ced8568e11aa465750f743097b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9d27693796fe4ced8568e11aa465750f743097b", "html_url": "https://github.com/rust-lang/rust/commit/c9d27693796fe4ced8568e11aa465750f743097b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9d27693796fe4ced8568e11aa465750f743097b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fe1c7071d9585f53748d8d0ccb5a06c7b850287", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe1c7071d9585f53748d8d0ccb5a06c7b850287", "html_url": "https://github.com/rust-lang/rust/commit/3fe1c7071d9585f53748d8d0ccb5a06c7b850287"}], "stats": {"total": 99, "additions": 58, "deletions": 41}, "files": [{"sha": "fb3d27e67e50d1d7582ac1478fd0c15c9ee8db9e", "filename": "doc/rust.md", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c9d27693796fe4ced8568e11aa465750f743097b/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9d27693796fe4ced8568e11aa465750f743097b/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c9d27693796fe4ced8568e11aa465750f743097b", "patch": "@@ -957,8 +957,8 @@ An example of a predicate that uses an unchecked block:\n \n fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n     alt ls {\n-      nil { u }\n-      cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n+      nil => u,\n+      cons(hd, tl) => f(hd, pure_foldl(*tl, f(hd, u), f))\n     }\n }\n \n@@ -1157,8 +1157,8 @@ class file_descriptor {\n     }\n     fn get_name() -> ~str {\n       alt self.name {\n-         none    { fail ~\"File has no name!\"; }\n-         some(n) { n }\n+         none    => fail ~\"File has no name!\",\n+         some(n) => n\n       }\n     }\n }\n@@ -2176,7 +2176,7 @@ then any `else` block is executed.\n ~~~~~~~~{.ebnf .gram}\n alt_expr : \"alt\" expr '{' alt_arm [ '|' alt_arm ] * '}' ;\n \n-alt_arm : alt_pat '{' block '}' ;\n+alt_arm : alt_pat '=>' expr_or_blockish ;\n \n alt_pat : pat [ \"to\" pat ] ? [ \"if\" expr ] ;\n ~~~~~~~~\n@@ -2199,9 +2199,9 @@ enum list<X> { nil, cons(X, @list<X>) }\n let x: list<int> = cons(10, @cons(11, @nil));\n \n alt x {\n-    cons(_, @nil) { fail ~\"singleton list\"; }\n-    cons(*)       { return; }\n-    nil           { fail ~\"empty list\"; }\n+    cons(_, @nil) => fail ~\"singleton list\",\n+    cons(*)       => return,\n+    nil           => fail ~\"empty list\"\n }\n ~~~~\n \n@@ -2228,16 +2228,16 @@ enum list<X> { nil, cons(X, @list<X>) }\n let x: list<int> = cons(10, @cons(11, @nil));\n \n alt x {\n-    cons(a, @cons(b, _)) {\n+    cons(a, @cons(b, _)) => {\n         process_pair(a,b);\n     }\n-    cons(10, _) {\n+    cons(10, _) => {\n         process_ten();\n     }\n-    nil {\n+    nil => {\n         return;\n     }\n-    _ {\n+    _ => {\n         fail;\n     }\n }\n@@ -2265,13 +2265,13 @@ fn main() {\n     };\n \n     alt r {\n-      {options: {choose: true, _}, _} {\n+      {options: {choose: true, _}, _} => {\n         choose_player(r)\n       }\n-      {player: p, options: {size: ~\"small\", _}, _} {\n+      {player: p, options: {size: ~\"small\", _}, _} => {\n         log(info, p + ~\" is small\");\n       }\n-      _ {\n+      _ => {\n         next_player();\n       }\n     }\n@@ -2285,9 +2285,9 @@ range of values may be specified with `to`. For example:\n # let x = 2;\n \n let message = alt x {\n-  0 | 1  { ~\"not many\" }\n-  2 to 9 { ~\"a few\" }\n-  _      { ~\"lots\" }\n+  0 | 1  => ~\"not many\",\n+  2 to 9 => ~\"a few\",\n+  _      => ~\"lots\"\n };\n ~~~~\n \n@@ -2302,9 +2302,9 @@ guard may refer to the variables bound within the pattern they follow.\n # fn process_other(i: int) { }\n \n let message = alt maybe_digit {\n-  some(x) if x < 10 { process_digit(x) }\n-  some(x) { process_other(x) }\n-  none { fail }\n+  some(x) if x < 10 => process_digit(x),\n+  some(x) => process_other(x),\n+  none => fail\n };\n ~~~~\n "}, {"sha": "8ee70482ea955a53cc7decf450845bd52f584b70", "filename": "doc/tutorial.md", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c9d27693796fe4ced8568e11aa465750f743097b/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/c9d27693796fe4ced8568e11aa465750f743097b/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=c9d27693796fe4ced8568e11aa465750f743097b", "patch": "@@ -117,9 +117,9 @@ fn main() {\n \n         // Pick two gestures and decide the result\n         alt (pick(), pick()) {\n-            (rock, scissors) | (paper, rock) | (scissors, paper) { copy player1 }\n-            (scissors, rock) | (rock, paper) | (paper, scissors) { copy player2 }\n-            _ { ~\"tie\" }\n+            (rock, scissors) | (paper, rock) | (scissors, paper) => copy player1,\n+            (scissors, rock) | (rock, paper) | (paper, scissors) => copy player2,\n+            _ => ~\"tie\"\n         }\n     }\n }\n@@ -715,10 +715,10 @@ the value.\n ~~~~\n # let my_number = 1;\n alt my_number {\n-  0       { io::println(~\"zero\"); }\n-  1 | 2   { io::println(~\"one or two\"); }\n-  3 to 10 { io::println(~\"three to ten\"); }\n-  _       { io::println(~\"something else\"); }\n+  0       => io::println(~\"zero\"),\n+  1 | 2   => io::println(~\"one or two\"),\n+  3 to 10 => io::println(~\"three to ten\"),\n+  _       => io::println(~\"something else\")\n }\n ~~~~\n \n@@ -732,6 +732,23 @@ valid patterns, and will match only their own value. The pipe operator\n of numeric literal patterns can be expressed with `to`. The underscore\n (`_`) is a wildcard pattern that matches everything.\n \n+The patterns in an alt arm are followed by a fat arrow, `=>`, then an\n+expression to evaluate. Each case is separated by commas. It's often\n+convenient to use a block expression for a case, in which case the\n+commas are optional.\n+\n+~~~\n+# let my_number = 1;\n+alt my_number {\n+  0 => {\n+    io::println(~\"zero\")\n+  }\n+  _ => {\n+    io::println(~\"something else\")\n+  }\n+}\n+~~~\n+\n If the arm with the wildcard pattern was left off in the above\n example, the typechecker would reject it at compile time. `alt`\n constructs must be exhaustive: they must have an arm covering every\n@@ -747,9 +764,9 @@ that `(float, float)` is a tuple of two floats:\n ~~~~\n fn angle(vec: (float, float)) -> float {\n     alt vec {\n-      (0f, y) if y < 0f { 1.5 * float::consts::pi }\n-      (0f, y) { 0.5 * float::consts::pi }\n-      (x, y) { float::atan(y / x) }\n+      (0f, y) if y < 0f => 1.5 * float::consts::pi,\n+      (0f, y) => 0.5 * float::consts::pi,\n+      (x, y) => float::atan(y / x)\n     }\n }\n ~~~~\n@@ -1035,8 +1052,8 @@ name as the field.\n ~~~~\n # let mypoint = {x: 0f, y: 0f};\n alt mypoint {\n-    {x: 0f, y: y_name} { /* Provide sub-patterns for fields */ }\n-    {x, y}             { /* Simply bind the fields */ }\n+    {x: 0f, y: y_name} => { /* Provide sub-patterns for fields */ }\n+    {x, y}             => { /* Simply bind the fields */ }\n }\n ~~~~\n \n@@ -1141,8 +1158,8 @@ patterns, as in this definition of `area`:\n # enum shape { circle(point, float), rectangle(point, point) }\n fn area(sh: shape) -> float {\n     alt sh {\n-        circle(_, size) { float::consts::pi * size * size }\n-        rectangle({x, y}, {x: x2, y: y2}) { (x2 - x) * (y2 - y) }\n+        circle(_, size) => float::consts::pi * size * size,\n+        rectangle({x, y}, {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n     }\n }\n ~~~~\n@@ -1154,10 +1171,10 @@ Another example, matching nullary enum variants:\n # enum direction { north, east, south, west }\n fn point_from_direction(dir: direction) -> point {\n     alt dir {\n-        north { {x:  0f, y:  1f} }\n-        east  { {x:  1f, y:  0f} }\n-        south { {x:  0f, y: -1f} }\n-        west  { {x: -1f, y:  0f} }\n+        north => {x:  0f, y:  1f},\n+        east  => {x:  1f, y:  0f},\n+        south => {x:  0f, y: -1f},\n+        west  => {x: -1f, y:  0f}\n     }\n }\n ~~~~\n@@ -1172,7 +1189,7 @@ nil, `()`, as the empty tuple if you like).\n ~~~~\n let mytup: (int, int, float) = (10, 20, 30.0);\n alt mytup {\n-  (a, b, c) { log(info, a + b + (c as int)); }\n+  (a, b, c) => log(info, a + b + (c as int))\n }\n ~~~~\n \n@@ -1914,7 +1931,7 @@ safety.\n ~~~~\n let mut my_rec = {a: 4, b: ~[1, 2, 3]};\n alt my_rec {\n-  {a, b} {\n+  {a, b} => {\n     log(info, b); // This is okay\n     my_rec = {a: a + 1, b: b + ~[a]};\n     log(info, b); // Here reference b has become invalid"}]}