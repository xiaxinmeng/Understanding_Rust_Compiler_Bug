{"sha": "26144fe86990a6dedd3c5766175156f81de1dc0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MTQ0ZmU4Njk5MGE2ZGVkZDNjNTc2NjE3NTE1NmY4MWRlMWRjMGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-23T16:58:36Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-06T04:43:58Z"}, "message": "Lowering: Fuse ExprKind::While logic + Cleanup.", "tree": {"sha": "c8f6ec0c1d84f4f62031d3e219796122193b8bef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8f6ec0c1d84f4f62031d3e219796122193b8bef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26144fe86990a6dedd3c5766175156f81de1dc0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26144fe86990a6dedd3c5766175156f81de1dc0e", "html_url": "https://github.com/rust-lang/rust/commit/26144fe86990a6dedd3c5766175156f81de1dc0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26144fe86990a6dedd3c5766175156f81de1dc0e/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547735457ff698dd44ba818a65d1f10853fbeb8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/547735457ff698dd44ba818a65d1f10853fbeb8e", "html_url": "https://github.com/rust-lang/rust/commit/547735457ff698dd44ba818a65d1f10853fbeb8e"}], "stats": {"total": 139, "additions": 54, "deletions": 85}, "files": [{"sha": "3c967fa6d8317c0b88228aa1c5d2dd8d103eac52", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 54, "deletions": 85, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/26144fe86990a6dedd3c5766175156f81de1dc0e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26144fe86990a6dedd3c5766175156f81de1dc0e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=26144fe86990a6dedd3c5766175156f81de1dc0e", "patch": "@@ -4394,20 +4394,17 @@ impl<'a> LoweringContext<'a> {\n                 let then_blk = self.lower_block(then, false);\n                 let then_expr = self.expr_block(then_blk, ThinVec::new());\n                 let (then_pats, scrutinee, desugar) = match cond.node {\n-                    // `<pat> => <then>`\n+                    // `<pat> => <then>`:\n                     ExprKind::Let(ref pats, ref scrutinee) => {\n                         let scrutinee = self.lower_expr(scrutinee);\n                         let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n                         let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n                         (pats, scrutinee, desugar)\n                     }\n-                    // `true => then`:\n+                    // `true => <then>`:\n                     _ => {\n                         // Lower condition:\n                         let cond = self.lower_expr(cond);\n-                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                        // to preserve drop semantics since `if cond { ... }`\n-                        // don't let temporaries live outside of `cond`.\n                         let span_block = self.mark_span_with_reason(CondTemporary, cond.span, None);\n                         // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n                         // to preserve drop semantics since `if cond { ... }` does not\n@@ -4424,61 +4421,36 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n             }\n             // FIXME(#53667): handle lowering of && and parens.\n-            ExprKind::While(ref cond, ref body, opt_label) => {\n-                // Desugar `ExprWhileLet`\n-                // from: `[opt_ident]: while let <pat> = <sub_expr> <body>`\n-                if let ExprKind::Let(ref pats, ref sub_expr) = cond.node {\n-                    // to:\n-                    //\n-                    //   [opt_ident]: loop {\n-                    //     match <sub_expr> {\n-                    //       <pat> => <body>,\n-                    //       _ => break\n-                    //     }\n-                    //   }\n-\n-                    // Note that the block AND the condition are evaluated in the loop scope.\n-                    // This is done to allow `break` from inside the condition of the loop.\n-                    let (body, break_expr, sub_expr) = self.with_loop_scope(e.id, |this| {\n-                        (\n-                            this.lower_block(body, false),\n-                            this.expr_break(e.span, ThinVec::new()),\n-                            this.with_loop_condition_scope(|this| P(this.lower_expr(sub_expr))),\n-                        )\n-                    });\n+            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                // Note that the block AND the condition are evaluated in the loop scope.\n+                // This is done to allow `break` from inside the condition of the loop.\n \n-                    // `<pat> => <body>`\n-                    let pat_arm = {\n-                        let body_expr = P(self.expr_block(body, ThinVec::new()));\n-                        let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                        self.arm(pats, body_expr)\n-                    };\n-\n-                    // `_ => break`\n-                    let break_arm = {\n-                        let pat_under = self.pat_wild(e.span);\n-                        self.arm(hir_vec![pat_under], break_expr)\n-                    };\n-\n-                    // `match <sub_expr> { ... }`\n-                    let match_expr = self.expr_match(\n-                        sub_expr.span,\n-                        sub_expr,\n-                        hir_vec![pat_arm, break_arm],\n-                        hir::MatchSource::WhileLetDesugar,\n-                    );\n+                // `_ => break`:\n+                let else_arm = {\n+                    let else_pat = this.pat_wild(e.span);\n+                    let else_expr = this.expr_break(e.span, ThinVec::new());\n+                    this.arm(hir_vec![else_pat], else_expr)\n+                };\n \n-                    // `[opt_ident]: loop { ... }`\n-                    let loop_block = P(self.block_expr(P(match_expr)));\n-                    let loop_expr = hir::ExprKind::Loop(\n-                        loop_block,\n-                        self.lower_label(opt_label),\n-                        hir::LoopSource::WhileLet,\n-                    );\n-                    // Add attributes to the outer returned expr node.\n-                    loop_expr\n-                } else {\n-                    self.with_loop_scope(e.id, |this| {\n+                // Handle then + scrutinee:\n+                let then_blk = this.lower_block(body, false);\n+                let then_expr = this.expr_block(then_blk, ThinVec::new());\n+                let (then_pats, scrutinee, desugar, source) = match cond.node {\n+                    ExprKind::Let(ref pats, ref scrutinee) => {\n+                        // to:\n+                        //\n+                        //   [opt_ident]: loop {\n+                        //     match <sub_expr> {\n+                        //       <pat> => <body>,\n+                        //       _ => break\n+                        //     }\n+                        //   }\n+                        let scrutinee = this.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n+                        let pats = pats.iter().map(|pat| this.lower_pat(pat)).collect();\n+                        let desugar = hir::MatchSource::WhileLetDesugar;\n+                        (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                    }\n+                    _ => {\n                         // We desugar: `'label: while $cond $body` into:\n                         //\n                         // ```\n@@ -4490,40 +4462,37 @@ impl<'a> LoweringContext<'a> {\n                         // }\n                         // ```\n \n-                        // `true => then`:\n-                        let then_pat = this.pat_bool(e.span, true);\n-                        let then_blk = this.lower_block(body, false);\n-                        let then_expr = this.expr_block(then_blk, ThinVec::new());\n-                        let then_arm = this.arm(hir_vec![then_pat], P(then_expr));\n-\n-                        // `_ => break`:\n-                        let else_pat = this.pat_wild(e.span);\n-                        let else_expr = this.expr_break(e.span, ThinVec::new());\n-                        let else_arm = this.arm(hir_vec![else_pat], else_expr);\n-\n                         // Lower condition:\n-                        let span_block = this.mark_span_with_reason(CondTemporary, cond.span, None);\n                         let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                        let span_block = this.mark_span_with_reason(CondTemporary, cond.span, None);\n                         // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                        // to preserve drop semantics since `if cond { ... }` does not\n+                        // to preserve drop semantics since `while cond { ... }` does not\n                         // let temporaries live outside of `cond`.\n                         let cond = this.expr_drop_temps(span_block, P(cond), ThinVec::new());\n \n-                        let match_expr = this.expr_match(\n-                            cond.span,\n-                            P(cond),\n-                            vec![then_arm, else_arm].into(),\n-                            hir::MatchSource::WhileDesugar,\n-                        );\n+                        let desugar = hir::MatchSource::WhileDesugar;\n+                        // `true => <then>`:\n+                        let pats = hir_vec![this.pat_bool(e.span, true)];\n+                        (pats, cond, desugar, hir::LoopSource::While)\n+                    }\n+                };\n+                let then_arm = this.arm(then_pats, P(then_expr));\n \n-                        hir::ExprKind::Loop(\n-                            P(this.block_expr(P(match_expr))),\n-                            this.lower_label(opt_label),\n-                            hir::LoopSource::While,\n-                        )\n-                    })\n-                }\n-            }\n+                // `match <scrutinee> { ... }`\n+                let match_expr = this.expr_match(\n+                    scrutinee.span,\n+                    P(scrutinee),\n+                    hir_vec![then_arm, else_arm],\n+                    desugar,\n+                );\n+\n+                // `[opt_ident]: loop { ... }`\n+                hir::ExprKind::Loop(\n+                    P(this.block_expr(P(match_expr))),\n+                    this.lower_label(opt_label),\n+                    source\n+                )\n+            }),\n             ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n                 hir::ExprKind::Loop(\n                     this.lower_block(body, false),"}]}