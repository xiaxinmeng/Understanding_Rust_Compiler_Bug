{"sha": "957971b63abbc816aebc6654dc68cf9ff15837d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1Nzk3MWI2M2FiYmM4MTZhZWJjNjY1NGRjNjhjZjlmZjE1ODM3ZDc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-08-18T12:44:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-09-03T10:39:34Z"}, "message": "Implement layout calculation and add more trans stubs", "tree": {"sha": "ff98df2f3111614abe2e8422e022b7f2b2773993", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff98df2f3111614abe2e8422e022b7f2b2773993"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/957971b63abbc816aebc6654dc68cf9ff15837d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/957971b63abbc816aebc6654dc68cf9ff15837d7", "html_url": "https://github.com/rust-lang/rust/commit/957971b63abbc816aebc6654dc68cf9ff15837d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/957971b63abbc816aebc6654dc68cf9ff15837d7/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2ca1530dbcde745175569b9f5434fa6643e5766", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2ca1530dbcde745175569b9f5434fa6643e5766", "html_url": "https://github.com/rust-lang/rust/commit/c2ca1530dbcde745175569b9f5434fa6643e5766"}], "stats": {"total": 225, "additions": 205, "deletions": 20}, "files": [{"sha": "9270057b54415b8ac8ad7124e652f569461fec56", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=957971b63abbc816aebc6654dc68cf9ff15837d7", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n         for field in fields {\n             if !self.sized {\n-                bug!(\"Struct::compute: field #{} of `{}` comes after unsized field\",\n+                bug!(\"Struct::extend: field #{} of `{}` comes after unsized field\",\n                      self.offset_after_field.len(), scapegoat);\n             }\n \n@@ -623,6 +623,54 @@ impl<'a, 'gcx, 'tcx> Struct {\n     }\n }\n \n+/// An untagged union.\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct Union {\n+    pub align: Align,\n+\n+    pub min_size: Size,\n+\n+    /// If true, no alignment padding is used.\n+    pub packed: bool,\n+}\n+\n+impl<'a, 'gcx, 'tcx> Union {\n+    pub fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+        Union {\n+            align: if packed { dl.i8_align } else { dl.aggregate_align },\n+            min_size: Size::from_bytes(0),\n+            packed: packed,\n+        }\n+    }\n+\n+    /// Extend the Struct with more fields.\n+    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                     fields: I,\n+                     scapegoat: Ty<'gcx>)\n+                     -> Result<(), LayoutError<'gcx>>\n+    where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n+        for (index, field) in fields.enumerate() {\n+            let field = field?;\n+            if field.is_unsized() {\n+                bug!(\"Union::extend: field #{} of `{}` is unsized\",\n+                     index, scapegoat);\n+            }\n+\n+            if !self.packed {\n+                self.align = self.align.max(field.align(dl));\n+            }\n+            self.min_size = cmp::max(self.min_size, field.size(dl));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    /// Get the size with trailing aligment padding.\n+    pub fn stride(&self) -> Size {\n+        self.min_size.abi_align(self.align)\n+    }\n+}\n+\n /// The first half of a fat pointer.\n /// - For a trait object, this is the address of the box.\n /// - For a slice, this is the base address.\n@@ -690,6 +738,11 @@ pub enum Layout {\n         non_zero: bool\n     },\n \n+    /// Untagged unions.\n+    UntaggedUnion {\n+        variants: Union,\n+    },\n+\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     General {\n@@ -896,8 +949,14 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     non_zero: Some(def.did) == tcx.lang_items.non_zero()\n                 }\n             }\n-            ty::TyUnion(..) => {\n-                unimplemented_unions!();\n+            ty::TyUnion(def, substs) => {\n+                let fields = def.struct_variant().fields.iter().map(|field| {\n+                    field.ty(tcx, substs).layout(infcx)\n+                });\n+                let packed = tcx.lookup_packed(def.did);\n+                let mut un = Union::new(dl, packed);\n+                un.extend(dl, fields, ty)?;\n+                UntaggedUnion { variants: un }\n             }\n             ty::TyEnum(def, substs) => {\n                 let hint = *tcx.lookup_repr_hints(def.did).get(0)\n@@ -1118,7 +1177,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n     pub fn is_unsized(&self) -> bool {\n         match *self {\n             Scalar {..} | Vector {..} | FatPointer {..} |\n-            CEnum {..} | General {..} |\n+            CEnum {..} | UntaggedUnion {..} | General {..} |\n             RawNullablePointer {..} |\n             StructWrappedNullablePointer {..} => false,\n \n@@ -1152,6 +1211,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n             Array { size, .. } | General { size, .. } => size,\n+            UntaggedUnion { ref variants } => variants.stride(),\n \n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n@@ -1191,6 +1251,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             CEnum { discr, .. } => Int(discr).align(dl),\n             Array { align, .. } | General { align, .. } => align,\n+            UntaggedUnion { ref variants } => variants.align,\n \n             Univariant { ref variant, .. } |\n             StructWrappedNullablePointer { nonnull: ref variant, .. } => {\n@@ -1256,9 +1317,6 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 }\n             }\n \n-            ty::TyUnion(..) => {\n-                unimplemented_unions!();\n-            }\n             ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => {\n                 // Only newtypes and enums w/ nullable pointer optimization.\n                 if def.variants.is_empty() || def.variants.len() > 2 {"}, {"sha": "c8f660a2d9c7c7dbe7aeff37feeff8ff3871ba20", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=957971b63abbc816aebc6654dc68cf9ff15837d7", "patch": "@@ -459,7 +459,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         hir::ExprStruct(_, ref fields, ref base) => {\n             match expr_ty.sty {\n-                ty::TyStruct(adt, substs) => {\n+                ty::TyStruct(adt, substs) | ty::TyUnion(adt, substs) => {\n                     let field_refs = field_refs(&adt.variants[0], fields);\n                     ExprKind::Adt {\n                         adt_def: adt,\n@@ -477,9 +477,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         })\n                     }\n                 }\n-                ty::TyUnion(..) => {\n-                    unimplemented_unions!();\n-                }\n                 ty::TyEnum(adt, substs) => {\n                     match cx.tcx.expect_def(expr.id) {\n                         Def::Variant(enum_id, variant_id) => {"}, {"sha": "abbb9a5d4dbe592ca2cdb0b67ff613dd72ce2451", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 88, "deletions": 8, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=957971b63abbc816aebc6654dc68cf9ff15837d7", "patch": "@@ -79,6 +79,8 @@ pub enum Repr<'tcx> {\n     CEnum(IntType, Disr, Disr), // discriminant range (signedness based on the IntType)\n     /// Single-case variants, and structs/tuples/records.\n     Univariant(Struct<'tcx>),\n+    /// Untagged unions.\n+    UntaggedUnion(Union<'tcx>),\n     /// General-case enums: for each case there is a struct, and they\n     /// all start with a field for the discriminant.\n     General(IntType, Vec<Struct<'tcx>>),\n@@ -121,6 +123,15 @@ pub struct Struct<'tcx> {\n     pub fields: Vec<Ty<'tcx>>,\n }\n \n+/// For untagged unions.\n+#[derive(Eq, PartialEq, Debug)]\n+pub struct Union<'tcx> {\n+    pub min_size: u64,\n+    pub align: u32,\n+    pub packed: bool,\n+    pub fields: Vec<Ty<'tcx>>,\n+}\n+\n #[derive(Copy, Clone)]\n pub struct MaybeSizedValue {\n     pub value: ValueRef,\n@@ -176,8 +187,12 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t))\n         }\n-        ty::TyUnion(..) => {\n-            unimplemented_unions!();\n+        ty::TyUnion(def, substs) => {\n+            let ftys = def.struct_variant().fields.iter().map(|field| {\n+                monomorphize::field_ty(cx.tcx(), substs, field)\n+            }).collect::<Vec<_>>();\n+            let packed = cx.tcx().lookup_packed(def.did);\n+            UntaggedUnion(mk_union(cx, &ftys[..], packed, t))\n         }\n         ty::TyClosure(_, ref substs) => {\n             Univariant(mk_struct(cx, &substs.upvar_tys, false, t))\n@@ -482,6 +497,31 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n+fn mk_union<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                      tys: &[Ty<'tcx>], packed: bool,\n+                      _scapegoat: Ty<'tcx>)\n+                      -> Union<'tcx> {\n+    let mut min_size = 0;\n+    let mut align = 0;\n+    for llty in tys.iter().map(|&ty| type_of::sizing_type_of(cx, ty)) {\n+        let field_size = machine::llsize_of_alloc(cx, llty);\n+        if min_size < field_size {\n+            min_size = field_size;\n+        }\n+        let field_align = machine::llalign_of_min(cx, llty);\n+        if align < field_align {\n+            align = field_align;\n+        }\n+    }\n+\n+    Union {\n+        min_size: min_size,\n+        align: align,\n+        packed: packed,\n+        fields: tys.to_vec(),\n+    }\n+}\n+\n #[derive(Debug)]\n struct IntBounds {\n     slo: i64,\n@@ -646,7 +686,7 @@ pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 r: &Repr<'tcx>, llty: &mut Type) {\n     match *r {\n-        CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n+        CEnum(..) | General(..) | UntaggedUnion(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n             llty.set_struct_body(&struct_llfields(cx, st, false, false),\n                                  st.packed)\n@@ -690,6 +730,34 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n+        UntaggedUnion(ref un) => {\n+            // Use alignment-sized ints to fill all the union storage.\n+            let (size, align) = (roundup(un.min_size, un.align), un.align);\n+\n+            let align_s = align as u64;\n+            assert_eq!(size % align_s, 0); // Ensure division in align_units comes out evenly\n+            let align_units = size / align_s;\n+            let fill_ty = match align_s {\n+                1 => Type::array(&Type::i8(cx), align_units),\n+                2 => Type::array(&Type::i16(cx), align_units),\n+                4 => Type::array(&Type::i32(cx), align_units),\n+                8 if machine::llalign_of_min(cx, Type::i64(cx)) == 8 =>\n+                                 Type::array(&Type::i64(cx), align_units),\n+                a if a.count_ones() == 1 => Type::array(&Type::vector(&Type::i32(cx), a / 4),\n+                                                              align_units),\n+                _ => bug!(\"unsupported union alignment: {}\", align)\n+            };\n+            match name {\n+                None => {\n+                    TypeContext::direct(Type::struct_(cx, &[fill_ty], un.packed))\n+                }\n+                Some(name) => {\n+                    let mut llty = Type::named_struct(cx, name);\n+                    llty.set_struct_body(&[fill_ty], un.packed);\n+                    TypeContext::direct(llty)\n+                }\n+            }\n+        }\n         General(ity, ref sts) => {\n             // We need a representation that has:\n             // * The alignment of the most-aligned field\n@@ -762,7 +830,7 @@ pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n             (BranchKind::Switch, Some(trans_get_discr(bcx, r, scrutinee, None, range_assert)))\n         }\n-        Univariant(..) => {\n+        Univariant(..) | UntaggedUnion(..) => {\n             // N.B.: Univariant means <= 1 enum variants (*not* == 1 variants).\n             (BranchKind::Single, None)\n         }\n@@ -773,7 +841,7 @@ pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n     match *r {\n         CEnum(ity, _, _) => ity.is_signed(),\n         General(ity, _) => ity.is_signed(),\n-        Univariant(..) => false,\n+        Univariant(..) | UntaggedUnion(..) => false,\n         RawNullablePointer { .. } => false,\n         StructWrappedNullablePointer { .. } => false,\n     }\n@@ -794,7 +862,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n             load_discr(bcx, ity, ptr, Disr(0), Disr(cases.len() as u64 - 1),\n                        range_assert)\n         }\n-        Univariant(..) => C_u8(bcx.ccx(), 0),\n+        Univariant(..) | UntaggedUnion(..) => C_u8(bcx.ccx(), 0),\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n             let cmp = if nndiscr == Disr(0) { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n@@ -856,8 +924,8 @@ pub fn trans_case<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr, discr: Disr)\n         General(ity, _) => {\n             C_integral(ll_inttype(bcx.ccx(), ity), discr.0, true)\n         }\n-        Univariant(..) => {\n-            bug!(\"no cases for univariants or structs\")\n+        Univariant(..) | UntaggedUnion(..) => {\n+            bug!(\"no cases for univariants, structs or unions\")\n         }\n         RawNullablePointer { .. } |\n         StructWrappedNullablePointer { .. } => {\n@@ -884,6 +952,9 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         Univariant(_) => {\n             assert_eq!(discr, Disr(0));\n         }\n+        UntaggedUnion(..) => {\n+            assert_eq!(discr, Disr(0));\n+        }\n         RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n@@ -939,6 +1010,11 @@ pub fn trans_field_ptr_builder<'blk, 'tcx>(bcx: &BlockAndBuilder<'blk, 'tcx>,\n         General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr.0 as usize], val, ix + 1, true)\n         }\n+        UntaggedUnion(ref un) => {\n+            let ty = type_of::in_memory_type_of(bcx.ccx(), un.fields[ix]);\n+            if bcx.is_unreachable() { return C_undef(ty.ptr_to()); }\n+            bcx.pointercast(val.value, ty.ptr_to())\n+        }\n         RawNullablePointer { nndiscr, ref nullfields, .. } |\n         StructWrappedNullablePointer { nndiscr, ref nullfields, .. } if discr != nndiscr => {\n             // The unit-like case might have a nonzero number of unit-like fields.\n@@ -1100,6 +1176,9 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             contents.extend_from_slice(&[padding(ccx, max_sz - case.size)]);\n             C_struct(ccx, &contents[..], false)\n         }\n+        UntaggedUnion(..) => {\n+            unimplemented_unions!();\n+        }\n         Univariant(ref st) => {\n             assert_eq!(discr, Disr(0));\n             let contents = build_const_struct(ccx, st, vals);\n@@ -1211,6 +1290,7 @@ pub fn const_get_field(r: &Repr, val: ValueRef, _discr: Disr,\n     match *r {\n         CEnum(..) => bug!(\"element access in C-like enum const\"),\n         Univariant(..) => const_struct_field(val, ix),\n+        UntaggedUnion(..) => const_struct_field(val, 0),\n         General(..) => const_struct_field(val, ix + 1),\n         RawNullablePointer { .. } => {\n             assert_eq!(ix, 0);"}, {"sha": "bd67a215d65eb02163f31ca81dcb0c9827128171", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=957971b63abbc816aebc6654dc68cf9ff15837d7", "patch": "@@ -1302,6 +1302,9 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     ]\n                 }\n             }\n+            adt::UntaggedUnion(..) => {\n+                unimplemented_unions!();\n+            }\n             adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n                 // As far as debuginfo is concerned, the pointer this enum\n                 // represents is still wrapped in a struct. This is to make the\n@@ -1616,7 +1619,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         },\n         adt::RawNullablePointer { .. }           |\n         adt::StructWrappedNullablePointer { .. } |\n-        adt::Univariant(..)                      => None,\n+        adt::Univariant(..) | adt::UntaggedUnion(..) => None,\n         adt::General(inttype, _) => Some(discriminant_type_metadata(inttype)),\n     };\n "}, {"sha": "474c8b4b18103c6fb62ab0eca47d3314961b2d49", "filename": "src/test/run-pass/union-basic.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Ftest%2Frun-pass%2Funion-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957971b63abbc816aebc6654dc68cf9ff15837d7/src%2Ftest%2Frun-pass%2Funion-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion-basic.rs?ref=957971b63abbc816aebc6654dc68cf9ff15837d7", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+use std::mem::{size_of, align_of, zeroed};\n+\n+union U {\n+    a: u8,\n+}\n+\n+union U64 {\n+    a: u64,\n+}\n+\n+union W {\n+    a: u8,\n+    b: u64,\n+}\n+\n+fn main() {\n+    assert_eq!(size_of::<U>(), 1);\n+    assert_eq!(size_of::<U64>(), 8);\n+    assert_eq!(size_of::<W>(), 8);\n+    assert_eq!(align_of::<U>(), 1);\n+    assert_eq!(align_of::<U64>(), align_of::<u64>());\n+    assert_eq!(align_of::<W>(), align_of::<u64>());\n+\n+    let u = U { a: 10 };\n+    assert_eq!(u.a, 10);\n+    let U { a } = u;\n+    assert_eq!(a, 10);\n+\n+    let mut w: W = unsafe { zeroed() };\n+    assert_eq!(w.a, 0);\n+    assert_eq!(w.b, 0);\n+    // w.a = 1;\n+    // assert_eq!(w.a, 0);\n+    // assert_eq!(w.b, 0);\n+}"}]}