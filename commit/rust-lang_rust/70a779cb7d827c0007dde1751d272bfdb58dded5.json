{"sha": "70a779cb7d827c0007dde1751d272bfdb58dded5", "node_id": "C_kwDOAAsO6NoAKDcwYTc3OWNiN2Q4MjdjMDAwN2RkZTE3NTFkMjcyYmZkYjU4ZGRlZDU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T02:36:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-07T02:36:15Z"}, "message": "Auto merge of #110693 - clubby789:x-clap-take-2, r=Mark-Simulacrum\n\nMigrate bootstrap to Clap-based argument parsing\n\nSupercedes #108083\n\nI chose to re-do the work rather than rebase the onto the large changes since the original PR. If it's preferred I can instead force-push the original PR to this version.\n\ncc `@jyn514` `@albertlarsan68`", "tree": {"sha": "dc6a81124bea026b4be326b02697f76917cb4cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc6a81124bea026b4be326b02697f76917cb4cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70a779cb7d827c0007dde1751d272bfdb58dded5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70a779cb7d827c0007dde1751d272bfdb58dded5", "html_url": "https://github.com/rust-lang/rust/commit/70a779cb7d827c0007dde1751d272bfdb58dded5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70a779cb7d827c0007dde1751d272bfdb58dded5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34bee196cb85b5e7f45118a791360161c46cf000", "url": "https://api.github.com/repos/rust-lang/rust/commits/34bee196cb85b5e7f45118a791360161c46cf000", "html_url": "https://github.com/rust-lang/rust/commit/34bee196cb85b5e7f45118a791360161c46cf000"}, {"sha": "32e27cc60765ae21426b31073ba9ac2bda499c8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/32e27cc60765ae21426b31073ba9ac2bda499c8d", "html_url": "https://github.com/rust-lang/rust/commit/32e27cc60765ae21426b31073ba9ac2bda499c8d"}], "stats": {"total": 1211, "additions": 481, "deletions": 730}, "files": [{"sha": "dfe6bb7f0572e82b8bd7751051bd0235960bc2d3", "filename": "src/bootstrap/Cargo.lock", "status": "modified", "additions": 70, "deletions": 22, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.lock?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -11,6 +11,12 @@ dependencies = [\n  \"memchr\",\n ]\n \n+[[package]]\n+name = \"anstyle\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41ed9a86bf92ae6580e0a31281f65a1b1d867c0cc68d5346e2ae128dddfa6a7d\"\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -38,10 +44,10 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper\",\n  \"cc\",\n+ \"clap\",\n  \"cmake\",\n  \"fd-lock\",\n  \"filetime\",\n- \"getopts\",\n  \"hex\",\n  \"ignore\",\n  \"is-terminal\",\n@@ -91,6 +97,46 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n+[[package]]\n+name = \"clap\"\n+version = \"4.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"956ac1f6381d8d82ab4684768f89c0ea3afe66925ceadb4eeb3fc452ffc55d62\"\n+dependencies = [\n+ \"clap_builder\",\n+ \"clap_derive\",\n+ \"once_cell\",\n+]\n+\n+[[package]]\n+name = \"clap_builder\"\n+version = \"4.2.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"84080e799e54cff944f4b4a4b0e71630b0e0443b25b985175c7dddc1a859b749\"\n+dependencies = [\n+ \"anstyle\",\n+ \"bitflags\",\n+ \"clap_lex\",\n+]\n+\n+[[package]]\n+name = \"clap_derive\"\n+version = \"4.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f9644cd56d6b87dbe899ef8b053e331c0637664e9e21a33dfcdc36093f5c5c4\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.15\",\n+]\n+\n+[[package]]\n+name = \"clap_lex\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8a2dd5a6fe8c6e3502f568a6353e5273bbb15193ad9a89e457b9970798efbea1\"\n+\n [[package]]\n name = \"cmake\"\n version = \"0.1.48\"\n@@ -175,7 +221,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f877be4f7c9f246b183111634f75baa039715e3f46ce860677d3b19a69fb229c\"\n dependencies = [\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -260,15 +306,6 @@ dependencies = [\n  \"version_check\",\n ]\n \n-[[package]]\n-name = \"getopts\"\n-version = \"0.2.21\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n-dependencies = [\n- \"unicode-width\",\n-]\n-\n [[package]]\n name = \"globset\"\n version = \"0.4.8\"\n@@ -282,6 +319,12 @@ dependencies = [\n  \"regex\",\n ]\n \n+[[package]]\n+name = \"heck\"\n+version = \"0.4.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"95505c38b4572b2d910cecb0281560f54b440a19336cbbcb27bf6ce6adc6f5a8\"\n+\n [[package]]\n name = \"hermit-abi\"\n version = \"0.1.19\"\n@@ -486,18 +529,18 @@ dependencies = [\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.46\"\n+version = \"1.0.56\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94e2ef8dbfc347b10c094890f778ee2e36ca9bb4262e86dc99cd217e35f3470b\"\n+checksum = \"2b63bdb0cd06f1f4dedf69b254734f9b45af66e4a031e42a7480257d9898b435\"\n dependencies = [\n  \"unicode-ident\",\n ]\n \n [[package]]\n name = \"quote\"\n-version = \"1.0.18\"\n+version = \"1.0.26\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1feb54ed693b93a84e14094943b84b7c4eae204c512b7ccb95ab0c66d278ad1\"\n+checksum = \"4424af4bf778aae2051a77b60283332f386554255d722233d09fbfc7e30da2fc\"\n dependencies = [\n  \"proc-macro2\",\n ]\n@@ -606,7 +649,7 @@ checksum = \"1f26faba0c3959972377d3b2d306ee9f71faee9714294e41bb777f83f88578be\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn\",\n+ \"syn 1.0.102\",\n ]\n \n [[package]]\n@@ -642,6 +685,17 @@ dependencies = [\n  \"unicode-ident\",\n ]\n \n+[[package]]\n+name = \"syn\"\n+version = \"2.0.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a34fcf3e8b60f57e6a14301a2e916d323af98b0ea63c599441eec8558660c822\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-ident\",\n+]\n+\n [[package]]\n name = \"sysinfo\"\n version = \"0.26.7\"\n@@ -707,12 +761,6 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d22af068fba1eb5edcb4aea19d382b2a3deb4c8f9d475c589b6ada9e0fd493ee\"\n \n-[[package]]\n-name = \"unicode-width\"\n-version = \"0.1.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n-\n [[package]]\n name = \"version_check\"\n version = \"0.9.4\""}, {"sha": "fd5eb740630ab743b1b5569304657c81ed7bc8cd", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -34,7 +34,6 @@ is-terminal = \"0.4\"\n build_helper = { path = \"../tools/build_helper\" }\n cmake = \"0.1.38\"\n filetime = \"0.2\"\n-getopts = \"0.2.19\"\n cc = \"1.0.69\"\n libc = \"0.2\"\n hex = \"0.4\"\n@@ -56,6 +55,7 @@ walkdir = \"2\"\n \n # Dependencies needed by the build-metrics feature\n sysinfo = { version = \"0.26.0\", optional = true }\n+clap = { version = \"4.2.4\", default-features = false, features = [\"std\", \"usage\", \"help\", \"derive\", \"error-context\"] }\n \n # Solaris doesn't support flock() and thus fd-lock is not option now\n [target.'cfg(not(target_os = \"solaris\"))'.dependencies]\n@@ -86,6 +86,7 @@ build-metrics = [\"sysinfo\"]\n # dependencies, only bootstrap itself.\n [profile.dev]\n debug = 0\n+\n [profile.dev.package]\n # Only use debuginfo=1 to further reduce compile times.\n bootstrap.debug = 1"}, {"sha": "1267c0be7193eb324bd79616bf8b7e4f74a743fa", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -33,6 +33,7 @@ pub use crate::Compiler;\n // - use std::lazy for `Lazy`\n // - use std::cell for `OnceCell`\n // Once they get stabilized and reach beta.\n+use clap::ValueEnum;\n use once_cell::sync::{Lazy, OnceCell};\n \n pub struct Builder<'a> {\n@@ -576,19 +577,24 @@ impl<'a> ShouldRun<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, ValueEnum)]\n pub enum Kind {\n+    #[clap(alias = \"b\")]\n     Build,\n+    #[clap(alias = \"c\")]\n     Check,\n     Clippy,\n     Fix,\n     Format,\n+    #[clap(alias = \"t\")]\n     Test,\n     Bench,\n+    #[clap(alias = \"d\")]\n     Doc,\n     Clean,\n     Dist,\n     Install,\n+    #[clap(alias = \"r\")]\n     Run,\n     Setup,\n     Suggest,\n@@ -887,18 +893,19 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn new(build: &Build) -> Builder<'_> {\n+        let paths = &build.config.paths;\n         let (kind, paths) = match build.config.cmd {\n-            Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n-            Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n-            Subcommand::Clippy { ref paths, .. } => (Kind::Clippy, &paths[..]),\n-            Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n-            Subcommand::Doc { ref paths, .. } => (Kind::Doc, &paths[..]),\n-            Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n-            Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n-            Subcommand::Dist { ref paths } => (Kind::Dist, &paths[..]),\n-            Subcommand::Install { ref paths } => (Kind::Install, &paths[..]),\n-            Subcommand::Run { ref paths, .. } => (Kind::Run, &paths[..]),\n-            Subcommand::Clean { ref paths, .. } => (Kind::Clean, &paths[..]),\n+            Subcommand::Build => (Kind::Build, &paths[..]),\n+            Subcommand::Check { .. } => (Kind::Check, &paths[..]),\n+            Subcommand::Clippy { .. } => (Kind::Clippy, &paths[..]),\n+            Subcommand::Fix => (Kind::Fix, &paths[..]),\n+            Subcommand::Doc { .. } => (Kind::Doc, &paths[..]),\n+            Subcommand::Test { .. } => (Kind::Test, &paths[..]),\n+            Subcommand::Bench { .. } => (Kind::Bench, &paths[..]),\n+            Subcommand::Dist => (Kind::Dist, &paths[..]),\n+            Subcommand::Install => (Kind::Install, &paths[..]),\n+            Subcommand::Run { .. } => (Kind::Run, &paths[..]),\n+            Subcommand::Clean { .. } => (Kind::Clean, &paths[..]),\n             Subcommand::Format { .. } => (Kind::Format, &[][..]),\n             Subcommand::Suggest { .. } => (Kind::Suggest, &[][..]),\n             Subcommand::Setup { profile: ref path } => ("}, {"sha": "c32fe59bbf0697de8b84637983b2eca1434c737d", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -236,7 +236,7 @@ mod defaults {\n     fn doc_default() {\n         let mut config = configure(\"doc\", &[\"A\"], &[\"A\"]);\n         config.compiler_docs = true;\n-        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false, json: false };\n+        config.cmd = Subcommand::Doc { open: false, json: false };\n         let mut cache = run_build(&[], config);\n         let a = TargetSelection::from_user(\"A\");\n \n@@ -545,19 +545,21 @@ mod dist {\n     fn test_with_no_doc_stage0() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n         config.stage = 0;\n+        config.paths = vec![\"library/std\".into()];\n         config.cmd = Subcommand::Test {\n-            paths: vec![\"library/std\".into()],\n             test_args: vec![],\n             rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n+            no_fail_fast: false,\n+            no_doc: true,\n+            doc: false,\n             bless: false,\n             force_rerun: false,\n             compare_mode: None,\n             rustfix_coverage: false,\n             pass: None,\n             run: None,\n             only_modified: false,\n+            skip: vec![],\n         };\n \n         let build = Build::new(config);\n@@ -587,7 +589,7 @@ mod dist {\n     fn doc_ci() {\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n         config.compiler_docs = true;\n-        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false, json: false };\n+        config.cmd = Subcommand::Doc { open: false, json: false };\n         let build = Build::new(config);\n         let mut builder = Builder::new(&build);\n         builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n@@ -616,11 +618,12 @@ mod dist {\n         // Behavior of `x.py test` doing various documentation tests.\n         let mut config = configure(&[\"A\"], &[\"A\"]);\n         config.cmd = Subcommand::Test {\n-            paths: vec![],\n             test_args: vec![],\n             rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::Yes,\n+            no_fail_fast: false,\n+            doc: true,\n+            no_doc: false,\n+            skip: vec![],\n             bless: false,\n             force_rerun: false,\n             compare_mode: None,"}, {"sha": "b11be96cefe628ec5596e6c9470c8316f45dc666", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -20,15 +20,7 @@ fn args(builder: &Builder<'_>) -> Vec<String> {\n         arr.iter().copied().map(String::from)\n     }\n \n-    if let Subcommand::Clippy {\n-        fix,\n-        clippy_lint_allow,\n-        clippy_lint_deny,\n-        clippy_lint_warn,\n-        clippy_lint_forbid,\n-        ..\n-    } = &builder.config.cmd\n-    {\n+    if let Subcommand::Clippy { fix, allow, deny, warn, forbid, .. } = &builder.config.cmd {\n         // disable the most spammy clippy lints\n         let ignored_lints = vec![\n             \"many_single_char_names\", // there are a lot in stdarch\n@@ -53,10 +45,10 @@ fn args(builder: &Builder<'_>) -> Vec<String> {\n         args.extend(strings(&[\"--\", \"--cap-lints\", \"warn\"]));\n         args.extend(ignored_lints.iter().map(|lint| format!(\"-Aclippy::{}\", lint)));\n         let mut clippy_lint_levels: Vec<String> = Vec::new();\n-        clippy_lint_allow.iter().for_each(|v| clippy_lint_levels.push(format!(\"-A{}\", v)));\n-        clippy_lint_deny.iter().for_each(|v| clippy_lint_levels.push(format!(\"-D{}\", v)));\n-        clippy_lint_warn.iter().for_each(|v| clippy_lint_levels.push(format!(\"-W{}\", v)));\n-        clippy_lint_forbid.iter().for_each(|v| clippy_lint_levels.push(format!(\"-F{}\", v)));\n+        allow.iter().for_each(|v| clippy_lint_levels.push(format!(\"-A{}\", v)));\n+        deny.iter().for_each(|v| clippy_lint_levels.push(format!(\"-D{}\", v)));\n+        warn.iter().for_each(|v| clippy_lint_levels.push(format!(\"-W{}\", v)));\n+        forbid.iter().for_each(|v| clippy_lint_levels.push(format!(\"-F{}\", v)));\n         args.extend(clippy_lint_levels);\n         args.extend(builder.config.free_args.clone());\n         args"}, {"sha": "f4e97d7dfed284c6260be2e1320bf12647ec1c71", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -21,7 +21,7 @@ use crate::cache::{Interned, INTERNER};\n use crate::cc_detect::{ndk_compiler, Language};\n use crate::channel::{self, GitInfo};\n pub use crate::flags::Subcommand;\n-use crate::flags::{Color, Flags};\n+use crate::flags::{Color, Flags, Warnings};\n use crate::util::{exe, output, t};\n use once_cell::sync::OnceCell;\n use serde::{Deserialize, Deserializer};\n@@ -237,6 +237,8 @@ pub struct Config {\n     initial_rustfmt: RefCell<RustfmtState>,\n     #[cfg(test)]\n     pub initial_rustfmt: RefCell<RustfmtState>,\n+\n+    pub paths: Vec<PathBuf>,\n }\n \n #[derive(Default, Deserialize, Clone)]\n@@ -376,6 +378,16 @@ pub struct TargetSelection {\n     file: Option<Interned<String>>,\n }\n \n+/// Newtype over `Vec<TargetSelection>` so we can implement custom parsing logic\n+#[derive(Clone, Default, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct TargetSelectionList(Vec<TargetSelection>);\n+\n+pub fn target_selection_list(s: &str) -> Result<TargetSelectionList, String> {\n+    Ok(TargetSelectionList(\n+        s.split(\",\").filter(|s| !s.is_empty()).map(TargetSelection::from_user).collect(),\n+    ))\n+}\n+\n impl TargetSelection {\n     pub fn from_user(selection: &str) -> Self {\n         let path = Path::new(selection);\n@@ -871,26 +883,24 @@ impl Config {\n     }\n \n     fn parse_inner<'a>(args: &[String], get_toml: impl 'a + Fn(&Path) -> TomlConfig) -> Config {\n-        let flags = Flags::parse(&args);\n+        let mut flags = Flags::parse(&args);\n         let mut config = Config::default_opts();\n \n         // Set flags.\n+        config.paths = std::mem::take(&mut flags.paths);\n         config.exclude = flags.exclude.into_iter().map(|path| TaskPath::parse(path)).collect();\n         config.include_default_paths = flags.include_default_paths;\n         config.rustc_error_format = flags.rustc_error_format;\n         config.json_output = flags.json_output;\n         config.on_fail = flags.on_fail;\n-        config.jobs = flags.jobs.map(threads_from_config);\n+        config.jobs = Some(threads_from_config(flags.jobs as u32));\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n         config.dry_run = if flags.dry_run { DryRun::UserSelected } else { DryRun::Disabled };\n         config.keep_stage = flags.keep_stage;\n         config.keep_stage_std = flags.keep_stage_std;\n         config.color = flags.color;\n-        config.free_args = flags.free_args.clone().unwrap_or_default();\n-        if let Some(value) = flags.deny_warnings {\n-            config.deny_warnings = value;\n-        }\n+        config.free_args = std::mem::take(&mut flags.free_args);\n         config.llvm_profile_use = flags.llvm_profile_use;\n         config.llvm_profile_generate = flags.llvm_profile_generate;\n         config.llvm_bolt_profile_generate = flags.llvm_bolt_profile_generate;\n@@ -1021,14 +1031,14 @@ impl Config {\n             config.out = dir;\n         }\n \n-        config.hosts = if let Some(arg_host) = flags.host {\n+        config.hosts = if let Some(TargetSelectionList(arg_host)) = flags.host {\n             arg_host\n         } else if let Some(file_host) = build.host {\n             file_host.iter().map(|h| TargetSelection::from_user(h)).collect()\n         } else {\n             vec![config.build]\n         };\n-        config.targets = if let Some(arg_target) = flags.target {\n+        config.targets = if let Some(TargetSelectionList(arg_target)) = flags.target {\n             arg_target\n         } else if let Some(file_target) = build.target {\n             file_target.iter().map(|h| TargetSelection::from_user(h)).collect()\n@@ -1064,7 +1074,7 @@ impl Config {\n         set(&mut config.print_step_rusage, build.print_step_rusage);\n         set(&mut config.patch_binaries_for_nix, build.patch_binaries_for_nix);\n \n-        config.verbose = cmp::max(config.verbose, flags.verbose);\n+        config.verbose = cmp::max(config.verbose, flags.verbose as usize);\n \n         if let Some(install) = toml.install {\n             config.prefix = install.prefix.map(PathBuf::from);\n@@ -1137,7 +1147,14 @@ impl Config {\n             config.rustc_default_linker = rust.default_linker;\n             config.musl_root = rust.musl_root.map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.map(PathBuf::from);\n-            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n+            set(\n+                &mut config.deny_warnings,\n+                match flags.warnings {\n+                    Warnings::Deny => Some(true),\n+                    Warnings::Warn => Some(false),\n+                    Warnings::Default => rust.deny_warnings,\n+                },\n+            );\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             config.rust_thin_lto_import_instr_limit = rust.thin_lto_import_instr_limit;"}, {"sha": "d913ca295e29db58233ae9fbcb0b833105757301", "filename": "src/bootstrap/config/tests.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -1,4 +1,5 @@\n-use super::{Config, TomlConfig};\n+use super::{Config, Flags, TomlConfig};\n+use clap::CommandFactory;\n use std::{env, path::Path};\n \n fn toml(config: &str) -> impl '_ + Fn(&Path) -> TomlConfig {\n@@ -88,3 +89,8 @@ fn detect_src_and_out() {\n         test(parse(\"build.build-dir = \\\"/tmp\\\"\"), build_dir);\n     }\n }\n+\n+#[test]\n+fn clap_verify() {\n+    Flags::command().debug_assert();\n+}"}, {"sha": "c79a1bf9563c2c55812f407720934325ad9b14f2", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 336, "deletions": 659, "changes": 995, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -5,724 +5,409 @@\n \n use std::path::PathBuf;\n \n-use getopts::Options;\n+use clap::{Parser, ValueEnum};\n \n use crate::builder::{Builder, Kind};\n-use crate::config::{Config, TargetSelection};\n+use crate::config::{target_selection_list, Config, TargetSelectionList};\n use crate::setup::Profile;\n-use crate::util::t;\n use crate::{Build, DocTests};\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Default, Debug, ValueEnum)]\n pub enum Color {\n     Always,\n     Never,\n+    #[default]\n     Auto,\n }\n \n-impl Default for Color {\n-    fn default() -> Self {\n-        Self::Auto\n-    }\n-}\n-\n-impl std::str::FromStr for Color {\n-    type Err = ();\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s.to_lowercase().as_str() {\n-            \"always\" => Ok(Self::Always),\n-            \"never\" => Ok(Self::Never),\n-            \"auto\" => Ok(Self::Auto),\n-            _ => Err(()),\n-        }\n-    }\n+/// Whether to deny warnings, emit them as warnings, or use the default behavior\n+#[derive(Copy, Clone, Default, Debug, ValueEnum)]\n+pub enum Warnings {\n+    Deny,\n+    Warn,\n+    #[default]\n+    Default,\n }\n \n /// Deserialized version of all flags for this compile.\n+#[derive(Debug, Parser)]\n+#[clap(\n+    override_usage = \"x.py <subcommand> [options] [<paths>...]\",\n+    disable_help_subcommand(true),\n+    about = \"\",\n+    next_line_help(false)\n+)]\n pub struct Flags {\n-    pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n-    pub on_fail: Option<String>,\n-    pub stage: Option<u32>,\n-    pub keep_stage: Vec<u32>,\n-    pub keep_stage_std: Vec<u32>,\n+    #[command(subcommand)]\n+    pub cmd: Subcommand,\n \n-    pub host: Option<Vec<TargetSelection>>,\n-    pub target: Option<Vec<TargetSelection>>,\n+    #[arg(global(true), short, long, action = clap::ArgAction::Count)]\n+    /// use verbose output (-vv for very verbose)\n+    pub verbose: u8, // each extra -v after the first is passed to Cargo\n+    #[arg(global(true), short, long)]\n+    /// use incremental compilation\n+    pub incremental: bool,\n+    #[arg(global(true), long, value_hint = clap::ValueHint::FilePath, value_name = \"FILE\")]\n+    /// TOML configuration file for build\n     pub config: Option<PathBuf>,\n+    #[arg(global(true), long, value_hint = clap::ValueHint::DirPath, value_name = \"DIR\")]\n+    /// Build directory, overrides `build.build-dir` in `config.toml`\n     pub build_dir: Option<PathBuf>,\n-    pub jobs: Option<u32>,\n-    pub cmd: Subcommand,\n-    pub incremental: bool,\n+\n+    #[arg(global(true), long, value_name = \"BUILD\")]\n+    /// build target of the stage0 compiler\n+    pub build: Option<String>,\n+\n+    #[arg(global(true), long, value_name = \"HOST\", value_parser = target_selection_list)]\n+    /// host targets to build\n+    pub host: Option<TargetSelectionList>,\n+\n+    #[arg(global(true), long, value_name = \"TARGET\", value_parser = target_selection_list)]\n+    /// target targets to build\n+    pub target: Option<TargetSelectionList>,\n+\n+    #[arg(global(true), long, value_name = \"PATH\")]\n+    /// build paths to exclude\n     pub exclude: Vec<PathBuf>,\n+    #[arg(global(true), long)]\n+    /// include default paths in addition to the provided ones\n     pub include_default_paths: bool,\n+\n+    #[arg(global(true), long)]\n     pub rustc_error_format: Option<String>,\n-    pub json_output: bool,\n+\n+    #[arg(global(true), long, value_hint = clap::ValueHint::CommandString, value_name = \"CMD\")]\n+    /// command to run on failure\n+    pub on_fail: Option<String>,\n+    #[arg(global(true), long)]\n+    /// dry run; don't build anything\n     pub dry_run: bool,\n-    pub color: Color,\n+    #[arg(global(true), long, value_name = \"N\")]\n+    /// stage to build (indicates compiler to use/test, e.g., stage 0 uses the\n+    /// bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\n+    pub stage: Option<u32>,\n \n+    #[arg(global(true), long, value_name = \"N\")]\n+    /// stage(s) to keep without recompiling\n+    /// (pass multiple times to keep e.g., both stages 0 and 1)\n+    pub keep_stage: Vec<u32>,\n+    #[arg(global(true), long, value_name = \"N\")]\n+    /// stage(s) of the standard library to keep without recompiling\n+    /// (pass multiple times to keep e.g., both stages 0 and 1)\n+    pub keep_stage_std: Vec<u32>,\n+    #[arg(global(true), long, value_hint = clap::ValueHint::DirPath, value_name = \"DIR\")]\n+    /// path to the root of the rust checkout\n+    pub src: Option<PathBuf>,\n+\n+    #[arg(\n+        global(true),\n+        short,\n+        long,\n+        default_value_t = std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get),\n+        value_name = \"JOBS\"\n+    )]\n+    /// number of jobs to run in parallel\n+    pub jobs: usize,\n     // This overrides the deny-warnings configuration option,\n     // which passes -Dwarnings to the compiler invocations.\n-    //\n-    // true => deny, false => warn\n-    pub deny_warnings: Option<bool>,\n+    #[arg(global(true), long)]\n+    #[clap(value_enum, default_value_t=Warnings::Default, value_name = \"deny|warn\")]\n+    /// if value is deny, will deny warnings\n+    /// if value is warn, will emit warnings\n+    /// otherwise, use the default configured behaviour\n+    pub warnings: Warnings,\n+\n+    #[arg(global(true), long, value_name = \"FORMAT\")]\n+    /// rustc error format\n+    pub error_format: Option<String>,\n+    #[arg(global(true), long)]\n+    /// use message-format=json\n+    pub json_output: bool,\n \n-    pub rust_profile_use: Option<String>,\n-    pub rust_profile_generate: Option<String>,\n+    #[arg(global(true), long, value_name = \"STYLE\")]\n+    #[clap(value_enum, default_value_t = Color::Auto)]\n+    /// whether to use color in cargo and rustc output\n+    pub color: Color,\n \n+    /// whether rebuilding llvm should be skipped, overriding `skip-rebuld` in config.toml\n+    #[arg(global(true), long, value_name = \"VALUE\")]\n+    pub llvm_skip_rebuild: Option<bool>,\n+    /// generate PGO profile with rustc build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n+    pub rust_profile_generate: Option<String>,\n+    /// use PGO profile for rustc build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n+    pub rust_profile_use: Option<String>,\n+    /// use PGO profile for LLVM build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n     pub llvm_profile_use: Option<String>,\n     // LLVM doesn't support a custom location for generating profile\n     // information.\n     //\n     // llvm_out/build/profiles/ is the location this writes to.\n+    /// generate PGO profile with llvm built for rustc\n+    #[arg(global(true), long)]\n     pub llvm_profile_generate: bool,\n+    /// generate BOLT profile for LLVM build\n+    #[arg(global(true), long)]\n     pub llvm_bolt_profile_generate: bool,\n+    /// use BOLT profile for LLVM build\n+    #[arg(global(true), long, value_name = \"PROFILE\")]\n     pub llvm_bolt_profile_use: Option<String>,\n+    #[arg(global(true))]\n+    /// paths for the subcommand\n+    pub paths: Vec<PathBuf>,\n+    /// arguments passed to subcommands\n+    #[arg(global(true), last(true), value_name = \"ARGS\")]\n+    pub free_args: Vec<String>,\n+}\n+\n+impl Flags {\n+    pub fn parse(args: &[String]) -> Self {\n+        let first = String::from(\"x.py\");\n+        let it = std::iter::once(&first).chain(args.iter());\n+        // We need to check for `<cmd> -h -v`, in which case we list the paths\n+        #[derive(Parser)]\n+        #[clap(disable_help_flag(true))]\n+        struct HelpVerboseOnly {\n+            #[arg(short, long)]\n+            help: bool,\n+            #[arg(global(true), short, long, action = clap::ArgAction::Count)]\n+            pub verbose: u8,\n+            #[arg(value_enum)]\n+            cmd: Kind,\n+        }\n+        if let Ok(HelpVerboseOnly { help: true, verbose: 1.., cmd: subcommand }) =\n+            HelpVerboseOnly::try_parse_from(it.clone())\n+        {\n+            println!(\"note: updating submodules before printing available paths\");\n+            let config = Config::parse(&[String::from(\"build\")]);\n+            let build = Build::new(config);\n+            let paths = Builder::get_help(&build, subcommand);\n+            if let Some(s) = paths {\n+                println!(\"{}\", s);\n+            } else {\n+                panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n+            }\n+            crate::detail_exit(0);\n+        }\n \n-    /// Arguments appearing after `--` to be forwarded to tools,\n-    /// e.g. `--fix-broken` or test arguments.\n-    pub free_args: Option<Vec<String>>,\n+        Flags::parse_from(it)\n+    }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug, Clone, Default, clap::Subcommand)]\n pub enum Subcommand {\n-    Build {\n-        paths: Vec<PathBuf>,\n-    },\n+    #[clap(aliases = [\"b\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to compile. For example, for a quick build of a usable\n+        compiler:\n+            ./x.py build --stage 1 library/std\n+        This will build a compiler and standard library from the local source code.\n+        Once this is done, build/$ARCH/stage1 contains a usable compiler.\n+        If no arguments are passed then the default artifacts for that stage are\n+        compiled. For example:\n+            ./x.py build --stage 0\n+            ./x.py build \")]\n+    /// Compile either the compiler or libraries\n+    #[default]\n+    Build,\n+    #[clap(aliases = [\"c\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to compile. For example:\n+            ./x.py check library/std\n+        If no arguments are passed then many artifacts are checked.\")]\n+    /// Compile either the compiler or libraries, using cargo check\n     Check {\n-        paths: Vec<PathBuf>,\n+        #[arg(long)]\n+        /// Check all targets\n+        all_targets: bool,\n     },\n+    /// Run Clippy (uses rustup/cargo-installed clippy binary)\n+    #[clap(long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to run clippy against. For example:\n+            ./x.py clippy library/core\n+            ./x.py clippy library/core library/proc_macro\")]\n     Clippy {\n+        #[arg(long)]\n         fix: bool,\n-        paths: Vec<PathBuf>,\n-        clippy_lint_allow: Vec<String>,\n-        clippy_lint_deny: Vec<String>,\n-        clippy_lint_warn: Vec<String>,\n-        clippy_lint_forbid: Vec<String>,\n-    },\n-    Fix {\n-        paths: Vec<PathBuf>,\n+        /// clippy lints to allow\n+        #[arg(global(true), short = 'A', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        allow: Vec<String>,\n+        /// clippy lints to deny\n+        #[arg(global(true), short = 'D', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        deny: Vec<String>,\n+        /// clippy lints to warn on\n+        #[arg(global(true), short = 'W', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        warn: Vec<String>,\n+        /// clippy lints to forbid\n+        #[arg(global(true), short = 'F', action = clap::ArgAction::Append, value_name = \"LINT\")]\n+        forbid: Vec<String>,\n     },\n+    /// Run cargo fix\n+    #[clap(long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories to the crates\n+        and/or artifacts to run `cargo fix` against. For example:\n+            ./x.py fix library/core\n+            ./x.py fix library/core library/proc_macro\")]\n+    Fix,\n+    #[clap(\n+        name = \"fmt\",\n+        long_about = \"\\n\n+    Arguments:\n+        This subcommand optionally accepts a `--check` flag which succeeds if formatting is correct and\n+        fails if it is not. For example:\n+            ./x.py fmt\n+            ./x.py fmt --check\"\n+    )]\n+    /// Run rustfmt\n     Format {\n-        paths: Vec<PathBuf>,\n+        /// check formatting instead of applying\n+        #[arg(long)]\n         check: bool,\n     },\n+    #[clap(aliases = [\"d\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to directories of documentation\n+        to build. For example:\n+            ./x.py doc src/doc/book\n+            ./x.py doc src/doc/nomicon\n+            ./x.py doc src/doc/book library/std\n+            ./x.py doc library/std --json\n+            ./x.py doc library/std --open\n+        If no arguments are passed then everything is documented:\n+            ./x.py doc\n+            ./x.py doc --stage 1\")]\n+    /// Build documentation\n     Doc {\n-        paths: Vec<PathBuf>,\n+        #[arg(long)]\n+        /// open the docs in a browser\n         open: bool,\n+        #[arg(long)]\n+        /// render the documentation in JSON format in addition to the usual HTML format\n         json: bool,\n     },\n+    #[clap(aliases = [\"t\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to test directories that\n+        should be compiled and run. For example:\n+            ./x.py test tests/ui\n+            ./x.py test library/std --test-args hash_map\n+            ./x.py test library/std --stage 0 --no-doc\n+            ./x.py test tests/ui --bless\n+            ./x.py test tests/ui --compare-mode chalk\n+        Note that `test tests/* --stage N` does NOT depend on `build compiler/rustc --stage N`;\n+        just like `build library/std --stage N` it tests the compiler produced by the previous\n+        stage.\n+        Execute tool tests with a tool name argument:\n+            ./x.py test tidy\n+        If no arguments are passed then the complete artifacts for that stage are\n+        compiled and tested.\n+            ./x.py test\n+            ./x.py test --stage 1\")]\n+    /// Build and run some test suites\n     Test {\n-        paths: Vec<PathBuf>,\n-        /// Whether to automatically update stderr/stdout files\n+        #[arg(long)]\n+        /// run all tests regardless of failure\n+        no_fail_fast: bool,\n+        #[arg(long, value_name = \"SUBSTRING\")]\n+        /// skips tests matching SUBSTRING, if supported by test tool. May be passed multiple times\n+        skip: Vec<String>,\n+        #[arg(long, value_name = \"ARGS\", allow_hyphen_values(true))]\n+        /// extra arguments to be passed for the test tool being used\n+        /// (e.g. libtest, compiletest or rustdoc)\n+        test_args: Vec<String>,\n+        /// extra options to pass the compiler when running tests\n+        #[arg(long, value_name = \"ARGS\", allow_hyphen_values(true))]\n+        rustc_args: Vec<String>,\n+        #[arg(long)]\n+        /// do not run doc tests\n+        no_doc: bool,\n+        #[arg(long)]\n+        /// only run doc tests\n+        doc: bool,\n+        #[arg(long)]\n+        /// whether to automatically update stderr/stdout files\n         bless: bool,\n+        #[arg(long)]\n+        /// rerun tests even if the inputs are unchanged\n         force_rerun: bool,\n+        #[arg(long)]\n+        /// only run tests that result has been changed\n+        only_modified: bool,\n+        #[arg(long, value_name = \"COMPARE MODE\")]\n+        /// mode describing what file the actual ui output will be compared to\n         compare_mode: Option<String>,\n+        #[arg(long, value_name = \"check | build | run\")]\n+        /// force {check,build,run}-pass tests to this mode.\n         pass: Option<String>,\n+        #[arg(long, value_name = \"auto | always | never\")]\n+        /// whether to execute run-* tests\n         run: Option<String>,\n-        test_args: Vec<String>,\n-        rustc_args: Vec<String>,\n-        fail_fast: bool,\n-        doc_tests: DocTests,\n+        #[arg(long)]\n+        /// enable this to generate a Rustfix coverage file, which is saved in\n+        /// `/<build_base>/rustfix_missing_coverage.txt`\n         rustfix_coverage: bool,\n-        only_modified: bool,\n     },\n+    /// Build and run some benchmarks\n     Bench {\n-        paths: Vec<PathBuf>,\n+        #[arg(long, allow_hyphen_values(true))]\n         test_args: Vec<String>,\n     },\n+    /// Clean out build directories\n     Clean {\n-        paths: Vec<PathBuf>,\n+        #[arg(long)]\n         all: bool,\n     },\n-    Dist {\n-        paths: Vec<PathBuf>,\n-    },\n-    Install {\n-        paths: Vec<PathBuf>,\n-    },\n+    /// Duild distribution artifacts\n+    Dist,\n+    /// Install distribution artifacts\n+    Install,\n+    #[clap(aliases = [\"r\"], long_about = \"\\n\n+    Arguments:\n+        This subcommand accepts a number of paths to tools to build and run. For\n+        example:\n+            ./x.py run src/tools/expand-yaml-anchors\n+        At least a tool needs to be called.\")]\n+    /// Run tools contained in this repository\n     Run {\n-        paths: Vec<PathBuf>,\n+        /// arguments for the tool\n+        #[arg(long, allow_hyphen_values(true))]\n         args: Vec<String>,\n     },\n-    Setup {\n-        profile: Option<PathBuf>,\n-    },\n-    Suggest {\n-        run: bool,\n-    },\n-}\n-\n-impl Default for Subcommand {\n-    fn default() -> Subcommand {\n-        Subcommand::Build { paths: vec![PathBuf::from(\"nowhere\")] }\n-    }\n-}\n-\n-impl Flags {\n-    pub fn parse(args: &[String]) -> Flags {\n-        let (args, free_args) = if let Some(pos) = args.iter().position(|s| s == \"--\") {\n-            let (args, free) = args.split_at(pos);\n-            (args, Some(free[1..].to_vec()))\n-        } else {\n-            (args, None)\n-        };\n-        let mut subcommand_help = String::from(\n-            \"\\\n-Usage: x.py <subcommand> [options] [<paths>...]\n-\n-Subcommands:\n-    build, b    Compile either the compiler or libraries\n-    check, c    Compile either the compiler or libraries, using cargo check\n-    clippy      Run clippy (uses rustup/cargo-installed clippy binary)\n-    fix         Run cargo fix\n-    fmt         Run rustfmt\n-    test, t     Build and run some test suites\n-    bench       Build and run some benchmarks\n-    doc, d      Build documentation\n-    clean       Clean out build directories\n-    dist        Build distribution artifacts\n-    install     Install distribution artifacts\n-    run, r      Run tools contained in this repository\n-    setup       Create a config.toml (making it easier to use `x.py` itself)\n-    suggest     Suggest a subset of tests to run, based on modified files\n-\n-To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n-        );\n-\n-        let mut opts = Options::new();\n-        // Options common to all subcommands\n-        opts.optflagmulti(\"v\", \"verbose\", \"use verbose output (-vv for very verbose)\");\n-        opts.optflag(\"i\", \"incremental\", \"use incremental compilation\");\n-        opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n-        opts.optopt(\n-            \"\",\n-            \"build-dir\",\n-            \"Build directory, overrides `build.build-dir` in `config.toml`\",\n-            \"DIR\",\n-        );\n-        opts.optopt(\"\", \"build\", \"build target of the stage0 compiler\", \"BUILD\");\n-        opts.optmulti(\"\", \"host\", \"host targets to build\", \"HOST\");\n-        opts.optmulti(\"\", \"target\", \"target targets to build\", \"TARGET\");\n-        opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n-        opts.optflag(\n-            \"\",\n-            \"include-default-paths\",\n-            \"include default paths in addition to the provided ones\",\n-        );\n-        opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n-        opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n-        opts.optopt(\n-            \"\",\n-            \"stage\",\n-            \"stage to build (indicates compiler to use/test, e.g., stage 0 uses the \\\n-             bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n-            \"N\",\n-        );\n-        opts.optmulti(\n-            \"\",\n-            \"keep-stage\",\n-            \"stage(s) to keep without recompiling \\\n-            (pass multiple times to keep e.g., both stages 0 and 1)\",\n-            \"N\",\n-        );\n-        opts.optmulti(\n-            \"\",\n-            \"keep-stage-std\",\n-            \"stage(s) of the standard library to keep without recompiling \\\n-            (pass multiple times to keep e.g., both stages 0 and 1)\",\n-            \"N\",\n-        );\n-        opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n-        let j_msg = format!(\n-            \"number of jobs to run in parallel; \\\n-             defaults to {} (this host's logical CPU count)\",\n-            std::thread::available_parallelism().map_or(1, std::num::NonZeroUsize::get)\n-        );\n-        opts.optopt(\"j\", \"jobs\", &j_msg, \"JOBS\");\n-        opts.optflag(\"h\", \"help\", \"print this help message\");\n-        opts.optopt(\n-            \"\",\n-            \"warnings\",\n-            \"if value is deny, will deny warnings, otherwise use default\",\n-            \"VALUE\",\n-        );\n-        opts.optopt(\"\", \"error-format\", \"rustc error format\", \"FORMAT\");\n-        opts.optflag(\"\", \"json-output\", \"use message-format=json\");\n-        opts.optopt(\"\", \"color\", \"whether to use color in cargo and rustc output\", \"STYLE\");\n-        opts.optopt(\n-            \"\",\n-            \"rust-profile-generate\",\n-            \"generate PGO profile with rustc build\",\n-            \"PROFILE\",\n-        );\n-        opts.optopt(\"\", \"rust-profile-use\", \"use PGO profile for rustc build\", \"PROFILE\");\n-        opts.optflag(\"\", \"llvm-profile-generate\", \"generate PGO profile with llvm built for rustc\");\n-        opts.optopt(\"\", \"llvm-profile-use\", \"use PGO profile for llvm build\", \"PROFILE\");\n-        opts.optmulti(\"A\", \"\", \"allow certain clippy lints\", \"OPT\");\n-        opts.optmulti(\"D\", \"\", \"deny certain clippy lints\", \"OPT\");\n-        opts.optmulti(\"W\", \"\", \"warn about certain clippy lints\", \"OPT\");\n-        opts.optmulti(\"F\", \"\", \"forbid certain clippy lints\", \"OPT\");\n-        opts.optflag(\"\", \"llvm-bolt-profile-generate\", \"generate BOLT profile for LLVM build\");\n-        opts.optopt(\"\", \"llvm-bolt-profile-use\", \"use BOLT profile for LLVM build\", \"PROFILE\");\n-\n-        // We can't use getopt to parse the options until we have completed specifying which\n-        // options are valid, but under the current implementation, some options are conditional on\n-        // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n-        // complete the definition of the options.  Then we can use the getopt::Matches object from\n-        // there on out.\n-        let subcommand = match args.iter().find_map(|s| Kind::parse(&s)) {\n-            Some(s) => s,\n-            None => {\n-                // No or an invalid subcommand -- show the general usage and subcommand help\n-                // An exit code will be 0 when no subcommand is given, and 1 in case of an invalid\n-                // subcommand.\n-                println!(\"{}\\n\", subcommand_help);\n-                let exit_code = if args.is_empty() { 0 } else { 1 };\n-                crate::detail_exit(exit_code);\n-            }\n-        };\n-\n-        // Some subcommands get extra options\n-        match subcommand {\n-            Kind::Test => {\n-                opts.optflag(\"\", \"no-fail-fast\", \"Run all tests regardless of failure\");\n-                opts.optmulti(\"\", \"skip\", \"skips tests matching SUBSTRING, if supported by test tool. May be passed multiple times\", \"SUBSTRING\");\n-                opts.optmulti(\n-                    \"\",\n-                    \"test-args\",\n-                    \"extra arguments to be passed for the test tool being used \\\n-                        (e.g. libtest, compiletest or rustdoc)\",\n-                    \"ARGS\",\n-                );\n-                opts.optmulti(\n-                    \"\",\n-                    \"rustc-args\",\n-                    \"extra options to pass the compiler when running tests\",\n-                    \"ARGS\",\n-                );\n-                opts.optflag(\"\", \"no-doc\", \"do not run doc tests\");\n-                opts.optflag(\"\", \"doc\", \"only run doc tests\");\n-                opts.optflag(\"\", \"bless\", \"update all stderr/stdout files of failing ui tests\");\n-                opts.optflag(\"\", \"force-rerun\", \"rerun tests even if the inputs are unchanged\");\n-                opts.optflag(\"\", \"only-modified\", \"only run tests that result has been changed\");\n-                opts.optopt(\n-                    \"\",\n-                    \"compare-mode\",\n-                    \"mode describing what file the actual ui output will be compared to\",\n-                    \"COMPARE MODE\",\n-                );\n-                opts.optopt(\n-                    \"\",\n-                    \"pass\",\n-                    \"force {check,build,run}-pass tests to this mode.\",\n-                    \"check | build | run\",\n-                );\n-                opts.optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\");\n-                opts.optflag(\n-                    \"\",\n-                    \"rustfix-coverage\",\n-                    \"enable this to generate a Rustfix coverage file, which is saved in \\\n-                        `/<build_base>/rustfix_missing_coverage.txt`\",\n-                );\n-            }\n-            Kind::Check => {\n-                opts.optflag(\"\", \"all-targets\", \"Check all targets\");\n-            }\n-            Kind::Bench => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-            }\n-            Kind::Clippy => {\n-                opts.optflag(\"\", \"fix\", \"automatically apply lint suggestions\");\n-            }\n-            Kind::Doc => {\n-                opts.optflag(\"\", \"open\", \"open the docs in a browser\");\n-                opts.optflag(\n-                    \"\",\n-                    \"json\",\n-                    \"render the documentation in JSON format in addition to the usual HTML format\",\n-                );\n-            }\n-            Kind::Clean => {\n-                opts.optflag(\"\", \"all\", \"clean all build artifacts\");\n-            }\n-            Kind::Format => {\n-                opts.optflag(\"\", \"check\", \"check formatting instead of applying.\");\n-            }\n-            Kind::Run => {\n-                opts.optmulti(\"\", \"args\", \"arguments for the tool\", \"ARGS\");\n-            }\n-            Kind::Suggest => {\n-                opts.optflag(\"\", \"run\", \"run suggested tests\");\n-            }\n-            _ => {}\n-        };\n-\n-        // fn usage()\n-        let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n-            println!(\"{}\", opts.usage(subcommand_help));\n-            if verbose {\n-                // We have an unfortunate situation here: some Steps use `builder.in_tree_crates` to determine their paths.\n-                // To determine those crates, we need to run `cargo metadata`, which means we need all submodules to be checked out.\n-                // That takes a while to run, so only do it when paths were explicitly requested, not on all CLI errors.\n-                // `Build::new` won't load submodules for the `setup` command.\n-                let cmd = if verbose {\n-                    println!(\"note: updating submodules before printing available paths\");\n-                    \"build\"\n-                } else {\n-                    \"setup\"\n-                };\n-                let config = Config::parse(&[cmd.to_string()]);\n-                let build = Build::new(config);\n-                let paths = Builder::get_help(&build, subcommand);\n-\n-                if let Some(s) = paths {\n-                    println!(\"{}\", s);\n-                } else {\n-                    panic!(\"No paths available for subcommand `{}`\", subcommand.as_str());\n-                }\n-            } else {\n-                println!(\n-                    \"Run `./x.py {} -h -v` to see a list of available paths.\",\n-                    subcommand.as_str()\n-                );\n-            }\n-            crate::detail_exit(exit_code);\n-        };\n-\n-        // Done specifying what options are possible, so do the getopts parsing\n-        let matches = opts.parse(args).unwrap_or_else(|e| {\n-            // Invalid argument/option format\n-            println!(\"\\n{}\\n\", e);\n-            usage(1, &opts, false, &subcommand_help);\n-        });\n-\n-        // Extra sanity check to make sure we didn't hit this crazy corner case:\n-        //\n-        //     ./x.py --frobulate clean build\n-        //            ^-- option  ^     ^- actual subcommand\n-        //                        \\_ arg to option could be mistaken as subcommand\n-        let mut pass_sanity_check = true;\n-        match matches.free.get(0).and_then(|s| Kind::parse(&s)) {\n-            Some(check_subcommand) => {\n-                if check_subcommand != subcommand {\n-                    pass_sanity_check = false;\n-                }\n-            }\n-            None => {\n-                pass_sanity_check = false;\n-            }\n-        }\n-        if !pass_sanity_check {\n-            eprintln!(\"{}\\n\", subcommand_help);\n-            eprintln!(\n-                \"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n-                 You may need to move some options to after the subcommand.\\n\"\n-            );\n-            crate::detail_exit(1);\n-        }\n-        // Extra help text for some commands\n-        match subcommand {\n-            Kind::Build => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to compile. For example, for a quick build of a usable\n-    compiler:\n-\n-        ./x.py build --stage 1 library/std\n-\n-    This will build a compiler and standard library from the local source code.\n-    Once this is done, build/$ARCH/stage1 contains a usable compiler.\n-\n-    If no arguments are passed then the default artifacts for that stage are\n-    compiled. For example:\n-\n-        ./x.py build --stage 0\n-        ./x.py build \",\n-                );\n-            }\n-            Kind::Check => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to compile. For example:\n-\n-        ./x.py check library/std\n-\n-    If no arguments are passed then many artifacts are checked.\",\n-                );\n-            }\n-            Kind::Clippy => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to run clippy against. For example:\n-\n-        ./x.py clippy library/core\n-        ./x.py clippy library/core library/proc_macro\",\n-                );\n-            }\n-            Kind::Fix => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories to the crates\n-    and/or artifacts to run `cargo fix` against. For example:\n-\n-        ./x.py fix library/core\n-        ./x.py fix library/core library/proc_macro\",\n-                );\n-            }\n-            Kind::Format => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand optionally accepts a `--check` flag which succeeds if formatting is correct and\n-    fails if it is not. For example:\n-\n-        ./x.py fmt\n-        ./x.py fmt --check\",\n-                );\n-            }\n-            Kind::Test => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to test directories that\n-    should be compiled and run. For example:\n-\n-        ./x.py test tests/ui\n-        ./x.py test library/std --test-args hash_map\n-        ./x.py test library/std --stage 0 --no-doc\n-        ./x.py test tests/ui --bless\n-        ./x.py test tests/ui --compare-mode chalk\n-\n-    Note that `test tests/* --stage N` does NOT depend on `build compiler/rustc --stage N`;\n-    just like `build library/std --stage N` it tests the compiler produced by the previous\n-    stage.\n-\n-    Execute tool tests with a tool name argument:\n-\n-        ./x.py test tidy\n-\n-    If no arguments are passed then the complete artifacts for that stage are\n-    compiled and tested.\n-\n-        ./x.py test\n-        ./x.py test --stage 1\",\n-                );\n-            }\n-            Kind::Doc => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to directories of documentation\n-    to build. For example:\n-\n-        ./x.py doc src/doc/book\n-        ./x.py doc src/doc/nomicon\n-        ./x.py doc src/doc/book library/std\n-        ./x.py doc library/std --json\n-        ./x.py doc library/std --open\n-\n-    If no arguments are passed then everything is documented:\n-\n-        ./x.py doc\n-        ./x.py doc --stage 1\",\n-                );\n-            }\n-            Kind::Run => {\n-                subcommand_help.push_str(\n-                    \"\\n\n-Arguments:\n-    This subcommand accepts a number of paths to tools to build and run. For\n-    example:\n-\n-        ./x.py run src/tools/expand-yaml-anchors\n-\n-    At least a tool needs to be called.\",\n-                );\n-            }\n-            Kind::Setup => {\n-                subcommand_help.push_str(&format!(\n-                    \"\\n\n+    /// Set up the environment for development\n+    #[clap(long_about = format!(\n+        \"\\n\n x.py setup creates a `config.toml` which changes the defaults for x.py itself,\n-as well as setting up a git pre-push hook, VS code config and toolchain link.\n-\n+as well as setting up a git pre-push hook, VS Code config and toolchain link.\n Arguments:\n     This subcommand accepts a 'profile' to use for builds. For example:\n-\n         ./x.py setup library\n-\n     The profile is optional and you will be prompted interactively if it is not given.\n     The following profiles are available:\n-\n {}\n-\n-    To only set up the git hook, VS code or toolchain link, you may use\n+    To only set up the git hook, VS Code config or toolchain link, you may use\n         ./x.py setup hook\n         ./x.py setup vscode\n-        ./x.py setup link\n-\",\n-                    Profile::all_for_help(\"        \").trim_end()\n-                ));\n-            }\n-            Kind::Bench | Kind::Clean | Kind::Dist | Kind::Install | Kind::Suggest => {}\n-        };\n-        // Get any optional paths which occur after the subcommand\n-        let mut paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n-\n-        let verbose = matches.opt_present(\"verbose\");\n-\n-        // User passed in -h/--help?\n-        if matches.opt_present(\"help\") {\n-            usage(0, &opts, verbose, &subcommand_help);\n-        }\n-\n-        let cmd = match subcommand {\n-            Kind::Build => Subcommand::Build { paths },\n-            Kind::Check => {\n-                if matches.opt_present(\"all-targets\") {\n-                    println!(\n-                        \"Warning: --all-targets is now on by default and does not need to be passed explicitly.\"\n-                    );\n-                }\n-                Subcommand::Check { paths }\n-            }\n-            Kind::Clippy => Subcommand::Clippy {\n-                paths,\n-                fix: matches.opt_present(\"fix\"),\n-                clippy_lint_allow: matches.opt_strs(\"A\"),\n-                clippy_lint_warn: matches.opt_strs(\"W\"),\n-                clippy_lint_deny: matches.opt_strs(\"D\"),\n-                clippy_lint_forbid: matches.opt_strs(\"F\"),\n-            },\n-            Kind::Fix => Subcommand::Fix { paths },\n-            Kind::Test => Subcommand::Test {\n-                paths,\n-                bless: matches.opt_present(\"bless\"),\n-                force_rerun: matches.opt_present(\"force-rerun\"),\n-                compare_mode: matches.opt_str(\"compare-mode\"),\n-                pass: matches.opt_str(\"pass\"),\n-                run: matches.opt_str(\"run\"),\n-                test_args: matches.opt_strs(\"test-args\"),\n-                rustc_args: matches.opt_strs(\"rustc-args\"),\n-                fail_fast: !matches.opt_present(\"no-fail-fast\"),\n-                rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n-                only_modified: matches.opt_present(\"only-modified\"),\n-                doc_tests: if matches.opt_present(\"doc\") {\n-                    DocTests::Only\n-                } else if matches.opt_present(\"no-doc\") {\n-                    DocTests::No\n-                } else {\n-                    DocTests::Yes\n-                },\n-            },\n-            Kind::Bench => Subcommand::Bench { paths, test_args: matches.opt_strs(\"test-args\") },\n-            Kind::Doc => Subcommand::Doc {\n-                paths,\n-                open: matches.opt_present(\"open\"),\n-                json: matches.opt_present(\"json\"),\n-            },\n-            Kind::Clean => Subcommand::Clean { all: matches.opt_present(\"all\"), paths },\n-            Kind::Format => Subcommand::Format { check: matches.opt_present(\"check\"), paths },\n-            Kind::Dist => Subcommand::Dist { paths },\n-            Kind::Install => Subcommand::Install { paths },\n-            Kind::Suggest => Subcommand::Suggest { run: matches.opt_present(\"run\") },\n-            Kind::Run => {\n-                if paths.is_empty() {\n-                    println!(\"\\nrun requires at least a path!\\n\");\n-                    usage(1, &opts, verbose, &subcommand_help);\n-                }\n-                Subcommand::Run { paths, args: matches.opt_strs(\"args\") }\n-            }\n-            Kind::Setup => {\n-                let profile = if paths.len() > 1 {\n-                    eprintln!(\"\\nerror: At most one option can be passed to setup\\n\");\n-                    usage(1, &opts, verbose, &subcommand_help)\n-                } else if let Some(path) = paths.pop() {\n-                    let profile_string = t!(path.into_os_string().into_string().map_err(\n-                        |path| format!(\"{} is not a valid UTF8 string\", path.to_string_lossy())\n-                    ));\n-\n-                    let profile = profile_string.parse().unwrap_or_else(|err| {\n-                        eprintln!(\"error: {}\", err);\n-                        eprintln!(\"help: the available profiles are:\");\n-                        eprint!(\"{}\", Profile::all_for_help(\"- \"));\n-                        crate::detail_exit(1);\n-                    });\n-                    Some(profile)\n-                } else {\n-                    None\n-                };\n-                Subcommand::Setup { profile }\n-            }\n-        };\n-\n-        Flags {\n-            verbose: matches.opt_count(\"verbose\"),\n-            stage: matches.opt_str(\"stage\").map(|j| j.parse().expect(\"`stage` should be a number\")),\n-            dry_run: matches.opt_present(\"dry-run\"),\n-            on_fail: matches.opt_str(\"on-fail\"),\n-            rustc_error_format: matches.opt_str(\"error-format\"),\n-            json_output: matches.opt_present(\"json-output\"),\n-            keep_stage: matches\n-                .opt_strs(\"keep-stage\")\n-                .into_iter()\n-                .map(|j| j.parse().expect(\"`keep-stage` should be a number\"))\n-                .collect(),\n-            keep_stage_std: matches\n-                .opt_strs(\"keep-stage-std\")\n-                .into_iter()\n-                .map(|j| j.parse().expect(\"`keep-stage-std` should be a number\"))\n-                .collect(),\n-            host: if matches.opt_present(\"host\") {\n-                Some(\n-                    split(&matches.opt_strs(\"host\"))\n-                        .into_iter()\n-                        .map(|x| TargetSelection::from_user(&x))\n-                        .collect::<Vec<_>>(),\n-                )\n-            } else {\n-                None\n-            },\n-            target: if matches.opt_present(\"target\") {\n-                Some(\n-                    split(&matches.opt_strs(\"target\"))\n-                        .into_iter()\n-                        .map(|x| TargetSelection::from_user(&x))\n-                        .collect::<Vec<_>>(),\n-                )\n-            } else {\n-                None\n-            },\n-            config: matches.opt_str(\"config\").map(PathBuf::from),\n-            build_dir: matches.opt_str(\"build-dir\").map(PathBuf::from),\n-            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().expect(\"`jobs` should be a number\")),\n-            cmd,\n-            incremental: matches.opt_present(\"incremental\"),\n-            exclude: split(&matches.opt_strs(\"exclude\"))\n-                .into_iter()\n-                .map(|p| p.into())\n-                .collect::<Vec<_>>(),\n-            include_default_paths: matches.opt_present(\"include-default-paths\"),\n-            deny_warnings: parse_deny_warnings(&matches),\n-            color: matches\n-                .opt_get_default(\"color\", Color::Auto)\n-                .expect(\"`color` should be `always`, `never`, or `auto`\"),\n-            rust_profile_use: matches.opt_str(\"rust-profile-use\"),\n-            rust_profile_generate: matches.opt_str(\"rust-profile-generate\"),\n-            llvm_profile_use: matches.opt_str(\"llvm-profile-use\"),\n-            llvm_profile_generate: matches.opt_present(\"llvm-profile-generate\"),\n-            llvm_bolt_profile_generate: matches.opt_present(\"llvm-bolt-profile-generate\"),\n-            llvm_bolt_profile_use: matches.opt_str(\"llvm-bolt-profile-use\"),\n-            free_args,\n-        }\n-    }\n+        ./x.py setup link\", Profile::all_for_help(\"        \").trim_end()))]\n+    Setup {\n+        /// Either the profile for `config.toml` or another setup action.\n+        /// May be omitted to set up interactively\n+        #[arg(value_name = \"<PROFILE>|hook|vscode|link\")]\n+        profile: Option<PathBuf>,\n+    },\n+    /// Suggest a subset of tests to run, based on modified files\n+    #[clap(long_about = \"\\n\")]\n+    Suggest {\n+        /// run suggested tests\n+        #[arg(long)]\n+        run: bool,\n+    },\n }\n \n impl Subcommand {\n@@ -756,14 +441,22 @@ impl Subcommand {\n \n     pub fn fail_fast(&self) -> bool {\n         match *self {\n-            Subcommand::Test { fail_fast, .. } => fail_fast,\n+            Subcommand::Test { no_fail_fast, .. } => !no_fail_fast,\n             _ => false,\n         }\n     }\n \n     pub fn doc_tests(&self) -> DocTests {\n         match *self {\n-            Subcommand::Test { doc_tests, .. } => doc_tests,\n+            Subcommand::Test { doc, no_doc, .. } => {\n+                if doc {\n+                    DocTests::Only\n+                } else if no_doc {\n+                    DocTests::No\n+                } else {\n+                    DocTests::Yes\n+                }\n+            }\n             _ => DocTests::Yes,\n         }\n     }\n@@ -831,19 +524,3 @@ impl Subcommand {\n         }\n     }\n }\n-\n-fn split(s: &[String]) -> Vec<String> {\n-    s.iter().flat_map(|s| s.split(',')).filter(|s| !s.is_empty()).map(|s| s.to_string()).collect()\n-}\n-\n-fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n-    match matches.opt_str(\"warnings\").as_deref() {\n-        Some(\"deny\") => Some(true),\n-        Some(\"warn\") => Some(false),\n-        Some(value) => {\n-            eprintln!(r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#, value,);\n-            crate::detail_exit(1);\n-        }\n-        None => None,\n-    }\n-}"}, {"sha": "994336977dc6a89f408916e4840eb5cb275455a1", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -660,8 +660,8 @@ impl Build {\n \n         // hardcoded subcommands\n         match &self.config.cmd {\n-            Subcommand::Format { check, paths } => {\n-                return format::format(&builder::Builder::new(&self), *check, &paths);\n+            Subcommand::Format { check } => {\n+                return format::format(&builder::Builder::new(&self), *check, &self.config.paths);\n             }\n             Subcommand::Suggest { run } => {\n                 return suggest::suggest(&builder::Builder::new(&self), *run);"}, {"sha": "854b7f5bd3afa4d3061dd14f70e06a49be1876d9", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70a779cb7d827c0007dde1751d272bfdb58dded5/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=70a779cb7d827c0007dde1751d272bfdb58dded5", "patch": "@@ -1545,7 +1545,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n \n         // Get paths from cmd args\n         let paths = match &builder.config.cmd {\n-            Subcommand::Test { ref paths, .. } => &paths[..],\n+            Subcommand::Test { .. } => &builder.config.paths[..],\n             _ => &[],\n         };\n "}]}