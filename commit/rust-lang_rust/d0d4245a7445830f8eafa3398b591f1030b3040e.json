{"sha": "d0d4245a7445830f8eafa3398b591f1030b3040e", "node_id": "C_kwDOAAsO6NoAKGQwZDQyNDVhNzQ0NTgzMGY4ZWFmYTMzOThiNTkxZjEwMzBiMzA0MGU", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-28T12:29:16Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-28T12:29:16Z"}, "message": "use `FxHashSet` instead of `FxHashMap`", "tree": {"sha": "fd38d3abc896814588b311b2e4c1998e8822ebcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd38d3abc896814588b311b2e4c1998e8822ebcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0d4245a7445830f8eafa3398b591f1030b3040e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d4245a7445830f8eafa3398b591f1030b3040e", "html_url": "https://github.com/rust-lang/rust/commit/d0d4245a7445830f8eafa3398b591f1030b3040e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0d4245a7445830f8eafa3398b591f1030b3040e/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5c7ec499a688d2022244b9bc847add2e700a236", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5c7ec499a688d2022244b9bc847add2e700a236", "html_url": "https://github.com/rust-lang/rust/commit/d5c7ec499a688d2022244b9bc847add2e700a236"}], "stats": {"total": 17, "additions": 7, "deletions": 10}, "files": [{"sha": "39324d27306b31368e78c0b3661860dd9e8640e0", "filename": "crates/hir-ty/src/inhabitedness.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d0d4245a7445830f8eafa3398b591f1030b3040e/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0d4245a7445830f8eafa3398b591f1030b3040e/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=d0d4245a7445830f8eafa3398b591f1030b3040e", "patch": "@@ -1,8 +1,5 @@\n //! Type inhabitedness logic.\n-use std::{\n-    collections::HashMap,\n-    ops::ControlFlow::{self, Break, Continue},\n-};\n+use std::ops::ControlFlow::{self, Break, Continue};\n \n use chalk_ir::{\n     visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n@@ -12,7 +9,7 @@ use hir_def::{\n     adt::VariantData, attr::Attrs, visibility::Visibility, AdtId, EnumVariantId, HasModule, Lookup,\n     ModuleId, VariantId,\n };\n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n \n use crate::{\n     consteval::try_const_usize, db::HirDatabase, Binders, Interner, Substitution, Ty, TyKind,\n@@ -21,7 +18,7 @@ use crate::{\n /// Checks whether a type is visibly uninhabited from a particular module.\n pub(crate) fn is_ty_uninhabited_from(ty: &Ty, target_mod: ModuleId, db: &dyn HirDatabase) -> bool {\n     let mut uninhabited_from =\n-        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: HashMap::default() };\n+        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: FxHashSet::default() };\n     let inhabitedness = ty.visit_with(&mut uninhabited_from, DebruijnIndex::INNERMOST);\n     inhabitedness == BREAK_VISIBLY_UNINHABITED\n }\n@@ -38,7 +35,7 @@ pub(crate) fn is_enum_variant_uninhabited_from(\n     let is_local = variant.parent.lookup(db.upcast()).container.krate() == target_mod.krate();\n \n     let mut uninhabited_from =\n-        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: HashMap::default() };\n+        UninhabitedFrom { target_mod, db, max_depth: 500, recursive_ty: FxHashSet::default() };\n     let inhabitedness = uninhabited_from.visit_variant(\n         variant.into(),\n         &enum_data.variants[variant.local_id].variant_data,\n@@ -51,7 +48,7 @@ pub(crate) fn is_enum_variant_uninhabited_from(\n \n struct UninhabitedFrom<'a> {\n     target_mod: ModuleId,\n-    recursive_ty: FxHashMap<Ty, ()>,\n+    recursive_ty: FxHashSet<Ty>,\n     // guard for preventing stack overflow in non trivial non terminating types\n     max_depth: usize,\n     db: &'a dyn HirDatabase,\n@@ -74,12 +71,12 @@ impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n         ty: &Ty,\n         outer_binder: DebruijnIndex,\n     ) -> ControlFlow<VisiblyUninhabited> {\n-        if self.recursive_ty.contains_key(ty) || self.max_depth == 0 {\n+        if self.recursive_ty.contains(ty) || self.max_depth == 0 {\n             // rustc considers recursive types always inhabited. I think it is valid to consider\n             // recursive types as always uninhabited, but we should do what rustc is doing.\n             return CONTINUE_OPAQUELY_INHABITED;\n         }\n-        self.recursive_ty.insert(ty.clone(), ());\n+        self.recursive_ty.insert(ty.clone());\n         self.max_depth -= 1;\n         let r = match ty.kind(Interner) {\n             TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),"}]}