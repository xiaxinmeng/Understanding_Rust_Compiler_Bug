{"sha": "d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZGExZDliNDZmNzA5MGIxOGJlMzU3YmVmOGQ1NWZmYTM2NzNkMmY=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-22T00:42:23Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-03-22T16:19:52Z"}, "message": "Various fixes to wording consistency in the docs", "tree": {"sha": "b1af890ad3f0728432eec3c8049e20789b7eb75d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1af890ad3f0728432eec3c8049e20789b7eb75d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "html_url": "https://github.com/rust-lang/rust/commit/d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/comments", "author": null, "committer": null, "parents": [{"sha": "cab4bff3de1a61472f3c2e7752ef54b87344d1c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab4bff3de1a61472f3c2e7752ef54b87344d1c9", "html_url": "https://github.com/rust-lang/rust/commit/cab4bff3de1a61472f3c2e7752ef54b87344d1c9"}], "stats": {"total": 123, "additions": 61, "deletions": 62}, "files": [{"sha": "efa96ca468e0143e23a6e0ef73dd4e6d6979a191", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -930,13 +930,13 @@ impl<'a, T> Hole<'a, T> {\n         self.pos\n     }\n \n-    /// Return a reference to the element removed\n+    /// Returns a reference to the element removed.\n     #[inline]\n     fn element(&self) -> &T {\n         self.elt.as_ref().unwrap()\n     }\n \n-    /// Return a reference to the element at `index`.\n+    /// Returns a reference to the element at `index`.\n     ///\n     /// Unsafe because index must be within the data slice and not equal to pos.\n     #[inline]"}, {"sha": "bed216ba3d111b83dd10fac0657854d2de7c08b1", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -526,7 +526,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         }\n     }\n \n-    /// Returns true if the map contains a value for the specified key.\n+    /// Returns `true` if the map contains a value for the specified key.\n     ///\n     /// The key may be any borrowed form of the map's key type, but the ordering\n     /// on the borrowed form *must* match the ordering on the key type.\n@@ -1965,7 +1965,7 @@ impl<K, V> BTreeMap<K, V> {\n         self.length\n     }\n \n-    /// Returns true if the map contains no elements.\n+    /// Returns `true` if the map contains no elements.\n     ///\n     /// # Examples\n     ///"}, {"sha": "9dbb61379379e9177145482ee3267c1c658c25db", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -415,7 +415,7 @@ impl<T: Ord> BTreeSet<T> {\n         self.map.len()\n     }\n \n-    /// Returns true if the set contains no elements.\n+    /// Returns `true` if the set contains no elements.\n     ///\n     /// # Examples\n     ///"}, {"sha": "e56b94b2e1ea296d7c8531a647f2959b2c553bc9", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -106,7 +106,7 @@ impl<E: CLike> EnumSet<E> {\n         self.bits.count_ones() as usize\n     }\n \n-    /// Returns true if the `EnumSet` is empty.\n+    /// Returns `true` if the `EnumSet` is empty.\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n     }"}, {"sha": "d10ca087f93e7347b25ef06530802d73246d8afd", "filename": "src/libcollections/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Frange.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -20,9 +20,9 @@ use Bound::{self, Excluded, Included, Unbounded};\n /// **RangeArgument** is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b` or `c..d`.\n pub trait RangeArgument<T: ?Sized> {\n-    /// Start index bound\n+    /// Start index bound.\n     ///\n-    /// Return start value as a `Bound`\n+    /// Returns start value as a `Bound`.\n     ///\n     /// # Examples\n     ///\n@@ -42,9 +42,9 @@ pub trait RangeArgument<T: ?Sized> {\n     /// ```\n     fn start(&self) -> Bound<&T>;\n \n-    /// End index bound\n+    /// End index bound.\n     ///\n-    /// Return end value as a `Bound`\n+    /// Returns end value as a `Bound`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "d3723ace9efb332f4349be1bf37e62b3878cf55c", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -195,7 +195,7 @@ impl<T> [T] {\n         core_slice::SliceExt::is_empty(self)\n     }\n \n-    /// Returns the first element of a slice, or `None` if it is empty.\n+    /// Returns the first element of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -212,7 +212,7 @@ impl<T> [T] {\n         core_slice::SliceExt::first(self)\n     }\n \n-    /// Returns a mutable pointer to the first element of a slice, or `None` if it is empty.\n+    /// Returns a mutable pointer to the first element of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -230,7 +230,7 @@ impl<T> [T] {\n         core_slice::SliceExt::first_mut(self)\n     }\n \n-    /// Returns the first and all the rest of the elements of a slice, or `None` if it is empty.\n+    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -248,7 +248,7 @@ impl<T> [T] {\n         core_slice::SliceExt::split_first(self)\n     }\n \n-    /// Returns the first and all the rest of the elements of a slice, or `None` if it is empty.\n+    /// Returns the first and all the rest of the elements of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -268,7 +268,7 @@ impl<T> [T] {\n         core_slice::SliceExt::split_first_mut(self)\n     }\n \n-    /// Returns the last and all the rest of the elements of a slice, or `None` if it is empty.\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -287,7 +287,7 @@ impl<T> [T] {\n \n     }\n \n-    /// Returns the last and all the rest of the elements of a slice, or `None` if it is empty.\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -307,7 +307,7 @@ impl<T> [T] {\n         core_slice::SliceExt::split_last_mut(self)\n     }\n \n-    /// Returns the last element of a slice, or `None` if it is empty.\n+    /// Returns the last element of the slice, or `None` if it is empty.\n     ///\n     /// # Examples\n     ///\n@@ -485,7 +485,7 @@ impl<T> [T] {\n         core_slice::SliceExt::as_mut_ptr(self)\n     }\n \n-    /// Swaps two elements in a slice.\n+    /// Swaps two elements in the slice.\n     ///\n     /// # Arguments\n     ///\n@@ -509,7 +509,7 @@ impl<T> [T] {\n         core_slice::SliceExt::swap(self, a, b)\n     }\n \n-    /// Reverses the order of elements in a slice, in place.\n+    /// Reverses the order of elements in the slice, in place.\n     ///\n     /// # Example\n     ///\n@@ -955,7 +955,7 @@ impl<T> [T] {\n         core_slice::SliceExt::ends_with(self, needle)\n     }\n \n-    /// Binary search a sorted slice for a given element.\n+    /// Binary searches this sorted slice for a given element.\n     ///\n     /// If the value is found then `Ok` is returned, containing the\n     /// index of the matching element; if the value is not found then\n@@ -984,7 +984,7 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search(self, x)\n     }\n \n-    /// Binary search a sorted slice with a comparator function.\n+    /// Binary searches this sorted slice with a comparator function.\n     ///\n     /// The comparator function should implement an order consistent\n     /// with the sort order of the underlying slice, returning an\n@@ -1023,7 +1023,7 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n-    /// Binary search a sorted slice with a key extraction function.\n+    /// Binary searches this sorted slice with a key extraction function.\n     ///\n     /// Assumes that the slice is sorted by the key, for instance with\n     /// [`sort_by_key`] using the same key extraction function.\n@@ -1092,7 +1092,7 @@ impl<T> [T] {\n         merge_sort(self, |a, b| a.lt(b));\n     }\n \n-    /// Sorts the slice using `compare` to compare elements.\n+    /// Sorts the slice with a comparator function.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n@@ -1125,7 +1125,7 @@ impl<T> [T] {\n         merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n \n-    /// Sorts the slice using `f` to extract a key to compare elements by.\n+    /// Sorts the slice with a key extraction function.\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n@@ -1191,8 +1191,8 @@ impl<T> [T] {\n         core_slice::SliceExt::sort_unstable(self);\n     }\n \n-    /// Sorts the slice using `compare` to compare elements, but may not preserve the order of\n-    /// equal elements.\n+    /// Sorts the slice with a comparator function, but may not preserve the order of equal\n+    /// elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n     /// and `O(n log n)` worst-case.\n@@ -1231,8 +1231,8 @@ impl<T> [T] {\n         core_slice::SliceExt::sort_unstable_by(self, compare);\n     }\n \n-    /// Sorts the slice using `f` to extract a key to compare elements by, but may not preserve the\n-    /// order of equal elements.\n+    /// Sorts the slice with a key extraction function, but may not preserve the order of equal\n+    /// elements.\n     ///\n     /// This sort is unstable (i.e. may reorder equal elements), in-place (i.e. does not allocate),\n     /// and `O(n log n)` worst-case.\n@@ -1313,7 +1313,6 @@ impl<T> [T] {\n         core_slice::SliceExt::copy_from_slice(self, src)\n     }\n \n-\n     /// Copies `self` into a new `Vec`.\n     ///\n     /// # Examples"}, {"sha": "8abc9ca7e9fe87b19ee29c632480122bda4a7853", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -204,7 +204,7 @@ impl str {\n         core_str::StrExt::len(self)\n     }\n \n-    /// Returns true if this slice has a length of zero bytes.\n+    /// Returns `true` if `self` has a length of zero bytes.\n     ///\n     /// # Examples\n     ///"}, {"sha": "cb92236ec736cf8928f92da43e8efb5921d7feea", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -133,7 +133,7 @@ impl<T> VecDeque<T> {\n         ptr::write(self.ptr().offset(off as isize), value);\n     }\n \n-    /// Returns true if and only if the buffer is at capacity\n+    /// Returns `true` if and only if the buffer is at full capacity.\n     #[inline]\n     fn is_full(&self) -> bool {\n         self.cap() - self.len() == 1\n@@ -788,7 +788,7 @@ impl<T> VecDeque<T> {\n         count(self.tail, self.head, self.cap())\n     }\n \n-    /// Returns true if the buffer contains no elements\n+    /// Returns `true` if the `VecDeque` is empty.\n     ///\n     /// # Examples\n     ///"}, {"sha": "338e5c7fd95b47a07d7e780b3af976e6922830c5", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -137,7 +137,7 @@ impl fmt::Debug for Any + Send {\n }\n \n impl Any {\n-    /// Returns true if the boxed type is the same as `T`.\n+    /// Returns `true` if the boxed type is the same as `T`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "7db35359a1f7d427433a69d9a100f8a5587bfc1b", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -210,7 +210,7 @@ pub enum Ordering {\n }\n \n impl Ordering {\n-    /// Reverse the `Ordering`.\n+    /// Reverses the `Ordering`.\n     ///\n     /// * `Less` becomes `Greater`.\n     /// * `Greater` becomes `Less`.\n@@ -616,7 +616,7 @@ pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {\n     }\n }\n \n-/// Compare and return the minimum of two values.\n+/// Compares and returns the minimum of two values.\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n ///\n@@ -634,7 +634,7 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     if v1 <= v2 { v1 } else { v2 }\n }\n \n-/// Compare and return the maximum of two values.\n+/// Compares and returns the maximum of two values.\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n ///"}, {"sha": "c4d54d2c7b81df6abb3adad2670d8afaf8f2003d", "filename": "src/libcore/iter_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fiter_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fiter_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter_private.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -22,7 +22,7 @@\n #[doc(hidden)]\n pub unsafe trait TrustedRandomAccess : ExactSizeIterator {\n     unsafe fn get_unchecked(&mut self, i: usize) -> Self::Item;\n-    /// Return `true` if getting an iterator element may have\n+    /// Returns `true` if getting an iterator element may have\n     /// side effects. Remember to take inner iterators into account.\n     fn may_have_side_effect() -> bool;\n }"}, {"sha": "8904322ca48f77b01db9b8a9bbbafe19c02438f7", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -148,14 +148,14 @@ macro_rules! define_bignum {\n                 $name { size: sz, base: base }\n             }\n \n-            /// Return the internal digits as a slice `[a, b, c, ...]` such that the numeric\n+            /// Returns the internal digits as a slice `[a, b, c, ...]` such that the numeric\n             /// value is `a + b * 2^W + c * 2^(2W) + ...` where `W` is the number of bits in\n             /// the digit type.\n             pub fn digits(&self) -> &[$ty] {\n                 &self.base[..self.size]\n             }\n \n-            /// Return the `i`-th bit where bit 0 is the least significant one.\n+            /// Returns the `i`-th bit where bit 0 is the least significant one.\n             /// In other words, the bit with weight `2^i`.\n             pub fn get_bit(&self, i: usize) -> u8 {\n                 use mem;\n@@ -166,7 +166,7 @@ macro_rules! define_bignum {\n                 ((self.base[d] >> b) & 1) as u8\n             }\n \n-            /// Returns true if the bignum is zero.\n+            /// Returns `true` if the bignum is zero.\n             pub fn is_zero(&self) -> bool {\n                 self.digits().iter().all(|&v| v == 0)\n             }"}, {"sha": "df343c9d45f20ffa64a47ecb01f6c4af0d6071f3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -2568,17 +2568,17 @@ pub trait Float: Sized {\n                                  implementable outside the standard library\")]\n     fn one() -> Self;\n \n-    /// Returns true if this value is NaN and false otherwise.\n+    /// Returns `true` if this value is NaN and false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_nan(self) -> bool;\n-    /// Returns true if this value is positive infinity or negative infinity and\n+    /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_infinite(self) -> bool;\n-    /// Returns true if this number is neither infinite nor NaN.\n+    /// Returns `true` if this number is neither infinite nor NaN.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_finite(self) -> bool;\n-    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    /// Returns `true` if this number is neither zero, infinite, denormal, or NaN.\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into."}, {"sha": "d2830a6d00cec149ba22e64c98db7de2ce23d63c", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -380,7 +380,7 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n \n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n-    /// Returns true if the pointer is null.\n+    /// Returns `true` if the pointer is null.\n     ///\n     /// # Examples\n     ///\n@@ -504,7 +504,7 @@ impl<T: ?Sized> *const T {\n \n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n-    /// Returns true if the pointer is null.\n+    /// Returns `true` if the pointer is null.\n     ///\n     /// # Examples\n     ///"}, {"sha": "6ec8a37dfa4330042e62996c4b956f1a3b75a770", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -268,7 +268,7 @@ impl<T, E> Result<T, E> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns true if the result is `Ok`.\n+    /// Returns `true` if the result is `Ok`.\n     ///\n     /// # Examples\n     ///\n@@ -290,7 +290,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns true if the result is `Err`.\n+    /// Returns `true` if the result is `Err`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "af492b3c63976089744aade562e703545c5b2e1b", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -1511,15 +1511,15 @@ fn ptrdistance<T>(start: *const T, end: *const T) -> usize {\n trait PointerExt : Copy {\n     unsafe fn slice_offset(self, i: isize) -> Self;\n \n-    /// Increment self by 1, but return the old value\n+    /// Increments `self` by 1, but returns the old value.\n     #[inline(always)]\n     unsafe fn post_inc(&mut self) -> Self {\n         let current = *self;\n         *self = self.slice_offset(1);\n         current\n     }\n \n-    /// Decrement self by 1, and return the new value\n+    /// Decrements `self` by 1, and returns the new value.\n     #[inline(always)]\n     unsafe fn pre_dec(&mut self) -> Self {\n         *self = self.slice_offset(-1);\n@@ -1545,7 +1545,7 @@ impl<T> PointerExt for *mut T {\n /// splitn, splitn_mut etc can be implemented once.\n #[doc(hidden)]\n trait SplitIter: DoubleEndedIterator {\n-    /// Mark the underlying iterator as complete, extracting the remaining\n+    /// Marks the underlying iterator as complete, extracting the remaining\n     /// portion of the slice.\n     fn finish(&mut self) -> Option<Self::Item>;\n }\n@@ -2267,11 +2267,11 @@ pub fn heapsort<T, F>(v: &mut [T], mut is_less: F)\n //\n \n extern {\n-    /// Call implementation provided memcmp\n+    /// Calls implementation provided memcmp.\n     ///\n     /// Interprets the data as u8.\n     ///\n-    /// Return 0 for equal, < 0 for less than and > 0 for greater\n+    /// Returns 0 for equal, < 0 for less than and > 0 for greater\n     /// than.\n     // FIXME(#32610): Return type should be c_int\n     fn memcmp(s1: *const u8, s2: *const u8, n: usize) -> i32;"}, {"sha": "d13d537d99301781dd6aa246c4008d529354e320", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -104,7 +104,7 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n \n /// Partially sorts a slice by shifting several out-of-order elements around.\n ///\n-/// Returns true if the slice is sorted at the end. This function is `O(n)` worst-case.\n+/// Returns `true` if the slice is sorted at the end. This function is `O(n)` worst-case.\n #[cold]\n fn partial_insertion_sort<T, F>(v: &mut [T], is_less: &mut F) -> bool\n     where F: FnMut(&T, &T) -> bool\n@@ -528,7 +528,7 @@ fn break_patterns<T>(v: &mut [T]) {\n     }\n }\n \n-/// Chooses a pivot in `v` and returns the index and true if the slice is likely already sorted.\n+/// Chooses a pivot in `v` and returns the index and `true` if the slice is likely already sorted.\n ///\n /// Elements in `v` might be reordered in the process.\n fn choose_pivot<T, F>(v: &mut [T], is_less: &mut F) -> (usize, bool)"}, {"sha": "1efd8137fa316fcc8b8f95ec91fdaba7f69128b2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6da1d9b46f7090b18be357bef8d55ffa3673d2f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=d6da1d9b46f7090b18be357bef8d55ffa3673d2f", "patch": "@@ -343,13 +343,13 @@ pub struct Chars<'a> {\n     iter: slice::Iter<'a, u8>\n }\n \n-/// Return the initial codepoint accumulator for the first byte.\n+/// Returns the initial codepoint accumulator for the first byte.\n /// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n /// for width 3, and 3 bits for width 4.\n #[inline]\n fn utf8_first_byte(byte: u8, width: u32) -> u32 { (byte & (0x7F >> width)) as u32 }\n \n-/// Return the value of `ch` updated with continuation byte `byte`.\n+/// Returns the value of `ch` updated with continuation byte `byte`.\n #[inline]\n fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 { (ch << 6) | (byte & CONT_MASK) as u32 }\n \n@@ -1244,13 +1244,13 @@ Section: UTF-8 validation\n // use truncation to fit u64 into usize\n const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n \n-/// Return `true` if any byte in the word `x` is nonascii (>= 128).\n+/// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n #[inline]\n fn contains_nonascii(x: usize) -> bool {\n     (x & NONASCII_MASK) != 0\n }\n \n-/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n+/// Walks through `iter` checking that it's a valid UTF-8 sequence,\n /// returning `true` in that case, or, if it is invalid, `false` with\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n@@ -1389,16 +1389,16 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n 4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n ];\n \n-/// Given a first byte, determine how many bytes are in this UTF-8 character\n+/// Given a first byte, determines how many bytes are in this UTF-8 character.\n #[unstable(feature = \"str_internals\", issue = \"0\")]\n #[inline]\n pub fn utf8_char_width(b: u8) -> usize {\n     return UTF8_CHAR_WIDTH[b as usize] as usize;\n }\n \n-/// Mask of the value bits of a continuation byte\n+/// Mask of the value bits of a continuation byte.\n const CONT_MASK: u8 = 0b0011_1111;\n-/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte\n+/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\n const TAG_CONT_U8: u8 = 0b1000_0000;\n \n /*"}]}