{"sha": "413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "node_id": "C_kwDOAAsO6NoAKDQxM2Y0OTA2NzdkN2Q1OGU2ZDNhMTRjOWZjNWQ5YmUxMWU1ZDY2OGQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-20T16:10:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-20T16:10:34Z"}, "message": "Rollup merge of #92183 - tmandry:issue-74256, r=estebank\n\nPoint at correct argument when async fn output type lifetime disagrees with signature\n\nFixes most of #74256.\n\n## Problems fixed\n\nThis PR fixes a couple of related problems in the error reporting code.\n\n### Highlighting the wrong argument\n\nFirst, the error reporting code was looking at the desugared return type of an `async fn` to decide which parameter to highlight. For example, a function like\n\n```rust\nasync fn async_fn(self: &Struct, f: &u32) -> &u32\n{ f }\n```\n\ndesugars to\n\n```rust\nasync fn async_fn<'a, 'b>(self: &'a Struct, f: &'b u32)\n-> impl Future<Output = &'a u32> + 'a + 'b\n{ f }\n```\n\nSince `f: &'b u32` is returned but the output type is `&'a u32`, the error would occur when checking that `'a: 'b`.\n\nThe reporting code would look to see if the \"offending\" lifetime `'b` was included in the return type, and because the code was looking at the desugared future type, it was included. So it defaulted to reporting that the source of the other lifetime `'a` (the `self` type) was the problem, when it was really the type of `f`. (Note that if it had chosen instead to look at `'a` first, it too would have been included in the output type, and it would have arbitrarily reported the error (correctly this time) on the type of `f`.)\n\nLooking at the actual future type isn't useful for this reason; it captures all input lifetimes. Using the written return type for `async fn` solves this problem and results in less confusing error messages for the user.\n\nThis isn't a perfect fix, unfortunately; writing the \"manually desugared\" form of the above function still results in the wrong parameter being highlighted. Looking at the output type of every `impl Future` return type doesn't feel like a very principled approach, though it might work. The problem would remain for function signatures that look like the desugared one above but use different traits. There may be deeper changes required to pinpoint which part of each type is conflicting.\n\n### Lying about await point capture causing lifetime conflicts\n\nThe second issue fixed by this PR is the unnecessary complexity in `try_report_anon_anon_conflict`. It turns out that the root cause I suggested in https://github.com/rust-lang/rust/issues/76547#issuecomment-692863608 wasn't really the root cause. Adding special handling to report that a variable was captured over an await point only made the error messages less correct and pointed to a problem other than the one that actually occurred.\n\nGiven the above discussion, it's easy to see why: `async fn`s capture all input lifetimes in their return type, so holding an argument across an await point should never cause a lifetime conflict! Removing the special handling simplified the code and improved the error messages (though they still aren't very good!)\n\n## Future work\n\n* Fix error reporting on the \"desugared\" form of this code\n* Get the `suggest_adding_lifetime_params` suggestion firing on these examples\n  * cc #42703, I think\n\nr? `@estebank`", "tree": {"sha": "4327d1f3b5944d0d2bdad7313ec83946cd92cd9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4327d1f3b5944d0d2bdad7313ec83946cd92cd9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6Yl6CRBK7hj4Ov3rIwAAdCEIABFhTekMtKZgrZNr3xdJTEei\nvCIkpUbWvrRwYd3KpVB2u5gu3jhKHyMCeDeGJbXMlkqZAnWh32v8qHp4DehEYef+\nn41iZ9uQraiEAWQz/BJAx48zwU7a4iZkTOSRQ+0MeUcrxYOfHtjkjS/Xs6ZC+FtC\nUp6W0ffZJ2A1QPseM/FqjJMYX2PQN1bXDChCIzI1nrCQIc5CAVmbN7f2jl8vijnA\nVbtvebUXaztONefyEVSBLA0ivyVzt7JyaMmoiUrvke/DzeCpL/Qo620cUNI5cRcZ\nYw61FUe6h49ErnZI6LDdqH9Pxcm1ErH4qofUoSBoB9XHf5DVu45AYO7zh4HnLZk=\n=vspW\n-----END PGP SIGNATURE-----\n", "payload": "tree 4327d1f3b5944d0d2bdad7313ec83946cd92cd9e\nparent 405cf2044210f5f2286d6b526882744d403ea805\nparent 698631e16c390c29bacc778e35aba1dc27bed57f\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642695034 +0100\ncommitter GitHub <noreply@github.com> 1642695034 +0100\n\nRollup merge of #92183 - tmandry:issue-74256, r=estebank\n\nPoint at correct argument when async fn output type lifetime disagrees with signature\n\nFixes most of #74256.\n\n## Problems fixed\n\nThis PR fixes a couple of related problems in the error reporting code.\n\n### Highlighting the wrong argument\n\nFirst, the error reporting code was looking at the desugared return type of an `async fn` to decide which parameter to highlight. For example, a function like\n\n```rust\nasync fn async_fn(self: &Struct, f: &u32) -> &u32\n{ f }\n```\n\ndesugars to\n\n```rust\nasync fn async_fn<'a, 'b>(self: &'a Struct, f: &'b u32)\n-> impl Future<Output = &'a u32> + 'a + 'b\n{ f }\n```\n\nSince `f: &'b u32` is returned but the output type is `&'a u32`, the error would occur when checking that `'a: 'b`.\n\nThe reporting code would look to see if the \"offending\" lifetime `'b` was included in the return type, and because the code was looking at the desugared future type, it was included. So it defaulted to reporting that the source of the other lifetime `'a` (the `self` type) was the problem, when it was really the type of `f`. (Note that if it had chosen instead to look at `'a` first, it too would have been included in the output type, and it would have arbitrarily reported the error (correctly this time) on the type of `f`.)\n\nLooking at the actual future type isn't useful for this reason; it captures all input lifetimes. Using the written return type for `async fn` solves this problem and results in less confusing error messages for the user.\n\nThis isn't a perfect fix, unfortunately; writing the \"manually desugared\" form of the above function still results in the wrong parameter being highlighted. Looking at the output type of every `impl Future` return type doesn't feel like a very principled approach, though it might work. The problem would remain for function signatures that look like the desugared one above but use different traits. There may be deeper changes required to pinpoint which part of each type is conflicting.\n\n### Lying about await point capture causing lifetime conflicts\n\nThe second issue fixed by this PR is the unnecessary complexity in `try_report_anon_anon_conflict`. It turns out that the root cause I suggested in https://github.com/rust-lang/rust/issues/76547#issuecomment-692863608 wasn't really the root cause. Adding special handling to report that a variable was captured over an await point only made the error messages less correct and pointed to a problem other than the one that actually occurred.\n\nGiven the above discussion, it's easy to see why: `async fn`s capture all input lifetimes in their return type, so holding an argument across an await point should never cause a lifetime conflict! Removing the special handling simplified the code and improved the error messages (though they still aren't very good!)\n\n## Future work\n\n* Fix error reporting on the \"desugared\" form of this code\n* Get the `suggest_adding_lifetime_params` suggestion firing on these examples\n  * cc #42703, I think\n\nr? `@estebank`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "html_url": "https://github.com/rust-lang/rust/commit/413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "405cf2044210f5f2286d6b526882744d403ea805", "url": "https://api.github.com/repos/rust-lang/rust/commits/405cf2044210f5f2286d6b526882744d403ea805", "html_url": "https://github.com/rust-lang/rust/commit/405cf2044210f5f2286d6b526882744d403ea805"}, {"sha": "698631e16c390c29bacc778e35aba1dc27bed57f", "url": "https://api.github.com/repos/rust-lang/rust/commits/698631e16c390c29bacc778e35aba1dc27bed57f", "html_url": "https://github.com/rust-lang/rust/commit/698631e16c390c29bacc778e35aba1dc27bed57f"}], "stats": {"total": 594, "additions": 244, "deletions": 350}, "files": [{"sha": "a9dbdd483fe6f7c3bd2f6bf61b09eb57febcde2e", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2726,6 +2726,10 @@ pub struct FnHeader {\n }\n \n impl FnHeader {\n+    pub fn is_async(&self) -> bool {\n+        matches!(&self.asyncness, IsAsync::Async)\n+    }\n+\n     pub fn is_const(&self) -> bool {\n         matches!(&self.constness, Constness::Const)\n     }\n@@ -3169,7 +3173,7 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n-    pub fn fn_decl(&self) -> Option<&FnDecl<'hir>> {\n+    pub fn fn_decl(&self) -> Option<&'hir FnDecl<'hir>> {\n         match self {\n             Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n             | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n@@ -3181,6 +3185,15 @@ impl<'hir> Node<'hir> {\n         }\n     }\n \n+    pub fn fn_sig(&self) -> Option<&'hir FnSig<'hir>> {\n+        match self {\n+            Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n+            | Node::Item(Item { kind: ItemKind::Fn(fn_sig, _, _), .. }) => Some(fn_sig),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn body_id(&self) -> Option<BodyId> {\n         match self {\n             Node::TraitItem(TraitItem {"}, {"sha": "14ab635a2ae2b05cac26898141ca96f21fd42b83", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -65,11 +65,11 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::dep_graph::DepContext;\n-use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::{\n     self,\n+    error::TypeError,\n     subst::{GenericArgKind, Subst, SubstsRef},\n-    Region, Ty, TyCtxt, TypeFoldable,\n+    Binder, Region, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::{sym, BytePos, DesugaringKind, MultiSpan, Pos, Span};\n use rustc_target::spec::abi;\n@@ -1765,7 +1765,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found, terr);\n     }\n \n-    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         if let ty::Opaque(def_id, substs) = ty.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n             // Future::Output\n@@ -1775,13 +1775,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             for (predicate, _) in bounds {\n                 let predicate = predicate.subst(self.tcx, substs);\n-                if let ty::PredicateKind::Projection(projection_predicate) =\n-                    predicate.kind().skip_binder()\n-                {\n-                    if projection_predicate.projection_ty.item_def_id == item_def_id {\n-                        // We don't account for multiple `Future::Output = Ty` contraints.\n-                        return projection_predicate.term.ty();\n-                    }\n+                let output = predicate\n+                    .kind()\n+                    .map_bound(|kind| match kind {\n+                        ty::PredicateKind::Projection(projection_predicate)\n+                            if projection_predicate.projection_ty.item_def_id == item_def_id =>\n+                        {\n+                            projection_predicate.term.ty()\n+                        }\n+                        _ => None,\n+                    })\n+                    .transpose();\n+                if output.is_some() {\n+                    // We don't account for multiple `Future::Output = Ty` contraints.\n+                    return output;\n                 }\n             }\n         }\n@@ -1823,8 +1830,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         match (\n-            self.get_impl_future_output_ty(exp_found.expected),\n-            self.get_impl_future_output_ty(exp_found.found),\n+            self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n+            self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n         ) {\n             (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match cause.code() {\n                 ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {"}, {"sha": "4eec492b3aeb9d4b7c2d9ac3e64a1322e6b50462", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 33, "deletions": 76, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -106,90 +106,47 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             None => String::new(),\n         };\n \n-        let (span_1, span_2, main_label, span_label, future_return_type) =\n-            match (sup_is_ret_type, sub_is_ret_type) {\n-                (None, None) => {\n-                    let (main_label_1, span_label_1) = if ty_sup.hir_id == ty_sub.hir_id {\n-                        (\n-                            \"this type is declared with multiple lifetimes...\".to_owned(),\n-                            \"...but data with one lifetime flows into the other here\".to_owned(),\n-                        )\n-                    } else {\n-                        (\n-                            \"these two types are declared with different lifetimes...\".to_owned(),\n-                            format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n-                        )\n-                    };\n-                    (ty_sup.span, ty_sub.span, main_label_1, span_label_1, None)\n-                }\n+        debug!(\n+            \"try_report_anon_anon_conflict: sub_is_ret_type={:?} sup_is_ret_type={:?}\",\n+            sub_is_ret_type, sup_is_ret_type\n+        );\n \n-                (Some(ret_span), _) => {\n-                    let sup_future = self.future_return_type(scope_def_id_sup);\n-                    let (return_type, action) = if sup_future.is_some() {\n-                        (\"returned future\", \"held across an await point\")\n-                    } else {\n-                        (\"return type\", \"returned\")\n-                    };\n+        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n \n-                    (\n-                        ty_sub.span,\n-                        ret_span,\n-                        format!(\n-                            \"this parameter and the {} are declared with different lifetimes...\",\n-                            return_type\n-                        ),\n-                        format!(\"...but data{} is {} here\", span_label_var1, action),\n-                        sup_future,\n-                    )\n-                }\n-                (_, Some(ret_span)) => {\n-                    let sub_future = self.future_return_type(scope_def_id_sub);\n-                    let (return_type, action) = if sub_future.is_some() {\n-                        (\"returned future\", \"held across an await point\")\n-                    } else {\n-                        (\"return type\", \"returned\")\n-                    };\n+        match (sup_is_ret_type, sub_is_ret_type) {\n+            (ret_capture @ Some(ret_span), _) | (_, ret_capture @ Some(ret_span)) => {\n+                let param_span =\n+                    if sup_is_ret_type == ret_capture { ty_sub.span } else { ty_sup.span };\n+\n+                err.span_label(\n+                    param_span,\n+                    \"this parameter and the return type are declared with different lifetimes...\",\n+                );\n+                err.span_label(ret_span, \"\");\n+                err.span_label(span, format!(\"...but data{} is returned here\", span_label_var1));\n+            }\n \n-                    (\n+            (None, None) => {\n+                if ty_sup.hir_id == ty_sub.hir_id {\n+                    err.span_label(ty_sup.span, \"this type is declared with multiple lifetimes...\");\n+                    err.span_label(ty_sub.span, \"\");\n+                    err.span_label(span, \"...but data with one lifetime flows into the other here\");\n+                } else {\n+                    err.span_label(\n                         ty_sup.span,\n-                        ret_span,\n-                        format!(\n-                            \"this parameter and the {} are declared with different lifetimes...\",\n-                            return_type\n-                        ),\n-                        format!(\"...but data{} is {} here\", span_label_var1, action),\n-                        sub_future,\n-                    )\n+                        \"these two types are declared with different lifetimes...\",\n+                    );\n+                    err.span_label(ty_sub.span, \"\");\n+                    err.span_label(\n+                        span,\n+                        format!(\"...but data{} flows{} here\", span_label_var1, span_label_var2),\n+                    );\n                 }\n-            };\n-\n-        let mut err = struct_span_err!(self.tcx().sess, span, E0623, \"lifetime mismatch\");\n-\n-        err.span_label(span_1, main_label);\n-        err.span_label(span_2, String::new());\n-        err.span_label(span, span_label);\n+            }\n+        }\n \n         self.suggest_adding_lifetime_params(sub, ty_sup, ty_sub, &mut err);\n \n-        if let Some(t) = future_return_type {\n-            let snip = self\n-                .tcx()\n-                .sess\n-                .source_map()\n-                .span_to_snippet(t.span)\n-                .ok()\n-                .and_then(|s| match (&t.kind, s.as_str()) {\n-                    (rustc_hir::TyKind::Tup(&[]), \"\") => Some(\"()\".to_string()),\n-                    (_, \"\") => None,\n-                    _ => Some(s),\n-                })\n-                .unwrap_or_else(|| \"{unnamed_type}\".to_string());\n-\n-            err.span_label(\n-                t.span,\n-                &format!(\"this `async fn` implicitly returns an `impl Future<Output = {}>`\", snip),\n-            );\n-        }\n         err.emit();\n         Some(ErrorReported)\n     }"}, {"sha": "b1535701bb399dc86fbda3a1f0c57c1a3b63e75e", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -1,6 +1,5 @@\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime as rl;\n@@ -25,25 +24,19 @@ pub(crate) fn find_anon_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     region: Region<'tcx>,\n     br: &ty::BoundRegionKind,\n-) -> Option<(&'tcx hir::Ty<'tcx>, &'tcx hir::FnDecl<'tcx>)> {\n+) -> Option<(&'tcx hir::Ty<'tcx>, &'tcx hir::FnSig<'tcx>)> {\n     if let Some(anon_reg) = tcx.is_suitable_region(region) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(anon_reg.def_id);\n-        let fndecl = match tcx.hir().get(hir_id) {\n-            Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n-            | Node::TraitItem(&hir::TraitItem {\n-                kind: hir::TraitItemKind::Fn(ref m, ..), ..\n-            })\n-            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(ref m, ..), .. }) => {\n-                &m.decl\n-            }\n-            _ => return None,\n+        let Some(fn_sig) = tcx.hir().get(hir_id).fn_sig() else {\n+            return None\n         };\n \n-        fndecl\n+        fn_sig\n+            .decl\n             .inputs\n             .iter()\n             .find_map(|arg| find_component_for_bound_region(tcx, arg, br))\n-            .map(|ty| (ty, &**fndecl))\n+            .map(|ty| (ty, fn_sig))\n     } else {\n         None\n     }"}, {"sha": "6d71d702cc89b069950d2cf733d37d07eb932b42", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 26, "deletions": 65, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -4,7 +4,7 @@\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_middle::ty::{self, DefIdTree, Region, Ty};\n+use rustc_middle::ty::{self, Binder, DefIdTree, Region, Ty, TypeFoldable};\n use rustc_span::Span;\n \n /// Information about the anonymous region we are searching for.\n@@ -94,81 +94,42 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             })\n     }\n \n-    pub(super) fn future_return_type(\n-        &self,\n-        local_def_id: LocalDefId,\n-    ) -> Option<&rustc_hir::Ty<'_>> {\n-        if let Some(hir::IsAsync::Async) = self.asyncness(local_def_id) {\n-            if let rustc_middle::ty::Opaque(def_id, _) =\n-                self.tcx().type_of(local_def_id).fn_sig(self.tcx()).output().skip_binder().kind()\n-            {\n-                match self.tcx().hir().get_if_local(*def_id) {\n-                    Some(hir::Node::Item(hir::Item {\n-                        kind:\n-                            hir::ItemKind::OpaqueTy(hir::OpaqueTy {\n-                                bounds,\n-                                origin: hir::OpaqueTyOrigin::AsyncFn(..),\n-                                ..\n-                            }),\n-                        ..\n-                    })) => {\n-                        for b in bounds.iter() {\n-                            if let hir::GenericBound::LangItemTrait(\n-                                hir::LangItem::Future,\n-                                _span,\n-                                _hir_id,\n-                                generic_args,\n-                            ) = b\n-                            {\n-                                for type_binding in generic_args.bindings.iter() {\n-                                    if type_binding.ident.name == rustc_span::sym::Output {\n-                                        if let hir::TypeBindingKind::Equality {\n-                                            term: hir::Term::Ty(ty),\n-                                        } = type_binding.kind\n-                                        {\n-                                            return Some(ty);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        None\n-    }\n-\n-    pub(super) fn asyncness(&self, local_def_id: LocalDefId) -> Option<hir::IsAsync> {\n-        // similar to the asyncness fn in rustc_ty_utils::ty\n-        let hir_id = self.tcx().hir().local_def_id_to_hir_id(local_def_id);\n-        let node = self.tcx().hir().get(hir_id);\n-        let fn_kind = node.fn_kind()?;\n-        Some(fn_kind.asyncness())\n-    }\n-\n     // Here, we check for the case where the anonymous region\n-    // is in the return type.\n+    // is in the return type as written by the user.\n     // FIXME(#42703) - Need to handle certain cases here.\n     pub(super) fn is_return_type_anon(\n         &self,\n         scope_def_id: LocalDefId,\n         br: ty::BoundRegionKind,\n-        decl: &hir::FnDecl<'_>,\n+        hir_sig: &hir::FnSig<'_>,\n     ) -> Option<Span> {\n-        let ret_ty = self.tcx().type_of(scope_def_id);\n-        if let ty::FnDef(_, _) = ret_ty.kind() {\n-            let sig = ret_ty.fn_sig(self.tcx());\n-            let late_bound_regions =\n-                self.tcx().collect_referenced_late_bound_regions(&sig.output());\n-            if late_bound_regions.iter().any(|r| *r == br) {\n-                return Some(decl.output.span());\n-            }\n+        let fn_ty = self.tcx().type_of(scope_def_id);\n+        if let ty::FnDef(_, _) = fn_ty.kind() {\n+            let ret_ty = fn_ty.fn_sig(self.tcx()).output();\n+            let span = hir_sig.decl.output.span();\n+            let future_output = if hir_sig.header.is_async() {\n+                ret_ty.map_bound(|ty| self.infcx.get_impl_future_output_ty(ty)).transpose()\n+            } else {\n+                None\n+            };\n+            return match future_output {\n+                Some(output) if self.includes_region(output, br) => Some(span),\n+                None if self.includes_region(ret_ty, br) => Some(span),\n+                _ => None,\n+            };\n         }\n         None\n     }\n \n+    fn includes_region(\n+        &self,\n+        ty: Binder<'tcx, impl TypeFoldable<'tcx>>,\n+        region: ty::BoundRegionKind,\n+    ) -> bool {\n+        let late_bound_regions = self.tcx().collect_referenced_late_bound_regions(&ty);\n+        late_bound_regions.iter().any(|r| *r == region)\n+    }\n+\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to"}, {"sha": "f6abeff60cd9468427320a917d0e696abc18ea9f", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -1909,7 +1909,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             _ => return,\n         };\n         let mut add_label = true;\n-        if let ty::Adt(def, _) = output_ty.kind() {\n+        if let ty::Adt(def, _) = output_ty.skip_binder().kind() {\n             // no field access on enum type\n             if !def.is_enum() {\n                 if def"}, {"sha": "be4c9ec99b9c68a093f24882b520ec5c4f1c75df", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -609,14 +609,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             let ty = match self.tcx.asyncness(fn_id.owner) {\n-                hir::IsAsync::Async => self.tcx.infer_ctxt().enter(|infcx| {\n-                    infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n-                        span_bug!(\n-                            fn_decl.output.span(),\n-                            \"failed to get output type of async function\"\n-                        )\n+                hir::IsAsync::Async => self\n+                    .tcx\n+                    .infer_ctxt()\n+                    .enter(|infcx| {\n+                        infcx.get_impl_future_output_ty(ty).unwrap_or_else(|| {\n+                            span_bug!(\n+                                fn_decl.output.span(),\n+                                \"failed to get output type of async function\"\n+                            )\n+                        })\n                     })\n-                }),\n+                    .skip_binder(),\n                 hir::IsAsync::NotAsync => ty,\n             };\n             if self.can_coerce(found, ty) {"}, {"sha": "96ab800afaffed0f4738907e902c1ee78a19e42e", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -1274,7 +1274,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n     ) {\n         let output_ty = match self.infcx.get_impl_future_output_ty(ty) {\n-            Some(output_ty) => self.resolve_vars_if_possible(output_ty),\n+            Some(output_ty) => self.resolve_vars_if_possible(output_ty).skip_binder(),\n             _ => return,\n         };\n         let method_exists = self.method_exists(item_name, output_ty, call.hir_id, true);"}, {"sha": "ac5f99970c8148398b7d105253eccad924fee621", "filename": "src/test/ui/async-await/issue-76547.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-76547.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,23 +2,17 @@ error[E0623]: lifetime mismatch\n   --> $DIR/issue-76547.rs:20:13\n    |\n LL | async fn fut(bufs: &mut [&mut [u8]]) {\n-   |                          ---------   -\n-   |                          |           |\n-   |                          |           this `async fn` implicitly returns an `impl Future<Output = ()>`\n-   |                          this parameter and the returned future are declared with different lifetimes...\n+   |                    ---------------- these two types are declared with different lifetimes...\n LL |     ListFut(bufs).await\n-   |             ^^^^ ...but data from `bufs` is held across an await point here\n+   |             ^^^^ ...but data from `bufs` flows into `bufs` here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/issue-76547.rs:34:14\n    |\n LL | async fn fut2(bufs: &mut [&mut [u8]]) -> i32 {\n-   |                           ---------      ---\n-   |                           |              |\n-   |                           |              this `async fn` implicitly returns an `impl Future<Output = i32>`\n-   |                           this parameter and the returned future are declared with different lifetimes...\n+   |                     ---------------- these two types are declared with different lifetimes...\n LL |     ListFut2(bufs).await\n-   |              ^^^^ ...but data from `bufs` is held across an await point here\n+   |              ^^^^ ...but data from `bufs` flows into `bufs` here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8f602a1492ad2ff02765b189b8ebc33f45a7c556", "filename": "src/test/ui/async-await/issues/issue-63388-1.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,14 +2,12 @@ error[E0623]: lifetime mismatch\n   --> $DIR/issue-63388-1.rs:14:9\n    |\n LL |         &'a self, foo: &dyn Foo\n-   |         -------- this parameter and the returned future are declared with different lifetimes...\n+   |                        -------- this parameter and the return type are declared with different lifetimes...\n LL |     ) -> &dyn Foo\n    |          --------\n-   |          |\n-   |          this `async fn` implicitly returns an `impl Future<Output = &dyn Foo>`\n LL |     {\n LL |         foo\n-   |         ^^^ ...but data from `foo` is held across an await point here\n+   |         ^^^ ...but data from `foo` is returned here\n \n error: aborting due to previous error\n "}, {"sha": "149692a2c6998e29981b192df521a48fa354c480", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -4,9 +4,8 @@ error[E0623]: lifetime mismatch\n LL | async fn async_ret_impl_trait3<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n    |                                                      ------     ^^^^^^^^^^^^^^^^^^^\n    |                                                      |          |\n-   |                                                      |          ...but data from `a` is held across an await point here\n-   |                                                      |          this `async fn` implicitly returns an `impl Future<Output = impl Trait<'a> + 'b>`\n-   |                                                      this parameter and the returned future are declared with different lifetimes...\n+   |                                                      |          ...but data from `a` is returned here\n+   |                                                      this parameter and the return type are declared with different lifetimes...\n \n error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n   --> $DIR/ret-impl-trait-one.rs:16:65"}, {"sha": "299a2d2f2d3de6f9b21ac115ab6c9b70b24f1cbe", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.stderr", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,28 +2,25 @@ error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:8:52\n    |\n LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n-   |                          ----               ----   ^ ...but data from `f` is held across an await point here\n-   |                          |                  |\n-   |                          |                  this `async fn` implicitly returns an `impl Future<Output = &Foo>`\n-   |                          this parameter and the returned future are declared with different lifetimes...\n+   |                                    ----     ----   ^ ...but data from `f` is returned here\n+   |                                    |\n+   |                                    this parameter and the return type are declared with different lifetimes...\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:11:82\n    |\n LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (self, f) }\n-   |                          -----                        -----------------          ^ ...but data from `f` is held across an await point here\n-   |                          |                            |\n-   |                          |                            this `async fn` implicitly returns an `impl Future<Output = (Pin<&Foo>, &Foo)>`\n-   |                          this parameter and the returned future are declared with different lifetimes...\n+   |                                     ----              -----------------          ^ ...but data from `f` is returned here\n+   |                                     |\n+   |                                     this parameter and the return type are declared with different lifetimes...\n \n error[E0623]: lifetime mismatch\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:17:64\n    |\n LL |     async fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n-   |                                  -----                   ---   ^^^ ...but data from `arg` is held across an await point here\n-   |                                  |                       |\n-   |                                  |                       this `async fn` implicitly returns an `impl Future<Output = &()>`\n-   |                                  this parameter and the returned future are declared with different lifetimes...\n+   |                                               ------     ---   ^^^ ...but data from `arg` is returned here\n+   |                                               |\n+   |                                               this parameter and the return type are declared with different lifetimes...\n \n error: aborting due to 3 previous errors\n "}, {"sha": "7448e8484b47a1af7b5e7bfffe1c14dd802d8ce4", "filename": "src/test/ui/self/elision/lt-ref-self-async.stderr", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,67 +2,61 @@ error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:13:9\n    |\n LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n-   |                       -----              ----\n-   |                       |                  |\n-   |                       |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                       this parameter and the returned future are declared with different lifetimes...\n+   |                                 ----     ----\n+   |                                 |\n+   |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:19:9\n    |\n LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n-   |                             -----              ----\n-   |                             |                  |\n-   |                             |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                             this parameter and the returned future are declared with different lifetimes...\n+   |                                       ----     ----\n+   |                                       |\n+   |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:23:9\n    |\n LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:27:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:31:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n-   |                                             -----                ----\n-   |                                             |                    |\n-   |                                             |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/lt-ref-self-async.rs:35:9\n    |\n LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n-   |                                         -----                ----\n-   |                                         |                    |\n-   |                                         |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                         this parameter and the returned future are declared with different lifetimes...\n+   |                                                     ----     ----\n+   |                                                     |\n+   |                                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 6 previous errors\n "}, {"sha": "6056cc46d3d8a505346e9bfade02dba8ce145809", "filename": "src/test/ui/self/elision/ref-mut-self-async.stderr", "status": "modified", "additions": 24, "deletions": 30, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,67 +2,61 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:13:9\n    |\n LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n-   |                       ---------              ----\n-   |                       |                      |\n-   |                       |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                       this parameter and the returned future are declared with different lifetimes...\n+   |                                     ----     ----\n+   |                                     |\n+   |                                     this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:19:9\n    |\n LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n-   |                             ---------              ----\n-   |                             |                      |\n-   |                             |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                             this parameter and the returned future are declared with different lifetimes...\n+   |                                           ----     ----\n+   |                                           |\n+   |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:23:9\n    |\n LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n-   |                                     ---------               ----\n-   |                                     |                       |\n-   |                                     |                       this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:27:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n-   |                                     ---------               ----\n-   |                                     |                       |\n-   |                                     |                       this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:31:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n-   |                                             ---------                ----\n-   |                                             |                        |\n-   |                                             |                        this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ----     ----\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-self-async.rs:35:9\n    |\n LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n-   |                                             ---------                ----\n-   |                                             |                        |\n-   |                                             |                        this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ----     ----\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 6 previous errors\n "}, {"sha": "61034ae4d47b6792ec66874f9079af8558291364", "filename": "src/test/ui/self/elision/ref-mut-struct-async.stderr", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,56 +2,51 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:13:9\n    |\n LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n-   |                               -----------              ----\n-   |                               |                        |\n-   |                               |                        this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                               this parameter and the returned future are declared with different lifetimes...\n+   |                                               ----     ----\n+   |                                               |\n+   |                                               this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:17:9\n    |\n LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n-   |                                       -----------               ----\n-   |                                       |                         |\n-   |                                       |                         this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                        ----     ----\n+   |                                                        |\n+   |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:21:9\n    |\n LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n-   |                                       -----------               ----\n-   |                                       |                         |\n-   |                                       |                         this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                        ----     ----\n+   |                                                        |\n+   |                                                        this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:25:9\n    |\n LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                               -----------                ----\n-   |                                               |                          |\n-   |                                               |                          this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                               this parameter and the returned future are declared with different lifetimes...\n+   |                                                                 ----     ----\n+   |                                                                 |\n+   |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-mut-struct-async.rs:29:9\n    |\n LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                               -----------                ----\n-   |                                               |                          |\n-   |                                               |                          this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                               this parameter and the returned future are declared with different lifetimes...\n+   |                                                                 ----     ----\n+   |                                                                 |\n+   |                                                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 5 previous errors\n "}, {"sha": "0eab16e685d4c4fc618fd7962b55406c648311e2", "filename": "src/test/ui/self/elision/ref-self-async.stderr", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-self-async.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,78 +2,71 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:23:9\n    |\n LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n-   |                       -----              ----\n-   |                       |                  |\n-   |                       |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                       this parameter and the returned future are declared with different lifetimes...\n+   |                                 ----     ----\n+   |                                 |\n+   |                                 this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:29:9\n    |\n LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n-   |                             -----              ----\n-   |                             |                  |\n-   |                             |                  this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                             this parameter and the returned future are declared with different lifetimes...\n+   |                                       ----     ----\n+   |                                       |\n+   |                                       this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:33:9\n    |\n LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:37:9\n    |\n LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n-   |                                     -----               ----\n-   |                                     |                   |\n-   |                                     |                   this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                     this parameter and the returned future are declared with different lifetimes...\n+   |                                                ----     ----\n+   |                                                |\n+   |                                                this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:41:9\n    |\n LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n-   |                                             -----                ----\n-   |                                             |                    |\n-   |                                             |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:45:9\n    |\n LL |     async fn box_pin_ref_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n-   |                                             -----                ----\n-   |                                             |                    |\n-   |                                             |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                             this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-self-async.rs:49:9\n    |\n LL |     async fn wrap_ref_Self_Self(self: Wrap<&Self, Self>, f: &u8) -> &u8 {\n-   |                                            -----                    ---\n-   |                                            |                        |\n-   |                                            |                        this `async fn` implicitly returns an `impl Future<Output = &u8>`\n-   |                                            this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ---     ---\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 7 previous errors\n "}, {"sha": "aa1d7453e83e1c0fefc5a3123b57d143451f6e1f", "filename": "src/test/ui/self/elision/ref-struct-async.stderr", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/413f490677d7d58e6d3a14c9fc5d9be11e5d668d/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.stderr?ref=413f490677d7d58e6d3a14c9fc5d9be11e5d668d", "patch": "@@ -2,56 +2,51 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:13:9\n    |\n LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n-   |                               -------              ----\n-   |                               |                    |\n-   |                               |                    this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                               this parameter and the returned future are declared with different lifetimes...\n+   |                                           ----     ----\n+   |                                           |\n+   |                                           this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:17:9\n    |\n LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n-   |                                       -------               ----\n-   |                                       |                     |\n-   |                                       |                     this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:21:9\n    |\n LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n-   |                                       -------               ----\n-   |                                       |                     |\n-   |                                       |                     this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                       this parameter and the returned future are declared with different lifetimes...\n+   |                                                    ----     ----\n+   |                                                    |\n+   |                                                    this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:25:9\n    |\n LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n-   |                                               -------                ----\n-   |                                               |                      |\n-   |                                               |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                               this parameter and the returned future are declared with different lifetimes...\n+   |                                                             ----     ----\n+   |                                                             |\n+   |                                                             this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ref-struct-async.rs:29:9\n    |\n LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n-   |                                           -------                ----\n-   |                                           |                      |\n-   |                                           |                      this `async fn` implicitly returns an `impl Future<Output = &u32>`\n-   |                                           this parameter and the returned future are declared with different lifetimes...\n+   |                                                         ----     ----\n+   |                                                         |\n+   |                                                         this parameter and the return type are declared with different lifetimes...\n LL |         f\n-   |         ^ ...but data from `f` is held across an await point here\n+   |         ^ ...but data from `f` is returned here\n \n error: aborting due to 5 previous errors\n "}]}