{"sha": "c392fbbbf16981dc6368de7ea6a8797892221283", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOTJmYmJiZjE2OTgxZGM2MzY4ZGU3ZWE2YTg3OTc4OTIyMjEyODM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-12T07:38:35Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-11-24T10:36:31Z"}, "message": "Adjust generics to `Allocation` parameters", "tree": {"sha": "5dea8e4745fbd671a2b6a809bb3e8a5cf928d289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5dea8e4745fbd671a2b6a809bb3e8a5cf928d289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c392fbbbf16981dc6368de7ea6a8797892221283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c392fbbbf16981dc6368de7ea6a8797892221283", "html_url": "https://github.com/rust-lang/rust/commit/c392fbbbf16981dc6368de7ea6a8797892221283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c392fbbbf16981dc6368de7ea6a8797892221283/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c9d786e5007004917d73749fad32bc3bff94cce", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9d786e5007004917d73749fad32bc3bff94cce", "html_url": "https://github.com/rust-lang/rust/commit/7c9d786e5007004917d73749fad32bc3bff94cce"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "05f9f482d5327ac952a2637b140612181d4e0ef4", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c392fbbbf16981dc6368de7ea6a8797892221283/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c392fbbbf16981dc6368de7ea6a8797892221283/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=c392fbbbf16981dc6368de7ea6a8797892221283", "patch": "@@ -59,7 +59,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// If you want to check bounds before doing a memory access, better use `check_bounds`.\n     pub fn check_bounds_ptr(\n         &self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Pointer<Tag>,\n         check: InboundsCheck,\n     ) -> EvalResult<'tcx> {\n         let allocation_size = match check {\n@@ -85,7 +85,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     #[inline(always)]\n     pub fn check_bounds(\n         &self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n         check: InboundsCheck,\n     ) -> EvalResult<'tcx> {\n@@ -183,9 +183,9 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Return all relocations overlapping with the given ptr-offset pair.\n     fn relocations(\n         &self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[(Size, (M::PointerTag, AllocId))]> {\n+    ) -> EvalResult<'tcx, &[(Size, (Tag, AllocId))]> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n@@ -195,7 +195,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n \n     /// Check that there ar eno relocations overlapping with the given range.\n     #[inline(always)]\n-    fn check_relocations(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n+    fn check_relocations(&self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n         if self.relocations(ptr, size)?.len() != 0 {\n             err!(ReadPointerAsBytes)\n         } else {\n@@ -209,7 +209,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// uninitialized.  This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(&mut self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n@@ -244,7 +244,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Error if there are relocations overlapping with the edges of the\n     /// given memory range.\n     #[inline]\n-    fn check_relocation_edges(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n+    fn check_relocation_edges(&self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n         self.check_relocations(ptr, Size::ZERO)?;\n         self.check_relocations(ptr.offset(size, self)?, Size::ZERO)?;\n         Ok(())\n@@ -257,7 +257,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n     #[inline]\n-    fn check_defined(&self, ptr: Pointer<M::PointerTag>, size: Size) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         alloc.undef_mask.is_range_defined(\n             ptr.offset,\n@@ -267,7 +267,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n \n     pub fn mark_definedness(\n         &mut self,\n-        ptr: Pointer<M::PointerTag>,\n+        ptr: Pointer<Tag>,\n         size: Size,\n         new_state: bool,\n     ) -> EvalResult<'tcx> {"}]}