{"sha": "27a18b127f4f02dbbdf12eec03b817ed3c3f0f68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3YTE4YjEyN2Y0ZjAyZGJiZGYxMmVlYzAzYjgxN2VkM2MzZjBmNjg=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-16T20:41:43Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-07-17T15:46:41Z"}, "message": "macros: Fix bug in statement matchers", "tree": {"sha": "119b4e09c633f918dbd70c050c361fe1010ffdec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/119b4e09c633f918dbd70c050c361fe1010ffdec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27a18b127f4f02dbbdf12eec03b817ed3c3f0f68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27a18b127f4f02dbbdf12eec03b817ed3c3f0f68", "html_url": "https://github.com/rust-lang/rust/commit/27a18b127f4f02dbbdf12eec03b817ed3c3f0f68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27a18b127f4f02dbbdf12eec03b817ed3c3f0f68/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "145f0ec88caaae531d7ba0232c4ef39704a23af2", "url": "https://api.github.com/repos/rust-lang/rust/commits/145f0ec88caaae531d7ba0232c4ef39704a23af2", "html_url": "https://github.com/rust-lang/rust/commit/145f0ec88caaae531d7ba0232c4ef39704a23af2"}], "stats": {"total": 80, "additions": 31, "deletions": 49}, "files": [{"sha": "125f1abb062bf2966b17a31cb428edd4a8fe6620", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 49, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/27a18b127f4f02dbbdf12eec03b817ed3c3f0f68/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27a18b127f4f02dbbdf12eec03b817ed3c3f0f68/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=27a18b127f4f02dbbdf12eec03b817ed3c3f0f68", "patch": "@@ -3789,13 +3789,8 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g. a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    ///\n-    /// Also, if a macro begins an expression statement, this only parses the macro. For example,\n-    /// ```rust\n-    /// vec![1].into_iter(); //< `parse_stmt` only parses the \"vec![1]\"\n-    /// ```\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(self.parse_stmt_())\n+        Ok(self.parse_stmt_(true))\n     }\n \n     // Eat tokens until we can be relatively sure we reached the end of the\n@@ -3859,15 +3854,15 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_stmt_(&mut self) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n+    fn parse_stmt_(&mut self, macro_expanded: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_expanded).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break);\n             None\n         })\n     }\n \n-    fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_without_recovery(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = self.parse_outer_attributes()?;\n@@ -3930,10 +3925,34 @@ impl<'a> Parser<'a> {\n \n             if id.name == keywords::Invalid.name() {\n                 let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                let node = if delim == token::Brace ||\n+                              self.token == token::Semi || self.token == token::Eof {\n+                    StmtKind::Mac(P((mac, style, attrs.into())))\n+                }\n+                // We used to incorrectly stop parsing macro-expanded statements here.\n+                // If the next token will be an error anyway but could have parsed with the\n+                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+                else if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                    // These can continue an expression, so we can't stop parsing and warn.\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                    token::BinOp(token::And) | token::BinOp(token::Or) |\n+                    token::AndAnd | token::OrOr |\n+                    token::DotDot | token::DotDotDot => false,\n+                    _ => true,\n+                } {\n+                    self.warn_missing_semicolon();\n+                    StmtKind::Mac(P((mac, style, attrs.into())))\n+                } else {\n+                    let e = self.mk_mac_expr(lo, hi, mac.node, ThinVec::new());\n+                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                    StmtKind::Expr(e)\n+                };\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Mac(P((mac, style, attrs.into()))),\n                     span: mk_sp(lo, hi),\n+                    node: node,\n                 }\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -4061,49 +4080,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement, including the trailing semicolon.\n-    /// This parses expression statements that begin with macros correctly (c.f. `parse_stmt`).\n     pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n-        let mut stmt = match self.parse_stmt_() {\n+        let mut stmt = match self.parse_stmt_(macro_expanded) {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n         };\n \n-        if let StmtKind::Mac(mac) = stmt.node {\n-            if mac.1 != MacStmtStyle::NoBraces ||\n-               self.token == token::Semi || self.token == token::Eof {\n-                stmt.node = StmtKind::Mac(mac);\n-            } else {\n-                // We used to incorrectly stop parsing macro-expanded statements here.\n-                // If the next token will be an error anyway but could have parsed with the\n-                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-                if macro_expanded && self.token.can_begin_expr() && match self.token {\n-                    // These tokens can continue an expression, so we can't stop parsing and warn.\n-                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n-                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n-                    token::BinOp(token::And) | token::BinOp(token::Or) |\n-                    token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot => false,\n-                    _ => true,\n-                } {\n-                    self.warn_missing_semicolon();\n-                    stmt.node = StmtKind::Mac(mac);\n-                    return Ok(Some(stmt));\n-                }\n-\n-                let (mac, _style, attrs) = mac.unwrap();\n-                let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n-                let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                stmt.node = StmtKind::Expr(e);\n-            }\n-        }\n-\n-        stmt = self.handle_trailing_semicolon(stmt, macro_expanded)?;\n-        Ok(Some(stmt))\n-    }\n-\n-    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt, macro_expanded: bool)\n-                                 -> PResult<'a, Stmt> {\n         match stmt.node {\n             StmtKind::Expr(ref expr) if self.token != token::Eof => {\n                 // expression without semicolon\n@@ -4133,7 +4115,7 @@ impl<'a> Parser<'a> {\n         }\n \n         stmt.span.hi = self.last_span.hi;\n-        Ok(stmt)\n+        Ok(Some(stmt))\n     }\n \n     fn warn_missing_semicolon(&self) {"}]}