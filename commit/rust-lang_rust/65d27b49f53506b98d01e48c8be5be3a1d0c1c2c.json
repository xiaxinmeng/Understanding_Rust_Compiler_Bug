{"sha": "65d27b49f53506b98d01e48c8be5be3a1d0c1c2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZDI3YjQ5ZjUzNTA2Yjk4ZDAxZTQ4YzhiZTViZTNhMWQwYzFjMmM=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-07-08T23:40:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-08T23:40:28Z"}, "message": "Merge pull request #1074 from Manishearth/fix-doc\n\nHandle `/**` and `~~~` in `DOC_MARKDOWN`", "tree": {"sha": "19e36ef391d1d6a322b431c3ac6037944ed65759", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19e36ef391d1d6a322b431c3ac6037944ed65759"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c", "html_url": "https://github.com/rust-lang/rust/commit/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cd177d2db044a8b94feb76482992660efd916d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cd177d2db044a8b94feb76482992660efd916d0", "html_url": "https://github.com/rust-lang/rust/commit/3cd177d2db044a8b94feb76482992660efd916d0"}, {"sha": "56d3bc70080ec9ae4fca650df8708d0aae410f41", "url": "https://api.github.com/repos/rust-lang/rust/commits/56d3bc70080ec9ae4fca650df8708d0aae410f41", "html_url": "https://github.com/rust-lang/rust/commit/56d3bc70080ec9ae4fca650df8708d0aae410f41"}], "stats": {"total": 176, "additions": 156, "deletions": 20}, "files": [{"sha": "92fcd804d5f64871068619086ba96dd5de0795de", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 108, "deletions": 18, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=65d27b49f53506b98d01e48c8be5be3a1d0c1c2c", "patch": "@@ -50,25 +50,50 @@ impl EarlyLintPass for Doc {\n     }\n }\n \n+/// Cleanup documentation decoration (`///` and such).\n+///\n+/// We can't use `syntax::attr::AttributeMethods::with_desugared_doc` or\n+/// `syntax::parse::lexer::comments::strip_doc_comment_decoration` because we need to keep track of\n+/// the span but this function is inspired from the later.\n+#[allow(cast_possible_truncation)]\n+pub fn strip_doc_comment_decoration((comment, span): (&str, Span)) -> Vec<(&str, Span)> {\n+    // one-line comments lose their prefix\n+    const ONELINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n+    for prefix in ONELINERS {\n+        if comment.starts_with(*prefix) {\n+            return vec![(\n+                &comment[prefix.len()..],\n+                Span { lo: span.lo + BytePos(prefix.len() as u32), ..span }\n+            )];\n+        }\n+    }\n+\n+    if comment.starts_with(\"/*\") {\n+        return comment[3..comment.len() - 2].lines().map(|line| {\n+            let offset = line.as_ptr() as usize - comment.as_ptr() as usize;\n+            debug_assert_eq!(offset as u32 as usize, offset);\n+\n+            (\n+                line,\n+                Span {\n+                    lo: span.lo + BytePos(offset as u32),\n+                    ..span\n+                }\n+            )\n+        }).collect();\n+    }\n+\n+    panic!(\"not a doc-comment: {}\", comment);\n+}\n+\n pub fn check_attrs<'a>(cx: &EarlyContext, valid_idents: &[String], attrs: &'a [ast::Attribute]) {\n     let mut docs = vec![];\n \n-    let mut in_multiline = false;\n     for attr in attrs {\n         if attr.node.is_sugared_doc {\n             if let ast::MetaItemKind::NameValue(_, ref doc) = attr.node.value.node {\n                 if let ast::LitKind::Str(ref doc, _) = doc.node {\n-                    // doc comments start with `///` or `//!`\n-                    let real_doc = &doc[3..];\n-                    let mut span = attr.span;\n-                    span.lo = span.lo + BytePos(3);\n-\n-                    // check for multiline code blocks\n-                    if real_doc.trim_left().starts_with(\"```\") {\n-                        in_multiline = !in_multiline;\n-                    } else if !in_multiline {\n-                        docs.push((real_doc, span));\n-                    }\n+                    docs.extend_from_slice(&strip_doc_comment_decoration((doc, attr.span)));\n                 }\n             }\n         }\n@@ -135,11 +160,11 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)])\n         }\n \n         #[allow(while_let_on_iterator)] // borrowck complains about for\n-        fn jump_to(&mut self, n: char) -> Result<(), ()> {\n-            while let Some((_, c)) = self.next() {\n+        fn jump_to(&mut self, n: char) -> Result<bool, ()> {\n+            while let Some((new_line, c)) = self.next() {\n                 if c == n {\n                     self.advance_begin();\n-                    return Ok(());\n+                    return Ok(new_line);\n                 }\n             }\n \n@@ -217,6 +242,54 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)])\n         pos: 0,\n     };\n \n+    /// Check for fanced code block.\n+    macro_rules! check_block {\n+        ($parser:expr, $c:tt, $new_line:expr) => {{\n+            check_block!($parser, $c, $c, $new_line)\n+        }};\n+\n+        ($parser:expr, $c:pat, $c_expr:expr, $new_line:expr) => {{\n+            fn check_block(parser: &mut Parser, new_line: bool) -> Result<bool, ()> {\n+                if new_line {\n+                    let mut lookup_parser = parser.clone();\n+                    if let (Some((false, $c)), Some((false, $c))) = (lookup_parser.next(), lookup_parser.next()) {\n+                        *parser = lookup_parser;\n+                        // 3 or more ` or ~ open a code block to be closed with the same number of ` or ~\n+                        let mut open_count = 3;\n+                        while let Some((false, $c)) = parser.next() {\n+                            open_count += 1;\n+                        }\n+\n+                        loop {\n+                            loop {\n+                                if try!(parser.jump_to($c_expr)) {\n+                                    break;\n+                                }\n+                            }\n+\n+                            lookup_parser = parser.clone();\n+                            if let (Some((false, $c)), Some((false, $c))) = (lookup_parser.next(), lookup_parser.next()) {\n+                                let mut close_count = 3;\n+                                while let Some((false, $c)) = lookup_parser.next() {\n+                                    close_count += 1;\n+                                }\n+\n+                                if close_count == open_count {\n+                                    *parser = lookup_parser;\n+                                    return Ok(true);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                Ok(false)\n+            }\n+\n+            check_block(&mut $parser, $new_line)\n+        }};\n+    }\n+\n     loop {\n         match parser.next() {\n             Some((new_line, c)) => {\n@@ -225,7 +298,20 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)])\n                         parser.next_line();\n                     }\n                     '`' => {\n-                        try!(parser.jump_to('`'));\n+                        if try!(check_block!(parser, '`', new_line)) {\n+                            continue;\n+                        }\n+\n+                        try!(parser.jump_to('`')); // not a code block, just inline code\n+                    }\n+                    '~' => {\n+                        if try!(check_block!(parser, '~', new_line)) {\n+                            continue;\n+                        }\n+\n+                        // ~ does not introduce inline code, but two of them introduce\n+                        // strikethrough. Too bad for the consistency but we don't care about\n+                        // strikethrough.\n                     }\n                     '[' => {\n                         // Check for a reference definition `[foo]:` at the beginning of a line\n@@ -249,8 +335,12 @@ fn check_doc(cx: &EarlyContext, valid_idents: &[String], docs: &[(&str, Span)])\n                         parser.link = false;\n \n                         match parser.peek() {\n-                            Some('(') => try!(parser.jump_to(')')),\n-                            Some('[') => try!(parser.jump_to(']')),\n+                            Some('(') => {\n+                                try!(parser.jump_to(')'));\n+                            }\n+                            Some('[') => {\n+                                try!(parser.jump_to(']'));\n+                            }\n                             Some(_) => continue,\n                             None => return Err(()),\n                         }"}, {"sha": "84283a8316e9f93cbc281de8a83c1dcb8d38a0b9", "filename": "tests/compile-fail/doc.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c/tests%2Fcompile-fail%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65d27b49f53506b98d01e48c8be5be3a1d0c1c2c/tests%2Fcompile-fail%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdoc.rs?ref=65d27b49f53506b98d01e48c8be5be3a1d0c1c2c", "patch": "@@ -14,6 +14,8 @@\n /// which should be reported only once despite being __doubly bad__.\n /// Here be ::is::a::global:path.\n //~^ ERROR: you should put `is::a::global:path` between ticks\n+/// That's not code ~NotInCodeBlock~.\n+//~^ ERROR: you should put `NotInCodeBlock` between ticks\n /// be_sure_we_got_to_the_end_of_it\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn foo_bar() {\n@@ -24,9 +26,14 @@ fn foo_bar() {\n /// foo_bar FOO_BAR\n /// _foo bar_\n /// ```\n+///\n+/// ~~~rust\n+/// foo_bar FOO_BAR\n+/// _foo bar_\n+/// ~~~\n /// be_sure_we_got_to_the_end_of_it\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n-fn multiline_ticks() {\n+fn multiline_codeblock() {\n }\n \n /// This _is a test for\n@@ -106,7 +113,7 @@ fn test_unicode() {\n //~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n fn main() {\n     foo_bar();\n-    multiline_ticks();\n+    multiline_codeblock();\n     test_emphasis();\n     test_units();\n }\n@@ -151,3 +158,42 @@ fn issue883() {\n /// bar](https://doc.rust-lang.org/stable/std/iter/trait.IteratorFooBar.html)\n fn multiline() {\n }\n+\n+/** E.g. serialization of an empty list: FooBar\n+```\n+That's in a code block: `PackedNode`\n+```\n+\n+And BarQuz too.\n+be_sure_we_got_to_the_end_of_it\n+*/\n+//~^^^^^^^^ ERROR: you should put `FooBar` between ticks\n+//~^^^^ ERROR: you should put `BarQuz` between ticks\n+//~^^^^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n+fn issue1073() {\n+}\n+\n+/** E.g. serialization of an empty list: FooBar\n+```\n+That's in a code block: PackedNode\n+```\n+\n+And BarQuz too.\n+be_sure_we_got_to_the_end_of_it\n+*/\n+//~^^^^^^^^ ERROR: you should put `FooBar` between ticks\n+//~^^^^ ERROR: you should put `BarQuz` between ticks\n+//~^^^^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n+fn issue1073_alt() {\n+}\n+\n+/// Test more than three quotes:\n+/// ````\n+/// DoNotWarn\n+/// ```\n+/// StillDont\n+/// ````\n+/// be_sure_we_got_to_the_end_of_it\n+//~^ ERROR: you should put `be_sure_we_got_to_the_end_of_it` between ticks\n+fn four_quotes() {\n+}"}]}