{"sha": "28a232a59ac4ded4e6de9e9c06a17a801c5199dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YTIzMmE1OWFjNGRlZDRlNmRlOWU5YzA2YTE3YTgwMWM1MTk5ZGQ=", "commit": {"author": {"name": "projektir", "email": "oprojektir@gmail.com", "date": "2017-04-04T03:32:59Z"}, "committer": {"name": "projektir", "email": "oprojektir@gmail.com", "date": "2017-04-08T19:33:21Z"}, "message": "Adding links around Sender/SyncSender/Receiver errors; Adding more documentation to channel() and sync_channel(); adding more links #29377", "tree": {"sha": "747bc9158e209b901a2149ff1a786a74a5a97cd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/747bc9158e209b901a2149ff1a786a74a5a97cd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28a232a59ac4ded4e6de9e9c06a17a801c5199dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28a232a59ac4ded4e6de9e9c06a17a801c5199dd", "html_url": "https://github.com/rust-lang/rust/commit/28a232a59ac4ded4e6de9e9c06a17a801c5199dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28a232a59ac4ded4e6de9e9c06a17a801c5199dd/comments", "author": {"login": "projektir", "id": 16269746, "node_id": "MDQ6VXNlcjE2MjY5NzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16269746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projektir", "html_url": "https://github.com/projektir", "followers_url": "https://api.github.com/users/projektir/followers", "following_url": "https://api.github.com/users/projektir/following{/other_user}", "gists_url": "https://api.github.com/users/projektir/gists{/gist_id}", "starred_url": "https://api.github.com/users/projektir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projektir/subscriptions", "organizations_url": "https://api.github.com/users/projektir/orgs", "repos_url": "https://api.github.com/users/projektir/repos", "events_url": "https://api.github.com/users/projektir/events{/privacy}", "received_events_url": "https://api.github.com/users/projektir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "projektir", "id": 16269746, "node_id": "MDQ6VXNlcjE2MjY5NzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16269746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projektir", "html_url": "https://github.com/projektir", "followers_url": "https://api.github.com/users/projektir/followers", "following_url": "https://api.github.com/users/projektir/following{/other_user}", "gists_url": "https://api.github.com/users/projektir/gists{/gist_id}", "starred_url": "https://api.github.com/users/projektir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projektir/subscriptions", "organizations_url": "https://api.github.com/users/projektir/orgs", "repos_url": "https://api.github.com/users/projektir/repos", "events_url": "https://api.github.com/users/projektir/events{/privacy}", "received_events_url": "https://api.github.com/users/projektir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61011761deeab9e308e6d103b1dc7aaf334f6e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61011761deeab9e308e6d103b1dc7aaf334f6e3", "html_url": "https://github.com/rust-lang/rust/commit/a61011761deeab9e308e6d103b1dc7aaf334f6e3"}], "stats": {"total": 138, "additions": 87, "deletions": 51}, "files": [{"sha": "852675edc0238d60baa13047c9bc6df67acbc402", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 84, "deletions": 50, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/28a232a59ac4ded4e6de9e9c06a17a801c5199dd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a232a59ac4ded4e6de9e9c06a17a801c5199dd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=28a232a59ac4ded4e6de9e9c06a17a801c5199dd", "patch": "@@ -436,81 +436,97 @@ unsafe impl<T: Send> Send for SyncSender<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> !Sync for SyncSender<T> {}\n \n-/// An error returned from the [`send`] function on channels.\n+/// An error returned from the [`Sender::send`] or [`SyncSender::send`]\n+/// function on **channel**s.\n ///\n-/// A [`send`] operation can only fail if the receiving end of a channel is\n+/// A **send** operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n ///\n-/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n+/// [`Sender::send`]: struct.Sender.html#method.send\n+/// [`SyncSender::send`]: struct.SyncSender.html#method.send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub struct SendError<T>(#[stable(feature = \"rust1\", since = \"1.0.0\")] pub T);\n \n /// An error returned from the [`recv`] function on a [`Receiver`].\n ///\n-/// The [`recv`] operation can only fail if the sending half of a channel is\n-/// disconnected, implying that no further messages will ever be received.\n+/// The [`recv`] operation can only fail if the sending half of a\n+/// [`channel`] (or [`sync_channel`]) is disconnected, implying that no further\n+/// messages will ever be received.\n ///\n-/// [`recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv\n-/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+/// [`recv`]: struct.Receiver.html#method.recv\n+/// [`Receiver`]: struct.Receiver.html\n+/// [`channel`]: fn.channel.html\n+/// [`sync_channel`]: fn.sync_channel.html\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that [`try_recv`] could\n-/// not return data when called.\n+/// not return data when called. This can occur with both a [`channel`] and\n+/// a [`sync_channel`].\n ///\n-/// [`try_recv`]: ../../../std/sync/mpsc/struct.Receiver.html#method.try_recv\n+/// [`try_recv`]: struct.Receiver.html#method.try_recv\n+/// [`channel`]: fn.channel.html\n+/// [`sync_channel`]: fn.sync_channel.html\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryRecvError {\n-    /// This channel is currently empty, but the sender(s) have not yet\n+    /// This **channel** is currently empty, but the **Sender**(s) have not yet\n     /// disconnected, so data may yet become available.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Empty,\n \n-    /// This channel's sending half has become disconnected, and there will\n-    /// never be any more data received on this channel\n+    /// The **channel**'s sending half has become disconnected, and there will\n+    /// never be any more data received on it.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected,\n }\n \n-/// This enumeration is the list of possible errors that [`recv_timeout`] could\n-/// not return data when called.\n+/// This enumeration is the list of possible errors that made [`recv_timeout`]\n+/// unable to return data when called. This can occur with both a [`channel`] and\n+/// a [`sync_channel`].\n ///\n-/// [`recv_timeout`]: ../../../std/sync/mpsc/struct.Receiver.html#method.recv_timeout\n+/// [`recv_timeout`]: struct.Receiver.html#method.recv_timeout\n+/// [`channel`]: fn.channel.html\n+/// [`sync_channel`]: fn.sync_channel.html\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n pub enum RecvTimeoutError {\n-    /// This channel is currently empty, but the sender(s) have not yet\n+    /// This **channel** is currently empty, but the **Sender**(s) have not yet\n     /// disconnected, so data may yet become available.\n     #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n     Timeout,\n-    /// This channel's sending half has become disconnected, and there will\n-    /// never be any more data received on this channel\n+    /// The **channel**'s sending half has become disconnected, and there will\n+    /// never be any more data received on it.\n     #[stable(feature = \"mpsc_recv_timeout\", since = \"1.12.0\")]\n     Disconnected,\n }\n \n /// This enumeration is the list of the possible error outcomes for the\n-/// [`SyncSender::try_send`] method.\n+/// [`try_send`] method.\n ///\n-/// [`SyncSender::try_send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.try_send\n+/// [`try_send`]: struct.SyncSender.html#method.try_send\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum TrySendError<T> {\n-    /// The data could not be sent on the channel because it would require that\n+    /// The data could not be sent on the [`sync_channel`] because it would require that\n     /// the callee block to send the data.\n     ///\n     /// If this is a buffered channel, then the buffer is full at this time. If\n-    /// this is not a buffered channel, then there is no receiver available to\n+    /// this is not a buffered channel, then there is no [`Receiver`] available to\n     /// acquire the data.\n+    ///\n+    /// [`sync_channel`]: fn.sync_channel.html\n+    /// [`Receiver`]: struct.Receiver.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Full(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n \n-    /// This channel's receiving half has disconnected, so the data could not be\n+    /// This [`sync_channel`]'s receiving half has disconnected, so the data could not be\n     /// sent. The data is returned back to the callee in this case.\n+    ///\n+    /// [`sync_channel`]: fn.sync_channel.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Disconnected(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n }\n@@ -544,36 +560,46 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n }\n \n /// Creates a new asynchronous channel, returning the sender/receiver halves.\n-/// All data sent on the sender will become available on the receiver, and no\n-/// send will block the calling thread (this channel has an \"infinite buffer\").\n+/// All data sent on the [`Sender`] will become available on the [`Receiver`] in\n+/// the same order as it was sent, and no [`send`] will block the calling thread\n+/// (this channel has an \"infinite buffer\", unlike [`sync_channel`], which will\n+/// block after its buffer limit is reached). [`recv`] will block until a message\n+/// is available.\n+///\n+/// The [`Sender`] can be cloned to [`send`] to the same channel multiple times, but\n+/// only one [`Receiver`] is supported.\n ///\n /// If the [`Receiver`] is disconnected while trying to [`send`] with the\n-/// [`Sender`], the [`send`] method will return an error.\n+/// [`Sender`], the [`send`] method will return a [`SendError`]. Similarly, If the\n+/// [`Sender`] is disconnected while trying to [`recv`], the [`recv`] method will\n+/// return a [`RecvError`].\n ///\n-/// [`send`]: ../../../std/sync/mpsc/struct.Sender.html#method.send\n-/// [`Sender`]: ../../../std/sync/mpsc/struct.Sender.html\n-/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+/// [`send`]: struct.Sender.html#method.send\n+/// [`recv`]: struct.Receiver.html#method.recv\n+/// [`Sender`]: struct.Sender.html\n+/// [`Receiver`]: struct.Receiver.html\n+/// [`sync_channel`]: fn.sync_channel.html\n+/// [`SendError`]: struct.SendError.html\n+/// [`RecvError`]: struct.RecvError.html\n ///\n /// # Examples\n ///\n /// ```\n /// use std::sync::mpsc::channel;\n /// use std::thread;\n ///\n-/// // tx is the sending half (tx for transmission), and rx is the receiving\n-/// // half (rx for receiving).\n-/// let (tx, rx) = channel();\n+/// let (sender, receiver) = channel();\n ///\n /// // Spawn off an expensive computation\n /// thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n-///     tx.send(expensive_computation()).unwrap();\n+///     sender.send(expensive_computation()).unwrap();\n /// });\n ///\n /// // Do some useful work for awhile\n ///\n /// // Let's see what that answer was\n-/// println!(\"{:?}\", rx.recv().unwrap());\n+/// println!(\"{:?}\", receiver.recv().unwrap());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n@@ -582,43 +608,51 @@ pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n }\n \n /// Creates a new synchronous, bounded channel.\n-///\n-/// Like asynchronous channels, the [`Receiver`] will block until a message\n-/// becomes available. These channels differ greatly in the semantics of the\n-/// sender from asynchronous channels, however.\n+/// All data sent on the [`SyncSender`] will become available on the [`Receiver`]\n+/// in the same order as it was sent. Like asynchronous [`channel`]s, the\n+/// [`Receiver`] will block until a message becomes available. `sync_channel`\n+/// differs greatly in the semantics of the sender, however.\n ///\n /// This channel has an internal buffer on which messages will be queued.\n /// `bound` specifies the buffer size. When the internal buffer becomes full,\n /// future sends will *block* waiting for the buffer to open up. Note that a\n /// buffer size of 0 is valid, in which case this becomes \"rendezvous channel\"\n-/// where each [`send`] will not return until a recv is paired with it.\n+/// where each [`send`] will not return until a [`recv`] is paired with it.\n+///\n+/// The [`SyncSender`] can be cloned to [`send`] to the same channel multiple\n+/// times, but only one [`Receiver`] is supported.\n ///\n-/// Like asynchronous channels, if the [`Receiver`] is disconnected while\n-/// trying to [`send`] with the [`SyncSender`], the [`send`] method will\n-/// return an error.\n+/// Like asynchronous channels, if the [`Receiver`] is disconnected while trying\n+/// to [`send`] with the [`SyncSender`], the [`send`] method will return a\n+/// [`SendError`]. Similarly, If the [`SyncSender`] is disconnected while trying\n+/// to [`recv`], the [`recv`] method will return a [`RecvError`].\n ///\n-/// [`send`]: ../../../std/sync/mpsc/struct.SyncSender.html#method.send\n-/// [`SyncSender`]: ../../../std/sync/mpsc/struct.SyncSender.html\n-/// [`Receiver`]: ../../../std/sync/mpsc/struct.Receiver.html\n+/// [`channel`]: fn.channel.html\n+/// [`send`]: struct.SyncSender.html#method.send\n+/// [`recv`]: struct.Receiver.html#method.recv\n+/// [`SyncSender`]: struct.SyncSender.html\n+/// [`Receiver`]: struct.Receiver.html\n+/// [`SendError`]: struct.SendError.html\n+/// [`RecvError`]: struct.RecvError.html\n ///\n /// # Examples\n ///\n /// ```\n /// use std::sync::mpsc::sync_channel;\n /// use std::thread;\n ///\n-/// let (tx, rx) = sync_channel(1);\n+/// let (sender, receiver) = sync_channel(1);\n ///\n /// // this returns immediately\n-/// tx.send(1).unwrap();\n+/// sender.send(1).unwrap();\n ///\n /// thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n-///     tx.send(2).unwrap();\n+///     sender.send(2).unwrap();\n /// });\n ///\n-/// assert_eq!(rx.recv().unwrap(), 1);\n-/// assert_eq!(rx.recv().unwrap(), 2);\n+/// assert_eq!(receiver.recv().unwrap(), 1);\n+/// assert_eq!(receiver.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sync_channel<T>(bound: usize) -> (SyncSender<T>, Receiver<T>) {"}, {"sha": "0127a9eb7596944cafc2bd0457eca9b8e24f6084", "filename": "src/libstd/sys_common/poison.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/28a232a59ac4ded4e6de9e9c06a17a801c5199dd/src%2Flibstd%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a232a59ac4ded4e6de9e9c06a17a801c5199dd/src%2Flibstd%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fpoison.rs?ref=28a232a59ac4ded4e6de9e9c06a17a801c5199dd", "patch": "@@ -73,7 +73,9 @@ pub struct PoisonError<T> {\n }\n \n /// An enumeration of possible errors which can occur while calling the\n-/// `try_lock` method.\n+/// [`try_lock`] method.\n+///\n+/// [`try_lock`]: struct.Mutex.html#method.try_lock\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another thread failed while holding"}]}