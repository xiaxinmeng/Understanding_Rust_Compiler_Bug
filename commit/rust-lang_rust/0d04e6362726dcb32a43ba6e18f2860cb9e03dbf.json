{"sha": "0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "node_id": "C_kwDOAAsO6NoAKDBkMDRlNjM2MjcyNmRjYjMyYTQzYmE2ZTE4ZjI4NjBjYjllMDNkYmY", "commit": {"author": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-25T12:07:07Z"}, "committer": {"name": "Amos Wenger", "email": "amoswenger@gmail.com", "date": "2022-07-25T12:07:07Z"}, "message": "Merge remote-tracking branch 'origin/master' into sync-from-rust-2", "tree": {"sha": "3def770a0eab519616bc5d1bf77e3be6e6ac7b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3def770a0eab519616bc5d1bf77e3be6e6ac7b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "html_url": "https://github.com/rust-lang/rust/commit/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/comments", "author": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fasterthanlime", "id": 7998310, "node_id": "MDQ6VXNlcjc5OTgzMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/7998310?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fasterthanlime", "html_url": "https://github.com/fasterthanlime", "followers_url": "https://api.github.com/users/fasterthanlime/followers", "following_url": "https://api.github.com/users/fasterthanlime/following{/other_user}", "gists_url": "https://api.github.com/users/fasterthanlime/gists{/gist_id}", "starred_url": "https://api.github.com/users/fasterthanlime/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fasterthanlime/subscriptions", "organizations_url": "https://api.github.com/users/fasterthanlime/orgs", "repos_url": "https://api.github.com/users/fasterthanlime/repos", "events_url": "https://api.github.com/users/fasterthanlime/events{/privacy}", "received_events_url": "https://api.github.com/users/fasterthanlime/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfe84494c142356a53f12279698f7bfc3b056481", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfe84494c142356a53f12279698f7bfc3b056481", "html_url": "https://github.com/rust-lang/rust/commit/dfe84494c142356a53f12279698f7bfc3b056481"}, {"sha": "ac86b8edffcfd8076436c4154ec0236a91cc3c62", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac86b8edffcfd8076436c4154ec0236a91cc3c62", "html_url": "https://github.com/rust-lang/rust/commit/ac86b8edffcfd8076436c4154ec0236a91cc3c62"}], "stats": {"total": 233, "additions": 169, "deletions": 64}, "files": [{"sha": "66f9c24e8724a77e10d73a0f55df2367ebb1e116", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -96,6 +96,7 @@ pub(super) fn lower(\n         expander,\n         name_to_pat_grouping: Default::default(),\n         is_lowering_inside_or_pat: false,\n+        is_lowering_assignee_expr: false,\n     }\n     .collect(params, body)\n }\n@@ -109,6 +110,7 @@ struct ExprCollector<'a> {\n     // a poor-mans union-find?\n     name_to_pat_grouping: FxHashMap<Name, Vec<PatId>>,\n     is_lowering_inside_or_pat: bool,\n+    is_lowering_assignee_expr: bool,\n }\n \n impl ExprCollector<'_> {\n@@ -283,7 +285,10 @@ impl ExprCollector<'_> {\n                 } else {\n                     Box::default()\n                 };\n-                self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Call { callee, args, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.receiver());\n@@ -359,6 +364,7 @@ impl ExprCollector<'_> {\n             ast::Expr::RecordExpr(e) => {\n                 let path =\n                     e.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n+                let is_assignee_expr = self.is_lowering_assignee_expr;\n                 let record_lit = if let Some(nfl) = e.record_expr_field_list() {\n                     let fields = nfl\n                         .fields()\n@@ -378,9 +384,16 @@ impl ExprCollector<'_> {\n                         })\n                         .collect();\n                     let spread = nfl.spread().map(|s| self.collect_expr(s));\n-                    Expr::RecordLit { path, fields, spread }\n+                    let ellipsis = nfl.dotdot_token().is_some();\n+                    Expr::RecordLit { path, fields, spread, ellipsis, is_assignee_expr }\n                 } else {\n-                    Expr::RecordLit { path, fields: Box::default(), spread: None }\n+                    Expr::RecordLit {\n+                        path,\n+                        fields: Box::default(),\n+                        spread: None,\n+                        ellipsis: false,\n+                        is_assignee_expr,\n+                    }\n                 };\n \n                 self.alloc_expr(record_lit, syntax_ptr)\n@@ -458,14 +471,21 @@ impl ExprCollector<'_> {\n                 )\n             }\n             ast::Expr::BinExpr(e) => {\n+                let op = e.op_kind();\n+                if let Some(ast::BinaryOp::Assignment { op: None }) = op {\n+                    self.is_lowering_assignee_expr = true;\n+                }\n                 let lhs = self.collect_expr_opt(e.lhs());\n+                self.is_lowering_assignee_expr = false;\n                 let rhs = self.collect_expr_opt(e.rhs());\n-                let op = e.op_kind();\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n                 let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n-                self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n+                self.alloc_expr(\n+                    Expr::Tuple { exprs, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    syntax_ptr,\n+                )\n             }\n             ast::Expr::BoxExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -477,8 +497,14 @@ impl ExprCollector<'_> {\n \n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n-                        let exprs = e.map(|expr| self.collect_expr(expr)).collect();\n-                        self.alloc_expr(Expr::Array(Array::ElementList(exprs)), syntax_ptr)\n+                        let elements = e.map(|expr| self.collect_expr(expr)).collect();\n+                        self.alloc_expr(\n+                            Expr::Array(Array::ElementList {\n+                                elements,\n+                                is_assignee_expr: self.is_lowering_assignee_expr,\n+                            }),\n+                            syntax_ptr,\n+                        )\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);"}, {"sha": "c1b3788acb7d36d97a53272df8228458b139270e", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -110,6 +110,7 @@ pub enum Expr {\n     Call {\n         callee: ExprId,\n         args: Box<[ExprId]>,\n+        is_assignee_expr: bool,\n     },\n     MethodCall {\n         receiver: ExprId,\n@@ -138,6 +139,8 @@ pub enum Expr {\n         path: Option<Box<Path>>,\n         fields: Box<[RecordLitField]>,\n         spread: Option<ExprId>,\n+        ellipsis: bool,\n+        is_assignee_expr: bool,\n     },\n     Field {\n         expr: ExprId,\n@@ -196,6 +199,7 @@ pub enum Expr {\n     },\n     Tuple {\n         exprs: Box<[ExprId]>,\n+        is_assignee_expr: bool,\n     },\n     Unsafe {\n         body: ExprId,\n@@ -211,7 +215,7 @@ pub enum Expr {\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n-    ElementList(Box<[ExprId]>),\n+    ElementList { elements: Box<[ExprId]>, is_assignee_expr: bool },\n     Repeat { initializer: ExprId, repeat: ExprId },\n }\n \n@@ -285,7 +289,7 @@ impl Expr {\n                 f(*iterable);\n                 f(*body);\n             }\n-            Expr::Call { callee, args } => {\n+            Expr::Call { callee, args, .. } => {\n                 f(*callee);\n                 args.iter().copied().for_each(f);\n             }\n@@ -339,9 +343,9 @@ impl Expr {\n             | Expr::Box { expr } => {\n                 f(*expr);\n             }\n-            Expr::Tuple { exprs } => exprs.iter().copied().for_each(f),\n+            Expr::Tuple { exprs, .. } => exprs.iter().copied().for_each(f),\n             Expr::Array(a) => match a {\n-                Array::ElementList(exprs) => exprs.iter().copied().for_each(f),\n+                Array::ElementList { elements, .. } => elements.iter().copied().for_each(f),\n                 Array::Repeat { initializer, repeat } => {\n                     f(*initializer);\n                     f(*repeat)"}, {"sha": "642e03edd230636ca3911a0e0eee44dc8989a41e", "filename": "crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -305,7 +305,10 @@ pub fn record_literal_missing_fields(\n     expr: &Expr,\n ) -> Option<(VariantId, Vec<LocalFieldId>, /*exhaustive*/ bool)> {\n     let (fields, exhaustive) = match expr {\n-        Expr::RecordLit { path: _, fields, spread } => (fields, spread.is_none()),\n+        Expr::RecordLit { fields, spread, ellipsis, is_assignee_expr, .. } => {\n+            let exhaustive = if *is_assignee_expr { !*ellipsis } else { spread.is_none() };\n+            (fields, exhaustive)\n+        }\n         _ => return None,\n     };\n "}, {"sha": "d164e64a8be0780a0d9b5d54008b648e46b89c18", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -276,7 +276,7 @@ impl<'a> InferenceContext<'a> {\n \n                 closure_ty\n             }\n-            Expr::Call { callee, args } => {\n+            Expr::Call { callee, args, .. } => {\n                 let callee_ty = self.infer_expr(*callee, &Expectation::none());\n                 let mut derefs = Autoderef::new(&mut self.table, callee_ty.clone());\n                 let mut res = None;\n@@ -421,7 +421,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 TyKind::Never.intern(Interner)\n             }\n-            Expr::RecordLit { path, fields, spread } => {\n+            Expr::RecordLit { path, fields, spread, .. } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_deref(), false);\n                 if let Some(variant) = def_id {\n                     self.write_variant_resolution(tgt_expr.into(), variant);\n@@ -693,7 +693,7 @@ impl<'a> InferenceContext<'a> {\n                     self.err_ty()\n                 }\n             }\n-            Expr::Tuple { exprs } => {\n+            Expr::Tuple { exprs, .. } => {\n                 let mut tys = match expected\n                     .only_has_type(&mut self.table)\n                     .as_ref()\n@@ -724,12 +724,12 @@ impl<'a> InferenceContext<'a> {\n \n                 let expected = Expectation::has_type(elem_ty.clone());\n                 let len = match array {\n-                    Array::ElementList(items) => {\n-                        for &expr in items.iter() {\n+                    Array::ElementList { elements, .. } => {\n+                        for &expr in elements.iter() {\n                             let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n                             coerce.coerce(self, Some(expr), &cur_elem_ty);\n                         }\n-                        consteval::usize_const(Some(items.len() as u128))\n+                        consteval::usize_const(Some(elements.len() as u128))\n                     }\n                     &Array::Repeat { initializer, repeat } => {\n                         self.infer_expr_coerce(initializer, &Expectation::has_type(elem_ty));\n@@ -850,15 +850,15 @@ impl<'a> InferenceContext<'a> {\n         let rhs_ty = self.resolve_ty_shallow(rhs_ty);\n \n         let ty = match &self.body[lhs] {\n-            Expr::Tuple { exprs } => {\n+            Expr::Tuple { exprs, .. } => {\n                 // We don't consider multiple ellipses. This is analogous to\n                 // `hir_def::body::lower::ExprCollector::collect_tuple_pat()`.\n                 let ellipsis = exprs.iter().position(|e| is_rest_expr(*e));\n                 let exprs: Vec<_> = exprs.iter().filter(|e| !is_rest_expr(**e)).copied().collect();\n \n                 self.infer_tuple_pat_like(&rhs_ty, (), ellipsis, &exprs)\n             }\n-            Expr::Call { callee, args } => {\n+            Expr::Call { callee, args, .. } => {\n                 // Tuple structs\n                 let path = match &self.body[*callee] {\n                     Expr::Path(path) => Some(path),\n@@ -872,7 +872,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.infer_tuple_struct_pat_like(path, &rhs_ty, (), lhs, ellipsis, &args)\n             }\n-            Expr::Array(Array::ElementList(elements)) => {\n+            Expr::Array(Array::ElementList { elements, .. }) => {\n                 let elem_ty = match rhs_ty.kind(Interner) {\n                     TyKind::Array(st, _) => st.clone(),\n                     _ => self.err_ty(),"}, {"sha": "c808c010c672eac67d9d397eaf20fa5332d7fee7", "filename": "crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -145,13 +145,16 @@ fn add_missing_impl_members_inner(\n             Some(cap) => {\n                 let mut cursor = Cursor::Before(first_new_item.syntax());\n                 let placeholder;\n-                if let ast::AssocItem::Fn(func) = &first_new_item {\n-                    if try_gen_trait_body(ctx, func, &trait_, &impl_def).is_none() {\n-                        if let Some(m) = func.syntax().descendants().find_map(ast::MacroCall::cast)\n-                        {\n-                            if m.syntax().text() == \"todo!()\" {\n-                                placeholder = m;\n-                                cursor = Cursor::Replace(placeholder.syntax());\n+                if let DefaultMethods::No = mode {\n+                    if let ast::AssocItem::Fn(func) = &first_new_item {\n+                        if try_gen_trait_body(ctx, func, &trait_, &impl_def).is_none() {\n+                            if let Some(m) =\n+                                func.syntax().descendants().find_map(ast::MacroCall::cast)\n+                            {\n+                                if m.syntax().text() == \"todo!()\" {\n+                                    placeholder = m;\n+                                    cursor = Cursor::Replace(placeholder.syntax());\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "7a0c912959a12c53b9b909225accc56e866d3ca5", "filename": "crates/ide-assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -5,7 +5,7 @@ use syntax::{\n     ted,\n };\n \n-/// Generate custom trait bodies where possible.\n+/// Generate custom trait bodies without default implementation where possible.\n ///\n /// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n /// `None` means that generating a custom trait body failed, and the body will remain\n@@ -28,6 +28,7 @@ pub(crate) fn gen_trait_fn_body(\n \n /// Generate a `Clone` impl based on the fields and members of the target type.\n fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    stdx::always!(func.name().map_or(false, |name| name.text() == \"clone\"));\n     fn gen_clone_call(target: ast::Expr) -> ast::Expr {\n         let method = make::name_ref(\"clone\");\n         make::expr_method_call(target, method, make::arg_list(None))\n@@ -339,6 +340,7 @@ fn gen_default_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n /// Generate a `Hash` impl based on the fields and members of the target type.\n fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    stdx::always!(func.name().map_or(false, |name| name.text() == \"hash\"));\n     fn gen_hash_call(target: ast::Expr) -> ast::Stmt {\n         let method = make::name_ref(\"hash\");\n         let arg = make::expr_path(make::ext::ident_path(\"state\"));\n@@ -394,9 +396,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n \n /// Generate a `PartialEq` impl based on the fields and members of the target type.\n fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n-    if func.name().map_or(false, |name| name.text() == \"ne\") {\n-        return None;\n-    }\n+    stdx::always!(func.name().map_or(false, |name| name.text() == \"eq\"));\n     fn gen_eq_chain(expr: Option<ast::Expr>, cmp: ast::Expr) -> Option<ast::Expr> {\n         match expr {\n             Some(expr) => Some(make::expr_bin_op(expr, BinaryOp::LogicOp(LogicOp::And), cmp)),\n@@ -573,6 +573,7 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n }\n \n fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    stdx::always!(func.name().map_or(false, |name| name.text() == \"partial_cmp\"));\n     fn gen_partial_eq_match(match_target: ast::Expr) -> Option<ast::Stmt> {\n         let mut arms = vec![];\n \n@@ -643,7 +644,7 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(stmts.into_iter(), tail).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // No fields in the body means there's nothing to hash.\n+            // No fields in the body means there's nothing to compare.\n             None => {\n                 let expr = make::expr_literal(\"true\").into();\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))"}, {"sha": "9b25964a6086e704e0c4ca5ef5676cf1f985127c", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 37, "deletions": 3, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -121,7 +121,7 @@ pub(crate) fn render_field(\n     let mut item = CompletionItem::new(\n         SymbolKind::Field,\n         ctx.source_range(),\n-        receiver.map_or_else(|| name.clone(), |receiver| format!(\"{}.{}\", receiver, name).into()),\n+        field_with_receiver(receiver.as_ref(), &name),\n     );\n     item.set_relevance(CompletionRelevance {\n         type_match: compute_type_match(ctx.completion, ty),\n@@ -132,7 +132,7 @@ pub(crate) fn render_field(\n         .set_documentation(field.docs(ctx.db()))\n         .set_deprecated(is_deprecated)\n         .lookup_by(name.clone());\n-    item.insert_text(escaped_name);\n+    item.insert_text(field_with_receiver(receiver.as_ref(), &escaped_name));\n     if let Some(receiver) = &dot_access.receiver {\n         if let Some(original) = ctx.completion.sema.original_ast_node(receiver.clone()) {\n             if let Some(ref_match) = compute_ref_match(ctx.completion, ty) {\n@@ -143,6 +143,11 @@ pub(crate) fn render_field(\n     item.build()\n }\n \n+fn field_with_receiver(receiver: Option<&hir::Name>, field_name: &str) -> SmolStr {\n+    receiver\n+        .map_or_else(|| field_name.into(), |receiver| format!(\"{}.{}\", receiver, field_name).into())\n+}\n+\n pub(crate) fn render_tuple_field(\n     ctx: RenderContext<'_>,\n     receiver: Option<hir::Name>,\n@@ -152,7 +157,7 @@ pub(crate) fn render_tuple_field(\n     let mut item = CompletionItem::new(\n         SymbolKind::Field,\n         ctx.source_range(),\n-        receiver.map_or_else(|| field.to_string(), |receiver| format!(\"{}.{}\", receiver, field)),\n+        field_with_receiver(receiver.as_ref(), &field.to_string()),\n     );\n     item.detail(ty.display(ctx.db()).to_string()).lookup_by(field.to_string());\n     item.build()\n@@ -1873,6 +1878,35 @@ impl r#trait for r#struct { type t$0 }\n struct r#struct {}\n trait r#trait { type r#type; }\n impl r#trait for r#struct { type r#type = $0; }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn field_access_includes_self() {\n+        check_edit(\n+            \"length\",\n+            r#\"\n+struct S {\n+    length: i32\n+}\n+\n+impl S {\n+    fn some_fn(&self) {\n+        let l = len$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S {\n+    length: i32\n+}\n+\n+impl S {\n+    fn some_fn(&self) {\n+        let l = self.length\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "edb1fc0919c242c9f83dc921a488f5b76813e3a4", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -292,6 +292,37 @@ fn x(a: S) {\n         )\n     }\n \n+    #[test]\n+    fn missing_record_expr_in_assignee_expr() {\n+        check_diagnostics(\n+            r\"\n+struct S { s: usize, t: usize }\n+struct S2 { s: S, t: () }\n+struct T(S);\n+fn regular(a: S) {\n+    let s;\n+    S { s, .. } = a;\n+}\n+fn nested(a: S2) {\n+    let s;\n+    S2 { s: S { s, .. }, .. } = a;\n+}\n+fn in_tuple(a: (S,)) {\n+    let s;\n+    (S { s, .. },) = a;\n+}\n+fn in_array(a: [S;1]) {\n+    let s;\n+    [S { s, .. },] = a;\n+}\n+fn in_tuple_struct(a: T) {\n+    let s;\n+    T(S { s, .. }) = a;\n+}\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn range_mapping_out_of_macros() {\n         check_fix("}, {"sha": "0ada4b73e842d9d7f814bf71f74c9dc4441158c3", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -60,9 +60,9 @@ pub fn load_workspace(\n \n     let proc_macro_client = if load_config.with_proc_macro {\n         let path = AbsPathBuf::assert(std::env::current_exe()?);\n-        Some(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n+        Ok(ProcMacroServer::spawn(path, &[\"proc-macro\"]).unwrap())\n     } else {\n-        None\n+        Err(\"proc macro server not started\".to_owned())\n     };\n \n     let crate_graph = ws.to_crate_graph(\n@@ -89,7 +89,7 @@ pub fn load_workspace(\n     if load_config.prefill_caches {\n         host.analysis().parallel_prime_caches(1, |_| {})?;\n     }\n-    Ok((host, vfs, proc_macro_client))\n+    Ok((host, vfs, proc_macro_client.ok()))\n }\n \n fn load_crate_graph("}, {"sha": "8f881cba4dbd7b113534e3cfdf1d6aa85bf95d27", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -61,7 +61,7 @@ pub(crate) struct GlobalState {\n     pub(crate) proc_macro_changed: bool,\n     pub(crate) last_reported_status: Option<lsp_ext::ServerStatusParams>,\n     pub(crate) source_root_config: SourceRootConfig,\n-    pub(crate) proc_macro_client: Option<ProcMacroServer>,\n+    pub(crate) proc_macro_clients: Vec<Result<ProcMacroServer, String>>,\n \n     pub(crate) flycheck: Vec<FlycheckHandle>,\n     pub(crate) flycheck_sender: Sender<flycheck::Message>,\n@@ -151,7 +151,7 @@ impl GlobalState {\n             proc_macro_changed: false,\n             last_reported_status: None,\n             source_root_config: SourceRootConfig::default(),\n-            proc_macro_client: None,\n+            proc_macro_clients: vec![],\n \n             flycheck: Vec::new(),\n             flycheck_sender,"}, {"sha": "deb777c952fdf7d7658f92b77b8d50f68244499c", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -44,7 +44,7 @@ use crate::{\n };\n \n pub(crate) fn handle_workspace_reload(state: &mut GlobalState, _: ()) -> Result<()> {\n-    state.proc_macro_client = None;\n+    state.proc_macro_clients.clear();\n     state.proc_macro_changed = false;\n     state.fetch_workspaces_queue.request_op(\"reload workspace request\".to_string());\n     state.fetch_build_data_queue.request_op(\"reload workspace request\".to_string());"}, {"sha": "e5802773e74739168bc7b68e94a0d6cd2ba9daa6", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d04e6362726dcb32a43ba6e18f2860cb9e03dbf/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=0d04e6362726dcb32a43ba6e18f2860cb9e03dbf", "patch": "@@ -303,18 +303,21 @@ impl GlobalState {\n         let files_config = self.config.files();\n         let project_folders = ProjectFolders::new(&self.workspaces, &files_config.exclude);\n \n-        if self.proc_macro_client.is_none() {\n+        if self.proc_macro_clients.is_empty() {\n             if let Some((path, args)) = self.config.proc_macro_srv() {\n-                match ProcMacroServer::spawn(path.clone(), args) {\n-                    Ok(it) => self.proc_macro_client = Some(it),\n-                    Err(err) => {\n-                        tracing::error!(\n-                            \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n-                            path.display(),\n-                            err\n-                        );\n-                    }\n-                }\n+                self.proc_macro_clients = (0..self.workspaces.len())\n+                    .map(|_| {\n+                        ProcMacroServer::spawn(path.clone(), args.clone()).map_err(|err| {\n+                            let error = format!(\n+                                \"Failed to run proc_macro_srv from path {}, error: {:?}\",\n+                                path.display(),\n+                                err\n+                            );\n+                            tracing::error!(error);\n+                            error\n+                        })\n+                    })\n+                    .collect();\n             }\n         }\n \n@@ -331,15 +334,7 @@ impl GlobalState {\n \n         // Create crate graph from all the workspaces\n         let crate_graph = {\n-            let proc_macro_client = self.proc_macro_client.as_ref();\n             let dummy_replacements = self.config.dummy_replacements();\n-            let mut load_proc_macro = move |crate_name: &str, path: &AbsPath| {\n-                load_proc_macro(\n-                    proc_macro_client,\n-                    path,\n-                    dummy_replacements.get(crate_name).map(|v| &**v).unwrap_or_default(),\n-                )\n-            };\n \n             let vfs = &mut self.vfs.write().0;\n             let loader = &mut self.loader;\n@@ -359,7 +354,15 @@ impl GlobalState {\n             };\n \n             let mut crate_graph = CrateGraph::default();\n-            for ws in self.workspaces.iter() {\n+            for (idx, ws) in self.workspaces.iter().enumerate() {\n+                let proc_macro_client = self.proc_macro_clients[idx].as_ref();\n+                let mut load_proc_macro = move |crate_name: &str, path: &AbsPath| {\n+                    load_proc_macro(\n+                        proc_macro_client,\n+                        path,\n+                        dummy_replacements.get(crate_name).map(|v| &**v).unwrap_or_default(),\n+                    )\n+                };\n                 crate_graph.extend(ws.to_crate_graph(&mut load_proc_macro, &mut load));\n             }\n             crate_graph\n@@ -536,14 +539,14 @@ impl SourceRootConfig {\n /// Load the proc-macros for the given lib path, replacing all expanders whose names are in `dummy_replace`\n /// with an identity dummy expander.\n pub(crate) fn load_proc_macro(\n-    server: Option<&ProcMacroServer>,\n+    server: Result<&ProcMacroServer, &String>,\n     path: &AbsPath,\n     dummy_replace: &[Box<str>],\n ) -> ProcMacroLoadResult {\n     let res: Result<Vec<_>, String> = (|| {\n         let dylib = MacroDylib::new(path.to_path_buf())\n             .map_err(|io| format!(\"Proc-macro dylib loading failed: {io}\"))?;\n-        let server = server.ok_or_else(|| format!(\"Proc-macro server not started\"))?;\n+        let server = server.map_err(ToOwned::to_owned)?;\n         let vec = server.load_dylib(dylib).map_err(|e| format!(\"{e}\"))?;\n         if vec.is_empty() {\n             return Err(\"proc macro library returned no proc macros\".to_string());"}]}